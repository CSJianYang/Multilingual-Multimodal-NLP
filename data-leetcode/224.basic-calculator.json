[
    {
        "title": "Swap Nodes in Pairs",
        "question_content": "Given a&nbsp;linked list, swap every two adjacent nodes and return its head. You must solve the problem without&nbsp;modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n&nbsp;\nExample 1:\n\nInput: head = [1,2,3,4]\nOutput: [2,1,4,3]\n\nExample 2:\n\nInput: head = []\nOutput: []\n\nExample 3:\n\nInput: head = [1]\nOutput: [1]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the&nbsp;list&nbsp;is in the range [0, 100].\n\t0 <= Node.val <= 100",
        "solutions": [
            {
                "id": 1775033,
                "title": "swapping-nodes-not-just-the-values-visual-explanation-well-explained-c",
                "content": "As mentioned in the question we have to **exchange the nodes itself (and not just their values)**, and this solution follows this constraint.\\n\\nI will be placing a `dummy node` before the head node so that the code we write can also be applicable to the head node also, and we don\\'t have to specifically write different conditions for the head node.\\n\\n#### Example:\\n***Given Linked List***\\n\\n![image](https://assets.leetcode.com/users/images/d4219c57-0fa8-4d02-8c75-e437d1613be0_1644993781.493073.jpeg)\\n\\n ***Final Linked List***\\n\\n![image](https://assets.leetcode.com/users/images/88cece9e-8fff-4f5f-807f-dcabecebe71e_1644993901.1494746.jpeg)\\n\\n\\nLet\\'s now understand the **approach**\\n\\n1. As mentioned earlier, we will place a `dummyNode` before the head node.\\n\\n![image](https://assets.leetcode.com/users/images/b06f77f0-507a-42ac-af35-04ebbd4a71b0_1644993113.5176115.jpeg)\\n\\n\\n2. Now, let the head be our `currNode`. That means the `node with value 1` is the currNode, and we have to swap it with the `node with value 2`. So for this, we will also have to keep track of the node previous to the currNode, let it be `prevNode`, as it\\'s next pointer value will have to change after we swap the currNode and the node next to currNode.\\n\\n![image](https://assets.leetcode.com/users/images/00a5d82c-ce1f-4d73-afb2-0ce20d23fb26_1644993239.638449.jpeg)\\n\\n3. Now the very first thing to do is change the `next pointer of prevNode to point to currNode->next`. Why?? Because in the answer we want the `node with value 2` after the dummyNode. Right? So we will have to connect `dummyNode` (prevNode) to the `node with value  2` (currNode->next). This means\\n```cpp\\nprevNode->next = currNode->next\\n```\\n\\n![image](https://assets.leetcode.com/users/images/5a4ce313-4f60-48f4-857d-ca141e48c103_1644993309.3371558.jpeg)\\n\\n\\n4. Now, in our finl answer `node with value 1` should be at the place of `node with value 2`. So the next pointer of `node with value 1` should point to whatever the `node with value 2` is pointing to originally. That means we will have to change `currNode->next` to the `next of next of prevNode`, as currently prevNode is dummyNode, prevNode->next is node with value 2 and prevNode->next->next = next of node with value 2. This means\\n```cpp\\ncurrNode->next = prevNode->next->next\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e531a190-a0cd-4117-ab66-4c5ed08047d9_1644993389.8530746.jpeg)\\n\\n\\n5. Now, as in the answer the `node with value 2` should point to `node with value 1`. That means\\n```cpp\\nprevNode->next->next = currNode\\n```\\n\\n![image](https://assets.leetcode.com/users/images/11fda637-3c1c-4f41-82a5-598f41540429_1644993447.1567922.jpeg)\\n\\n\\n6. After this iteration, nodes 1 and 2 will get swapped and our linked list will look like this.\\n\\n![image](https://assets.leetcode.com/users/images/eba94308-ed4a-4542-aed6-ef8f4eb1f807_1644993522.337313.jpeg)\\n\\n\\n7. Now for the next iteration, we have to swap `nodes with values 3 and 4`. For that the `prevNode` should point to `node with value 1` and the `currNode` should point to `node with value 3`. This means\\n```cpp\\nprevNode = currNode\\ncurrNode = currNode->next\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e73873b6-a236-4171-ac89-52f0c5d63164_1645010559.588748.jpeg)\\n\\n\\n\\n\\n8. We should stop this procedure when either there is no nodes left to swap or there is only one node left which cannot be swapped with any node.\\n\\n9. At the end, as we can see that our head of the list has been misplaced in the procedure of swapping, so we can return `dummyNode->next` to return the swapped linked list.\\n\\n\\n#### Code\\n```cpp\\nListNode* swapPairs(ListNode* head) {\\n        if(!head || !head->next) return head; //If there are less than 2 nodes in the given nodes, then no need to do anything just return the list as it is.\\n\\t\\t\\n        ListNode* dummyNode = new ListNode();\\n        \\n        ListNode* prevNode=dummyNode;\\n        ListNode* currNode=head;\\n        \\n        while(currNode && currNode->next){\\n            prevNode->next = currNode->next;\\n            currNode->next = prevNode->next->next;\\n            prevNode->next->next = currNode;\\n            \\n            prevNode = currNode;\\n            currNode = currNode->next;\\n        }\\n        \\n        return dummyNode->next;\\n    }\\n\\n```\\n\\n#### Complexity:\\n***TC*** **= O(n)**\\n***SC*** **= O(1)**\\n\\n***Plz upvote if you liked the post***\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```cpp\\nprevNode->next = currNode->next\\n```\n```cpp\\ncurrNode->next = prevNode->next->next\\n```\n```cpp\\nprevNode->next->next = currNode\\n```\n```cpp\\nprevNode = currNode\\ncurrNode = currNode->next\\n```\n```cpp\\nListNode* swapPairs(ListNode* head) {\\n        if(!head || !head->next) return head; //If there are less than 2 nodes in the given nodes, then no need to do anything just return the list as it is.\\n\\t\\t\\n        ListNode* dummyNode = new ListNode();\\n        \\n        ListNode* prevNode=dummyNode;\\n        ListNode* currNode=head;\\n        \\n        while(currNode && currNode->next){\\n            prevNode->next = currNode->next;\\n            currNode->next = prevNode->next->next;\\n            prevNode->next->next = currNode;\\n            \\n            prevNode = currNode;\\n            currNode = currNode->next;\\n        }\\n        \\n        return dummyNode->next;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1774708,
                "title": "c-visual-image-how-links-change-explained-every-step-commented-code",
                "content": "***Brief note about Question-***\\n* We have to *swap every two adjacent nodes and return its head*.\\n```\\nLet\\'s take an example not given in question -\\nSuppose our head pointer given to us as [1,9,2,8,3,7]\\n\\nSo, we have to swap every two adjcant nodes,\\nthe answer should be [9,1,8,2,7,3]\\n```\\n_______________\\n***Solution - I (using recursion, Accepted)-***\\n* The very basic thing that is given to us is, **it is given in form of linked list**.\\n* We have a advantage by having linked list, How?\\n* For swapping every two adjcant nodes, we will be able to just change the link of nodes.\\n* See how we change links on the first example.\\n![image](https://assets.leetcode.com/users/images/53a7a769-ce39-4d7d-9e37-cd0420f72bf0_1644988593.5987253.jpeg)\\n\\n\\n* I have mention everything in image itself, and also add comment in code also, but if u have still doubt or suggestion,please put that in comment part.\\n ____________\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // if head is NULL OR just having a single node, then no need to change anything \\n        if(head == NULL || head -> next == NULL) \\n        {\\n            return head;\\n        }\\n            \\n        ListNode* temp; // temporary pointer to store head -> next\\n        temp = head->next; // give temp what he want\\n        \\n        head->next = swapPairs(head->next->next); // changing links\\n        temp->next = head; // put temp -> next to head\\n        \\n        return temp; // now after changing links, temp act as our head\\n    }\\n};\\n```\\n***`If u find this useful , please consider to give a upvote!!`***\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nLet\\'s take an example not given in question -\\nSuppose our head pointer given to us as [1,9,2,8,3,7]\\n\\nSo, we have to swap every two adjcant nodes,\\nthe answer should be [9,1,8,2,7,3]\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // if head is NULL OR just having a single node, then no need to change anything \\n        if(head == NULL || head -> next == NULL) \\n        {\\n            return head;\\n        }\\n            \\n        ListNode* temp; // temporary pointer to store head -> next\\n        temp = head->next; // give temp what he want\\n        \\n        head->next = swapPairs(head->next->next); // changing links\\n        temp->next = head; // put temp -> next to head\\n        \\n        return temp; // now after changing links, temp act as our head\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774318,
                "title": "python3-i-hate-linked-lists-not-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38-_-\\'), If you have any question, feel free to ask.**\\n\\nJust a bunch of placeholders, edge cases, and strange errors about a cycle meanwhile :(\\n\\nprev cur cur porev next cur prev pasdfaslfjgnzdsf;ljgfsdaz;lkjkfgn\\n\\nTime: **O(n)** - iterate\\nSpace: **O(1)**\\n\\n```\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tif not head: return head\\n\\n\\tprev, cur, ans = None, head, head.next\\n\\twhile cur and cur.next:\\n\\t\\tadj = cur.next\\n\\t\\tif prev: prev.next = adj\\n\\n\\t\\tcur.next, adj.next = adj.next, cur\\n\\t\\tprev, cur = cur, cur.next\\n\\n\\treturn ans or head\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38-_-\\'), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tif not head: return head\\n\\n\\tprev, cur, ans = None, head, head.next\\n\\twhile cur and cur.next:\\n\\t\\tadj = cur.next\\n\\t\\tif prev: prev.next = adj\\n\\n\\t\\tcur.next, adj.next = adj.next, cur\\n\\t\\tprev, cur = cur, cur.next\\n\\n\\treturn ans or head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 11030,
                "title": "my-accepted-java-code-used-recursion",
                "content": "    public class Solution {\\n        public ListNode swapPairs(ListNode head) {\\n            if ((head == null)||(head.next == null))\\n                return head;\\n            ListNode n = head.next;\\n            head.next = swapPairs(head.next.next);\\n            n.next = head;\\n            return n;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public ListNode swapPairs(ListNode head) {\\n            if ((head == null)||(head.next == null))\\n                return head;\\n            ListNode n = head.next;\\n            head.next = swapPairs(head.next.next);\\n            n.next = head;\\n            return n;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 11019,
                "title": "7-8-lines-c-python-ruby",
                "content": "Three different implementations of the same algorithm, taking advantage of different strengths of the three languages. I suggest reading all three, even if you don't know all three languages.\\n\\nAll three of course work swap the current node with the next node by rearranging pointers, then move on to the next pair, and repeat until the end of the list.\\n\\n---\\n\\n**C++**\\n\\nPointer-pointer `pp`  points to the pointer to the current node. So at first, `pp` points to `head`, and later it points to the `next` field of ListNodes. Additionally, for convenience and clarity, pointers `a` and `b` point to the current node and the next node.\\n\\nWe need to go from `*pp == a -> b -> (b->next)` to `*pp == b -> a -> (b->next)`. The first three lines inside the loop do that, setting those three pointers (from right to left). The fourth line moves `pp` to the next pair.\\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode **pp = &head, *a, *b;\\n        while ((a = *pp) && (b = a->next)) {\\n            a->next = b->next;\\n            b->next = a;\\n            *pp = b;\\n            pp = &(a->next);\\n        }\\n        return head;\\n    }\\n\\n---\\n\\n**Python**\\n\\nHere, `pre` is the previous node. Since the head doesn't have a previous node, I just use `self` instead. Again, `a` is the current node and `b` is the next node.\\n\\nTo go from `pre -> a -> b -> b.next` to `pre -> b -> a -> b.next`, we need to change those three references. Instead of thinking about in what order I change them, I just change all three at once.\\n\\n    def swapPairs(self, head):\\n        pre, pre.next = self, head\\n        while pre.next and pre.next.next:\\n            a = pre.next\\n            b = a.next\\n            pre.next, b.next, a.next = b, a, b.next\\n            pre = a\\n        return self.next\\n\\n---\\n\\n**Ruby**\\n\\nAgain, `pre` is the previous node, but here I create a dummy as previous node of the head. And again, `a` is the current node and `b` is the next node. This time I go one node further and call it `c`.\\n\\nTo go from `pre -> a -> b -> c` to `pre -> b -> a -> c`, we need to change those three references. Here I chain the assignments, pretty much directly saying \"`pre` points to `b`, which points to `a`, which points to `c`\".\\n\\n    def swap_pairs(head)\\n        pre = dummy = ListNode.new 0\\n        pre.next = head\\n        while a = pre.next and b = a.next\\n            c = b.next\\n            ((pre.next = b).next = a).next = c\\n            pre = a\\n        end\\n        dummy.next\\n    end",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Ruby"
                ],
                "code": "Three different implementations of the same algorithm, taking advantage of different strengths of the three languages. I suggest reading all three, even if you don't know all three languages.\\n\\nAll three of course work swap the current node with the next node by rearranging pointers, then move on to the next pair, and repeat until the end of the list.\\n\\n---\\n\\n**C++**\\n\\nPointer-pointer `pp`  points to the pointer to the current node. So at first, `pp` points to `head`, and later it points to the `next` field of ListNodes. Additionally, for convenience and clarity, pointers `a` and `b` point to the current node and the next node.\\n\\nWe need to go from `*pp == a -> b -> (b->next)` to `*pp == b -> a -> (b->next)`. The first three lines inside the loop do that, setting those three pointers (from right to left). The fourth line moves `pp` to the next pair.\\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode **pp = &head, *a, *b;\\n        while ((a = *pp) && (b = a->next)) {\\n            a->next = b->next;\\n            b->next = a;\\n            *pp = b;\\n            pp = &(a->next);\\n        }\\n        return head;\\n    }\\n\\n---\\n\\n**Python**\\n\\nHere, `pre` is the previous node. Since the head doesn't have a previous node, I just use `self` instead. Again, `a` is the current node and `b` is the next node.\\n\\nTo go from `pre -> a -> b -> b.next` to `pre -> b -> a -> b.next`, we need to change those three references. Instead of thinking about in what order I change them, I just change all three at once.\\n\\n    def swapPairs(self, head):\\n        pre, pre.next = self, head\\n        while pre.next and pre.next.next:\\n            a = pre.next\\n            b = a.next\\n            pre.next, b.next, a.next = b, a, b.next\\n            pre = a\\n        return self.next\\n\\n---\\n\\n**Ruby**\\n\\nAgain, `pre` is the previous node, but here I create a dummy as previous node of the head. And again, `a` is the current node and `b` is the next node. This time I go one node further and call it `c`.\\n\\nTo go from `pre -> a -> b -> c` to `pre -> b -> a -> c`, we need to change those three references. Here I chain the assignments, pretty much directly saying \"`pre` points to `b`, which points to `a`, which points to `c`\".\\n\\n    def swap_pairs(head)\\n        pre = dummy = ListNode.new 0\\n        pre.next = head\\n        while a = pre.next and b = a.next\\n            c = b.next\\n            ((pre.next = b).next = a).next = c\\n            pre = a\\n        end\\n        dummy.next\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 11046,
                "title": "my-simple-java-solution-for-share",
                "content": "    public ListNode swapPairs(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode current = dummy;\\n        while (current.next != null && current.next.next != null) {\\n            ListNode first = current.next;\\n            ListNode second = current.next.next;\\n            first.next = second.next;\\n            current.next = second;\\n            current.next.next = first;\\n            current = current.next.next;\\n        }\\n        return dummy.next;\\n    }",
                "solutionTags": [],
                "code": "    public ListNode swapPairs(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode current = dummy;\\n        while (current.next != null && current.next.next != null) {\\n            ListNode first = current.next;\\n            ListNode second = current.next.next;\\n            first.next = second.next;\\n            current.next = second;\\n            current.next.next = first;\\n            current = current.next.next;\\n        }\\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 171788,
                "title": "python-dummynode",
                "content": "### 24. Swap Nodes in Pairs\\n\\n```python\\nclass Solution(object):\\n    def swapPairs(self, head):\\n        if not head or not head.next: return head\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        cur = dummy\\n        \\n        while cur.next and cur.next.next:\\n            first = cur.next\\n            sec = cur.next.next\\n            cur.next = sec\\n            first.next = sec.next\\n            sec.next = first\\n            cur = cur.next.next\\n        return dummy.next       \\n```\\n![](https://raw.githubusercontent.com/yuzhoujr/spazzatura/master/img_box/24.jpg)\\n\\n#### Recursive\\n```python\\nclass Solution(object):\\n    def swapPairs(self, head):\\n        if not head or not head.next: return head\\n        new_start = head.next.next\\n        head, head.next = head.next, head\\n        head.next.next = self.swapPairs(new_start)\\n        return head\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def swapPairs(self, head):\\n        if not head or not head.next: return head\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        cur = dummy\\n        \\n        while cur.next and cur.next.next:\\n            first = cur.next\\n            sec = cur.next.next\\n            cur.next = sec\\n            first.next = sec.next\\n            sec.next = first\\n            cur = cur.next.next\\n        return dummy.next       \\n```\n```python\\nclass Solution(object):\\n    def swapPairs(self, head):\\n        if not head or not head.next: return head\\n        new_start = head.next.next\\n        head, head.next = head.next, head\\n        head.next.next = self.swapPairs(new_start)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11271,
                "title": "simple-implementation-with-c",
                "content": "    class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            if(head == NULL)\\n                return NULL;\\n            if(head->next == NULL)\\n                return head;\\n            \\n            ListNode* next = head->next;\\n            head->next = swapPairs(next->next);\\n            next->next = head;\\n            \\n            return next;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            if(head == NULL)\\n                return NULL;\\n            if(head->next == NULL)\\n                return head;\\n            \\n            ListNode* next = head->next;\\n            head->next = swapPairs(next->next);\\n            next->next = head;\\n            \\n            return next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 11183,
                "title": "c-solution-with-graph-explanation",
                "content": "    /*\\n           #---->@---->@---->@---->@---->@---->@\\n                       ^     ^\\n                       pre   cur\\n\\n          1. pre->next = cur->next\\n                        __________\\n                       /          \\\\\\n           #---->@---->@     @---->@---->@---->@\\n                       ^     ^\\n                       pre   cur\\n\\n          2. pre = pre->next\\n                        __________\\n                       /          \\\\\\n          #---->@---->@      @---->@---->@---->@\\n                             ^     ^\\n                             cur   pre\\n\\n          3. cur->next = pre->next\\n                        __________\\n                       /          \\\\\\n           #---->@---->@     @     @---->@---->@\\n                              \\\\_________/\\n                             ^     ^\\n                             cur   pre\\n\\n          4. pre->next = cur\\n                       __________\\n                      /          \\\\\\n          #---->@---->@     @<----@     @---->@\\n                             \\\\_________/\\n                            ^     ^\\n                            cur   pre\\n        \\n          5. pre = cur; cur = cur->next\\n                       __________\\n                      /          \\\\\\n          #---->@---->@     @<----@     @---->@\\n                             \\\\_________/\\n                            ^           ^\\n                            pre         cur\\n     */\\n    class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            if(!head) return NULL;\\n            ListNode tmp(0);\\n            tmp.next = head;\\n            ListNode *pre = &tmp, *cur = head;\\n            while(cur && cur->next){\\n                pre->next = cur->next;\\n                pre = pre->next;\\n                cur->next = pre->next;\\n                pre->next = cur;\\n                pre = cur;\\n                cur = cur->next;\\n            }\\n            return tmp.next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            if(!head) return NULL;\\n            ListNode tmp(0);\\n            tmp.next = head;\\n            ListNode *pre = &tmp, *cur = head;\\n            while(cur && cur->next){\\n                pre->next = cur->next;\\n                pre = pre->next;\\n                cur->next = pre->next;\\n                pre->next = cur;\\n                pre = cur;\\n                cur = cur->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 11312,
                "title": "python-concise-iterative-and-recursive-solutions",
                "content": "    # Iteratively\\n    def swapPairs1(self, head):\\n        dummy = p = ListNode(0)\\n        dummy.next = head\\n        while head and head.next:\\n            tmp = head.next\\n            head.next = tmp.next\\n            tmp.next = head\\n            p.next = tmp\\n            head = head.next\\n            p = tmp.next\\n        return dummy.next\\n     \\n    # Recursively    \\n    def swapPairs(self, head):\\n        if head and head.next:\\n            tmp = head.next\\n            head.next = self.swapPairs(tmp.next)\\n            tmp.next = head\\n            return tmp\\n        return head",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "    # Iteratively\\n    def swapPairs1(self, head):\\n        dummy = p = ListNode(0)\\n        dummy.next = head\\n        while head and head.next:\\n            tmp = head.next\\n            head.next = tmp.next\\n            tmp.next = head\\n            p.next = tmp\\n            head = head.next\\n            p = tmp.next\\n        return dummy.next\\n     \\n    # Recursively    \\n    def swapPairs(self, head):\\n        if head and head.next:\\n            tmp = head.next\\n            head.next = self.swapPairs(tmp.next)\\n            tmp.next = head\\n            return tmp\\n        return head",
                "codeTag": "Python3"
            },
            {
                "id": 11111,
                "title": "java-simple-recursive-solution",
                "content": "Starting to see that recursion is the perfect tool for (many) linked list problems (this one + merging list problem).\\n\\n    /**\\n     * Definition for singly-linked list.\\n     * public class ListNode {\\n     *     int val;\\n     *     ListNode next;\\n     *     ListNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public ListNode swapPairs(ListNode head) {\\n            if (head == null || head.next == null) return head;\\n            ListNode second = head.next;\\n            ListNode third = second.next;\\n            \\n            second.next = head;\\n            head.next = swapPairs(third);\\n            \\n            return second;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public ListNode swapPairs(ListNode head) {\\n            if (head == null || head.next == null) return head;\\n            ListNode second = head.next;\\n            ListNode third = second.next;\\n            \\n            second.next = head;\\n            head.next = swapPairs(third);\\n            \\n            return second;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 344445,
                "title": "c-recursive-solution-faster-than-100-of-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode* temp;\\n        temp = head->next;\\n        head->next = swapPairs(head->next->next);\\n        temp->next = head;\\n        \\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode* temp;\\n        temp = head->next;\\n        head->next = swapPairs(head->next->next);\\n        temp->next = head;\\n        \\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11223,
                "title": "javascript-solution-beats-94-44-of-all-submissions",
                "content": "    var swapPairs = function(head) {\\n        if(!head || !head.next) return head;\\n        var v1 = head, v2 = head.next, v3 = v2.next;\\n        v2.next = v1;\\n        v1.next = swapPairs(v3);\\n        return v2;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var swapPairs = function(head) {\\n        if(!head || !head.next) return head;\\n        var v1 = head, v2 = head.next, v3 = v2.next;\\n        v2.next = v1;\\n        v1.next = swapPairs(v3);\\n        return v2;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3528791,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers. This is only for first 10,000 Subscribers.  **DON\\'T FORGET** to Subscribe\\n\\n# Search \\uD83D\\uDC49 `Tech Wired Leetcode` to Subscribe\\n\\n# Video Solution\\n\\n# Search \\uD83D\\uDC49 `Swap Nodes in Pairs by Tech Wired`\\n\\n# or\\n\\n# Click the Link in my Profile\\n\\n# Approach:\\nThe approach used in the code is to traverse the linked list and swap adjacent pairs of nodes. This is done iteratively by maintaining a current pointer that points to the previous node before the pair to be swapped. The swapping is done by modifying the next pointers of the nodes.\\n\\n# Intuition:\\nThe intuition behind the code is to break down the problem into smaller subproblems. By swapping two nodes at a time, we can gradually swap adjacent pairs throughout the linked list. This is achieved by manipulating the next pointers of the nodes.\\n\\nThe use of a dummy node helps in handling the edge case where the head of the list needs to be swapped. It serves as a placeholder for the new head of the modified list.\\n\\nThe while loop iterates as long as there are at least two nodes remaining in the list. In each iteration, the current pair of nodes is swapped by adjusting the next pointers accordingly.\\n\\n\\n\\n```Python []\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        if not head or not head.next: return head\\n\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        curr = dummy\\n\\n        while curr.next and curr.next.next:\\n            first = curr.next\\n            second = curr.next.next\\n            curr.next = second\\n            first.next = second.next\\n            second.next = first\\n            curr = curr.next.next\\n        \\n        return dummy.next\\n```\\n```Java []\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode curr = dummy;\\n        \\n        while (curr.next != null && curr.next.next != null) {\\n            ListNode first = curr.next;\\n            ListNode second = curr.next.next;\\n            curr.next = second;\\n            first.next = second.next;\\n            second.next = first;\\n            curr = curr.next.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head == nullptr || head->next == nullptr) {\\n            return head;\\n        }\\n        \\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* curr = dummy;\\n        \\n        while (curr->next != nullptr && curr->next->next != nullptr) {\\n            ListNode* first = curr->next;\\n            ListNode* second = curr->next->next;\\n            curr->next = second;\\n            first->next = second->next;\\n            second->next = first;\\n            curr = curr->next->next;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```\\n# An Upvote will be encouraging \\uD83D\\uDC4D\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Linked List"
                ],
                "code": "```Python []\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        if not head or not head.next: return head\\n\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        curr = dummy\\n\\n        while curr.next and curr.next.next:\\n            first = curr.next\\n            second = curr.next.next\\n            curr.next = second\\n            first.next = second.next\\n            second.next = first\\n            curr = curr.next.next\\n        \\n        return dummy.next\\n```\n```Java []\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode curr = dummy;\\n        \\n        while (curr.next != null && curr.next.next != null) {\\n            ListNode first = curr.next;\\n            ListNode second = curr.next.next;\\n            curr.next = second;\\n            first.next = second.next;\\n            second.next = first;\\n            curr = curr.next.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head == nullptr || head->next == nullptr) {\\n            return head;\\n        }\\n        \\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* curr = dummy;\\n        \\n        while (curr->next != nullptr && curr->next->next != nullptr) {\\n            ListNode* first = curr->next;\\n            ListNode* second = curr->next->next;\\n            curr->next = second;\\n            first->next = second->next;\\n            second->next = first;\\n            curr = curr->next->next;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11028,
                "title": "my-straight-forward-java-solution-without-recursion-or-dummy-nodes-0ms",
                "content": "- The idea is straightforward: use two pointers and swap\\n - `a.next = b.next`, `b.next = a`.\\n - Then continue the next pair, `b = a.next.next`, `a=a.next`\\n - Remember to check `null`\\n - Remember to track new `head`\\n - Remember to link the new pair after the prior nodes. \\n\\nAttached is the accepted code.\\n\\n\\n    public class Solution {\\n      public ListNode swapPairs(ListNode head) {\\n        if(head==null || head.next==null) return head;\\n        ListNode newHead = head.next, a=head,b=a.next,pre = null;\\n        while(a!=null && b!=null){\\n          a.next = b.next;\\n          b.next = a;\\n          if(pre!=null) pre.next = b;\\n          if(a.next==null) break;\\n          b = a.next.next;\\n          pre = a;\\n          a = a.next;\\n        }\\n        return newHead;\\n      }\\n    }\\n\\n- AC, 0ms",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      public ListNode swapPairs(ListNode head) {\\n        if(head==null || head.next==null) return head;\\n        ListNode newHead = head.next, a=head,b=a.next,pre = null;\\n        while(a!=null && b!=null){\\n          a.next = b.next;\\n          b.next = a;\\n          if(pre!=null) pre.next = b;\\n          if(a.next==null) break;\\n          b = a.next.next;\\n          pre = a;\\n          a = a.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 486804,
                "title": "python-simple-solution-memory-usage-less-than-100",
                "content": "Given:\\n**prev->a->b->c**\\n\\nChange it to:\\n**prev->b->a->c**\\n\\nSince the first node does not have any previous node, we create a dummy node at the beginning.\\n\\n```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n\\n        dummy = prev = ListNode(0)\\n        prev.next = head\\n\\t\\t\\n        while prev.next and prev.next.next:\\n            a = prev.next\\n            b = prev.next.next\\n            c = prev.next.next.next\\n            prev.next = b\\n            prev.next.next = a\\n            prev.next.next.next = c\\n            prev = prev.next.next\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n\\n        dummy = prev = ListNode(0)\\n        prev.next = head\\n\\t\\t\\n        while prev.next and prev.next.next:\\n            a = prev.next\\n            b = prev.next.next\\n            c = prev.next.next.next\\n            prev.next = b\\n            prev.next.next = a\\n            prev.next.next.next = c\\n            prev = prev.next.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11320,
                "title": "my-simple-recursive-solution",
                "content": "My solution is quite simple. Just find the reverse job is the same for every 2 nodes.\\n\\n    public ListNode swapPairs(ListNode head) {\\n            if (head == null || head.next == null) {\\n                return head;\\n            }\\n            \\n            ListNode newhd = head.next;\\n            head.next = swapPairs(newhd.next);\\n            newhd.next = head;\\n            return newhd;\\n    }",
                "solutionTags": [],
                "code": "My solution is quite simple. Just find the reverse job is the same for every 2 nodes.\\n\\n    public ListNode swapPairs(ListNode head) {\\n            if (head == null || head.next == null) {\\n                return head;\\n            }\\n            \\n            ListNode newhd = head.next;\\n            head.next = swapPairs(newhd.next);\\n            newhd.next = head;\\n            return newhd;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 265325,
                "title": "java-recursive-solution-beats-100-with-explanation",
                "content": "The idea is simple:\\neach we take two first elements of (sub)sequence, swap them using two additional variables, and call the function recursively from the tail. For example:\\n![image](https://assets.leetcode.com/users/olsh/image_1553979740.png)\\n\\nThe code of this solution:\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next==null)return head;\\n        ListNode tempNext = head.next.next;\\n        ListNode tempFirst = head.next;\\n        ListNode tempSecond = head;\\n        head = tempFirst;\\n        head.next = tempSecond;\\n        head.next.next = swapPairs(tempNext);\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next==null)return head;\\n        ListNode tempNext = head.next.next;\\n        ListNode tempFirst = head.next;\\n        ListNode tempSecond = head;\\n        head = tempFirst;\\n        head.next = tempSecond;\\n        head.next.next = swapPairs(tempNext);\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11331,
                "title": "4ms-easy-c-iterative-solution",
                "content": "Well, since the `head` pointer may also been modified, we create a `new_head` that points to it to facilitate the swapping process.\\n\\nFor the example list `1 -> 2 -> 3 -> 4` in the problem statement, it will become `0 -> 1 -> 2 -> 3 -> 4` (we init `new_head -> val` to be `0`). Then we set a pointer `pre` to `new_head` and another `cur` to `head`. Each time, we will swap `pre -> next` and `cur -> next` using the following piece of code.\\n\\n    pre -> next = cur -> next;\\n    cur -> next = cur -> next -> next;\\n    pre -> next -> next = cur;\\n\\nAfter swapping them, we update as follows:\\n\\n    pre = cur; \\n    cur = pre -> next; \\n\\nto swap the next two nodes.\\n\\nFinally, we return `new_head -> next`.\\n\\nThe complete code is as follows.\\n\\n    class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) { \\n            if (!head || !(head -> next)) return head;\\n            ListNode* new_head = new ListNode(0);\\n            new_head -> next = head;\\n            ListNode* pre = new_head; \\n            ListNode* cur = head;\\n            while (pre -> next && cur -> next) {\\n                pre -> next = cur -> next;\\n                cur -> next = cur -> next -> next;\\n                pre -> next -> next = cur;\\n                pre = cur;\\n                cur = pre -> next;\\n            }\\n            return new_head -> next;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) { \\n            if (!head || !(head -> next)) return head;\\n            ListNode* new_head = new ListNode(0);\\n            new_head -> next = head;\\n            ListNode* pre = new_head; \\n            ListNode* cur = head;\\n            while (pre -> next && cur -> next) {\\n                pre -> next = cur -> next;\\n                cur -> next = cur -> next -> next;\\n                pre -> next -> next = cur;\\n                pre = cur;\\n                cur = pre -> next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 486026,
                "title": "java-0-ms-beating-100-simple-iterative-solution-with-diagram-and-explanation",
                "content": "```\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        ListNode prevNode = new ListNode(0);    //Node situated before the two to-be-swapped nodes\\n        prevNode.next = head;                   //Starting before head\\n        ListNode newHead = prevNode;            //Storing a reference for returning\\n        \\n        while(prevNode.next!=null && prevNode.next.next!=null){\\n            \\n            //Declare                                           // ...[prev]-->[node1]-->[node2]-->[next]...\\n            ListNode node1 = prevNode.next;                     \\n            ListNode node2 = node1.next;\\n            ListNode nextNode = node2.next;\\n            \\n            //Swap\\n            prevNode.next = node2;                              // ...[prev]-->[node2]<--[node1]   [next]...\\n            node2.next = node1;                                 // ...[prev]-->[node2]<-->[node1]  [next]...\\n            node1.next = nextNode;                              // ...[prev]-->[node2]-->[node1]-->[next]...\\n            \\n            //Move \\n            prevNode = node1;                                   // ...[...]-->[node2]-->[node1/prev]-->[next]...\\n        }\\n        \\n        return newHead.next;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        ListNode prevNode = new ListNode(0);    //Node situated before the two to-be-swapped nodes\\n        prevNode.next = head;                   //Starting before head\\n        ListNode newHead = prevNode;            //Storing a reference for returning\\n        \\n        while(prevNode.next!=null && prevNode.next.next!=null){\\n            \\n            //Declare                                           // ...[prev]-->[node1]-->[node2]-->[next]...\\n            ListNode node1 = prevNode.next;                     \\n            ListNode node2 = node1.next;\\n            ListNode nextNode = node2.next;\\n            \\n            //Swap\\n            prevNode.next = node2;                              // ...[prev]-->[node2]<--[node1]   [next]...\\n            node2.next = node1;                                 // ...[prev]-->[node2]<-->[node1]  [next]...\\n            node1.next = nextNode;                              // ...[prev]-->[node2]-->[node1]-->[next]...\\n            \\n            //Move \\n            prevNode = node1;                                   // ...[...]-->[node2]-->[node1/prev]-->[next]...\\n        }\\n        \\n        return newHead.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11175,
                "title": "c-recursive-and-iterative-solutions",
                "content": "    \\n    // recursively\\n    ListNode* swapPairs1(ListNode* head) {\\n        if (!head || !(head->next))\\n            return head;\\n        ListNode *res = head->next;\\n        head->next = swapPairs(res->next);\\n        res->next = head;\\n        return res;\\n    }\\n    \\n    // iteratively\\n    ListNode *swapPairs(ListNode *head) {\\n        ListNode *dummy = new ListNode(0), *node;\\n        node = dummy;\\n        dummy->next = head;\\n        while (head && head->next) {\\n            ListNode *nxt = head->next;\\n            head->next = nxt->next;\\n            nxt->next = head;\\n            node->next = nxt;\\n            node = head;\\n            head = node->next;\\n        }\\n        return dummy->next;\\n    }",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Iterator"
                ],
                "code": "    \\n    // recursively\\n    ListNode* swapPairs1(ListNode* head) {\\n        if (!head || !(head->next))\\n            return head;\\n        ListNode *res = head->next;\\n        head->next = swapPairs(res->next);\\n        res->next = head;\\n        return res;\\n    }\\n    \\n    // iteratively\\n    ListNode *swapPairs(ListNode *head) {\\n        ListNode *dummy = new ListNode(0), *node;\\n        node = dummy;\\n        dummy->next = head;\\n        while (head && head->next) {\\n            ListNode *nxt = head->next;\\n            head->next = nxt->next;\\n            nxt->next = head;\\n            node->next = nxt;\\n            node = head;\\n            head = node->next;\\n        }\\n        return dummy->next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3529293,
                "title": "c-easy-recursion",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)return head;\\n        ListNode* temp=swapPairs(head->next->next);\\n        ListNode* t=head;\\n        head=head->next;\\n        head->next=t;\\n        head->next->next=temp;\\n        return head;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/425d38ef-1ecd-4fe2-966c-1df715fb51d0_1684210746.862829.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)return head;\\n        ListNode* temp=swapPairs(head->next->next);\\n        ListNode* t=head;\\n        head=head->next;\\n        head->next=t;\\n        head->next->next=temp;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529474,
                "title": "easy-solution-beginner-friendly-easy-to-understand-beats-100-java-python-3-c-js-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse the list and swap pairs of nodes one by one.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The node \"ans\" is to point to the head of the original list. It then uses a \"curr\" node to traverse the list and swap pairs of nodes. The loop continues as long as there are at least two more nodes to swap.\\n\\n- Inside the loop, the solution uses two temporary nodes, \"t1\" and \"t2\", to hold the first and second nodes of the pair. Then, it updates the pointers to swap the nodes, and moves \"curr\" two nodes ahead. At the end, it returns the modified list starting from the next node of the  \"ans\" node.\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n          if (head == null || head.next == null) {\\n            return head;\\n        }\\n    ListNode ans =new ListNode(0);\\n    ans.next=head;\\n    ListNode curr=ans;\\n   while (curr.next != null && curr.next.next != null) {\\n            ListNode t1 = curr.next;\\n            ListNode t2 = curr.next.next;\\n            curr.next = t2;\\n            t1.next = t2.next;\\n            t2.next = t1;\\n            curr = curr.next.next;\\n        }  \\n      return ans.next;\\n    }\\n}\\n```\\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n        \\n        ans = ListNode(0)\\n        ans.next = head\\n        curr = ans\\n        \\n        while curr.next and curr.next.next:\\n            t1 = curr.next\\n            t2 = curr.next.next\\n            curr.next = t2\\n            t1.next = t2.next\\n            t2.next = t1\\n            curr = curr.next.next\\n        \\n        return ans.next\\n```\\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         if (head == NULL || head->next == NULL) {\\n        return head;\\n    }\\n    struct ListNode* ans = (struct ListNode*) malloc(sizeof(struct ListNode));\\n    ans->next = head;\\n    struct ListNode* curr = ans;\\n    while (curr->next != NULL && curr->next->next != NULL) {\\n        struct ListNode* t1 = curr->next;\\n        struct ListNode* t2 = curr->next->next;\\n        curr->next = t2;\\n        t1->next = t2->next;\\n        t2->next = t1;\\n        curr = curr->next->next;\\n    }\\n    return ans->next;\\n    }\\n};\\n```\\n```Javascript []\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function(head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    let ans = new ListNode(0);\\n    ans.next = head;\\n    let curr = ans;\\n    while (curr.next != null && curr.next.next != null) {\\n        let t1 = curr.next;\\n        let t2 = curr.next.next;\\n        curr.next = t2;\\n        t1.next = t2.next;\\n        t2.next = t1;\\n        curr = curr.next.next;\\n    }\\n    return ans.next;\\n};\\n```\\n```C# []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode SwapPairs(ListNode head) {\\n    if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode ans = new ListNode(0);\\n        ans.next = head;\\n        ListNode curr = ans;\\n        while (curr.next != null && curr.next.next != null) {\\n            ListNode t1 = curr.next;\\n            ListNode t2 = curr.next.next;\\n            curr.next = t2;\\n            t1.next = t2.next;\\n            t2.next = t1;\\n            curr = curr.next.next;\\n        }\\n        return ans.next;    \\n    }\\n}\\n```\\n```Kotlin []\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun swapPairs(head: ListNode?): ListNode? {\\n         if (head == null || head.next == null) {\\n            return head\\n        }\\n        val ans = ListNode(0)\\n        ans.next = head\\n        var curr: ListNode? = ans\\n        while (curr?.next != null && curr.next?.next != null) {\\n            val t1 = curr.next\\n            val t2 = curr.next?.next\\n            curr.next = t2\\n            t1.next = t2?.next\\n            t2?.next = t1\\n            curr = curr.next?.next\\n        }\\n        return ans.next\\n    }\\n}\\n```\\n```C []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* swapPairs(struct ListNode* head){\\n if (head == NULL || head->next == NULL) {\\n        return head;\\n    }\\n    struct ListNode* ans = (struct ListNode*) malloc(sizeof(struct ListNode));\\n    ans->next = head;\\n    struct ListNode* curr = ans;\\n    while (curr->next != NULL && curr->next->next != NULL) {\\n        struct ListNode* t1 = curr->next;\\n        struct ListNode* t2 = curr->next->next;\\n        curr->next = t2;\\n        t1->next = t2->next;\\n        t2->next = t1;\\n        curr = curr->next->next;\\n    }\\n    return ans->next;\\n}\\n```\\n\\nUPVOTES ARE ENCOURAGING!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Kotlin"
                ],
                "code": "```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n          if (head == null || head.next == null) {\\n            return head;\\n        }\\n    ListNode ans =new ListNode(0);\\n    ans.next=head;\\n    ListNode curr=ans;\\n   while (curr.next != null && curr.next.next != null) {\\n            ListNode t1 = curr.next;\\n            ListNode t2 = curr.next.next;\\n            curr.next = t2;\\n            t1.next = t2.next;\\n            t2.next = t1;\\n            curr = curr.next.next;\\n        }  \\n      return ans.next;\\n    }\\n}\\n```\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n        \\n        ans = ListNode(0)\\n        ans.next = head\\n        curr = ans\\n        \\n        while curr.next and curr.next.next:\\n            t1 = curr.next\\n            t2 = curr.next.next\\n            curr.next = t2\\n            t1.next = t2.next\\n            t2.next = t1\\n            curr = curr.next.next\\n        \\n        return ans.next\\n```\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         if (head == NULL || head->next == NULL) {\\n        return head;\\n    }\\n    struct ListNode* ans = (struct ListNode*) malloc(sizeof(struct ListNode));\\n    ans->next = head;\\n    struct ListNode* curr = ans;\\n    while (curr->next != NULL && curr->next->next != NULL) {\\n        struct ListNode* t1 = curr->next;\\n        struct ListNode* t2 = curr->next->next;\\n        curr->next = t2;\\n        t1->next = t2->next;\\n        t2->next = t1;\\n        curr = curr->next->next;\\n    }\\n    return ans->next;\\n    }\\n};\\n```\n```Javascript []\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function(head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    let ans = new ListNode(0);\\n    ans.next = head;\\n    let curr = ans;\\n    while (curr.next != null && curr.next.next != null) {\\n        let t1 = curr.next;\\n        let t2 = curr.next.next;\\n        curr.next = t2;\\n        t1.next = t2.next;\\n        t2.next = t1;\\n        curr = curr.next.next;\\n    }\\n    return ans.next;\\n};\\n```\n```C# []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode SwapPairs(ListNode head) {\\n    if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode ans = new ListNode(0);\\n        ans.next = head;\\n        ListNode curr = ans;\\n        while (curr.next != null && curr.next.next != null) {\\n            ListNode t1 = curr.next;\\n            ListNode t2 = curr.next.next;\\n            curr.next = t2;\\n            t1.next = t2.next;\\n            t2.next = t1;\\n            curr = curr.next.next;\\n        }\\n        return ans.next;    \\n    }\\n}\\n```\n```Kotlin []\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun swapPairs(head: ListNode?): ListNode? {\\n         if (head == null || head.next == null) {\\n            return head\\n        }\\n        val ans = ListNode(0)\\n        ans.next = head\\n        var curr: ListNode? = ans\\n        while (curr?.next != null && curr.next?.next != null) {\\n            val t1 = curr.next\\n            val t2 = curr.next?.next\\n            curr.next = t2\\n            t1.next = t2?.next\\n            t2?.next = t1\\n            curr = curr.next?.next\\n        }\\n        return ans.next\\n    }\\n}\\n```\n```C []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* swapPairs(struct ListNode* head){\\n if (head == NULL || head->next == NULL) {\\n        return head;\\n    }\\n    struct ListNode* ans = (struct ListNode*) malloc(sizeof(struct ListNode));\\n    ans->next = head;\\n    struct ListNode* curr = ans;\\n    while (curr->next != NULL && curr->next->next != NULL) {\\n        struct ListNode* t1 = curr->next;\\n        struct ListNode* t2 = curr->next->next;\\n        curr->next = t2;\\n        t1->next = t2->next;\\n        t2->next = t1;\\n        curr = curr->next->next;\\n    }\\n    return ans->next;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656816,
                "title": "solution-swift-swap-nodes-in-pairs-test-cases",
                "content": "```swift\\nclass Solution {\\n    func swapPairs(_ head: ListNode?) -> ListNode? {\\n        var head = head, node = head, pre: ListNode?\\n        \\n        while node != nil, let next = node!.next {\\n            let cur = next, tmp = cur.next\\n            pre == nil ? (head = cur) : (pre!.next = cur)\\n            cur.next = node\\n            node!.next = tmp\\n            pre = node\\n            node = tmp\\n        }\\n        return head\\n    }\\n}\\n```\\n\\n---\\n\\n<p><details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.012 (0.014) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.swapPairs(ListNode([1,2,3,4]))\\n        XCTAssertEqual(value?.val, ListNode([2,1,4,3])?.val)\\n    }\\n    \\n    func test1() {\\n        let value = solution.swapPairs(ListNode([]))\\n        XCTAssertEqual(value?.val, ListNode([])?.val)\\n    }\\n    \\n    func test2() {\\n        let value = solution.swapPairs(ListNode([1]))\\n        XCTAssertEqual(value?.val, ListNode([1])?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details></p>\\n\\n<p><details>\\n<summary>\\n<b>ListNode</b>\\n</summary>\\n\\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n\\n\\tpublic init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```\\n\\n</details></p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func swapPairs(_ head: ListNode?) -> ListNode? {\\n        var head = head, node = head, pre: ListNode?\\n        \\n        while node != nil, let next = node!.next {\\n            let cur = next, tmp = cur.next\\n            pre == nil ? (head = cur) : (pre!.next = cur)\\n            cur.next = node\\n            node!.next = tmp\\n            pre = node\\n            node = tmp\\n        }\\n        return head\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.swapPairs(ListNode([1,2,3,4]))\\n        XCTAssertEqual(value?.val, ListNode([2,1,4,3])?.val)\\n    }\\n    \\n    func test1() {\\n        let value = solution.swapPairs(ListNode([]))\\n        XCTAssertEqual(value?.val, ListNode([])?.val)\\n    }\\n    \\n    func test2() {\\n        let value = solution.swapPairs(ListNode([1]))\\n        XCTAssertEqual(value?.val, ListNode([1])?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n\\n\\tpublic init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984266,
                "title": "c-c-simple-short-and-easy-recursive-solution-0ms-faster-than-100",
                "content": "```\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    if ((!head) || (!head->next))\\n        return head;\\n    \\n    struct ListNode* tmp = head;\\n    head = head->next;\\n    tmp->next = head->next;\\n    head->next = tmp;\\n    \\n    head->next->next = swapPairs(head->next->next);\\n    return head;\\n}\\n```\\n**Like it? please upvote!\\nHave any comments? I\\'d love to hear...**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    if ((!head) || (!head->next))\\n        return head;\\n    \\n    struct ListNode* tmp = head;\\n    head = head->next;\\n    tmp->next = head->next;\\n    head->next = tmp;\\n    \\n    head->next->next = swapPairs(head->next->next);\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1163702,
                "title": "python3-simple-recursive-solution-beats-95-00-easily-understandable-with-figure-explanation",
                "content": "## Idea\\n**Recursion**\\n- Base case: list is empty or contains only one node. (In this case there\\'s no need to swap anything)\\n- Recursive case: If the nodes after the first two nodes are already done swapping in pairs,  we just need to swap the first two nodes and then we\\'re done!\\n\\n## Implementation\\n\\n```python\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        # base case\\n        if not head or not head.next:\\n            return head\\n        \\n        # recursive case\\n        _next = head.next\\n        head.next = self.swapPairs(_next.next)\\n        _next.next = head\\n        \\n        return _next\\n```\\n\\n## Visualization\\n\\n![image](https://assets.leetcode.com/users/images/399f06f6-0361-4b86-a29d-823f0d42a04a_1618696569.132693.png)\\n\\n## Complexity\\n- Time: O(n)\\n- Space: O(n)\\n\\n\\nIf you think this is helpful, please give it a vote.\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        # base case\\n        if not head or not head.next:\\n            return head\\n        \\n        # recursive case\\n        _next = head.next\\n        head.next = self.swapPairs(_next.next)\\n        _next.next = head\\n        \\n        return _next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984392,
                "title": "python-o-n-solution-explained",
                "content": "As with a lot of other linked lists, it is good idea to add dummy node before list to avoid cases. Imagine, we have list `1, 2, 3, 4, 5, 6`, let us add `0` node in the beginning, so we have `0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6` now.\\n\\nNow, let us look at the main step of algorithm (for simplicity I will call nodes by its values)\\n1. `pre = 0`, whe check if `pre.next` and `pre.next.next` exists, they are, so define `a = 1` and `b = 2`.\\n2. Now, we need to rewrite links: `0 -> 2`, `2 -> 1` and `1 -> 3`. Note, that we do it all in one step.\\n3. Finally, we say, that `pre = 1`. Also, our list now looks like `0 -> 2 -> 1 -> 3 -> 4 -> 5 -> 6` and as I said `pre = 1` now, so we swapped first two elements and now we on element number 2, which is exaclty what we have previously for smaller list.\\n4. On next step we have `0 -> 2 -> 1 -> 4 -> 3 -> 5 -> 6` and finally `0 -> 2 -> 1 -> 4 -> 3 -> 6 -> 5`, this is exaclty what we need to return.\\n\\n**Complexity**: time complexity is `O(n)`: we iterate over our list once, space complexity is `O(1)`: we did not add any new space and reused already existing nodes.\\n\\n```\\nclass Solution:\\n    def swapPairs(self, head):\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        pre = dummy\\n        while pre.next and pre.next.next:\\n            a = pre.next\\n            b = a.next\\n            pre.next, b.next, a.next = b, a, b.next\\n            pre = a\\n        return dummy.next\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head):\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        pre = dummy\\n        while pre.next and pre.next.next:\\n            a = pre.next\\n            b = a.next\\n            pre.next, b.next, a.next = b, a, b.next\\n            pre = a\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774508,
                "title": "c-easy-to-understand-short-simple-10-lines",
                "content": "# 24. Swap Nodes in Pairs\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Please Upvote if it helps\\u2B06\\uFE0F\\n4. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\\n\\n[LeetCode](https://github.com/knockcat/Leetcode)\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**CODE WITH EXPLANATION**\\n\\n```\\n\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head-> next == NULL)  // if list contain 0 nodes or a single node return head\\n            return head;\\n        \\n         ListNode* p = head;   // p pointing to head\\n        ListNode* res = head->next; // res is pointed to head -> next\\n        ListNode* q; ListNode* temp; // temporary nodes for links updation\\n        \\n        while(true)\\n        {\\n\\t\\t// for eg 1 2 3 4\\n\\t\\t//this iteration temp is point to 3 and 2 -> 1 will be acheived \\n\\t\\t// more explanation read after end of code\\n            q = p->next;\\n            temp = q->next;\\n            q->next = p;\\n            \\n            if(temp == NULL || temp->next == NULL) {\\n                p->next = temp;\\n                break;\\n            }\\n\\t\\t// if statement of temp won\\'t execute \\n            p->next = temp->next;\\n            p = temp;\\n        }\\n        return res;  \\n       \\n    }\\n};\\n```\\n\\n```\\n{\\n// 1\\'s link with 4 will extablished & value of temp i.e 3 will be stored in p.\\n\\n// now p contains 3 that points to 4.\\n\\n// Same way 2nd iteration will execute and 3->4 will turn into 4->3\\n\\n// if statement inside while loop will execute as temp has become null, \\n\\n// p->next = temp means terminate the linked list by attaching NULL to last element 3 and break out of while loop.\\n\\n// return res , which will give 2 -> 1 -> 4 -> 3 -> NULL\\n}\\n```\\n\\n**ANOTHER APPROACH BY SWAPPING VALUES**\\n\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head-> next == NULL)  // if list contain 0 nodes or a single node return head\\n            return head;\\n        \\n        ListNode* temp = head;    // temporary pointer so that we don\\'t loose reference to head\\n        \\n        while(temp)        // while temp != NULL\\n        {\\n            if(temp->next != NULL)       \\n            {\\n\\t\\t\\t   // if list contain odd no of nodes than at last node the temp->next,\\n\\t\\t\\t   //will be pointing to null and the code crashes, as there is no other node,\\n\\t\\t\\t   // to perform swap opearation\\n                swap(temp->val, temp->next->val);    // swap with the adjacent node\\n                temp = temp->next->next;                 //incrementing pointer with 2 step\\n            }\\n\\t\\t\\t\\telse    // break because last pair of list is odd \\n\\t\\t\\t\\t\\tbreak;\\n        }\\n        \\n        return head;    // return head\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Please Upvote if it helps\\u2B06\\uFE0F\\n4. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\n```\\n\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head-> next == NULL)  // if list contain 0 nodes or a single node return head\\n            return head;\\n        \\n         ListNode* p = head;   // p pointing to head\\n        ListNode* res = head->next; // res is pointed to head -> next\\n        ListNode* q; ListNode* temp; // temporary nodes for links updation\\n        \\n        while(true)\\n        {\\n\\t\\t// for eg 1 2 3 4\\n\\t\\t//this iteration temp is point to 3 and 2 -> 1 will be acheived \\n\\t\\t// more explanation read after end of code\\n            q = p->next;\\n            temp = q->next;\\n            q->next = p;\\n            \\n            if(temp == NULL || temp->next == NULL) {\\n                p->next = temp;\\n                break;\\n            }\\n\\t\\t// if statement of temp won\\'t execute \\n            p->next = temp->next;\\n            p = temp;\\n        }\\n        return res;  \\n       \\n    }\\n};\\n```\n```\\n{\\n// 1\\'s link with 4 will extablished & value of temp i.e 3 will be stored in p.\\n\\n// now p contains 3 that points to 4.\\n\\n// Same way 2nd iteration will execute and 3->4 will turn into 4->3\\n\\n// if statement inside while loop will execute as temp has become null, \\n\\n// p->next = temp means terminate the linked list by attaching NULL to last element 3 and break out of while loop.\\n\\n// return res , which will give 2 -> 1 -> 4 -> 3 -> NULL\\n}\\n```\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head-> next == NULL)  // if list contain 0 nodes or a single node return head\\n            return head;\\n        \\n        ListNode* temp = head;    // temporary pointer so that we don\\'t loose reference to head\\n        \\n        while(temp)        // while temp != NULL\\n        {\\n            if(temp->next != NULL)       \\n            {\\n\\t\\t\\t   // if list contain odd no of nodes than at last node the temp->next,\\n\\t\\t\\t   //will be pointing to null and the code crashes, as there is no other node,\\n\\t\\t\\t   // to perform swap opearation\\n                swap(temp->val, temp->next->val);    // swap with the adjacent node\\n                temp = temp->next->next;                 //incrementing pointer with 2 step\\n            }\\n\\t\\t\\t\\telse    // break because last pair of list is odd \\n\\t\\t\\t\\t\\tbreak;\\n        }\\n        \\n        return head;    // return head\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 751194,
                "title": "javascript-iterative-time-o-n-space-o-1-explanation",
                "content": "```\\nvar swapPairs = function(head) {\\n    // Store head to return list, Only instance of new data so space is O(1)\\n    let dummy = new ListNode(-1);\\n    dummy.next = head;\\n    \\n    let prev = dummy\\n    \\n    // Traverse list\\n    while (head && head.next) {\\n        \\n    // Declare\\n    let n1 = head\\n    let n2 = head.next\\n        \\n        // Swap\\n        prev.next = n2\\n        n1.next = n2.next\\n        n2.next = n1\\n        \\n        // Assign\\n        prev = n1\\n        head = n1.next\\n    }\\n    \\n    // The variable prev has been used to create the dummy list. dummy.next is still the head of new list\\n    return dummy.next;\\n};\\n```\\ntime: O(n)\\nspace: O(1)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar swapPairs = function(head) {\\n    // Store head to return list, Only instance of new data so space is O(1)\\n    let dummy = new ListNode(-1);\\n    dummy.next = head;\\n    \\n    let prev = dummy\\n    \\n    // Traverse list\\n    while (head && head.next) {\\n        \\n    // Declare\\n    let n1 = head\\n    let n2 = head.next\\n        \\n        // Swap\\n        prev.next = n2\\n        n1.next = n2.next\\n        n2.next = n1\\n        \\n        // Assign\\n        prev = n1\\n        head = n1.next\\n    }\\n    \\n    // The variable prev has been used to create the dummy list. dummy.next is still the head of new list\\n    return dummy.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 233501,
                "title": "rust-0ms-100",
                "content": "```\\nimpl Solution {\\n    pub fn swap_pairs(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        head.and_then(|mut n| {\\n            match n.next {\\n                Some(mut m) => {\\n                    n.next = Solution::swap_pairs(m.next);\\n                    m.next = Some(n);\\n                    Some(m)\\n                },\\n                None => Some(n)\\n            }\\n        })\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn swap_pairs(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        head.and_then(|mut n| {\\n            match n.next {\\n                Some(mut m) => {\\n                    n.next = Solution::swap_pairs(m.next);\\n                    m.next = Some(n);\\n                    Some(m)\\n                },\\n                None => Some(n)\\n            }\\n        })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481145,
                "title": "go-many-clean-solutions-with-images-in-go-golang-0ms-100",
                "content": "Hello Gophers!\\n\\nStart:\\n![swap-nodes-start.png](https://assets.leetcode.com/users/images/f5bbe08e-42e8-42ce-9977-d5f2a58bc653_1690834893.7782896.png)\\n\\nSwap:\\n\\n![swap-nodes-swap.png](https://assets.leetcode.com/users/images/7085cfe8-e298-435b-bc12-739668f3580f_1690834907.7661934.png)\\n\\nEnd:\\n![swap-nodes-end.png](https://assets.leetcode.com/users/images/78c9effb-98e4-4594-b2ff-b91bce480211_1690834920.5882404.png)\\n\\n\\n## Solution 1: Recursive (Easy-Medium)\\n\\nCleaner, but worst space complexity.\\n\\nTime Complexity: `O(n)`\\nSpace Complexity: `O(n)` (recursion)\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\thead, head.Next, head.Next.Next = head.Next, swapPairs(head.Next.Next), head\\n\\n\\treturn head\\n}\\n\\n```\\n\\nor\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n    if head != nil && head.Next != nil {\\n        head, head.Next, head.Next.Next = head.Next, swapPairs(head.Next.Next), head\\n    }\\n    return head\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/fb93b1d2-41f9-44b6-a05d-f24d58f76c8f_1661481740.6021497.jpeg)\\n![image](https://assets.leetcode.com/users/images/edacf671-cf94-4da0-8569-d55c1d682b51_1661481740.3160453.jpeg)\\n\\n\\n## Solution 2: Iterative (Medium-Hard)\\n\\n\\nIteration (`for` loop) instead of recursivity (function calling itself).  \\nUglier (imo), but better space complexity.\\n\\n\\nTime Complexity: `O(n)`\\nSpace Complexity: `O(1)`\\n\\n### Solution 2.1: with temp nodes (Medium)\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tfor curr != nil && curr.Next != nil {\\n\\t\\tfirstNode, secondNode := curr, curr.Next\\n\\t\\tfirstNode.Next, secondNode.Next = secondNode.Next, firstNode\\n\\n\\t\\tif prev != nil {\\n\\t\\t\\tprev.Next = secondNode\\n\\t\\t}\\n\\n\\t\\tprev, curr = firstNode, firstNode.Next\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\\n\\n### Solution 2.2: Without temp nodes (Hard)\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\t\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tprev, curr, curr.Next, curr.Next.Next = curr, curr.Next.Next, curr.Next.Next, curr\\n\\tfor curr != nil && curr.Next != nil {\\n        prev, prev.Next, curr, curr.Next, curr.Next.Next = curr, curr.Next, curr.Next.Next, curr.Next.Next, curr\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\\n\\nHow did I get to solution 2.2?\\n\\nStart:\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tfor curr != nil && curr.Next != nil {\\n\\t\\tfirstNode, secondNode := curr, curr.Next\\n\\t\\tfirstNode.Next, secondNode.Next = secondNode.Next, firstNode\\n\\n\\t\\tif prev != nil {\\n\\t\\t\\tprev.Next = secondNode\\n\\t\\t}\\n\\n\\t\\tprev, curr = firstNode, firstNode.Next\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\\n\\nRemove \"temp nodes\" `firstNode` and `secondNode`:\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tfor curr != nil && curr.Next != nil {\\n\\t\\tprev, prev.Next, curr, curr.Next, curr.Next.Next = curr, curr.Next, curr.Next.Next, curr.Next.Next, curr\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\\n\\nBut because `prev` can be nil:\\n\\n```go\\nif prev != nil {\\n    prev.Next = secondNode\\n}\\n```\\n\\nWe need a \"first step\":\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\t\\n    // Start\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\n    // Firtst Step (prev is nil)\\n\\tprev, curr, curr.Next, curr.Next.Next = curr, curr.Next.Next, curr.Next.Next, curr\\n\\n    // All Next Steps\\n\\tfor curr != nil && curr.Next != nil {\\n        prev, prev.Next, curr, curr.Next, curr.Next.Next = curr, curr.Next, curr.Next.Next, curr.Next.Next, curr\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\\n\\nIt works \\uD83E\\uDD2F\\n\\nStart:\\n![swap-nodes-1.png](https://assets.leetcode.com/users/images/d5342873-a9b1-4b5e-938d-7294231bcf9e_1690831346.3609188.png)\\n\\nFirst iteration:\\n![swap-nodes-2.png](https://assets.leetcode.com/users/images/6f6aa2b9-35b1-48eb-abd2-06e701276bca_1690831364.0310698.png)\\n\\nTODO: Finish this\\n\\nI hope it helped!",
                "solutionTags": [
                    "Go",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\thead, head.Next, head.Next.Next = head.Next, swapPairs(head.Next.Next), head\\n\\n\\treturn head\\n}\\n\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n    if head != nil && head.Next != nil {\\n        head, head.Next, head.Next.Next = head.Next, swapPairs(head.Next.Next), head\\n    }\\n    return head\\n}\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tfor curr != nil && curr.Next != nil {\\n\\t\\tfirstNode, secondNode := curr, curr.Next\\n\\t\\tfirstNode.Next, secondNode.Next = secondNode.Next, firstNode\\n\\n\\t\\tif prev != nil {\\n\\t\\t\\tprev.Next = secondNode\\n\\t\\t}\\n\\n\\t\\tprev, curr = firstNode, firstNode.Next\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\t\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tprev, curr, curr.Next, curr.Next.Next = curr, curr.Next.Next, curr.Next.Next, curr\\n\\tfor curr != nil && curr.Next != nil {\\n        prev, prev.Next, curr, curr.Next, curr.Next.Next = curr, curr.Next, curr.Next.Next, curr.Next.Next, curr\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tfor curr != nil && curr.Next != nil {\\n\\t\\tfirstNode, secondNode := curr, curr.Next\\n\\t\\tfirstNode.Next, secondNode.Next = secondNode.Next, firstNode\\n\\n\\t\\tif prev != nil {\\n\\t\\t\\tprev.Next = secondNode\\n\\t\\t}\\n\\n\\t\\tprev, curr = firstNode, firstNode.Next\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tfor curr != nil && curr.Next != nil {\\n\\t\\tprev, prev.Next, curr, curr.Next, curr.Next.Next = curr, curr.Next, curr.Next.Next, curr.Next.Next, curr\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\n```go\\nif prev != nil {\\n    prev.Next = secondNode\\n}\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\t\\n    // Start\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\n    // Firtst Step (prev is nil)\\n\\tprev, curr, curr.Next, curr.Next.Next = curr, curr.Next.Next, curr.Next.Next, curr\\n\\n    // All Next Steps\\n\\tfor curr != nil && curr.Next != nil {\\n        prev, prev.Next, curr, curr.Next, curr.Next.Next = curr, curr.Next, curr.Next.Next, curr.Next.Next, curr\\n\\t}\\n\\n\\treturn newHead\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3517577,
                "title": "c-java-python-javascript-swapping-nodes-fully-explained",
                "content": "# Approach\\n\\n1. Check if the list is empty or contains only one node. If so, there is no need to perform any swaps, so the original head is returned.\\n2. Initialize three pointers: `newHead` to store the new head after swapping, `prev` to keep track of the previous node, and `curr` to iterate through the list.\\n3. Enter a loop that continues as long as both `curr` and `curr->next` are not null.\\n4. Inside the loop, create a pointer `next` to store the next node after `curr`.\\n5. Update the next pointers of `curr` and `next` to perform the swap. Set `curr->next` to `next->next` to connect `curr` with the next pair of nodes.\\n6. Set `next->next` to `curr` to swap the positions of `curr` and `next`.\\n7. If `prev` is not null, update its `next` pointer to `next` to connect the previous pair with the swapped pair.\\n8. Update `prev` to `curr` and `curr` to `curr->next` to move forward in the list.\\n9. After the loop ends, return `newHead`, which stores the new head of the swapped list.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this algorithm is O(n), where n is the number of nodes in the linked list. This is because the algorithm iterates through the list once. The space complexity is O(1) because it uses a constant amount of additional space to store the pointers.\\n\\n# C++\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (!head || !head->next) {\\n            return head;\\n        }\\n        ListNode* newHead = head->next;\\n        ListNode* prev = nullptr;\\n        ListNode* curr = head;\\n        \\n        while (curr && curr->next) {\\n            ListNode* next = curr->next;\\n            curr->next = next->next;\\n            next->next = curr;\\n            \\n            if (prev) {\\n                prev->next = next;\\n            }\\n            \\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        \\n        return newHead;\\n    }\\n};\\n```\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        \\n        ListNode newHead = head.next;\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        \\n        while (curr != null && curr.next != null) {\\n            ListNode next = curr.next;\\n            curr.next = next.next;\\n            next.next = curr;\\n            \\n            if (prev != null) {\\n                prev.next = next;\\n            }\\n            \\n            prev = curr;\\n            curr = curr.next;\\n        }\\n        \\n        return newHead;\\n    }\\n}\\n```\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def swapPairs(self, head):\\n        if not head or not head.next:\\n            return head\\n        \\n        new_head = head.next\\n        prev = None\\n        curr = head\\n        \\n        while curr and curr.next:\\n            next = curr.next\\n            curr.next = next.next\\n            next.next = curr\\n            \\n            if prev:\\n                prev.next = next\\n            \\n            prev = curr\\n            curr = curr.next\\n        \\n        return new_head\\n```\\n---\\n# JavaScript\\n```\\nvar swapPairs = function(head) {\\n    if (!head || !head.next) {\\n        return head;\\n    }\\n    \\n    var newHead = head.next;\\n    var prev = null;\\n    var curr = head;\\n    \\n    while (curr && curr.next) {\\n        var next = curr.next;\\n        curr.next = next.next;\\n        next.next = curr;\\n        \\n        if (prev) {\\n            prev.next = next;\\n        }\\n        \\n        prev = curr;\\n        curr = curr.next;\\n    }\\n    \\n    return newHead;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (!head || !head->next) {\\n            return head;\\n        }\\n        ListNode* newHead = head->next;\\n        ListNode* prev = nullptr;\\n        ListNode* curr = head;\\n        \\n        while (curr && curr->next) {\\n            ListNode* next = curr->next;\\n            curr->next = next->next;\\n            next->next = curr;\\n            \\n            if (prev) {\\n                prev->next = next;\\n            }\\n            \\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        \\n        return newHead;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        \\n        ListNode newHead = head.next;\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        \\n        while (curr != null && curr.next != null) {\\n            ListNode next = curr.next;\\n            curr.next = next.next;\\n            next.next = curr;\\n            \\n            if (prev != null) {\\n                prev.next = next;\\n            }\\n            \\n            prev = curr;\\n            curr = curr.next;\\n        }\\n        \\n        return newHead;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def swapPairs(self, head):\\n        if not head or not head.next:\\n            return head\\n        \\n        new_head = head.next\\n        prev = None\\n        curr = head\\n        \\n        while curr and curr.next:\\n            next = curr.next\\n            curr.next = next.next\\n            next.next = curr\\n            \\n            if prev:\\n                prev.next = next\\n            \\n            prev = curr\\n            curr = curr.next\\n        \\n        return new_head\\n```\n```\\nvar swapPairs = function(head) {\\n    if (!head || !head.next) {\\n        return head;\\n    }\\n    \\n    var newHead = head.next;\\n    var prev = null;\\n    var curr = head;\\n    \\n    while (curr && curr.next) {\\n        var next = curr.next;\\n        curr.next = next.next;\\n        next.next = curr;\\n        \\n        if (prev) {\\n            prev.next = next;\\n        }\\n        \\n        prev = curr;\\n        curr = curr.next;\\n    }\\n    \\n    return newHead;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774796,
                "title": "java-0ms-recursive-code-faster-than-100-of-the-solutions-with-comments",
                "content": "```\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        /**\\n        * The base condition will be triggered when there is no node left or there is just 1 node.\\n        * If there is just 1 node left, there is nothing that can be swapped, hence we return the node\\n        * itself.\\n        */\\n        if(head == null || head.next == null) return head;\\n        \\n        /**\\n        * If there are more than 1 nodes remaining, we would recursively call the method by passing the\\n        * next.next element.\\n        * This is because we would be swapping the head and the head.next element.\\n        * So, to call the method we would pass the head.next.next element.\\n        * This call will return a head which we would have to attach it to the current head.next element,\\n        AFTER SWAPPING.\\n        */\\n        ListNode tHead = swapPairs(head.next.next);\\n        \\n        /**\\n        * Here, we would write the swapping logic.\\n        * The node which is returned from the above line of code, will be connected with the nodes after\\n        * swapping here.\\n        */\\n        \\n        ListNode temp = head.next;\\n        head.next = tHead;\\n        temp.next = head;\\n        return temp;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        /**\\n        * The base condition will be triggered when there is no node left or there is just 1 node.\\n        * If there is just 1 node left, there is nothing that can be swapped, hence we return the node\\n        * itself.\\n        */\\n        if(head == null || head.next == null) return head;\\n        \\n        /**\\n        * If there are more than 1 nodes remaining, we would recursively call the method by passing the\\n        * next.next element.\\n        * This is because we would be swapping the head and the head.next element.\\n        * So, to call the method we would pass the head.next.next element.\\n        * This call will return a head which we would have to attach it to the current head.next element,\\n        AFTER SWAPPING.\\n        */\\n        ListNode tHead = swapPairs(head.next.next);\\n        \\n        /**\\n        * Here, we would write the swapping logic.\\n        * The node which is returned from the above line of code, will be connected with the nodes after\\n        * swapping here.\\n        */\\n        \\n        ListNode temp = head.next;\\n        head.next = tHead;\\n        temp.next = head;\\n        return temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 830851,
                "title": "swift-recursive-iterative",
                "content": "**Simple recursion**\\nTime: O(n), Space: O(n)\\n```\\nfunc swapPairs(_ head: ListNode?) -> ListNode? {\\n\\tguard let head = head else { return nil }\\n\\tif let next = head.next {\\n\\t\\thead.next = swapPairs(next.next)\\n\\t\\tnext.next = head\\n\\t\\treturn next\\n\\t} else {\\n\\t   return head \\n\\t}\\n}\\n```\\n---\\nHow about iterative?\\n**Iterative**\\nTime: O(n), Space: O(n)\\n```\\nfunc swapPairs(_ head: ListNode?) -> ListNode? {\\n\\tif head == nil || head?.next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tlet newHead = head!.next\\n\\n\\tvar stack = [ListNode]()\\n\\tvar node = head\\n\\twhile let cur = node, let next = cur.next { // 2 at a time\\n\\t\\tstack.append(cur)\\n\\t\\tstack.append(next)\\n\\t\\tnode = next.next\\n\\t}\\n\\n\\twhile !stack.isEmpty {\\n\\t\\tlet next = stack.popLast()!\\n\\t\\tlet cur = stack.popLast()!\\n\\t\\tcur.next = next.next\\n\\t\\tnext.next = cur\\n\\t\\tif let prev = stack.last {\\n\\t\\t\\tprev.next = next\\n\\t\\t}\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\\n\\n**Iterative without a stack**\\nTime: O(n), Space: O(1)\\n```\\nfunc swapPairs(_ head: ListNode?) -> ListNode? {\\n\\tvar dummy = ListNode()\\n\\tvar prev = dummy\\n\\tprev.next = head\\n\\twhile let cur = prev.next, let next = cur.next {\\n\\t\\tcur.next = next.next\\n\\t\\tnext.next = cur\\n\\t\\tprev.next = next\\n\\t\\tprev = cur\\n\\t}\\n\\n\\treturn dummy.next\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc swapPairs(_ head: ListNode?) -> ListNode? {\\n\\tguard let head = head else { return nil }\\n\\tif let next = head.next {\\n\\t\\thead.next = swapPairs(next.next)\\n\\t\\tnext.next = head\\n\\t\\treturn next\\n\\t} else {\\n\\t   return head \\n\\t}\\n}\\n```\n```\\nfunc swapPairs(_ head: ListNode?) -> ListNode? {\\n\\tif head == nil || head?.next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tlet newHead = head!.next\\n\\n\\tvar stack = [ListNode]()\\n\\tvar node = head\\n\\twhile let cur = node, let next = cur.next { // 2 at a time\\n\\t\\tstack.append(cur)\\n\\t\\tstack.append(next)\\n\\t\\tnode = next.next\\n\\t}\\n\\n\\twhile !stack.isEmpty {\\n\\t\\tlet next = stack.popLast()!\\n\\t\\tlet cur = stack.popLast()!\\n\\t\\tcur.next = next.next\\n\\t\\tnext.next = cur\\n\\t\\tif let prev = stack.last {\\n\\t\\t\\tprev.next = next\\n\\t\\t}\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\n```\\nfunc swapPairs(_ head: ListNode?) -> ListNode? {\\n\\tvar dummy = ListNode()\\n\\tvar prev = dummy\\n\\tprev.next = head\\n\\twhile let cur = prev.next, let next = cur.next {\\n\\t\\tcur.next = next.next\\n\\t\\tnext.next = cur\\n\\t\\tprev.next = next\\n\\t\\tprev = cur\\n\\t}\\n\\n\\treturn dummy.next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 557411,
                "title": "python-recursive-solution-faster-than-99-72",
                "content": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if head:                                           # first (head) node exists\\n            h = head.next                                  # second node\\n            if h:                                          # second node exists => a pair exists\\n                h.next, head.next = head, h.next           # swap node pair, first node with second => \\'h\\' is new head\\n                h.next.next = self.swapPairs(h.next.next)  # recurse on next pair head\\n                return h              # returns the new head of a swapped node pair\\n        return head                   # returns when a node pair doesn\\'t exist\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if head:                                           # first (head) node exists\\n            h = head.next                                  # second node\\n            if h:                                          # second node exists => a pair exists\\n                h.next, head.next = head, h.next           # swap node pair, first node with second => \\'h\\' is new head\\n                h.next.next = self.swapPairs(h.next.next)  # recurse on next pair head\\n                return h              # returns the new head of a swapped node pair\\n        return head                   # returns when a node pair doesn\\'t exist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529642,
                "title": "c-beats-100-image-explanation-using-dummy-head-and-dummy-tail",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will convert the list into the list with dummy head and dummy tail. It will help us to maintain pointer and will save us from writing edge cases for null pointers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEg. Given list is `1 -> 2 -> 3 -> 4`. We will convert it to `-1 -> 1 -> 2 -> 3 -> 4 -> -1`. Now our head will point to dummy head.\\n\\nWe will keep track of three pointer and will reverse every pair of elements,\\n1. prev - which will link the reversed element (from a pair of elements), this pointer is immediate left of the current pair\\n2. cur - first element of current pair\\n3. next - second element of current pair\\n\\nIf we look at this example `-1 -> 1 -> 2 -> 3 -> 4 -> -1`, then in the first iteration prev would be -1, cur would be 1 and next would be 2.\\n\\nAfter swapping a pair list will look like this `-1 -> 2 -> 1 -> 3 -> 4 -> -1`. Now we will have our next pair which is `3 -> 4`. So prev would be 1, curr would be at 3 and next would be at 4. \\n\\nAfter second iteration list will look like `-1 -> 2 -> 1 -> 4 -> 3 -> -1`.\\n\\nNow, The list is swapped in pairs of two elements. We just have to remove dummy head and dummy tail.\\n\\nFinal answer: `2 -> 1 -> 4 -> 3`\\n\\n**NOTE 1:** ***Odd size list handled in the code. Just emit the last element from being swapped with dummy tail.***\\n**NOTE 2:** ***Code is self explanatory.***\\n\\n### Iteration Steps Explanation\\n![image.png](https://assets.leetcode.com/users/images/2deeb1b9-a52a-4694-9bbd-6e681c855146_1684217143.7158692.png)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n    - As we are traversing list only once (ignore adding and deleting dummy head and dummy tail)\\n\\n- Space complexity: $$O(1)$$\\n    - As we have not used any space (containers) except the pointers.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // if list is null or contains one element then return the list itself (null => null & `1` => `1`)\\n        if (!head or !head->next)\\n            return head;\\n\\n        // Adding dummy head\\n        ListNode *dummyHead = new ListNode(-1);\\n        dummyHead->next = head;\\n        head = dummyHead;\\n\\n        // Adding dummy tail\\n        ListNode *dummyTail = new ListNode(-1);\\n        ListNode *ptr = head;\\n        while (ptr->next)\\n            ptr = ptr->next;\\n        ptr->next = dummyTail;\\n\\n        // assigning prev, cur and next for first iteration\\n        ListNode *prev = head, *cur = head->next, *next = head->next->next;\\n        while (next and next->val != -1)\\n        {\\n            // Check above image\\n            ListNode *nextCur = next->next; // 1\\n            prev->next = next; // 2\\n            cur->next = next->next; // 3\\n            next->next = cur; // 4\\n\\n            prev = cur; // 5\\n            cur = nextCur; // 6\\n            next = cur->next; // 7\\n        }   \\n\\n        // Remove dummy tail\\n        ListNode *remove = head;\\n        while(remove->next->val != -1)\\n            remove = remove->next;\\n        remove->next = NULL;\\n\\n        // remove dummy head\\n        return head = head->next;\\n    }\\n};\\n```\\n### Upvote if it helped you !!!\\n![image.png](https://assets.leetcode.com/users/images/58838411-f6e7-4acb-b98b-a8427e7453da_1684217764.5259085.png)\\n",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // if list is null or contains one element then return the list itself (null => null & `1` => `1`)\\n        if (!head or !head->next)\\n            return head;\\n\\n        // Adding dummy head\\n        ListNode *dummyHead = new ListNode(-1);\\n        dummyHead->next = head;\\n        head = dummyHead;\\n\\n        // Adding dummy tail\\n        ListNode *dummyTail = new ListNode(-1);\\n        ListNode *ptr = head;\\n        while (ptr->next)\\n            ptr = ptr->next;\\n        ptr->next = dummyTail;\\n\\n        // assigning prev, cur and next for first iteration\\n        ListNode *prev = head, *cur = head->next, *next = head->next->next;\\n        while (next and next->val != -1)\\n        {\\n            // Check above image\\n            ListNode *nextCur = next->next; // 1\\n            prev->next = next; // 2\\n            cur->next = next->next; // 3\\n            next->next = cur; // 4\\n\\n            prev = cur; // 5\\n            cur = nextCur; // 6\\n            next = cur->next; // 7\\n        }   \\n\\n        // Remove dummy tail\\n        ListNode *remove = head;\\n        while(remove->next->val != -1)\\n            remove = remove->next;\\n        remove->next = NULL;\\n\\n        // remove dummy head\\n        return head = head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528838,
                "title": "easy-solution-of-java-100-faster-code-beginner-friendly",
                "content": "\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n\\n```\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null)return head;\\n        ListNode d = new ListNode(0), a;\\n        d.next = head;\\n        a=d;\\n        while(head!=null&&head.next!=null) {\\n            a.next = head.next;\\n            head.next = head.next.next;\\n            a.next.next = head;\\n            a = a.next.next;\\n            head =  head.next;\\n        }\\n        return d.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null)return head;\\n        ListNode d = new ListNode(0), a;\\n        d.next = head;\\n        a=d;\\n        while(head!=null&&head.next!=null) {\\n            a.next = head.next;\\n            head.next = head.next.next;\\n            a.next.next = head;\\n            a = a.next.next;\\n            head =  head.next;\\n        }\\n        return d.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477540,
                "title": "python-recursive-solution-w-step-by-step-thought-process",
                "content": "Is the point of Leetcode to come up with intensely technical and condensed code, or is it to help us practice systematically solving problems and showing our thought process? Its the latter. This may not be the most condensed solution, but the thought process is clear and sequential.\\n\\n**Overall Thought Process**\\n1. Write out ideally how the algorithm would execute. It\\'ll be easier to see the pattern this way\\n2. Then, I look at pairs and try to come up with a pseudocode\\n3. From that, I can come up with a rough recursive algorithm. To simplify this, I\\'m not thinking of edge cases \\n4. Add in conditionals to account for edge cases\\n5. Convert algorithm into code\\n\\n<br>\\n\\n\\n**Walking through each Step**\\n\\n\\n**1. Write out ideally how the algorithm would execute. It\\'ll be easier to see the pattern this way**\\n\\n```\\nFor linked list -> 1 - 2\\n2.next = 1\\n1.next = None\\nreturn 2\\n\\nFor linked list -> 1 - 2 - 3\\n2.next = 1\\n1.next = None\\nreturn 2\\n\\nFor linked list -> 1 - 2 - 3 - 4\\n4.next = 3\\n3.next = None\\n2.next = 1\\n1.next = 4\\nreturn 2\\n\\nFor linked list -> 1 - 2 - 3 - 4 - 5\\n4.next = 3\\n3.next = 5\\n2.next = 1\\n1.next = 4\\nreturn 2\\n```\\n\\n\\n**2. Then, I look at pairs and try to come up with a pseudocode**\\n```\\nfor each pair (a, b):\\n    a.next = whatever is the first of next pair\\n    b.next = a\\n    return b\\n```\\n\\n**3. From that, I can come up with a rough recursive algorithm. To simplify this, I\\'m not thinking of edge cases yet**\\n```\\nswap_pair(head):\\n    first = head\\n    second = first.next\\n    \\n    first.next = swap_pair(second.next)\\n    second.next = first\\n    return second\\n```\\n\\n**4. Add in conditionals to account for edge cases**\\n```\\nswap_pair(head):\\n    if not head:\\n        return None\\n\\n    first = head\\n    \\n    if not first.next:\\n        return first\\n    second = first.next\\n    \\n    first.next = swap_pair(second.next)\\n    second.next = first\\n    return second\\n```\\n\\n**5. Convert algorithm into code**\\n```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if not head:\\n            return None\\n\\n        first = head\\n        if not first.next:\\n            return first\\n        second = first.next\\n\\n        first.next = self.swapPairs(second.next)\\n        second.next = first\\n        return second\\n```",
                "solutionTags": [],
                "code": "```\\nFor linked list -> 1 - 2\\n2.next = 1\\n1.next = None\\nreturn 2\\n\\nFor linked list -> 1 - 2 - 3\\n2.next = 1\\n1.next = None\\nreturn 2\\n\\nFor linked list -> 1 - 2 - 3 - 4\\n4.next = 3\\n3.next = None\\n2.next = 1\\n1.next = 4\\nreturn 2\\n\\nFor linked list -> 1 - 2 - 3 - 4 - 5\\n4.next = 3\\n3.next = 5\\n2.next = 1\\n1.next = 4\\nreturn 2\\n```\n```\\nfor each pair (a, b):\\n    a.next = whatever is the first of next pair\\n    b.next = a\\n    return b\\n```\n```\\nswap_pair(head):\\n    first = head\\n    second = first.next\\n    \\n    first.next = swap_pair(second.next)\\n    second.next = first\\n    return second\\n```\n```\\nswap_pair(head):\\n    if not head:\\n        return None\\n\\n    first = head\\n    \\n    if not first.next:\\n        return first\\n    second = first.next\\n    \\n    first.next = swap_pair(second.next)\\n    second.next = first\\n    return second\\n```\n```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if not head:\\n            return None\\n\\n        first = head\\n        if not first.next:\\n            return first\\n        second = first.next\\n\\n        first.next = self.swapPairs(second.next)\\n        second.next = first\\n        return second\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529141,
                "title": "day-411-brute-better-optimal-100-python-java-c-explained",
                "content": "\\n\\n\\n\\n# BRUTE\\n```JAVA []\\npublic ListNode swapPairs(ListNode head) {\\n        List<ListNode> list = new ArrayList<>();\\n        ListNode temNode = head;\\n        while (temNode != null) {\\n            list.add(temNode);\\n            temNode = temNode.next;\\n        }\\n        for (int i = 0; i < list.size() - 1; i += 2) {\\n            int swapElement = list.get(i).val;\\n            list.get(i).val = list.get(i + 1).val;\\n            list.get(i + 1).val = swapElement;\\n        }\\n        return head;\\n}\\n```\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe first check if the input head is null or has only one node. If so, we return the head as it is. Otherwise, we create two nodes first and second and set them to the first and second nodes of the linked list, respectively. We then recursively call the swapPairs function on the next of the second node and set the next of the first node to the result. We then swap the next pointers of the first and second nodes and return the second node.\\n\\n# BETTER\\n```JAVA []\\npublic ListNode swapPairs(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    ListNode first = head;\\n    ListNode second = head.next;\\n    first.next = swapPairs(second.next);\\n    second.next = first;\\n    return second;\\n}\\n```\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(LOG(N))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# OPTIMAL\\nWe create a dummy node and set its next to the head. We then create a current node and initialize it to the dummy node. We use a single loop to swap every two adjacent nodes. We do this by creating two nodes first and second and swapping their next pointers. We then update the current node to point to the second node and continue the loop. Finally, we return the next of the dummy node.The time complexity of this solution is O(n) as we need to traverse the entire linked list once.\\n```JAVA []\\npublic ListNode swapPairs(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    ListNode dummy = new ListNode(0);\\n    dummy.next = head;\\n    ListNode current = dummy;\\n    while (current.next != null && current.next.next != null) {\\n        ListNode first = current.next;\\n        ListNode second = current.next.next;\\n        first.next = second.next;\\n        second.next = first;\\n        current.next = second;\\n        current = current.next.next;\\n    }\\n    return dummy.next;\\n}\\n```\\n```c++ []\\nListNode* swapPairs(ListNode* head) {\\n    ListNode* dummy = new ListNode(0);\\n    dummy->next = head;\\n    ListNode* current = dummy;\\n    while (current->next != NULL && current->next->next != NULL) {\\n        ListNode* first = current->next;\\n        ListNode* second = current->next->next;\\n        first->next = second->next;\\n        second->next = first;\\n        current->next = second;\\n        current = current->next->next;\\n    }\\n    return dummy->next;\\n}\\n```\\n```python []\\ndef swapPairs(self, head: ListNode) -> ListNode:\\n    dummy = ListNode(0)\\n    dummy.next = head\\n    current = dummy\\n    while current.next and current.next.next:\\n        first = current.next\\n        second = current.next.next\\n        first.next = second.next\\n        second.next = first\\n        current.next = second\\n        current = current.next.next\\n    return dummy.next\\n```\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06 \\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```JAVA []\\npublic ListNode swapPairs(ListNode head) {\\n        List<ListNode> list = new ArrayList<>();\\n        ListNode temNode = head;\\n        while (temNode != null) {\\n            list.add(temNode);\\n            temNode = temNode.next;\\n        }\\n        for (int i = 0; i < list.size() - 1; i += 2) {\\n            int swapElement = list.get(i).val;\\n            list.get(i).val = list.get(i + 1).val;\\n            list.get(i + 1).val = swapElement;\\n        }\\n        return head;\\n}\\n```\n```JAVA []\\npublic ListNode swapPairs(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    ListNode first = head;\\n    ListNode second = head.next;\\n    first.next = swapPairs(second.next);\\n    second.next = first;\\n    return second;\\n}\\n```\n```JAVA []\\npublic ListNode swapPairs(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    ListNode dummy = new ListNode(0);\\n    dummy.next = head;\\n    ListNode current = dummy;\\n    while (current.next != null && current.next.next != null) {\\n        ListNode first = current.next;\\n        ListNode second = current.next.next;\\n        first.next = second.next;\\n        second.next = first;\\n        current.next = second;\\n        current = current.next.next;\\n    }\\n    return dummy.next;\\n}\\n```\n```c++ []\\nListNode* swapPairs(ListNode* head) {\\n    ListNode* dummy = new ListNode(0);\\n    dummy->next = head;\\n    ListNode* current = dummy;\\n    while (current->next != NULL && current->next->next != NULL) {\\n        ListNode* first = current->next;\\n        ListNode* second = current->next->next;\\n        first->next = second->next;\\n        second->next = first;\\n        current->next = second;\\n        current = current->next->next;\\n    }\\n    return dummy->next;\\n}\\n```\n```python []\\ndef swapPairs(self, head: ListNode) -> ListNode:\\n    dummy = ListNode(0)\\n    dummy.next = head\\n    current = dummy\\n    while current.next and current.next.next:\\n        first = current.next\\n        second = current.next.next\\n        first.next = second.next\\n        second.next = first\\n        current.next = second\\n        current = current.next.next\\n    return dummy.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1902446,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func swapPairs(_ head: ListNode?) -> ListNode? {\\n        if head == nil || head?.next == nil { return head }\\n        let res = head?.next\\n        head?.next = swapPairs(res?.next)\\n        res?.next = head\\n        return res\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func swapPairs(_ head: ListNode?) -> ListNode? {\\n        if head == nil || head?.next == nil { return head }\\n        let res = head?.next\\n        head?.next = swapPairs(res?.next)\\n        res?.next = head\\n        return res\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11236,
                "title": "very-easy-solution",
                "content": "    class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            ListNode *l=head;\\n            if(head&&head->next){\\n                l=head->next;\\n                head->next=swapPairs(l->next);\\n                l->next=head;\\n            }\\n            return l;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            ListNode *l=head;\\n            if(head&&head->next){\\n                l=head->next;\\n                head->next=swapPairs(l->next);\\n                l->next=head;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 300006,
                "title": "go-0-ms-faster-than-100-00-easy-code-recursion",
                "content": "```\\ntype ListNode struct {\\n\\tVal  int\\n\\tNext *ListNode\\n}\\n\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tresult := head.Next\\n\\thead.Next = swapPairs(head.Next.Next)\\n\\tresult.Next = head\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\ntype ListNode struct {\\n\\tVal  int\\n\\tNext *ListNode\\n}\\n\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tresult := head.Next\\n\\thead.Next = swapPairs(head.Next.Next)\\n\\tresult.Next = head\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 298168,
                "title": "java-clean-recursive-solution",
                "content": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        ListNode newHead = head.next;\\n        head.next = swapPairs(newHead.next);\\n        newHead.next = head;\\n        return newHead;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        ListNode newHead = head.next;\\n        head.next = swapPairs(newHead.next);\\n        newHead.next = head;\\n        return newHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278452,
                "title": "python-concise-solution",
                "content": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if not head or not head.next: return head\\n        first = head.next\\n        second = head\\n        second.next = self.swapPairs(first.next)\\n        first.next = second\\n        return first\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if not head or not head.next: return head\\n        first = head.next\\n        second = head\\n        second.next = self.swapPairs(first.next)\\n        first.next = second\\n        return first\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11361,
                "title": "share-my-accepted-java-solution",
                "content": "    public class Solution {\\n        public ListNode swapPairs(ListNode head) {\\n            if (head == null || head.next == null) {\\n                return head;\\n            }\\n            ListNode first = head, last = head.next;\\n            first.next = swapPairs(last.next);\\n            last.next = first;\\n            return last;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public ListNode swapPairs(ListNode head) {\\n            if (head == null || head.next == null) {\\n                return head;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 11216,
                "title": "my-accepted-solution-in-python-quite-fast",
                "content": "    class Solution:\\n        # @param a ListNode\\n        # @return a ListNode\\n        def swapPairs(self, head):\\n            p1 = guard = ListNode(0)\\n            guard.next = head\\n            \\n            try:\\n                while True:\\n                    p0, p1, p2 = p1, p1.next, p1.next.next\\n                    p0.next, p1.next, p2.next = p2, p2.next, p1\\n            except:\\n                return guard.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param a ListNode\\n        # @return a ListNode\\n        def swapPairs(self, head):\\n            p1 = guard = ListNode(0)\\n            guard.next = head\\n            \\n            try:\\n                while True:\\n                    p0, p1, p2 = p1, p1.next, p1.next.next\\n                    p0.next, p1.next, p2.next = p2, p2.next, p1\\n            except:\\n                return guard.next",
                "codeTag": "Java"
            },
            {
                "id": 11254,
                "title": "seeking-for-a-better-solution",
                "content": "Is someone has a better solution? My code can get AC, but I don't think it's good enough. Thanks~~\\n \\n   \\n\\n    public class Solution {\\n            public ListNode swapPairs(ListNode head) {\\n                ListNode cur = head, next1, next2;\\n                if(head == null) return null;\\n                if(head.next == null) return head;\\n                \\n                //head change with next is a special case, so we deal with it first\\n                ListNode temp = cur.next;\\n                cur.next = temp.next;\\n                temp.next = cur;\\n                head = temp;\\n                \\n            \\twhile(cur.next != null && cur.next.next != null) {\\n            \\t\\tnext1 = cur.next;\\n            \\t\\tnext2 = cur.next.next;\\n            \\t\\tswap(cur,next1,next2);\\n            \\t\\tcur = cur.next.next;\\n            \\t}\\n            \\treturn head;\\n            }\\n            \\n            private void swap(ListNode cur, ListNode next1, ListNode next2) {\\n            \\tcur.next = next2;\\n            \\tnext1.next = next2.next;\\n            \\tnext2.next = next1;\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public ListNode swapPairs(ListNode head) {\\n                ListNode cur = head, next1, next2;\\n                if(head == null) return null;\\n                if(head.next == null) return head;\\n                \\n                //head change with next is a special case, so we deal with it first\\n                ListNode temp = cur.next;\\n                cur.next = temp.next;\\n                temp.next = cur;\\n                head = temp;\\n                \\n            \\twhile(cur.next != null && cur.next.next != null) {\\n            \\t\\tnext1 = cur.next;\\n            \\t\\tnext2 = cur.next.next;\\n            \\t\\tswap(cur,next1,next2);\\n            \\t\\tcur = cur.next.next;\\n            \\t}",
                "codeTag": "Java"
            },
            {
                "id": 2596746,
                "title": "straightforward-0ms-iterative-solution-with-comments",
                "content": "Introduced 2 macros to make the algo more clear: one taking .next node as reference, and one as mutable\\n\\n```\\nmacro_rules! next_node_as_ref {\\n    ($a: expr) => {\\n        $a.as_ref().unwrap().next\\n    };\\n}\\nmacro_rules! next_node_as_mut {\\n    ($a: expr) => {\\n        $a.as_mut().unwrap().next\\n    };\\n}\\nimpl Solution {\\n    pub fn swap_pairs(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        if head.is_none() {\\n            return None;\\n        }\\n        let mut cur_node = &mut head;\\n\\n        // while we have something to work with (.next has something)\\n        while cur_node.is_some() && next_node_as_ref!(cur_node).is_some() {\\n            // .take() Takes the value out of the option, leaving a None in its place.\\n            let mut even_node = next_node_as_mut!(cur_node).take();\\n\\n            // taking next odd node\\'s value\\n            let next_odd_node = next_node_as_mut!(even_node).take();\\n            // cur_node\\'s .next points to next odd node\\n            next_node_as_mut!(cur_node) = next_odd_node;\\n            // even node\\'s .next points to cur_node\\n            next_node_as_mut!(even_node) = cur_node.take();\\n            // switching cur_node with even node\\n            cur_node.replace(even_node.unwrap());\\n            // point cursor to .next.next\\n            cur_node = &mut next_node_as_mut!(next_node_as_mut!(cur_node));\\n        }\\n        head\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nmacro_rules! next_node_as_ref {\\n    ($a: expr) => {\\n        $a.as_ref().unwrap().next\\n    };\\n}\\nmacro_rules! next_node_as_mut {\\n    ($a: expr) => {\\n        $a.as_mut().unwrap().next\\n    };\\n}\\nimpl Solution {\\n    pub fn swap_pairs(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        if head.is_none() {\\n            return None;\\n        }\\n        let mut cur_node = &mut head;\\n\\n        // while we have something to work with (.next has something)\\n        while cur_node.is_some() && next_node_as_ref!(cur_node).is_some() {\\n            // .take() Takes the value out of the option, leaving a None in its place.\\n            let mut even_node = next_node_as_mut!(cur_node).take();\\n\\n            // taking next odd node\\'s value\\n            let next_odd_node = next_node_as_mut!(even_node).take();\\n            // cur_node\\'s .next points to next odd node\\n            next_node_as_mut!(cur_node) = next_odd_node;\\n            // even node\\'s .next points to cur_node\\n            next_node_as_mut!(even_node) = cur_node.take();\\n            // switching cur_node with even node\\n            cur_node.replace(even_node.unwrap());\\n            // point cursor to .next.next\\n            cur_node = &mut next_node_as_mut!(next_node_as_mut!(cur_node));\\n        }\\n        head\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11132,
                "title": "very-simple-c-recursive-solution",
                "content": "    class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            if (head == NULL || head->next == NULL) return head;\\n            ListNode *grandChild = swapPairs(head->next->next);\\n            ListNode *child = head->next;\\n            child->next = head;\\n            head->next = grandChild;\\n            return child;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            if (head == NULL || head->next == NULL) return head;\\n            ListNode *grandChild = swapPairs(head->next->next);\\n            ListNode *child = head->next;\\n            child->next = head;\\n            head->next = grandChild;\\n            return child;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1788868,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode tHead = swapPairs(head.next.next);\\n        ListNode temp = head.next;\\n        head.next = tHead;\\n        temp.next = head;\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode tHead = swapPairs(head.next.next);\\n        ListNode temp = head.next;\\n        head.next = tHead;\\n        temp.next = head;\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776487,
                "title": "javascript-time-o-n-space-o-1-simple-approach-with-explanation",
                "content": "1. Check if we have current and next Node or not.\\n2. Do simple swapping using temp variable.\\n3. Take a temporary variable and store value of first node into that.\\n4. Take value of second node and store in first node\\n5. Move to second node and replace value of second node by temp.\\n6. repeat the swapping till end of linked list.\\n\\n```\\nvar swapPairs = function(head) {\\n    let start = new ListNode();  // Taking a pointer for keeping head of linked list safe with us\\n    start = head;  // storing head into result as we\\'ll be updating head further.\\n    while(head != undefined && head.next != undefined){  //loop for itterating through linked list\\n        let temp = head.val;                              // swapping\\n        head.val = head.next.val;                     // swapping\\n        head = head.next;                               // swapping\\n        head.val = temp;                                // swapping\\n        head = head.next;                            // increasing the pointer to next element\\n    }\\n    return start;       // return the starting point of linked list as we modified the same linked list.\\n};\\n```\\n\\nFeel free to comment down if doubts on any steps.\\n\\n**Upvote** if helped.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar swapPairs = function(head) {\\n    let start = new ListNode();  // Taking a pointer for keeping head of linked list safe with us\\n    start = head;  // storing head into result as we\\'ll be updating head further.\\n    while(head != undefined && head.next != undefined){  //loop for itterating through linked list\\n        let temp = head.val;                              // swapping\\n        head.val = head.next.val;                     // swapping\\n        head = head.next;                               // swapping\\n        head.val = temp;                                // swapping\\n        head = head.next;                            // increasing the pointer to next element\\n    }\\n    return start;       // return the starting point of linked list as we modified the same linked list.\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1517929,
                "title": "c-two-soltn-0-ms-faster-than-100-00",
                "content": "**Soln 1**\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if(head==0)\\n            return NULL;\\n        if(head->next==0)\\n            return head;\\n        \\n        \\n        ListNode *first=head;\\n        ListNode *second=first->next;\\n        ListNode *newhead=second;\\n        ListNode *prev=first;\\n        while(first && second)\\n        {\\n            prev=first;\\n            first->next=second->next;\\n            second->next=prev;\\n            \\n            first=first->next;\\n            if(first!=0 && first->next!=0)\\n             second=first->next;\\n            else\\n                break;\\n            prev->next=second;\\n            \\n        }\\n        return newhead;\\n        \\n    }\\n};\\n```\\n\\n**Soln 2**\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        ListNode *temp=new ListNode(0);\\n        temp->next=head;\\n        ListNode *curr=temp;\\n        \\n        while(curr->next && curr->next->next)\\n        {\\n            ListNode *first=curr->next;\\n            ListNode *second=curr->next->next;\\n            first->next=second->next;\\n            second->next=first;\\n            curr->next=second;\\n            curr=curr->next->next;\\n        }\\n        return temp->next;\\n        \\n    }\\n};\\n```\\n\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if(head==0)\\n            return NULL;\\n        if(head->next==0)\\n            return head;\\n        \\n        \\n        ListNode *first=head;\\n        ListNode *second=first->next;\\n        ListNode *newhead=second;\\n        ListNode *prev=first;\\n        while(first && second)\\n        {\\n            prev=first;\\n            first->next=second->next;\\n            second->next=prev;\\n            \\n            first=first->next;\\n            if(first!=0 && first->next!=0)\\n             second=first->next;\\n            else\\n                break;\\n            prev->next=second;\\n            \\n        }\\n        return newhead;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        ListNode *temp=new ListNode(0);\\n        temp->next=head;\\n        ListNode *curr=temp;\\n        \\n        while(curr->next && curr->next->next)\\n        {\\n            ListNode *first=curr->next;\\n            ListNode *second=curr->next->next;\\n            first->next=second->next;\\n            second->next=first;\\n            curr->next=second;\\n            curr=curr->next->next;\\n        }\\n        return temp->next;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549794,
                "title": "3-solutions-easy-to-understand-faster-2-iterative-and-1-recursive-python",
                "content": "```\\ndef recursive(self, head):\\n        def rec(head):\\n            if head and head.next:\\n                rep = rec(head.next.next)\\n                second = head.next\\n                first = head\\n                if second:\\n                    first.next = rep\\n                    second.next = first\\n                    return second\\n                return first\\n            elif head: return head\\n            \\n        return rec(head)\\n    \\n    def in_place_nodes(self, head):\\n        if not head: return head\\n        prev = None\\n        first = head\\n        second = head.next\\n        while first and second:\\n            if prev:\\n                prev.next = second\\n            else:\\n                head = second\\n            forward = second.next\\n            first.next = second.next\\n            second.next = first\\n            prev = first\\n            first = forward\\n            if not first: break\\n            second = first.next\\n        return head\\n    \\n        \\n    def in_place_value(self, head):\\n        if not head: return head\\n        first = head\\n        second = head.next\\n        while first and second:\\n            first.val, second.val = second.val, first.val\\n            first = second.next\\n            if not first: break\\n            second = second.next.next\\n        return head\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef recursive(self, head):\\n        def rec(head):\\n            if head and head.next:\\n                rep = rec(head.next.next)\\n                second = head.next\\n                first = head\\n                if second:\\n                    first.next = rep\\n                    second.next = first\\n                    return second\\n                return first\\n            elif head: return head\\n            \\n        return rec(head)\\n    \\n    def in_place_nodes(self, head):\\n        if not head: return head\\n        prev = None\\n        first = head\\n        second = head.next\\n        while first and second:\\n            if prev:\\n                prev.next = second\\n            else:\\n                head = second\\n            forward = second.next\\n            first.next = second.next\\n            second.next = first\\n            prev = first\\n            first = forward\\n            if not first: break\\n            second = first.next\\n        return head\\n    \\n        \\n    def in_place_value(self, head):\\n        if not head: return head\\n        first = head\\n        second = head.next\\n        while first and second:\\n            first.val, second.val = second.val, first.val\\n            first = second.next\\n            if not first: break\\n            second = second.next.next\\n        return head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 11078,
                "title": "easy-understand-3-lines-solutions-with-comments",
                "content": "before '=': the first node, the second and  the third node\\nafter '='   : the second node, the first  and  the third node returned by recursion.\\n\\n```\\ndef swapPairs(self, head):\\n        if head and head.next:\\n            head, head.next, head.next.next = head.next, head, self.swapPairs(head.next.next)\\n        return head",
                "solutionTags": [],
                "code": "before '=': the first node, the second and  the third node\\nafter '='   : the second node, the first  and  the third node returned by recursion.\\n\\n```\\ndef swapPairs(self, head):\\n        if head and head.next:\\n            head, head.next, head.next.next = head.next, head, self.swapPairs(head.next.next)\\n        return head",
                "codeTag": "Python3"
            },
            {
                "id": 11204,
                "title": "java-recursive-and-iterative-solutions",
                "content": "        \\n    // recursively \\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode nxt = head.next;\\n        head.next = swapPairs(nxt.next);\\n        nxt.next = head;\\n        return nxt;\\n    }\\n    \\n    // iteratively\\n    public ListNode swapPairs1(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode pre = new ListNode(0), p = head, ret = head.next;\\n        while (p != null && p.next != null) {\\n            ListNode nxt = p.next;\\n            p.next = nxt.next;\\n            nxt.next = p;\\n            pre.next = nxt;\\n            pre = p;\\n            p = p.next;\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    // recursively \\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode nxt = head.next;\\n        head.next = swapPairs(nxt.next);\\n        nxt.next = head;\\n        return nxt;\\n    }\\n    \\n    // iteratively\\n    public ListNode swapPairs1(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode pre = new ListNode(0), p = head, ret = head.next;\\n        while (p != null && p.next != null) {\\n            ListNode nxt = p.next;\\n            p.next = nxt.next;\\n            nxt.next = p;\\n            pre.next = nxt;\\n            pre = p;\\n            p = p.next;\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2774348,
                "title": "in-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    if(head==NULL || head->next==NULL)\\n    return head;\\n    struct ListNode*x,*y,*z=NULL;\\n    x=head;\\n    y=head->next;\\n    if(head->next->next!=NULL)\\n    {\\n        z=head->next->next;\\n    }\\n    head=y;\\n    while(z!=NULL && z->next!=NULL)\\n    {\\n        y->next=x;\\n        x->next=z->next;\\n        x=z;\\n        y=x->next;\\n        z=y->next;\\n    }\\n    y->next=x;\\n    x->next=z;\\n    return head;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    if(head==NULL || head->next==NULL)\\n    return head;\\n    struct ListNode*x,*y,*z=NULL;\\n    x=head;\\n    y=head->next;\\n    if(head->next->next!=NULL)\\n    {\\n        z=head->next->next;\\n    }\\n    head=y;\\n    while(z!=NULL && z->next!=NULL)\\n    {\\n        y->next=x;\\n        x->next=z->next;\\n        x=z;\\n        y=x->next;\\n        z=y->next;\\n    }\\n    y->next=x;\\n    x->next=z;\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1775417,
                "title": "iterative-solution-with-tuples-and-no-recursion",
                "content": "Pointer swapping can be done in a modern way using tuples:\\n```csharp\\npublic class Solution\\n{\\n    public ListNode SwapPairs(ListNode head)\\n    {\\n        ListNode prev = new();\\n        var a = head;\\n        var b = head?.next;\\n\\n        head = b ?? a;\\n\\n        while (a != null && b != null)\\n        {\\n            (prev.next, a.next, b.next) = (b, b.next, a); //swap the nodes\\n            (prev, a, b) = (a, a.next, a.next?.next); //move on\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Iterator"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public ListNode SwapPairs(ListNode head)\\n    {\\n        ListNode prev = new();\\n        var a = head;\\n        var b = head?.next;\\n\\n        head = b ?? a;\\n\\n        while (a != null && b != null)\\n        {\\n            (prev.next, a.next, b.next) = (b, b.next, a); //swap the nodes\\n            (prev, a, b) = (a, a.next, a.next?.next); //move on\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233188,
                "title": "my-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head)return head;\\n        if(!head->next)return head;\\n        ListNode temp(0);\\n        temp.next = head;\\n        ListNode* current = &temp;\\n        while(current->next!=NULL && current->next->next!=NULL){\\n            ListNode* first = current->next;\\n            ListNode* second = current->next->next;\\n            first->next = second->next;\\n            current->next = second;\\n            current->next->next = first;\\n            current = current->next->next;\\n        }\\n        return temp.next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head)return head;\\n        if(!head->next)return head;\\n        ListNode temp(0);\\n        temp.next = head;\\n        ListNode* current = &temp;\\n        while(current->next!=NULL && current->next->next!=NULL){\\n            ListNode* first = current->next;\\n            ListNode* second = current->next->next;\\n            first->next = second->next;\\n            current->next = second;\\n            current->next->next = first;\\n            current = current->next->next;\\n        }\\n        return temp.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 231784,
                "title": "javascript-recursion-solution",
                "content": "```\\nvar swapPairs = function(head) {\\n  // base case\\n  if (head === null || head.next === null) return head;\\n  let temp = head.next;\\n  head.next = temp.next;\\n  temp.next = head;\\n  head.next = swapPairs(head.next);\\n  return temp;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar swapPairs = function(head) {\\n  // base case\\n  if (head === null || head.next === null) return head;\\n  let temp = head.next;\\n  head.next = temp.next;\\n  temp.next = head;\\n  head.next = swapPairs(head.next);\\n  return temp;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11094,
                "title": "simple-0ms-c-solution-beats-98-08",
                "content": "All we need to do is rearrange the links in the list.If <b>prev </b> is the pevious node,<b> head </b> is the current node,at every alternate node perform operations such that <br>\\nInitial:           prev | head | head->next|head->next->next\\nAfter swap:prev|head->next|head|head->next->next\\n\\n```\\n ListNode* swapPairs(ListNode* head) {\\n        ListNode* dummy=new ListNode(0);\\n        dummy->next=head;\\n        ListNode* prev=dummy;\\n        while(head &&head->next)\\n        {\\n            ListNode* nn=head->next->next;\\n            prev->next=head->next;\\n            head->next->next=head;\\n            head->next=nn;\\n            prev=head;\\n            head=nn;\\n           \\n        }\\n        return dummy->next;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n ListNode* swapPairs(ListNode* head) {\\n        ListNode* dummy=new ListNode(0);\\n        dummy->next=head;\\n        ListNode* prev=dummy;\\n        while(head &&head->next)\\n        {\\n            ListNode* nn=head->next->next;\\n            prev->next=head->next;\\n            head->next->next=head;\\n            head->next=nn;\\n            prev=head;\\n            head=nn;\\n           \\n        }\\n        return dummy->next;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11266,
                "title": "python-solution-using-36ms-with-simple-method",
                "content": "\\nclass Solution(object):\\n\\n    def swapPairs(self, head):\\n\\n        if not head or not head.next:\\n            return head\\n      \\n        first,second = head, head.next\\n        third = second.next\\n        head = second\\n        second.next = first\\n        first.next = self.swapPairs(third)\\n        \\n        return head",
                "solutionTags": [],
                "code": "\\nclass Solution(object):\\n\\n    def swapPairs(self, head):\\n\\n        if not head or not head.next:\\n            return head\\n      \\n        first,second = head, head.next\\n        third = second.next\\n        head = second\\n        second.next = first\\n        first.next = self.swapPairs(third)\\n        \\n        return head",
                "codeTag": "Java"
            },
            {
                "id": 3532106,
                "title": "5-lines-0ms-easy-approach-beasts-100-stepped-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we are using a very simple and easy ***recursive*** approach to solve this\\n\\n\\n**Steps:**\\n\\n1. At first we will check, if head value is null we will return null.\\n\\n    `if(head==null) return null;`\\n2. Then we check, if next head value is null we will return current head.\\n\\n    `if (head.next == null) return head;`\\n3. Later we will swap the 2 value of by creating a temp variable & recursively swapping the values.\\n    \\n    - Storing the next head to a temp ListNode that we will return at last. `ListNode temp = head.next;`\\n    - Then we  get the call the function recursively for next head. \\n     `head.next = swapPairs(temp.next);`\\n    - Then we swap value next temp with the head.\\n     `temp.next = head;`\\n4. At last we will return the temp ListNode we created .\\n \\n    `return temp;`\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        if(head==null) return null;\\n        if (head.next == null) return head;\\n\\n        ListNode temp = head.next;\\n        head.next = swapPairs(temp.next);\\n        temp.next = head;\\n\\n        return temp;\\n    }\\n}\\n```\\n\\n<!-- ---\\n**Iterative** \\n```\\npublic ListNode swapPairs1(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    ListNode pre = new ListNode(0), p = head, ret = head.next;\\n    while (p != null && p.next != null) {\\n        ListNode nxt = p.next;\\n        p.next = nxt.next;\\n        nxt.next = p;\\n        pre.next = nxt;\\n        pre = p;\\n        p = p.next;\\n    }\\n    return ret;\\n}\\n``` -->\\n\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/e835e6d0-5193-493a-9394-e4e90c90e1b0_1684266894.6208477.jpeg)\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        if(head==null) return null;\\n        if (head.next == null) return head;\\n\\n        ListNode temp = head.next;\\n        head.next = swapPairs(temp.next);\\n        temp.next = head;\\n\\n        return temp;\\n    }\\n}\\n```\n```\\npublic ListNode swapPairs1(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    ListNode pre = new ListNode(0), p = head, ret = head.next;\\n    while (p != null && p.next != null) {\\n        ListNode nxt = p.next;\\n        p.next = nxt.next;\\n        nxt.next = p;\\n        pre.next = nxt;\\n        pre = p;\\n        p = p.next;\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530416,
                "title": "c-recursive-solution-to-swap-nodes-in-pairs-dlc-16-05-2023-all-testcases-passed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst intuition that comes to mind is that swap the pairs of nodes and modify the next pointers for each pair of nodes.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe basic ideology of recursion\\n\"Solve the first case, other cases will be handled by Recursion.\"\\n\\nHere, solve for the first pair of nodes, i.e., swap the first two nodes and modify their next pointers. First node will now point to the node where second node was pointing to and second node will point to the first node.\\n\\nCall the function recursively and store the head (first) node of the remaining part of the linked list in the next pointer of the first node.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head == NULL || head->next==NULL){\\n            return head;\\n        }\\n\\n        ListNode* temp1 = head;\\n        ListNode* temp2 = head->next;\\n\\n        temp1->next = temp2->next;\\n        temp2->next = temp1;\\n\\n        if (temp1->next!=NULL){\\n            temp1->next = swapPairs(temp1->next);\\n        }\\n\\n        return temp2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head == NULL || head->next==NULL){\\n            return head;\\n        }\\n\\n        ListNode* temp1 = head;\\n        ListNode* temp2 = head->next;\\n\\n        temp1->next = temp2->next;\\n        temp2->next = temp1;\\n\\n        if (temp1->next!=NULL){\\n            temp1->next = swapPairs(temp1->next);\\n        }\\n\\n        return temp2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471758,
                "title": "c-very-easy-solution-100-beat",
                "content": "\\nclass Solution {\\npublic:\\n\\n    ListNode* swapPairs(ListNode* head) {\\n        // base case \\n        if(head == NULL){\\n            return NULL;\\n        }\\n        \\n        ListNode* forward = NULL;\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        int count = 0;\\n        while(curr != NULL && count < 2){\\n             forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n        \\n        if(forward != NULL){\\n            head->next = swapPairs(forward);\\n        }\\n        //sb hogya abb return krde \\n        return prev;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n\\n    ListNode* swapPairs(ListNode* head) {\\n        // base case \\n        if(head == NULL){\\n            return NULL;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3310367,
                "title": "java-three-line-solution-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ni have used basic concept of linkedlist and recursive call\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head==null||head.next==null){\\n            return head;\\n        }\\n        ListNode prv=head;\\n        ListNode curr=head.next;\\n        ListNode next=head.next.next;\\n        head=curr;\\n        head.next=prv;\\n        head.next.next=swapPairs(next);\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head==null||head.next==null){\\n            return head;\\n        }\\n        ListNode prv=head;\\n        ListNode curr=head.next;\\n        ListNode next=head.next.next;\\n        head=curr;\\n        head.next=prv;\\n        head.next.next=swapPairs(next);\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430680,
                "title": "c-code-without-finding-length-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* hp = head;\\n        int x = 0;\\n        while(hp!=nullptr && hp->next!=nullptr){\\n            if(x%2==0){\\n              swap(hp->val , hp->next->val);\\n            }\\n            x++;\\n            hp = hp->next;\\n        }\\n        return head;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* hp = head;\\n        int x = 0;\\n        while(hp!=nullptr && hp->next!=nullptr){\\n            if(x%2==0){\\n              swap(hp->val , hp->next->val);\\n            }\\n            x++;\\n            hp = hp->next;\\n        }\\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1795879,
                "title": "simple-c-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* dummy = new ListNode(0, head);\\n        ListNode *prev = dummy, *cur = head;\\n\\n        while(cur && cur->next) {\\n        \\t// save pointers\\n        \\tListNode* nxtPair = cur->next->next;\\n        \\tListNode* second = cur->next;\\n\\n        \\t// reverse this pair\\n        \\tsecond->next = cur;\\n        \\tcur->next = nxtPair;\\n        \\tprev->next = second;\\n\\n        \\t// update pointers\\n        \\tprev = cur;\\n        \\tcur = nxtPair;\\n        }\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* dummy = new ListNode(0, head);\\n        ListNode *prev = dummy, *cur = head;\\n\\n        while(cur && cur->next) {\\n        \\t// save pointers\\n        \\tListNode* nxtPair = cur->next->next;\\n        \\tListNode* second = cur->next;\\n\\n        \\t// reverse this pair\\n        \\tsecond->next = cur;\\n        \\tcur->next = nxtPair;\\n        \\tprev->next = second;\\n\\n        \\t// update pointers\\n        \\tprev = cur;\\n        \\tcur = nxtPair;\\n        }\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774481,
                "title": "c-recursive-solutions-faster-than-100-00-of-submissions",
                "content": "class Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n      if(head==NULL || head->next == NULL)\\n            return head;\\n        ListNode *temp = head->next;\\n        head->next = swapPairs(temp->next);\\n        temp->next = head;\\n        return temp;  \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n      if(head==NULL || head->next == NULL)\\n            return head;\\n        ListNode *temp = head->next;\\n        head->next = swapPairs(temp->next);\\n        temp->next = head;\\n        return temp;  \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1133526,
                "title": "js-iterative-and-recursive-w-explanation",
                "content": "Iterative Method\\n```\\nvar swapPairs = function(head) {\\n    if (head == null || head.next == null) return head\\n    \\n    // create a dummy to keep track of the new linked list\\n    let dummy = new ListNode(0, null)\\n    // tail would keep track of the dummy and move as it link more nodes\\n    let tail = dummy\\n    \\n    while (head != null && head.next != null) {\\n        let currHead = head\\n        let nextHead = head.next\\n        let skipHead = head.next.next    \\n        \\n        // reverse the second node with the first node\\n        nextHead.next = currHead\\n        currHead.next = null\\n        \\n        // nextHead = [2,1]\\n        tail.next = nextHead\\n        // dummy = [0,2,1] so tail = [1]\\n        tail = tail.next.next\\n        // point the head to the next part so it can reverse and repeat again\\n        head = skipHead\\n    }\\n    \\n    // this is for odd amount of nodes\\n    // since previous is tail.next = nextHead, which skips 2\\n    // for even, it won\\'t affect it\\n    tail.next = head\\n    \\n    // dummy.next holds the newly reversed linked list\\n    return dummy.next\\n};\\n```\\n\\n\\nRecursive Method\\n```\\nvar swapPairs = function(head) {\\n    if (head == null || head.next == null) return head\\n    \\n    let currHead = head\\n    let nextHead = head.next\\n    let skipHead = head.next.next\\n    \\n    // relink the second node to the first node\\n    nextHead.next = currHead\\n    \\n    // the firstNode\\'s next would be the result of the swap\\n    currHead.next = swapPairs(skipHead)\\n    \\n    // nextHead targets the 2nd node, which would be the first node if it reversed\\n    return nextHead\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvar swapPairs = function(head) {\\n    if (head == null || head.next == null) return head\\n    \\n    // create a dummy to keep track of the new linked list\\n    let dummy = new ListNode(0, null)\\n    // tail would keep track of the dummy and move as it link more nodes\\n    let tail = dummy\\n    \\n    while (head != null && head.next != null) {\\n        let currHead = head\\n        let nextHead = head.next\\n        let skipHead = head.next.next    \\n        \\n        // reverse the second node with the first node\\n        nextHead.next = currHead\\n        currHead.next = null\\n        \\n        // nextHead = [2,1]\\n        tail.next = nextHead\\n        // dummy = [0,2,1] so tail = [1]\\n        tail = tail.next.next\\n        // point the head to the next part so it can reverse and repeat again\\n        head = skipHead\\n    }\\n    \\n    // this is for odd amount of nodes\\n    // since previous is tail.next = nextHead, which skips 2\\n    // for even, it won\\'t affect it\\n    tail.next = head\\n    \\n    // dummy.next holds the newly reversed linked list\\n    return dummy.next\\n};\\n```\n```\\nvar swapPairs = function(head) {\\n    if (head == null || head.next == null) return head\\n    \\n    let currHead = head\\n    let nextHead = head.next\\n    let skipHead = head.next.next\\n    \\n    // relink the second node to the first node\\n    nextHead.next = currHead\\n    \\n    // the firstNode\\'s next would be the result of the swap\\n    currHead.next = swapPairs(skipHead)\\n    \\n    // nextHead targets the 2nd node, which would be the first node if it reversed\\n    return nextHead\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 717219,
                "title": "go-golang-two-solutions",
                "content": ">Runtime: 0 ms, faster than 100.00% of Go online submissions for Swap Nodes in Pairs.\\nMemory Usage: 2.1 MB, less than 13.25% of Go online submissions for Swap Nodes in Pairs.\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n    ans := &ListNode{0, head}\\n    dummy := ans\\n    for dummy.Next != nil && dummy.Next.Next != nil {\\n        a := dummy.Next\\n        b := dummy.Next.Next\\n        a.Next = b.Next\\n        dummy.Next = b\\n        dummy.Next.Next = a\\n        dummy = dummy.Next.Next\\n    }\\n    return ans.Next\\n}\\n```\\n\\n>Runtime: 0 ms, faster than 100.00% of Go online submissions for Swap Nodes in Pairs.\\nMemory Usage: 2.1 MB, less than 99.40% of Go online submissions for Swap Nodes in Pairs.\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n    if head == nil || head.Next == nil { return head }\\n    tmp := head.Next\\n    head.Next = swapPairs(head.Next.Next)\\n    tmp.Next = head\\n    return tmp\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n    ans := &ListNode{0, head}\\n    dummy := ans\\n    for dummy.Next != nil && dummy.Next.Next != nil {\\n        a := dummy.Next\\n        b := dummy.Next.Next\\n        a.Next = b.Next\\n        dummy.Next = b\\n        dummy.Next.Next = a\\n        dummy = dummy.Next.Next\\n    }\\n    return ans.Next\\n}\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n    if head == nil || head.Next == nil { return head }\\n    tmp := head.Next\\n    head.Next = swapPairs(head.Next.Next)\\n    tmp.Next = head\\n    return tmp\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 580838,
                "title": "python-js-java-c-o-n-recursive-sol-w-visualization",
                "content": "Python/Java/JS/C++ O(n) recusrion sol.\\n\\n[Tutorial video to Swap nodes in pairs [ Chinese \\u4E2D\\u6587\\u8B1B\\u89E3\\u5F71\\u7247]](https://youtu.be/DIHuNQ-PQZg)\\n\\n---\\n\\n**Visualization**\\n\\n1. Reverse next node linkage\\n```\\nnext_node.next = node\\n```\\n  \\n2. Update node linkage to next pair\\n```\\nnode.next = helper( next_pair)\\n```\\n![image.png](https://assets.leetcode.com/users/images/b903dd7c-983c-44c2-8166-289928c97fff_1684213084.129816.png)\\n\\n\\n---\\n\\n**Hint**:\\n\\nRecurvisely reverse each pair and build new linkage between reversed pairs.\\n\\n---\\n\\n**Implementation** by Python:\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        \\n        cur = head\\n               \\n        try:\\n            \\n            # locate head of next pair\\n            next_pair = cur.next.next\\n            \\n            # reverse next pair\\n            junction = self.swapPairs( next_pair )\\n            \\n            # reverse current pair\\n            original_next = cur.next\\n            \\n            original_next.next = cur\\n            \\n            # build new linkage from current pair to next pair\\n            cur.next = junction\\n            \\n            return original_next\\n            \\n        except:\\n            \\n            # Base case:\\n            # Either one node or None remaining\\n            return cur\\n\\n```\\n\\n---\\n\\nShare another implementation:\\n\\n```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        def helper( node ):\\n\\n            # Base case: empty node, or only one node\\n            if not node or not node.next:\\n                return node\\n\\n\\n            # General case:\\n            next_node = node.next\\n            next_pair = next_node.next\\n\\n            # Reverse next node linkage\\n            next_node.next = node\\n\\n            # Update node linkage to next pair\\n            node.next = helper( next_pair)\\n\\n            # return new head after swap\\n            return next_node\\n        \\n        # ------------------------------\\n\\n        return helper( head )\\n```\\n\\n---\\n\\n**Implementation** by Java:\\n\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        if( head == null || head.next == null){\\n            \\n            // base case aka stop condition\\n            return head;\\n        }\\n        \\n        // backup original pointer\\n        ListNode right = head.next;\\n        ListNode nextHop = right.next;\\n        \\n        // reverse linkage of current pair\\n        right.next = head;\\n            \\n        // reverse next pair and get the node of current head\\'s next node\\n        head.next = swapPairs( nextHop );\\n            \\n        return right;\\n        \\n    }\\n}\\n```\\n\\n---\\n\\n**Implementation** by C++\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if( head == nullptr || head->next == nullptr ){\\n            \\n            // base case aka stop condition\\n            return head;\\n        }\\n        \\n        // backup original node\\n        ListNode *right = head->next, *nextPair = head->next->next;\\n        \\n        // reverse current pair\\n        right->next = head;\\n        \\n        // swap next pair recursively\\n        head->next = swapPairs( nextPair );\\n        \\n        return right;\\n        \\n    }\\n};\\n```\\n\\n---\\n\\n**Implementation** by Javascript:\\n\\n```\\nvar swapPairs = function(head) {\\n    \\n    if( head == null || head.next == null ){\\n        \\n        // Base case aka stop condition\\n        return head;\\n    }\\n    \\n    // General cases:\\n    let [right, nextPair] = [head.next, head.next.next];\\n    \\n    // Reverse current pair\\n    right.next = head;\\n    \\n    // Reverse next pair recursively\\n    head.next = swapPairs( nextPair );\\n    \\n    return right;\\n    \\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\nnext_node.next = node\\n```\n```\\nnode.next = helper( next_pair)\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        \\n        cur = head\\n               \\n        try:\\n            \\n            # locate head of next pair\\n            next_pair = cur.next.next\\n            \\n            # reverse next pair\\n            junction = self.swapPairs( next_pair )\\n            \\n            # reverse current pair\\n            original_next = cur.next\\n            \\n            original_next.next = cur\\n            \\n            # build new linkage from current pair to next pair\\n            cur.next = junction\\n            \\n            return original_next\\n            \\n        except:\\n            \\n            # Base case:\\n            # Either one node or None remaining\\n            return cur\\n\\n```\n```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        def helper( node ):\\n\\n            # Base case: empty node, or only one node\\n            if not node or not node.next:\\n                return node\\n\\n\\n            # General case:\\n            next_node = node.next\\n            next_pair = next_node.next\\n\\n            # Reverse next node linkage\\n            next_node.next = node\\n\\n            # Update node linkage to next pair\\n            node.next = helper( next_pair)\\n\\n            # return new head after swap\\n            return next_node\\n        \\n        # ------------------------------\\n\\n        return helper( head )\\n```\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        if( head == null || head.next == null){\\n            \\n            // base case aka stop condition\\n            return head;\\n        }\\n        \\n        // backup original pointer\\n        ListNode right = head.next;\\n        ListNode nextHop = right.next;\\n        \\n        // reverse linkage of current pair\\n        right.next = head;\\n            \\n        // reverse next pair and get the node of current head\\'s next node\\n        head.next = swapPairs( nextHop );\\n            \\n        return right;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if( head == nullptr || head->next == nullptr ){\\n            \\n            // base case aka stop condition\\n            return head;\\n        }\\n        \\n        // backup original node\\n        ListNode *right = head->next, *nextPair = head->next->next;\\n        \\n        // reverse current pair\\n        right->next = head;\\n        \\n        // swap next pair recursively\\n        head->next = swapPairs( nextPair );\\n        \\n        return right;\\n        \\n    }\\n};\\n```\n```\\nvar swapPairs = function(head) {\\n    \\n    if( head == null || head.next == null ){\\n        \\n        // Base case aka stop condition\\n        return head;\\n    }\\n    \\n    // General cases:\\n    let [right, nextPair] = [head.next, head.next.next];\\n    \\n    // Reverse current pair\\n    right.next = head;\\n    \\n    // Reverse next pair recursively\\n    head.next = swapPairs( nextPair );\\n    \\n    return right;\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273702,
                "title": "python-solution-in-place",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if head and head.next:\\n            dummy = head\\n            head = head.next\\n            dummy.next = head.next\\n            head.next = dummy\\n            head.next.next = self.swapPairs(head.next.next)\\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if head and head.next:\\n            dummy = head\\n            head = head.next\\n            dummy.next = head.next\\n            head.next = dummy\\n            head.next.next = self.swapPairs(head.next.next)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11194,
                "title": "java-recursive-and-iterative-solutions-both-cost-0ms",
                "content": "Recursive:\\n\\n    public ListNode swapPairs(ListNode head) {\\n    \\t\\tif (head == null || head.next == null) \\n    \\t\\t\\treturn head;\\n    \\t\\tListNode p1 = head, p2 = head.next, p3 = p2.next;\\n    \\t\\tp1.next = p3;\\n    \\t\\tp2.next = p1;\\n    \\t\\t\\n    \\t\\tif (p3 != null) {\\n    \\t\\t\\tp1.next = swapPairs(p3);\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn p2;\\n    \\t}\\n\\nIterative:\\n\\n    public ListNode swapPairs(ListNode head) {\\n    \\t\\tif (head == null || head.next == null)\\n    \\t\\t\\treturn head;\\n    \\t\\tListNode curr = head;\\n    \\t\\tListNode next = head.next;\\n    \\t\\tListNode newHead = next;\\n    \\t\\t\\n    \\t\\tcurr.next = next.next;\\n    \\t\\tnext.next = curr;\\n    \\t\\t\\n    \\t\\tif (curr.next == null)\\n    \\t\\t\\treturn newHead;\\n    \\t\\t\\n    \\t\\twhile (curr.next.next != null) {\\n    \\t\\t\\tListNode prev = curr;\\n    \\t\\t\\tcurr = curr.next;\\n    \\t\\t\\tnext = curr.next;\\n    \\t\\t\\n    \\t\\t\\tprev.next = next;\\n    \\t\\t\\tcurr.next = next.next;\\n    \\t\\t\\tnext.next = curr;\\n    \\t\\t\\t\\n    \\t\\t\\tif (curr.next == null || curr.next.next == null)\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn newHead;\\n    \\t}",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "Recursive:\\n\\n    public ListNode swapPairs(ListNode head) {\\n    \\t\\tif (head == null || head.next == null) \\n    \\t\\t\\treturn head;\\n    \\t\\tListNode p1 = head, p2 = head.next, p3 = p2.next;\\n    \\t\\tp1.next = p3;\\n    \\t\\tp2.next = p1;\\n    \\t\\t\\n    \\t\\tif (p3 != null) {\\n    \\t\\t\\tp1.next = swapPairs(p3);\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn p2;\\n    \\t}\\n\\nIterative:\\n\\n    public ListNode swapPairs(ListNode head) {\\n    \\t\\tif (head == null || head.next == null)\\n    \\t\\t\\treturn head;\\n    \\t\\tListNode curr = head;\\n    \\t\\tListNode next = head.next;\\n    \\t\\tListNode newHead = next;\\n    \\t\\t\\n    \\t\\tcurr.next = next.next;\\n    \\t\\tnext.next = curr;\\n    \\t\\t\\n    \\t\\tif (curr.next == null)\\n    \\t\\t\\treturn newHead;\\n    \\t\\t\\n    \\t\\twhile (curr.next.next != null) {\\n    \\t\\t\\tListNode prev = curr;\\n    \\t\\t\\tcurr = curr.next;\\n    \\t\\t\\tnext = curr.next;\\n    \\t\\t\\n    \\t\\t\\tprev.next = next;\\n    \\t\\t\\tcurr.next = next.next;\\n    \\t\\t\\tnext.next = curr;\\n    \\t\\t\\t\\n    \\t\\t\\tif (curr.next == null || curr.next.next == null)\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn newHead;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 11267,
                "title": "c-solution-easy-to-understand-with-comments-and-explanations",
                "content": "<h1>Renewed Solution</h1>\\n\\nThe main point is that if there are 2 more nodes (which is a pair) following, then swap them, otherwise, end the process.\\n\\n    bool SwapHelper(ListNode *p)\\n    {\\n        if (p->next and p->next->next)\\n        {\\n            ListNode *n1 = p->next;\\n            ListNode *n2 = p->next->next;\\n            \\n            p->next = n2;\\n            n1->next = n2->next;\\n            n2->next = n1;\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n\\n    ListNode *swapPairs(ListNode *head) \\n    {\\n        if (!head) \\n            return nullptr;\\n        \\n        // Create a head Node\\n        ListNode new_head(-1);\\n        new_head.next = head;\\n        \\n        ListNode *p = &new_head;\\n        \\n        // While has two more node and swap succeeded\\n        while (SwapHelper(p)) \\n            p = p->next->next;\\n        \\n        return new_head.next;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "<h1>Renewed Solution</h1>\\n\\nThe main point is that if there are 2 more nodes (which is a pair) following, then swap them, otherwise, end the process.\\n\\n    bool SwapHelper(ListNode *p)\\n    {\\n        if (p->next and p->next->next)\\n        {\\n            ListNode *n1 = p->next;\\n            ListNode *n2 = p->next->next;\\n            \\n            p->next = n2;\\n            n1->next = n2->next;\\n            n2->next = n1;\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n\\n    ListNode *swapPairs(ListNode *head) \\n    {\\n        if (!head) \\n            return nullptr;\\n        \\n        // Create a head Node\\n        ListNode new_head(-1);\\n        new_head.next = head;\\n        \\n        ListNode *p = &new_head;\\n        \\n        // While has two more node and swap succeeded\\n        while (SwapHelper(p)) \\n            p = p->next->next;\\n        \\n        return new_head.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3529195,
                "title": "easy-java-solution-with-explanation-beating-100-in-tc",
                "content": "# Please Upvote!!!\\n\\n\\n![Screenshot 2023-05-16 at 09.08.07.png](https://assets.leetcode.com/users/images/6223796e-4c86-4b23-8b51-880f70453355_1684208465.7977593.png)\\n\\n\\n\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo swap every two adjacent nodes in a linked list without modifying the node values, you can manipulate the pointers of the nodes. Here\\'s an algorithm to solve the problem:\\n\\nInitialize a dummy node and set its next pointer to the head of the given linked list. This dummy node will be useful as the new head of the modified list.\\nInitialize three pointers: prev, curr, and next. Set prev to the dummy node and curr to the head of the list.\\nIterate through the list while curr and curr.next are not null:\\nSet next to curr.next.\\nPoint curr.next to next.next.\\nPoint next.next to curr.\\nPoint prev.next to next.\\nMove prev to curr.\\nMove curr to curr.next.\\nReturn the modified list\\'s head, which is the dummy node\\'s next node.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head==null||head.next==null){\\n            return head;\\n        }\\n        ListNode nodeSlow = null, nodeFast = head.next;\\n        ListNode temp = head;\\n        temp.next = nodeFast.next;\\n        nodeFast.next = temp;\\n        head = nodeFast;\\n        nodeFast = nodeFast.next;\\n        nodeSlow = head;\\n        while(nodeFast.next!=null){\\n            nodeSlow = nodeSlow.next;\\n            nodeFast = nodeFast.next;\\n\\n            if(nodeFast.next!=null) {\\n                nodeSlow.next = nodeFast.next;\\n                temp = nodeFast.next.next;\\n                nodeSlow.next.next = nodeFast;\\n                nodeFast.next = temp;\\n                nodeSlow = nodeSlow.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head==null||head.next==null){\\n            return head;\\n        }\\n        ListNode nodeSlow = null, nodeFast = head.next;\\n        ListNode temp = head;\\n        temp.next = nodeFast.next;\\n        nodeFast.next = temp;\\n        head = nodeFast;\\n        nodeFast = nodeFast.next;\\n        nodeSlow = head;\\n        while(nodeFast.next!=null){\\n            nodeSlow = nodeSlow.next;\\n            nodeFast = nodeFast.next;\\n\\n            if(nodeFast.next!=null) {\\n                nodeSlow.next = nodeFast.next;\\n                temp = nodeFast.next.next;\\n                nodeSlow.next.next = nodeFast;\\n                nodeFast.next = temp;\\n                nodeSlow = nodeSlow.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528787,
                "title": "c-best-shortest-3-lines-solution-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStart\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCheck if the linked list is empty or has only one node. If so, return the head of the linked list. \\n\\nOtherwise, create a pointer next to the second node in the linked list.\\n\\nSet the next pointer of the first node to the result of recursively calling swapPairs on the third node (if it exists) and beyond.\\n\\nSet the next pointer of the next node to the first node.\\nReturn the next node as the new head of the linked list.\\nDone !!!!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n    if (!head || !head->next) {\\n        return head;\\n    }\\n    ListNode* next = head->next;\\n    head->next = swapPairs(next->next);\\n    next->next = head;\\n    return next;\\n}\\n\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/ab237660-fad0-4f6c-b23d-642be5c4aa75_1684195692.93272.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion",
                    "Doubly-Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n    if (!head || !head->next) {\\n        return head;\\n    }\\n    ListNode* next = head->next;\\n    head->next = swapPairs(next->next);\\n    next->next = head;\\n    return next;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528782,
                "title": "java-recursion-beats-100-12-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Recursively traverse the list to the end.\\n2. On the way back return every node at an even number position.\\n3. Update the `next` pointers for nodes at odd and even positions with their own logic.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ on the stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int cnt = 0;\\n\\n  public ListNode swapPairs(ListNode node) {\\n    if (node == null) return null;\\n\\n    cnt++;\\n    var ret = swapPairs(node.next);\\n\\n    if (cnt % 2 == 1 && ret != null) {\\n      // node -> the first (left) node in each pair\\n      node.next = ret.next;\\n      ret.next = node;\\n    } else {\\n      // node -> the second (right) node in each pair\\n      node.next = ret;\\n      ret = node;\\n    }\\n    cnt--;\\n    return ret;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  int cnt = 0;\\n\\n  public ListNode swapPairs(ListNode node) {\\n    if (node == null) return null;\\n\\n    cnt++;\\n    var ret = swapPairs(node.next);\\n\\n    if (cnt % 2 == 1 && ret != null) {\\n      // node -> the first (left) node in each pair\\n      node.next = ret.next;\\n      ret.next = node;\\n    } else {\\n      // node -> the second (right) node in each pair\\n      node.next = ret;\\n      ret = node;\\n    }\\n    cnt--;\\n    return ret;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142432,
                "title": "c-solution-easy-to-understand-recursion",
                "content": "# Intuition\\nA pretty simple approach using recursion\\n\\n# Approach\\n1. We have to keep in mind that while swapping, we are only working with two nodes at a time.\\n2. I have written the swapping steps under the comment in the code. Take a piece of paper and try to dry run it on two nodes, You will get it.\\n3. Now we know how I am swapping them, One case is solved, rest will be done by recursion.\\n4. After swapping the first two nodes, we will attach the result of swapping after the recursion has done it\\'s work.\\n5. we will have to return the temp as it will be pointing to the first node of the swapping result.\\n6. and we\\'re DONE !!\\n\\nMy solution is not the best, but is easy to understand for the beginners. \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL)\\n            return NULL;\\n\\n        if(head->next == NULL)\\n            return head;\\n\\n        ListNode* tempHead = head;\\n\\n        //swapping\\n        ListNode* temp = tempHead->next;\\n        tempHead->next = tempHead->next->next;\\n        temp->next = tempHead;\\n        //tempHead = tempHead->next;\\n\\n        tempHead->next = swapPairs(tempHead->next);\\n\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL)\\n            return NULL;\\n\\n        if(head->next == NULL)\\n            return head;\\n\\n        ListNode* tempHead = head;\\n\\n        //swapping\\n        ListNode* temp = tempHead->next;\\n        tempHead->next = tempHead->next->next;\\n        temp->next = tempHead;\\n        //tempHead = tempHead->next;\\n\\n        tempHead->next = swapPairs(tempHead->next);\\n\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774660,
                "title": "easy-c-100-faster-solution",
                "content": "```\\nListNode* swapPairs(ListNode* head) {\\n        if(head==NULL or head->next==NULL) return head;\\n        ListNode* a = NULL;\\n        ListNode* b = head;\\n        ListNode* c = head->next;\\n        \\n        while(b!=NULL && c!=NULL){\\n            if(a==NULL){\\n                b->next = c->next;\\n                c->next = b;\\n                head = c;\\n            }else{\\n                a->next = c;\\n                b->next = c->next;\\n                c->next = b;\\n            }\\n            a = b;\\n            b = b->next;\\n            if(b) c = b->next;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nListNode* swapPairs(ListNode* head) {\\n        if(head==NULL or head->next==NULL) return head;\\n        ListNode* a = NULL;\\n        ListNode* b = head;\\n        ListNode* c = head->next;\\n        \\n        while(b!=NULL && c!=NULL){\\n            if(a==NULL){\\n                b->next = c->next;\\n                c->next = b;\\n                head = c;\\n            }else{\\n                a->next = c;\\n                b->next = c->next;\\n                c->next = b;\\n            }\\n            a = b;\\n            b = b->next;\\n            if(b) c = b->next;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1487511,
                "title": "python-easy-with-dummy-head-clean-concise",
                "content": "```python\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummyHead = curHead = ListNode(0)\\n        \\n        def addNode(node):\\n            nonlocal curHead\\n            curHead.next = node\\n            curHead = curHead.next\\n        \\n        while head != None and head.next != None:\\n            nxt = head.next\\n            nxt2 = nxt.next\\n            \\n            addNode(nxt)  # Add nxt node\\n            addNode(head) # Add cur node\\n            \\n            head = nxt2\\n            \\n        if head != None:  # If there is a left node -> Add that node\\n            addNode(head)\\n        curHead.next = None\\n        \\n        return dummyHead.next\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 100` is number of nodes in the linked list.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummyHead = curHead = ListNode(0)\\n        \\n        def addNode(node):\\n            nonlocal curHead\\n            curHead.next = node\\n            curHead = curHead.next\\n        \\n        while head != None and head.next != None:\\n            nxt = head.next\\n            nxt2 = nxt.next\\n            \\n            addNode(nxt)  # Add nxt node\\n            addNode(head) # Add cur node\\n            \\n            head = nxt2\\n            \\n        if head != None:  # If there is a left node -> Add that node\\n            addNode(head)\\n        curHead.next = None\\n        \\n        return dummyHead.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485546,
                "title": "c-easytounderstand-recursion-faster-than-100-less-memory-than-99-88",
                "content": "If you have any queries, be sure to ask \\u270C.\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next == NULL){  // If List is empty otr has only 1 node return;\\n            return head;\\n        }\\n        \\n        ListNode* first = head; // first pointer to List\\'s first node\\n        ListNode* second = head->next; // second pointer to List\\'s second node\\n        ListNode* third = head->next->next; // third pointer to List\\'s third node\\n        \\n        second->next = first; // Made second\\'s next point to first instead of third. So, it\\'s like first\\'s next and second\\'s next are pointing to second and first respectively.\\n\\t\\t\\n        first->next = swapPairs(third); // made first\\'s next point to swapPairs(third), because we assume, recursion will swap the rest of the pairs and whatever it will return first\\'s next will point to that node.\\n        \\n        return second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next == NULL){  // If List is empty otr has only 1 node return;\\n            return head;\\n        }\\n        \\n        ListNode* first = head; // first pointer to List\\'s first node\\n        ListNode* second = head->next; // second pointer to List\\'s second node\\n        ListNode* third = head->next->next; // third pointer to List\\'s third node\\n        \\n        second->next = first; // Made second\\'s next point to first instead of third. So, it\\'s like first\\'s next and second\\'s next are pointing to second and first respectively.\\n\\t\\t\\n        first->next = swapPairs(third); // made first\\'s next point to swapPairs(third), because we assume, recursion will swap the rest of the pairs and whatever it will return first\\'s next will point to that node.\\n        \\n        return second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430366,
                "title": "c-well-commented",
                "content": "```\\nLets take an example : 1 2 3 4\\nBase condition at top is if linked list has no element or 1 element just return the head itself .\\nNow we have 2 pointers p pointing to head i.e. 1 and res pointing to head->next i.e. 2\\nTwo more pointers q and temp of ListNode type.\\nWhile(true)\\n{\\n            q = p->next;\\n            temp = q->next;\\n            q->next = p;\\n\\t\\t\\t\\nthis above statements simply means in first iteration :  temp will point to 3 and 2->1 will be achieved , if statement of temp wont execute \\n\\n            p->next = temp->next;\\n            p = temp;\\n\\t\\t\\t\\nAbove 2 statements means : 1\\'s link with 4 will be established and value of temp i.e 3 will be stored in p, so now p contains 3 that points to 4.\\nSame way 2nd iteration will execute and 3->4 will turn into 4->3 and this time if statement inside while loop will execute as temp has become null, \\np->next = temp means terminate the linked list by attaching NULL to last element 3 and break out of while loop.\\n}\\nWe are returning res as it points to 2 which can give us entire linked list i.e : 2 -> 1 -> 4 -> 3 -> NULL\\nupvote if u like it .\\n```\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if(!head || !head->next) \\n            return head;\\n        \\n        ListNode* p = head;\\n        ListNode* res = head->next;\\n        ListNode* q; ListNode* temp;\\n        \\n        while(true)\\n        {\\n            q = p->next;\\n            temp = q->next;\\n            q->next = p;\\n            \\n            if(temp == NULL || temp->next == NULL) {\\n                p->next = temp;\\n                break;\\n            }\\n            p->next = temp->next;\\n            p = temp;\\n        }\\n        return res;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nLets take an example : 1 2 3 4\\nBase condition at top is if linked list has no element or 1 element just return the head itself .\\nNow we have 2 pointers p pointing to head i.e. 1 and res pointing to head->next i.e. 2\\nTwo more pointers q and temp of ListNode type.\\nWhile(true)\\n{\\n            q = p->next;\\n            temp = q->next;\\n            q->next = p;\\n\\t\\t\\t\\nthis above statements simply means in first iteration :  temp will point to 3 and 2->1 will be achieved , if statement of temp wont execute \\n\\n            p->next = temp->next;\\n            p = temp;\\n\\t\\t\\t\\nAbove 2 statements means : 1\\'s link with 4 will be established and value of temp i.e 3 will be stored in p, so now p contains 3 that points to 4.\\nSame way 2nd iteration will execute and 3->4 will turn into 4->3 and this time if statement inside while loop will execute as temp has become null, \\np->next = temp means terminate the linked list by attaching NULL to last element 3 and break out of while loop.\\n}\\nWe are returning res as it points to 2 which can give us entire linked list i.e : 2 -> 1 -> 4 -> 3 -> NULL\\nupvote if u like it .\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if(!head || !head->next) \\n            return head;\\n        \\n        ListNode* p = head;\\n        ListNode* res = head->next;\\n        ListNode* q; ListNode* temp;\\n        \\n        while(true)\\n        {\\n            q = p->next;\\n            temp = q->next;\\n            q->next = p;\\n            \\n            if(temp == NULL || temp->next == NULL) {\\n                p->next = temp;\\n                break;\\n            }\\n            p->next = temp->next;\\n            p = temp;\\n        }\\n        return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1422154,
                "title": "c-easy-to-understand-swap-nodes-two-methods",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n\\n**Iterative**\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n    if(head==NULL)\\n    return NULL;\\n    if(head->next==NULL)\\n    return head;\\n    ListNode *dummy=new ListNode(-1);\\n    ListNode* curr=head;\\n    ListNode* prev=dummy;    \\n    prev->next=curr;\\n    while(curr&&curr->next)\\n    {\\n    prev->next=curr->next;\\n    curr->next=curr->next->next;\\n    prev->next->next=curr;\\n    prev=prev->next->next;\\n    curr=curr->next;\\n    }   \\n return dummy->next;   \\n}\\n};\\n```\\n**Recursive**\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        //base case\\n        if(!head || !head->next) return head;\\n        ListNode *temp = head->next;\\n        head->next = swapPairs(temp->next); \\n        temp->next = head;\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n    if(head==NULL)\\n    return NULL;\\n    if(head->next==NULL)\\n    return head;\\n    ListNode *dummy=new ListNode(-1);\\n    ListNode* curr=head;\\n    ListNode* prev=dummy;    \\n    prev->next=curr;\\n    while(curr&&curr->next)\\n    {\\n    prev->next=curr->next;\\n    curr->next=curr->next->next;\\n    prev->next->next=curr;\\n    prev=prev->next->next;\\n    curr=curr->next;\\n    }   \\n return dummy->next;   \\n}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        //base case\\n        if(!head || !head->next) return head;\\n        ListNode *temp = head->next;\\n        head->next = swapPairs(temp->next); \\n        temp->next = head;\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301987,
                "title": "c-solution",
                "content": "**Intuition**\\nSwap the node pairs is not difficult, but link node paris after swapping is tricky. We need to use ```prev``` to record the first node ```s1``` of the previous node pair, and then link it to the next node pair.\\n\\n![image](https://assets.leetcode.com/users/images/773756a7-225c-41cb-895b-aecc89dddfa2_1634282202.369622.png)\\n\\n**complexity**\\n- time: O(N)\\n- space: O(1)\\n\\n**implementation**\\n```\\npublic class Solution {\\n    public ListNode SwapPairs(ListNode head) {\\n        \\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        ListNode s1 = null;\\n        ListNode s2 = null;\\n        \\n        while(prev != null && prev.next != null && prev.next.next != null)\\n        {\\n            s1 = prev.next;\\n            s2 = prev.next.next;\\n            prev.next = s2;\\n            s1.next = s2.next;\\n            s2.next = s1;\\n            prev = s1;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```prev```\n```s1```\n```\\npublic class Solution {\\n    public ListNode SwapPairs(ListNode head) {\\n        \\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        ListNode s1 = null;\\n        ListNode s2 = null;\\n        \\n        while(prev != null && prev.next != null && prev.next.next != null)\\n        {\\n            s1 = prev.next;\\n            s2 = prev.next.next;\\n            prev.next = s2;\\n            s1.next = s2.next;\\n            s2.next = s1;\\n            prev = s1;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683353,
                "title": "javascript",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function(head) {\\n    let cur = head;\\n    let newHead = head && head.next ? head.next : head;\\n        \\n    while (cur && cur.next) {\\n        let next = cur.next;\\n        let temp = next.next;\\n        \\n        next.next = cur;\\n        cur.next = temp && temp.next ? temp.next : temp;\\n        \\n        cur = temp;\\n    }\\n\\n    \\n    return newHead;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function(head) {\\n    let cur = head;\\n    let newHead = head && head.next ? head.next : head;\\n        \\n    while (cur && cur.next) {\\n        let next = cur.next;\\n        let temp = next.next;\\n        \\n        next.next = cur;\\n        cur.next = temp && temp.next ? temp.next : temp;\\n        \\n        cur = temp;\\n    }\\n\\n    \\n    return newHead;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 674270,
                "title": "c-o-n-solution-beats-100-in-time-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/swap-nodes-in-pairs/\\n    \\n    Idea is to take 2 ndoes at a time and swap them, then make the\\n    2st node connected to the 3rd node if there and continue with the 3rd node.\\n    TC: O(N), SC:O(1)\\n*/\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // We use a dummy head node to make handling head operations simpler\\n        ListNode *dummy = new ListNode(-1), *tail = dummy;\\n        // add the dummy node to list\\n        tail->next = head;\\n        \\n        while(head && head->next) {\\n            ListNode *nextptr = head->next->next;\\n            // swap the adjacent nodes\\n            // 2nd node comes to 1st pos \\n            tail->next = head->next;\\n            // connecting 2nd node to 1st node\\n            (head->next)->next = head;\\n            // make the 1st node connected to next node on list\\n            tail = head;\\n            tail->next = nextptr;\\n            head = nextptr;\\n        }\\n        \\n        head = dummy->next;\\n        delete dummy;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/swap-nodes-in-pairs/\\n    \\n    Idea is to take 2 ndoes at a time and swap them, then make the\\n    2st node connected to the 3rd node if there and continue with the 3rd node.\\n    TC: O(N), SC:O(1)\\n*/\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // We use a dummy head node to make handling head operations simpler\\n        ListNode *dummy = new ListNode(-1), *tail = dummy;\\n        // add the dummy node to list\\n        tail->next = head;\\n        \\n        while(head && head->next) {\\n            ListNode *nextptr = head->next->next;\\n            // swap the adjacent nodes\\n            // 2nd node comes to 1st pos \\n            tail->next = head->next;\\n            // connecting 2nd node to 1st node\\n            (head->next)->next = head;\\n            // make the 1st node connected to next node on list\\n            tail = head;\\n            tail->next = nextptr;\\n            head = nextptr;\\n        }\\n        \\n        head = dummy->next;\\n        delete dummy;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501576,
                "title": "java-100-and-only-11-lines",
                "content": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null){\\n            return head;\\n        }\\n        ListNode l = head.next;\\n        head.next = swapPairs(head.next.next);\\n        l.next = head;\\n        return l;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null){\\n            return head;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 11241,
                "title": "my-simple-recursive-c-solution-in-6-lines-4ms",
                "content": "    ListNode* swapPairs(ListNode* head) {\\n        if (head == NULL) { return NULL; }\\n        if (head ->next == NULL) { return head; }\\n        \\n        ListNode *newHead = head->next;\\n        head->next = swapPairs(head->next->next);\\n        newHead->next = head;\\n        return newHead;\\n    }",
                "solutionTags": [
                    "Linked List",
                    "Recursion"
                ],
                "code": "    ListNode* swapPairs(ListNode* head) {\\n        if (head == NULL) { return NULL; }\\n        if (head ->next == NULL) { return head; }\\n        \\n        ListNode *newHead = head->next;\\n        head->next = swapPairs(head->next->next);\\n        newHead->next = head;\\n        return newHead;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 11278,
                "title": "ac-java-solution",
                "content": "    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        \\n        ListNode n1 = head;\\n        ListNode n2 = head.next;\\n        \\n        n1.next = n2.next;\\n        n2.next = n1;\\n        \\n        n1.next = swapPairs(n1.next);\\n        \\n        return n2;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        \\n        ListNode n1 = head;\\n        ListNode n2 = head.next;\\n        \\n        n1.next = n2.next;\\n        n2.next = n1;\\n        \\n        n1.next = swapPairs(n1.next);\\n        \\n        return n2;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3531484,
                "title": "think-recursive-python-c-golang",
                "content": "# Intuition\\nLet\\'s solve a very basic problem, like if we have only two nodes in linked list something like this\\n![Screenshot from 2023-05-16 21-18-05.png](https://assets.leetcode.com/users/images/1d8eaf14-3512-4e3d-bc46-57e3dd6746f0_1684253393.1944199.png)\\n\\nThen, our approach is divided into 3 steps\\n* ***Step1*** Set CurrNode\\'s next to NextNode\\'s next\\n![Screenshot from 2023-05-16 21-21-08.png](https://assets.leetcode.com/users/images/0409e8be-a0f4-49de-8ca8-7cf14ba869be_1684253489.2341714.png)\\n\\n* ***Step2*** Set NextNode\\'s next to CurrNode\\n![Screenshot from 2023-05-16 21-25-06.png](https://assets.leetcode.com/users/images/362d02de-00fc-4e49-a1c2-2c80404593c9_1684253531.1400237.png)\\n\\n* ***Step3*** We are done with swapping now, we have to return the NextNode as our new head.\\n![Screenshot from 2023-05-16 21-28-32.png](https://assets.leetcode.com/users/images/dc72258a-ac45-4dfe-8045-4d4cb40b279a_1684253573.5092244.png)\\n\\nWe have solved our problem, now we have to implement this logic\\n\\n# Approach\\n* If Head node is empty or Head\\'s next is empty, return Head ecause we don\\'t have anything to perform our logic\\n\\n* Set NextNode to Head->next\\n\\n* Now, Set recursion result to Head->next\\n\\n* Now, Set NextNode->next to head\\n\\n* Finally, return the NextNode which is our ans.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\nWhere n is the length of the linked list.\\n`Note: We have traversed only half linked list.`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\nBecause we haven\\'t consumed any extra space.\\n`Note: We consumed some auxiliary space for recursion stack.`\\n\\n# Code\\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        nextNode = head.next\\n        head.next = self.swapPairs(head.next.next)\\n        nextNode.next = head\\n\\n        return nextNode\\n\\n```\\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head or !head->next) return head;\\n\\n        ListNode* nextNode = head->next;\\n        head->next = swapPairs(head->next->next);\\n        nextNode->next = head;\\n\\n        return nextNode;\\n    }\\n};\\n```\\n```Go []\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc swapPairs(head *ListNode) *ListNode {\\n    if head == nil || head.Next == nil {\\n        return head\\n    }\\n\\n    nextNode := head.Next\\n    head.Next = swapPairs(head.Next.Next)\\n    nextNode.Next = head\\n\\n    return nextNode    \\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Go",
                    "Recursion"
                ],
                "code": "```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        nextNode = head.next\\n        head.next = self.swapPairs(head.next.next)\\n        nextNode.next = head\\n\\n        return nextNode\\n\\n```\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head or !head->next) return head;\\n\\n        ListNode* nextNode = head->next;\\n        head->next = swapPairs(head->next->next);\\n        nextNode->next = head;\\n\\n        return nextNode;\\n    }\\n};\\n```\n```Go []\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc swapPairs(head *ListNode) *ListNode {\\n    if head == nil || head.Next == nil {\\n        return head\\n    }\\n\\n    nextNode := head.Next\\n    head.Next = swapPairs(head.Next.Next)\\n    nextNode.Next = head\\n\\n    return nextNode    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528845,
                "title": "python-3-4-lines-t-m-98-65",
                "content": "```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        if not(head and head.next): return head \\n\\n        newHead = head.next\\n        head.next, newHead.next = self.swapPairs(head.next.next), head\\n\\n        return newHead\\n```\\n[https://leetcode.com/submissions/detail/582543531/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        if not(head and head.next): return head \\n\\n        newHead = head.next\\n        head.next, newHead.next = self.swapPairs(head.next.next), head\\n\\n        return newHead\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151844,
                "title": "beats-100-java-recursive-approach-swapping-nodes-simple-solution",
                "content": "# Intuition\\nWe can solve it by doing simple swapping of nodes!\\n# Complexity\\n- Time complexity:\\n0(n)\\n\\n- Space complexity:\\n0(n) [Recursion stack]\\n# Code\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null) return head;\\n        ListNode temp = head.next;\\n        swapper(head);\\n        return temp;\\n    }\\n    void swapper(ListNode head)\\n    {\\n        if(head == null || head.next == null) return;\\n        ListNode temp = head.next;\\n        head.next = head.next.next;\\n        temp.next = head;\\n        ListNode temp2 = null;\\n        if(head.next != null)\\n         temp2 = head.next.next;\\n        swapper(head.next);\\n        if(temp2 != null)\\n        head.next = temp2;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null) return head;\\n        ListNode temp = head.next;\\n        swapper(head);\\n        return temp;\\n    }\\n    void swapper(ListNode head)\\n    {\\n        if(head == null || head.next == null) return;\\n        ListNode temp = head.next;\\n        head.next = head.next.next;\\n        temp.next = head;\\n        ListNode temp2 = null;\\n        if(head.next != null)\\n         temp2 = head.next.next;\\n        swapper(head.next);\\n        if(temp2 != null)\\n        head.next = temp2;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044431,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* temp=head->next;\\n        head->next=swapPairs(head->next->next);\\n        temp->next=head;\\n        return temp;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* temp=head->next;\\n        head->next=swapPairs(head->next->next);\\n        temp->next=head;\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014145,
                "title": "100-beats-java-solution-executed-in-0ms-using-three-pointer-iterative-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Three Pointer Iterative Approach where the swapping is done with help of Three Pointers**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach to solve this problem is the three pointer approach, where I have taken the three pointers and with the help of that the swapping of nodes is done, The programming language used is Java. Here the three nodes p for previous, c for current and cn for current_next is taken and also the d node is taken at the starting which will act as p in the first iteration. \\n\\nSuppose the linked list is given\\n1-->2-->3-->4-->null\\nthen first we have declared the d node such that it\\'s next pointer points to the head of the linked list hence\\nD-->1-->2-->3-->4-->null\\nNow During the first Iteration\\n![Untitled.jpg](https://assets.leetcode.com/users/images/036ca02f-24e3-4523-8a2e-61e7b6676f0a_1673101141.142306.jpeg)\\nAfter First Iteration \\n![Untitled.jpg](https://assets.leetcode.com/users/images/78144949-1a21-4c30-837d-297959ae7f54_1673101304.5513315.jpeg)\\nHence as the processing of swapping will be done the pointers will be moved as \\n![Untitled.jpg](https://assets.leetcode.com/users/images/ae9c0caf-c34e-41f3-8162-a6104bce1311_1673101484.9050355.jpeg)\\nAnd again the processing of swapping will be done\\nTill the c and cn is null.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**Time Complexity - O(n)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**Space Compleixty - O(1)**\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        ListNode d = new ListNode(0);\\n        d.next = head;\\n        ListNode p = d;\\n        ListNode c = d.next;\\n        while(c!=null){\\n            ListNode cn = c.next;\\n            if(cn==null){\\n                break;\\n            }\\n            c.next = cn.next;\\n            cn.next=p.next;\\n            p.next = cn;\\n            p = c;\\n            c = c.next;\\n        }\\n        return d.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        ListNode d = new ListNode(0);\\n        d.next = head;\\n        ListNode p = d;\\n        ListNode c = d.next;\\n        while(c!=null){\\n            ListNode cn = c.next;\\n            if(cn==null){\\n                break;\\n            }\\n            c.next = cn.next;\\n            cn.next=p.next;\\n            p.next = cn;\\n            p = c;\\n            c = c.next;\\n        }\\n        return d.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882193,
                "title": "simple-rust-recursive-solution",
                "content": "# Approach\\nSwaps the first pair, then recurses to handle the rest of the list\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$ additional space\\n\\n# Code\\n```\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\nimpl Solution {\\n    pub fn swap_pairs(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        match head {\\n            Some(mut h) => {\\n                match h.next {\\n                    Some(mut n) => {\\n                        h.next = Solution::swap_pairs(n.next);\\n                        n.next = Some(h);\\n                        Some(n)\\n                    },\\n                    _ => Some(h),\\n                }\\n            },\\n            _ => head,\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\nimpl Solution {\\n    pub fn swap_pairs(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        match head {\\n            Some(mut h) => {\\n                match h.next {\\n                    Some(mut n) => {\\n                        h.next = Solution::swap_pairs(n.next);\\n                        n.next = Some(h);\\n                        Some(n)\\n                    },\\n                    _ => Some(h),\\n                }\\n            },\\n            _ => head,\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2374316,
                "title": "easy-to-understand-simple-java-0ms-100-faster-solution-singlylinkedlist-space",
                "content": "**Please  \\uD83D\\uDC4D this.solution if(you understood == true)**\\n\\n```\\n// Best Approach : Recursive\\n// Space Complexity : O(n)\\n// Author - Nikhil Sharma\\n// LinkedIn - https://www.linkedin.com/in/nikhil-sharma-41a287226/\\n// Twitter - https://twitter.com/Sharma_Nikh12\\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if ((head == null)||(head.next == null))\\n            return head;\\n        ListNode n = head.next;\\n        head.next = swapPairs(head.next.next);\\n        n.next = head;\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n// Best Approach : Recursive\\n// Space Complexity : O(n)\\n// Author - Nikhil Sharma\\n// LinkedIn - https://www.linkedin.com/in/nikhil-sharma-41a287226/\\n// Twitter - https://twitter.com/Sharma_Nikh12\\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if ((head == null)||(head.next == null))\\n            return head;\\n        ListNode n = head.next;\\n        head.next = swapPairs(head.next.next);\\n        n.next = head;\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303855,
                "title": "easy-0-ms-100-faster-fully-explained-c-java-c-language-js",
                "content": "# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        //Base condition\\n        if(!head || !head->next)   \\n        return head;\\n        \\n        //Create a tmp node whose next pointer will point to the current head\\n        ListNode* tmp = new ListNode(0);\\n        tmp->next = head;\\n        \\n        //Now take a curr node which will be used to traverse the list\\n        ListNode* curr = tmp;\\n        \\n        // Loop until we reach to the second last node...\\n        while(curr->next && curr->next->next){\\n            \\n            //In each iteration, take two nodes, n1 = curr.next and n2 = curr.next.next.\\n            ListNode* n1 = curr->next;\\n            ListNode* n2 = curr->next->next;\\n            \\n            n1->next = n2->next;              // Point the next of n1 to the node after n2\\n            curr->next = n2;                 // Now n2 node should be the curr.next node.\\n            curr->next->next = n1;            // Linking n2 to the n1 node.\\n            curr = curr->next->next;    // Move the pointer two nodes ahead\\n    }\\n \\n    return tmp->next;    //at last return the tmp.next\\n    }\\n};\\n```\\n\\n# **Java Solution:**\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        //Base condition\\n        if(head == null || head.next == null)   \\n        return head;\\n        \\n        //Create a tmp node whose next pointer will point to the current head\\n        ListNode tmp = new ListNode(0);\\n        tmp.next = head;\\n        \\n        //Now take a curr node which will be used to traverse the list\\n        ListNode curr = tmp;\\n        \\n        // Loop until we reach to the second last node...\\n        while(curr.next != null && curr.next.next != null){\\n            \\n            //In each iteration, take two nodes, n1 = curr.next and n2 = curr.next.next.\\n            ListNode n1 = curr.next;\\n            ListNode n2 = curr.next.next;\\n            \\n            n1.next = n2.next;              // Point the next of n1 to the node after n2\\n            curr.next = n2;                 // Now n2 node should be the curr.next node.\\n            curr.next.next = n1;            // Linking n2 to the n1 node.\\n            curr = curr.next.next;    // Move the pointer two nodes ahead\\n    }\\n \\n    return tmp.next;    //at last return the tmp.next\\n    }\\n}\\n```\\n\\n# **C Language:**\\n```\\n//Another approach is here...\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    if(head==NULL || head->next==NULL)\\n        return head;\\n    struct ListNode* temp = head->next;\\n    head->next = swapPairs(temp->next);  //call recursively.\\n    temp->next = head;\\n    return temp;\\n}\\n```\\n\\n# **Javascript Solution:**\\n```\\nvar swapPairs = function(head) {\\n    \\n    //Base condition\\n    if(head == null || head.next == null)   \\n    return head;\\n        \\n    //Create a tmp node whose next pointer will point to the current head\\n    const tmp = new ListNode(0);\\n    tmp.next = head;\\n        \\n    //Now take a curr node which will be used to traverse the list\\n    let curr = tmp;\\n        \\n    // Loop until we reach to the second last node...\\n    while(curr.next != null && curr.next.next != null){\\n            \\n        //In each iteration, take two nodes, n1 = curr.next and n2 = curr.next.next.\\n        let n1 = curr.next;\\n        let n2 = curr.next.next;\\n            \\n        n1.next = n2.next;              // Point the next of n1 to the node after n2\\n        curr.next = n2;                 // Now n2 node should be the curr.next node.\\n        curr.next.next = n1;            // Linking n2 to the n1 node.\\n        curr = curr.next.next;    // Move the pointer two nodes ahead\\n    }\\n    return tmp.next;    //at last return the tmp.next\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        //Base condition\\n        if(!head || !head->next)   \\n        return head;\\n        \\n        //Create a tmp node whose next pointer will point to the current head\\n        ListNode* tmp = new ListNode(0);\\n        tmp->next = head;\\n        \\n        //Now take a curr node which will be used to traverse the list\\n        ListNode* curr = tmp;\\n        \\n        // Loop until we reach to the second last node...\\n        while(curr->next && curr->next->next){\\n            \\n            //In each iteration, take two nodes, n1 = curr.next and n2 = curr.next.next.\\n            ListNode* n1 = curr->next;\\n            ListNode* n2 = curr->next->next;\\n            \\n            n1->next = n2->next;              // Point the next of n1 to the node after n2\\n            curr->next = n2;                 // Now n2 node should be the curr.next node.\\n            curr->next->next = n1;            // Linking n2 to the n1 node.\\n            curr = curr->next->next;    // Move the pointer two nodes ahead\\n    }\\n \\n    return tmp->next;    //at last return the tmp.next\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        //Base condition\\n        if(head == null || head.next == null)   \\n        return head;\\n        \\n        //Create a tmp node whose next pointer will point to the current head\\n        ListNode tmp = new ListNode(0);\\n        tmp.next = head;\\n        \\n        //Now take a curr node which will be used to traverse the list\\n        ListNode curr = tmp;\\n        \\n        // Loop until we reach to the second last node...\\n        while(curr.next != null && curr.next.next != null){\\n            \\n            //In each iteration, take two nodes, n1 = curr.next and n2 = curr.next.next.\\n            ListNode n1 = curr.next;\\n            ListNode n2 = curr.next.next;\\n            \\n            n1.next = n2.next;              // Point the next of n1 to the node after n2\\n            curr.next = n2;                 // Now n2 node should be the curr.next node.\\n            curr.next.next = n1;            // Linking n2 to the n1 node.\\n            curr = curr.next.next;    // Move the pointer two nodes ahead\\n    }\\n \\n    return tmp.next;    //at last return the tmp.next\\n    }\\n}\\n```\n```\\n//Another approach is here...\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    if(head==NULL || head->next==NULL)\\n        return head;\\n    struct ListNode* temp = head->next;\\n    head->next = swapPairs(temp->next);  //call recursively.\\n    temp->next = head;\\n    return temp;\\n}\\n```\n```\\nvar swapPairs = function(head) {\\n    \\n    //Base condition\\n    if(head == null || head.next == null)   \\n    return head;\\n        \\n    //Create a tmp node whose next pointer will point to the current head\\n    const tmp = new ListNode(0);\\n    tmp.next = head;\\n        \\n    //Now take a curr node which will be used to traverse the list\\n    let curr = tmp;\\n        \\n    // Loop until we reach to the second last node...\\n    while(curr.next != null && curr.next.next != null){\\n            \\n        //In each iteration, take two nodes, n1 = curr.next and n2 = curr.next.next.\\n        let n1 = curr.next;\\n        let n2 = curr.next.next;\\n            \\n        n1.next = n2.next;              // Point the next of n1 to the node after n2\\n        curr.next = n2;                 // Now n2 node should be the curr.next node.\\n        curr.next.next = n1;            // Linking n2 to the n1 node.\\n        curr = curr.next.next;    // Move the pointer two nodes ahead\\n    }\\n    return tmp.next;    //at last return the tmp.next\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260102,
                "title": "2-pointer-approach-with-diagram-in-c",
                "content": "![image](https://assets.leetcode.com/users/images/61041d00-400c-4eaf-b071-a8a9355894cf_1657454552.3188987.png)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* dummy = new ListNode();\\n        dummy -> next = head;\\n        ListNode* prev = dummy;\\n        \\n        ListNode* curr = head;\\n        ListNode *second, *nextPair;\\n        \\n        if(head == NULL || head -> next == NULL)\\n            return head;\\n        \\n        while(curr && curr -> next){\\n            second = curr -> next;\\n            nextPair = curr -> next -> next;\\n            \\n            second -> next = curr;\\n            curr -> next = nextPair;\\n            prev -> next = second;\\n            \\n            prev = curr;\\n            curr = nextPair;\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```\\n\\n[Further Explanation : NeetCode](https://youtu.be/o811TZLAWOo)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* dummy = new ListNode();\\n        dummy -> next = head;\\n        ListNode* prev = dummy;\\n        \\n        ListNode* curr = head;\\n        ListNode *second, *nextPair;\\n        \\n        if(head == NULL || head -> next == NULL)\\n            return head;\\n        \\n        while(curr && curr -> next){\\n            second = curr -> next;\\n            nextPair = curr -> next -> next;\\n            \\n            second -> next = curr;\\n            curr -> next = nextPair;\\n            prev -> next = second;\\n            \\n            prev = curr;\\n            curr = nextPair;\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2150670,
                "title": "fastest-100-faster-0ms-java-solution",
                "content": "ListNode cur=head;\\n        ListNode next=null;\\n        ListNode prev=null;\\n        ListNode first=head;\\n        int c=1;\\n        while(cur!=null&&c<3){\\n            next=cur.next;\\n            cur.next=prev;\\n            prev=cur;\\n            cur=next;\\n            if(c==2)\\n                first.next=swapPairs(cur);\\n            c++;\\n        }\\n        return prev;",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "ListNode cur=head;\\n        ListNode next=null;\\n        ListNode prev=null;\\n        ListNode first=head;\\n        int c=1;\\n        while(cur!=null&&c<3){\\n            next=cur.next;\\n            cur.next=prev;\\n            prev=cur;\\n            cur=next;\\n            if(c==2)\\n                first.next=swapPairs(cur);\\n            c++;\\n        }\\n        return prev;",
                "codeTag": "Unknown"
            },
            {
                "id": 2037031,
                "title": "java-0ms-100-faster-2-methods",
                "content": "*1. First way using iteration :-*\\n\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n      if(head == null || head.next == null)\\n        return head;\\n       ListNode curr = head.next;\\n      ListNode prev = head;\\n      ListNode next = null;\\n      ListNode newHead = curr;\\n      while(curr != null)\\n      {\\n        next = curr.next;\\n        curr.next = prev;\\n        if(next == null || next.next == null)\\n        {\\n          prev.next = next;\\n          curr = null;\\n        }\\n        else\\n        {\\n          curr = next.next;\\n          prev.next = curr;\\n          prev = next;\\n        }\\n      }\\n      return newHead;\\n    }\\n}\\n```\\n\\n*2. Second way using recursion :-*\\n\\n\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n      if(head == null || head.next == null)\\n        return head;\\n\\t\\tListNode second = head.next;\\n\\t\\tListNode third = second.next;\\n\\t\\tsecond.next = head;\\n\\t\\thead.next = swapPairs(third);\\n\\t\\treturn second;\\n\\t}\\n}\\n\\t\\t",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n      if(head == null || head.next == null)\\n        return head;\\n       ListNode curr = head.next;\\n      ListNode prev = head;\\n      ListNode next = null;\\n      ListNode newHead = curr;\\n      while(curr != null)\\n      {\\n        next = curr.next;\\n        curr.next = prev;\\n        if(next == null || next.next == null)\\n        {\\n          prev.next = next;\\n          curr = null;\\n        }\\n        else\\n        {\\n          curr = next.next;\\n          prev.next = curr;\\n          prev = next;\\n        }\\n      }\\n      return newHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775381,
                "title": "my-java-code-faster-than-100-without-recursion",
                "content": "```\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null){\\n            return null;\\n        }\\n        if(head.next == null){\\n            return head;\\n        }\\n        \\n        \\n        ListNode current = head;\\n        ListNode dummy = new ListNode(-1); // dummy node\\n        ListNode prev =dummy;\\n        while(current != null && current.next != null){\\n            prev.next = current.next;\\n            current.next = current.next.next;\\n            prev.next.next = current;\\n            \\n            // now update the current and prev \\n            current = current.next;\\n            prev = prev.next.next;\\n        }\\n        return dummy.next;\\n    }\\n```\\nFor solving any linked list problem like this, it will be good to use the help of dummy node\\nSo we will create a dummy node with any value (let suppose -1 ) and we will return dummy.next because its gonna be our new head.\\n\\nDry Run - 1-->2-->3-->4 ,      dummy node ->  -1 \\ncurrent = head   ->  current is at 1 \\nprev = dummy  -> prev is at -1\\n\\nrun a for loop and check if current node and its next node not be equal to null\\n```prev.next = current.next;```  ->   -1 (prev)  --> 2(next node of current)\\n```current.next = current.next.next;```  ->   1  --> 3 \\n```prev.next.next = current;``` -> -1-->2-->1 (prev is -1, prev.next is 2 and next of 2 is set to 1)\\n\\nnow update the pointers position\\n```current = current.next;``` -> current = 3 \\n```prev = prev.next.next``` -> prev = 1\\n\\nrun all the steps again for current and prev until condition satisfy. \\nI am sharing the code for the first time. If i did any mistake in this post then please forgive me\\uD83D\\uDE42. \\n\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null){\\n            return null;\\n        }\\n        if(head.next == null){\\n            return head;\\n        }\\n        \\n        \\n        ListNode current = head;\\n        ListNode dummy = new ListNode(-1); // dummy node\\n        ListNode prev =dummy;\\n        while(current != null && current.next != null){\\n            prev.next = current.next;\\n            current.next = current.next.next;\\n            prev.next.next = current;\\n            \\n            // now update the current and prev \\n            current = current.next;\\n            prev = prev.next.next;\\n        }\\n        return dummy.next;\\n    }\\n```\n```prev.next = current.next;```\n```current.next = current.next.next;```\n```prev.next.next = current;```\n```current = current.next;```\n```prev = prev.next.next```",
                "codeTag": "Unknown"
            },
            {
                "id": 1775317,
                "title": "c-c-simplest-recursive-solution-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if ((!head) || (!head->next))\\n            return head;\\n\\n        struct ListNode* tmp = head;\\n        head = head->next;\\n        tmp->next = head->next;\\n        head->next = tmp;\\n\\n        head->next->next = swapPairs(head->next->next);\\n        return head;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if ((!head) || (!head->next))\\n            return head;\\n\\n        struct ListNode* tmp = head;\\n        head = head->next;\\n        tmp->next = head->next;\\n        head->next = tmp;\\n\\n        head->next->next = swapPairs(head->next->next);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775223,
                "title": "java-simple-recursion-faster-than-100",
                "content": "**Solution 1**\\n\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        ListNode temp=head;\\n        while(temp!=null && temp.next!=null){\\n            int x=temp.val;\\n            temp.val=temp.next.val;\\n            temp.next.val=x;\\n            temp=temp.next.next;\\n        }\\n        return head;\\n    }\\n}\\n```\\n\\n**Solution 2 (without changing values)**\\n\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head==null)\\n            return null;\\n        return swapPairs(head,head.next);\\n    }\\n    public ListNode swapPairs(ListNode n1,ListNode n2){\\n        if(n1==null || n2==null){\\n            return n1;\\n        }\\n        n1.next=swapPairs(n1.next!=null?n1.next.next:null,n2.next!=null?n2.next.next:null);\\n        n2.next=n1;\\n        return n2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        ListNode temp=head;\\n        while(temp!=null && temp.next!=null){\\n            int x=temp.val;\\n            temp.val=temp.next.val;\\n            temp.next.val=x;\\n            temp=temp.next.next;\\n        }\\n        return head;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head==null)\\n            return null;\\n        return swapPairs(head,head.next);\\n    }\\n    public ListNode swapPairs(ListNode n1,ListNode n2){\\n        if(n1==null || n2==null){\\n            return n1;\\n        }\\n        n1.next=swapPairs(n1.next!=null?n1.next.next:null,n2.next!=null?n2.next.next:null);\\n        n2.next=n1;\\n        return n2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774872,
                "title": "beginner-friendly-python-solution-with-comments",
                "content": "The main logic used is the swapping of values\\n```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None:\\n            return head\\n        \\n        node=head\\n        c=0\\n        while node:  #loop to check the length of linkedlist\\n            c+=1\\n            node=node.next\\n            \\n        node=head\\n        if c%2!=0:    #If the length of linkedlist is odd then this loop will be executed\\n            while node.next is not None:\\n                node.next.val, node.val=node.val, node.next.val  #swapping the values\\n                node=node.next.next\\n        else:\\n            while node is not None:\\n                node.val, node.next.val=node.next.val, node.val #swapping the values\\n                node=node.next.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None:\\n            return head\\n        \\n        node=head\\n        c=0\\n        while node:  #loop to check the length of linkedlist\\n            c+=1\\n            node=node.next\\n            \\n        node=head\\n        if c%2!=0:    #If the length of linkedlist is odd then this loop will be executed\\n            while node.next is not None:\\n                node.next.val, node.val=node.val, node.next.val  #swapping the values\\n                node=node.next.next\\n        else:\\n            while node is not None:\\n                node.val, node.next.val=node.next.val, node.val #swapping the values\\n                node=node.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703662,
                "title": "c-iteration",
                "content": "C# solution by iteration \\n**Runtime: 84 ms, faster than 70.48% of C# online submissions for Swap Nodes in Pairs.\\nMemory Usage: 37.3 MB, less than 48.11% of C# online submissions for Swap Nodes in Pairs.**\\n\\n```\\npublic ListNode SwapPairs(ListNode head) {\\n       \\n\\t\\tListNode tempNode = new ListNode(-1, head);\\n        ListNode prevNode = tempNode;\\n        \\n        while(prevNode.next!=null && prevNode.next.next!=null)\\n        {\\n            ListNode firstNode = prevNode.next;\\n            ListNode secondNode= prevNode.next.next;\\n            \\n            firstNode.next = secondNode.next;\\n            secondNode.next = firstNode;\\n            \\n            prevNode.next = secondNode;\\n            \\n            /*resetting the value for prevNode for iteraton*/\\n            prevNode = firstNode;\\n        }\\n        return tempNode.next;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode SwapPairs(ListNode head) {\\n       \\n\\t\\tListNode tempNode = new ListNode(-1, head);\\n        ListNode prevNode = tempNode;\\n        \\n        while(prevNode.next!=null && prevNode.next.next!=null)\\n        {\\n            ListNode firstNode = prevNode.next;\\n            ListNode secondNode= prevNode.next.next;\\n            \\n            firstNode.next = secondNode.next;\\n            secondNode.next = firstNode;\\n            \\n            prevNode.next = secondNode;\\n            \\n            /*resetting the value for prevNode for iteraton*/\\n            prevNode = firstNode;\\n        }\\n        return tempNode.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1534508,
                "title": "iterative-easy-soln-runtime-0-ms-faster-than-100-00-of-c",
                "content": "\\n\\n        \\n\\tListNode* swapPairs(ListNode* head)\\n\\t{\\n\\t\\tListNode* dummy = new ListNode(-1);\\n\\t\\tdummy->next = head;\\n\\t\\tListNode* prev = dummy;\\n        while(prev->next !=NULL && prev->next->next !=NULL)\\n        {\\n            ListNode* curr = prev->next;\\n            ListNode* forw = curr->next;\\n            ListNode* temp = forw->next;\\n            \\n            prev->next = forw;\\n            forw->next = curr;\\n            curr->next = temp;\\n            \\n            prev = curr;\\n        }\\n        return dummy->next;\\n        \\n    }\\n\\t",
                "solutionTags": [],
                "code": "\\n\\n        \\n\\tListNode* swapPairs(ListNode* head)\\n\\t{\\n\\t\\tListNode* dummy = new ListNode(-1);\\n\\t\\tdummy->next = head;\\n\\t\\tListNode* prev = dummy;\\n        while(prev->next !=NULL && prev->next->next !=NULL)\\n        {\\n            ListNode* curr = prev->next;\\n            ListNode* forw = curr->next;\\n            ListNode* temp = forw->next;\\n            \\n            prev->next = forw;\\n            forw->next = curr;\\n            curr->next = temp;\\n            \\n            prev = curr;\\n        }\\n        return dummy->next;\\n        \\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1101344,
                "title": "python-recursion",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        # recursion\\n        if not head or not head.next: return head\\n        new_head = head.next\\n        head.next = self.swapPairs(new_head.next)\\n        new_head.next = head\\n        return new_head\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        # recursion\\n        if not head or not head.next: return head\\n        new_head = head.next\\n        head.next = self.swapPairs(new_head.next)\\n        new_head.next = head\\n        return new_head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910322,
                "title": "javascript-solution-24",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nlet swapPairs = function(head) {\\n    let dummy=new ListNode();\\n    dummy.next = head;\\n    let result = dummy;\\n    while(dummy.next && dummy.next.next){\\n        let p=dummy.next,q = dummy.next.next;\\n        dummy.next = q;\\n        p.next = q.next;\\n        q.next = p;\\n        dummy = p\\n    }\\n    return result.next\\n};\\n```\\n\\n**Runtime: 72 ms, faster than 87.88% of JavaScript online submissions for Swap Nodes in Pairs.**\\n\\n**Memory Usage: 38.8 MB, less than 40.76% of JavaScript online submissions for Swap Nodes in Pairs.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nlet swapPairs = function(head) {\\n    let dummy=new ListNode();\\n    dummy.next = head;\\n    let result = dummy;\\n    while(dummy.next && dummy.next.next){\\n        let p=dummy.next,q = dummy.next.next;\\n        dummy.next = q;\\n        p.next = q.next;\\n        q.next = p;\\n        dummy = p\\n    }\\n    return result.next\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 748467,
                "title": "python-clean-recursive-and-iterative-solution",
                "content": "Variable names should help understand the solutions easily.\\nRecursive:\\n```\\ndef swapPairs(self, head: ListNode) -> ListNode:\\n    if head is None or head.next is None:\\n        return head\\n    newHead = head.next\\n    head.next = self.swapPairs(newHead.next)\\n    newHead.next = head\\n    return newHead\\n```\\nE.g: [1,2,3,4] -> [2,1,4,3]\\nThere will be 3 calls to swapPairs ( 1 normal call + 2 recursive calls)\\n```\\nswapPairs(1)\\n         swapPairs(3)\\n                  swapPairs(None):\\n                  returns None # swapPairs(None)\\n         returns 4 #swapPairs(3)\\nreturns 2 #swapPairs(1)\\n```\\n\\nIterative:\\n```\\ndef swapPairs(self, head: ListNode) -> ListNode:\\n\\tif head is None or head.next is None:\\n\\t\\treturn head\\n\\tfirst, newHead, previous = head, head.next, None\\n\\twhile first and first.next:\\n\\t\\tif previous:\\n\\t\\t\\tprevious.next = first.next\\n\\t\\tsecond = first.next\\n\\t\\tfirst.next = second.next\\n\\t\\tsecond.next = first\\n\\t\\tprevious = first\\n\\t\\tfirst = first.next\\n\\treturn newHead\\n",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\ndef swapPairs(self, head: ListNode) -> ListNode:\\n    if head is None or head.next is None:\\n        return head\\n    newHead = head.next\\n    head.next = self.swapPairs(newHead.next)\\n    newHead.next = head\\n    return newHead\\n```\n```\\nswapPairs(1)\\n         swapPairs(3)\\n                  swapPairs(None):\\n                  returns None # swapPairs(None)\\n         returns 4 #swapPairs(3)\\nreturns 2 #swapPairs(1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 655218,
                "title": "c-100-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if(!head || !head->next) return head;\\n        \\n        // get length \\n        ListNode* cur = head; int len=0;\\n        while(cur) {\\n            cur=cur->next; ++len;\\n        }\\n        \\n        ListNode* cur1 = head;   ListNode* cur2 = head->next;  ListNode* head2 = cur2;\\n        ListNode* cur3=NULL;\\n        \\n        while (cur2->next!=NULL) {\\n            \\n            cur1->next = cur2->next;\\n            cur2->next = cur1;\\n            \\n            cur3 = cur1;\\n            \\n            if(cur1->next->next!=NULL) { // so that cur2 is not NULL\\n                cur1 = cur1->next;\\n                cur2 = cur1->next;\\n          \\n                cur3->next = cur2;\\n            }\\n            else\\n                break;\\n        }\\n        \\n        if(len%2==0) {\\n            cur2->next = cur1;\\n            cur1->next = NULL;\\n        }\\n        \\n        return head2;\\n    }\\n};\\n\\n```\\n![image](https://assets.leetcode.com/users/duttaani/image_1590587889.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if(!head || !head->next) return head;\\n        \\n        // get length \\n        ListNode* cur = head; int len=0;\\n        while(cur) {\\n            cur=cur->next; ++len;\\n        }\\n        \\n        ListNode* cur1 = head;   ListNode* cur2 = head->next;  ListNode* head2 = cur2;\\n        ListNode* cur3=NULL;\\n        \\n        while (cur2->next!=NULL) {\\n            \\n            cur1->next = cur2->next;\\n            cur2->next = cur1;\\n            \\n            cur3 = cur1;\\n            \\n            if(cur1->next->next!=NULL) { // so that cur2 is not NULL\\n                cur1 = cur1->next;\\n                cur2 = cur1->next;\\n          \\n                cur3->next = cur2;\\n            }\\n            else\\n                break;\\n        }\\n        \\n        if(len%2==0) {\\n            cur2->next = cur1;\\n            cur1->next = NULL;\\n        }\\n        \\n        return head2;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 284762,
                "title": "js-solution-faster-than-100",
                "content": "```\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function (head) {\\n    //dummy node\\n    dummy = new ListNode(0)\\n    dummy.next = head\\n\\n    current = dummy\\n    while (current.next && current.next.next) {\\n        temp1 = current.next\\n        temp2 = current.next.next\\n\\n        current.next.next = current.next.next.next\\n        current.next = temp2\\n        current.next.next = temp1\\n\\n        //current move to next 2 pos\\n        current = current.next.next\\n    }\\n\\n    return dummy.next\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function (head) {\\n    //dummy node\\n    dummy = new ListNode(0)\\n    dummy.next = head\\n\\n    current = dummy\\n    while (current.next && current.next.next) {\\n        temp1 = current.next\\n        temp2 = current.next.next\\n\\n        current.next.next = current.next.next.next\\n        current.next = temp2\\n        current.next.next = temp1\\n\\n        //current move to next 2 pos\\n        current = current.next.next\\n    }\\n\\n    return dummy.next\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 176015,
                "title": "simple-go-solution",
                "content": "```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n        list := &ListNode{Next: head}\\n        for prev, node := list, list.Next; node != nil; node = node.Next {\\n                if node.Next != nil {\\n                        swapNode(prev, node, node.Next)\\n                        prev = node\\n                }\\n        }\\n        return list.Next\\n}\\n\\nfunc swapNode(prev, node, next *ListNode) {\\n        prev.Next = next\\n        node.Next = next.Next\\n        next.Next = node\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n        list := &ListNode{Next: head}\\n        for prev, node := list, list.Next; node != nil; node = node.Next {\\n                if node.Next != nil {\\n                        swapNode(prev, node, node.Next)\\n                        prev = node\\n                }\\n        }\\n        return list.Next\\n}\\n\\nfunc swapNode(prev, node, next *ListNode) {\\n        prev.Next = next\\n        node.Next = next.Next\\n        next.Next = node\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11195,
                "title": "java-0ms-using-recusion",
                "content": "    public ListNode swapPairs(ListNode head) {\\n\\t\\tif(head == null || head.next == null)\\n\\t\\t\\treturn head;\\n\\t\\t\\n\\t\\tListNode p1 = head, p2 = head.next, p3 = null;\\n\\t\\tp3 = p2.next;\\n\\t\\tp2.next = null;\\n\\t\\tp1.next.next = p1;\\n\\t\\tp1.next = p3;\\n\\t\\t\\n\\t\\tif(p3 != null)\\n\\t\\t\\tp1.next = swapPairs(p3);\\n\\t\\t\\n\\t\\treturn p2;\\n\\t}",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "    public ListNode swapPairs(ListNode head) {\\n\\t\\tif(head == null || head.next == null)\\n\\t\\t\\treturn head;\\n\\t\\t\\n\\t\\tListNode p1 = head, p2 = head.next, p3 = null;\\n\\t\\tp3 = p2.next;\\n\\t\\tp2.next = null;\\n\\t\\tp1.next.next = p1;\\n\\t\\tp1.next = p3;\\n\\t\\t\\n\\t\\tif(p3 != null)\\n\\t\\t\\tp1.next = swapPairs(p3);\\n\\t\\t\\n\\t\\treturn p2;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 11222,
                "title": "my-solution-c",
                "content": "        ListNode* swapPairs(ListNode* head) {\\n            ListNode* p1;       \\n            if(head && head->next){  \\n                p1 = head->next; \\n                head->next = swapPairs(head->next->next);\\n                p1->next = head;\\n                head = p1; \\n           }\\n           return head;\\n    }",
                "solutionTags": [],
                "code": "        ListNode* swapPairs(ListNode* head) {\\n            ListNode* p1;       \\n            if(head && head->next){  \\n                p1 = head->next; \\n                head->next = swapPairs(head->next->next);\\n                p1->next = head;\\n                head = p1; \\n           }\\n           return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 11343,
                "title": "runtime-0ms-in-c",
                "content": "struct ListNode* swapPairs(struct ListNode* head) {\\n    \\n    struct ListNode* dummy=head;\\n    struct ListNode* prev=NULL;\\n    struct ListNode* Nextnode=NULL;\\n\\n\\n    if(!dummy)\\n          return head;\\n    \\n    while(dummy!=NULL && dummy->next!=NULL){\\n        \\n        Nextnode=dummy->next;\\n        dummy->next=Nextnode->next;\\n        \\n        if(prev)\\n          prev->next=Nextnode;\\n        else\\n          head=Nextnode;\\n          \\n        Nextnode->next=dummy;\\n        \\n        prev=dummy;\\n\\n        dummy=dummy->next;\\n           \\n           \\n    }\\n    \\n    return head;\\n}",
                "solutionTags": [],
                "code": "struct ListNode* swapPairs(struct ListNode* head) {\\n    \\n    struct ListNode* dummy=head;\\n    struct ListNode* prev=NULL;\\n    struct ListNode* Nextnode=NULL;\\n\\n\\n    if(!dummy)\\n          return head;\\n    \\n    while(dummy!=NULL && dummy->next!=NULL){\\n        \\n        Nextnode=dummy->next;\\n        dummy->next=Nextnode->next;\\n        \\n        if(prev)\\n          prev->next=Nextnode;\\n        else\\n          head=Nextnode;\\n          \\n        Nextnode->next=dummy;\\n        \\n        prev=dummy;\\n\\n        dummy=dummy->next;\\n           \\n           \\n    }\\n    \\n    return head;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3585152,
                "title": "best-o-n-solution",
                "content": "# Approach\\nOptimal Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head == NULL || head->next == NULL)\\n            return head;\\n        ListNode* dummy = new ListNode();\\n        ListNode* temp = dummy;\\n        while (head != NULL && head->next != NULL) {\\n            ListNode* cur = head->next->next;\\n            temp->next = head->next;\\n            temp = head;\\n            head->next->next = head;\\n            head->next = cur;\\n            head = cur;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head == NULL || head->next == NULL)\\n            return head;\\n        ListNode* dummy = new ListNode();\\n        ListNode* temp = dummy;\\n        while (head != NULL && head->next != NULL) {\\n            ListNode* cur = head->next->next;\\n            temp->next = head->next;\\n            temp = head;\\n            head->next->next = head;\\n            head->next = cur;\\n            head = cur;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534681,
                "title": "100-beats-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head || !head->next){\\n            return head;\\n        }\\n        ListNode* p = head,*q=head->next;\\n        while(true){\\n            swap(p->val,q->val);\\n            if(!(q->next && q->next->next))break;\\n            p = p->next->next;\\n            q = q->next->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head || !head->next){\\n            return head;\\n        }\\n        ListNode* p = head,*q=head->next;\\n        while(true){\\n            swap(p->val,q->val);\\n            if(!(q->next && q->next->next))break;\\n            p = p->next->next;\\n            q = q->next->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531446,
                "title": "c-by-swapping-the-values-of-the-adjacent-nodes-t-c-o-n",
                "content": "# Intuition\\nTraverse the list and swap pairs of nodes one by one.\\n# Approach\\n![53a7a769-ce39-4d7d-9e37-cd0420f72bf0_1644988593.5987253.jpeg](https://assets.leetcode.com/users/images/1c079065-d5e5-478f-80bb-c20f4881d340_1684253393.321737.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)(where n is number of nodes in the linked list)\\n\\n- Space complexity:\\nO(1)-> since we are just changing the value of the nodes by swapping so no extra space is used.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n    class Solution {\\n\\npublic:\\n\\n    ListNode* swapPairs(ListNode* head) {\\n\\n        if(head==NULL)return head;\\n\\n        if(head->next==NULL)return head;\\n\\n        \\n\\n        ListNode*curr=head->next;\\n\\n        ListNode*prev=head;\\n\\n        swap(curr->val,prev->val);\\n\\n        while(prev->next->next!=NULL&&curr->next->next!=NULL){\\n\\n            prev=prev->next->next;\\n\\n            curr=curr->next->next;\\n\\n            swap(curr->val,prev->val);\\n\\n        }\\n\\n        return head;\\n\\n        \\n\\n    }\\n\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n    class Solution {\\n\\npublic:\\n\\n    ListNode* swapPairs(ListNode* head) {\\n\\n        if(head==NULL)return head;\\n\\n        if(head->next==NULL)return head;\\n\\n        \\n\\n        ListNode*curr=head->next;\\n\\n        ListNode*prev=head;\\n\\n        swap(curr->val,prev->val);\\n\\n        while(prev->next->next!=NULL&&curr->next->next!=NULL){\\n\\n            prev=prev->next->next;\\n\\n            curr=curr->next->next;\\n\\n            swap(curr->val,prev->val);\\n\\n        }\\n\\n        return head;\\n\\n        \\n\\n    }\\n\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531230,
                "title": "python-3-4-lines-recursion-t-m-98-65",
                "content": "```\\nclass Solution:\\n    def swapPairs(self, head):\\n\\n        if not(head and head.next): return head \\n\\n        newHead = head.next\\n        head.next, newHead.next = self.swapPairs(head.next.next), head\\n\\n        return newHead\\n```\\n[https://leetcode.com/submissions/detail/582543531/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head):\\n\\n        if not(head and head.next): return head \\n\\n        newHead = head.next\\n        head.next, newHead.next = self.swapPairs(head.next.next), head\\n\\n        return newHead\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531172,
                "title": "easy-solution-java-iterative-swap",
                "content": "# Approach\\nThe provided code implements a method called `swapPairs` in a class. This method swaps adjacent pairs of nodes in a singly linked list. Here\\'s the breakdown of the approach used:\\n\\n1. The method takes a parameter `head`, which represents the head node of the linked list.\\n\\n2. The first step is to check if the `head` is `null` or if there is only one node in the list (`head.next == null`). In either case, there is no need to swap any nodes, so the method returns the `head` as it is.\\n\\n3. If there are at least two nodes in the list, a new dummy node called `ans` is created with a value of 0. The `ans.next` is set to the original `head` of the list. This dummy node serves as the new head of the modified list, which will make it easier to handle the edge case of swapping the first two nodes.\\n\\n4. Two pointers, `temp` and `temp1`, are initialized with `head` and `ans` respectively. These pointers will be used to traverse the list and perform the node swaps.\\n\\n5. The main loop runs as long as `temp` is not `null` and `temp.next` is not `null`. This loop processes pairs of nodes in the list until there are no more pairs left to swap.\\n\\n6. Inside the loop, a new node `forw` is assigned as the next node after `temp`. This node represents the second node of the current pair.\\n\\n7. The following steps perform the swapping:\\n   - `temp.next` is updated to skip the second node (`forw`).\\n   - `forw.next` is set to `temp`, making `temp` the second node in the pair.\\n   - `temp1.next` is set to `forw`, connecting the swapped pair to the modified list.\\n   - `temp1` is updated to `temp`, so it now represents the last node that was swapped.\\n   - `temp` is updated to `temp.next` to move to the next pair of nodes.\\n\\n8. Once the loop is completed, the modified list is obtained by accessing `ans.next`. This returns the head of the modified linked list.\\n\\n9. Finally, the modified list is returned as the result.\\n\\nOverall, this approach uses iterative traversal and manipulation of the linked list to swap adjacent pairs of nodes. It employs a dummy node to simplify the handling of the first pair.\\n\\n# Complexity\\n- Time complexity:\\n    - The time complexity of the swapPairs method is O(n).\\n- Space complexity:\\n    - The space complexity of the method is O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }        \\n        ListNode ans = new ListNode(0);\\n        ans.next = head;       \\n        ListNode temp = head;\\n        ListNode temp1 = ans;\\n        \\n        while (temp != null && temp.next != null) {\\n            ListNode forw = temp.next;\\n            temp.next = forw.next;\\n            forw.next = temp;\\n            temp1.next = forw;\\n            temp1 = temp;\\n            temp = temp.next;\\n        }\\n        \\n        return ans.next;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }        \\n        ListNode ans = new ListNode(0);\\n        ans.next = head;       \\n        ListNode temp = head;\\n        ListNode temp1 = ans;\\n        \\n        while (temp != null && temp.next != null) {\\n            ListNode forw = temp.next;\\n            temp.next = forw.next;\\n            forw.next = temp;\\n            temp1.next = forw;\\n            temp1 = temp;\\n            temp = temp.next;\\n        }\\n        \\n        return ans.next;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529795,
                "title": "beats-100-time-ands-90-space",
                "content": "**Italic**# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void ans(ListNode*&temp,ListNode*&curr,ListNode*a){\\n        a=curr;\\n        if(temp==NULL || temp->next==NULL)return;\\n        temp->next=NULL;\\n        temp->next=curr->next;\\n        curr->next=temp;\\n        ListNode*prev = temp;\\n\\n        temp=temp->next;\\n        if(temp==NULL || temp->next==NULL)return;\\n        curr=temp->next;\\n        prev->next=curr;\\n        ans(temp,curr,a);\\n    }\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL)return NULL;\\n        if(head->next==NULL)return head;\\n        ListNode*temp=head;\\n        ListNode*curr = head->next;\\n        ListNode*a=curr;\\n        ans(temp,curr,a);\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void ans(ListNode*&temp,ListNode*&curr,ListNode*a){\\n        a=curr;\\n        if(temp==NULL || temp->next==NULL)return;\\n        temp->next=NULL;\\n        temp->next=curr->next;\\n        curr->next=temp;\\n        ListNode*prev = temp;\\n\\n        temp=temp->next;\\n        if(temp==NULL || temp->next==NULL)return;\\n        curr=temp->next;\\n        prev->next=curr;\\n        ans(temp,curr,a);\\n    }\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL)return NULL;\\n        if(head->next==NULL)return head;\\n        ListNode*temp=head;\\n        ListNode*curr = head->next;\\n        ListNode*a=curr;\\n        ans(temp,curr,a);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529774,
                "title": "easy-java-solution-detailed-explanation-two-pointers-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question by two ways that are Two Pointers and Recursion.\\nHere I have use two pointer approach, Folks who does not wanted recursive space can go through my approach.  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere I have taken dummy Node which next will points to head of LikedList. Use of this dummy node is that we have to return head of LinkedList and if we swap then head will change, so we can return dummy.next (new head).\\n1. I have taken two pointers that are pre and curr, pre will points to dummy node and curr will points head of LinkedList\\n![WhatsApp Image 2023-05-16 at 11.29.57 AM.jpeg](https://assets.leetcode.com/users/images/05ec86d4-6fc7-4c8b-80b2-17d9c22e173b_1684219328.4818847.jpeg)\\n\\n2. Here I have done connetion of pre\\'s next node to curr\\'s node next node.\\n```java []\\npre.next=curr.next;\\n```\\n\\n![WhatsApp Image 2023-05-16 at 11.38.00 AM.jpeg](https://assets.leetcode.com/users/images/af90cb2b-1003-4027-ae43-3e67f2a59cca_1684219425.2694046.jpeg)\\n\\n3. After this, I break curr\\'s next node (node 2) connection and establish it\\'s next connection to pre\\'s next of next node (node 3).\\n```java []\\ncurr.next=pre.next.next;\\n```\\n\\n![WhatsApp Image 2023-05-16 at 11.45.00 AM.jpeg](https://assets.leetcode.com/users/images/f62f9709-1fa5-42bc-8523-07cb507f1e42_1684219589.7843626.jpeg)\\n\\n4. This is the main step, here the swapping of node are done by doing pre\\'s next of next node to curr node.\\n```java []\\npre.next.next=curr;\\n```\\n![WhatsApp Image 2023-05-16 at 11.53.43 AM.jpeg](https://assets.leetcode.com/users/images/43ca3fc2-d1ec-47a5-85d9-bd6eddc3ce47_1684219689.5950298.jpeg)\\n\\n5. Here we simply update our pre node (node 0) to curr node (node 1) and curr node (node 1) to pre next node (node 3).\\n```java []\\npre=curr;\\ncurr=pre.next;\\n```\\n![WhatsApp Image 2023-05-16 at 12.00.35 PM.jpeg](https://assets.leetcode.com/users/images/a4910cb9-5d0c-45bd-a08e-b181626953cf_1684219778.19854.jpeg)\\n\\n6. While loop will get false when either curr will become null of curr next node will beacome null, and last dummy\\'s next node will return.\\n```java []\\nreturn dummy.next;\\n```\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next=head;\\n        ListNode pre=dummy;\\n        ListNode curr=pre.next;\\n\\n        while(curr!=null && curr.next!=null){\\n            pre.next=curr.next;\\n            curr.next=pre.next.next;\\n            pre.next.next=curr;\\n\\n            pre=curr;\\n            curr=pre.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```java []\\npre.next=curr.next;\\n```\n```java []\\ncurr.next=pre.next.next;\\n```\n```java []\\npre.next.next=curr;\\n```\n```java []\\npre=curr;\\ncurr=pre.next;\\n```\n```java []\\nreturn dummy.next;\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next=head;\\n        ListNode pre=dummy;\\n        ListNode curr=pre.next;\\n\\n        while(curr!=null && curr.next!=null){\\n            pre.next=curr.next;\\n            curr.next=pre.next.next;\\n            pre.next.next=curr;\\n\\n            pre=curr;\\n            curr=pre.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529173,
                "title": "very-easy-c-soln-beats-100-beginner-friendly",
                "content": "**Please upVote if it helps.**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* prev=head,*curr=head->next,*ans=head->next;\\n        \\n        while(1)\\n        {\\n            prev->next = curr->next;\\n            curr->next=prev;\\n            ListNode* temp=prev->next;\\n            if(temp==NULL)\\n                break;\\n            curr=temp->next;\\n            if(curr==NULL)\\n                break;\\n            prev->next=curr;\\n            prev=temp;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* prev=head,*curr=head->next,*ans=head->next;\\n        \\n        while(1)\\n        {\\n            prev->next = curr->next;\\n            curr->next=prev;\\n            ListNode* temp=prev->next;\\n            if(temp==NULL)\\n                break;\\n            curr=temp->next;\\n            if(curr==NULL)\\n                break;\\n            prev->next=curr;\\n            prev=temp;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132394,
                "title": "easy-python-solution-using-lists-runtime-97",
                "content": "\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        lst=[]\\n        while head:\\n            lst.append(head.val)\\n            head=head.next\\n        ans=[]\\n        for i in range(0,len(lst),2):\\n            val=lst[i:i+2]\\n            ans+=val[::-1]\\n        final=ListNode(0)\\n        tmp=final\\n        for i in ans:\\n            tmp.next=ListNode(i)\\n            tmp=tmp.next\\n        return final.next\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        lst=[]\\n        while head:\\n            lst.append(head.val)\\n            head=head.next\\n        ans=[]\\n        for i in range(0,len(lst),2):\\n            val=lst[i:i+2]\\n            ans+=val[::-1]\\n        final=ListNode(0)\\n        tmp=final\\n        for i in ans:\\n            tmp.next=ListNode(i)\\n            tmp=tmp.next\\n        return final.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070647,
                "title": "95-javascript-very-easy-to-understand-with-video-explanation",
                "content": "Here is video for explain if it is helpful please subscribe! :\\n\\nhttps://youtu.be/p8x7qjD1wEM\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function(head) {\\n    let arr = []\\n    let res = new ListNode()\\n    let copy = res;\\n    while(head){\\n        arr.push(head.val)\\n        head = head.next;\\n    }\\n    let len = arr.length % 2 ==0 ? arr.length : arr.length-1;\\n    \\n    for(let i =0; i <len; i++){\\n        if(i % 2 == 0) copy.next = new ListNode(arr[i+1])\\n        else copy.next = new ListNode(arr[i-1])\\n        copy = copy.next;\\n    }\\n    if(arr.length % 2 ==1){\\n        copy.next = new ListNode(arr[arr.length-1])\\n        copy = copy.next;\\n    }\\n    return res.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function(head) {\\n    let arr = []\\n    let res = new ListNode()\\n    let copy = res;\\n    while(head){\\n        arr.push(head.val)\\n        head = head.next;\\n    }\\n    let len = arr.length % 2 ==0 ? arr.length : arr.length-1;\\n    \\n    for(let i =0; i <len; i++){\\n        if(i % 2 == 0) copy.next = new ListNode(arr[i+1])\\n        else copy.next = new ListNode(arr[i-1])\\n        copy = copy.next;\\n    }\\n    if(arr.length % 2 ==1){\\n        copy.next = new ListNode(arr[arr.length-1])\\n        copy = copy.next;\\n    }\\n    return res.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2955805,
                "title": "c-easy-recursive-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* node1 = head;\\n        ListNode* node2 = head->next;\\n        node1->next = swapPairs(node2->next);\\n        node2->next = node1;\\n        return node2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* node1 = head;\\n        ListNode* node2 = head->next;\\n        node1->next = swapPairs(node2->next);\\n        node2->next = node1;\\n        return node2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654022,
                "title": "24-super-easy-connection",
                "content": "**time complexity - O(n) space-O(1)**\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # MAKE a dummy node\\n        dummy = prev = ListNode(0)\\n        prev.next = head\\n        \\n        # prev-a-b-c-d-e\\n        # prev-b-a-c\\n        while head and head.next:\\n            a = head \\n            b = a.next \\n            c = b.next \\n            \\n            prev.next = b \\n            b.next = a \\n            a.next = c\\n            \\n            prev= a\\n            head= c\\n        \\n        \\n        return dummy.next\\n\\t\\t\\n\\t\\t\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # MAKE a dummy node\\n        dummy = prev = ListNode(0)\\n        prev.next = head\\n        \\n        # prev-a-b-c-d-e\\n        # prev-b-a-c\\n        while head and head.next:\\n            a = head \\n            b = a.next \\n            c = b.next \\n            \\n            prev.next = b \\n            b.next = a \\n            a.next = c\\n            \\n            prev= a\\n            head= c\\n        \\n        \\n        return dummy.next\\n\\t\\t\\n\\t\\t\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2588735,
                "title": "recursion-7-lines-python-solution",
                "content": "```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def swap(node):\\n            if not node or not node.next:\\n                return node\\n            first, second = node, node.next\\n            first.next, second.next = second.next,first\\n            first.next = swap(first.next)\\n            return second\\n       \\n        return swap(head)\\n   ```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def swap(node):\\n            if not node or not node.next:\\n                return node\\n            first, second = node, node.next\\n            first.next, second.next = second.next,first\\n            first.next = swap(first.next)\\n            return second\\n       \\n        return swap(head)\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 2420385,
                "title": "java-solution-with-pointer",
                "content": "The code is commented and if you are familiar with using pointers and linkedlist you may be able to understand it \\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null) return null;\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        \\n        ListNode currentPtr = dummy ; // for iteration\\n        \\n        while(currentPtr.next != null && currentPtr.next.next != null ){\\n            ListNode firstNode = currentPtr.next ; \\n            ListNode secondNode  = currentPtr.next.next;\\n            // swaping nodes by replacing next wrt the currentPtr, which points to dummy atm\\n            firstNode.next = secondNode.next;\\n            currentPtr.next = secondNode;\\n            currentPtr.next.next = firstNode; \\n            \\n            // now, currentPtr will move to the 2nd node, then currentPtr.next will become first             //   node for the second pair\\n            currentPtr = currentPtr.next.next;\\n            \\n        }\\n        // our dummy is empty so after that lies our first node(head of the new list)\\n        return dummy.next;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null) return null;\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        \\n        ListNode currentPtr = dummy ; // for iteration\\n        \\n        while(currentPtr.next != null && currentPtr.next.next != null ){\\n            ListNode firstNode = currentPtr.next ; \\n            ListNode secondNode  = currentPtr.next.next;\\n            // swaping nodes by replacing next wrt the currentPtr, which points to dummy atm\\n            firstNode.next = secondNode.next;\\n            currentPtr.next = secondNode;\\n            currentPtr.next.next = firstNode; \\n            \\n            // now, currentPtr will move to the 2nd node, then currentPtr.next will become first             //   node for the second pair\\n            currentPtr = currentPtr.next.next;\\n            \\n        }\\n        // our dummy is empty so after that lies our first node(head of the new list)\\n        return dummy.next;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347917,
                "title": "c-100-faster-recursive-solution",
                "content": "```\\nvoid swa(ListNode*head)\\n    {\\n        if(head==NULL || head->next==NULL || head->next->next==NULL)\\n            return;\\n        ListNode*t=head->next;\\n        head->next=t->next;\\n        t->next=t->next->next;\\n        head->next->next=t;\\n        swa(head->next->next);\\n        \\n    }\\n    ListNode* swapPairs(ListNode* head) {\\n        // return NULL;\\n        if(!head || !head->next)return head;\\n       ListNode*temp=head->next;\\n        head->next=temp->next;\\n        temp->next=head;\\n        head=temp;\\n        swa(head->next);\\n       return head;\\n    }",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nvoid swa(ListNode*head)\\n    {\\n        if(head==NULL || head->next==NULL || head->next->next==NULL)\\n            return;\\n        ListNode*t=head->next;\\n        head->next=t->next;\\n        t->next=t->next->next;\\n        head->next->next=t;\\n        swa(head->next->next);\\n        \\n    }\\n    ListNode* swapPairs(ListNode* head) {\\n        // return NULL;\\n        if(!head || !head->next)return head;\\n       ListNode*temp=head->next;\\n        head->next=temp->next;\\n        temp->next=head;\\n        head=temp;\\n        swa(head->next);\\n       return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2245683,
                "title": "simple-python-reccursion-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head == None or head.next == None:\\n            return head\\n        \\n        first = head\\n        second = head.next\\n        third = second.next\\n        \\n        second.next = first\\n        first.next = self.swapPairs(third)\\n        return second\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head == None or head.next == None:\\n            return head\\n        \\n        first = head\\n        second = head.next\\n        third = second.next\\n        \\n        second.next = first\\n        first.next = self.swapPairs(third)\\n        return second\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990913,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\npublic ListNode swapPairs(ListNode leftNode){\\n        if (leftNode == null || leftNode.next == null){\\n            return leftNode;\\n        }\\n        \\n        ListNode rightNode = leftNode.next;\\n        leftNode.next = swapPairs(rightNode.next);\\n        rightNode.next = leftNode;\\n        return rightNode;\\n    }\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nclass Solution {\\npublic:\\n\\tListNode* swapPairs(ListNode* head) {\\n\\t\\tif(!head || !head->next) return head;\\n\\t\\t\\n\\t\\tListNode* prev=head;ListNode* curr=head;\\n\\t\\thead=head->next;\\n\\t\\twhile(curr && curr->next){\\n\\t\\t\\tprev->next=curr->next;\\n\\n\\t\\t\\tprev=curr;\\n\\t\\t\\tcurr=curr->next;\\n\\t\\t\\tprev->next=curr->next;\\n\\t\\t\\tcurr->next=prev;\\n\\t\\t\\tcurr=curr->next->next;}\\n\\t\\treturn head;\\n\\n\\t}\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tif not head: return head\\n\\n\\tprev, cur, ans = None, head, head.next\\n\\twhile cur and cur.next:\\n\\t\\tadj = cur.next\\n\\t\\tif prev: prev.next = adj\\n\\n\\t\\tcur.next, adj.next = adj.next, cur\\n\\t\\tprev, cur = cur, cur.next\\n\\n\\treturn ans or head\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nconst swapPairs = data => {\\n  let current = data;\\n  let count = 0;\\n  while (current) {\\n    if (count % 2 === 0 && current.next) {\\n      const tmp = current.val;\\n      current.val = current.next.val;\\n      current.next.val = tmp; \\n    }\\n    count++;\\n    current = current.next;\\n  }\\n  return data;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nclass Solution {\\n    fun swapPairs(head: ListNode?): ListNode? {\\n\\t\\n\\t\\t// if we got empty list return null\\n        head ?: return null\\n\\n\\t\\t// create a pointer, pointing to second element in the list \\n\\t\\t// we will handle the case of swapping first two elements\\n\\t\\t// in the list later\\n        var ptr: ListNode? = head?.next\\n\\n        // in case of list with single element, return the list as\\n\\t\\t// swapping is not possible with just one element\\n        ptr ?: return head\\n\\n        while (ptr?.next != null) {\\n\\t\\t\\t// assign a temp pointer pointing to first of the two elements\\n\\t\\t\\t// to be swapped (we\\'re swapping in chunks on two in entire list)\\n\\t\\t\\t// so, for eg, if the list is 1 -> 2 -> 3 -> 4 -> 5, variable ptr \\n\\t\\t\\t// will point to 2 and variable temp will point to 3 in first pass\\n\\t\\t\\t// of this while loop\\n            val temp = ptr?.next \\n\\n\\t\\t\\t// check if the next chunk of two numbers exist or not\\n\\t\\t\\t// this check will handle lists with odd number of nodes\\n\\t\\t\\t// as the last nodes will not end up being swapped\\n            if (ptr?.next?.next != null) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// swap the two nodes\\n                ptr?.next = ptr?.next?.next \\n                temp?.next = ptr?.next?.next \\n                ptr?.next?.next = temp\\n            }\\n\\n\\t\\t\\t// move the pointer by two nodes, remember we\\'re swapping\\n\\t\\t\\t// in chunks of two?\\n            ptr = ptr?.next?.next\\n        }\\n\\n        // swap elements at head\\n        ptr = head\\n        val temp: ListNode? = head?.next\\n        ptr?.next = temp?.next\\n        temp?.next = ptr\\n        return temp\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func swapPairs(_ head: ListNode?) -> ListNode? {\\n        if head == nil || head?.next == nil { return head }\\n        let res = head?.next\\n        head?.next = swapPairs(res?.next)\\n        res?.next = head\\n        return res\\n    }\\n    \\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\npublic ListNode swapPairs(ListNode leftNode){\\n        if (leftNode == null || leftNode.next == null){\\n            return leftNode;\\n        }\\n        \\n        ListNode rightNode = leftNode.next;\\n        leftNode.next = swapPairs(rightNode.next);\\n        rightNode.next = leftNode;\\n        return rightNode;\\n    }\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n\\tListNode* swapPairs(ListNode* head) {\\n\\t\\tif(!head || !head->next) return head;\\n\\t\\t\\n\\t\\tListNode* prev=head;ListNode* curr=head;\\n\\t\\thead=head->next;\\n\\t\\twhile(curr && curr->next){\\n\\t\\t\\tprev->next=curr->next;\\n\\n\\t\\t\\tprev=curr;\\n\\t\\t\\tcurr=curr->next;\\n\\t\\t\\tprev->next=curr->next;\\n\\t\\t\\tcurr->next=prev;\\n\\t\\t\\tcurr=curr->next->next;}\\n\\t\\treturn head;\\n\\n\\t}\\n};\\n```\n```\\n```\n```\\n```\n```\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tif not head: return head\\n\\n\\tprev, cur, ans = None, head, head.next\\n\\twhile cur and cur.next:\\n\\t\\tadj = cur.next\\n\\t\\tif prev: prev.next = adj\\n\\n\\t\\tcur.next, adj.next = adj.next, cur\\n\\t\\tprev, cur = cur, cur.next\\n\\n\\treturn ans or head\\n```\n```\\n```\n```\\n```\n```\\nconst swapPairs = data => {\\n  let current = data;\\n  let count = 0;\\n  while (current) {\\n    if (count % 2 === 0 && current.next) {\\n      const tmp = current.val;\\n      current.val = current.next.val;\\n      current.next.val = tmp; \\n    }\\n    count++;\\n    current = current.next;\\n  }\\n  return data;\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    fun swapPairs(head: ListNode?): ListNode? {\\n\\t\\n\\t\\t// if we got empty list return null\\n        head ?: return null\\n\\n\\t\\t// create a pointer, pointing to second element in the list \\n\\t\\t// we will handle the case of swapping first two elements\\n\\t\\t// in the list later\\n        var ptr: ListNode? = head?.next\\n\\n        // in case of list with single element, return the list as\\n\\t\\t// swapping is not possible with just one element\\n        ptr ?: return head\\n\\n        while (ptr?.next != null) {\\n\\t\\t\\t// assign a temp pointer pointing to first of the two elements\\n\\t\\t\\t// to be swapped (we\\'re swapping in chunks on two in entire list)\\n\\t\\t\\t// so, for eg, if the list is 1 -> 2 -> 3 -> 4 -> 5, variable ptr \\n\\t\\t\\t// will point to 2 and variable temp will point to 3 in first pass\\n\\t\\t\\t// of this while loop\\n            val temp = ptr?.next \\n\\n\\t\\t\\t// check if the next chunk of two numbers exist or not\\n\\t\\t\\t// this check will handle lists with odd number of nodes\\n\\t\\t\\t// as the last nodes will not end up being swapped\\n            if (ptr?.next?.next != null) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// swap the two nodes\\n                ptr?.next = ptr?.next?.next \\n                temp?.next = ptr?.next?.next \\n                ptr?.next?.next = temp\\n            }\\n\\n\\t\\t\\t// move the pointer by two nodes, remember we\\'re swapping\\n\\t\\t\\t// in chunks of two?\\n            ptr = ptr?.next?.next\\n        }\\n\\n        // swap elements at head\\n        ptr = head\\n        val temp: ListNode? = head?.next\\n        ptr?.next = temp?.next\\n        temp?.next = ptr\\n        return temp\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func swapPairs(_ head: ListNode?) -> ListNode? {\\n        if head == nil || head?.next == nil { return head }\\n        let res = head?.next\\n        head?.next = swapPairs(res?.next)\\n        res?.next = head\\n        return res\\n    }\\n    \\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965896,
                "title": "python-iterative-solution-w-o-temporary-variables",
                "content": "```\\n def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        dummy = ListNode(val=None,next=head)\\n        \\n        prev = dummy\\n        cur = head\\n        \\n        while cur and cur.next:\\n            \\n            prev.next, cur.next.next, cur.next, prev, cur = cur.next, cur, cur.next.next, cur, cur.next.next\\n        \\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        dummy = ListNode(val=None,next=head)\\n        \\n        prev = dummy\\n        cur = head\\n        \\n        while cur and cur.next:\\n            \\n            prev.next, cur.next.next, cur.next, prev, cur = cur.next, cur, cur.next.next, cur, cur.next.next\\n        \\n        return dummy.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1775864,
                "title": "c-o-n-simple-solution-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)return head;\\n        ListNode* temp = new ListNode;\\n        temp->next = head;\\n        ListNode* prev = temp;\\n        ListNode* cur = head;\\n        while(cur && cur->next){\\n            prev->next = cur->next;\\n            prev = prev->next;\\n            cur->next = prev->next;\\n            prev->next = cur;\\n            prev = cur;\\n            cur = cur->next;\\n        }\\n        return temp->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)return head;\\n        ListNode* temp = new ListNode;\\n        temp->next = head;\\n        ListNode* prev = temp;\\n        ListNode* cur = head;\\n        while(cur && cur->next){\\n            prev->next = cur->next;\\n            prev = prev->next;\\n            cur->next = prev->next;\\n            prev->next = cur;\\n            prev = cur;\\n            cur = cur->next;\\n        }\\n        return temp->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775090,
                "title": "2-java-solution-with-comments-recursive-and-iterative",
                "content": "1.take three pointers. prev, curr, next. and create arbitary node with dummy value and point it to head. by this we don\\'t need to handle head conditions.\\n2.initially curr will point to head and prev to dummynode and next to curr.next node.\\n3.loop till we curr and curr.next available. and perform below step.\\n4.just swap nodes next and curr. and after that reassign values of prev, curr and next to right position so that we can again swap curr with next.\\n\\n```\\npublic ListNode swapPairs(ListNode head) {\\n        if(head==null || head.next==null) {\\n            return head;\\n        }\\n        ListNode tempHead = new ListNode(-1);\\n        ListNode prev = tempHead;\\n        ListNode curr=head;\\n        while(curr!=null && curr.next!=null) {\\n            ListNode next=curr.next;\\n            curr.next=next.next;\\n            next.next=curr;\\n            prev.next=next;\\n            prev=curr;\\n            curr=curr.next;\\n        }\\n        return tempHead.next;\\n    }\\n```\\n\\nRecursive ->\\n```\\npublic ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t\\tListNode second = head.next;\\n\\t\\tListNode third = second.next;\\n\\t\\tsecond.next=(head);\\n\\t\\thead.next=(swapPairs(third));\\n\\t\\treturn second;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\npublic ListNode swapPairs(ListNode head) {\\n        if(head==null || head.next==null) {\\n            return head;\\n        }\\n        ListNode tempHead = new ListNode(-1);\\n        ListNode prev = tempHead;\\n        ListNode curr=head;\\n        while(curr!=null && curr.next!=null) {\\n            ListNode next=curr.next;\\n            curr.next=next.next;\\n            next.next=curr;\\n            prev.next=next;\\n            prev=curr;\\n            curr=curr.next;\\n        }\\n        return tempHead.next;\\n    }\\n```\n```\\npublic ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t\\tListNode second = head.next;\\n\\t\\tListNode third = second.next;\\n\\t\\tsecond.next=(head);\\n\\t\\thead.next=(swapPairs(third));\\n\\t\\treturn second;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1774677,
                "title": "c-code-using-a-vector",
                "content": "-> used a vector to store sum of every pair node. \\n-> the traverse through the vector and current node value is replaced by (v[i] - (curr->val)\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* curr = head;\\n        ListNode* temp = curr;\\n        vector<int> v;\\n        while(head && head->next )\\n        {\\n            v.push_back(head->val + head->next->val);\\n            head = head->next->next;\\n        }\\n        int k = v.size();\\n        int i = 0;\\n        while(i<k)\\n        {\\n            curr->val = v[i]-(curr->val);\\n            curr->next->val = v[i]-(curr->next->val);\\n            curr = curr->next->next;\\n            i++;\\n        }\\n        \\n        return temp;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* curr = head;\\n        ListNode* temp = curr;\\n        vector<int> v;\\n        while(head && head->next )\\n        {\\n            v.push_back(head->val + head->next->val);\\n            head = head->next->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1722643,
                "title": "four-recursive-and-iterative-solutions-in-python",
                "content": "## Approach 1. recursion with modification of node values\\n---\\n##### Time complexity: O(n)\\n##### Space complexity: O(n)\\n\\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head and head.next:\\n            head.val, head.next.val = head.next.val, head.val\\n\\n            self.swapPairs(head.next.next)\\n\\n        return head\\n```\\n## Approach 2. iteration with modification of node values\\n---\\n##### Time complexity: O(n)\\n##### Space complexity: O(1)\\n\\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n\\n        while curr and curr.next:\\n            curr.val, curr.next.val = curr.next.val, curr.val\\n\\n            curr = curr.next.next\\n\\n        return head\\n```\\n\\n## Approach 3. recursion without modification of node values\\n---\\n##### Time complexity: O(n)\\n##### Space complexity: O(n)\\n\\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        first, second = head, head.next\\n\\n        first.next = self.swapPairs(second.next)\\n        second.next = first\\n\\n        return second\\n```\\n\\n## Approach 4. iteration without modification of node values\\n---\\n##### Time complexity: O(n)\\n##### Space complexity: O(1)\\n\\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n\\n        prev = dummy\\n\\n        while head and head.next:\\n            first, second = head, head.next\\n\\n            prev.next = second\\n            first.next = second.next\\n            second.next = first\\n\\n            prev = first\\n            head = head.first\\n\\n        return dummy.next\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head and head.next:\\n            head.val, head.next.val = head.next.val, head.val\\n\\n            self.swapPairs(head.next.next)\\n\\n        return head\\n```\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n\\n        while curr and curr.next:\\n            curr.val, curr.next.val = curr.next.val, curr.val\\n\\n            curr = curr.next.next\\n\\n        return head\\n```\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        first, second = head, head.next\\n\\n        first.next = self.swapPairs(second.next)\\n        second.next = first\\n\\n        return second\\n```\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n\\n        prev = dummy\\n\\n        while head and head.next:\\n            first, second = head, head.next\\n\\n            prev.next = second\\n            first.next = second.next\\n            second.next = first\\n\\n            prev = first\\n            head = head.first\\n\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585587,
                "title": "python-recursion-with-example",
                "content": "```\\ndef swapPairs(self, head):\\n        if not head or not head.next:\\n            return head\\n        \\n        first = head\\n        second = head.next\\n        \\n        first.next = self.swapPairs(second.next)\\n        second.next = first\\n        \\n        return second\\n```\\n\\nThe recursive function is called on the 1st node of each pair. The recursive flow will be as follows:\\n\\nConsider the example : 1 --> 2 --> 3 --> 4 --> 5\\n\\n```\\nswap(1) --> first = 1\\n\\t\\t\\tsecond = 2\\n\\t\\t\\t1.next = swap(3) --> first = 3\\n\\t\\t\\t2.next = 1           second = 4\\n\\t\\t\\treturn 2\\t\\t\\t 3.next = swap(5) -- > return 5\\n\\t\\t\\t\\t\\t\\t\\t\\t 4.next = 3\\n\\t\\t\\t\\t\\t\\t\\t\\t return 4\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\ndef swapPairs(self, head):\\n        if not head or not head.next:\\n            return head\\n        \\n        first = head\\n        second = head.next\\n        \\n        first.next = self.swapPairs(second.next)\\n        second.next = first\\n        \\n        return second\\n```\n```\\nswap(1) --> first = 1\\n\\t\\t\\tsecond = 2\\n\\t\\t\\t1.next = swap(3) --> first = 3\\n\\t\\t\\t2.next = 1           second = 4\\n\\t\\t\\treturn 2\\t\\t\\t 3.next = swap(5) -- > return 5\\n\\t\\t\\t\\t\\t\\t\\t\\t 4.next = 3\\n\\t\\t\\t\\t\\t\\t\\t\\t return 4\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1489575,
                "title": "easy-c-solution",
                "content": "```\\nListNode* swapPairs(ListNode* head) {\\n        if(head==NULL) return head;\\n        int sum=0;\\n        ListNode* start=head,*temp=head;\\n        start=head;\\n        while(start){\\n            sum++;\\n            start=start->next;\\n        }\\n        if(sum==1) return head;\\n        else if(sum%2==0){\\n            start=head;\\n            while(start){\\n                int x=start->val;\\n                start->val=start->next->val;\\n                start->next->val=x;\\n                start=start->next->next;\\n            }\\n            return head;\\n        }else if(sum%2==1){\\n            start=head;\\n            while(start->next){\\n                int x=start->val;\\n                start->val=start->next->val;\\n                start->next->val=x;\\n                start=start->next->next;\\n            }\\n            return head;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* swapPairs(ListNode* head) {\\n        if(head==NULL) return head;\\n        int sum=0;\\n        ListNode* start=head,*temp=head;\\n        start=head;\\n        while(start){\\n            sum++;\\n            start=start->next;\\n        }\\n        if(sum==1) return head;\\n        else if(sum%2==0){\\n            start=head;\\n            while(start){\\n                int x=start->val;\\n                start->val=start->next->val;\\n                start->next->val=x;\\n                start=start->next->next;\\n            }\\n            return head;\\n        }else if(sum%2==1){\\n            start=head;\\n            while(start->next){\\n                int x=start->val;\\n                start->val=start->next->val;\\n                start->next->val=x;\\n                start=start->next->next;\\n            }\\n            return head;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1453499,
                "title": "java-beats-100-simple-solution",
                "content": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null){\\n            return head;\\n        }\\n        \\n        ListNode dummyHead = new ListNode(-1);\\n        ListNode prev = dummyHead;\\n        ListNode curr = head;\\n        \\n        while(curr != null && curr.next != null){\\n            prev.next = curr.next;\\n            curr.next = curr.next.next;\\n            prev.next.next = curr;\\n            curr = curr.next;\\n            prev = prev.next.next;\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null){\\n            return head;\\n        }\\n        \\n        ListNode dummyHead = new ListNode(-1);\\n        ListNode prev = dummyHead;\\n        ListNode curr = head;\\n        \\n        while(curr != null && curr.next != null){\\n            prev.next = curr.next;\\n            curr.next = curr.next.next;\\n            prev.next.next = curr;\\n            curr = curr.next;\\n            prev = prev.next.next;\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318487,
                "title": "python-easy-solution-with-comments-and-explanation",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        \\n        \\n        # dummy -> A -> B -> C \\n        \\n        # we want to swap A and B so we have to make dummy to point towards B and B towards A and A towards C \\n        \\n        \\n        # dummy >>>>> B\\n        # B >>>>> A\\n        # A >>>>> C \\n        # all steps simultaneously\\n        \\n        \\n        dummy = ListNode(0)\\n        \\n        dummy.next = head\\n        \\n        start = dummy\\n        \\n        \\n        while dummy.next and dummy.next.next:\\n            \\n            temp1 = dummy.next # A\\n            temp2 = temp1.next # B\\n            \\n            dummy.next ,temp2.next , temp1.next = temp2 , temp1, temp2.next\\n            \\n            dummy = temp1\\n            \\n        return start.next\\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        \\n        \\n        # dummy -> A -> B -> C \\n        \\n        # we want to swap A and B so we have to make dummy to point towards B and B towards A and A towards C \\n        \\n        \\n        # dummy >>>>> B\\n        # B >>>>> A\\n        # A >>>>> C \\n        # all steps simultaneously\\n        \\n        \\n        dummy = ListNode(0)\\n        \\n        dummy.next = head\\n        \\n        start = dummy\\n        \\n        \\n        while dummy.next and dummy.next.next:\\n            \\n            temp1 = dummy.next # A\\n            temp2 = temp1.next # B\\n            \\n            dummy.next ,temp2.next , temp1.next = temp2 , temp1, temp2.next\\n            \\n            dummy = temp1\\n            \\n        return start.next\\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269068,
                "title": "python-solution-using-recursion",
                "content": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        \\n        if head is None or head.next is None:\\n            return head\\n        else:\\n            # Swap the 2 nodes\\n            temp = head \\n            head = head.next\\n            temp.next = head.next\\n            head.next = temp\\n            \\n            # call function recursively for next nodes\\n            temp.next = self.swapPairs(temp.next)\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        \\n        if head is None or head.next is None:\\n            return head\\n        else:\\n            # Swap the 2 nodes\\n            temp = head \\n            head = head.next\\n            temp.next = head.next\\n            head.next = temp\\n            \\n            # call function recursively for next nodes\\n            temp.next = self.swapPairs(temp.next)\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984754,
                "title": "easy-understandable-python-solution",
                "content": "```\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        head2 = head\\n        while head and head.next:\\n            head.val, head.next.val = head.next.val, head.val\\n            head = head.next.next\\n            \\n        return head2\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        head2 = head\\n        while head and head.next:\\n            head.val, head.next.val = head.next.val, head.val\\n            head = head.next.next\\n            \\n        return head2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 984473,
                "title": "python-o-n-easy-clear-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef swapPairs(self, head: ListNode) -> ListNode:\\n\\t\\t\\tif not head or not head.next:\\n\\t\\t\\t\\treturn head\\n\\t\\t\\t\\n\\t\\t\\ttmp = head\\n\\t\\t\\thead = head.next\\n\\t\\t\\ttmp.next = head.next\\n\\t\\t\\thead.next = tmp\\n\\t\\t\\t\\n\\t\\t\\ttmp.next = self.swapPairs(tmp.next)\\n\\t\\t\\t\\n\\t\\t\\treturn head",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef swapPairs(self, head: ListNode) -> ListNode:\\n\\t\\t\\tif not head or not head.next:\\n\\t\\t\\t\\treturn head\\n\\t\\t\\t\\n\\t\\t\\ttmp = head\\n\\t\\t\\thead = head.next\\n\\t\\t\\ttmp.next = head.next\\n\\t\\t\\thead.next = tmp\\n\\t\\t\\t\\n\\t\\t\\ttmp.next = self.swapPairs(tmp.next)\\n\\t\\t\\t\\n\\t\\t\\treturn head",
                "codeTag": "Java"
            },
            {
                "id": 984443,
                "title": "swap-nodes-in-pair-c-faster-than-100-00-solutions-o-n-time-o-1-space-0ms-runtime",
                "content": "Time: O(n)\\nSpace: O(1)\\nThis is a very easy-to-follow solution. It beats 100% of the submitted C++ solutions according to my submission on Leetcode:\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        // If NULL, then return\\n        if(head == NULL)\\n            return head;\\n        \\n        // An iterator node for traversing the LinkedList\\n        ListNode* it = head;\\n        \\n        // A previous pointer to store the second node of the previous pair \\n        ListNode* prev = NULL;\\n        \\n        while(it != NULL && it->next != NULL)\\n        {\\n            // Front and back pointers for the two nodes of the pair to be swapped\\n            ListNode* back = it;\\n            ListNode* front = back->next;\\n            \\n            // Pointing Back node to the node next to Front \\n            back->next = front->next;\\n            \\n            // If it\\'s the start of the Linked List\\n            if(prev == NULL)\\n            {\\n                front->next = back;\\n                // point the head to Front since Front is not swapped back\\n                head = front;\\n            }\\n            else\\n            {\\n                // If it\\'s not the start of the linkedlist,\\n                // point the Prev pointer to the Front\\n                // And, Front pointer to the Back.\\n                prev->next = front;\\n                front->next = back;\\n            }\\n            \\n            // Update the Prev pointer\\n            prev = back;\\n            \\n            // Shift it to Front and two nodes ahead\\n            it = front;\\n            it = it->next->next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```\\n\\nAny question let me know. If you like the post please upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        // If NULL, then return\\n        if(head == NULL)\\n            return head;\\n        \\n        // An iterator node for traversing the LinkedList\\n        ListNode* it = head;\\n        \\n        // A previous pointer to store the second node of the previous pair \\n        ListNode* prev = NULL;\\n        \\n        while(it != NULL && it->next != NULL)\\n        {\\n            // Front and back pointers for the two nodes of the pair to be swapped\\n            ListNode* back = it;\\n            ListNode* front = back->next;\\n            \\n            // Pointing Back node to the node next to Front \\n            back->next = front->next;\\n            \\n            // If it\\'s the start of the Linked List\\n            if(prev == NULL)\\n            {\\n                front->next = back;\\n                // point the head to Front since Front is not swapped back\\n                head = front;\\n            }\\n            else\\n            {\\n                // If it\\'s not the start of the linkedlist,\\n                // point the Prev pointer to the Front\\n                // And, Front pointer to the Back.\\n                prev->next = front;\\n                front->next = back;\\n            }\\n            \\n            // Update the Prev pointer\\n            prev = back;\\n            \\n            // Shift it to Front and two nodes ahead\\n            it = front;\\n            it = it->next->next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877607,
                "title": "rust-straightforward-non-recursive-i-e-o-1-space",
                "content": "```rust\\nimpl Solution {\\n    pub fn swap_pairs(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        let mut curr: &mut Option<Box<ListNode>> = &mut head;\\n        // Man, if-let chains or box patterns would be so nice...\\n        while curr.is_some() && curr.as_ref().unwrap().next.is_some() {\\n            let mut node1 = curr.take().unwrap();\\n            let mut node2 = node1.next.take().unwrap();\\n            let rest = node2.next.take();\\n            node1.next = rest;\\n            node2.next = Some(node1);\\n            *curr = Some(node2);\\n            curr = &mut curr.as_mut().unwrap().next.as_mut().unwrap().next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn swap_pairs(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        let mut curr: &mut Option<Box<ListNode>> = &mut head;\\n        // Man, if-let chains or box patterns would be so nice...\\n        while curr.is_some() && curr.as_ref().unwrap().next.is_some() {\\n            let mut node1 = curr.take().unwrap();\\n            let mut node2 = node1.next.take().unwrap();\\n            let rest = node2.next.take();\\n            node1.next = rest;\\n            node2.next = Some(node1);\\n            *curr = Some(node2);\\n            curr = &mut curr.as_mut().unwrap().next.as_mut().unwrap().next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 820212,
                "title": "c-monster-oneliner-solution-vs-iterative-approach-explained-100-time-90-space",
                "content": "This is a rather simple to understand and not necessarily trivial to solve problem, so I decided to give myself a good extra challenge and to solve it first of all with a recursive approach.\\n\\nAnd doing it in one line.\\n\\nMy original code, the blasphemous oneliner:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode *head, ListNode *originalHead = NULL, ListNode *tmp = NULL) {\\n        return (originalHead = originalHead ? originalHead : head && head->next ? head->next : head, head) && head->next ? swapPairs(head->next->next, originalHead, (tmp = head->next, head->next = head->next->next && head->next->next->next ? head->next->next->next : head->next->next, tmp->next = head)) : originalHead;\\n    }\\n};\\n```\\n\\nNow, for the sake of exercise and possibly for the joy of some of my most affectionate readers, I converted it into an iterative approach.\\n\\nFirst of all we move the variable declaration where they belong (in the recursive approach, I used the trick of setting them as additional parameters).\\n\\nAnd we get the first tricky part: `originalHead` needs to be `head->next` (because we are going to swap the first 2 elements too), provided it exists, otherwise it is going to be just `head` (if it is a valid node or `NULL`), so we initialise it to `head && head->next ? head->next : head`; `tmp` does not need to be initialised. And anyway nobody ever loved `tmp` and its parent were not even proud of `tmp`, so `tmp` does not deserve any initial value! In this version we will also need another pointer that I could avoid using previously, `nextHead`.\\n\\nBut enough with pointers\\' drama: we move on and convert the bulk of the rest of the logic to fit into a `while` loop with a `head && head->next` condition, again matching the logic of our oversized oneliner.\\n\\nInside our loop we can first of all store the value of the element after the current `head` in `tmp` and the value of the next `head` into `nextHead`.\\n\\nThen we have to update `head->next`: it has to be an element 3 steps to the right, if such an element exist, otherwise it is going to be an element 2 steps to the right (as it is the case for when we encounter the last element in an odd-lengthed list).\\n\\nTime to switch, so we set `tmp->next = head` and, since we are done with the logic for this run, all that we are missing is just to set it for the next iteration, with `head = nextHead`.\\n\\nOnce we are done looping, we can just return `originalHead`.\\n\\nThe refactored (and significantly more readable) code, which curiously seems to run a bit slower:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode *head) {\\n        ListNode *originalHead = head && head->next ? head->next : head, *tmp, *nextHead;\\n        while (head && head->next) {\\n            // storing the current value of the node following head\\n            tmp = head->next;\\n            // storing the head of the next loop\\n            nextHead = head->next->next;\\n            // updating head->next\\n            head->next = head->next->next && head->next->next->next ? head->next->next->next : head->next->next;\\n            // switching head and its previous next position\\n            tmp->next = head;\\n            // setting the head of the next loop\\n            head = nextHead;\\n        }\\n        return originalHead;\\n    }\\n};\\n```\\n\\nAnd that was me months ago; I forgot about having solved the problem already, so I came up with another solution using one less variable.\\n\\nIn it I just declare `nextHead`, initialised to be `head->next`, provided both it and `head` exist, then I assign `head->next` the result of a recursive call, swap `head` and `nextHead` and return the latter.\\n\\nThe updated code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // base case: we are at the end of the line\\n        if (!head || !head->next) return head; \\n        // support variable\\n        ListNode *nextHead = head->next;\\n        // swapping positions\\n        head->next = swapPairs(nextHead->next);\\n        nextHead->next = head;\\n        return nextHead;\\n    }\\n};\\n```\\n\\nEven turning it into one liner is much more concise \\uD83D\\uDE09 :\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head, ListNode *nextHead = NULL) {\\n        return head && head->next ? nextHead = head->next, head->next = swapPairs(nextHead->next), nextHead->next = head, nextHead : head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode *head, ListNode *originalHead = NULL, ListNode *tmp = NULL) {\\n        return (originalHead = originalHead ? originalHead : head && head->next ? head->next : head, head) && head->next ? swapPairs(head->next->next, originalHead, (tmp = head->next, head->next = head->next->next && head->next->next->next ? head->next->next->next : head->next->next, tmp->next = head)) : originalHead;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode *head) {\\n        ListNode *originalHead = head && head->next ? head->next : head, *tmp, *nextHead;\\n        while (head && head->next) {\\n            // storing the current value of the node following head\\n            tmp = head->next;\\n            // storing the head of the next loop\\n            nextHead = head->next->next;\\n            // updating head->next\\n            head->next = head->next->next && head->next->next->next ? head->next->next->next : head->next->next;\\n            // switching head and its previous next position\\n            tmp->next = head;\\n            // setting the head of the next loop\\n            head = nextHead;\\n        }\\n        return originalHead;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // base case: we are at the end of the line\\n        if (!head || !head->next) return head; \\n        // support variable\\n        ListNode *nextHead = head->next;\\n        // swapping positions\\n        head->next = swapPairs(nextHead->next);\\n        nextHead->next = head;\\n        return nextHead;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head, ListNode *nextHead = NULL) {\\n        return head && head->next ? nextHead = head->next, head->next = swapPairs(nextHead->next), nextHead->next = head, nextHead : head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793729,
                "title": "3-lines-in-python-recursion",
                "content": "```python\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if not head or not head.next: return head\\n        head.next.next, head.next, head = head, self.swapPairs(head.next.next), head.next\\n        return head\\n```\\n\\nAnd, non-recursion in 5 lines:\\n```python\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        prev, cur = dummy, dummy.next = ListNode(0), head\\n        while cur and cur.next:\\n            cur.next.next, cur.next, prev.next = prev.next, cur.next.next, cur.next\\n            prev, cur = cur, cur.next\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if not head or not head.next: return head\\n        head.next.next, head.next, head = head, self.swapPairs(head.next.next), head.next\\n        return head\\n```\n```python\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        prev, cur = dummy, dummy.next = ListNode(0), head\\n        while cur and cur.next:\\n            cur.next.next, cur.next, prev.next = prev.next, cur.next.next, cur.next\\n            prev, cur = cur, cur.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393307,
                "title": "very-short-line-of-kotlin-code",
                "content": "Hope if you guys love it\\n\\n```\\nfun swapPairs(head: ListNode?): ListNode? {\\n    if(head?.next == null) return head\\n    val remaining = swapPairs(head.next?.next)\\n    val newHead = head.next!!\\n    newHead.next = head\\n    newHead.next!!.next = remaining\\n    return newHead\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfun swapPairs(head: ListNode?): ListNode? {\\n    if(head?.next == null) return head\\n    val remaining = swapPairs(head.next?.next)\\n    val newHead = head.next!!\\n    newHead.next = head\\n    newHead.next!!.next = remaining\\n    return newHead\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 303149,
                "title": "c-recursive-solution-short-simple-with-comments",
                "content": "```\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head != NULL && head->next != NULL)\\n        {\\n            ListNode *temp = head->next;                // temp = 2\\n            head->next = swapPairs(head->next->next);   // 1->3\\n            temp->next = head;                          // 2->1 \\n            head = temp;                                // head = 2\\n        }\\n        return head; // if head is NULL, head->next is NULL, or we\\'re done swapping\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head != NULL && head->next != NULL)\\n        {\\n            ListNode *temp = head->next;                // temp = 2\\n            head->next = swapPairs(head->next->next);   // 1->3\\n            temp->next = head;                          // 2->1 \\n            head = temp;                                // head = 2\\n        }\\n        return head; // if head is NULL, head->next is NULL, or we\\'re done swapping\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1574728,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1895922,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1566737,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1783820,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1836468,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1827949,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1566051,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1895437,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1671797,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1571062,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1574728,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1895922,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1566737,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1783820,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1836468,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1827949,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1566051,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1895437,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1671797,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1571062,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1895928,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1576659,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1896284,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1573008,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 2057965,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 2034957,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 2013646,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1997607,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1988499,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1985704,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1984894,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1972364,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1972265,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1968740,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1958756,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1896214,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1895915,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1895810,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1895807,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1895616,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1895609,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895543,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895531,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895521,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895482,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895451,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895446,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895389,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1883859,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1817742,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1808252,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1804363,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1803290,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1799258,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1786274,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1785572,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1764185,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1763737,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1760984,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1760448,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Binary Tree Maximum Path Sum",
        "question_content": "<p>A <strong>path</strong> in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence <strong>at most once</strong>. Note that the path does not need to pass through the root.</p>\n\n<p>The <strong>path sum</strong> of a path is the sum of the node&#39;s values in the path.</p>\n\n<p>Given the <code>root</code> of a binary tree, return <em>the maximum <strong>path sum</strong> of any <strong>non-empty</strong> path</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg\" style=\"width: 322px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The optimal path is 2 -&gt; 1 -&gt; 3 with a path sum of 2 + 1 + 3 = 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg\" />\n<pre>\n<strong>Input:</strong> root = [-10,9,20,null,null,15,7]\n<strong>Output:</strong> 42\n<strong>Explanation:</strong> The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 = 42.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 3 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 603423,
                "title": "python-recursion-stack-thinking-process-diagram",
                "content": "This problem requires quite a bit of quirky thinking steps. Take it slow until you fully grasp it.\\n\\n# **Basics**\\n![image](https://assets.leetcode.com/users/arkaung/image_1588177330.png)\\n\\n\\n# **Base cases**\\n![image](https://assets.leetcode.com/users/arkaung/image_1588177335.png)\\n\\n\\n# **Important Observations**\\n* These important observations are very important to understand `Line 9` and `Line 10` in the code.\\n\\t* For example, in the code (`Line 9`), we do something like `max(get_max_gain(node.left), 0)`. The important part is: why do we take maximum value between 0 and maximum gain we can get from left branch? Why 0?\\n\\t* Check the two images below first.\\n![image](https://assets.leetcode.com/users/arkaung/image_1588177343.png)\\n![image](https://assets.leetcode.com/users/arkaung/image_1588177349.png)\\n\\n* The important thing is \"We can only get any sort of gain IF our branches are not below zero. If they are below zero, why do we even bother considering them? Just pick 0 in that case. Therefore, we do `max(<some gain we might get or not>, 0)`.\\n\\n# **Going down the recursion stack for one example**\\n![image](https://assets.leetcode.com/users/arkaung/image_1588177356.png)\\n![image](https://assets.leetcode.com/users/arkaung/image_1588177362.png)\\n![image](https://assets.leetcode.com/users/arkaung/image_1588177368.png)\\n\\n* Because of this, we do `Line 12` and `Line 13`. It is important to understand the different between looking for the maximum path INVOLVING the current node in process and what we return for the node which starts the recursion stack. `Line 12` and `Line 13` takes care of the former issue and `Line 15` (and the image below) takes care of the latter issue.\\n\\n![image](https://assets.leetcode.com/users/arkaung/image_1588177373.png)\\n\\n* Because of this fact, we have to return like `Line 15`. For our example, for node 1, which is the recursion call that node 3 does for `max(get_max_gain(node.left), 0)`, node 1 cannot include both node 6 and node 7 for a path to include node 3. Therefore, we can only pick the max gain from left path or right path of node 1.\\n\\n\\n**Python**\\n``` python\\n1. class Solution:\\n2.     def maxPathSum(self, root: TreeNode) -> int:\\n3. \\t\\tmax_path = float(\"-inf\") # placeholder to be updated\\n4. \\t\\tdef get_max_gain(node):\\n5. \\t\\t\\tnonlocal max_path # This tells that max_path is not a local variable\\n6. \\t\\t\\tif node is None:\\n7. \\t\\t\\t\\treturn 0\\n8. \\t\\t\\t\\t\\n9. \\t\\t\\tgain_on_left = max(get_max_gain(node.left), 0) # Read the part important observations\\n10. \\t\\tgain_on_right = max(get_max_gain(node.right), 0)  # Read the part important observations\\n11. \\t\\t\\t\\n12. \\t\\tcurrent_max_path = node.val + gain_on_left + gain_on_right # Read first three images of going down the recursion stack\\n13. \\t\\tmax_path = max(max_path, current_max_path) # Read first three images of going down the recursion stack\\n14. \\t\\t\\t\\n15. \\t\\treturn node.val + max(gain_on_left, gain_on_right) # Read the last image of going down the recursion stack\\n16. \\t\\t\\t\\n17. \\t\\t\\t\\n18. \\tget_max_gain(root) # Starts the recursion chain\\n19. \\treturn max_path\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "``` python\\n1. class Solution:\\n2.     def maxPathSum(self, root: TreeNode) -> int:\\n3. \\t\\tmax_path = float(\"-inf\") # placeholder to be updated\\n4. \\t\\tdef get_max_gain(node):\\n5. \\t\\t\\tnonlocal max_path # This tells that max_path is not a local variable\\n6. \\t\\t\\tif node is None:\\n7. \\t\\t\\t\\treturn 0\\n8. \\t\\t\\t\\t\\n9. \\t\\t\\tgain_on_left = max(get_max_gain(node.left), 0) # Read the part important observations\\n10. \\t\\tgain_on_right = max(get_max_gain(node.right), 0)  # Read the part important observations\\n11. \\t\\t\\t\\n12. \\t\\tcurrent_max_path = node.val + gain_on_left + gain_on_right # Read first three images of going down the recursion stack\\n13. \\t\\tmax_path = max(max_path, current_max_path) # Read first three images of going down the recursion stack\\n14. \\t\\t\\t\\n15. \\t\\treturn node.val + max(gain_on_left, gain_on_right) # Read the last image of going down the recursion stack\\n16. \\t\\t\\t\\n17. \\t\\t\\t\\n18. \\tget_max_gain(root) # Starts the recursion chain\\n19. \\treturn max_path\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39775,
                "title": "accepted-short-solution-in-java",
                "content": "Here's my ideas:\\n\\n - A path from start to end, goes up on the tree for 0 or more steps, then goes down for 0 or more steps. Once it goes down, it can't go up. Each path has a highest node, which is also the lowest common ancestor of all other nodes on the path.\\n - A recursive method `maxPathDown(TreeNode node)` (1) computes the maximum path sum with highest node is the input node, update maximum if necessary (2) returns the maximum sum of the path that can be extended to input node's parent.\\n\\nCode:\\n\\n    public class Solution {\\n        int maxValue;\\n        \\n        public int maxPathSum(TreeNode root) {\\n            maxValue = Integer.MIN_VALUE;\\n            maxPathDown(root);\\n            return maxValue;\\n        }\\n        \\n        private int maxPathDown(TreeNode node) {\\n            if (node == null) return 0;\\n            int left = Math.max(0, maxPathDown(node.left));\\n            int right = Math.max(0, maxPathDown(node.right));\\n            maxValue = Math.max(maxValue, left + right + node.val);\\n            return Math.max(left, right) + node.val;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        int maxValue;\\n        \\n        public int maxPathSum(TreeNode root) {\\n            maxValue = Integer.MIN_VALUE;\\n            maxPathDown(root);\\n            return maxValue;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 389609,
                "title": "full-explanation-article-with-pseudo-code-beats-java-100-time-and-100-space-solution",
                "content": "A lot of the discussions here left me wondering with the magic that was happening between the lines and did not clearly explain the concept of the solution.\\nHere is a step by step solution of what would probably be easier to understand.\\n\\nOur goal is to find the maximum path sum. Now consider the following example.\\n\\n       10\\n\\t  /  \\\\\\n\\tnull null\\n\\t\\n\\t\\nIn this simple case we know that the max sum would be just the root node itself and the answer would be 10. So fo all `leaf`  nodes the max sum path is the value of the node itself.\\n\\nNow let\\'s consider the following example.\\n\\n ```\\n    20\\n   /  \\\\\\n 10    30\\n```\\n\\nHere there are multiple possibilities and we need to take care of the following **FOUR PATHS** that could be our max.\\n1.  The root iself : `20 `\\n2.  The root with the maximum from it\\'s left subTree : \\n\\t```\\n\\t\\t20\\n\\t\\t/\\n\\t  10\\n```\\t\\n3. The root with the maximum from it\\'s right subTree : \\n\\t\\n\\t\\t20\\n\\t\\t  \\\\\\n\\t       30\\n```\\t\\n4. The root with it\\'s left, right and itself\\n ```\\n\\t\\t 20\\n\\t\\t / \\\\\\n\\t 10  30\\n```\\n\\nIn case you are wondering  why we did not choose the root.left (10) or root.right(30) alone in the calculation ( like I wondered ), that\\'s because we would have already computed the result of it as a node in our recursion separately.\\n\\nThis actually breaks down our code to a very simple pseudo code:\\n\\n```\\nif( root == null) return 0;\\nleft = recurse(leftChild);\\nright = recurse(rightChild);\\n\\n// now find the max of all the four paths\\nleftPath = root.value + left;\\nrightPath = root.value + right;\\ncompletePath = root.value + right + left;\\n\\nresult = max( root.value, leftPath, rightPath, completePath );\\n\\nreturn max(root.value, leftPath, rightPath);\\n```\\n\\n*What\\'s  interesting to note here is the last line of the code* :\\n\\n```\\nreturn max(root.value, leftPath, rightPath);\\n```\\n\\n**Wondering why  did we do that ?**\\n\\nWell,  we know that we did all the calculations possible if the tree only consists of the current node as root in any possible recursion cycle. And the result of that cycle would have been stored in the `result` variable.\\nBut, what if the current node is just a child of it\\'s parent. Then it needs to return a value, such that the root had to be part of the answer. \\nSo if the root has to be part of the answer, it should return what\\'s the maximum value it can return if it\\'s part of it.\\nThat would be either of the three cases here :\\n1.  The root iself : `20 `\\n2.  The root with the maximum from it\\'s left subTree : \\n\\t```\\n\\t\\t20\\n\\t\\t/\\n\\t  10\\n```\\t\\n3. The root with the maximum from it\\'s right subTree : \\n\\t\\n\\t\\t20\\n\\t\\t  \\\\\\n\\t       30\\n```\\t\\nThis concludes us to the following code :\\n\\n```\\npublic class BinaryTreeMaximumPathSum {\\n    private int maxSum;\\n\\n    public int maxSumHelper(TreeNode root) {\\n\\t\\t\\n\\t\\t// base case\\n        if (root == null) return 0; \\n\\t\\t\\n\\t\\t// recursing through left and right subtree\\n        int leftMax = maxSumHelper(root.left);\\n        int rightMax = maxSumHelper(root.right);\\n\\n\\t\\t// finding all the four paths and the maximum between all of them\\n        int maxRightLeft = Math.max(leftMax, rightMax);\\n        int maxOneNodeRoot = Math.max(root.val, (root.val + maxRightLeft));\\n        int maxAll = Math.max(maxOneNodeRoot, leftMax + rightMax + root.val);\\n\\t\\t\\n\\t\\t// Storing the result in the maxSum holder\\n        maxSum = Math.max(maxSum, maxAll);\\n\\t\\t\\n\\t\\t// returning the value if root was part of the answer\\n        return maxOneNodeRoot;\\n\\n    }\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        maxSumHelper(root);\\n        return maxSum; // as maxSum will always store the result\\n\\n    }\\n}\\n\\n```\\nHope this post helps you clear your doubts !\\n",
                "solutionTags": [],
                "code": "```\\n    20\\n   /  \\\\\\n 10    30\\n```\n```\\n\\t\\t20\\n\\t\\t/\\n\\t  10\\n```\n```\\t\\n4. The root with it\\'s left, right and itself\\n ```\n```\\n\\nIn case you are wondering  why we did not choose the root.left (10) or root.right(30) alone in the calculation ( like I wondered ), that\\'s because we would have already computed the result of it as a node in our recursion separately.\\n\\nThis actually breaks down our code to a very simple pseudo code:\\n\\n```\n```\\n\\n*What\\'s  interesting to note here is the last line of the code* :\\n\\n```\n```\\n\\n**Wondering why  did we do that ?**\\n\\nWell,  we know that we did all the calculations possible if the tree only consists of the current node as root in any possible recursion cycle. And the result of that cycle would have been stored in the `result` variable.\\nBut, what if the current node is just a child of it\\'s parent. Then it needs to return a value, such that the root had to be part of the answer. \\nSo if the root has to be part of the answer, it should return what\\'s the maximum value it can return if it\\'s part of it.\\nThat would be either of the three cases here :\\n1.  The root iself : `20 `\\n2.  The root with the maximum from it\\'s left subTree : \\n\\t```\n```\\t\\n3. The root with the maximum from it\\'s right subTree : \\n\\t\\n\\t\\t20\\n\\t\\t  \\\\\\n\\t       30\\n```\n```\\npublic class BinaryTreeMaximumPathSum {\\n    private int maxSum;\\n\\n    public int maxSumHelper(TreeNode root) {\\n\\t\\t\\n\\t\\t// base case\\n        if (root == null) return 0; \\n\\t\\t\\n\\t\\t// recursing through left and right subtree\\n        int leftMax = maxSumHelper(root.left);\\n        int rightMax = maxSumHelper(root.right);\\n\\n\\t\\t// finding all the four paths and the maximum between all of them\\n        int maxRightLeft = Math.max(leftMax, rightMax);\\n        int maxOneNodeRoot = Math.max(root.val, (root.val + maxRightLeft));\\n        int maxAll = Math.max(maxOneNodeRoot, leftMax + rightMax + root.val);\\n\\t\\t\\n\\t\\t// Storing the result in the maxSum holder\\n        maxSum = Math.max(maxSum, maxAll);\\n\\t\\t\\n\\t\\t// returning the value if root was part of the answer\\n        return maxOneNodeRoot;\\n\\n    }\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        maxSumHelper(root);\\n        return maxSum; // as maxSum will always store the result\\n\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 603072,
                "title": "c-solution-o-n-with-detailed-explanation",
                "content": "```\\nThe way to think of a solution to this is that when we are looking a path in a tree its unidirectional and cannot retrace back what i mean by that is:\\n    _\\n  / 1 \\\\ \\n / / \\\\ \\\\ <-----path that goes like a depth first search without backtracking\\n/ 2   3 v  \\n\\nSo a way to solve this is that if i am at a node i can choose a left or right subtree but if i choose both this is the only subtree that will contain my maximum\\n\\nI first set my max_sum to INT_MIN.\\nI can do either either of the options presented:\\n1.I can choose to take up the left subtree or drop it.\\n2.I can either choose to take up the right subtree or drop it.\\n3.I check for a possibility whether if i were to take both left subtree and right subtree would that beat my current max_sum?\\nLets consider\\n   -10\\n   / \\\\\\n  9  20\\n    /  \\\\\\n   15   7\\nI do my postorder traversal with a bit of variation:-\\n\\nint l=max(max_gain(root->left),0);\\nint r=max(max_gain(root->right),0);\\nBut why?\\nThis is because I have the option to choose the left or right subtree or whether i will just settle with my root value.\\n\\nSo I do my regular postorder traversal and do the above steps\\nI hit 9\\n\\n    9\\n   / \\\\\\nNULL  NULL\\n\\nint l=0,r=0(Base condition)\\ni store the value of 9+0+0 in a variable\\nThen check if this is greater than maxsum or not is so i update it.\\nAs my max_sum was INT_MIN it gets updated to 9\\n\\nNow we explore the right tree of root which reaches 15\\n\\n    15\\n   / \\\\\\nNULL  NULL\\n\\nint l=0,r=0(Base condition)\\ni store the value of 9+0+0 in a variable\\nThen check if this is greater than maxsum or not is so i update it.\\nAs my max_sum was 9 it gets updated to 15\\n\\nSimilarly with 7 but 7 doesnt beat the max_sum so nothing happens.\\n\\nNow we backtrack 20\\nhere int r=7(as 7>0)\\n     int l=15(as 15>0)\\n now i check whether 20+15+7(considering this subtree to be my maximum)\\n as 42>15 max_sum=42\\n Now what if we dont consider this subtree?\\n\\n Then we choose 20 and maximum of its left or right subtree\\n so we send return root->val+max(l,r) to our recursion stack\\n so when i reach the root it would be like this\\n           -10\\n           /  \\\\    <----I considered 15 and 20 because its along a path and is greater than 20+7\\n          9    35\\n  int l=9\\n      r=35\\n      check whether 9+35+-10=34 beats max_sum\\n      34<42 so nothing happens and we return -10+max(9,35)=25 to the caller after which we break out of the helper function and we get max_sum as 42.\\n\\n    int max_sum=INT_MIN;\\n    int max_gain(TreeNode* root)\\n    {\\n        if(!root)return 0;\\n        int l=max(max_gain(root->left),0);\\n        int r=max(max_gain(root->right),0);\\n        int new_price=root->val+l+r;\\n        max_sum=max(max_sum,new_price);\\n        return root->val+max(l,r);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        max_gain(root);\\n        return max_sum;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nThe way to think of a solution to this is that when we are looking a path in a tree its unidirectional and cannot retrace back what i mean by that is:\\n    _\\n  / 1 \\\\ \\n / / \\\\ \\\\ <-----path that goes like a depth first search without backtracking\\n/ 2   3 v  \\n\\nSo a way to solve this is that if i am at a node i can choose a left or right subtree but if i choose both this is the only subtree that will contain my maximum\\n\\nI first set my max_sum to INT_MIN.\\nI can do either either of the options presented:\\n1.I can choose to take up the left subtree or drop it.\\n2.I can either choose to take up the right subtree or drop it.\\n3.I check for a possibility whether if i were to take both left subtree and right subtree would that beat my current max_sum?\\nLets consider\\n   -10\\n   / \\\\\\n  9  20\\n    /  \\\\\\n   15   7\\nI do my postorder traversal with a bit of variation:-\\n\\nint l=max(max_gain(root->left),0);\\nint r=max(max_gain(root->right),0);\\nBut why?\\nThis is because I have the option to choose the left or right subtree or whether i will just settle with my root value.\\n\\nSo I do my regular postorder traversal and do the above steps\\nI hit 9\\n\\n    9\\n   / \\\\\\nNULL  NULL\\n\\nint l=0,r=0(Base condition)\\ni store the value of 9+0+0 in a variable\\nThen check if this is greater than maxsum or not is so i update it.\\nAs my max_sum was INT_MIN it gets updated to 9\\n\\nNow we explore the right tree of root which reaches 15\\n\\n    15\\n   / \\\\\\nNULL  NULL\\n\\nint l=0,r=0(Base condition)\\ni store the value of 9+0+0 in a variable\\nThen check if this is greater than maxsum or not is so i update it.\\nAs my max_sum was 9 it gets updated to 15\\n\\nSimilarly with 7 but 7 doesnt beat the max_sum so nothing happens.\\n\\nNow we backtrack 20\\nhere int r=7(as 7>0)\\n     int l=15(as 15>0)\\n now i check whether 20+15+7(considering this subtree to be my maximum)\\n as 42>15 max_sum=42\\n Now what if we dont consider this subtree?\\n\\n Then we choose 20 and maximum of its left or right subtree\\n so we send return root->val+max(l,r) to our recursion stack\\n so when i reach the root it would be like this\\n           -10\\n           /  \\\\    <----I considered 15 and 20 because its along a path and is greater than 20+7\\n          9    35\\n  int l=9\\n      r=35\\n      check whether 9+35+-10=34 beats max_sum\\n      34<42 so nothing happens and we return -10+max(9,35)=25 to the caller after which we break out of the helper function and we get max_sum as 42.\\n\\n    int max_sum=INT_MIN;\\n    int max_gain(TreeNode* root)\\n    {\\n        if(!root)return 0;\\n        int l=max(max_gain(root->left),0);\\n        int r=max(max_gain(root->right),0);\\n        int new_price=root->val+l+r;\\n        max_sum=max(max_sum,new_price);\\n        return root->val+max(l,r);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        max_gain(root);\\n        return max_sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39875,
                "title": "elegant-java-solution",
                "content": "    public class Solution {\\n        int max = Integer.MIN_VALUE;\\n        \\n        public int maxPathSum(TreeNode root) {\\n            helper(root);\\n            return max;\\n        }\\n        \\n        // helper returns the max branch \\n        // plus current node's value\\n        int helper(TreeNode root) {\\n            if (root == null) return 0;\\n            \\n            int left = Math.max(helper(root.left), 0);\\n            int right = Math.max(helper(root.right), 0);\\n            \\n            max = Math.max(max, root.val + left + right);\\n            \\n            return root.val + Math.max(left, right);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        int max = Integer.MIN_VALUE;\\n        \\n        public int maxPathSum(TreeNode root) {\\n            helper(root);\\n            return max;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 39869,
                "title": "simple-o-n-algorithm-with-one-traversal-through-the-tree",
                "content": "    class Solution {\\n        int maxToRoot(TreeNode *root, int &re) {\\n            if (!root) return 0;\\n            int l = maxToRoot(root->left, re);\\n            int r = maxToRoot(root->right, re);\\n            if (l < 0) l = 0;\\n            if (r < 0) r = 0;\\n            if (l + r + root->val > re) re = l + r + root->val;\\n            return root->val += max(l, r);\\n        }\\n    public:\\n        int maxPathSum(TreeNode *root) {\\n            int max = -2147483648;\\n            maxToRoot(root, max);\\n            return max;\\n        }\\n    };\\n\\nupdate the val of each node of the tree bottom-up, the new val of TreeNode *x stands for the max sum started from any node in subtree x and ended in x, mataining the re for result in traversal at the same time.",
                "solutionTags": [],
                "code": "class Solution {\\n        int maxToRoot(TreeNode *root, int &re) {\\n            if (!root) return 0;\\n            int l = maxToRoot(root->left, re);\\n            int r = maxToRoot(root->right, re);\\n            if (l < 0) l = 0;\\n            if (r < 0) r = 0;\\n            if (l + r + root->val > re) re = l + r + root->val;\\n            return root->val += max(l, r);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 370666,
                "title": "concise-dfs-solution-with-detailed-explanation-python",
                "content": "The idea is to **update node values with the biggest, positive cumulative sum gathered by its children**:\\n* If both contributions are negative, no value is added. \\n* If both are positive, only the biggest one is added, so that we don\\'t include both children during the rest of the tree exploration. \\n* Leaves return its own value and we recursively work our way upwards.\\n\\nA global maximum sum variable is maintained so that **every path can be individually checked**, while updated node values on the tree **allow for exploration of other valid paths outside of the current subtree**. \\nMore details in the code comments:\\n\\n```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        self.max_sum = float(\\'-inf\\')\\n        self.dfs(root)\\n        return self.max_sum\\n    \\n    def dfs(self, node):\\n        if not node: return 0\\n        \\n        # only add positive contributions\\n        leftST_sum = max(0, self.dfs(node.left))\\n        rightST_sum = max(0, self.dfs(node.right))\\n\\n        # check if cumulative sum at current node > global max sum so far\\n        # this evaluates a candidate path\\n        self.max_sum = max(self.max_sum, leftST_sum + rightST_sum + node.val)\\n        \\n        # add to the current node ONLY one of the children contributions\\n        # in order to maintain the constraint of considering only paths\\n        # if not, we would be exploring explore the whole tree - against problem definition\\n        return max(leftST_sum, rightST_sum) + node.val\\n```\\n\\nThe key is to always choose the maximum cumulative sum path, while updating the \"global\" maximum value, from the leaves upwards.",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        self.max_sum = float(\\'-inf\\')\\n        self.dfs(root)\\n        return self.max_sum\\n    \\n    def dfs(self, node):\\n        if not node: return 0\\n        \\n        # only add positive contributions\\n        leftST_sum = max(0, self.dfs(node.left))\\n        rightST_sum = max(0, self.dfs(node.right))\\n\\n        # check if cumulative sum at current node > global max sum so far\\n        # this evaluates a candidate path\\n        self.max_sum = max(self.max_sum, leftST_sum + rightST_sum + node.val)\\n        \\n        # add to the current node ONLY one of the children contributions\\n        # in order to maintain the constraint of considering only paths\\n        # if not, we would be exploring explore the whole tree - against problem definition\\n        return max(leftST_sum, rightST_sum) + node.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39919,
                "title": "8-10-lines-two-solutions",
                "content": "Two solutions:\\n\\n---\\n\\n**Solution 1: *Helper returning two values*:** (240 ms, 8 lines)\\n\\n    def maxPathSum(self, root):\\n        def maxsums(node):\\n            if not node:\\n                return [-2**31] * 2\\n            left = maxsums(node.left)\\n            right = maxsums(node.right)\\n            return [node.val + max(left[0], right[0], 0),\\n                    max(left + right + [node.val + left[0] + right[0]])]\\n        return max(maxsums(root))\\n\\nMy helper function returns two values:\\n\\n 1. The max sum of all paths ending in the given node (can be extended through the parent)\\n 2. The max sum of all paths anywhere in tree rooted at the given node (can *not* be extended through the parent).\\n\\n\\n---\\n\\n**Solution 2: *Helper updating a \"global\" maximum*:** (172 ms, 10 lines)\\n\\n    def maxPathSum(self, root):\\n        def maxend(node):\\n            if not node:\\n                return 0\\n            left = maxend(node.left)\\n            right = maxend(node.right)\\n            self.max = max(self.max, left + node.val + right)\\n            return max(node.val + max(left, right), 0)\\n        self.max = None\\n        maxend(root)\\n        return self.max\\n\\nHere the helper is similar, but only returns the first of the two values (the max sum of all paths ending in the given node). Instead of returning the second value (the max sum of all paths anywhere in tree rooted at the given node), it updates a \"global\" maximum.",
                "solutionTags": [
                    "Python"
                ],
                "code": "Two solutions:\\n\\n---\\n\\n**Solution 1: *Helper returning two values*:** (240 ms, 8 lines)\\n\\n    def maxPathSum(self, root):\\n        def maxsums(node):\\n            if not node:\\n                return [-2**31] * 2\\n            left = maxsums(node.left)\\n            right = maxsums(node.right)\\n            return [node.val + max(left[0], right[0], 0),\\n                    max(left + right + [node.val + left[0] + right[0]])]\\n        return max(maxsums(root))\\n\\nMy helper function returns two values:\\n\\n 1. The max sum of all paths ending in the given node (can be extended through the parent)\\n 2. The max sum of all paths anywhere in tree rooted at the given node (can *not* be extended through the parent).\\n\\n\\n---\\n\\n**Solution 2: *Helper updating a \"global\" maximum*:** (172 ms, 10 lines)\\n\\n    def maxPathSum(self, root):\\n        def maxend(node):\\n            if not node:\\n                return 0\\n            left = maxend(node.left)\\n            right = maxend(node.right)\\n            self.max = max(self.max, left + node.val + right)\\n            return max(node.val + max(left, right), 0)\\n        self.max = None\\n        maxend(root)\\n        return self.max\\n\\nHere the helper is similar, but only returns the first of the two values (the max sum of all paths ending in the given node). Instead of returning the second value (the max sum of all paths anywhere in tree rooted at the given node), it updates a \"global\" maximum.",
                "codeTag": "Python3"
            },
            {
                "id": 39873,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "    class Solution {\\n        int sum;\\n    public:\\n        int maxPathSum(TreeNode* root) {\\n            sum=INT_MIN;\\n            help(root);\\n            return sum;\\n        }\\n        \\n        /*** return the max-value-ended-at-root-node ***/\\n        int help(TreeNode* root){\\n            if(!root)   return 0;\\n            int left = max(0, help(root->left));\\n            int right = max(0, help(root->right));\\n            /*** key parts : embedding the max-value-find in the recursion process ***/\\n            sum = max(sum, left+right+root->val);\\n            /*** get the max-value-ended-at-root ***/\\n            return max(left, right)+root->val;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        int sum;\\n    public:\\n        int maxPathSum(TreeNode* root) {\\n            sum=INT_MIN;\\n            help(root);\\n            return sum;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1288024,
                "title": "c-easy-to-understand-full-explanation-article-with-code",
                "content": "```\\nLet\\'s think what can be the possible cases for this question:\\n1) The MaxPathSum can pass through root node.\\n    eg: \\n            10  <- MaxPathSum passes through this node ( considering 10 as root ).\\n            /\\\\\\n           2  10\\n          /\\\\    \\\\\\n         20 1   -20 \\n2) MaxPathSum can be present in the left Subtree.\\n    eg:\\n           -100  <- MaxPathSum passes lies in the left Subtree ( considering -100 as root ).\\n            /\\\\\\n           2  10\\n          /\\\\    \\\\\\n         20 1   -20 \\n    \\n\\n3) MaxPathSum can be present int the right Subtree.\\n\\n    eg:\\n           -100  <- MaxPathSum passes lies in the right Subtree ( considering -100 as root ).\\n            /\\\\\\n         -200  1000\\n          /\\\\    \\\\\\n         20 1   200 \\n\\nSo, we just have to write for the case when it passes through the root node. Recursion will take care of the rest.\\n\\nAnother thing, we have to also keep a track of max branch sum. Here is an example why:\\n    eg: \\n\\n        Lets say the left branch sum of this subtree is 20 and right branch is 30.\\n            10\\n           /  \\\\                         BS = Branch Sum\\n        /\\\\      /\\\\  \\n       /20\\\\    /30\\\\\\n      / BS \\\\  / BS \\\\\\n     /______\\\\/______\\\\\\n\\n But it may be possible that we can find even better answer which includes this subtree. \\n In that case we have to pick a single branch of this subtree.\\n Since path can only be in one direction from a node, i.e, either we can go left or right from a node.\\n like, \\n\\n              50            MaxPathSum = 30 + 10 + 50 + 7\\n             /  \\\\ \\n            10   7\\n           /  \\\\\\n        /\\\\      /\\\\  \\n       /20\\\\    /30\\\\\\n      / BS \\\\  / BS \\\\\\n     /______\\\\/______\\\\\\n\\n So, here the root 50 should know what is the maxBranchSum in the left to find the maxPathSum.\\nSo, 10 will return the branch sum as [max(leftBranchSum , rightBranchSum) + root->val] to its parent.\\n```\\n\\n\\nOnce you have figured that out, then the answer is pretty simple.\\n\\nthe ans can be :\\nmax({\\n    root->val,                                    //root can be ans\\n    leftBS,   //BS = BranchSum        //left branch of the root may have the ans\\n    rightBS,  //BS = BranchSum      //right branch of the root may have the ans\\n    leftBS + rightBS + root->val   //left branch + root + right branch can be the ans\\n});\\nLets have a look at the code:\\n```\\n\\nint maxSum(TreeNode* root, int& ans) {\\n    /* This function return the Branch Sum......\\n    So if the node is NULL then it won\\'t have a branch....so the branch sum will be 0.\\n    */\\n    //Base Case\\n    if(root == NULL){\\n        return 0;\\n    }\\n    \\n    //Recursive Case \\n    //BS = Branch Sum\\n    int leftBS = root->val + maxSum( root->left , ans );\\n    int rightBS = root->val + maxSum( root->right , ans );\\n    \\n    ans = max({\\n                ans,            //we may have found the maximum ans already\\n                root->val,      //may be the current root val is the maximum sum possible\\n                leftBS,         //may be the answer contain root->val + left branch value\\n                rightBS,        //may be the answer contain root->val + right branch value\\n                leftBS + rightBS - root->val   // may be ans conatin left branch + right branch + root->val\\n                                               // Since the root val is added twice from leftBS and rightBS so we are sunstracting it.\\n            });\\n    \\n    //Return the max branch Sum\\n    return max({ leftBS , rightBS , root->val });\\n}\\n\\nint maxPathSum(TreeNode* root) {\\n    int ans = INT_MIN;\\n    maxSum(root, ans);\\n    return ans;\\n}\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nLet\\'s think what can be the possible cases for this question:\\n1) The MaxPathSum can pass through root node.\\n    eg: \\n            10  <- MaxPathSum passes through this node ( considering 10 as root ).\\n            /\\\\\\n           2  10\\n          /\\\\    \\\\\\n         20 1   -20 \\n2) MaxPathSum can be present in the left Subtree.\\n    eg:\\n           -100  <- MaxPathSum passes lies in the left Subtree ( considering -100 as root ).\\n            /\\\\\\n           2  10\\n          /\\\\    \\\\\\n         20 1   -20 \\n    \\n\\n3) MaxPathSum can be present int the right Subtree.\\n\\n    eg:\\n           -100  <- MaxPathSum passes lies in the right Subtree ( considering -100 as root ).\\n            /\\\\\\n         -200  1000\\n          /\\\\    \\\\\\n         20 1   200 \\n\\nSo, we just have to write for the case when it passes through the root node. Recursion will take care of the rest.\\n\\nAnother thing, we have to also keep a track of max branch sum. Here is an example why:\\n    eg: \\n\\n        Lets say the left branch sum of this subtree is 20 and right branch is 30.\\n            10\\n           /  \\\\                         BS = Branch Sum\\n        /\\\\      /\\\\  \\n       /20\\\\    /30\\\\\\n      / BS \\\\  / BS \\\\\\n     /______\\\\/______\\\\\\n\\n But it may be possible that we can find even better answer which includes this subtree. \\n In that case we have to pick a single branch of this subtree.\\n Since path can only be in one direction from a node, i.e, either we can go left or right from a node.\\n like, \\n\\n              50            MaxPathSum = 30 + 10 + 50 + 7\\n             /  \\\\ \\n            10   7\\n           /  \\\\\\n        /\\\\      /\\\\  \\n       /20\\\\    /30\\\\\\n      / BS \\\\  / BS \\\\\\n     /______\\\\/______\\\\\\n\\n So, here the root 50 should know what is the maxBranchSum in the left to find the maxPathSum.\\nSo, 10 will return the branch sum as [max(leftBranchSum , rightBranchSum) + root->val] to its parent.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39927,
                "title": "iterative-java-solution",
                "content": "Hi guys!\\n\\nThe idea of mine approach is similar to recursive solutions which can be found in other posts but made in iterative manner. We just need to traverse the nodes in post-order (the same as the order of topological sorting, actually) storing the maximum root paths in a cache and updating the result value. Here's how it looks like in Java:\\n\\n    // just returns the nodes in post-order\\n    public Iterable<TreeNode> topSort(TreeNode root) {\\n        Deque<TreeNode> result = new LinkedList<>();\\n        if (root != null) {\\n            Deque<TreeNode> stack = new LinkedList<>();\\n            stack.push(root);\\n            while (!stack.isEmpty()) {\\n                TreeNode curr = stack.pop();\\n                result.push(curr);\\n                if (curr.right != null) stack.push(curr.right);\\n                if (curr.left != null) stack.push(curr.left);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public int maxPathSum(TreeNode root) {\\n        int result = Integer.MIN_VALUE;\\n        Map<TreeNode, Integer> maxRootPath = new HashMap<>(); // cache\\n        maxRootPath.put(null, 0); // for simplicity we want to handle null nodes\\n        for (TreeNode node : topSort(root)) {\\n            // as we process nodes in post-order their children are already cached\\n            int left = Math.max(maxRootPath.get(node.left), 0);\\n            int right = Math.max(maxRootPath.get(node.right), 0); \\n            maxRootPath.put(node, Math.max(left, right) + node.val);\\n            result = Math.max(left + right + node.val, result);\\n        }\\n        return result;\\n    }\\n\\nHappy coding!",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi guys!\\n\\nThe idea of mine approach is similar to recursive solutions which can be found in other posts but made in iterative manner. We just need to traverse the nodes in post-order (the same as the order of topological sorting, actually) storing the maximum root paths in a cache and updating the result value. Here's how it looks like in Java:\\n\\n    // just returns the nodes in post-order\\n    public Iterable<TreeNode> topSort(TreeNode root) {\\n        Deque<TreeNode> result = new LinkedList<>();\\n        if (root != null) {\\n            Deque<TreeNode> stack = new LinkedList<>();\\n            stack.push(root);\\n            while (!stack.isEmpty()) {\\n                TreeNode curr = stack.pop();\\n                result.push(curr);\\n                if (curr.right != null) stack.push(curr.right);\\n                if (curr.left != null) stack.push(curr.left);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public int maxPathSum(TreeNode root) {\\n        int result = Integer.MIN_VALUE;\\n        Map<TreeNode, Integer> maxRootPath = new HashMap<>(); // cache\\n        maxRootPath.put(null, 0); // for simplicity we want to handle null nodes\\n        for (TreeNode node : topSort(root)) {\\n            // as we process nodes in post-order their children are already cached\\n            int left = Math.max(maxRootPath.get(node.left), 0);\\n            int right = Math.max(maxRootPath.get(node.right), 0); \\n            maxRootPath.put(node, Math.max(left, right) + node.val);\\n            result = Math.max(left + right + node.val, result);\\n        }\\n        return result;\\n    }\\n\\nHappy coding!",
                "codeTag": "Unknown"
            },
            {
                "id": 39807,
                "title": "a-very-concise-recursive-solution",
                "content": "    int maxPathSum(TreeNode *root) {\\n        int maxPath = INT_MIN;\\n        dfsMaxPath(root, maxPath);\\n        return maxPath;\\n    }\\n    \\n    int dfsMaxPath(TreeNode *root, int &maxPath) {\\n        if (!root) return 0;\\n        int l = max(0, dfsMaxPath(root->left, maxPath));\\n        int r = max(0, dfsMaxPath(root->right, maxPath));\\n        maxPath = max(maxPath, l + r + root->val);\\n        return root->val + max(l, r);\\n    }",
                "solutionTags": [],
                "code": "    int maxPathSum(TreeNode *root) {\\n        int maxPath = INT_MIN;\\n        dfsMaxPath(root, maxPath);\\n        return maxPath;\\n    }\\n    \\n    int dfsMaxPath(TreeNode *root, int &maxPath) {\\n        if (!root) return 0;\\n        int l = max(0, dfsMaxPath(root->left, maxPath));\\n        int r = max(0, dfsMaxPath(root->right, maxPath));\\n        maxPath = max(maxPath, l + r + root->val);\\n        return root->val + max(l, r);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 39884,
                "title": "python-solution-beats-97",
                "content": "    class Solution(object):\\n        current_max = float('-inf')\\n        def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n            self.maxPathSumHelper(root)\\n            return self.current_max\\n    \\n        def maxPathSumHelper(self, root):\\n            \"\"\"Helper method\"\"\"\\n            if root is None:\\n                return root\\n            left = self.maxPathSumHelper(root.left)\\n            right = self.maxPathSumHelper(root.right)\\n            left = 0 if left is None else (left if left > 0 else 0)\\n            right = 0 if right is None else (right if right > 0 else 0)\\n            self.current_max = max(left+right+root.val, self.current_max)\\n            return max(left, right) + root.val\\n\\nThis is my first post and I thought I would share my solution since it beats 97% of submissions. I keep a global variable current_max and update it whenever the sum of the root and its children are greater than the current max. I don't consider a child if its value is negative(set it to zero). Each parent returns its maximum child plus its own value.",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        current_max = float('-inf')\\n        def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n            self.maxPathSumHelper(root)\\n            return self.current_max\\n    \\n        def maxPathSumHelper(self, root):\\n            \"\"\"Helper method\"\"\"\\n            if root is None:\\n                return root\\n            left = self.maxPathSumHelper(root.left)\\n            right = self.maxPathSumHelper(root.right)\\n            left = 0 if left is None else (left if left > 0 else 0)\\n            right = 0 if right is None else (right if right > 0 else 0)\\n            self.current_max = max(left+right+root.val, self.current_max)\\n            return max(left, right) + root.val\\n\\nThis is my first post and I thought I would share my solution since it beats 97% of submissions. I keep a global variable current_max and update it whenever the sum of the root and its children are greater than the current max. I don't consider a child if its value is negative(set it to zero). Each parent returns its maximum child plus its own value.",
                "codeTag": "Java"
            },
            {
                "id": 982696,
                "title": "javascript-o-n-time-easy-to-understand-with-explanation",
                "content": "It\\'s important to point out that we are looking for the **maximum path**. In the most simple case, a single node can be the max path, or even the entire tree could be the max path. To keep the max variable up to date, I create a global variable that will be updated over the run of the functions.\\n\\nWe are doing a DFS recursive function here.\\n\\nWe need a base case, and that base case is if we hit a null, we return 0. We are going going to finish the left subtree before going to the right subtree, which is denoted by `findSums(node.left)` then after is `findSums(node.right)`. After the left and right subtree are done (for an example, look at a single node), we have three different sums. All three nodes (left, right and node.val), left side (node.val and left), right side (node.val and right) or just the single node. We use these values (with the current max) to find the max.\\n\\nThe most important part is **what do we return for this recursive function?** The answer is we are returning\\n\\n\\tThe Max Path from this node\\n\\t\\nThat can be node.val, leftNodeSum, or rightNodeSum. We cannot return allSum since that would not be a path. Very, very important to point that out.\\n\\n```\\nconst maxPathSum = (root) => {\\n\\tlet max = -Infinity;\\n\\n\\tconst findSums = (node) => {\\n\\t\\t// Base case / hit a null\\n\\t\\tif (!node) return 0;\\n\\n\\t\\tlet left = findSums(node.left),\\n\\t\\t\\tright = findSums(node.right),\\n\\t\\t\\tallSum = left + right + node.val,\\n\\t\\t\\tleftNodeSum = left + node.val,\\n\\t\\t\\trightNodeSum = right + node.val;\\n\\n\\t\\t// Max is all possible combinations\\n\\t\\tmax = Math.max(max, node.val, allSum, leftNodeSum, rightNodeSum);\\n\\t\\t\\n\\t\\t// Return the MAX path, which can be node.val, left + node.val, or right + node.val\\n\\t\\treturn Math.max(leftNodeSum, rightNodeSum, node.val);\\n\\t};\\n\\n\\tfindSums(root);\\n\\n\\treturn max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nconst maxPathSum = (root) => {\\n\\tlet max = -Infinity;\\n\\n\\tconst findSums = (node) => {\\n\\t\\t// Base case / hit a null\\n\\t\\tif (!node) return 0;\\n\\n\\t\\tlet left = findSums(node.left),\\n\\t\\t\\tright = findSums(node.right),\\n\\t\\t\\tallSum = left + right + node.val,\\n\\t\\t\\tleftNodeSum = left + node.val,\\n\\t\\t\\trightNodeSum = right + node.val;\\n\\n\\t\\t// Max is all possible combinations\\n\\t\\tmax = Math.max(max, node.val, allSum, leftNodeSum, rightNodeSum);\\n\\t\\t\\n\\t\\t// Return the MAX path, which can be node.val, left + node.val, or right + node.val\\n\\t\\treturn Math.max(leftNodeSum, rightNodeSum, node.val);\\n\\t};\\n\\n\\tfindSums(root);\\n\\n\\treturn max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 419793,
                "title": "python-recursive-solution-beats-98-in-time-and-75-in-memory",
                "content": "```python\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        self.res = float(\\'-inf\\')\\n        self.helper(root)\\n        return self.res \\n        \\n    def helper(self, root):\\n        if not root:\\n            return 0\\n        left, right = self.helper(root.left), self.helper(root.right)\\n        self.res = max(self.res, root.val + left + right)\\n        return max(root.val + max(left, right), 0)\\n   ```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```python\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        self.res = float(\\'-inf\\')\\n        self.helper(root)\\n        return self.res \\n        \\n    def helper(self, root):\\n        if not root:\\n            return 0\\n        left, right = self.helper(root.left), self.helper(root.right)\\n        self.res = max(self.res, root.val + left + right)\\n        return max(root.val + max(left, right), 0)\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 39908,
                "title": "python-solution-with-comments",
                "content": "    \\n    # Recursively \\n    def maxPathSum(self, root):\\n        self.res = -sys.maxsize-1\\n        self.oneSideSum(root)\\n        return self.res\\n        \\n    # compute one side maximal sum, \\n    # (root+left children, or root+right children),\\n    # root is the included top-most node \\n    def oneSideSum(self, root):\\n        if not root:\\n            return 0\\n        l = max(0, self.oneSideSum(root.left))\\n        r = max(0, self.oneSideSum(root.right))\\n        self.res = max(self.res, l+r+root.val)\\n        return max(l, r)+root.val",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "    \\n    # Recursively \\n    def maxPathSum(self, root):\\n        self.res = -sys.maxsize-1\\n        self.oneSideSum(root)\\n        return self.res\\n        \\n    # compute one side maximal sum, \\n    # (root+left children, or root+right children),\\n    # root is the included top-most node \\n    def oneSideSum(self, root):\\n        if not root:\\n            return 0\\n        l = max(0, self.oneSideSum(root.left))\\n        r = max(0, self.oneSideSum(root.right))\\n        self.res = max(self.res, l+r+root.val)\\n        return max(l, r)+root.val",
                "codeTag": "Python3"
            },
            {
                "id": 39862,
                "title": "easy-understand-34ms-c-dfs-solution",
                "content": "    class Solution {\\n    private:\\n        int dfs(TreeNode* root, int& maxsum) {\\n            if(!root) return 0;\\n            int l = max(0,dfs(root->left,maxsum));\\n            int r = max(0,dfs(root->right,maxsum));\\n            maxsum = max(l+r+root->val, maxsum);\\n            return root->val + max(l,r);\\n        }\\n    public:\\n        int maxPathSum(TreeNode* root) {\\n            int maxsum = INT_MIN;\\n            dfs(root,maxsum);\\n            return maxsum;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    private:\\n        int dfs(TreeNode* root, int& maxsum) {\\n            if(!root) return 0;\\n            int l = max(0,dfs(root->left,maxsum));\\n            int r = max(0,dfs(root->right,maxsum));\\n            maxsum = max(l+r+root->val, maxsum);\\n            return root->val + max(l,r);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 39767,
                "title": "simple-python-o-n-solution",
                "content": "```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        \\n        self.msum = float('-inf')\\n        self.get_sum(root)\\n        return self.msum\\n    \\n    def get_sum(self, node):\\n        if not node:\\n            return 0\\n        \\n        ls, rs = self.get_sum(node.left), self.get_sum(node.right)\\n        max_single_path = max(node.val+max(ls,rs), node.val)\\n        self.msum = max(self.msum, max_single_path , node.val+ls+rs)\\n        return max_single_path\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        \\n        self.msum = float('-inf')\\n        self.get_sum(root)\\n        return self.msum\\n    \\n    def get_sum(self, node):\\n        if not node:\\n            return 0\\n        \\n        ls, rs = self.get_sum(node.left), self.get_sum(node.right)\\n        max_single_path = max(node.val+max(ls,rs), node.val)\\n        self.msum = max(self.msum, max_single_path , node.val+ls+rs)\\n        return max_single_path\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39779,
                "title": "8-lines-c-similar-to-diameter-of-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int maxSum = INT_MIN;\\n        DFS(root, maxSum);\\n        return maxSum;\\n    }\\n    \\n    int DFS(TreeNode* root, int& maxSum){\\n        if(!root) return 0;\\n        int left = max(0, DFS(root->left, maxSum));\\n        int right = max(0, DFS(root->right, maxSum));\\n        maxSum = max(maxSum, left + right + root->val);\\n        return max(left, right) + root->val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int maxSum = INT_MIN;\\n        DFS(root, maxSum);\\n        return maxSum;\\n    }\\n    \\n    int DFS(TreeNode* root, int& maxSum){\\n        if(!root) return 0;\\n        int left = max(0, DFS(root->left, maxSum));\\n        int right = max(0, DFS(root->right, maxSum));\\n        maxSum = max(maxSum, left + right + root->val);\\n        return max(left, right) + root->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040330,
                "title": "o-n-time-beats-99-97-memory-speed-0ms-may-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\n// just returns the nodes in post-order\\npublic Iterable<TreeNode> topSort(TreeNode root) {\\n    Deque<TreeNode> result = new LinkedList<>();\\n    if (root != null) {\\n        Deque<TreeNode> stack = new LinkedList<>();\\n        stack.push(root);\\n        while (!stack.isEmpty()) {\\n            TreeNode curr = stack.pop();\\n            result.push(curr);\\n            if (curr.right != null) stack.push(curr.right);\\n            if (curr.left != null) stack.push(curr.left);\\n        }\\n    }\\n    return result;\\n}\\n\\npublic int maxPathSum(TreeNode root) {\\n    int result = Integer.MIN_VALUE;\\n    Map<TreeNode, Integer> maxRootPath = new HashMap<>(); // cache\\n    maxRootPath.put(null, 0); // for simplicity we want to handle null nodes\\n    for (TreeNode node : topSort(root)) {\\n        // as we process nodes in post-order their children are already cached\\n        int left = Math.max(maxRootPath.get(node.left), 0);\\n        int right = Math.max(maxRootPath.get(node.right), 0); \\n        maxRootPath.put(node, Math.max(left, right) + node.val);\\n        result = Math.max(left + right + node.val, result);\\n    }\\n    return result;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nint maxSum(TreeNode* root, int& ans) {\\n    /* This function return the Branch Sum......\\n    So if the node is NULL then it won\\'t have a branch....so the branch sum will be 0.\\n    */\\n    //Base Case\\n    if(root == NULL){\\n        return 0;\\n    }\\n    \\n    //Recursive Case \\n    //BS = Branch Sum\\n    int leftBS = root->val + maxSum( root->left , ans );\\n    int rightBS = root->val + maxSum( root->right , ans );\\n    \\n    ans = max({\\n                ans,            //we may have found the maximum ans already\\n                root->val,      //may be the current root val is the maximum sum possible\\n                leftBS,         //may be the answer contain root->val + left branch value\\n                rightBS,        //may be the answer contain root->val + right branch value\\n                leftBS + rightBS - root->val   // may be ans conatin left branch + right branch + root->val\\n                                               // Since the root val is added twice from leftBS and rightBS so we are sunstracting it.\\n            });\\n    \\n    //Return the max branch Sum\\n    return max({ leftBS , rightBS , root->val });\\n}\\n\\nint maxPathSum(TreeNode* root) {\\n    int ans = INT_MIN;\\n    maxSum(root, ans);\\n    return ans;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.maxSum = float(\\'-inf\\')\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        def traverse(root):\\n            if root:\\n                left = traverse(root.left)\\n                right = traverse(root.right)\\n                self.maxSum = max(self.maxSum,root.val, root.val + left, root.val + right, root.val + left + right)\\n                return max(root.val,root.val + left,root.val + right)\\n            else:\\n                return 0\\n        traverse(root)\\n        return self.maxSum\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nvar maxPathSum = function(root) {\\n  var max = -Number.MAX_VALUE;\\n  getMaxSum(root);\\n  return max;\\n  function getMaxSum(node) {\\n    if (!node) return 0;\\n    var leftSum = getMaxSum(node.left);\\n    var rightSum = getMaxSum(node.right);\\n    max = Math.max(max, node.val + leftSum + rightSum);\\n    return Math.max(0, node.val + leftSum, node.val + rightSum);\\n  }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nclass Solution {\\n    fun maxPathSum(root: TreeNode?) = postorder(root).maxSum\\n\\n    private fun postorder(node: TreeNode?): Res {\\n        if (node == null)\\n            return Res(Int.MIN_VALUE, 0)\\n\\n        val (leftMaxSum, leftPathSum) = postorder(node.left)\\n        val (rightMaxSum, rightPathSum) = postorder(node.right)\\n\\n        val value = node.`val`\\n        val sum = leftPathSum + rightPathSum + value\\n\\n        return Res(maxOf(leftMaxSum, rightMaxSum, sum), maxOf(0, value + maxOf(leftPathSum, rightPathSum)))\\n    }\\n\\n    private data class Res(val maxSum: Int, val pathSum: Int)\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in binary tree.\\n    //   - space: O(n), where n is the number of nodes in binary tree.\\n    \\n    func maxPathSum(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        var currMaxSum = Int.min\\n        return max(maxPathSum(root, currMaxSum: &currMaxSum), currMaxSum)\\n    }\\n\\n    \\n    private func maxPathSum(_ currNode: TreeNode?, currMaxSum: inout Int) -> Int {\\n        guard let currNode = currNode else { return 0 }\\n\\n        let leftSum = max(maxPathSum(currNode.left, currMaxSum: &currMaxSum), 0)\\n        let rightSum = max(maxPathSum(currNode.right, currMaxSum: &currMaxSum), 0)\\n\\n        currMaxSum = max(currNode.val + leftSum + rightSum, currMaxSum)\\n        return max(leftSum, rightSum) + currNode.val\\n    }\\n\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\n// just returns the nodes in post-order\\npublic Iterable<TreeNode> topSort(TreeNode root) {\\n    Deque<TreeNode> result = new LinkedList<>();\\n    if (root != null) {\\n        Deque<TreeNode> stack = new LinkedList<>();\\n        stack.push(root);\\n        while (!stack.isEmpty()) {\\n            TreeNode curr = stack.pop();\\n            result.push(curr);\\n            if (curr.right != null) stack.push(curr.right);\\n            if (curr.left != null) stack.push(curr.left);\\n        }\\n    }\\n    return result;\\n}\\n\\npublic int maxPathSum(TreeNode root) {\\n    int result = Integer.MIN_VALUE;\\n    Map<TreeNode, Integer> maxRootPath = new HashMap<>(); // cache\\n    maxRootPath.put(null, 0); // for simplicity we want to handle null nodes\\n    for (TreeNode node : topSort(root)) {\\n        // as we process nodes in post-order their children are already cached\\n        int left = Math.max(maxRootPath.get(node.left), 0);\\n        int right = Math.max(maxRootPath.get(node.right), 0); \\n        maxRootPath.put(node, Math.max(left, right) + node.val);\\n        result = Math.max(left + right + node.val, result);\\n    }\\n    return result;\\n}\\n```\n```\\n```\n```\\n```\n```\\nint maxSum(TreeNode* root, int& ans) {\\n    /* This function return the Branch Sum......\\n    So if the node is NULL then it won\\'t have a branch....so the branch sum will be 0.\\n    */\\n    //Base Case\\n    if(root == NULL){\\n        return 0;\\n    }\\n    \\n    //Recursive Case \\n    //BS = Branch Sum\\n    int leftBS = root->val + maxSum( root->left , ans );\\n    int rightBS = root->val + maxSum( root->right , ans );\\n    \\n    ans = max({\\n                ans,            //we may have found the maximum ans already\\n                root->val,      //may be the current root val is the maximum sum possible\\n                leftBS,         //may be the answer contain root->val + left branch value\\n                rightBS,        //may be the answer contain root->val + right branch value\\n                leftBS + rightBS - root->val   // may be ans conatin left branch + right branch + root->val\\n                                               // Since the root val is added twice from leftBS and rightBS so we are sunstracting it.\\n            });\\n    \\n    //Return the max branch Sum\\n    return max({ leftBS , rightBS , root->val });\\n}\\n\\nint maxPathSum(TreeNode* root) {\\n    int ans = INT_MIN;\\n    maxSum(root, ans);\\n    return ans;\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution:\\n    def __init__(self):\\n        self.maxSum = float(\\'-inf\\')\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        def traverse(root):\\n            if root:\\n                left = traverse(root.left)\\n                right = traverse(root.right)\\n                self.maxSum = max(self.maxSum,root.val, root.val + left, root.val + right, root.val + left + right)\\n                return max(root.val,root.val + left,root.val + right)\\n            else:\\n                return 0\\n        traverse(root)\\n        return self.maxSum\\n```\n```\\n```\n```\\n```\n```\\nvar maxPathSum = function(root) {\\n  var max = -Number.MAX_VALUE;\\n  getMaxSum(root);\\n  return max;\\n  function getMaxSum(node) {\\n    if (!node) return 0;\\n    var leftSum = getMaxSum(node.left);\\n    var rightSum = getMaxSum(node.right);\\n    max = Math.max(max, node.val + leftSum + rightSum);\\n    return Math.max(0, node.val + leftSum, node.val + rightSum);\\n  }\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    fun maxPathSum(root: TreeNode?) = postorder(root).maxSum\\n\\n    private fun postorder(node: TreeNode?): Res {\\n        if (node == null)\\n            return Res(Int.MIN_VALUE, 0)\\n\\n        val (leftMaxSum, leftPathSum) = postorder(node.left)\\n        val (rightMaxSum, rightPathSum) = postorder(node.right)\\n\\n        val value = node.`val`\\n        val sum = leftPathSum + rightPathSum + value\\n\\n        return Res(maxOf(leftMaxSum, rightMaxSum, sum), maxOf(0, value + maxOf(leftPathSum, rightPathSum)))\\n    }\\n\\n    private data class Res(val maxSum: Int, val pathSum: Int)\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in binary tree.\\n    //   - space: O(n), where n is the number of nodes in binary tree.\\n    \\n    func maxPathSum(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        var currMaxSum = Int.min\\n        return max(maxPathSum(root, currMaxSum: &currMaxSum), currMaxSum)\\n    }\\n\\n    \\n    private func maxPathSum(_ currNode: TreeNode?, currMaxSum: inout Int) -> Int {\\n        guard let currNode = currNode else { return 0 }\\n\\n        let leftSum = max(maxPathSum(currNode.left, currMaxSum: &currMaxSum), 0)\\n        let rightSum = max(maxPathSum(currNode.right, currMaxSum: &currMaxSum), 0)\\n\\n        currMaxSum = max(currNode.val + leftSum + rightSum, currMaxSum)\\n        return max(leftSum, rightSum) + currNode.val\\n    }\\n\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329033,
                "title": "python-bottom-up-dfs-solution",
                "content": "Please see and vote for my solutions for these similar problems.\\n[250. Count Univalue Subtrees](https://leetcode.com/problems/count-univalue-subtrees/discuss/329039/Python-bottom-up-DFS-solution)\\n[508. Most Frequent Subtree Sum](https://leetcode.com/problems/most-frequent-subtree-sum/discuss/329045/Python-bottom-up-DFS)\\n[543. Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/discuss/329022/Python-DFS-solution%3A-return-values-and-update-global-result-from-bottom-to-top)\\n[1245. Tree Diameter](https://leetcode.com/problems/tree-diameter/discuss/418906/Python-bottom-up-DFS-solution-(similar-problems-listed))\\n[687. Longest Univalue Path](https://leetcode.com/problems/longest-univalue-path/discuss/329031/Python-bottom-up-DFS-solution)\\n[124. Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/discuss/329033/Python-bottom-up-DFS-solution)\\n[Max Path Sum in a Grid](https://leetcode.com/discuss/interview-question/391278/google-phone-screen-maximal-path-sum/351744)\\n[298. Binary Tree Longest Consecutive Sequence](https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/discuss/389208/Python-bottom-up-DFS-solution)\\n[549. Binary Tree Longest Consecutive Sequence II](https://leetcode.com/problems/binary-tree-longest-consecutive-sequence-ii/discuss/389210/Python-bottom-up-DFS-solution-(56-ms-beat-93.37))\\n\\nA path may or may not pass through the root.\\nAll paths = {all paths passing through a node and its desendants | for each node in tree}.\\nBottom-up DFS: from bottom to top,\\nfind the maximum-sum path passing through a node and its desendants,\\nupdate the global maximum sum.\\n```\\n    def maxPathSum(self, root):\\n        def maxSum(root):\\n            if not root:\\n                return 0\\n            l_sum = maxSum(root.left)\\n            r_sum = maxSum(root.right)\\n            l = max(0, l_sum)\\n            r = max(0, r_sum)\\n            res[0] = max(res[0], root.val + l + r)\\n            return root.val + max(l, r)\\n        \\n        res = [-float(\\'inf\\')]\\n        maxSum(root)\\n        return res[0]\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxPathSum(self, root):\\n        def maxSum(root):\\n            if not root:\\n                return 0\\n            l_sum = maxSum(root.left)\\n            r_sum = maxSum(root.right)\\n            l = max(0, l_sum)\\n            r = max(0, r_sum)\\n            res[0] = max(res[0], root.val + l + r)\\n            return root.val + max(l, r)\\n        \\n        res = [-float(\\'inf\\')]\\n        maxSum(root)\\n        return res[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 278525,
                "title": "python-iterative-solution",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    \\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        res = float(\\'-inf\\')\\n        stack, last, d = [], None, defaultdict(int)\\n        while root or stack:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            node = stack[-1]        \\n            if node.right and last != node.right:\\n                root = node.right\\n            else:\\n                # Consume the node\\n                node = stack.pop()\\n                last = node\\n                d[node] = max(max(d[node.left], d[node.right]) + node.val, 0)\\n                res = max(res, d[node.left] + d[node.right] + node.val)\\n                \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    \\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        res = float(\\'-inf\\')\\n        stack, last, d = [], None, defaultdict(int)\\n        while root or stack:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            node = stack[-1]        \\n            if node.right and last != node.right:\\n                root = node.right\\n            else:\\n                # Consume the node\\n                node = stack.pop()\\n                last = node\\n                d[node] = max(max(d[node.left], d[node.right]) + node.val, 0)\\n                res = max(res, d[node.left] + d[node.right] + node.val)\\n                \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 602827,
                "title": "python-recursive-clean-beat-99",
                "content": "```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        self.max = float(\\'-inf\\')\\n        def get_sum(root):\\n            if root is None:\\n                return 0\\n            else:\\n                ls = max(get_sum(root.left), 0)\\n                rs = max(get_sum(root.right), 0)\\n                self.max = max(self.max, ls + rs + root.val)\\n                return max(ls, rs, 0) + root.val\\n        \\n        get_sum(root)\\n        return self.max",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        self.max = float(\\'-inf\\')\\n        def get_sum(root):\\n            if root is None:\\n                return 0\\n            else:\\n                ls = max(get_sum(root.left), 0)\\n                rs = max(get_sum(root.right), 0)\\n                self.max = max(self.max, ls + rs + root.val)\\n                return max(ls, rs, 0) + root.val\\n        \\n        get_sum(root)\\n        return self.max",
                "codeTag": "Java"
            },
            {
                "id": 39933,
                "title": "accepted-o-n-solution",
                "content": "The idea is based on the solution of max sum of a sequence array, Here is the explaination of the code:\\n\\n - Have a recursive method which traverse the binary tree, it also\\n   return the max possible sum of left branch and right branch\\n   saperately. for example, For node A, when it's left and right node\\n   recusive call returned, we will know the max possible sum of left\\n   branch, right branch.\\n   \\n - Have a CheckMax function which will compare the sequence sum and\\n   record the max history. For node A, check whether left branch + this \\n   node + right branch is the maximum, check whether left branch + this \\n   node is max\\uff0c check whether right branch + this node is max.\\n - When recursive method return, we should only return the max sum of one path - either the left branch + this node, or the right branch +\\n   this node. So that this is still a single path and can be used to\\n   link by node A's parent node.\\n\\nIt's accepted by OL. Let me know if you have any question\\n\\n    class Solution {\\n        public:\\n            int maxPathSum(TreeNode *root) {\\n                if(!root) return 0;\\n                maxSum = root->val;\\n                recNodes(root); \\n                return maxSum;\\n            }\\n        \\n        protected:\\n            int recNodes(TreeNode* node)\\n            {\\n                int numl=0,numr=0;\\n                if (node->left)\\n                    numl = recNodes(node->left);\\n                if (node->right)\\n                    numr = recNodes(node->right);\\n        \\n                //choose the max path, either left or right \\n                int value = node->val;\\n                int sumWhole = checkMax(value,numl+numr);\\n                int sumLeft = numl>0?checkMax(value,numl):value;\\n                int sumRight = numr>0?checkMax(value,numr):value;\\n        \\n                return max(sumLeft,sumRight);\\n            }\\n        \\n            int checkMax(int value, int sum)\\n            {\\n                if(sum>0)\\n                    sum+=value;\\n                else\\n                    sum=value;\\n                if(sum>maxSum)\\n                    maxSum = sum;\\n                return sum;\\n            }\\n        \\n            int maxSum;\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int maxPathSum(TreeNode *root) {\\n                if(!root) return 0;\\n                maxSum = root->val;\\n                recNodes(root); \\n                return maxSum;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 39871,
                "title": "sharing-a-simple-java-solution",
                "content": "\\n    int max = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return max;\\n    }\\n    \\n    public int helper(TreeNode root) {\\n        if(root == null)\\n            return Integer.MIN_VALUE;\\n        int left = Math.max(0, helper(root.left));\\n        int right = Math.max(0, helper(root.right));\\n        max = Math.max(max, root.val + left + right);\\n        return root.val + Math.max(left, right);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    int max = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return max;\\n    }\\n    \\n    public int helper(TreeNode root) {\\n        if(root == null)\\n            return Integer.MIN_VALUE;\\n        int left = Math.max(0, helper(root.left));\\n        int right = Math.max(0, helper(root.right));\\n        max = Math.max(max, root.val + left + right);\\n        return root.val + Math.max(left, right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 39926,
                "title": "12-line-o-n-javascript-solution-with-176-ms-execution-time",
                "content": "    var maxPathSum = function(root) {\\n      var max = -Number.MAX_VALUE;\\n      getMaxSum(root);\\n      return max;\\n      function getMaxSum(node) {\\n        if (!node) return 0;\\n        var leftSum = getMaxSum(node.left);\\n        var rightSum = getMaxSum(node.right);\\n        max = Math.max(max, node.val + leftSum + rightSum);\\n        return Math.max(0, node.val + leftSum, node.val + rightSum);\\n      }\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var maxPathSum = function(root) {\\n      var max = -Number.MAX_VALUE;\\n      getMaxSum(root);\\n      return max;\\n      function getMaxSum(node) {\\n        if (!node) return 0;\\n        var leftSum = getMaxSum(node.left);\\n        var rightSum = getMaxSum(node.right);\\n        max = Math.max(max, node.val + leftSum + rightSum);\\n        return Math.max(0, node.val + leftSum, node.val + rightSum);\\n      }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 1242055,
                "title": "swift-binary-tree-maximum-path-sum-test-cases",
                "content": "```swift\\nclass Solution {\\n    func maxPathSum(_ root: TreeNode?) -> Int {\\n        var maxSum = Int.min\\n        dfs(root, &maxSum)\\n        return maxSum\\n    }\\n    private func dfs(_ root: TreeNode?, _ maxSum: inout Int) -> Int {\\n        guard let root = root else { return 0 }\\n        let left = max(dfs(root.left, &maxSum), 0)\\n        let right = max(dfs(root.right, &maxSum), 0)\\n        maxSum = max(maxSum, (root.val + left + right))\\n        return root.val + max(left, right)\\n    }\\n}\\n```\\n<hr>\\n\\n##### Test Cases\\n\\n```swift\\nimport XCTest\\n\\n//      Executed 2 tests, with 0 failures (0 unexpected) in 0.387 (0.389) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        let tree = TreeNode([1,2,3])\\n        XCTAssertEqual(s.maxPathSum(tree), 6)\\n    }\\n    func test2() {\\n        let tree = TreeNode([-10,9,20,nil,nil,15,7])\\n        XCTAssertEqual(s.maxPathSum(tree), 42)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n<hr>\\n\\n##### TreeNode class\\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    \\n    // Additional initializer\\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        \\n        val = head; left = nil; right = nil\\n        \\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func maxPathSum(_ root: TreeNode?) -> Int {\\n        var maxSum = Int.min\\n        dfs(root, &maxSum)\\n        return maxSum\\n    }\\n    private func dfs(_ root: TreeNode?, _ maxSum: inout Int) -> Int {\\n        guard let root = root else { return 0 }\\n        let left = max(dfs(root.left, &maxSum), 0)\\n        let right = max(dfs(root.right, &maxSum), 0)\\n        maxSum = max(maxSum, (root.val + left + right))\\n        return root.val + max(left, right)\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n//      Executed 2 tests, with 0 failures (0 unexpected) in 0.387 (0.389) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        let tree = TreeNode([1,2,3])\\n        XCTAssertEqual(s.maxPathSum(tree), 6)\\n    }\\n    func test2() {\\n        let tree = TreeNode([-10,9,20,nil,nil,15,7])\\n        XCTAssertEqual(s.maxPathSum(tree), 42)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    \\n    // Additional initializer\\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        \\n        val = head; left = nil; right = nil\\n        \\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 271697,
                "title": "java-1ms-solution-with-highly-detailed-explanation",
                "content": "Intuitively, we can use recursive method to solve the problem. In order to get the max path sum, we must consider every node in the tree. \\nThe final path must consist of three parts: one node as root (necessary), an **Up To Down Path** originated from its left child (optional)  and an **Up To Down Path** originated from its right child (optional). Here, the **Up to Down Path denotes a sub path originated from a node to its leaf.**\\nWe use ```leftMax``` to denote the max up to down path sum originated from the left child of a node and ```rightMax``` to denote the max up to down path sum originated from the right child of a node. Then the **max path sum** of a node ```n``` is ```n.val + Math.max(leftMax, 0) + Math.max(rightMax, 0)```. Apparently, if ```leftMax``` or ```rightMax``` is no greater than zero, then we don\\'t need them and that\\'s why they are optional. \\nAfter processing a node, we return its **max up to down path sum (not max path sum)**, i.e., ```n.val + Math.max(Math.max(leftMax, 0), Math.max(rightMax, 0))```. \\nAs we can see, the key point of this problem is processing current node to get **max path sum** while returning **max up to down path sum** after processing the node. It is an important idea for solving complex tree problems: processing a problem and return the result of another problem.\\n```\\nint result = Integer.MIN_VALUE;\\n    \\npublic int maxSum(TreeNode root) {\\n\\tif( root == null )\\n\\t\\treturn 0;\\n\\tint leftMax = Math.max(0, maxSum(root.left));\\n\\tint rightMax = Math.max(0, maxSum(root.right));\\n\\tresult = Math.max(result, root.val + leftMax + rightMax);\\n\\treturn root.val + Math.max(leftMax, rightMax);\\n}\\n\\npublic int maxPathSum(TreeNode root) {\\n\\tif( root == null )\\n\\t\\treturn 0;\\n\\telse {\\n\\t\\tmaxSum(root);\\n\\t\\treturn result;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```leftMax```\n```rightMax```\n```n```\n```n.val + Math.max(leftMax, 0) + Math.max(rightMax, 0)```\n```leftMax```\n```rightMax```\n```n.val + Math.max(Math.max(leftMax, 0), Math.max(rightMax, 0))```\n```\\nint result = Integer.MIN_VALUE;\\n    \\npublic int maxSum(TreeNode root) {\\n\\tif( root == null )\\n\\t\\treturn 0;\\n\\tint leftMax = Math.max(0, maxSum(root.left));\\n\\tint rightMax = Math.max(0, maxSum(root.right));\\n\\tresult = Math.max(result, root.val + leftMax + rightMax);\\n\\treturn root.val + Math.max(leftMax, rightMax);\\n}\\n\\npublic int maxPathSum(TreeNode root) {\\n\\tif( root == null )\\n\\t\\treturn 0;\\n\\telse {\\n\\t\\tmaxSum(root);\\n\\t\\treturn result;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39913,
                "title": "clean-c-solution",
                "content": "    class Solution {\\n        int res;\\n    public:\\n        int depth(TreeNode *root){\\n            if(root==NULL) return 0;\\n            int a=depth(root->left), b=depth(root->right);\\n            res=max(res,a+b+root->val);//if *root is the top node in the path\\n            return max(0,max(a, b)+root->val);//if *root is in the path, if this branch a burden or a plus\\n        }\\n        int maxPathSum(TreeNode *root) {\\n            if(root==NULL) return 0;\\n            res=root->val;\\n            depth(root);\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        int res;\\n    public:\\n        int depth(TreeNode *root){\\n            if(root==NULL) return 0;\\n            int a=depth(root->left), b=depth(root->right);\\n            res=max(res,a+b+root->val);//if *root is the top node in the path\\n            return max(0,max(a, b)+root->val);//if *root is in the path, if this branch a burden or a plus\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1481368,
                "title": "java-dfs-explained-faster-than-100-ttt",
                "content": "**This problem needs a bit of thinking**\\nThe key to solving this problem is to break the problem into 2 smaller and simpler sub-parts\\n\\nWe are asked to find out the path with the largest sum. **So, two cases can arise**\\n1. **Case 1** : the present node is included in the largest sum path. If so, it is obvious that the largest sum path will either pass through the left subtree or the right subtree or it might terminate here. *If the larget sum path has to terminate at the current node then it must not include any subtree contribution. Here, it is imp to understand that if the subtrees have a negative contribution then we MUST not add it to our path because if we add anyhting negative, the final value will be even lesser. *\\nExample: If the root val is -2 and the left subtree can generate a max sum of -1 and the right tree can generate -7. If we add either of these values the ultimate result will be lesser that -2. Hence, we WILL ADD ONLY POSITIVE VALUES \\n\\n2. **Case 2 :** the present node need not be included in the path to get the greatest path sum. So, we need to update the max result at every dfs call and we wil see how in the code\\n\\nNow, that we have segmented the question, let\\'s see the code\\n```\\nclass Solution {\\n    int res = Integer.MIN_VALUE; \\n    //this variable will be used to store the result after each possible path and hence will finally store the max  path sum\\n    public int maxPathSum(TreeNode root) {\\n        if(root == null)return res;\\n        dfs(root);      //this will update the value or res as required\\n        return res;\\n    }\\n    public int dfs(TreeNode root){\\n        if(root == null)return 0;   //base case and very imp\\n        \\n        //at any node we want to find the left and right side max Sum\\n        int left = Math.max(dfs(root.left), 0);\\n        int right = Math.max(dfs(root.right), 0);\\n        // we are finding the max with 0 as we do not want to include any subtree with negative contributiuon. See explaination above\\n        \\n\\t\\t\\n\\t\\t//left here is storing the max possible contribution of the left subtree \\n\\t\\t//right here is storing the max possible contribution of right subtree\\n\\t\\t//if either of left and rigth have a possitive contribution(value), the larger will finally be taken \\n\\t\\t\\n\\t\\t//but first we will have to assume that the subtree with root node as root(the variable in this function) will have the largest sum path, so we will inlude this in our res if it has a value larger than previous res\\n        res = Math.max(res, root.val+left + right);\\n\\t\\t\\n\\t\\t\\n\\t\\t//the function however is expected to return the contribution of the current subtree if the subtree was include as in case 1 explained above. It it was terminating here, left and right would have value 0\\n\\t\\t//so we simply return the sum of the root val and the larger between left and rigth subtree sum\\n        return root.val + Math.max(left, right);\\n    \\n    }\\n} //do upvote if this helps\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int res = Integer.MIN_VALUE; \\n    //this variable will be used to store the result after each possible path and hence will finally store the max  path sum\\n    public int maxPathSum(TreeNode root) {\\n        if(root == null)return res;\\n        dfs(root);      //this will update the value or res as required\\n        return res;\\n    }\\n    public int dfs(TreeNode root){\\n        if(root == null)return 0;   //base case and very imp\\n        \\n        //at any node we want to find the left and right side max Sum\\n        int left = Math.max(dfs(root.left), 0);\\n        int right = Math.max(dfs(root.right), 0);\\n        // we are finding the max with 0 as we do not want to include any subtree with negative contributiuon. See explaination above\\n        \\n\\t\\t\\n\\t\\t//left here is storing the max possible contribution of the left subtree \\n\\t\\t//right here is storing the max possible contribution of right subtree\\n\\t\\t//if either of left and rigth have a possitive contribution(value), the larger will finally be taken \\n\\t\\t\\n\\t\\t//but first we will have to assume that the subtree with root node as root(the variable in this function) will have the largest sum path, so we will inlude this in our res if it has a value larger than previous res\\n        res = Math.max(res, root.val+left + right);\\n\\t\\t\\n\\t\\t\\n\\t\\t//the function however is expected to return the contribution of the current subtree if the subtree was include as in case 1 explained above. It it was terminating here, left and right would have value 0\\n\\t\\t//so we simply return the sum of the root val and the larger between left and rigth subtree sum\\n        return root.val + Math.max(left, right);\\n    \\n    }\\n} //do upvote if this helps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39885,
                "title": "c-very-concise-recursive-solution",
                "content": "    int maxSum;\\n    int maxPathSum(TreeNode* root) {\\n        maxSum = INT_MIN;\\n        dfs(root);\\n        return maxSum;\\n    }\\n    // post order\\n    int dfs(TreeNode *root) {\\n        if (!root) return 0;\\n         int l = dfs(root->left);\\n         int r = dfs(root->right);\\n         maxSum = max(maxSum, root->val + (l > 0 ? l : 0) + (r > 0 ? r : 0));\\n         return (max(l, r) > 0 ? max(l, r) : 0) + root->val;\\n    }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "    int maxSum;\\n    int maxPathSum(TreeNode* root) {\\n        maxSum = INT_MIN;\\n        dfs(root);\\n        return maxSum;\\n    }\\n    // post order\\n    int dfs(TreeNode *root) {\\n        if (!root) return 0;\\n         int l = dfs(root->left);\\n         int r = dfs(root->right);\\n         maxSum = max(maxSum, root->val + (l > 0 ? l : 0) + (r > 0 ? r : 0));\\n         return (max(l, r) > 0 ? max(l, r) : 0) + root->val;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 39888,
                "title": "a-recursive-solution-with-comment",
                "content": "        \\n        // global max\\n        int max = Integer.MIN_VALUE;\\n\\n        public int maxPathSum(TreeNode root) {\\n            dfs(root);\\n            return max;\\n        }\\n        \\n        private int dfs(TreeNode root) {\\n            if (root == null) return 0;\\n            // 2 possible choices\\n            // 1.Already calculated in left or right child\\n            // 2.left max path + right max path + root\\n            int lMax = dfs(root.left);\\n            int rMax = dfs(root.right);\\n            if (lMax + rMax + root.val > max) max = lMax + rMax + root.val;\\n            // if the below path is negative, just make it 0 so that we could 'ignore' it\\n            return Math.max(0, root.val + Math.max(lMax, rMax));\\n        }",
                "solutionTags": [],
                "code": "        \\n        // global max\\n        int max = Integer.MIN_VALUE;\\n\\n        public int maxPathSum(TreeNode root) {\\n            dfs(root);\\n            return max;\\n        }\\n        \\n        private int dfs(TreeNode root) {\\n            if (root == null) return 0;\\n            // 2 possible choices\\n            // 1.Already calculated in left or right child\\n            // 2.left max path + right max path + root\\n            int lMax = dfs(root.left);\\n            int rMax = dfs(root.right);\\n            if (lMax + rMax + root.val > max) max = lMax + rMax + root.val;\\n            // if the below path is negative, just make it 0 so that we could 'ignore' it\\n            return Math.max(0, root.val + Math.max(lMax, rMax));\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1935332,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in binary tree.\\n    //   - space: O(n), where n is the number of nodes in binary tree.\\n    \\n    func maxPathSum(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        var currMaxSum = Int.min\\n        return max(maxPathSum(root, currMaxSum: &currMaxSum), currMaxSum)\\n    }\\n\\n    \\n    private func maxPathSum(_ currNode: TreeNode?, currMaxSum: inout Int) -> Int {\\n        guard let currNode = currNode else { return 0 }\\n\\n        let leftSum = max(maxPathSum(currNode.left, currMaxSum: &currMaxSum), 0)\\n        let rightSum = max(maxPathSum(currNode.right, currMaxSum: &currMaxSum), 0)\\n\\n        currMaxSum = max(currNode.val + leftSum + rightSum, currMaxSum)\\n        return max(leftSum, rightSum) + currNode.val\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in binary tree.\\n    //   - space: O(n), where n is the number of nodes in binary tree.\\n    \\n    func maxPathSum(_ root: TreeNode?) -> Int {\\n        guard let root = root else { return 0 }\\n        var currMaxSum = Int.min\\n        return max(maxPathSum(root, currMaxSum: &currMaxSum), currMaxSum)\\n    }\\n\\n    \\n    private func maxPathSum(_ currNode: TreeNode?, currMaxSum: inout Int) -> Int {\\n        guard let currNode = currNode else { return 0 }\\n\\n        let leftSum = max(maxPathSum(currNode.left, currMaxSum: &currMaxSum), 0)\\n        let rightSum = max(maxPathSum(currNode.right, currMaxSum: &currMaxSum), 0)\\n\\n        currMaxSum = max(currNode.val + leftSum + rightSum, currMaxSum)\\n        return max(leftSum, rightSum) + currNode.val\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 167952,
                "title": "clean-python-solution-o-n",
                "content": "Bottom up divider and conquer\\nAt each rode, it can form 3 tyes of path. \\n1st is node \\n2nd is left - node - right\\n3rd is left/right - node\\nOnce we get the max after comparsion, we return 1st or 3rd path sum to the upper level.\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\nclass Solution:\\n    res = -float(\\'inf\\')\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if root == None:\\n            return 0\\n        self.helper(root)\\n        return self.res\\n    \\n    def helper(self, root):\\n        if root == None:\\n            return 0\\n        leftMax = self.helper(root.left)\\n        rightMax = self.helper(root.right)\\n        tempPath = root.val + leftMax + rightMax\\n        sum = root.val + max(leftMax, rightMax, 0)\\n        self.res = max(sum, tempPath, self.res)\\n        return sum\\n",
                "solutionTags": [],
                "code": "Bottom up divider and conquer\\nAt each rode, it can form 3 tyes of path. \\n1st is node \\n2nd is left - node - right\\n3rd is left/right - node\\nOnce we get the max after comparsion, we return 1st or 3rd path sum to the upper level.\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\nclass Solution:\\n    res = -float(\\'inf\\')\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if root == None:\\n            return 0\\n        self.helper(root)\\n        return self.res\\n    \\n    def helper(self, root):\\n        if root == None:\\n            return 0\\n        leftMax = self.helper(root.left)\\n        rightMax = self.helper(root.right)\\n        tempPath = root.val + leftMax + rightMax\\n        sum = root.val + max(leftMax, rightMax, 0)\\n        self.res = max(sum, tempPath, self.res)\\n        return sum\\n",
                "codeTag": "Java"
            },
            {
                "id": 39810,
                "title": "12-lines-of-python-code-fast-and-easy-to-understand",
                "content": "    class Solution(object):\\n        def maxPathSum(self, root):\\n            def dfs(node):  # returns: max one side path sum, max path sum\\n                l = r = 0\\n                ls = rs = None\\n                if node.left:\\n                    l, ls = dfs(node.left)\\n                    l = max(l, 0)\\n                if node.right:\\n                    r, rs = dfs(node.right)\\n                    r = max(r, 0)\\n                return node.val + max(l, r), max(node.val + l + r, ls, rs)\\n            if root:\\n                return dfs(root)[1]\\n            return 0",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def maxPathSum(self, root):\\n            def dfs(node):  # returns: max one side path sum, max path sum\\n                l = r = 0\\n                ls = rs = None\\n                if node.left:\\n                    l, ls = dfs(node.left)\\n                    l = max(l, 0)\\n                if node.right:\\n                    r, rs = dfs(node.right)\\n                    r = max(r, 0)\\n                return node.val + max(l, r), max(node.val + l + r, ls, rs)\\n            if root:\\n                return dfs(root)[1]\\n            return 0",
                "codeTag": "Java"
            },
            {
                "id": 2899997,
                "title": "c-dfs-subtree-sum-method",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int subTreesum(TreeNode* root,int& mx)\\n    {\\n        if(root==NULL) return 0;\\n\\n        // we are using max function over here because as we know node can be negative , and we also know that when we take negatuve nodes\\n        // then they will reduce our path cost but we need to maximize it as much as possible\\n        // so whenever we got negative node then just take 0 instead of negative value\\n        int l = max(0,subTreesum(root->left,mx));\\n        int r = max(0,subTreesum(root->right,mx));\\n\\n        int curr = root->val+l+r;                             // curr node + left node + right node (path sum for curr node)\\n        cout<<curr<<\" \";\\n\\n        mx = max(mx,curr);                                    // took max out of all\\n\\n        return root->val+max(l,r);                            // max(l,r) means we will chose one path that will gave max path sum to us\\n    }\\n    int maxPathSum(TreeNode* root) \\n    {\\n        int mx = INT_MIN;\\n        subTreesum(root,mx);\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int subTreesum(TreeNode* root,int& mx)\\n    {\\n        if(root==NULL) return 0;\\n\\n        // we are using max function over here because as we know node can be negative , and we also know that when we take negatuve nodes\\n        // then they will reduce our path cost but we need to maximize it as much as possible\\n        // so whenever we got negative node then just take 0 instead of negative value\\n        int l = max(0,subTreesum(root->left,mx));\\n        int r = max(0,subTreesum(root->right,mx));\\n\\n        int curr = root->val+l+r;                             // curr node + left node + right node (path sum for curr node)\\n        cout<<curr<<\" \";\\n\\n        mx = max(mx,curr);                                    // took max out of all\\n\\n        return root->val+max(l,r);                            // max(l,r) means we will chose one path that will gave max path sum to us\\n    }\\n    int maxPathSum(TreeNode* root) \\n    {\\n        int mx = INT_MIN;\\n        subTreesum(root,mx);\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2632175,
                "title": "100-fastest-solution-with-explain-best-approach-easy-to-understand",
                "content": "**Read the below approach with dry run to understand the logic.**\\n\\n***Please upvote if you like it!!!!***\\n\\n**Approach:** \\n* A brute force approach would be to generate all paths and compare them. Generating all paths will be a time-costly activity therefore we need to look for something else.\\n\\n* We first need to define what is the maximum path sum through a given node (when that node is acting as the root node/curving point). At a given node with a value, if we find the max leftSumPath in the left-subtree and the max rightSumPath in the right subtree, then the maxPathSum through that node is value+(leftSumPath+rightSumPath).\\n\\n![image](https://assets.leetcode.com/users/images/8908909f-7acc-47b8-a570-2d6228fbd324_1664308086.3526118.png)\\n\\n* Now we can apply this formula at every node by doing a simple tree traversal and storing the maximum value (our answer) in a reference variable.\\n\\n* For our recursion to work, it is very important to understand what value we return from our function. In our recursive function, we find and compare the maxPathSum from a given node when it is the root/turning point of the path. But what we return is the maxPathSum of that same node when it is NOT the root/turning point of the path. To find the latter maxPath, we no longer have the liberty to consider both leftMaxPath and rightMaxPath, we will simply take the maximum of the two and it to the value of the node.\\n\\n![image](https://assets.leetcode.com/users/images/b1e861d5-d848-4f93-81d6-98aa8d162c6a_1664308132.2479436.png)\\n\\n**To summarize:**\\n\\n* Initialize a maxi variable to store our final answer.\\n* Do a simple tree traversal. At each node, find  recursively its leftMaxPath and its rightMaxPath.\\n* Calculate the maxPath through the node as val + (leftMaxPath + rightMaxPath) and update maxi accordingly.\\n* Return the maxPath when node is not the curving point as val + max(leftMaxPath, rightMaxPath).\\n\\n**Paper dry run:**\\n\\n![image](https://assets.leetcode.com/users/images/353e17b5-20b5-47f9-a434-ad2e83a01d7e_1664308186.004981.jpeg)\\n\\n**~Time Complexity: O(N).**\\n* **Reason:** We are doing a tree traversal.\\n\\n**~Space Complexity: O(N)**\\n* **Reason:** Space is needed for the recursion stack. In the worst case (skewed tree), space complexity can be O(N).\\n\\n**C++ Code**\\n```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root,int& mx){\\n        if(!root) return 0;\\n        \\n        int left=max(0,solve(root->left,mx));\\n        int right=max(0,solve(root->right,mx));\\n        int currVal=root->val;\\n        \\n        mx=max(mx,left+right+currVal);\\n        return max(left,right)+currVal;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int mx=INT_MIN;\\n        solve(root,mx);\\n        return mx;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root,int& mx){\\n        if(!root) return 0;\\n        \\n        int left=max(0,solve(root->left,mx));\\n        int right=max(0,solve(root->right,mx));\\n        int currVal=root->val;\\n        \\n        mx=max(mx,left+right+currVal);\\n        return max(left,right)+currVal;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int mx=INT_MIN;\\n        solve(root,mx);\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295418,
                "title": "java-solution-with-explanation",
                "content": "**Idea**\\nThe main part of the logic is same as https://leetcode.com/problems/maximum-subarray/description/\\nThree key points here. \\n1. Since the path doesn\\'t need to go through the root node, we need to try all nodes.\\n2. At the current node, let us say you have maxPathSum **from** the left node and maxPathSum **from** the right node, we can easily check what is the `max` so far. It should be either of those or the path connecting both.\\n3. We should return \"max path sum ending here\" to the caller, this will be either extending the path on left or right or just returning `curr` node.\\n\\nFurther explanation https://leetcode.com/problems/longest-univalue-path/discuss/130315/Java-Solution-With-Explanation\\n\\n---\\n\\n```\\nclass Solution {\\n    int max = -Integer.MAX_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return max;\\n    }\\n    private Integer helper(TreeNode curr){\\n        if(curr == null) return null;\\n        Integer l = helper(curr.left), r = helper(curr.right);\\n        int maxEndingHere = curr.val;\\n        if(l != null && r != null){\\n            maxEndingHere = Math.max(maxEndingHere, curr.val+l);\\n            maxEndingHere = Math.max(maxEndingHere, curr.val+r);\\n            max = Math.max(max, l+r+curr.val);\\n        }else if(l != null)\\n            maxEndingHere = Math.max(maxEndingHere, curr.val+l);\\n        else if(r != null)\\n            maxEndingHere = Math.max(maxEndingHere, curr.val+r);\\n        max = Math.max(max, maxEndingHere);\\n        return maxEndingHere;\\n    }\\n}\\n```\\n\\nShorter version of the same idea\\n```\\nclass Solution {\\n    int maxSumSoFar = -1001;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxSumSoFar;\\n    }\\n    \\n    private int helper(TreeNode curr){\\n        if(curr == null) return -1001;\\n        int l = helper(curr.left);\\n        int maxEndHere = Math.max(l+curr.val, curr.val);\\n        maxSumSoFar = Math.max(maxSumSoFar, maxEndHere);\\n        int r = helper(curr.right);\\n        maxEndHere = Math.max(r+curr.val, maxEndHere);\\n        maxSumSoFar = Math.max(maxSumSoFar, maxEndHere);\\n        maxSumSoFar = Math.max(maxSumSoFar, l+r+curr.val);\\n        \\n        return maxEndHere;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max = -Integer.MAX_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return max;\\n    }\\n    private Integer helper(TreeNode curr){\\n        if(curr == null) return null;\\n        Integer l = helper(curr.left), r = helper(curr.right);\\n        int maxEndingHere = curr.val;\\n        if(l != null && r != null){\\n            maxEndingHere = Math.max(maxEndingHere, curr.val+l);\\n            maxEndingHere = Math.max(maxEndingHere, curr.val+r);\\n            max = Math.max(max, l+r+curr.val);\\n        }else if(l != null)\\n            maxEndingHere = Math.max(maxEndingHere, curr.val+l);\\n        else if(r != null)\\n            maxEndingHere = Math.max(maxEndingHere, curr.val+r);\\n        max = Math.max(max, maxEndingHere);\\n        return maxEndingHere;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int maxSumSoFar = -1001;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxSumSoFar;\\n    }\\n    \\n    private int helper(TreeNode curr){\\n        if(curr == null) return -1001;\\n        int l = helper(curr.left);\\n        int maxEndHere = Math.max(l+curr.val, curr.val);\\n        maxSumSoFar = Math.max(maxSumSoFar, maxEndHere);\\n        int r = helper(curr.right);\\n        maxEndHere = Math.max(r+curr.val, maxEndHere);\\n        maxSumSoFar = Math.max(maxSumSoFar, maxEndHere);\\n        maxSumSoFar = Math.max(maxSumSoFar, l+r+curr.val);\\n        \\n        return maxEndHere;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39943,
                "title": "java-accepted-solution-with-post-order-traversal",
                "content": "Short Java solution involving a postorder visit of the tree. Complexity is O(n).\\n\\n\\n    public class Solution {\\n        \\n        int max;\\n        \\n        public int maxPathSum(TreeNode root) {\\n            \\n            if(root==null) return 0;\\n            \\n            //still check the result of the \"root subtree\"\\n            max = root.val;\\n            int tmp = visit(root);\\n            if(tmp > max) max = tmp;\\n            \\n            return max;\\n            \\n        }\\n        \\n        //recursive visit\\n        private int visit(TreeNode current){\\n        \\n            if(current==null) return 0;\\n        \\n            int l = visit(current.left);\\n            int r = visit(current.right);\\n            \\n            if(l<0) l=0;\\n            if(r<0) r=0;\\n            \\n            //check if current subtree is better than max\\n            int tmp = l+r+current.val;\\n            if(tmp>max) max = tmp;\\n            \\n            //return the best of the two ways to go down\\n            //if coming from top, cannot go both left and right\\n            //same if we come from down and want to go up, cannot go down again through other child\\n            if(l>r) {return l+current.val;}\\n            else {return r+current.val;}\\n            \\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n        \\n        int max;\\n        \\n        public int maxPathSum(TreeNode root) {\\n            \\n            if(root==null) return 0;\\n            \\n            //still check the result of the \"root subtree\"\\n            max = root.val;\\n            int tmp = visit(root);\\n            if(tmp > max) max = tmp;\\n            \\n            return max;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2899158,
                "title": "python-c-compute-left-right-partial-sums-with-dfs-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a *Depth First Search* approach to traverse the tree in order to compute left and right partial path sums for each node. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**.\\n****\\n\\n**Python.**\\n```\\nclass Solution:\\n    def maxPathSum(self, root, s = -inf) -> int:\\n        \\n        def dfs(n):                    # this recursive function \\n            nonlocal s                 # computes best partial path\\n            if not n : return 0        # sum starting from node \\'n\\':\\n            l = max(0, dfs(n.left))    # [1] compute left and right\\n            r = max(0, dfs(n.right))   #     partial path sums\\n            s = max(s, l + r + n.val)  # [2] compute full path sum\\n            return n.val + max(l, r)   # [3] choose best partial sum\\n\\n        dfs(root)\\n        return s\\n```\\n\\n**C++.**\\n```\\nclass Solution \\n{\\npublic:\\n    int maxPathSum(TreeNode* root, int s = INT_MIN) \\n    {\\n        function<int(TreeNode*)> dfs;\\n        dfs = [&](TreeNode* n) -> int\\n        {\\n            if (!n) return 0;\\n            int l = max(0, dfs(n->left));\\n            int r = max(0, dfs(n->right));\\n            s = max(s, l + r + n->val);\\n            return n->val + max(l, r);\\n        };\\n        \\n        dfs(root);\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxPathSum(self, root, s = -inf) -> int:\\n        \\n        def dfs(n):                    # this recursive function \\n            nonlocal s                 # computes best partial path\\n            if not n : return 0        # sum starting from node \\'n\\':\\n            l = max(0, dfs(n.left))    # [1] compute left and right\\n            r = max(0, dfs(n.right))   #     partial path sums\\n            s = max(s, l + r + n.val)  # [2] compute full path sum\\n            return n.val + max(l, r)   # [3] choose best partial sum\\n\\n        dfs(root)\\n        return s\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int maxPathSum(TreeNode* root, int s = INT_MIN) \\n    {\\n        function<int(TreeNode*)> dfs;\\n        dfs = [&](TreeNode* n) -> int\\n        {\\n            if (!n) return 0;\\n            int l = max(0, dfs(n->left));\\n            int r = max(0, dfs(n->right));\\n            s = max(s, l + r + n->val);\\n            return n->val + max(l, r);\\n        };\\n        \\n        dfs(root);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776579,
                "title": "easy-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    int maxi = INT_MIN;\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        depth(root);\\n        return maxi;\\n    }\\n    \\n    int depth(TreeNode* root){\\n        if(root == NULL) return 0;\\n        \\n        int lh = max(0,depth(root->left));\\n        int rh = max(0,depth(root->right));\\n        \\n        maxi = max(maxi , root->val + lh + rh);\\n        \\n        return root->val + max(lh,rh);\\n    }\\n};\\n```\\n\\nThought Process : \\n\\nFor any node in the Tree , we will consider the current node as the pivot point and add it\\'s left sub-tree and right sub-tree and the node itself. We will check this value with the maximum yet found and update if its larger.\\n\\nWhile backtracking we will set the node\\'s value = root->val + max(left-subtree sum , right-subtree sum) so that in case if parent nodes chose to take it we have the maximum possible sum present to the leaf node.\\n\\nIn case , we have negative values in the sub-trees or the path sum turns out to be negative ,  we will not include it in our path as we want maximum possible sum and mark the sum as 0 instead of -ve.",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int maxi = INT_MIN;\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        depth(root);\\n        return maxi;\\n    }\\n    \\n    int depth(TreeNode* root){\\n        if(root == NULL) return 0;\\n        \\n        int lh = max(0,depth(root->left));\\n        int rh = max(0,depth(root->right));\\n        \\n        maxi = max(maxi , root->val + lh + rh);\\n        \\n        return root->val + max(lh,rh);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332780,
                "title": "recursive-javascript-solution-with-comments",
                "content": "```javascript\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar maxPathSum = function(root) {\\n  var max = -Infinity // Initialize to a very small number to handle a path of negative values\\n  getMaxSum(root) // Call our recursive fn to start the program\\n  \\n  return max // Once we have popped out of our recursive calls, `max` contains our maximum path sum\\n  \\n  function getMaxSum(tree) {\\n    if (tree == null) { return 0 } // Termination condition\\n    \\n    const leftBranch = Math.max(0, getMaxSum(tree.left)) // calculate the root to leaf sum where root is the left node\\n    const rightBranch = Math.max(0, getMaxSum(tree.right)) // calculate the root to leaf sum where root is the right node\\n    const currentPath = leftBranch + tree.val + rightBranch  // Sum the path: left -> root -> right (leaf to leaf)\\n    \\n    max = Math.max(max, currentPath) // if the current path is greater than the previous value of `max`, update `max` to the current path sum\\n    return tree.val + Math.max(leftBranch, rightBranch)\\n  }\\n};\\n```\\n\\n---\\n\\nI hope others find my code and comments helpful.  Please add feedback if there is an error in my thinking.",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```javascript\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar maxPathSum = function(root) {\\n  var max = -Infinity // Initialize to a very small number to handle a path of negative values\\n  getMaxSum(root) // Call our recursive fn to start the program\\n  \\n  return max // Once we have popped out of our recursive calls, `max` contains our maximum path sum\\n  \\n  function getMaxSum(tree) {\\n    if (tree == null) { return 0 } // Termination condition\\n    \\n    const leftBranch = Math.max(0, getMaxSum(tree.left)) // calculate the root to leaf sum where root is the left node\\n    const rightBranch = Math.max(0, getMaxSum(tree.right)) // calculate the root to leaf sum where root is the right node\\n    const currentPath = leftBranch + tree.val + rightBranch  // Sum the path: left -> root -> right (leaf to leaf)\\n    \\n    max = Math.max(max, currentPath) // if the current path is greater than the previous value of `max`, update `max` to the current path sum\\n    return tree.val + Math.max(leftBranch, rightBranch)\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 209995,
                "title": "python-solution",
                "content": "Idea: Use DFS to compute for each node `v` the largest path sum ending with `v`. This can be done recursively using the formua `max_end_here = max(l_max, r_max)`, where `l_max = dfs(v.left)+v.val` if `dfs(v.left)` > 0, and `l_max = v.val` if `dfs(v.left) <= 0` (i.e., the left path ending with `v` that has the maximum sum consists of `v` only because the maximum path ending with `v.left` sums to a negative value). Similarly, `r_max = dfs(v.right)+v.val` if `dfs(v.right)` > 0, and `l_max = v.val` if `dfs(v.right) <= 0`. From `l_max` and `r_max`, we can compute the maximum path sum of a path that pass through `v` (not necessarily ending with `v`) by the formula `maximum = l_max+r_max-root.val`. We can then update the global variable `self.maximum = max(self.maximum, maximum)`, and return `max_end_here`. After running DFS from the root of the tree, `self.maximum` gives the desired maximum path sum.\\n\\nTime complexity: `O(n)`, space complexity: `O(h)`.\\n\\n```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return 0\\n            l_max = dfs(root.left)\\n            r_max = dfs(root.right)\\n            if l_max < 0:\\n                l_max = root.val\\n            else:\\n                l_max += root.val\\n            if r_max < 0:\\n                r_max = root.val\\n            else:\\n                r_max += root.val\\n            self.maximum = max(self.maximum, l_max+r_max-root.val)\\n            return max(l_max, r_max)\\n           \\n        self.maximum = -float(\\'inf\\')\\n        dfs(root)\\n        return self.maximum \\n```\\nWith a slight modification, we can eliminate the need for the variable `self.maximum`.\\n```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return 0, -float(\\'inf\\')\\n            l_max, res_l = dfs(root.left)\\n            r_max, res_r = dfs(root.right)\\n            if l_max < 0:\\n                l_max = root.val\\n            else:\\n                l_max += root.val\\n            if r_max < 0:\\n                r_max = root.val\\n            else:\\n                r_max += root.val\\n            maximum = l_max+r_max-root.val\\n            return max(l_max, r_max), max(maximum, res_l, res_r)\\n        \\n        res = dfs(root)[1]\\n        return res if res != -float(\\'inf\\') else 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return 0\\n            l_max = dfs(root.left)\\n            r_max = dfs(root.right)\\n            if l_max < 0:\\n                l_max = root.val\\n            else:\\n                l_max += root.val\\n            if r_max < 0:\\n                r_max = root.val\\n            else:\\n                r_max += root.val\\n            self.maximum = max(self.maximum, l_max+r_max-root.val)\\n            return max(l_max, r_max)\\n           \\n        self.maximum = -float(\\'inf\\')\\n        dfs(root)\\n        return self.maximum \\n```\n```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return 0, -float(\\'inf\\')\\n            l_max, res_l = dfs(root.left)\\n            r_max, res_r = dfs(root.right)\\n            if l_max < 0:\\n                l_max = root.val\\n            else:\\n                l_max += root.val\\n            if r_max < 0:\\n                r_max = root.val\\n            else:\\n                r_max += root.val\\n            maximum = l_max+r_max-root.val\\n            return max(l_max, r_max), max(maximum, res_l, res_r)\\n        \\n        res = dfs(root)[1]\\n        return res if res != -float(\\'inf\\') else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39879,
                "title": "my-ac-java-recursive-solution",
                "content": "max1 is the max value of the current node to pass to the upper level node. \\n\\nmax is the global max value that could be max1 or the sum of root and left max and right max \\n\\n    public class Solution {\\n    \\n    int max=Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        maxPathSumR(root);\\n        return max;\\n    }\\n    \\n    public int maxPathSumR(TreeNode root) {\\n        \\n        if(root==null) return 0;\\n        int left=maxPathSumR(root.left);\\n        int right=maxPathSumR(root.right);\\n        \\n        int max1 = Math.max(root.val,Math.max(root.val+left,root.val+right));\\n        max = Math.max(max,Math.max(max1,left+right+root.val));\\n        return max1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    int max=Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        maxPathSumR(root);\\n        return max;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3655975,
                "title": "easiest-c-code-2-easy-concepts-used",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int m=INT_MIN;\\n\\n    int find_max_sum(TreeNode* root){   //maxsum \\n        if(!root)\\n        return 0;\\n\\n        return root->val+max(0,max(find_max_sum(root->left),find_max_sum(root->right)));\\n    }\\n\\n    void solve(TreeNode* root){   //postorder\\n        if(root){\\n            solve(root->left);\\n            solve(root->right);\\n            int ls=find_max_sum(root->left);\\n            int rs=find_max_sum(root->right);\\n\\n            if(ls<0)\\n            ls=0;\\n            if(rs<0)\\n            rs=0;\\n\\n            m=max(ls+rs+root->val,m);\\n        }\\n    }\\n\\n    int maxPathSum(TreeNode* root) {\\n        solve(root);\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int m=INT_MIN;\\n\\n    int find_max_sum(TreeNode* root){   //maxsum \\n        if(!root)\\n        return 0;\\n\\n        return root->val+max(0,max(find_max_sum(root->left),find_max_sum(root->right)));\\n    }\\n\\n    void solve(TreeNode* root){   //postorder\\n        if(root){\\n            solve(root->left);\\n            solve(root->right);\\n            int ls=find_max_sum(root->left);\\n            int rs=find_max_sum(root->right);\\n\\n            if(ls<0)\\n            ls=0;\\n            if(rs<0)\\n            rs=0;\\n\\n            m=max(ls+rs+root->val,m);\\n        }\\n    }\\n\\n    int maxPathSum(TreeNode* root) {\\n        solve(root);\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763640,
                "title": "c-solution-easy-simple-code-comment-explaination",
                "content": "\\n\\n# Code\\n```\\n// If it helps plz upvote :)\\n\\nclass Solution {\\nprivate:\\n    int solve(TreeNode* root,int &ans){\\n        // base case\\n        if(root == NULL){\\n            return 0;\\n        }\\n\\n        int left = max(0,solve(root->left,ans));\\n        int right = max(0,solve(root->right,ans));\\n\\n        int curr = root->val + left + right;\\n        ans = max(curr,ans);\\n\\n        return root->val + max(left,right);\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        solve(root,ans);\\n\\n        return ans;\\n    }\\n};\\n\\n// If it helps plz upvote :)\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n// If it helps plz upvote :)\\n\\nclass Solution {\\nprivate:\\n    int solve(TreeNode* root,int &ans){\\n        // base case\\n        if(root == NULL){\\n            return 0;\\n        }\\n\\n        int left = max(0,solve(root->left,ans));\\n        int right = max(0,solve(root->right,ans));\\n\\n        int curr = root->val + left + right;\\n        ans = max(curr,ans);\\n\\n        return root->val + max(left,right);\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        solve(root,ans);\\n\\n        return ans;\\n    }\\n};\\n\\n// If it helps plz upvote :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827780,
                "title": "java-0-ms-faster-than-100-00-short-and-simple",
                "content": "```\\nclass Solution {\\n    int maxPath = 0;\\n    public int maxPathSum(TreeNode root) {\\n        maxPath = root.val;\\n        getMax(root);\\n        return maxPath;\\n    }\\n    \\n    private int getMax(TreeNode root) {\\n        if (root==null) {\\n            return 0;\\n        }\\n        int leftMax = getMax(root.left);\\n        int rightMax = getMax(root.right);\\n        leftMax = Math.max(leftMax, 0);\\n        rightMax = Math.max(rightMax, 0);\\n        maxPath = Math.max(maxPath, root.val + leftMax + rightMax);\\n        return root.val + Math.max(leftMax, rightMax);\\n    }\\n}\\n```\\n\\nPlease upvote if you like the solution..!!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int maxPath = 0;\\n    public int maxPathSum(TreeNode root) {\\n        maxPath = root.val;\\n        getMax(root);\\n        return maxPath;\\n    }\\n    \\n    private int getMax(TreeNode root) {\\n        if (root==null) {\\n            return 0;\\n        }\\n        int leftMax = getMax(root.left);\\n        int rightMax = getMax(root.right);\\n        leftMax = Math.max(leftMax, 0);\\n        rightMax = Math.max(rightMax, 0);\\n        maxPath = Math.max(maxPath, root.val + leftMax + rightMax);\\n        return root.val + Math.max(leftMax, rightMax);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187845,
                "title": "java-100-short-simple",
                "content": "```\\n\\nclass Solution {\\n    int ans = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        recurse(root);\\n        return ans;\\n    }\\n    \\n    public int recurse(TreeNode root) {\\n\\t\\t//base case\\n        if(root == null) return 0;\\n\\t\\t//postorder\\n        int left = recurse(root.left); \\n        int right = recurse(root.right);\\n        \\n\\t\\t//anything that is negative will never help maximize the path , so lets ignore it\\n        if(left < 0) left = 0;\\n        if(right < 0) right = 0;\\n\\t\\t\\n\\t\\t//worst case - root is only considered , if left and right are negatives\\n        int sum = root.val + left + right;\\n\\t\\t//update global answer\\n        ans = Math.max(sum, ans);\\n\\t\\t//from here send to parent what is max (it will be either curr+leftMax or curr+rightMax , as path in one directional)\\n        return Math.max(left + root.val, right + root.val);\\n    }\\n}\\n```\\n\\nIf the approach helps, please up-vote for reach.",
                "solutionTags": [
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    int ans = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        recurse(root);\\n        return ans;\\n    }\\n    \\n    public int recurse(TreeNode root) {\\n\\t\\t//base case\\n        if(root == null) return 0;\\n\\t\\t//postorder\\n        int left = recurse(root.left); \\n        int right = recurse(root.right);\\n        \\n\\t\\t//anything that is negative will never help maximize the path , so lets ignore it\\n        if(left < 0) left = 0;\\n        if(right < 0) right = 0;\\n\\t\\t\\n\\t\\t//worst case - root is only considered , if left and right are negatives\\n        int sum = root.val + left + right;\\n\\t\\t//update global answer\\n        ans = Math.max(sum, ans);\\n\\t\\t//from here send to parent what is max (it will be either curr+leftMax or curr+rightMax , as path in one directional)\\n        return Math.max(left + root.val, right + root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 602931,
                "title": "c-o-n-recursive-short-and-easy-to-understand-with-comment",
                "content": "```\\nclass Solution {\\n    int helper( TreeNode* node, int &maxSum ) {\\n        if( !node ) return 0;\\n        int left = 0, right = 0;\\n        if( node->left )  left = helper( node->left, maxSum );\\n        if( node->right ) right = helper( node->right, maxSum );\\n        \\n        // node+left or node+right or node\\n        int leftOrRightOrNode = max( node->val, node->val + max( left, right ) );\\n        // set maxSum to max of maxSum, node+left+right, node+left, node+right, node\\n        maxSum = max( maxSum, max( node->val + left + right, leftOrRightOrNode ) );        \\n        return leftOrRightOrNode;\\n    }\\n    \\npublic:\\n    int maxPathSum( TreeNode* root ) {\\n        int maxSum = INT_MIN;\\n        helper( root, maxSum );\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int helper( TreeNode* node, int &maxSum ) {\\n        if( !node ) return 0;\\n        int left = 0, right = 0;\\n        if( node->left )  left = helper( node->left, maxSum );\\n        if( node->right ) right = helper( node->right, maxSum );\\n        \\n        // node+left or node+right or node\\n        int leftOrRightOrNode = max( node->val, node->val + max( left, right ) );\\n        // set maxSum to max of maxSum, node+left+right, node+left, node+right, node\\n        maxSum = max( maxSum, max( node->val + left + right, leftOrRightOrNode ) );        \\n        return leftOrRightOrNode;\\n    }\\n    \\npublic:\\n    int maxPathSum( TreeNode* root ) {\\n        int maxSum = INT_MIN;\\n        helper( root, maxSum );\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 577860,
                "title": "python-beats-89-49-basic-recursion-structure-w-algorithm-explanation",
                "content": "Idea:\\n\\nEvery single node in the original tree could be the \"root\" of the max path.\\nFor every one of these \"roots,\" you could add the stuff on the left, the stuff on the right, neither, or both to get the max path.\\n* What is this \"stuff\"? It\\'s the max path of the subtree created by following node.left or node.right.\\n\\nAt the end, we return the max of EITHER just the root, the root and the max path left subtree, or the root and the max path right subtree.\\n* Why not root and both left and right subtree? If the root ISN\\'T the actual root, it\\'ll be in either the left or right subtree of the actual root. Since we want a single path, the path can\\'t \"split\", so it needs to take exactly one \"road\", namely left or right.\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.maxSum = float(\\'-inf\\')\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        def traverse(root):\\n            if root:\\n                left = traverse(root.left)\\n                right = traverse(root.right)\\n                self.maxSum = max(self.maxSum,root.val, root.val + left, root.val + right, root.val + left + right)\\n                return max(root.val,root.val + left,root.val + right)\\n            else:\\n                return 0\\n        traverse(root)\\n        return self.maxSum\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.maxSum = float(\\'-inf\\')\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        def traverse(root):\\n            if root:\\n                left = traverse(root.left)\\n                right = traverse(root.right)\\n                self.maxSum = max(self.maxSum,root.val, root.val + left, root.val + right, root.val + left + right)\\n                return max(root.val,root.val + left,root.val + right)\\n            else:\\n                return 0\\n        traverse(root)\\n        return self.maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254281,
                "title": "javascript",
                "content": "```\\nvar maxPathSum = function(root) {\\n    let maxPathSumNum = -Infinity;\\n    \\n    const maxPathSumRec = function(node){\\n        if(!node){\\n            return 0;\\n        }\\n        \\n        let leftMax = Math.max(maxPathSumRec(node.left), 0);\\n        let rightMax = Math.max(maxPathSumRec(node.right), 0);\\n        maxPathSumNum = Math.max(maxPathSumNum, leftMax + rightMax + node.val);\\n        return Math.max(leftMax, rightMax) + node.val;\\n    };\\n    \\n    maxPathSumRec(root);\\n    return maxPathSumNum;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxPathSum = function(root) {\\n    let maxPathSumNum = -Infinity;\\n    \\n    const maxPathSumRec = function(node){\\n        if(!node){\\n            return 0;\\n        }\\n        \\n        let leftMax = Math.max(maxPathSumRec(node.left), 0);\\n        let rightMax = Math.max(maxPathSumRec(node.right), 0);\\n        maxPathSumNum = Math.max(maxPathSumNum, leftMax + rightMax + node.val);\\n        return Math.max(leftMax, rightMax) + node.val;\\n    };\\n    \\n    maxPathSumRec(root);\\n    return maxPathSumNum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 232373,
                "title": "postorder-iterative-solution-python",
                "content": "The general idea is that we can go through the nodes in post order traversal and cache the maximum path from a node\\'s subtree to itself (the reason is that we can obtain the left_max_path and right_max_path in O(1) time).\\n\\n```\\nclass Solution:\\n    def maxPathSum(self, root: \\'TreeNode\\') -> \\'int\\':\\n        def post_order(node):\\n            cur = node\\n            stack = []\\n            res = []\\n            while cur or stack:\\n                if cur:\\n                    stack.append(cur)\\n                    res.append(cur)\\n                    cur = cur.right\\n                else:\\n                    cur = stack.pop()\\n                    cur = cur.left\\n            return res[::-1]\\n        \\n        res = -float(\\'inf\\')\\n        nodes = post_order(root)\\n        path_until_node = {None: 0}\\n        for node in nodes:\\n            left_max_path = max(0, path_until_node[node.left])\\n            right_max_path = max(0, path_until_node[node.right])\\n            res = max(res, left_max_path + right_max_path + node.val)\\n            path_until_node[node] = max(left_max_path, right_max_path) + node.val\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def maxPathSum(self, root: \\'TreeNode\\') -> \\'int\\':\\n        def post_order(node):\\n            cur = node\\n            stack = []\\n            res = []\\n            while cur or stack:\\n                if cur:\\n                    stack.append(cur)\\n                    res.append(cur)\\n                    cur = cur.right\\n                else:\\n                    cur = stack.pop()\\n                    cur = cur.left\\n            return res[::-1]\\n        \\n        res = -float(\\'inf\\')\\n        nodes = post_order(root)\\n        path_until_node = {None: 0}\\n        for node in nodes:\\n            left_max_path = max(0, path_until_node[node.left])\\n            right_max_path = max(0, path_until_node[node.right])\\n            res = max(res, left_max_path + right_max_path + node.val)\\n            path_until_node[node] = max(left_max_path, right_max_path) + node.val\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 171807,
                "title": "python-dfs",
                "content": "# 124. Binary Tree Maximum Path Sum\\n[\\u6B64\\u9898\\u6536\\u5F55\\u5728Github](https://github.com/yuzhoujr/leetcode/issues/33)\\n\\n1. \\u5206\\u5236\\u5230\\u5E95\\u90E8\\uFF0C\\u5728\\u8FD4\\u56DE\\u7684\\u65F6\\u5019\\u4F20\\u5165\\u5DE6\\u53F3\\u4EFB\\u610F\\u4E00\\u904D\\u6700\\u5927\\u503C\\u52A0\\u4E0A\\u76EE\\u524D`root.val`:\\n`cur = max(left, right) + root.val`\\n\\u8FD9\\u79CD\\u60C5\\u51B5\\u5904\\u7406\\u4E86\\u4ECERoot\\u5230\\u5DE6\\u53F3\\u4EFB\\u610F\\u4E00\\u8FB9\\u7684\\u6700\\u5927\\u503C\\uFF0C\\u4E5F\\u5C31\\u662F `root.val + left` \\u548C `root.val + right`\\n2. \\u8FD8\\u6709\\u4E00\\u79CD\\u60C5\\u51B5\\u5C31\\u662F\\u5F53\\u6700\\u5927\\u503C = `root.val + left + right`\\uFF0C \\u6211\\u4EEC\\u5728\\u653E\\u5165global\\u53D8\\u91CF\\u7684\\u65F6\\u5019\\u4F55\\u5176\\u6BD4\\u8F83\\u3002\\n3. \\u5BF9\\u4E8E\\u6700\\u5E95\\u90E8\\u53F6\\u5B50\\u8282\\u70B9\\u4F20\\u4E0A\\u6765\\u7684\\u503C\\uFF0C\\u6211\\u4EEC\\u5C06\\u5176\\u8BBE\\u7F6E\\u62100: `return cur if cur > 0 else 0`\\n\\n```python\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        self.res = - float(\\'inf\\')\\n        self.dfs(root)\\n        return self.res\\n\\n    \\n    def dfs(self, root):\\n        if not root: return 0\\n        left = self.dfs(root.left)\\n        right = self.dfs(root.right)\\n        self.res = max(self.res, left + right + root.val)\\n        cur = max(left, right) + root.val\\n        return cur if cur > 0 else 0\\n```\\n<br>",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        self.res = - float(\\'inf\\')\\n        self.dfs(root)\\n        return self.res\\n\\n    \\n    def dfs(self, root):\\n        if not root: return 0\\n        left = self.dfs(root.left)\\n        right = self.dfs(root.right)\\n        self.res = max(self.res, left + right + root.val)\\n        cur = max(left, right) + root.val\\n        return cur if cur > 0 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39813,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Binary Tree Maximum Path Sum** https://leetcode.com/problems/binary-tree-maximum-path-sum/\\n\\n**Brute Force Solution: O(N^2)**\\n* Assume we have nodes numbered 1 to N\\n* sum(i) = Maximum sum of a path containing node(i). Clearly the solution of the problem is max(sum(1), sum(2), ...., sum(N))\\n* Now what is the maximum sum of a path containing a particular node(i)?\\n* lresult[0]: maximum path sum starting at node(i).left\\n* rresult[0]: maximum path sum starting at node(i).right\\n* sum(i) = max(lresult[0], 0) + max(rresult[0], 0) + node(i).val\\n* Why do we do max(lresult[0], 0)? sum(i) must contain node(i).val. We will add lresult[0] or rresult[0] only when they help increase sum(i). We will ignore lresult[0] or rresult[0] if they are negative.\\n* We use pre-order traversal to iterate over the nodes and compute sum(i) for each node(i).\\n* Time complexity for sum(i) is O(N). Total time complexity is O(N^2)\\n* Space complexity is O(N)\\n```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        self.answer = float('-inf')\\n        self.helper(root)\\n        return self.answer\\n    \\n    def max_path_sum(self, root, so_far, result):\\n        if root is None:\\n            return\\n        result[0] = max(result[0], so_far + root.val)\\n        self.max_path_sum(root.left, so_far + root.val, result)\\n        self.max_path_sum(root.right, so_far + root.val, result)\\n        return\\n    \\n    def helper(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if root == None:\\n            return\\n        lresult, rresult = [float('-inf')], [float('-inf')]\\n        self.max_path_sum(root.left, 0, lresult) # Find maximum path sum starting from root.left\\n        self.max_path_sum(root.right, 0, rresult) # Find maximum path sum starting from root.right\\n        self.answer = max(max(lresult[0], 0) + max(rresult[0], 0) + root.val, self.answer)\\n        self.helper(root.left)\\n        self.helper(root.right)        \\n        return\\n```\\n**Bottom Up Optimized Solution: O(N)**\\n* Bottom up template uses post-order traversal and usually returns two items. To visualize this algorithm, always start with bottom up picture returning 1 or 2 values\\n* In this algorithm, we can use post-order traversal and return the maximum sum in the subtree starting from the root. \\n* We call it lresult and rresult for left and right subtree\\n```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        self.max_so_far = float('-inf')\\n        self.helper(root) # Maximum sum starting from root\\n        return self.max_so_far\\n        \\n    def helper(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if root == None:\\n            return 0\\n        lresult = self.helper(root.left) # Maximum sum starting from root.left\\n        rresult = self.helper(root.right) # Maximum sum starting from root.left\\n        self.max_so_far = max(max(lresult, 0) + max(rresult, 0) + root.val, self.max_so_far)\\n        return max(lresult, rresult, 0) + root.val # Return maximum sum starting from root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        self.answer = float('-inf')\\n        self.helper(root)\\n        return self.answer\\n    \\n    def max_path_sum(self, root, so_far, result):\\n        if root is None:\\n            return\\n        result[0] = max(result[0], so_far + root.val)\\n        self.max_path_sum(root.left, so_far + root.val, result)\\n        self.max_path_sum(root.right, so_far + root.val, result)\\n        return\\n    \\n    def helper(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if root == None:\\n            return\\n        lresult, rresult = [float('-inf')], [float('-inf')]\\n        self.max_path_sum(root.left, 0, lresult) # Find maximum path sum starting from root.left\\n        self.max_path_sum(root.right, 0, rresult) # Find maximum path sum starting from root.right\\n        self.answer = max(max(lresult[0], 0) + max(rresult[0], 0) + root.val, self.answer)\\n        self.helper(root.left)\\n        self.helper(root.right)        \\n        return\\n```\n```\\nclass Solution(object):\\n    def maxPathSum(self, root):\\n        self.max_so_far = float('-inf')\\n        self.helper(root) # Maximum sum starting from root\\n        return self.max_so_far\\n        \\n    def helper(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if root == None:\\n            return 0\\n        lresult = self.helper(root.left) # Maximum sum starting from root.left\\n        rresult = self.helper(root.right) # Maximum sum starting from root.left\\n        self.max_so_far = max(max(lresult, 0) + max(rresult, 0) + root.val, self.max_so_far)\\n        return max(lresult, rresult, 0) + root.val # Return maximum sum starting from root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899144,
                "title": "kotlin-clean-and-efficient-less-than-15-lines",
                "content": "```\\nclass Solution {\\n    fun maxPathSum(root: TreeNode?): Int {\\n        var bestSum = Integer.MIN_VALUE\\n        \\n        fun recurse(node: TreeNode?): Int {\\n            if (node == null) return 0\\n            val left = Math.max(recurse(node.left), 0)\\n            val right =  Math.max(recurse(node.right), 0)\\n            bestSum = Math.max(bestSum, left + right + node.`val`)\\n            return node.`val` + Math.max(left, right)\\n        }\\n        recurse(root)\\n\\n        return bestSum\\n    }\\n}\\n```\\n\\nworst case time: O(n) the solution traverses all nodes\\nworst case space: O(n) the call stack could include the number of nodes",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maxPathSum(root: TreeNode?): Int {\\n        var bestSum = Integer.MIN_VALUE\\n        \\n        fun recurse(node: TreeNode?): Int {\\n            if (node == null) return 0\\n            val left = Math.max(recurse(node.left), 0)\\n            val right =  Math.max(recurse(node.right), 0)\\n            bestSum = Math.max(bestSum, left + right + node.`val`)\\n            return node.`val` + Math.max(left, right)\\n        }\\n        recurse(root)\\n\\n        return bestSum\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305158,
                "title": "implementing-using-pair-class-c-o-n-easy-to-understand-15-line-code",
                "content": "The idea is to implement a pair class to store the answer of each node as well as the maximum sum including that node in the path(**NOTE: this is different from the actual answer because it is not necessary that the node is part of our answer**) this helps us to find maximum sum including that node in O(1) time.\\n```\\nclass Solution {\\npublic:\\n    pair<int,int> helper(TreeNode* root){\\n        if(root==NULL){\\n            pair<int,int> p={0,INT_MIN};\\n            return p;\\n        }\\n        pair<int,int> left=helper(root->left);\\n        pair<int,int> right=helper(root->right);\\n        int include=max(max(root->val,root->val+left.first+right.first),max(root->val+left.first,root->val+right.first)); \\n        int notinclude=max(left.second,right.second);\\n        pair<int,int>ans;\\n        ans.second=max(include,notinclude);\\n        ans.first=max(max(left.first,right.first)+root->val,root->val);\\n        return ans;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        return helper(root).second;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    pair<int,int> helper(TreeNode* root){\\n        if(root==NULL){\\n            pair<int,int> p={0,INT_MIN}",
                "codeTag": "Java"
            },
            {
                "id": 2304217,
                "title": "c-easy-short-and-fastest",
                "content": "```\\nclass Solution {\\nprivate:\\n    int helper(TreeNode* root, int&ans){\\n\\t\\t// Escape condition\\n        if(!root) return 0;\\n        \\n\\t\\t// DFS\\n\\t\\tint left = max(0, helper(root->left,ans));\\n        int right = max(0, helper(root->right,ans));\\n        \\n\\t\\t// There is also possibility left+parent+right > ans\\n\\t\\tans = max(ans, root->val + left + right);\\n\\t\\t\\n\\t\\t// Inorder to make the path continous we can send either right or the left side,\\n\\t\\t// So we will send the maximum side\\n        return root->val + max(left, right);\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n\\t\\t// The answer\\n        int ans = INT_MIN;\\n        if(!root) return 0;\\n        \\n\\t\\t// Recurssive function\\n\\t\\thelper(root, ans);\\n        return ans;\\n    }\\n};\\n```\\nUpvote if you find it useful. \\uD83D\\uDE4C",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int helper(TreeNode* root, int&ans){\\n\\t\\t// Escape condition\\n        if(!root) return 0;\\n        \\n\\t\\t// DFS\\n\\t\\tint left = max(0, helper(root->left,ans));\\n        int right = max(0, helper(root->right,ans));\\n        \\n\\t\\t// There is also possibility left+parent+right > ans\\n\\t\\tans = max(ans, root->val + left + right);\\n\\t\\t\\n\\t\\t// Inorder to make the path continous we can send either right or the left side,\\n\\t\\t// So we will send the maximum side\\n        return root->val + max(left, right);\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n\\t\\t// The answer\\n        int ans = INT_MIN;\\n        if(!root) return 0;\\n        \\n\\t\\t// Recurssive function\\n\\t\\thelper(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335817,
                "title": "recursive-solution-c-and-java-0-ms",
                "content": "We need to find the maximum path sum, We can do it by simply comparing the sum of the root* along with its leftSubtree sum or rightSubtree sum and returning the max. But, there is a condition left that we still need to fulfill. \\n   Suppose, what is the maximum sum in a path -> sum of all the nodes present in the path but what if one or two nodes are negative what would we do in this case, as we need to find the maximum sum we will not count them and will take zero to obtain the maximum result.\\n  \\n ```\\n  class Solution {\\n  public:  \\n  \\n    int sum = INT_MIN;\\n   \\n    int helper(TreeNode* root)\\n    {\\n        if(!root)  return 0;\\n        \\n        int leftSum = max(0,helper(root->left));\\n        int rightSum = max(0,helper(root->right));\\n        \\n        sum = max(sum,leftSum + rightSum + root->val);\\n        \\n        return max(leftSum,rightSum) + root->val;   \\n    }\\n    \\n    int maxPathSum(TreeNode* root) \\n    {\\n        helper(root);\\n        \\n        return sum;\\n    }\\n};\\n```\\n\\nwe didn\\'t  include current root->val + root-> left + root->right in the last line while returning value because, for current root\\'s parent root, if we were to include root->val + root->left + root->right in the maxPathSum, it would violate the principle that we can only traverse each node once.\\nWe are returning the path sum not the subtree sum.\\n\\nsame code in Java\\n\\n```\\nclass Solution {\\n    int sum = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        sum = Integer.MIN_VALUE;\\n        \\n        helper(root);\\n        \\n        return sum;\\n    }\\n    \\n    public int helper(TreeNode root)\\n    {\\n        if(root == null)\\n            return 0;\\n        \\n        int leftSum = Math.max(0,helper(root.left));\\n        int rightSum = Math.max(0,helper(root.right));\\n        \\n        sum = Math.max(sum,leftSum + rightSum + root.val);\\n        \\n        return Math.max(leftSum,rightSum) + root.val;  \\n    }\\n}\\n```\\n\\nPS : I am learning and trying to help the community ! Still not sure if my solution is the best one, even after 0ms. Feel free to give your suggestions or correct me in the comments. Thanks for reading.\\uD83D\\uDE43\\n",
                "solutionTags": [],
                "code": "```\\n  class Solution {\\n  public:  \\n  \\n    int sum = INT_MIN;\\n   \\n    int helper(TreeNode* root)\\n    {\\n        if(!root)  return 0;\\n        \\n        int leftSum = max(0,helper(root->left));\\n        int rightSum = max(0,helper(root->right));\\n        \\n        sum = max(sum,leftSum + rightSum + root->val);\\n        \\n        return max(leftSum,rightSum) + root->val;   \\n    }\\n    \\n    int maxPathSum(TreeNode* root) \\n    {\\n        helper(root);\\n        \\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int sum = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        sum = Integer.MIN_VALUE;\\n        \\n        helper(root);\\n        \\n        return sum;\\n    }\\n    \\n    public int helper(TreeNode root)\\n    {\\n        if(root == null)\\n            return 0;\\n        \\n        int leftSum = Math.max(0,helper(root.left));\\n        int rightSum = Math.max(0,helper(root.right));\\n        \\n        sum = Math.max(sum,leftSum + rightSum + root.val);\\n        \\n        return Math.max(leftSum,rightSum) + root.val;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258344,
                "title": "c-concise-o-n-solution-easy",
                "content": "```\\n int sum(TreeNode* root, int& res)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        \\n        int l = sum(root -> left, res);\\n        int r = sum(root -> right, res);\\n        \\n        int temp = max(max(l, r) + root -> val, root -> val);\\n        int ans = max(temp, l + r + root -> val);\\n        res =  max(res, ans);\\n        \\n        return temp;\\n    }\\n    \\n    int maxPathSum(TreeNode* root) \\n    {\\n        int res = INT_MIN;\\n        sum(root, res);\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n int sum(TreeNode* root, int& res)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        \\n        int l = sum(root -> left, res);\\n        int r = sum(root -> right, res);\\n        \\n        int temp = max(max(l, r) + root -> val, root -> val);\\n        int ans = max(temp, l + r + root -> val);\\n        res =  max(res, ans);\\n        \\n        return temp;\\n    }\\n    \\n    int maxPathSum(TreeNode* root) \\n    {\\n        int res = INT_MIN;\\n        sum(root, res);\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1113179,
                "title": "python-recursion-solution",
                "content": "See docstring for algorithm\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        # set initial max to negative to system max size\\n        self.max_sum = -sys.maxsize\\n        \\n    def maxPathSum(self, root: TreeNode) -> int:\\n        def get_max(node):\\n            \"\"\"Search for max path for given node and update global max \\n            \\n            - Find max of these 4 cases:\\n            -- node \\n            -- node + left \\n            -- node + right \\n            -- node + left + right \\n            \\n            for left and right calculation use recursion \\n            \\n            - Update global max with this value \\n            \\n            Return max of only first 3 cases - becasue 4th case marks top of the tree \\n            If both children of node are added - then it can\\'t be connected to caller\\n            \\n            :param node: current node to calculate\\n            :type node: TreeNode\\n            :returns: max path that can be continued\\n            :rype: int\\n            \"\"\"\\n            if not node:\\n                return 0 \\n\\n            \\n            left = get_max(node.left)\\n            right = get_max(node.right)\\n            \\n            cases = [\\n                    node.val,                      # when node is the best case\\n                    node.val + left,               # when left path is chosen \\n                    node.val + right,              # when right parth is chosen\\n                    node.val + left + right,       # top of the tree case - this cannot be part of any other path\\n                ]\\n            \\n            self.max_sum = max(self.max_sum, max(cases))\\n                       \\n            return max(cases[0:3])\\n\\n        get_max(root)\\n        return self.max_sum\\n        \\n",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "See docstring for algorithm\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        # set initial max to negative to system max size\\n        self.max_sum = -sys.maxsize\\n        \\n    def maxPathSum(self, root: TreeNode) -> int:\\n        def get_max(node):\\n            \"\"\"Search for max path for given node and update global max \\n            \\n            - Find max of these 4 cases:\\n            -- node \\n            -- node + left \\n            -- node + right \\n            -- node + left + right \\n            \\n            for left and right calculation use recursion \\n            \\n            - Update global max with this value \\n            \\n            Return max of only first 3 cases - becasue 4th case marks top of the tree \\n            If both children of node are added - then it can\\'t be connected to caller\\n            \\n            :param node: current node to calculate\\n            :type node: TreeNode\\n            :returns: max path that can be continued\\n            :rype: int\\n            \"\"\"\\n            if not node:\\n                return 0 \\n\\n            \\n            left = get_max(node.left)\\n            right = get_max(node.right)\\n            \\n            cases = [\\n                    node.val,                      # when node is the best case\\n                    node.val + left,               # when left path is chosen \\n                    node.val + right,              # when right parth is chosen\\n                    node.val + left + right,       # top of the tree case - this cannot be part of any other path\\n                ]\\n            \\n            self.max_sum = max(self.max_sum, max(cases))\\n                       \\n            return max(cases[0:3])\\n\\n        get_max(root)\\n        return self.max_sum\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 592138,
                "title": "clean-and-simple-c-solution-96-57-faster-100-memory",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int max_sum = root->val;\\n        getMaxSumPath(root, &max_sum);\\n        return max_sum;\\n    }\\nprivate:\\n    int getMaxSumPath(TreeNode* node, int* max_sum) {\\n        if (node == nullptr) return 0;\\n        auto l = max(getMaxSumPath(node->left, max_sum), 0);\\n        auto r = max(getMaxSumPath(node->right, max_sum), 0);\\n        *max_sum = max(*max_sum, node->val + l + r);\\n        return node->val + max(l, r);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int max_sum = root->val;\\n        getMaxSumPath(root, &max_sum);\\n        return max_sum;\\n    }\\nprivate:\\n    int getMaxSumPath(TreeNode* node, int* max_sum) {\\n        if (node == nullptr) return 0;\\n        auto l = max(getMaxSumPath(node->left, max_sum), 0);\\n        auto r = max(getMaxSumPath(node->right, max_sum), 0);\\n        *max_sum = max(*max_sum, node->val + l + r);\\n        return node->val + max(l, r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422797,
                "title": "javascript-solution-w-explanation",
                "content": "### The Idea\\n1. Use DFS\\n2. If a branch\\'s maximum sum is negative, we will never consider that route so we set it to 0\\n3. Right before we backtrack, calculate the global maximum sum\\n4. For the backtrack value, we return the current route\\'s max sum \\n``` \\nvar maxPathSum = function(root) {\\n    let max = -Infinity;\\n    var recur = function(node) {\\n        if (node == null) return 0;\\n        let left = Math.max(0, recur(node.left)); // negative sums will just be ignored\\n        let right = Math.max(0, recur(node.right));\\n        max = Math.max(left + right + node.val, max); // calculate the global max\\n        return Math.max(left, right)+node.val;  // return current route\\'s best sum\\n    }\\n    recur(root)\\n    return max\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` \\nvar maxPathSum = function(root) {\\n    let max = -Infinity;\\n    var recur = function(node) {\\n        if (node == null) return 0;\\n        let left = Math.max(0, recur(node.left)); // negative sums will just be ignored\\n        let right = Math.max(0, recur(node.right));\\n        max = Math.max(left + right + node.val, max); // calculate the global max\\n        return Math.max(left, right)+node.val;  // return current route\\'s best sum\\n    }\\n    recur(root)\\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 213322,
                "title": "javascript-dfs-o-n-100",
                "content": "```\\nvar maxPathSum = function(root) {\\n    \\n    let max = -Infinity;\\n    \\n    function dfs(node) {\\n        if(!node) return 0;\\n        \\n        let left = dfs(node.left);\\n        let right = dfs(node.right);\\n        \\n        max = Math.max(\\n            left + right + node.val,\\n            left + node.val,\\n            right + node.val,\\n            node.val,\\n            max\\n        );\\n        \\n        return Math.max(left + node.val, right + node.val, node.val);\\n        \\n    }\\n    \\n    dfs(root);\\n    \\n    return max;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxPathSum = function(root) {\\n    \\n    let max = -Infinity;\\n    \\n    function dfs(node) {\\n        if(!node) return 0;\\n        \\n        let left = dfs(node.left);\\n        let right = dfs(node.right);\\n        \\n        max = Math.max(\\n            left + right + node.val,\\n            left + node.val,\\n            right + node.val,\\n            node.val,\\n            max\\n        );\\n        \\n        return Math.max(left + node.val, right + node.val, node.val);\\n        \\n    }\\n    \\n    dfs(root);\\n    \\n    return max;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189725,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    int Max = Int32.MinValue;\\n    \\n    public int MaxPathSum(TreeNode root) {\\n            Helper(root);\\n            return Max;\\n    }\\n    \\n    private int Helper(TreeNode root)\\n    {\\n        if (root == null)\\n            return 0;\\n\\n        int leftMax = Helper(root.left),\\n            rightMax = Helper(root.right),\\n            currentMax = 0;\\n\\n        currentMax = Math.Max(currentMax, Math.Max(leftMax + root.val, rightMax + root.val));\\n        Max = Math.Max(Max, leftMax + root.val + rightMax);\\n\\n        return currentMax;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int Max = Int32.MinValue;\\n    \\n    public int MaxPathSum(TreeNode root) {\\n            Helper(root);\\n            return Max;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 39872,
                "title": "ac-java-solution-very-simple-dfs",
                "content": "    private int maxPath = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        traverse(root);\\n        return maxPath;\\n    }\\n    \\n    public int traverse(TreeNode root){\\n        if(root == null)    return 0;\\n        \\n        int left = traverse(root.left) + root.val;\\n        int right = traverse(root.right) + root.val;\\n\\n        int tmpMax = Math.max(left, Math.max(right, root.val));\\n        maxPath = Math.max(maxPath, Math.max(tmpMax, left + right - root.val));\\n        return tmpMax;\\n    }",
                "solutionTags": [],
                "code": "    private int maxPath = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        traverse(root);\\n        return maxPath;\\n    }\\n    \\n    public int traverse(TreeNode root){\\n        if(root == null)    return 0;\\n        \\n        int left = traverse(root.left) + root.val;\\n        int right = traverse(root.right) + root.val;\\n\\n        int tmpMax = Math.max(left, Math.max(right, root.val));\\n        maxPath = Math.max(maxPath, Math.max(tmpMax, left + right - root.val));\\n        return tmpMax;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 39940,
                "title": "accepted-java-code-19-lines-simple-and-effective",
                "content": "The thought is bottom-up, first we need to get left and right tree max value and make sure that they need to be larger than 0. Next add them to current node value, compare to the total max value and update the total max value. Finally return current value with one of left or right max value (>=0).\\n    \\n    public class Solution {\\n            int max = 0;\\n            public int maxPathSum(TreeNode root) {\\n                if(root == null) return 0;\\n                max = root.val;\\n                helper(root);\\n                return max;\\n            }\\n            public int helper(TreeNode node)\\n            {\\n                if(node == null) return 0;\\n                int left = helper(node.left);\\n                int right = helper(node.right);\\n                left = left > 0 ? left : 0;\\n                right = right > 0 ? right : 0;\\n                int curMax = node.val + left + right;\\n                max = Math.max(max, curMax);\\n                return node.val + Math.max(left, right);\\n            }\\n        }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n            int max = 0;\\n            public int maxPathSum(TreeNode root) {\\n                if(root == null) return 0;\\n                max = root.val;\\n                helper(root);\\n                return max;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3587990,
                "title": "c-recursion-most-optimized-very-simple",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root,int &ans){\\n        if(root == NULL)return 0;\\n        int l = solve(root->left,ans);\\n        int r = solve(root->right,ans);\\n        ans = max({ans,root->val,r+root->val,l+root->val,l+r+root->val});\\n        return max({max({l,r})+root->val,root->val,0});\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root,int &ans){\\n        if(root == NULL)return 0;\\n        int l = solve(root->left,ans);\\n        int r = solve(root->right,ans);\\n        ans = max({ans,root->val,r+root->val,l+root->val,l+r+root->val});\\n        return max({max({l,r})+root->val,root->val,0});\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425731,
                "title": "simple-c-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int helper(TreeNode* root,int &maxi){\\n        if(root == NULL)\\n            return 0;\\n\\n        int ls = max(0,helper(root->left,maxi));\\n        int rs = max(0,helper(root->right,maxi));\\n\\n        maxi = max(maxi,(ls + root->val + rs));\\n        return (root->val + max(ls,rs));\\n    }\\n\\n    int maxPathSum(TreeNode* root) {\\n        int maxi = INT_MIN;\\n        helper(root,maxi);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int helper(TreeNode* root,int &maxi){\\n        if(root == NULL)\\n            return 0;\\n\\n        int ls = max(0,helper(root->left,maxi));\\n        int rs = max(0,helper(root->right,maxi));\\n\\n        maxi = max(maxi,(ls + root->val + rs));\\n        return (root->val + max(ls,rs));\\n    }\\n\\n    int maxPathSum(TreeNode* root) {\\n        int maxi = INT_MIN;\\n        helper(root,maxi);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221814,
                "title": "best-o-n-solution",
                "content": "# Approach\\nBest Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        findMaxPathSum(root, ans);\\n        return ans;\\n    }\\nprivate:\\n    int findMaxPathSum(TreeNode* root, int& ans) {\\n        if (root == NULL)\\n            return 0;\\n        int leftSum = max (0, findMaxPathSum(root->left, ans));    \\n        int rightSum = max (0, findMaxPathSum(root->right, ans)); \\n        ans = max (ans, root->val + leftSum + rightSum);\\n        return root->val + max (leftSum, rightSum);   \\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        findMaxPathSum(root, ans);\\n        return ans;\\n    }\\nprivate:\\n    int findMaxPathSum(TreeNode* root, int& ans) {\\n        if (root == NULL)\\n            return 0;\\n        int leftSum = max (0, findMaxPathSum(root->left, ans));    \\n        int rightSum = max (0, findMaxPathSum(root->right, ans)); \\n        ans = max (ans, root->val + leftSum + rightSum);\\n        return root->val + max (leftSum, rightSum);   \\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195903,
                "title": "beats-92-69-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution also uses a recursive approach, but instead of keeping track of the maximum path sum so far in a global variable, it passes it down as a parameter to the recursive function. This allows for a cleaner implementation of the DFS function, as it only needs to return the maximum path sum of the current node and its subtrees.\\n\\nThe function dfs takes a node as input and returns the maximum path sum of the current node and its subtrees. It first checks if the node is None (i.e., a leaf node), and returns 0 in that case. Then, it recursively calls itself on the left and right subtrees, and stores the maximum sums in the variables left_sum and right_sum.\\n\\nThe maximum path sum of the current node is then calculated by adding the value of the node to the maximum sums of the left and right subtrees (if they are positive), and updating the global variable self.max_path_sum if necessary.\\n\\nFinally, the function returns the maximum sum of the current node and the maximum sums of its left and right subtrees.\\n\\nThe main function maxPathSum first initializes the maximum path sum to negative infinity, and then calls the dfs function on the root node. It then returns the maximum path sum.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nBeats\\n92.69%\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def dfs(node):\\n            # Base case: node is None\\n            if not node:\\n                return 0\\n            \\n            # Get the maximum sum of the left subtree\\n            left_sum = max(dfs(node.left), 0)\\n            # Get the maximum sum of the right subtree\\n            right_sum = max(dfs(node.right), 0)\\n            \\n            # Update the maximum path sum so far with the sum of the current node\\n            # and the maximum sums of the left and right subtrees\\n            self.max_path_sum = max(self.max_path_sum, node.val + left_sum + right_sum)\\n            \\n            # Return the maximum sum of the current node and the maximum sum of its\\n            # left and right subtrees\\n            return node.val + max(left_sum, right_sum)\\n        \\n        # Initialize the maximum path sum to negative infinity\\n        self.max_path_sum = float(\\'-inf\\')\\n        \\n        # Start the depth-first search\\n        dfs(root)\\n        \\n        # Return the maximum path sum\\n        return self.max_path_sum\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def dfs(node):\\n            # Base case: node is None\\n            if not node:\\n                return 0\\n            \\n            # Get the maximum sum of the left subtree\\n            left_sum = max(dfs(node.left), 0)\\n            # Get the maximum sum of the right subtree\\n            right_sum = max(dfs(node.right), 0)\\n            \\n            # Update the maximum path sum so far with the sum of the current node\\n            # and the maximum sums of the left and right subtrees\\n            self.max_path_sum = max(self.max_path_sum, node.val + left_sum + right_sum)\\n            \\n            # Return the maximum sum of the current node and the maximum sum of its\\n            # left and right subtrees\\n            return node.val + max(left_sum, right_sum)\\n        \\n        # Initialize the maximum path sum to negative infinity\\n        self.max_path_sum = float(\\'-inf\\')\\n        \\n        # Start the depth-first search\\n        dfs(root)\\n        \\n        # Return the maximum path sum\\n        return self.max_path_sum\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093544,
                "title": "java-c-100-solution-using-depth-first-search-binary-tree-maximum-path-sum",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log(n))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\npublic class Solution {\\n    int maxValue;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        maxValue = Integer.MIN_VALUE;\\n        maxPathDown(root);\\n        return maxValue;\\n    }\\n    \\n    private int maxPathDown(TreeNode node) {\\n        if (node == null) return 0;\\n        int left = Math.max(0, maxPathDown(node.left));\\n        int right = Math.max(0, maxPathDown(node.right));\\n\\n        maxValue = Math.max(maxValue, left + right + node.val);\\n        return Math.max(left, right) + node.val;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int res = INT_MIN;\\n    int solve(TreeNode* root){\\n        if(root)\\n        {   \\n            int left = max(0,solve(root->left));\\n            int right = max(0,solve(root->right));\\n\\n            res = max(res,root->val+left+right);\\n            return max(left,right)+root->val;\\n        }\\n        return 0;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        solve(root);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```Java []\\npublic class Solution {\\n    int maxValue;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        maxValue = Integer.MIN_VALUE;\\n        maxPathDown(root);\\n        return maxValue;\\n    }\\n    \\n    private int maxPathDown(TreeNode node) {\\n        if (node == null) return 0;\\n        int left = Math.max(0, maxPathDown(node.left));\\n        int right = Math.max(0, maxPathDown(node.right));\\n\\n        maxValue = Math.max(maxValue, left + right + node.val);\\n        return Math.max(left, right) + node.val;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int res = INT_MIN;\\n    int solve(TreeNode* root){\\n        if(root)\\n        {   \\n            int left = max(0,solve(root->left));\\n            int right = max(0,solve(root->right));\\n\\n            res = max(res,root->val+left+right);\\n            return max(left,right)+root->val;\\n        }\\n        return 0;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        solve(root);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045768,
                "title": "very-short-c-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust simply check for left subtree and right subtree and keep updating the maximum sum .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt first we intiliaze our maxi by INT_MIN then check with left and right subtree\\'s data and current root\\'s data if its max update it .\\n\\n---\\n\\n\\n` int l=max(height(root->left,dis),0);`\\n - `is because we don\\'t want negative sum if there is negative node value then don\\'t take it or we should not explore that branch which gives overall negative sum and that means 0. So just take the sum if its +ve gain or take it 0 if its -ve`\\n\\n\\n---\\n\\n- `similarly for right subtree.` // ` int r=max(height(root->right,dis),0);`\\n- Then just update the the max_sum stored\\n     -  `dis=max(dis,l+r+root->val);`\\n- Then at last return  `max(l+root->val,r+root->val);` which starts recursive stack\\n# Complexity\\n- Time complexity:O(n) `Gotta Traverse n nodes`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n) `Recusrive stack`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int height(TreeNode * root,int& dis){\\n       if(!root)return 0;\\n        int l=max(height(root->left,dis),0);\\n        int r=max(height(root->right,dis),0);\\n        dis=max(dis,l+r+root->val);\\n        return max(l+root->val,r+root->val);\\n   }\\n    int maxPathSum(TreeNode* root) {\\n        int dis=INT_MIN;\\n        height(root,dis);\\n        return dis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int height(TreeNode * root,int& dis){\\n       if(!root)return 0;\\n        int l=max(height(root->left,dis),0);\\n        int r=max(height(root->right,dis),0);\\n        dis=max(dis,l+r+root->val);\\n        return max(l+root->val,r+root->val);\\n   }\\n    int maxPathSum(TreeNode* root) {\\n        int dis=INT_MIN;\\n        height(root,dis);\\n        return dis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900900,
                "title": "simple-5-lines-dfs-solution-o-n-time-space",
                "content": "//upvote if helpful.\\n//thank you.\\n\\n# Approach\\nwe can see here we just need 5 values which are maximum value which we will get from my left child , maximum value which we will get from right child, we should add them to my value to return to my parent or just return my own value. I have commented the solution to get the understanding better.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root,int& ans){\\n        if(!root)return 0; //this is base case which is we have reached end of some path.\\n\\n        int lmax= dfs(root->left,  ans);// it will give me max value which i can get from my left child\\n        int rmax= dfs(root->right, ans);// it will give me max value which i can get from my right child\\n        ans= max({lmax+root->val, rmax+root->val, rmax+lmax+root->val, ans, root->val});// this is tricky because has 5 cases in total\\n        //1) should i take value coming from left child and add my value\\n        //2) should i take value coming from right child and add my value\\n        //3) or assume myself as root of that path then i have to take values coming from left+right and have to add mine too.\\n        //4) this is obvious\\n        //5)the path could contain myself only instead of taking left, right or my parent.\\n\\n        // now when i am returning my own max to my parent then \\n        //it will be my value+ either lmax or rmax because \\n        //if i am returning some value to my parent then it implies\\n        //that i am not root so we have to take either left or right.\\n        // and there is one more chance that both lmax, rmax are negative so i will return my value only.\\n        return max(root->val+max(lmax, rmax), root->val);\\n\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=root->val;\\n        //if(root->left==NULL && root->right==NULL)return root->val;\\n        int k= dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root,int& ans){\\n        if(!root)return 0; //this is base case which is we have reached end of some path.\\n\\n        int lmax= dfs(root->left,  ans);// it will give me max value which i can get from my left child\\n        int rmax= dfs(root->right, ans);// it will give me max value which i can get from my right child\\n        ans= max({lmax+root->val, rmax+root->val, rmax+lmax+root->val, ans, root->val});// this is tricky because has 5 cases in total\\n        //1) should i take value coming from left child and add my value\\n        //2) should i take value coming from right child and add my value\\n        //3) or assume myself as root of that path then i have to take values coming from left+right and have to add mine too.\\n        //4) this is obvious\\n        //5)the path could contain myself only instead of taking left, right or my parent.\\n\\n        // now when i am returning my own max to my parent then \\n        //it will be my value+ either lmax or rmax because \\n        //if i am returning some value to my parent then it implies\\n        //that i am not root so we have to take either left or right.\\n        // and there is one more chance that both lmax, rmax are negative so i will return my value only.\\n        return max(root->val+max(lmax, rmax), root->val);\\n\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=root->val;\\n        //if(root->left==NULL && root->right==NULL)return root->val;\\n        int k= dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481730,
                "title": "o-n-recursive-solution-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    int max_so_far = INT_MIN;\\npublic:\\n    int dfs(TreeNode* root) {\\n        if(!root) {\\n            return 0;\\n        }\\n        // l & r -> give the maximum sum path in both subtrees\\n        int l = dfs(root->left);\\n        int r = dfs(root->right);\\n\\n        // max_till_now -> assure path won\\'t be discontinuous\\n        int max_till_now = max({ root->val, r + root->val, l + root->val });\\n\\n        // max_path_in_subtrees -> forms the max path b/w 2 leaf nodes, through current node\\n        int max_path_in_subtrees = root->val + l + r;\\n        \\n        // max_so_far -> maintains the max path\\n        max_so_far = max({ max_so_far, max_till_now, max_path_in_subtrees });\\n\\n        // return\\n        return max_till_now;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int p = dfs(root);\\n        return max_so_far;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int max_so_far = INT_MIN;\\npublic:\\n    int dfs(TreeNode* root) {\\n        if(!root) {\\n            return 0;\\n        }\\n        // l & r -> give the maximum sum path in both subtrees\\n        int l = dfs(root->left);\\n        int r = dfs(root->right);\\n\\n        // max_till_now -> assure path won\\'t be discontinuous\\n        int max_till_now = max({ root->val, r + root->val, l + root->val });\\n\\n        // max_path_in_subtrees -> forms the max path b/w 2 leaf nodes, through current node\\n        int max_path_in_subtrees = root->val + l + r;\\n        \\n        // max_so_far -> maintains the max path\\n        max_so_far = max({ max_so_far, max_till_now, max_path_in_subtrees });\\n\\n        // return\\n        return max_till_now;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int p = dfs(root);\\n        return max_so_far;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1149399,
                "title": "deceptively-simple-problem-intuitive-java-solution-with-comments-beats-100",
                "content": "I felt the problem is deceptively simple, and very easy to get it wrong. Hence an intuitive answer is most helpful because you can possibly come up with this solution during interview without memorizing the approach!\\n\\nTwo main things to remember:\\n* This is a max path sum problem, not max subtree sum problem\\n* The value that is interesting for the current node may not be interesting for its parent, given the constraints of the problem\\n\\nI found the best way to solve this is to have a tracker that maintains maximum sum for every node visited. The tree is traversed post-order with each node returning path sum. The tracker is used to memorize the max path sum. The return value really is the path sum that the subtree rooted at the current node can contribute as path sum if the parent node decides to include it. This aspect is intuitive when you think about it, but it may not come to mind first time!\\n\\nThe time complexity of the code below is O(n) - every node is visited. Space complexity should be O(h) considering the recursion stack size.\\n\\n```\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root); // return value is not important in this function\\n        return maxSum;\\n    }\\n    \\n    private int helper(TreeNode node) {\\n        if (node == null) {\\n            return 0; // null node contributes nothing to the sum\\n        }\\n        \\n        // Postorder traversal\\n        int leftSum = helper(node.left);\\n        int rightSum = helper(node.right);\\n        \\n        int maxChildSum = Math.max(leftSum, rightSum);\\n        \\n        // We now need to compute three aspects:\\n        // Case 1: Max path is only the current node\\n        maxSum = Math.max(node.val, maxSum);\\n        // Case 2: the path includes node and both of its children\\n        maxSum = Math.max(node.val + leftSum + rightSum, maxSum);\\n        // Case 3: Path including Node and only one of the child\\n        maxSum = Math.max(node.val + maxChildSum, maxSum);\\n        \\n        // The question here is to find max path sum, and not max subtree sum\\n        // hence we return only a viable path sum to the parent node\\n        // Depending on the value of the nodes, this can either be the node itself, \\n        // or sum of the node and max of its children\\n        return Math.max(node.val, node.val + maxChildSum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root); // return value is not important in this function\\n        return maxSum;\\n    }\\n    \\n    private int helper(TreeNode node) {\\n        if (node == null) {\\n            return 0; // null node contributes nothing to the sum\\n        }\\n        \\n        // Postorder traversal\\n        int leftSum = helper(node.left);\\n        int rightSum = helper(node.right);\\n        \\n        int maxChildSum = Math.max(leftSum, rightSum);\\n        \\n        // We now need to compute three aspects:\\n        // Case 1: Max path is only the current node\\n        maxSum = Math.max(node.val, maxSum);\\n        // Case 2: the path includes node and both of its children\\n        maxSum = Math.max(node.val + leftSum + rightSum, maxSum);\\n        // Case 3: Path including Node and only one of the child\\n        maxSum = Math.max(node.val + maxChildSum, maxSum);\\n        \\n        // The question here is to find max path sum, and not max subtree sum\\n        // hence we return only a viable path sum to the parent node\\n        // Depending on the value of the nodes, this can either be the node itself, \\n        // or sum of the node and max of its children\\n        return Math.max(node.val, node.val + maxChildSum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1101447,
                "title": "java-beats-100-easy-to-understand-solution-with-explanation-and-comments",
                "content": "/**\\n *Definition for a binary tree node.\\npublic class TreeNode {\\n \\xA0 int val;\\n TreeNode left;\\n TreeNode right;\\n  \\xA0 \\xA0 TreeNode() {}\\n TreeNode(int val) { this.val = val; }\\n TreeNode(int val, TreeNode left, TreeNode right) {\\n this.val = val;\\n this.left = left;\\n this.right = right;\\n }\\n}\\n */ \\n \\n \\n // Solution explanation\\n// In this solution we are doing postorder tranversal and finding maximum path sum for each node during traversal\\n\\n\\n// We need to take care of 3 test cases\\n// Case 1: The current node lies in the path of maximum sum \\n// Case 2: The current node is the root of maximum path sum\\n// Case 3: The current node doesn\\'t lie in the path of maximum sum \\n```\\n\\n```class Solution {\\n    // this variable is going to store maximum sum we have found \\n    int result= Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n       maxUtil( root);\\n          return result;\\n    }\\n    public int maxUtil(TreeNode root){\\n       \\n        if(root==null)\\n            return 0;\\n        // left & right variable is storing maximum path sum of left & right subtree\\n       int left=maxUtil(root.left);\\n       int right=maxUtil(root.right);\\n// checking for Case 1 here either we are coming from left subtree or right subtree in this case that\\'s why taking maximum of left & right \\n        int max1=Math.max(Math.max(left,right)+root.val,root.val);\\n        // checking for case 2 here and comparing it with previous case 1 value . In this case max sum is root\\'s value + left child value+ right child value \\n        int max2=Math.max(max1,left+right+root.val);\\n        // finally comparing the maximum sum we have got so far and updating its value checking case 3 as well \\n    \\n        result= Math.max(max2, result);\\n        return max1;\\n        \\n}\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1044638,
                "title": "java-intuitive-0ms-100",
                "content": "```\\nclass Solution {\\n    int res = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        postTraverse(root);\\n        return res;\\n    }\\n    \\n    public int postTraverse(TreeNode root){\\n        if(root == null) return 0;\\n        \\n        int leftMax = postTraverse(root.left);\\n        int rightMax = postTraverse(root.right);\\n        \\n        // Max of (root+left), (root+right), (root); \\n        //only max1 gets returned to it\\'s parent to make a single path along the parent node.\\n        int max1 = Math.max(Math.max(leftMax, rightMax)+root.val, root.val); \\n        \\n        // Max of (root+left), (root+right), (root), (root+left+right); \\n        // check if a subtree makes the max sum path.\\n        int max2 = Math.max(max1, leftMax + rightMax + root.val);\\n        \\n        res = Math.max(res, max2); \\n        \\n        return max1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int res = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        postTraverse(root);\\n        return res;\\n    }\\n    \\n    public int postTraverse(TreeNode root){\\n        if(root == null) return 0;\\n        \\n        int leftMax = postTraverse(root.left);\\n        int rightMax = postTraverse(root.right);\\n        \\n        // Max of (root+left), (root+right), (root); \\n        //only max1 gets returned to it\\'s parent to make a single path along the parent node.\\n        int max1 = Math.max(Math.max(leftMax, rightMax)+root.val, root.val); \\n        \\n        // Max of (root+left), (root+right), (root), (root+left+right); \\n        // check if a subtree makes the max sum path.\\n        int max2 = Math.max(max1, leftMax + rightMax + root.val);\\n        \\n        res = Math.max(res, max2); \\n        \\n        return max1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1013639,
                "title": "c-clean-short-simplest-solution-ever-faster-than-99-5",
                "content": "This question should be medium, not hard!\\n```\\nclass Solution {\\npublic:\\n    int rec(TreeNode* root) {\\n        if (!root)\\n            return 0;\\n        int left = max(rec(root->left), 0);\\n        int right = max(rec(root->right), 0);\\n        maxi = max(maxi, left+right+root->val);\\n        return max(left, right) + root->val;\\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n        rec(root);\\n        return maxi;\\n    }\\nprivate:\\n    int maxi = INT_MIN;\\n};\\n```\\n**Like it? Please upvote!!\\nHave any comments? I\\'d love to hear...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rec(TreeNode* root) {\\n        if (!root)\\n            return 0;\\n        int left = max(rec(root->left), 0);\\n        int right = max(rec(root->right), 0);\\n        maxi = max(maxi, left+right+root->val);\\n        return max(left, right) + root->val;\\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n        rec(root);\\n        return maxi;\\n    }\\nprivate:\\n    int maxi = INT_MIN;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769037,
                "title": "a-precise-recursive-dfs-solution-in-java-with-explanation",
                "content": "Algorithm for Problem: Since we have to find the maximum sum from some node in the binary tree to any node,we can use  a recursive bottom up approach to solve this problem. \\nWe have to consider the left child of every node and right child of every node then we need to find the current sum  that can be  calculated using basic logic.\\n**currentsum=Math.max((root.val+left),Math.max((root.val+right),Math.max(root.val,root.val+left+right)));\\nWe need to consider three cases:\\n1)The subtree sum of left child+right child +root value(subtree might be the maximu path).\\n2)The sum of left child and root value.\\n3)The sum of right child and root value.\\n4)We need to find the maximum of step 1,2,3.**\\n\\nAfter finding the current sum we need to compare it with maxsum,if it is less than maxsum then we do nothing,if it is greater than maxsum then we update maxsum to currentsum.\\n\\nMost Important process to whole algorithm is to get the return value form the function,this is a little bit tricky.\\nWe cannot return maxsum because it might contain the whole subtree(which might not be maxmium path) and we seek to find maximum path .\\nHere we define integer ret:\\n**ret=Math.max(root.val+left,Math.max(root.val+right,root.val));\\nValue to be returned we be either of the three:\\n1)Sum of Left child and Root value.\\n2)Sum of Right child and Root value.\\n3)Only root value.**\\n\\nSolution contains a print statement to demonstrate the flow of program, but is commented.\\n\\n\\n```\\nclass Solution {\\n    int maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        maxpath(root);\\n        return maxsum;\\n    }\\n    public int maxpath(TreeNode root)\\n    {\\n        if(root==null)\\n            return 0;\\n        int left=maxpath(root.left);\\n        int right=maxpath(root.right);\\n        int currentsum=Math.max((root.val+left),Math.max((root.val+right),Math.max(root.val,root.val+left+right)));\\n        //System.out.println(\"left \"+left+\" right \"+right+\" currentsum \"+currentsum);\\n        maxsum=Math.max(maxsum,currentsum);\\n        int ret=Math.max(root.val+left,Math.max(root.val+right,root.val));\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        maxpath(root);\\n        return maxsum;\\n    }\\n    public int maxpath(TreeNode root)\\n    {\\n        if(root==null)\\n            return 0;\\n        int left=maxpath(root.left);\\n        int right=maxpath(root.right);\\n        int currentsum=Math.max((root.val+left),Math.max((root.val+right),Math.max(root.val,root.val+left+right)));\\n        //System.out.println(\"left \"+left+\" right \"+right+\" currentsum \"+currentsum);\\n        maxsum=Math.max(maxsum,currentsum);\\n        int ret=Math.max(root.val+left,Math.max(root.val+right,root.val));\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684624,
                "title": "java-with-picture",
                "content": "\\nThanks [@wei-bung](https://leetcode.com/problems/binary-tree-maximum-path-sum/discuss/39775/Accepted-short-solution-in-Java)\\n\\n![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_124_common.png)  \\n\\n\\n![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_124_careful_with_return.png)  \\n\\n\\n``` java\\nclass Solution {\\n    \\n    int ans = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return ans;\\n    }\\n    \\n    private int helper(TreeNode root){\\n        \\n        // Base case.\\n        if (root == null) return 0;\\n        \\n        int left  = Math.max(0, helper(root.left));\\n        int right = Math.max(0, helper(root.right));\\n        int cur   = root.val + left + right;\\n        ans       = Math.max(ans, cur);\\n        // return cur;\\n        return Math.max(left, right) + root.val;\\n    }\\n}\\n```\\n\\n`Enjoy it ! `",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    \\n    int ans = Integer.MIN_VALUE;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return ans;\\n    }\\n    \\n    private int helper(TreeNode root){\\n        \\n        // Base case.\\n        if (root == null) return 0;\\n        \\n        int left  = Math.max(0, helper(root.left));\\n        int right = Math.max(0, helper(root.right));\\n        int cur   = root.val + left + right;\\n        ans       = Math.max(ans, cur);\\n        // return cur;\\n        return Math.max(left, right) + root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467723,
                "title": "go-golang-clean-solution",
                "content": ">Runtime: 16 ms, faster than 90.40% of Go online submissions for Binary Tree Maximum Path Sum.\\nMemory Usage: 6.7 MB, less than 100.00% of Go online submissions for Binary Tree Maximum Path Sum.\\n\\n```go\\nfunc maxPathSum(root *TreeNode) int {\\n    res := math.MinInt32\\n    helper(root, &res)\\n    return res\\n}\\n\\nfunc helper(node *TreeNode, res *int) int {\\n    if node == nil { return 0 }\\n    left := helper(node.Left, res)\\n    right := helper(node.Right, res)\\n    currentNodeNotAsRoot := max(max(left, right) + node.Val, node.Val)\\n    currentNodeAsRoot := max(currentNodeNotAsRoot, left + right + node.Val)\\n    *res = max(*res, currentNodeAsRoot)\\n    return currentNodeNotAsRoot\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc maxPathSum(root *TreeNode) int {\\n    res := math.MinInt32\\n    helper(root, &res)\\n    return res\\n}\\n\\nfunc helper(node *TreeNode, res *int) int {\\n    if node == nil { return 0 }\\n    left := helper(node.Left, res)\\n    right := helper(node.Right, res)\\n    currentNodeNotAsRoot := max(max(left, right) + node.Val, node.Val)\\n    currentNodeAsRoot := max(currentNodeNotAsRoot, left + right + node.Val)\\n    *res = max(*res, currentNodeAsRoot)\\n    return currentNodeNotAsRoot\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 340521,
                "title": "my-java-solution",
                "content": "We need to figure out 3 things to solve this problem. \\nSuppose we are on one tree node,\\n**1. what do we want from left subtree and right subtree.**\\nWe need to know max sum from two children. And if sum < 0, we must left it be 0 to eliminate its negative effect because we want the max sum path. This is very important.\\n```\\n\\tint left = Math.max(0, dfs(root.left));\\n\\tint right = Math.max(0, dfs(root.right));\\n```\\n**2. What do we want to do in the current layer**\\nWe want to add leftSum, rightSum and the node value up. This is a sum path from one leaf node to another leaf node. So we need to get the global_max like\\n```\\n\\tglobal_max = Math.max(global_max, left + right + root.val);\\n```\\n**3. What value we want to return to our parent node.**\\nWhat we want to return is not the full sum path. It\\'s the max path from root to one leaf node. So, we need to return\\n```\\n\\treturn Math.max(left, right) + root.val;\\n```\\nMy code is shown below:\\n```\\nclass Solution {\\n    int global_max;\\n    public int maxPathSum(TreeNode root) {\\n        global_max = Integer.MIN_VALUE;\\n        dfs(root);\\n\\t    return global_max;\\n}\\nprivate int dfs(TreeNode root){\\n\\tif (root == null){\\n\\t\\treturn 0;\\n\\t}\\n\\tint left = Math.max(0, dfs(root.left));\\n\\tint right = Math.max(0, dfs(root.right));\\n\\tif (root.left != null && root.right != null){\\n\\t\\tglobal_max = Math.max(global_max, left + right + root.val);\\n\\t\\treturn Math.max(left, right) + root.val;\\n\\t}\\n\\tif (root.left == null){\\n\\t\\tglobal_max = Math.max(global_max, right + root.val);\\n\\t\\treturn right + root.val;\\n\\t}\\t\\n\\telse {\\n\\t\\tglobal_max = Math.max(global_max, left + root.val);\\n\\t\\treturn  left + root.val;\\n\\t}\\n}\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint left = Math.max(0, dfs(root.left));\\n\\tint right = Math.max(0, dfs(root.right));\\n```\n```\\n\\tglobal_max = Math.max(global_max, left + right + root.val);\\n```\n```\\n\\treturn Math.max(left, right) + root.val;\\n```\n```\\nclass Solution {\\n    int global_max;\\n    public int maxPathSum(TreeNode root) {\\n        global_max = Integer.MIN_VALUE;\\n        dfs(root);\\n\\t    return global_max;\\n}\\nprivate int dfs(TreeNode root){\\n\\tif (root == null){\\n\\t\\treturn 0;\\n\\t}\\n\\tint left = Math.max(0, dfs(root.left));\\n\\tint right = Math.max(0, dfs(root.right));\\n\\tif (root.left != null && root.right != null){\\n\\t\\tglobal_max = Math.max(global_max, left + right + root.val);\\n\\t\\treturn Math.max(left, right) + root.val;\\n\\t}\\n\\tif (root.left == null){\\n\\t\\tglobal_max = Math.max(global_max, right + root.val);\\n\\t\\treturn right + root.val;\\n\\t}\\t\\n\\telse {\\n\\t\\tglobal_max = Math.max(global_max, left + root.val);\\n\\t\\treturn  left + root.val;\\n\\t}\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 321667,
                "title": "swift-o-n-linear-recursive-solution",
                "content": "```\\nclass Solution {\\n    func maxPathSum(_ root: TreeNode?) -> Int {\\n        var result: Int = 0;\\n        if root != nil {\\n            result = root!.val\\n            maxPathSumHelper(root, &result)\\n        }\\n        return result\\n    }\\n    \\n    func maxPathSumHelper(_ root: TreeNode?, _ result: inout Int) -> Int {\\n        \\n        guard let root = root else { return 0 }\\n        \\n        var leftCost = maxPathSumHelper(root.left, &result)\\n        if leftCost < 0 { leftCost = 0 }\\n        \\n        var rightCost = maxPathSumHelper(root.right, &result)\\n        if rightCost < 0 { rightCost = 0 }\\n        \\n        var val = root.val + leftCost + rightCost\\n        if val > result { result = val }\\n        \\n        return root.val + max(leftCost, rightCost)\\n    }\\n    \\n}\\n```\\n\\nThe main difficulty with this question is understanding what \"path\" means at each recursion level. For calculating the max possible path, we can take into consideration the current node AND (none, one, or both children). For calculating the return value, we are focusing on a sub-path, which means there would be a fork in our path - basically, we can only pick one child as our max path to return to a parent, which will count both directional children of its max computation... \\n\\nThink of the max/result computation as independent from the return value, because it is...",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func maxPathSum(_ root: TreeNode?) -> Int {\\n        var result: Int = 0;\\n        if root != nil {\\n            result = root!.val\\n            maxPathSumHelper(root, &result)\\n        }\\n        return result\\n    }\\n    \\n    func maxPathSumHelper(_ root: TreeNode?, _ result: inout Int) -> Int {\\n        \\n        guard let root = root else { return 0 }\\n        \\n        var leftCost = maxPathSumHelper(root.left, &result)\\n        if leftCost < 0 { leftCost = 0 }\\n        \\n        var rightCost = maxPathSumHelper(root.right, &result)\\n        if rightCost < 0 { rightCost = 0 }\\n        \\n        var val = root.val + leftCost + rightCost\\n        if val > result { result = val }\\n        \\n        return root.val + max(leftCost, rightCost)\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 306274,
                "title": "actually-reabable-python-with-explanation-14-lines",
                "content": "**Idea**:\\n1) The first and most imporant insight here is a path, as defined formally in the question, can only **cross the two subtrees at most once in the entire path**.  \\n```\\n   -10\\n   / \\\\\\n  9  20\\n    /  \\\\\\n   15   7\\n```\\n**E.g. Once we have path [15,20,7], we can never have a path that includes 20 and any of its ancestor together. Because in those paths, we will be touching 20 more than once and that would not be a legal path. For instance, had -10 and 20 been included together on the same path, there\\'s no way to touch every node of the subtree rooted at 20 without touching 20 twice.**\\n\\n**When we include a root node of a tree, I call it *crossing the subtrees* (imagine crossing left subtree into right subtree).**\\n\\n2) The second insight is just that there are two kinds of sums - a) the sum you get by crossing some pair of subtrees b) the sum you get by not crossing any pair of subtrees.\\n\\nIn the code, for each node, I call the sum you get crossing the subtrees max_ex (for max_extensible because you could choose to extend this sum by crossing subtrees when we get to its ancestors) and the max_nonex (for max_nonextensible). \\n\\nThen everything follows from these definitions/worldviews.\\na) (max_ex, again, the sum by going on a straight path, no crossing subtrees) max_ex is defined to be the max of i) root.val (straight path of 1 node) and ii) results of subproblems\\nb) max_nonex is defined to be i) max_ex (for the optimal result could be a straight path from current node to one of its descendent and we just don\\'t extend it for reasons like maybe ancestors are negative as in our example), ii) root.val + max_left_ex + max_right_ex (for extending and crossing the subtrees) and finally iii) results of the subproblems.\\n\\nSee everything in action, a modified diagram of max_ex and max_nonex next to each node.val:\\n```\\nformat: node.val (max_ex, max_nonex)\\n   -10 (25,42)\\n   /           \\\\\\n  9 (9,9) 20 (35,42)\\n    /              \\\\\\n   15 (15,15)  7 (7,7)\\n```\\n\\nNote:\\nThis writing is one of my first few writings on Leetcode, I\\'d love to get some feedback from you and keep improving and shareing my thoughts. My focus is try to explain what may be confusing in other explanations as simply as possible while keeping the insights I had while coding. Because at the end of the day, it\\'s these insights that help us solve these problems. \\n\\nPlease don\\'t feel frustrated or give up if you don\\'t understand as my writing could\\'ve been confusing. Do try focus on the above example I provided here. Please provide feedback, leave a comment, and I will try my best to get back to you. \\n\\n```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        return max(self.exten_and_nonexten_sum(root))\\n    def exten_and_nonexten_sum(self, root: TreeNode) -> int:\\n        if not root:\\n            return (float(\\'-inf\\'), float(\\'-inf\\'))\\n        max_left_ex, max_left_nonex = self.exten_and_nonexten_sum(root.left)\\n        max_right_ex, max_right_nonex = self.exten_and_nonexten_sum(root.right)\\n        max_ex = max(root.val, root.val + max_left_ex, root.val + max_right_ex)\\n        max_nonex = max(\\n            max_ex,\\n            root.val + max_left_ex + max_right_ex,\\n            max_left_nonex,\\n            max_right_nonex)\\n        return (max_ex, max_nonex)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n   -10\\n   / \\\\\\n  9  20\\n    /  \\\\\\n   15   7\\n```\n```\\nformat: node.val (max_ex, max_nonex)\\n   -10 (25,42)\\n   /           \\\\\\n  9 (9,9) 20 (35,42)\\n    /              \\\\\\n   15 (15,15)  7 (7,7)\\n```\n```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        return max(self.exten_and_nonexten_sum(root))\\n    def exten_and_nonexten_sum(self, root: TreeNode) -> int:\\n        if not root:\\n            return (float(\\'-inf\\'), float(\\'-inf\\'))\\n        max_left_ex, max_left_nonex = self.exten_and_nonexten_sum(root.left)\\n        max_right_ex, max_right_nonex = self.exten_and_nonexten_sum(root.right)\\n        max_ex = max(root.val, root.val + max_left_ex, root.val + max_right_ex)\\n        max_nonex = max(\\n            max_ex,\\n            root.val + max_left_ex + max_right_ex,\\n            max_left_nonex,\\n            max_right_nonex)\\n        return (max_ex, max_nonex)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 179498,
                "title": "recursion-thinking-process",
                "content": ">Each node can be the root of the final Maximum Path Sum - root here means the topmost node in a path.\\n\\n>We calculate Maximum Path Sum rooted at each node and update `maxSum`  on the fly.\\n\\n>Maximum Path Sum rooted at a node = \\n```\\nmax(maxPathSumFrom(node.left), 0) + max(maxPathSumFrom(node.right), 0) + node.val)\\n// Pay attention to how 0-trick saves tedious comparison.\\n```\\n\\n> getDownwardPathSum(node) =\\n```\\nmax(maxPathSumFrom(node.left), maxPathSumFrom(node.right)) + node.val\\n```\\n\\n****\\n```\\n    private int maxSum;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        maxPathSumFrom(root);\\n        return maxSum;\\n    }\\n    \\n    private int maxPathSumFrom(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        int left = Math.max(0, maxPathSumFrom(root.left));\\n        int right = Math.max(0, maxPathSumFrom(root.right));\\n        \\n        maxSum = Math.max(maxSum, left + right + root.val);\\n        \\n        return Math.max(left, right) + root.val;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nmax(maxPathSumFrom(node.left), 0) + max(maxPathSumFrom(node.right), 0) + node.val)\\n// Pay attention to how 0-trick saves tedious comparison.\\n```\n```\\nmax(maxPathSumFrom(node.left), maxPathSumFrom(node.right)) + node.val\\n```\n```\\n    private int maxSum;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        maxPathSumFrom(root);\\n        return maxSum;\\n    }\\n    \\n    private int maxPathSumFrom(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        int left = Math.max(0, maxPathSumFrom(root.left));\\n        int right = Math.max(0, maxPathSumFrom(root.right));\\n        \\n        maxSum = Math.max(maxSum, left + right + root.val);\\n        \\n        return Math.max(left, right) + root.val;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39851,
                "title": "simple-recursive-yet-still-accepted-as-best-in-cpp",
                "content": "    class Solution {\\n    private:\\n        int traverse(TreeNode* root, int& maxSum)\\n        {\\n            if(!root) return 0;\\n            int lMax = max(0, traverse(root->left, maxSum));\\n            int rMax = max(0, traverse(root->right, maxSum));\\n            maxSum = max(maxSum, lMax+rMax+root->val);\\n            return max(lMax, rMax)+root->val;\\n        }\\n    public:\\n        int maxPathSum(TreeNode* root) {\\n            int maxSum = INT_MIN;\\n            traverse(root, maxSum);\\n            return maxSum;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\n    private:\\n        int traverse(TreeNode* root, int& maxSum)\\n        {\\n            if(!root) return 0;\\n            int lMax = max(0, traverse(root->left, maxSum));\\n            int rMax = max(0, traverse(root->right, maxSum));\\n            maxSum = max(maxSum, lMax+rMax+root->val);\\n            return max(lMax, rMax)+root->val;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3998373,
                "title": "a-dynamic-programming-dp-approach-images-c-simple-intuitive-100-runtime-90-memory",
                "content": "# Intuition\\nWhen faced with a problem like finding the maximum sum binary tree path, it\\'s tempting to draw parallels with familiar algorithms like the maximum sum subarray problem. However, in this case, we don\\'t have a simple array to work with. Instead, we\\'re dealing with a binary tree. The question arises: can we transform the tree into an array and then apply a 1D dynamic programming approach? The answer is not straightforward. Consider the following counterexample:\\n`[1,-2,-3,1,3,-2,null,-1]`\\n\\n![Screenshot 2023-09-03 at 13.33.41.png](https://assets.leetcode.com/users/images/95804efb-eb89-4544-b6a7-2401a8d0174d_1693762433.8614566.png)\\n\\nIn the inorder traversal of this tree `[-1,1,-2,3,1,-3,-2]`, the numbers 1 and 3 are adjacent. However, they do not form a valid path in the tree.\\n\\nNevertheless, the essence of the idea is promising. For calculating the maximum subarray sum, we can use the dynamic programming formula:\\n`dp[i] = max(dp[i - 1] + arr[i], arr[i])`\\n\\nIn our case, we have more options than just considering the previous element, and we must account for the \"path\" nature of the problem.\\n\\n# Approach\\nLet\\'s define our dynamic programming (DP) for the current node. We want to calculate the maximum path sum that includes the current node as the root. Logically, it can be expressed as:\\n```\\ndp[curr_node] = max(\\n    dp[left_child] + curr_val, \\n    dp[right_child] + curr_val, \\n    curr_val\\n)\\n```\\n\\nWe have three choices: either take the left subtree sum and add the current node\\'s value, or take the right subtree sum and add the current node\\'s value, or ignore both subtrees and just take the current node\\'s value.\\n\\nHowever, there are two significant problems with this solution so far:\\n\\n- We don\\'t know how to calculate dp[node] because there is no unique way to define a node (values are not guaranteed to be unique).\\n- The solution only supports paths that start in a specific node as their left or right subtree, while the path may lead from any node to any other node.\\n\\n![1.png](https://assets.leetcode.com/users/images/008a6416-ca3b-45b4-b365-414a5560b250_1693763460.2434177.png)\\n\\nLet\\'s address the second problem first. Every time we calculate `dp[curr_node]`, we can also compute the `ans`, which represents the best answer seen so far (the maximum path sum up to that point). To accommodate paths that don\\'t necessarily start from a specific node, we modify our answer calculation as follows:\\n```\\nans = max(ans, dp[curr_node], dp[left_child] + curr_val + dp[right_child])\\n```\\n\\nNow what about `dp[curr_node]`? Well, we have `node.val` for every node, and we do not have a requirement on keeping this value after the function execution. So we can use this `node.val` as our `dp[curr_node]`:\\n```\\ncurr.val = max(curr.val, max(left + curr.val, right + curr.val));\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ - we simply do tree traversal (dfs)\\n\\n- Space complexity:\\n$$O(n)$$ - because of the recursive approach, we could also do that in $$O(1)$$ rewriting in iterative way.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    const int INF = 1e9;\\n    int ans = -1e9;\\n\\n    // dp for current node is max(left + curr, right + curr, left + right + curr, curr);\\n\\n    int dfs(TreeNode *curr) {\\n        if (curr == NULL) return -INF;\\n\\n        int left = dfs(curr->left);\\n        int right = dfs(curr->right);\\n\\n        int cval = curr->val;\\n        curr->val = std::max(\\n            cval,\\n            std::max(left + cval, right + cval)\\n        );\\n\\n        ans = std::max(std::max(ans, curr->val), left + cval + right);\\n\\n        return curr->val;\\n    }\\n\\n    int maxPathSum(TreeNode* curr) {\\n        int res = dfs(curr);\\n        return std::max(res, ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\ndp[curr_node] = max(\\n    dp[left_child] + curr_val, \\n    dp[right_child] + curr_val, \\n    curr_val\\n)\\n```\n```\\nans = max(ans, dp[curr_node], dp[left_child] + curr_val + dp[right_child])\\n```\n```\\ncurr.val = max(curr.val, max(left + curr.val, right + curr.val));\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    const int INF = 1e9;\\n    int ans = -1e9;\\n\\n    // dp for current node is max(left + curr, right + curr, left + right + curr, curr);\\n\\n    int dfs(TreeNode *curr) {\\n        if (curr == NULL) return -INF;\\n\\n        int left = dfs(curr->left);\\n        int right = dfs(curr->right);\\n\\n        int cval = curr->val;\\n        curr->val = std::max(\\n            cval,\\n            std::max(left + cval, right + cval)\\n        );\\n\\n        ans = std::max(std::max(ans, curr->val), left + cval + right);\\n\\n        return curr->val;\\n    }\\n\\n    int maxPathSum(TreeNode* curr) {\\n        int res = dfs(curr);\\n        return std::max(res, ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813082,
                "title": "java-easy-solution-full-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize a `maxValue` array to store our final answer.\\n- Do a simple tree traversal. At each node, find  recursively its `leftMaxPath` and its `rightMaxPath`.\\n- Calculate the maxPath through the node as `val + (leftMaxPath + rightMaxPath)` and update maxi accordingly.\\n- Return the maxPath when node is not the curving point as `val + max(leftMaxPath, rightMaxPath)`.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) recursive stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int maxPathSum(TreeNode root) {\\n      int maxValue[] = new int[1];\\n      maxValue[0] = Integer.MIN_VALUE;\\n      helper(root, maxValue);\\n      return maxValue[0];\\n    }\\n  int helper(TreeNode root, int[] maxValue) {\\n    if(root == null) return 0;\\n    int left = Math.max(helper(root.left, maxValue), 0);\\n    int right = Math.max(helper(root.right, maxValue), 0);  \\n    \\n    maxValue[0] = Math.max(maxValue[0], root.val + left + right);\\n    return root.val + Math.max(left, right);\\n  }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int maxPathSum(TreeNode root) {\\n      int maxValue[] = new int[1];\\n      maxValue[0] = Integer.MIN_VALUE;\\n      helper(root, maxValue);\\n      return maxValue[0];\\n    }\\n  int helper(TreeNode root, int[] maxValue) {\\n    if(root == null) return 0;\\n    int left = Math.max(helper(root.left, maxValue), 0);\\n    int right = Math.max(helper(root.right, maxValue), 0);  \\n    \\n    maxValue[0] = Math.max(maxValue[0], root.val + left + right);\\n    return root.val + Math.max(left, right);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718407,
                "title": "binary-tree-maximum-path-sum-leetcode",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root, int &maxi){\\n        // base case:-\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int left = max(solve(root -> left, maxi), 0);\\n        int right = max(solve(root -> right, maxi), 0);\\n\\n        maxi = max(maxi, left + right + root -> val);\\n        return max(left,right) + root -> val;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        // base case:-\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int maxi = INT_MIN;\\n        int ans = solve(root,maxi);\\n        return max(maxi,ans);\\n    }\\n// By ~ Shubham Verma\\n};\\n```\\n![7cfadaec-4ab3-45e4-9ad8-313c2db992f9_1678433858.6366765.png](https://assets.leetcode.com/users/images/a89c7575-9822-4560-9cbc-50f4ffa8b753_1688490238.7928553.png)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root, int &maxi){\\n        // base case:-\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int left = max(solve(root -> left, maxi), 0);\\n        int right = max(solve(root -> right, maxi), 0);\\n\\n        maxi = max(maxi, left + right + root -> val);\\n        return max(left,right) + root -> val;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        // base case:-\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int maxi = INT_MIN;\\n        int ans = solve(root,maxi);\\n        return max(maxi,ans);\\n    }\\n// By ~ Shubham Verma\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702811,
                "title": "a-simple-accepted-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int maxPathSumHelper(TreeNode* root, int& res) {\\n        if (root == nullptr) {\\n            return 0;\\n        }\\n        \\n        int leftSum = maxPathSumHelper(root->left, res);\\n        int rightSum = maxPathSumHelper(root->right, res);\\n        \\n        int maxChildSum = max(leftSum, rightSum);\\n        \\n        int maxRootSum = max(maxChildSum + root->val, root->val);\\n        int maxTreeSum = max(maxRootSum, leftSum + rightSum + root->val);\\n        \\n        res = max(res, maxTreeSum);\\n        \\n        return maxRootSum;\\n    }\\n    \\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int res = INT_MIN;\\n        maxPathSumHelper(root, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int maxPathSumHelper(TreeNode* root, int& res) {\\n        if (root == nullptr) {\\n            return 0;\\n        }\\n        \\n        int leftSum = maxPathSumHelper(root->left, res);\\n        int rightSum = maxPathSumHelper(root->right, res);\\n        \\n        int maxChildSum = max(leftSum, rightSum);\\n        \\n        int maxRootSum = max(maxChildSum + root->val, root->val);\\n        int maxTreeSum = max(maxRootSum, leftSum + rightSum + root->val);\\n        \\n        res = max(res, maxTreeSum);\\n        \\n        return maxRootSum;\\n    }\\n    \\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int res = INT_MIN;\\n        maxPathSumHelper(root, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693478,
                "title": "100-beats-cpp-c-code-tc-o-n-easy-code-dfs-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int solve(TreeNode* root, int &maxi){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int lefti=max(0,solve(root->left,maxi));\\n        int righti=max(0,solve(root->right,maxi));\\n        // int op1=max(lefti,righti);\\n        // int op2=max(lefti+root->val,righti+root->val);\\n        // int op3=root->val+lefti+righti;\\n        // maxi=max(op1,max(op2,op3));\\n        // return maxi;\\n        maxi=max(maxi,lefti+righti+root->val);\\n        return max(lefti,righti)+root->val;\\n\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int maxi=INT_MIN;\\n        int result=solve(root,maxi);\\n        return max(maxi,result);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int solve(TreeNode* root, int &maxi){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int lefti=max(0,solve(root->left,maxi));\\n        int righti=max(0,solve(root->right,maxi));\\n        // int op1=max(lefti,righti);\\n        // int op2=max(lefti+root->val,righti+root->val);\\n        // int op3=root->val+lefti+righti;\\n        // maxi=max(op1,max(op2,op3));\\n        // return maxi;\\n        maxi=max(maxi,lefti+righti+root->val);\\n        return max(lefti,righti)+root->val;\\n\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int maxi=INT_MIN;\\n        int result=solve(root,maxi);\\n        return max(maxi,result);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645311,
                "title": "c-easy-and-crisp-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxsum(TreeNode* root, int & maxi){\\n        if(!root) return 0;\\n        int l=max(maxsum(root->left,maxi),0);\\n        int r=max(maxsum(root->right,maxi),0);\\n        maxi=max(maxi,root->val+l+r);\\n        return root->val+max(l,r);\\n    }\\n    int maxPathSum(TreeNode* root){\\n        int maxi=INT_MIN;\\n        maxsum(root,maxi);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxsum(TreeNode* root, int & maxi){\\n        if(!root) return 0;\\n        int l=max(maxsum(root->left,maxi),0);\\n        int r=max(maxsum(root->right,maxi),0);\\n        maxi=max(maxi,root->val+l+r);\\n        return root->val+max(l,r);\\n    }\\n    int maxPathSum(TreeNode* root){\\n        int maxi=INT_MIN;\\n        maxsum(root,maxi);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169589,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int res = INT_MIN;\\n        find_max(root, res);\\n        return res;\\n    }\\n\\n    int find_max(TreeNode* root, int& res) {\\n        if (root == nullptr) return 0;\\n\\n        int left_max = find_max(root->left, res);\\n        int right_max = find_max(root->right, res);\\n\\n        int sum = root->val;\\n        if (left_max > 0) sum += left_max;\\n        if (right_max > 0) sum += right_max;\\n        if (sum > res) res = sum;\\n\\n        int root_max = root->val;\\n        root_max += max(0, max(left_max, right_max));\\n        return root_max;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        self.sum = root.val\\n        def maxHelper( root: Optional[TreeNode]) -> int:\\n            l, r = 0, 0\\n            if root.left != None:\\n                l += maxHelper(root.left)\\n            if root.right != None:\\n                r += maxHelper(root.right)\\n\\n            sum1, sum2 = root.val, root.val\\n            if l > 0:\\n                sum1 += l\\n            if r > 0:\\n                sum1 += r\\n            \\n            if l > 0 or r > 0:\\n                sum2 += l if l > r else r\\n\\n            self.sum = sum2 if self.sum < sum2 else self.sum\\n            self.sum = sum1 if self.sum < sum1 else self.sum\\n            return sum2\\n        if root:\\n            maxHelper(root)\\n        return self.sum\\n```\\n\\n```Java []\\nclass Solution {\\n\\n    int ans = Integer.MIN_VALUE;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxPathSumHelper(root);\\n        return ans;\\n    }\\n\\n    public int maxPathSumHelper(TreeNode root) {\\n\\n         if(root == null) return 0;\\n         int left = maxPathSumHelper(root.left);\\n         int right = maxPathSumHelper(root.right);\\n         int max = Math.max(root.val, Math.max(Math.max(root.val+left, root.val+right), root.val+left+right)); \\n         ans = Math.max(ans, max);\\n        return Math.max(root.val, Math.max(root.val+left, root.val+right));\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int res = INT_MIN;\\n        find_max(root, res);\\n        return res;\\n    }\\n\\n    int find_max(TreeNode* root, int& res) {\\n        if (root == nullptr) return 0;\\n\\n        int left_max = find_max(root->left, res);\\n        int right_max = find_max(root->right, res);\\n\\n        int sum = root->val;\\n        if (left_max > 0) sum += left_max;\\n        if (right_max > 0) sum += right_max;\\n        if (sum > res) res = sum;\\n\\n        int root_max = root->val;\\n        root_max += max(0, max(left_max, right_max));\\n        return root_max;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        self.sum = root.val\\n        def maxHelper( root: Optional[TreeNode]) -> int:\\n            l, r = 0, 0\\n            if root.left != None:\\n                l += maxHelper(root.left)\\n            if root.right != None:\\n                r += maxHelper(root.right)\\n\\n            sum1, sum2 = root.val, root.val\\n            if l > 0:\\n                sum1 += l\\n            if r > 0:\\n                sum1 += r\\n            \\n            if l > 0 or r > 0:\\n                sum2 += l if l > r else r\\n\\n            self.sum = sum2 if self.sum < sum2 else self.sum\\n            self.sum = sum1 if self.sum < sum1 else self.sum\\n            return sum2\\n        if root:\\n            maxHelper(root)\\n        return self.sum\\n```\n```Java []\\nclass Solution {\\n\\n    int ans = Integer.MIN_VALUE;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxPathSumHelper(root);\\n        return ans;\\n    }\\n\\n    public int maxPathSumHelper(TreeNode root) {\\n\\n         if(root == null) return 0;\\n         int left = maxPathSumHelper(root.left);\\n         int right = maxPathSumHelper(root.right);\\n         int max = Math.max(root.val, Math.max(Math.max(root.val+left, root.val+right), root.val+left+right)); \\n         ans = Math.max(ans, max);\\n        return Math.max(root.val, Math.max(root.val+left, root.val+right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042357,
                "title": "postorder-traversal-solution-with-pair-int-int-approach",
                "content": "# Intuition\\nIn this question we have to return maximum the sum of path between any 2 node. So, if we are present at root we have to compare between 3 entity :\\n1. Max path sum in left subtree(if exist).\\n2. Max path sum in right subtree(if exist).\\n3. sum of left, right subtree from node to root with root.\\n\\n# Approach\\nTake helper function pathSum with return type pair<int, int> where first int store the maximum path sum between any two node in a tree and second int store the maximum path sum of any node from the root node either from the left sub tree or right subtree. \\n\\n# Complexity\\n- Time complexity:\\nO(n) : As it traverse all nodes\\n\\n- Space complexity:\\nO(n) : if tree is skew tree.\\nO(logn) : if tree is a binary tree.\\n\\n# Abbreviation\\n\\n1. lpsum : maximum path sum exist between any 2 nodes in left subtree\\n2. rpsum : maximum path sum exist between any 2 nodes in right subtree\\n3. lsum : maximum sum from node to root in left subtree.\\n4. rsum : maximum sum from node to root in right subtree.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    pair<int, int> pathSum(TreeNode* root){\\n        if(root == NULL){\\n            return {INT_MIN, INT_MIN};\\n        }\\n        pair<int, int> leftchild = pathSum(root->left);\\n        pair<int, int> rightchild = pathSum(root->right);\\n        int lpsum = leftchild.first;\\n        int lsum = leftchild.second;\\n        int rpsum = rightchild.first;\\n        int rsum = rightchild.second;\\n        // if leftsum or rightsum is less than 0 then initialise as zero as we don\\'t include that path in it\\n        if(lsum < 0){\\n            lsum = 0;\\n        }\\n        if(rsum < 0){\\n            rsum = 0;\\n        }\\n        int valu = lsum+rsum+root->val;\\n        int maxpsum = max(lpsum, max(rpsum, valu));\\n        return {maxpsum, max(lsum,rsum)+root->val};\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        pair<int, int> ans = pathSum(root);\\n        return ans.first;\\n    }\\n};\\n```\\n\\nPlease do UPVOTE if you like it !!",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int, int> pathSum(TreeNode* root){\\n        if(root == NULL){\\n            return {INT_MIN, INT_MIN};\\n        }\\n        pair<int, int> leftchild = pathSum(root->left);\\n        pair<int, int> rightchild = pathSum(root->right);\\n        int lpsum = leftchild.first;\\n        int lsum = leftchild.second;\\n        int rpsum = rightchild.first;\\n        int rsum = rightchild.second;\\n        // if leftsum or rightsum is less than 0 then initialise as zero as we don\\'t include that path in it\\n        if(lsum < 0){\\n            lsum = 0;\\n        }\\n        if(rsum < 0){\\n            rsum = 0;\\n        }\\n        int valu = lsum+rsum+root->val;\\n        int maxpsum = max(lpsum, max(rpsum, valu));\\n        return {maxpsum, max(lsum,rsum)+root->val};\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        if(root == NULL){\\n            return 0;\\n        }\\n        pair<int, int> ans = pathSum(root);\\n        return ans.first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900629,
                "title": "c-stacks-and-queue-modifying-tree-value",
                "content": "# Intuition\\nStart from bottom.\\nAt a node, there are 3 options:\\n* Choose the left path (left sum - lc)\\n* Choose the right path (right sum - rc)\\n* Choosing none (0)\\n\\nThe path is selected by checking the maximum value of these 3 options.\\nAdding the sum to node\\'s value acts like selecting a maximum sum path.\\n\\nBends can be handled easily just by adding left value , right value and node value for the node.\\n\\nThe maximum of all values for all nodes is our answer.\\n\\n# Approach\\nStore the nodes in a stack in level wise order (Bottom first and right to left)\\nPop and store elements from this stack. Make a variable that stores the sum of paths that have bends in them.\\nUpdate the node\\'s value by adding the larger of left path sum and right path sum(making sure new value is a greater value). \\nThe new result will be maximum of bended value, the node value and old result.\\n\\nWhen the stack is finished, res will return the maximum path sum.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        queue<TreeNode*> level;\\n        level.push(root);\\n        while(!level.empty()){\\n            TreeNode* temp = level.front();\\n            level.pop();\\n            st.push(temp);\\n            if(temp->left){\\n                level.push(temp->left);\\n            }\\n            if(temp->right){\\n                level.push(temp->right);\\n            }\\n        }\\n        int res=INT_MIN;\\n        while(!st.empty()){\\n            TreeNode* temp = st.top();\\n            st.pop();\\n            int lc = temp->left? temp->left->val : 0;\\n            int rc = temp->right? temp->right->val : 0;\\n            int bend = lc + rc + temp->val;\\n            temp->val += max(0,max(lc,rc));\\n            res = max(bend,max(res,temp->val));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        queue<TreeNode*> level;\\n        level.push(root);\\n        while(!level.empty()){\\n            TreeNode* temp = level.front();\\n            level.pop();\\n            st.push(temp);\\n            if(temp->left){\\n                level.push(temp->left);\\n            }\\n            if(temp->right){\\n                level.push(temp->right);\\n            }\\n        }\\n        int res=INT_MIN;\\n        while(!st.empty()){\\n            TreeNode* temp = st.top();\\n            st.pop();\\n            int lc = temp->left? temp->left->val : 0;\\n            int rc = temp->right? temp->right->val : 0;\\n            int bend = lc + rc + temp->val;\\n            temp->val += max(0,max(lc,rc));\\n            res = max(bend,max(res,temp->val));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900612,
                "title": "c-begineer-friendly-easy-understanding-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/IIn-jtjniXw\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int sum =INT_MIN;\\n\\n    int maxPathSum(TreeNode* root) {\\n\\n        calcualteMaxPathSum(root);\\n        return sum;\\n\\n    }\\n    // max sum path including root of the tree.\\n    int calcualteMaxPathSum(TreeNode* root){\\n        if(root == NULL) return 0;\\n\\n        //if lhsum is comming -ve so we will return 0;\\n\\n      int  lhsum = max(0,calcualteMaxPathSum(root->left));\\n      int  rhsum = max(0,calcualteMaxPathSum(root->right));\\n\\n\\n        //updating the value in the sum.. // maximum sum upto now.(can be subtree sum)\\n        sum = max(sum,root->val+lhsum+rhsum);\\n\\n\\n        //returning the maxximum sum possible.. using which path.\\n        return max(lhsum,rhsum) + root->val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int sum =INT_MIN;\\n\\n    int maxPathSum(TreeNode* root) {\\n\\n        calcualteMaxPathSum(root);\\n        return sum;\\n\\n    }\\n    // max sum path including root of the tree.\\n    int calcualteMaxPathSum(TreeNode* root){\\n        if(root == NULL) return 0;\\n\\n        //if lhsum is comming -ve so we will return 0;\\n\\n      int  lhsum = max(0,calcualteMaxPathSum(root->left));\\n      int  rhsum = max(0,calcualteMaxPathSum(root->right));\\n\\n\\n        //updating the value in the sum.. // maximum sum upto now.(can be subtree sum)\\n        sum = max(sum,root->val+lhsum+rhsum);\\n\\n\\n        //returning the maxximum sum possible.. using which path.\\n        return max(lhsum,rhsum) + root->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899155,
                "title": "javascript-dfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar maxPathSum = function (root) {\\n  const ans = { val: -Infinity };\\n  dfs(root, ans);\\n\\n  return ans.val;\\n};\\n\\nfunction dfs(root, ans) {\\n  if (!root) return 0;\\n\\n  const left = dfs(root.left, ans);\\n  const right = dfs(root.right, ans);\\n\\n  const maxVal = Math.max(root.val, root.val + left, root.val + right);\\n  ans.val = Math.max(ans.val, maxVal, root.val + left + right);\\n\\n  return maxVal;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar maxPathSum = function (root) {\\n  const ans = { val: -Infinity };\\n  dfs(root, ans);\\n\\n  return ans.val;\\n};\\n\\nfunction dfs(root, ans) {\\n  if (!root) return 0;\\n\\n  const left = dfs(root.left, ans);\\n  const right = dfs(root.right, ans);\\n\\n  const maxVal = Math.max(root.val, root.val + left, root.val + right);\\n  ans.val = Math.max(ans.val, maxVal, root.val + left + right);\\n\\n  return maxVal;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2899116,
                "title": "java-code-solution-it-works",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) as we have to traverse all of the nodes in the tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) as we are using a recursion stack.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    int maxsum;\\n    public int maxPathSum(TreeNode root) {\\n        maxsum = Integer.MIN_VALUE;\\n        maxPathSumUtil(root);\\n        return maxsum;\\n    }\\n    \\n    public int maxPathSumUtil(TreeNode root){\\n        if(root==null) return 0;\\n        int leftMaxSum = Math.max(0,maxPathSumUtil(root.left));\\n        int rightMaxSum = Math.max(0,maxPathSumUtil(root.right));\\n        \\n        maxsum = Math.max(maxsum, root.val+leftMaxSum+rightMaxSum);\\n        return root.val+Math.max(leftMaxSum, rightMaxSum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    int maxsum;\\n    public int maxPathSum(TreeNode root) {\\n        maxsum = Integer.MIN_VALUE;\\n        maxPathSumUtil(root);\\n        return maxsum;\\n    }\\n    \\n    public int maxPathSumUtil(TreeNode root){\\n        if(root==null) return 0;\\n        int leftMaxSum = Math.max(0,maxPathSumUtil(root.left));\\n        int rightMaxSum = Math.max(0,maxPathSumUtil(root.right));\\n        \\n        maxsum = Math.max(maxsum, root.val+leftMaxSum+rightMaxSum);\\n        return root.val+Math.max(leftMaxSum, rightMaxSum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616820,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode *root, int &ans){\\n        if(root==nullptr) return 0;        \\n        int l = solve(root->left, ans);\\n        int r = solve(root->right, ans);\\n        int v = root->val;\\n        ans = max({ans, v, r+l+v, r+v, l+v});\\n        return max(max(r,l)+v, v);\\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n        int ans=-1001;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode *root, int &ans){\\n        if(root==nullptr) return 0;        \\n        int l = solve(root->left, ans);\\n        int r = solve(root->right, ans);\\n        int v = root->val;\\n        ans = max({ans, v, r+l+v, r+v, l+v});\\n        return max(max(r,l)+v, v);\\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n        int ans=-1001;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485475,
                "title": "python-what-is-a-path-intuition-for-the-problem",
                "content": "This problem is a mash up of\\n* https://leetcode.com/problems/maximum-depth-of-binary-tree/ BT height/width\\n* https://leetcode.com/problems/diameter-of-binary-tree/ BT height/width\\n* https://leetcode.com/problems/maximum-subarray/ Kadane\\'s algo applied to a tree\\n* https://leetcode.com/problems/longest-univalue-path/ BT path\\n\\nIf you understand all of the above, there\\'s nothing to solve here.\\n\\nThe crux of the problem is the \"path\" definition. A few examples what\\'s path and what\\'s not.\\nAs it\\'s said \"a picture is worth a thousand words\":\\n\\n**What is a path here?**\\n\\nYou can imagine a path as a road (set of nodes). You can turn left or right. But you **cannot turn left and right** at the same time. Path can be a single node, or it can be a linked-list like skewed tree. It can start anywhere and also end in the middle of the tree.\\n\\n![image](https://assets.leetcode.com/users/images/d5202c73-011e-4ecd-bd23-02979540997e_1661544784.4822035.png)\\n\\n**How to solve the problem with a few examples?**\\n\\nWe are going to build and check paths from the tree leaves and up to the root, from bottom to top.\\n\\nWe\\'ll need to use a **post order traversal** for this. (offtop: btw, the same idea with Binary Tree Cameras problem)\\nWhy?\\n\\nPost-order processing: *process left subtree paths*, *process right subtree paths*, and only then **process root**.\\n\\nBecause in order to make a decision - \"pick the left subtree path or pick the right subtree path\", we need to know information from the node children beforehand.\\n\\n```\\nleft_path_sum = postorder(node.left)\\nright_path_sum = postorder(node.right)\\n\\n# info processing code\\n```\\n\\nWe have info from the left subtree, the right subtree and the node - so we can make some decision about path building. \\n\\n**How Kadane\\'s algo ideas and max sum are related to the problem?**\\n\\nLet\\'s look at examples where we need to make decisions:\\n\\n**Case #1**\\nYellow node needs to decide if it\\'s going to join the path from left subtree or from the right subtree.\\n\\n![image](https://assets.leetcode.com/users/images/49e5b58c-a7f4-4bc2-8763-05ee288adcef_1661548368.0108829.png)\\n\\nHere it\\'s easy: pick the one with the max sum. In our case:\\n\\n80 + 0 vs 5+100 + 0\\n\\nObviously we choose 105 and form a path 5->100->0.\\n\\nLogic to handle the case:\\n```\\npath_sum = max(left_path_sum + node.val, right_path_sum + node.val)\\n```\\n\\n**Case #2**\\nYellow node needs to decide if it\\'s going to join the path from left subtree or from the right subtree.\\nNow what heppens in this case???\\n\\n![image](https://assets.leetcode.com/users/images/ddd7e50f-a496-4ad3-93e0-32a5d58ab770_1661549406.0686157.png)\\n\\nPick the one with the max sum... but wait! left path sum = -50, right path sum = -85\\n\\n-50 vs -85\\n\\nWhich one is the best???\\n\\n**NEITHER!!!**\\n\\nLet\\'s see what\\'s going on: building a path with the left path is -50+100 = 50. With the right path is -85+100 = 15.\\n\\nHere\\'s where the idea from Kadane\\'s algo come into play...\\nWe choose neither and start building the path from scratch from the node that we have.\\n\\n-50 vs -85 **vs 100**\\n\\nLogic to handle the cases 1-2:\\n```\\npath_sum = max(node.val, left_path_sum + node.val, right_path_sum + node.val)\\n```\\n\\nRemember about \"**cannot turn left and right** at the same time\"? That is where we decide how we build the path - join left part or right. So we have the option #3: start building a path from scratch from the node.\\n\\n**Case with only negative numbers**\\nWhat if we have negative values. Only negative values.\\n\\n![image](https://assets.leetcode.com/users/images/23e815ce-ef90-4792-a2f2-1385d097e4a5_1661550144.2250712.png)\\n\\nIn this case logic from case #2 will handle the case. How?\\n\\nEvery time the node see\\'s that there\\'s an option to build a new better path with max sum from scratch, it will do it. Pick max from (node_left_path + node.val, node_right_path + node.val, node.val)\\n\\nThis way we will have the following paths: -100, -15, -50, -200. Pick the max values from the paths.\\n\\n---\\n\\n**There is one more important case #3**\\nGoing back to our case #1 example:\\n\\nBut is this the max possible path where the node \"0\" is a part of?\\nSo far we checked the following path: 5, 5+100, 5+100+0, 80, 80+0.\\n\\n![image](https://assets.leetcode.com/users/images/49e5b58c-a7f4-4bc2-8763-05ee288adcef_1661548368.0108829.png)\\n\\n*Here it\\'s easy: pick the one with the max sum. In our case:*\\n*80 + 0 vs 5+100 + 0*\\n*Obviously we choose 105 and form a path 5->100->0.*\\n\\nBut is this the max path sum???\\n\\n---\\n!!!\\nThe most important part of the problem is to understand that the path can be not only **root -> left path** or **root -> right path**, **BUT** path can also **go through the node itself** starting from the **left path -> subtree root -> the right path**.\\n!!!\\n\\n---\\n\\nYes. this is a valid path too. It does not \"turn left and right at the same time\" and gives us the max path sum for the node \"0\".\\n\\n![image](https://assets.leetcode.com/users/images/5368634d-0889-4576-8621-e1a0f6dde6a0_1661551187.5639656.png)\\n\\nHere it\\'s **not that** easy: pick the one with left + root + right paths. In our case:\\n80 + 0 vs 5+100 + 0 **vs 80 + 0 + 5 + 100**\\nObviously we choose max 185 and form a path 80->0->100->5*.\\n\\nHow do we handle the logic? The way we described it with words:\\n\\n```\\n# pick max from current_node or left_path + current_node or right_path + current_node\\npath_sum = max(current_node.val, left_path_sum + current_node.val, right_path_sum + current_node.val) # cases 1-2\\n\\n# pick global max path sum: it\\'s either the \\'path_sum\\' or \\'left_path_sum + current_node + right_path_sum\\'\\nself.max_path_sum = max(self.max_path_sum, path_sum, left + right + node.val) # case 3\\n```\\n\\nThat\\'s it!\\n\\nThe full source code for the problem:\\n\\n```\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        def postorder(node):\\n            if not node: # no node - no value, aka the empty sum = 0\\n                return 0\\n            \\n            left = postorder(node.left) # get left max path sum\\n            right = postorder(node.right) # get right max path sum\\n            \\n\\t\\t\\t# pick max from (current_node_only, left_path + current_node, right_path + current_node)\\n\\t\\t\\t# \\'local node\\' max path sum\\n            path_sum = max(node.val, max(left, right) + node.val)\\n\\t\\t\\t\\n\\t\\t\\t# pick global max path: it\\'s either the \\'path_sum\\' or \\'left_path_sum + current_node + right_path_sum\\'\\n\\t\\t\\t# \\'global\\' max path sum\\n            self.max_path_sum = max(self.max_path_sum, path_sum, left + right + node.val)\\n            \\n\\t\\t\\t# return current path max sum - local max_sum\\n            return path_sum\\n\\n\\t\\t# we might have negative path sum only trees, so use \"-infinity\"\\n        self.max_path_sum = float(-inf)\\n        postorder(root) # find the \\'global\\' max path sum\\n        return self.max_path_sum\\n```\\n\\nThat\\'s it!\\n\\nOK. More like dp on trees approach without the \"global/local\" variable.\\n```\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        def postorder(node):\\n            if not node:\\n                return (float(-inf),0) # global_max_path_sum, path_sum\\n            \\n            left = postorder(node.left)\\n            right = postorder(node.right)\\n            \\n            path_sum = max(node.val, max(left[1],right[1]) + node.val)\\n            max_path_sum = max(left[0], right[0], path_sum, left[1] + right[1] + node.val)\\n            \\n            return (max_path_sum, path_sum)\\n        \\n        return postorder(root)[0]\\n```\\n\\n( \\u25D1\\u203F\\u25D1)\\u0254\\u250F\\uD83C\\uDF5F--\\uD83C\\uDF54\\u2511\\u0669(^\\u25E1^ )\\n\\nIf you liked the read, **upvote so the other people can see it too.**\\n\\nP.S. I think after solving \"Binary Tree Cameras\" I mastered the post order traversl that I can now do anything with it.\\n\\nP.P.S. https://leetcode.com/problems/diameter-of-binary-tree/ and this one has quite copy+paste like code. The intuition is different: find \"node\\'s left height + right height + 1\" vs \"max path sum between any 2 nodes\"",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nleft_path_sum = postorder(node.left)\\nright_path_sum = postorder(node.right)\\n\\n# info processing code\\n```\n```\\npath_sum = max(left_path_sum + node.val, right_path_sum + node.val)\\n```\n```\\npath_sum = max(node.val, left_path_sum + node.val, right_path_sum + node.val)\\n```\n```\\n# pick max from current_node or left_path + current_node or right_path + current_node\\npath_sum = max(current_node.val, left_path_sum + current_node.val, right_path_sum + current_node.val) # cases 1-2\\n\\n# pick global max path sum: it\\'s either the \\'path_sum\\' or \\'left_path_sum + current_node + right_path_sum\\'\\nself.max_path_sum = max(self.max_path_sum, path_sum, left + right + node.val) # case 3\\n```\n```\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        def postorder(node):\\n            if not node: # no node - no value, aka the empty sum = 0\\n                return 0\\n            \\n            left = postorder(node.left) # get left max path sum\\n            right = postorder(node.right) # get right max path sum\\n            \\n\\t\\t\\t# pick max from (current_node_only, left_path + current_node, right_path + current_node)\\n\\t\\t\\t# \\'local node\\' max path sum\\n            path_sum = max(node.val, max(left, right) + node.val)\\n\\t\\t\\t\\n\\t\\t\\t# pick global max path: it\\'s either the \\'path_sum\\' or \\'left_path_sum + current_node + right_path_sum\\'\\n\\t\\t\\t# \\'global\\' max path sum\\n            self.max_path_sum = max(self.max_path_sum, path_sum, left + right + node.val)\\n            \\n\\t\\t\\t# return current path max sum - local max_sum\\n            return path_sum\\n\\n\\t\\t# we might have negative path sum only trees, so use \"-infinity\"\\n        self.max_path_sum = float(-inf)\\n        postorder(root) # find the \\'global\\' max path sum\\n        return self.max_path_sum\\n```\n```\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        def postorder(node):\\n            if not node:\\n                return (float(-inf),0) # global_max_path_sum, path_sum\\n            \\n            left = postorder(node.left)\\n            right = postorder(node.right)\\n            \\n            path_sum = max(node.val, max(left[1],right[1]) + node.val)\\n            max_path_sum = max(left[0], right[0], path_sum, left[1] + right[1] + node.val)\\n            \\n            return (max_path_sum, path_sum)\\n        \\n        return postorder(root)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309746,
                "title": "go-26-lines-o-n",
                "content": "```\\nfunc maxPathSum(root *TreeNode) int {\\n    globalMax := -1<<63\\n    dfs(root, &globalMax)\\n    return globalMax\\n}\\n\\nfunc dfs(root *TreeNode, globalMax *int) int {\\n    if root == nil {\\n        return 0\\n    }\\n\\n    pathSumFromLeft := max(dfs(root.Left, globalMax), 0)\\n    pathSumFromRight := max(dfs(root.Right, globalMax), 0)\\n    \\n    *globalMax = max(*globalMax, root.Val + pathSumFromLeft + pathSumFromRight)\\n    \\n    return root.Val + max(pathSumFromLeft, pathSumFromRight) \\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nfunc maxPathSum(root *TreeNode) int {\\n    globalMax := -1<<63\\n    dfs(root, &globalMax)\\n    return globalMax\\n}\\n\\nfunc dfs(root *TreeNode, globalMax *int) int {\\n    if root == nil {\\n        return 0\\n    }\\n\\n    pathSumFromLeft := max(dfs(root.Left, globalMax), 0)\\n    pathSumFromRight := max(dfs(root.Right, globalMax), 0)\\n    \\n    *globalMax = max(*globalMax, root.Val + pathSumFromLeft + pathSumFromRight)\\n    \\n    return root.Val + max(pathSumFromLeft, pathSumFromRight) \\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2130341,
                "title": "simple-clean-faster-than-95-c",
                "content": "The code is self explanatory ! Have a look : ) \\n```\\nclass Solution {\\npublic:\\n    \\n    int maxi = INT_MIN;    // store the maximum \\n    int sum(TreeNode *root){\\n        if(!root)return 0;\\n        \\n        int a = sum(root->right);  // maximum path *starting* from root->right \\n        int b = sum(root->left);   // maximum path *starting* from root->right\\n        \\n        maxi = max({maxi,root->val,root->val+a,root->val+b,root->val+a+b});\\n        return max({root->val,root->val+a,root->val+b});  // return maximum path starting from root itself \\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n      int _ = sum(root);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxi = INT_MIN;    // store the maximum \\n    int sum(TreeNode *root){\\n        if(!root)return 0;\\n        \\n        int a = sum(root->right);  // maximum path *starting* from root->right \\n        int b = sum(root->left);   // maximum path *starting* from root->right\\n        \\n        maxi = max({maxi,root->val,root->val+a,root->val+b,root->val+a+b});\\n        return max({root->val,root->val+a,root->val+b});  // return maximum path starting from root itself \\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n      int _ = sum(root);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954827,
                "title": "recursion-easy-to-unuderstand-c",
                "content": "```class Solution {\\npublic:\\n    int ans=INT_MIN;\\n    int maxPathSum(TreeNode* root) {\\n        solve(root,ans);\\n        return ans;\\n    }\\n    \\n    int solve(TreeNode* root,int &ans)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        int left=solve(root->left,ans);\\n        int right=solve(root->right,ans);\\n        ans=max({ans,left+right+root->val,left+root->val,right+root->val,root->val});\\n        return max({root->val,root->val+left,root->val+right});\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int ans=INT_MIN;\\n    int maxPathSum(TreeNode* root) {\\n        solve(root,ans);\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1775976,
                "title": "divide-and-conquer-method-in-python-time-o-n-explained-very-clearly",
                "content": "**Divide and Conquer**!\\n\\nFirst we need to understand when reaching a node, what should we compare and return.\\n\\n**For example:**\\na tree like this\\n```\\n     [5]\\n   [3, 6]\\n[2, 7, -8, -9]\\n```\\n\\nSuppose now we are at level 1, we need to compare **three** possible cases:\\n* maximum path sum of the **left subtree of 5** (3 as a root)\\n\\twhich is [2, 3, 7] in our example\\n* maximum path sum of the **right subtree of 5** (6 as a root)\\n\\twhich is [6] in our example\\n* maximum path sum of the tree 5 that **includes root 5 in the path**\\n\\nNow the question comes to, how could we get the maximum path sum of the tree 5 that includes root 5 in the path?\\nThe answer should be: We need to know the **left maximum chain**  and **the right maximum chain**!\\n**In the example**, it should be:\\n* left maximum chain: [3, 7]\\n* right maximum chain: [6]\\n\\n**The requirement of maximum chain** is that: it must include the root, and can only goes one direction down, in our example:\\n* left maximum chain: from [3, 7], [3, 2], and [3], we choose [3, 7]\\n* right maximum chain: from [6, -8], [6, -9], and [6], we choose [6]\\n\\nSo, maximum path sum of the tree 5 that includes root 5 should be [3, 7, 5, 6]:\\nleft maximum chain [3, 7] + root 5 + right maximum chain [6]\\n\\nSo now, we understand that, at each subtree of the divide and conquer helper function, we need to **return two things**:\\n* **maximum path sum** of this subtree\\n* **maximum path chain** that includes root of this subtree\\n\\n**Time:** O(n)\\n**Space:** O(H), to keep the recursion stack, H is the height of the binary tree, worst case O(n)\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        \\n        max_sum, _ = self.divideConquer(root)\\n        return max_sum\\n    \\n    def divideConquer(self, node):\\n\\n        if not node:\\n            return float(\\'-inf\\'), 0\\n        \\n        # Divide and conquer, return the maximum path of both left and right subtree of root node, and also return the maximum path chain of both left and right subtree of root node\\n        left_sum, left_chain = self.divideConquer(node.left)\\n        right_sum, right_chain = self.divideConquer(node.right)\\n        \\n        # If any maximum path chain is negative, we will update it to 0, meaning that we will not go down that chain\\n        left_chain = max(left_chain, 0)\\n        right_chain = max(right_chain, 0)\\n\\n        # Construct the maximum path that includes root node\\n        root_sum = node.val + left_chain + right_chain\\n\\n        # Now compare three possible cases, that is\\n        # maximum path sum of the left subtree, maximum path sum of the right subtree, and maximum path sum of the current tree that includes root  \\n        max_sum = max(left_sum, right_sum, root_sum)\\n\\n        # We also need to return the maximum path chain of the current tree\\n        max_chain = max(left_chain, right_chain) + node.val\\n        \\n        return max_sum, max_chain\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\n     [5]\\n   [3, 6]\\n[2, 7, -8, -9]\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        \\n        max_sum, _ = self.divideConquer(root)\\n        return max_sum\\n    \\n    def divideConquer(self, node):\\n\\n        if not node:\\n            return float(\\'-inf\\'), 0\\n        \\n        # Divide and conquer, return the maximum path of both left and right subtree of root node, and also return the maximum path chain of both left and right subtree of root node\\n        left_sum, left_chain = self.divideConquer(node.left)\\n        right_sum, right_chain = self.divideConquer(node.right)\\n        \\n        # If any maximum path chain is negative, we will update it to 0, meaning that we will not go down that chain\\n        left_chain = max(left_chain, 0)\\n        right_chain = max(right_chain, 0)\\n\\n        # Construct the maximum path that includes root node\\n        root_sum = node.val + left_chain + right_chain\\n\\n        # Now compare three possible cases, that is\\n        # maximum path sum of the left subtree, maximum path sum of the right subtree, and maximum path sum of the current tree that includes root  \\n        max_sum = max(left_sum, right_sum, root_sum)\\n\\n        # We also need to return the maximum path chain of the current tree\\n        max_chain = max(left_chain, right_chain) + node.val\\n        \\n        return max_sum, max_chain\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454245,
                "title": "postorder-traversal-kadane-algortihm-commented",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int res = INT_MIN;\\n    \\n    int traverse(TreeNode *root){\\n        if(!root) return 0;\\n        \\n        int left = traverse(root->left);\\n        int right = traverse(root->right);\\n        \\n        // same as kadane\\'s algo. if negative, make 0\\n        left = (left < 0) ? 0 : left;\\n        right = (right < 0) ? 0 : right;\\n        \\n        // max sum will be root data + left sum + right sum\\n        res = max(res, root->val + left + right);\\n        \\n        // we need path\\'s sum not whole subtree sum; so, return only max sum from left or right\\n        return root->val + max(left, right);\\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n        traverse(root);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int res = INT_MIN;\\n    \\n    int traverse(TreeNode *root){\\n        if(!root) return 0;\\n        \\n        int left = traverse(root->left);\\n        int right = traverse(root->right);\\n        \\n        // same as kadane\\'s algo. if negative, make 0\\n        left = (left < 0) ? 0 : left;\\n        right = (right < 0) ? 0 : right;\\n        \\n        // max sum will be root data + left sum + right sum\\n        res = max(res, root->val + left + right);\\n        \\n        // we need path\\'s sum not whole subtree sum; so, return only max sum from left or right\\n        return root->val + max(left, right);\\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n        traverse(root);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361330,
                "title": "java-faster-than-100",
                "content": "```\\npublic class BinaryTreeMaximumPathSumProblem {\\n\\n    int maxSum = Integer.MIN_VALUE;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum(root);\\n\\n        return maxSum;\\n    }\\n\\n    /*\\n    Steps:\\n    1. check for edge case [null node]\\n    2. calculate left and right sum by recursively calling the child nodes\\n    3. store currSum as the sum of node value, left and right sum\\n    4. update the max sum if current sum is greater\\n    5. return the sum of node value and max of left/right node\\n\\n    Time complexity: O(N), where N is number of nodes, since we visit each node not more than 2 times.\\n\\n    Space complexity: O(H), where H is a tree height, to keep the recursion stack. \\n    In the average case of balanced tree, the tree height H = logN, in the worst case of skewed tree, H=N.\\n    */\\n    public int maxSum(TreeNode node) {\\n\\n        if (node == null) return 0;\\n\\n        int leftSum = Math.max(maxSum(node.left), 0);\\n        int rightSum = Math.max(maxSum(node.right), 0);\\n\\n        int currSum = node.val + leftSum + rightSum;\\n\\n        if (currSum > maxSum) maxSum = currSum;\\n\\n        return node.val + Math.max(leftSum, rightSum);\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/b414232c-f008-4cc8-8200-6689b908d8f6_1627197889.2321608.png)\\n",
                "solutionTags": [],
                "code": "```\\npublic class BinaryTreeMaximumPathSumProblem {\\n\\n    int maxSum = Integer.MIN_VALUE;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum(root);\\n\\n        return maxSum;\\n    }\\n\\n    /*\\n    Steps:\\n    1. check for edge case [null node]\\n    2. calculate left and right sum by recursively calling the child nodes\\n    3. store currSum as the sum of node value, left and right sum\\n    4. update the max sum if current sum is greater\\n    5. return the sum of node value and max of left/right node\\n\\n    Time complexity: O(N), where N is number of nodes, since we visit each node not more than 2 times.\\n\\n    Space complexity: O(H), where H is a tree height, to keep the recursion stack. \\n    In the average case of balanced tree, the tree height H = logN, in the worst case of skewed tree, H=N.\\n    */\\n    public int maxSum(TreeNode node) {\\n\\n        if (node == null) return 0;\\n\\n        int leftSum = Math.max(maxSum(node.left), 0);\\n        int rightSum = Math.max(maxSum(node.right), 0);\\n\\n        int currSum = node.val + leftSum + rightSum;\\n\\n        if (currSum > maxSum) maxSum = currSum;\\n\\n        return node.val + Math.max(leftSum, rightSum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122979,
                "title": "java-0ms-all-test-cases-covered",
                "content": "```\\nclass Solution {\\n    int pathsum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        path_sum(root);\\n        return pathsum;\\n    }\\n    int path_sum(TreeNode node){\\n        if(node==null){\\n            return 0;\\n        }\\n        \\n        int left= path_sum(node.left);\\n        int right= path_sum(node.right);\\n        \\n        pathsum= Math.max(node.val, Math.max(node.val + left, Math.max(node.val + right, Math.max(node.val+left+right, pathsum))));\\n        \\n        return Math.max(node.val, Math.max(node.val + left, node.val+right));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int pathsum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        path_sum(root);\\n        return pathsum;\\n    }\\n    int path_sum(TreeNode node){\\n        if(node==null){\\n            return 0;\\n        }\\n        \\n        int left= path_sum(node.left);\\n        int right= path_sum(node.right);\\n        \\n        pathsum= Math.max(node.val, Math.max(node.val + left, Math.max(node.val + right, Math.max(node.val+left+right, pathsum))));\\n        \\n        return Math.max(node.val, Math.max(node.val + left, node.val+right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 924563,
                "title": "concise-java-solution-using-dfs-beats-100",
                "content": "```\\nclass Solution {\\n    \\n    private int result;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        \\n        result = Integer.MIN_VALUE;\\n        \\n        getMaxSum(root);\\n        \\n        return result;\\n    }\\n    \\n    private int getMaxSum(TreeNode node)\\n    {\\n        if (node == null)\\n            return 0;\\n        \\n        int leftSum = getMaxSum(node.left);\\n        int rightSum = getMaxSum(node.right);\\n        \\n        result = Math.max(result, node.val + leftSum + rightSum);\\n        \\n        // We will not count the path if the max path sum is less than zero\\n        return Math.max(0, node.val + Math.max(leftSum, rightSum));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private int result;\\n    \\n    public int maxPathSum(TreeNode root) {\\n        \\n        result = Integer.MIN_VALUE;\\n        \\n        getMaxSum(root);\\n        \\n        return result;\\n    }\\n    \\n    private int getMaxSum(TreeNode node)\\n    {\\n        if (node == null)\\n            return 0;\\n        \\n        int leftSum = getMaxSum(node.left);\\n        int rightSum = getMaxSum(node.right);\\n        \\n        result = Math.max(result, node.val + leftSum + rightSum);\\n        \\n        // We will not count the path if the max path sum is less than zero\\n        return Math.max(0, node.val + Math.max(leftSum, rightSum));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767082,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int sum=INT_MIN;\\n        helper(root,sum);\\n        return sum;\\n    }\\n    int helper(TreeNode* root, int &sum)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        int l=max(0,helper(root->left,sum));\\n        int r=max(0,helper(root->right,sum));\\n        \\n        sum=max(sum, root->val+l+r);\\n        return (root->val +max(l,r));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int sum=INT_MIN;\\n        helper(root,sum);\\n        return sum;\\n    }\\n    int helper(TreeNode* root, int &sum)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        int l=max(0,helper(root->left,sum));\\n        int r=max(0,helper(root->right,sum));\\n        \\n        sum=max(sum, root->val+l+r);\\n        return (root->val +max(l,r));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727545,
                "title": "super-easy-python-o-n-time-single-traversal",
                "content": "\\n**Super Easy - Python - O(n) Time (Single Traversal)**\\n\\nSimple Code Performing a One-Time Traversal through the Binary Tree with O(n) Time Complexity . The bulk of the work is made by the internal MaxPath function.\\n\\nMaxPath function highlights:\\n\\n1. Each call to the function MaxPath(node) returns the branch with the highest sum starting from \"node\".\\n2. The best path possible is calculated as an in-between move, by attempting to join the left and right branches into one arc.\\n3. Any negative values for the \"left\" and \"right\" branches are ignored, as if they hadn\\'t existed.\\n\\nI think this problem should be \"Medium\" difficulty with all due respect. Cheers,\\n\\n```\\nfmax = lambda x,y: x if x>y else y # Custom Max Function (33% Faster than Python\\'s Built-in Max function)\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        self.result = root.val\\n        def maxpath(node):\\n            if not node:\\n                return 0\\n            x = node.val\\n            l = fmax(0,maxpath(node.left )) # ignore \"left\" branch if negative\\n            r = fmax(0,maxpath(node.right)) # ignore \"right\" branch if negative\\n            self.result = fmax(self.result, x+l+r ) # Check if merged arc-path (left+node+right) beats the current result\\n            return fmax(x+l,x+r) # Try to build maximum branch value\\n        maxpath(root)\\n        return self.result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfmax = lambda x,y: x if x>y else y # Custom Max Function (33% Faster than Python\\'s Built-in Max function)\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        self.result = root.val\\n        def maxpath(node):\\n            if not node:\\n                return 0\\n            x = node.val\\n            l = fmax(0,maxpath(node.left )) # ignore \"left\" branch if negative\\n            r = fmax(0,maxpath(node.right)) # ignore \"right\" branch if negative\\n            self.result = fmax(self.result, x+l+r ) # Check if merged arc-path (left+node+right) beats the current result\\n            return fmax(x+l,x+r) # Try to build maximum branch value\\n        maxpath(root)\\n        return self.result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 673314,
                "title": "easy-to-understand-c",
                "content": "```\\nclass Solution {\\n   int res;\\n    public:\\n    int maxPathSum(TreeNode* root) {\\n        res = INT_MIN;\\n        call(root);\\n        return res;\\n    }\\n    int call(TreeNode* root)\\n    {\\n        if(root==NULL)return 0;\\n        int l = call(root->left);\\n        int r = call(root->right);\\n        int data_without = max(root->val,max(l,r)+root->val);\\n        int data_with = max(data_without, l+r+root->val);\\n        res = max(res,data_with);\\n        return data_without;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\n   int res;\\n    public:\\n    int maxPathSum(TreeNode* root) {\\n        res = INT_MIN;\\n        call(root);\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 611877,
                "title": "in-c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\\n\\nint maxPathSumInt(struct TreeNode* root, int *max)\\n{\\n    if (root == NULL) {\\n        return 0;\\n    }\\n    \\n    int left = maxPathSumInt(root->left, max);\\n    int right = maxPathSumInt(root->right, max);\\n    \\n    left = MAX(left, 0);\\n    right = MAX(right, 0);\\n\\n    // XXX: what about int overflows?\\n    int curr = left + root->val + right;\\n    *max = MAX(*max, curr);\\n\\n    return root->val + MAX(left, right);\\n}\\n    \\n\\nint maxPathSum(struct TreeNode* root)\\n{\\n    int max = INT_MIN;\\n    maxPathSumInt(root, &max);\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\\n\\nint maxPathSumInt(struct TreeNode* root, int *max)\\n{\\n    if (root == NULL) {\\n        return 0;\\n    }\\n    \\n    int left = maxPathSumInt(root->left, max);\\n    int right = maxPathSumInt(root->right, max);\\n    \\n    left = MAX(left, 0);\\n    right = MAX(right, 0);\\n\\n    // XXX: what about int overflows?\\n    int curr = left + root->val + right;\\n    *max = MAX(*max, curr);\\n\\n    return root->val + MAX(left, right);\\n}\\n    \\n\\nint maxPathSum(struct TreeNode* root)\\n{\\n    int max = INT_MIN;\\n    maxPathSumInt(root, &max);\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 603612,
                "title": "java-easy-o-n-solution",
                "content": "```\\nclass Solution {\\n    int max = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n       if (root!=null) maxPath(root);\\n        return max;\\n    }\\n    public void maxPath(TreeNode root) {\\n        int current = root.val;\\n          max = Math.max(max, current);\\n        if (root.right!=null){\\n            maxPath(root.right);\\n            root.val = Math.max(root.val, current+root.right.val);\\n            max = Math.max(max, current+root.right.val);\\n        } \\n        if (root.left!=null) {\\n            maxPath(root.left);\\n            root.val = Math.max(root.val, current+root.left.val);\\n            max = Math.max(max, current+root.left.val);\\n        }\\n        if (root.right!=null && root.left!=null){\\n          max = Math.max(max, current+root.left.val+root.right.val);\\n\\t\\t}\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n       if (root!=null) maxPath(root);\\n        return max;\\n    }\\n    public void maxPath(TreeNode root) {\\n        int current = root.val;\\n          max = Math.max(max, current);\\n        if (root.right!=null){\\n            maxPath(root.right);\\n            root.val = Math.max(root.val, current+root.right.val);\\n            max = Math.max(max, current+root.right.val);\\n        } \\n        if (root.left!=null) {\\n            maxPath(root.left);\\n            root.val = Math.max(root.val, current+root.left.val);\\n            max = Math.max(max, current+root.left.val);\\n        }\\n        if (root.right!=null && root.left!=null){\\n          max = Math.max(max, current+root.left.val+root.right.val);\\n\\t\\t}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 416095,
                "title": "c-7-lines-with-explanation",
                "content": "```\\nclass Solution {\\nprivate:  \\n    // Partial sum is like a logger, it logs the max we\\'ve seen so far.\\n    int maxHelper(TreeNode* root, int& partialSum) {\\n        if (!root) return 0;\\n        int leftMine = maxHelper(root->left, partialSum), rightMine = maxHelper(root->right, partialSum); \\n        partialSum = max(partialSum, leftMine + rightMine + root->val); // Log the max we\\'ve seen\\n        return max(0, root->val + max(leftMine, rightMine)); // Here we are returning paths\\n    } // Since we are looking for the longest single path, we make a decision between\\n\\t// returning our current value plus either the left or the right path.\\n\\t// If a path sums to negative, we don\\'t want to return it, it won\\'t add to our longest path\\n      // If a path is positive, it will have a positive impact on our max path, so we want to \\n\\t  // return it as opposed to returning 0.\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int res{numeric_limits<int>::min()};\\n        maxHelper(root, res);\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\nprivate:  \\n    // Partial sum is like a logger, it logs the max we\\'ve seen so far.\\n    int maxHelper(TreeNode* root, int& partialSum) {\\n        if (!root) return 0;\\n        int leftMine = maxHelper(root->left, partialSum), rightMine = maxHelper(root->right, partialSum); \\n        partialSum = max(partialSum, leftMine + rightMine + root->val); // Log the max we\\'ve seen\\n        return max(0, root->val + max(leftMine, rightMine)); // Here we are returning paths\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 301587,
                "title": "8-line-python-beats-90-very-clear",
                "content": "```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        self.max = root.val\\n        def dfs(root):\\n            if not root: return 0\\n            left, right = dfs(root.left), dfs(root.right)\\n            self.max = max(self.max, root.val + left + right, left+root.val, right+root.val)\\n            return max(left+root.val, right+root.val, root.val)\\n        dfs(root)\\n        return self.max\\n```\\n\\nSo this one is a bit different from the other Path sum questions in that the path need not pass through the root. We do some kind of postorder traversal.\\n\\nNote that the return value in each call of the recursive function must be either: the root value + left value or root value + right value, or just the root value. We **cannot** return root value + left value + right value because otherwise that would end up being an invalid path in case some other tree node wants to include this value in its path. For example: (apology for formatting, tree is taken from the example)\\n\\n   **-10**\\n        / \\\\\\\\\\n  9    **20**\\n        / \\\\\\\\\\n     **15**   **7**\\nis an invalid path. However, the maximum path sum **can** be root value + left value + right value.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        self.max = root.val\\n        def dfs(root):\\n            if not root: return 0\\n            left, right = dfs(root.left), dfs(root.right)\\n            self.max = max(self.max, root.val + left + right, left+root.val, right+root.val)\\n            return max(left+root.val, right+root.val, root.val)\\n        dfs(root)\\n        return self.max\\n```",
                "codeTag": "Java"
            },
            {
                "id": 233315,
                "title": "c-well-commented-solution-with-explanation",
                "content": "```\\n/* Idea ----- \\n   First, we calculate the maximum path value for each node such that the path starts from below (or at) the node\\n   However, in addition to this, we also keep track of the global maximum which also consists of paths going down a node\\n   The trick here is that if you go down a node, the journey is completed and you cannot go up again .\\n   Now, any maxPath sum will eventually come in the section of maxGoingDownRoot and hence will be updated \\n**/   \\n\\n/* Idea borrowed from below source */\\n\\n/* https://leetcode.com/problems/binary-tree-maximum-path-sum/discuss/39775/Accepted-short-solution-in-Java */\\n\\n/* Tricky corner case ---- What if everything is negative */\\n\\nclass Solution\\n{    \\npublic:\\n    int maxSoFar = INT_MIN;\\n    int maxPathSum(TreeNode* root);\\n    int maxEndingAt(TreeNode* root);\\n};\\n\\n/* Returns the maximum path value ending at root */\\nint Solution :: maxEndingAt(TreeNode* root)\\n{\\n    // If root is not present, return 0\\n    if(!root) return 0;\\n    \\n    // Get the maximum path value ending at the left and right subtree \\n    int leftMax  = maxEndingAt(root->left);\\n    int rightMax = maxEndingAt(root->right);\\n    \\n    // The maximum value ending at root can include exactly one of them or none of them \\n    int maxEndingAtRoot = max({leftMax + root->val, rightMax + root->val, root->val});\\n    \\n    // Keep updating the global maximum\\n    maxSoFar = max(maxSoFar, maxEndingAtRoot);\\n    \\n    // Once you go down the root, the journey is finished\\n    int maxGoingDownRoot = leftMax + rightMax + root->val;\\n    \\n    // Check if going down can be beneficial. We are just going down virtually\\n    maxSoFar = max(maxSoFar, maxGoingDownRoot);\\n    \\n    // Return the max value ending at root, as per the definitions\\n    return maxEndingAtRoot;\\n}\\n\\n/* Returns the maximum value of the path anywhere in the tree */\\nint Solution :: maxPathSum(TreeNode* root)\\n{\\n    // Run the algorithm and keep track of the maximum path seen\\n    int maxFromRoot = maxEndingAt(root);\\n    \\n    // Return the updated global maximum\\n    return maxSoFar;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/* Idea ----- \\n   First, we calculate the maximum path value for each node such that the path starts from below (or at) the node\\n   However, in addition to this, we also keep track of the global maximum which also consists of paths going down a node\\n   The trick here is that if you go down a node, the journey is completed and you cannot go up again .\\n   Now, any maxPath sum will eventually come in the section of maxGoingDownRoot and hence will be updated \\n**/   \\n\\n/* Idea borrowed from below source */\\n\\n/* https://leetcode.com/problems/binary-tree-maximum-path-sum/discuss/39775/Accepted-short-solution-in-Java */\\n\\n/* Tricky corner case ---- What if everything is negative */\\n\\nclass Solution\\n{    \\npublic:\\n    int maxSoFar = INT_MIN;\\n    int maxPathSum(TreeNode* root);\\n    int maxEndingAt(TreeNode* root);\\n};\\n\\n/* Returns the maximum path value ending at root */\\nint Solution :: maxEndingAt(TreeNode* root)\\n{\\n    // If root is not present, return 0\\n    if(!root) return 0;\\n    \\n    // Get the maximum path value ending at the left and right subtree \\n    int leftMax  = maxEndingAt(root->left);\\n    int rightMax = maxEndingAt(root->right);\\n    \\n    // The maximum value ending at root can include exactly one of them or none of them \\n    int maxEndingAtRoot = max({leftMax + root->val, rightMax + root->val, root->val});\\n    \\n    // Keep updating the global maximum\\n    maxSoFar = max(maxSoFar, maxEndingAtRoot);\\n    \\n    // Once you go down the root, the journey is finished\\n    int maxGoingDownRoot = leftMax + rightMax + root->val;\\n    \\n    // Check if going down can be beneficial. We are just going down virtually\\n    maxSoFar = max(maxSoFar, maxGoingDownRoot);\\n    \\n    // Return the max value ending at root, as per the definitions\\n    return maxEndingAtRoot;\\n}\\n\\n/* Returns the maximum value of the path anywhere in the tree */\\nint Solution :: maxPathSum(TreeNode* root)\\n{\\n    // Run the algorithm and keep track of the maximum path seen\\n    int maxFromRoot = maxEndingAt(root);\\n    \\n    // Return the updated global maximum\\n    return maxSoFar;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39837,
                "title": "c-recursive-solution-beats-99-with-explanation",
                "content": "Basic idea:\\n- ```maxPathDownwards:``` denotes max sum from the current node downwards **including the current node**\\n- Traverse bottom-up and update ```ans = max(ans, (max(0, left) + max(0, right) + root->val));```, 0 here means we don't use the left/right son's downward path.\\n```\\nclass Solution {\\nprivate:\\n    int ans = -2147483648;\\npublic:\\n    int maxPathDownwards(TreeNode* root) {\\n        if (!root) return 0;\\n        int left = maxPathDownwards(root->left);\\n        int right = maxPathDownwards(root->right);\\n        ans = max(ans, (max(0, left) + max(0, right) + root->val));\\n        return root->val + max(0, max(left, right));\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        maxPathDownwards(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Interactive"
                ],
                "code": "```maxPathDownwards:```\n```ans = max(ans, (max(0, left) + max(0, right) + root->val));```\n```\\nclass Solution {\\nprivate:\\n    int ans = -2147483648;\\npublic:\\n    int maxPathDownwards(TreeNode* root) {\\n        if (!root) return 0;\\n        int left = maxPathDownwards(root->left);\\n        int right = maxPathDownwards(root->right);\\n        ans = max(ans, (max(0, left) + max(0, right) + root->val));\\n        return root->val + max(0, max(left, right));\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        maxPathDownwards(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39930,
                "title": "simple-and-easy-understood-recursive-c-code-with-o-n-time",
                "content": "    class Solution {\\n    public:\\n        int maxPathSum(TreeNode *root) {\\n            buildVector(root);\\n            return maxVal;\\n        }\\n        int buildVector(TreeNode *root){\\n            if(!root)\\n                return 0;\\n            int left = buildVector(root->left);\\n            int right = buildVector(root->right);\\n            //assume this node as root and calcu maxVal based on it\\n            int sum = root->val;\\n            if(left > 0)\\n                sum += left;\\n            if(right > 0)\\n                sum += right;\\n            if(sum > maxVal)\\n                maxVal = sum;\\n            //return val is either left or right node with this node\\n            left = left > right ? left : right;\\n            sum = root->val;\\n            if(left > 0)\\n                sum += left;\\n            return sum;\\n        }\\n    private:\\n        int maxVal = INT_MIN;\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxPathSum(TreeNode *root) {\\n            buildVector(root);\\n            return maxVal;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 39953,
                "title": "a-java-solution-without-using-a-global-variable",
                "content": "I am using an array with only one element as a function parameter.\\n\\n\\n    public class Solution {\\n        public int maxPathSum(TreeNode root) {\\n            \\n            if (root==null) return 0;\\n            int[] max={Integer.MIN_VALUE};\\n            maxTree(root,max);\\n            return max[0];\\n            \\n        }\\n        //@Param:return the sum of the root value and largest branch\\n        private int maxTree(TreeNode root,int[] max){\\n            if (root==null) return 0;\\n            \\n            int left=root.left!=null?maxTree(root.left,max):Integer.MIN_VALUE;\\n            int right=root.right!=null?maxTree(root.right,max):Integer.MIN_VALUE;\\n            \\n            max[0]=Math.max(max[0],(left>0?left:0)+(right>0?right:0)+root.val);\\n    \\n            return root.val+((left>0||right>0)?Math.max(left,right):0);\\n    \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maxPathSum(TreeNode root) {\\n            \\n            if (root==null) return 0;\\n            int[] max={Integer.MIN_VALUE}",
                "codeTag": "Java"
            },
            {
                "id": 3801935,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    private int maxPath = Integer.MIN_VALUE;\\n\\n    public int maxPathSum(TreeNode root) {\\n        if(root.left == null && root.right == null) return root.val;\\n        helper(root);\\n        return maxPath;\\n    }\\n\\n    private int helper(TreeNode node) {\\n        if(node == null) return 0;\\n\\n        int left = Math.max(0, helper(node.left));\\n        int right = Math.max(0, helper(node.right));\\n        \\n        maxPath = Math.max(node.val + left + right, maxPath);\\n        return node.val + Math.max(left, right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int maxPath = Integer.MIN_VALUE;\\n\\n    public int maxPathSum(TreeNode root) {\\n        if(root.left == null && root.right == null) return root.val;\\n        helper(root);\\n        return maxPath;\\n    }\\n\\n    private int helper(TreeNode node) {\\n        if(node == null) return 0;\\n\\n        int left = Math.max(0, helper(node.left));\\n        int right = Math.max(0, helper(node.right));\\n        \\n        maxPath = Math.max(node.val + left + right, maxPath);\\n        return node.val + Math.max(left, right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652916,
                "title": "commented-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(h)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxAll=INT_MIN;\\n    int maxSum(TreeNode*root){\\n        //Base case\\n        if(root==NULL){\\n            return 0;\\n        }\\n\\n        // go for left and right\\n        // we don\\'t want negative value to go forward\\n        int left=max(maxSum(root->left),0);\\n        int right=max(maxSum(root->right),0);\\n        \\n        maxAll=max(maxAll,root->val+left+right);\\n\\n        return root->val+max(left,right);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int sum = maxSum(root);\\n        return maxAll;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxAll=INT_MIN;\\n    int maxSum(TreeNode*root){\\n        //Base case\\n        if(root==NULL){\\n            return 0;\\n        }\\n\\n        // go for left and right\\n        // we don\\'t want negative value to go forward\\n        int left=max(maxSum(root->left),0);\\n        int right=max(maxSum(root->right),0);\\n        \\n        maxAll=max(maxAll,root->val+left+right);\\n\\n        return root->val+max(left,right);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int sum = maxSum(root);\\n        return maxAll;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647138,
                "title": "easy-to-understand-8-liner-dfs-recursion-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWell if you read the question carefully and observe ...you will get the vibe of easy dfs only where we need to store all possibilities at each node and store the maximum of them. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we have 4 possibilities\\n1. ans will lie in below three only (2nd example)\\n2. ans will lie somewhere upper root side which take advantage of left part of current node\\n3. ans will lie somewhere upper root side which take advantage of right part of current node\\n4. ans will be just root without any previous involvement.(ex-[2,-1]...here ans will be 2 only)\\nAt every point we return left_part_max and righ_part_max\\nlets take a variable to store res which takes the maximum of all 4 possibilities.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//--------------------------------normal dfs----------------\\n    pair<int,int> dfs(TreeNode *root,int &res){\\n        if(root==NULL) return {0,0};\\n        pair<int,int> left_part = dfs(root->left,res);\\n        pair<int,int> right_part = dfs(root->right,res);\\n        // if your desired tree exist below this root only hemce no upper connection\\n        int no_upper_conn  = max(left_part.first,left_part.second)+max(right_part.first,right_part.second)+root->val;\\n        //if your desired tree constitute of left part only\\n        int max_left_part  = max(left_part.first,left_part.second)  +root->val ;\\n        //if your desired tree constitute of right part only\\n        int max_right_part = max(right_part.first,right_part.second)+root->val ;\\n        //RES will be max of all 4 possibilities\\n        res = max({res,no_upper_conn,max_left_part,max_right_part,root->val});\\n        //and also IT MAY CONSIST OF ONLY ROOT NODE e.g;[1,-2,3] , [2,1] \\n        //that\\'s why we check max with root->val also\\n        return {max(max_left_part,root->val),max(max_right_part,root->val)};\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int res=INT_MIN;\\n        dfs(root,res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//--------------------------------normal dfs----------------\\n    pair<int,int> dfs(TreeNode *root,int &res){\\n        if(root==NULL) return {0,0};\\n        pair<int,int> left_part = dfs(root->left,res);\\n        pair<int,int> right_part = dfs(root->right,res);\\n        // if your desired tree exist below this root only hemce no upper connection\\n        int no_upper_conn  = max(left_part.first,left_part.second)+max(right_part.first,right_part.second)+root->val;\\n        //if your desired tree constitute of left part only\\n        int max_left_part  = max(left_part.first,left_part.second)  +root->val ;\\n        //if your desired tree constitute of right part only\\n        int max_right_part = max(right_part.first,right_part.second)+root->val ;\\n        //RES will be max of all 4 possibilities\\n        res = max({res,no_upper_conn,max_left_part,max_right_part,root->val});\\n        //and also IT MAY CONSIST OF ONLY ROOT NODE e.g;[1,-2,3] , [2,1] \\n        //that\\'s why we check max with root->val also\\n        return {max(max_left_part,root->val),max(max_right_part,root->val)};\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int res=INT_MIN;\\n        dfs(root,res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583833,
                "title": "c-solution-with-diagrammatic-explanation",
                "content": "Before heading to the solution let us see all possible form of testcases for the given question.\\n\\n1. Maximum path exist in the left-subtree or right-subtree. shown in example (i) & (ii).\\n1. Maximum path is the sum of the part of left-subtree , right-subtree and root. shown in example (iii).\\n1. Maximum path is the sum of the (Maximum consecutive path of left-subtree and right-subtree) and root. shown in example (iv) & (v).\\n\\n![image](https://assets.leetcode.com/users/images/452ee832-327d-4443-aae0-699148a7a4ef_1685568434.8347857.png)\\n\\n![image](https://assets.leetcode.com/users/images/37dc84c8-061a-4386-ac35-10f798af31ac_1685568522.5391746.png)\\n\\n![image](https://assets.leetcode.com/users/images/51ed88b8-4ef4-4869-ad91-956253c70853_1685570162.9089835.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/3e4e518c-92c2-4c52-933d-67065293986a_1685568716.1070657.png)\\n\\n\\n\\n**Recursive Code Explanation:**\\n* max_ps is storing the maximum path sum and if at some ith recursive call we get a path having sum greater than max_ps then we will change the max_ps.\\n* solve function is giving us the maximum consecutive path posibble including the root node.\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n\\tint solve(TreeNode* root,int &max_ps) {\\n        if(root==NULL) {\\n            return 0;\\n        }\\n        int l = max(0,solve(root->left,max_ps));\\n        // l gives the maximum consecutive path from left-subtree that can contribute to the  maximum path sum\\n        \\n        int r = max(0,solve(root->right,max_ps));\\n        // r gives the maximum consecutive path from right-subtree that can contribute to the  maximum path sum\\n        \\n        int curr_max = max(max(l,r) + root->val,root->val);\\n        // curr_max gives the maximum consecutive path including root-node as explained in example-(iv) and (v).\\n        \\n        int new_max_ps = max(l + r + root->val,curr_max);\\n        // explanation of l + r + root->val is given in example-(iii)\\n        \\n        max_ps = max(new_max_ps,max_ps);\\n        // updating the max_ps\\n        \\n        return curr_max;\\n    }\\n\\tint maxPathSum(TreeNode* root) {\\n        int max_ps = INT_MIN;\\n        int temp = solve(root,max_ps);\\n        return max_ps;\\n    }\\n};\\n```\\n\\n\\n\\n\\t",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint solve(TreeNode* root,int &max_ps) {\\n        if(root==NULL) {\\n            return 0;\\n        }\\n        int l = max(0,solve(root->left,max_ps));\\n        // l gives the maximum consecutive path from left-subtree that can contribute to the  maximum path sum\\n        \\n        int r = max(0,solve(root->right,max_ps));\\n        // r gives the maximum consecutive path from right-subtree that can contribute to the  maximum path sum\\n        \\n        int curr_max = max(max(l,r) + root->val,root->val);\\n        // curr_max gives the maximum consecutive path including root-node as explained in example-(iv) and (v).\\n        \\n        int new_max_ps = max(l + r + root->val,curr_max);\\n        // explanation of l + r + root->val is given in example-(iii)\\n        \\n        max_ps = max(new_max_ps,max_ps);\\n        // updating the max_ps\\n        \\n        return curr_max;\\n    }\\n\\tint maxPathSum(TreeNode* root) {\\n        int max_ps = INT_MIN;\\n        int temp = solve(root,max_ps);\\n        return max_ps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394265,
                "title": "detailed-image-solution-java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int []ans=new int[1];\\n        ans[0]=Integer.MIN_VALUE;\\n        solve(root,ans);\\n        return ans[0];        \\n    }\\n\\n    public int solve(TreeNode root,int[]ans){\\n        if(root==null) return 0;\\n\\n        //if solve(root.left,ans) return the value < 0 then leftSum = 0;\\n        int leftSum=Math.max(0,solve(root.left,ans));\\n\\n        //if solve(root.right,ans) return the value < 0 then rightSum = 0;\\n        int rightSum=Math.max(0,solve(root.right,ans));\\n\\n        ans[0]=Math.max(ans[0],leftSum+rightSum+root.val);\\n\\n        return root.val+Math.max(leftSum,rightSum);\\n    }\\n}\\n```\\n![WhatsApp Image 2023-04-08 at 8.44.18 PM.jpeg](https://assets.leetcode.com/users/images/616bf59f-03d2-43cb-8c45-cd8e5143d825_1680966911.0263126.jpeg)\\n\\n```\\nGive An Upvote if you Understand the solution.\\n```\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int []ans=new int[1];\\n        ans[0]=Integer.MIN_VALUE;\\n        solve(root,ans);\\n        return ans[0];        \\n    }\\n\\n    public int solve(TreeNode root,int[]ans){\\n        if(root==null) return 0;\\n\\n        //if solve(root.left,ans) return the value < 0 then leftSum = 0;\\n        int leftSum=Math.max(0,solve(root.left,ans));\\n\\n        //if solve(root.right,ans) return the value < 0 then rightSum = 0;\\n        int rightSum=Math.max(0,solve(root.right,ans));\\n\\n        ans[0]=Math.max(ans[0],leftSum+rightSum+root.val);\\n\\n        return root.val+Math.max(leftSum,rightSum);\\n    }\\n}\\n```\n```\\nGive An Upvote if you Understand the solution.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363263,
                "title": "this-is-easier-than-easy-category-question-beats-93",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/2d6e0912-50e8-4546-a8c2-855be4a3d60b_1680286287.571895.png)\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt just like finding the height of binary tree...Traverse the tree and at every node calculate the sum of node.left+node.right+node.val.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        \\n        int maxValue[] = new int[1]; // Create an array to hold the max value\\n        maxValue[0] = Integer.MIN_VALUE; // Initialize the max value to the lowest possible integer value\\n        maxPathDown(root,maxValue); // Call the recursive helper function to compute the max path sum\\n\\n        return maxValue[0]; // Return the max path sum\\n    }\\n\\n    public int maxPathDown(TreeNode root, int maxValue[]){\\n\\n        if(root == null){ // Base case: If the node is null, return 0\\n            return 0;\\n        }\\n\\n        // Compute the maximum path sum in the left and right subtrees\\n        // int left = maxPathDown(root.left,maxValue);\\n        // int right = maxPathDown(root.right,maxValue);\\n\\n        // Modify the above lines to take care of negative values\\n        int left = Math.max(0,maxPathDown(root.left,maxValue));\\n        int right = Math.max(0,maxPathDown(root.right,maxValue));\\n\\n        // Update the max path sum if the path passing through the current node has a greater sum\\n        maxValue[0] = Math.max(maxValue[0], left + right + root.val);\\n\\n        // Return the maximum path sum down to the current node\\n        return Math.max(left,right) + root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        \\n        int maxValue[] = new int[1]; // Create an array to hold the max value\\n        maxValue[0] = Integer.MIN_VALUE; // Initialize the max value to the lowest possible integer value\\n        maxPathDown(root,maxValue); // Call the recursive helper function to compute the max path sum\\n\\n        return maxValue[0]; // Return the max path sum\\n    }\\n\\n    public int maxPathDown(TreeNode root, int maxValue[]){\\n\\n        if(root == null){ // Base case: If the node is null, return 0\\n            return 0;\\n        }\\n\\n        // Compute the maximum path sum in the left and right subtrees\\n        // int left = maxPathDown(root.left,maxValue);\\n        // int right = maxPathDown(root.right,maxValue);\\n\\n        // Modify the above lines to take care of negative values\\n        int left = Math.max(0,maxPathDown(root.left,maxValue));\\n        int right = Math.max(0,maxPathDown(root.right,maxValue));\\n\\n        // Update the max path sum if the path passing through the current node has a greater sum\\n        maxValue[0] = Math.max(maxValue[0], left + right + root.val);\\n\\n        // Return the maximum path sum down to the current node\\n        return Math.max(left,right) + root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327481,
                "title": "java-dfs-solution-beats-100-online-submissions",
                "content": "# Complexity\\n- Time complexity: **O(N)**\\n\\n- Space complexity: **O(N)**\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int ans = Integer.MIN_VALUE;\\n\\n    public int maxPathSum(TreeNode root) {\\n        if(root == null){\\n            return 0;\\n        }\\n\\n        update(root);\\n\\n        return ans;\\n    }\\n\\n    private int update(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        \\n        int leftsum = Math.max(update(root.left),0);\\n        int rightsum = Math.max(update(root.right),0);\\n\\n        ans = Math.max(ans,leftsum+rightsum+root.val);\\n\\n        return Math.max(leftsum+root.val, rightsum+root.val);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n\\n    int ans = Integer.MIN_VALUE;\\n\\n    public int maxPathSum(TreeNode root) {\\n        if(root == null){\\n            return 0;\\n        }\\n\\n        update(root);\\n\\n        return ans;\\n    }\\n\\n    private int update(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        \\n        int leftsum = Math.max(update(root.left),0);\\n        int rightsum = Math.max(update(root.right),0);\\n\\n        ans = Math.max(ans,leftsum+rightsum+root.val);\\n\\n        return Math.max(leftsum+root.val, rightsum+root.val);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296155,
                "title": "time-space-o-n-short-sweet-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root,int &ans){\\n        if(root == NULL)return 0;\\n        int l = solve(root->left,ans);\\n        int r = solve(root->right,ans);\\n        ans = max({ans,root->val,root->val+max({l,r,l+r})});\\n        return max({root->val,root->val+max({l,r})});\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        return max(ans,solve(root,ans));\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root,int &ans){\\n        if(root == NULL)return 0;\\n        int l = solve(root->left,ans);\\n        int r = solve(root->right,ans);\\n        ans = max({ans,root->val,root->val+max({l,r,l+r})});\\n        return max({root->val,root->val+max({l,r})});\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        return max(ans,solve(root,ans));\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280297,
                "title": "note-made-it-clear-onlycode-in-java",
                "content": "# Note\\nIn the maxPathSum function, we want to find the maximum path sum in a binary tree. To accomplish this, we traverse the binary tree and compute the sum of all paths from the root node to a leaf node.\\n\\nDuring the traversal, we keep track of the maximum path sum found so far in the max[0] variable. This variable is initialized to Integer.MIN_VALUE at the beginning of the function.\\n\\nNow, let\\'s consider what would happen if we don\\'t initialize max[0] to Integer.MIN_VALUE. If we simply declare the max array without initializing it, then the default value for an integer, which is 0, would be used as the initial value for max[0].\\n\\nIf all the path sum values in the binary tree are negative, the max[0] variable would never get updated, because every path sum value encountered during the traversal would be less than max[0] (which is 0). Therefore, the function would return 0, which is not correct, since there could be negative path sum values that are less than 0.\\n\\nOn the other hand, by initializing max[0] to Integer.MIN_VALUE, we ensure that max[0] will always be updated with the correct maximum path sum value during the traversal, even if all the path sum values are negative. This is because any path sum value encountered during the traversal will be greater than or equal to Integer.MIN_VALUE, so max[0] will always get updated with the maximum path sum value found so far.\\n\\nTherefore, it is important to initialize max[0] to a value that is lower than any possible path sum value in the binary tree. By convention, Integer.MIN_VALUE is used as the initial value for maximum path sum problems to ensure that max[0] gets updated correctly during the traversal.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int max[]= new int[1];\\n        max[0] = Integer.MIN_VALUE;\\n        ht(root,max);\\n        return max[0];\\n    }\\n    public int ht(TreeNode root,int maxValue[]){\\n        if(root==null) return 0;\\n        int lh = Math.max(0,ht(root.left,maxValue));\\n        int rh = Math.max(0,ht(root.right,maxValue));\\n        maxValue[0] = Math.max(maxValue[0], lh + rh + root.val);\\n        return root.val + Math.max(lh,rh);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int max[]= new int[1];\\n        max[0] = Integer.MIN_VALUE;\\n        ht(root,max);\\n        return max[0];\\n    }\\n    public int ht(TreeNode root,int maxValue[]){\\n        if(root==null) return 0;\\n        int lh = Math.max(0,ht(root.left,maxValue));\\n        int rh = Math.max(0,ht(root.right,maxValue));\\n        maxValue[0] = Math.max(maxValue[0], lh + rh + root.val);\\n        return root.val + Math.max(lh,rh);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270970,
                "title": "1ms-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int maximum[]=new int[1];\\n        maximum[0]=Integer.MIN_VALUE;\\n        maxPathDown(root,maximum);\\n        return maximum[0];\\n    }\\n    public int maxPathDown(TreeNode node,int maximum[]){\\n        if(node==null){\\n            return 0;\\n        }\\n        int left=Math.max(0,maxPathDown(node.left,maximum));\\n        int right=Math.max(0,maxPathDown(node.right,maximum));\\n        maximum[0]=Math.max(maximum[0],left+right+node.val);\\n        return Math.max(left,right)+node.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int maximum[]=new int[1];\\n        maximum[0]=Integer.MIN_VALUE;\\n        maxPathDown(root,maximum);\\n        return maximum[0];\\n    }\\n    public int maxPathDown(TreeNode node,int maximum[]){\\n        if(node==null){\\n            return 0;\\n        }\\n        int left=Math.max(0,maxPathDown(node.left,maximum));\\n        int right=Math.max(0,maxPathDown(node.right,maximum));\\n        maximum[0]=Math.max(maximum[0],left+right+node.val);\\n        return Math.max(left,right)+node.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936559,
                "title": "striver-recursive-simple-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int[] maxp=new int[1]; //to pass the maxp integer by reference\\n        maxp[0]=Integer.MIN_VALUE; //because we have to compare to find max\\n        solver(root,maxp);\\n        return maxp[0];\\n    }\\n\\n    public int solver(TreeNode root, int[] maxp){\\n        if(root==null) return 0;\\n        int lh=solver(root.left,maxp); //max path sum from left \\n        int rh=solver(root.right,maxp); //max path sum from right\\n        maxp[0]=Math.max(maxp[0],lh+rh+root.val); \\n        int ret= Math.max(root.val,Math.max(lh,rh)+root.val); //max of root and \\n        maxp[0]=Math.max(maxp[0],ret);// max stores the max of (root value, root+maxLeft/right ,path sum including the node from right to left,previous max)\\n        //max can be a discontinuos set sum but returned value is a continous part of branch of tree\\n        return ret; //max path sum from this node \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxPathSum(TreeNode root) {\\n        int[] maxp=new int[1]; //to pass the maxp integer by reference\\n        maxp[0]=Integer.MIN_VALUE; //because we have to compare to find max\\n        solver(root,maxp);\\n        return maxp[0];\\n    }\\n\\n    public int solver(TreeNode root, int[] maxp){\\n        if(root==null) return 0;\\n        int lh=solver(root.left,maxp); //max path sum from left \\n        int rh=solver(root.right,maxp); //max path sum from right\\n        maxp[0]=Math.max(maxp[0],lh+rh+root.val); \\n        int ret= Math.max(root.val,Math.max(lh,rh)+root.val); //max of root and \\n        maxp[0]=Math.max(maxp[0],ret);// max stores the max of (root value, root+maxLeft/right ,path sum including the node from right to left,previous max)\\n        //max can be a discontinuos set sum but returned value is a continous part of branch of tree\\n        return ret; //max path sum from this node \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902290,
                "title": "binary-tree-maximum-path-sum-c-o-n-solution",
                "content": "# Intuition\\nDFS and max between left and right subtree.\\n\\n# Approach\\nUse dfs and check max left and right subtree value then return max(current,left,right), and check max answer at each and every node.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int ans = INT_MIN;\\n    int solve(TreeNode * root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        \\n        int left = solve(root->left);\\n        int right = solve(root->right);\\n        // calculate the max path \\n        // considering current node as a part of the path\\n        int path = root->val;\\n        path = max(path,path+left);\\n        path = max(path,path+right);\\n\\n        //store the ans\\n        ans = max(ans,path);\\n\\n        // return max(current node, left subtree, right subtree);\\n        return max(root->val,root->val+max(left,right));        \\n    }\\n\\n    int maxPathSum(TreeNode* root) {\\n        ans = root->val;\\n        solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int ans = INT_MIN;\\n    int solve(TreeNode * root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        \\n        int left = solve(root->left);\\n        int right = solve(root->right);\\n        // calculate the max path \\n        // considering current node as a part of the path\\n        int path = root->val;\\n        path = max(path,path+left);\\n        path = max(path,path+right);\\n\\n        //store the ans\\n        ans = max(ans,path);\\n\\n        // return max(current node, left subtree, right subtree);\\n        return max(root->val,root->val+max(left,right));        \\n    }\\n\\n    int maxPathSum(TreeNode* root) {\\n        ans = root->val;\\n        solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902181,
                "title": "c-dfs-single-traversal-easy-to-understand",
                "content": "# Intuition\\nwe have to calculate sum of each possible path in a binary tree and then maximize it and store the maximum sum into any variable. So, we can use subtree sum where we can pick the max sum obtained from left subtree and right subtree and on the same time maximize the maxSum (holds the maximum sum of any particular path in a tree)variable as well. \\n\\n# Approach\\nevery time we are going to a particular node we recursively calculating the left sum (left subtree sum) and right sum (right subtree sum) and store them in specified variables. Then we have to maximize the maxSum variable by adding current node value into our leftsubtree sum and rightsubtree sum. At last, we are returning the maximum of leftsubtree sum and rightsubtree sum by adding the root value into it.\\n\\n# Complexity\\n- Time complexity:\\no(h) where h is the height of the tree. In worst case it can got upto o(n) where n is the number of nodes in the tree.\\n\\n- Space complexity:\\n0(n) functional call is stack is used \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int solve(TreeNode* root, int& maxSum) {\\n        if(root == NULL) return 0;\\n        \\n        int lSum = max(0, solve(root->left,maxSum));\\n        int rSum = max(0, solve(root->right,maxSum));\\n        \\n        maxSum = max(maxSum, lSum + rSum + root->val);\\n        \\n        return root->val + max(lSum,rSum);\\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n        int maxSum = INT_MIN;\\n        solve(root,maxSum);\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int solve(TreeNode* root, int& maxSum) {\\n        if(root == NULL) return 0;\\n        \\n        int lSum = max(0, solve(root->left,maxSum));\\n        int rSum = max(0, solve(root->right,maxSum));\\n        \\n        maxSum = max(maxSum, lSum + rSum + root->val);\\n        \\n        return root->val + max(lSum,rSum);\\n    }\\n    \\n    int maxPathSum(TreeNode* root) {\\n        int maxSum = INT_MIN;\\n        solve(root,maxSum);\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901692,
                "title": "easy-c-solution-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint maxi = INT_MIN;\\n    int dfs(TreeNode* root){\\n        if(!root) return 0;\\n        int l = dfs(root->left);\\n        int r = dfs(root->right);\\n        maxi = max(maxi , root->val+l+r);\\n        int sum = root->val + max(l , r);\\n        if(sum<0){\\n            sum=0;\\n        }\\n        return sum;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        dfs(root);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint maxi = INT_MIN;\\n    int dfs(TreeNode* root){\\n        if(!root) return 0;\\n        int l = dfs(root->left);\\n        int r = dfs(root->right);\\n        maxi = max(maxi , root->val+l+r);\\n        int sum = root->val + max(l , r);\\n        if(sum<0){\\n            sum=0;\\n        }\\n        return sum;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        dfs(root);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901370,
                "title": "java-easiest-solution-possible",
                "content": "# Code\\n```\\nclass Solution {\\n    private static int ans = Integer.MIN_VALUE;\\n    private static int PathMax(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        int left = PathMax(root.left);\\n        int right = PathMax(root.right);\\n        int ms = Math.max(Math.max(left,right)+root.val, root.val);\\n        int ms_1 = Math.max((left+right+root.val), ms);\\n        ans = Math.max(ans, ms_1);\\n\\n        return ms;\\n    }\\n    public int maxPathSum(TreeNode root) {\\n        ans = Integer.MIN_VALUE;\\n        PathMax(root);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static int ans = Integer.MIN_VALUE;\\n    private static int PathMax(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        int left = PathMax(root.left);\\n        int right = PathMax(root.right);\\n        int ms = Math.max(Math.max(left,right)+root.val, root.val);\\n        int ms_1 = Math.max((left+right+root.val), ms);\\n        ans = Math.max(ans, ms_1);\\n\\n        return ms;\\n    }\\n    public int maxPathSum(TreeNode root) {\\n        ans = Integer.MIN_VALUE;\\n        PathMax(root);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900237,
                "title": "simple-dfs-log-n",
                "content": "1. Find non negative leftPathSum\\n2. Find non negative rightPathSum\\n3. Calculate maxPathSum for current Node (left+right+root.val)\\n4. Compair final ans and update it.\\n\\n# Code\\n### Python\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n\\n        self.ans = float(\\'-inf\\')\\n        def leftRightSum(root):\\n            if not root:\\n                return 0\\n            l = max(leftRightSum(root.left), 0)\\n            r = max(leftRightSum(root.right), 0)\\n            self.ans = max(l+r+root.val, self.ans)\\n            # print(l, r, root.val, self.ans)\\n            return max(l, r) + root.val\\n        \\n        leftRightSum(root)\\n        return self.ans\\n\\n```\\n### Go\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc maxPathSum(root *TreeNode) int {\\n    ans := -1 << 63\\n    maxPath(root, &ans)\\n    return ans\\n}\\n\\nfunc maxPath(root *TreeNode, ans *int) int {\\n    if root == nil {\\n        return 0\\n    }\\n    leftPathSum := maxPath(root.Left, ans)\\n    rightPathSum := maxPath(root.Right, ans)\\n    *ans = max(*ans, leftPathSum + rightPathSum + root.Val)\\n    return max(max(leftPathSum+root.Val, rightPathSum+root.Val), 0)\\n}\\n\\nfunc max(a int, b int) int {\\n    if (a >= b) {\\n        return a\\n    }\\n    return b\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n\\n        self.ans = float(\\'-inf\\')\\n        def leftRightSum(root):\\n            if not root:\\n                return 0\\n            l = max(leftRightSum(root.left), 0)\\n            r = max(leftRightSum(root.right), 0)\\n            self.ans = max(l+r+root.val, self.ans)\\n            # print(l, r, root.val, self.ans)\\n            return max(l, r) + root.val\\n        \\n        leftRightSum(root)\\n        return self.ans\\n\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc maxPathSum(root *TreeNode) int {\\n    ans := -1 << 63\\n    maxPath(root, &ans)\\n    return ans\\n}\\n\\nfunc maxPath(root *TreeNode, ans *int) int {\\n    if root == nil {\\n        return 0\\n    }\\n    leftPathSum := maxPath(root.Left, ans)\\n    rightPathSum := maxPath(root.Right, ans)\\n    *ans = max(*ans, leftPathSum + rightPathSum + root.Val)\\n    return max(max(leftPathSum+root.Val, rightPathSum+root.Val), 0)\\n}\\n\\nfunc max(a int, b int) int {\\n    if (a >= b) {\\n        return a\\n    }\\n    return b\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899200,
                "title": "easiest-java-solution-faster-than-99-63",
                "content": "**Intuition:**\\nAt every node, check what is the maxium left and right path sum that you can get. Take the max sum of current path (left + root + right). Now return max(left, right) + root.\\n\\n```java\\n class Solution {\\n    public int maxPathSum(TreeNode root) {\\n        solve(root);\\n        return maxSum;\\n    }\\n    \\n    int maxSum = Integer.MIN_VALUE;\\n    int solve(TreeNode root) {\\n        if (root == null) return 0;\\n        int maxLeft = Math.max(0, solve(root.left));\\n        int maxRight = Math.max(0, solve(root.right));\\n        maxSum = Math.max(maxSum, root.val + maxLeft + maxRight);\\n        return root.val + Math.max(maxLeft, maxRight);\\n    }\\n}\\n```\\n**Time complexity :** `O(N)` for traversing all nodes\\n**Space complexity :** `O(N)` for recursion stack space",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n class Solution {\\n    public int maxPathSum(TreeNode root) {\\n        solve(root);\\n        return maxSum;\\n    }\\n    \\n    int maxSum = Integer.MIN_VALUE;\\n    int solve(TreeNode root) {\\n        if (root == null) return 0;\\n        int maxLeft = Math.max(0, solve(root.left));\\n        int maxRight = Math.max(0, solve(root.right));\\n        maxSum = Math.max(maxSum, root.val + maxLeft + maxRight);\\n        return root.val + Math.max(maxLeft, maxRight);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899166,
                "title": "c-easy-explaination",
                "content": "# Intuition\\nAt every node , we have two possible actions \\n1. At this node, we decide to join the paths from left and right , which means we are trying to form our answer from this node.\\n2. Find the maximum path from left and right , so that it can be used by the ancestor nodes to perform action 1.\\n\\n# Approach\\n1. We will just do a postorder traversal\\n2. At each node, we maximise the answer by adding maximum in left and right\\n3. At the same time we find the maximum path, from left and right\\n4. If the pathsum becomes less than 0, we should drop that path\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity:O(h) h=height of tree \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=INT_MIN;\\n    int helper(TreeNode * root){\\n        if(!root) return 0;\\n        int left = helper(root->left);\\n        int right = helper(root->right);\\n        ans = max(ans , left+right+root->val);\\n        return max({left+root->val,right+root->val,0});\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        helper(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MIN;\\n    int helper(TreeNode * root){\\n        if(!root) return 0;\\n        int left = helper(root->left);\\n        int right = helper(root->right);\\n        ans = max(ans , left+right+root->val);\\n        return max({left+root->val,right+root->val,0});\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        helper(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899138,
                "title": "simple-and-easy-to-understand-c-recursive-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is quiet simple just travel each node and get max positive path cost of left and right sub tree. Check if cost of left and right sub tree plus cost of node is greater than max path cost till now then update it. Return max positive path cost from left and right sub with increment of node\\'s cost.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ if Consider Recursive Call Stack then Space Complexity will be $$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int getMaxPath(TreeNode* root, int &maxPath){\\n        if(!root)\\n            return 0;\\n        int leftVal = max(getMaxPath(root->left, maxPath),0);\\n        int rightVal = max(getMaxPath(root->right, maxPath),0);\\n        maxPath = max(maxPath, root->val+leftVal+rightVal);\\n        return max(leftVal, rightVal)+root->val;\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int maxPath = -1001;\\n        getMaxPath(root, maxPath);\\n        return maxPath;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int getMaxPath(TreeNode* root, int &maxPath){\\n        if(!root)\\n            return 0;\\n        int leftVal = max(getMaxPath(root->left, maxPath),0);\\n        int rightVal = max(getMaxPath(root->right, maxPath),0);\\n        maxPath = max(maxPath, root->val+leftVal+rightVal);\\n        return max(leftVal, rightVal)+root->val;\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int maxPath = -1001;\\n        getMaxPath(root, maxPath);\\n        return maxPath;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899130,
                "title": "java-beat-99-6-post-order-traversal-easy-solution",
                "content": "```\\n    //post order traverse\\n    int res = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        getSiglePathMax(root);\\n        return res;\\n    }\\n    \\n    private int getSiglePathMax(TreeNode root) {\\n        if(root == null) return 0;\\n        //no need to add if it\\'s negetive\\n        int left = Math.max(0, getSiglePathMax(root.left));\\n        int right = Math.max(0, getSiglePathMax(root.right));\\n        int curPath = left + right + root.val;\\n        res = Math.max(res, curPath);\\n        return Math.max(left, right) + root.val;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n    //post order traverse\\n    int res = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        getSiglePathMax(root);\\n        return res;\\n    }\\n    \\n    private int getSiglePathMax(TreeNode root) {\\n        if(root == null) return 0;\\n        //no need to add if it\\'s negetive\\n        int left = Math.max(0, getSiglePathMax(root.left));\\n        int right = Math.max(0, getSiglePathMax(root.right));\\n        int curPath = left + right + root.val;\\n        res = Math.max(res, curPath);\\n        return Math.max(left, right) + root.val;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2831066,
                "title": "c-o-n-solution-with-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int as(TreeNode* root,int& ans){\\n        if(root==NULL) return 0;\\n        int l=as(root->left,ans);\\n        if(l<0) l=0;\\n        int r=as(root->right,ans);\\n        if(r<0) r=0;\\n        ans=max(ans,root->val+l+r);\\n        return root->val+max(l,r);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        as(root,ans);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int as(TreeNode* root,int& ans){\\n        if(root==NULL) return 0;\\n        int l=as(root->left,ans);\\n        if(l<0) l=0;\\n        int r=as(root->right,ans);\\n        if(r<0) r=0;\\n        ans=max(ans,root->val+l+r);\\n        return root->val+max(l,r);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2749045,
                "title": "easy-c-solution-o-n-with-comments",
                "content": "Here is my C++ Solution :\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxi=INT_MIN;\\n    int demo (TreeNode* root){\\n        if (root==NULL)return 0;\\n        int ls= max(0,demo(root->left));   // taking max with 0 to avoid negative nodes\\n        int rs= max(0,demo(root->right));\\n        maxi = max(maxi, root->val+ls+rs); // for umbrellas;\\n        return root->val + max(ls,rs); // for along heights;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        demo(root);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxi=INT_MIN;\\n    int demo (TreeNode* root){\\n        if (root==NULL)return 0;\\n        int ls= max(0,demo(root->left));   // taking max with 0 to avoid negative nodes\\n        int rs= max(0,demo(root->right));\\n        maxi = max(maxi, root->val+ls+rs); // for umbrellas;\\n        return root->val + max(ls,rs); // for along heights;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        demo(root);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571541,
                "title": "very-easy-solution-binary-tree-maximum-path-sum",
                "content": "class Solution {\\npublic:\\n    int solve(TreeNode*root, int &res){\\n        if(!root) return 0;\\n        \\n        int l=solve(root->left, res);\\n        int r=solve(root->right, res);\\n        \\n        int temp=max(max(l,r)+root->val, root->val);\\n      //  cout<<temp<<\" \"<<endl;\\n        int ans=max(temp, l+r+root->val);\\n        cout<<ans<<\" \";\\n        res=max(res,ans);\\n        \\n        return temp;\\n        \\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int res=INT_MIN;\\n        solve(root, res);\\n        \\n        return res;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int solve(TreeNode*root, int &res){\\n        if(!root) return 0;\\n        \\n        int l=solve(root->left, res);\\n        int r=solve(root->right, res);\\n        \\n        int temp=max(max(l,r)+root->val, root->val);\\n      //  cout<<temp<<\" \"<<endl;\\n        int ans=max(temp, l+r+root->val);\\n        cout<<ans<<\" \";\\n        res=max(res,ans);\\n        \\n        return temp;\\n        \\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2392892,
                "title": "5-line-c-dfs-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        dfs(root, ans);\\n        return ans;\\n    }\\n    \\n    int dfs(TreeNode* node , int &ans) {\\n        if(node == NULL) return 0;\\n        int l = max(0, dfs(node->left, ans));\\n        int r = max(0, dfs(node->right, ans));\\n        ans = max(ans, l + r + node->val);\\n        return max(l, r) + node->val;\\n    }\\n};\\n```\\n**Please Upvote\\nthank you!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        dfs(root, ans);\\n        return ans;\\n    }\\n    \\n    int dfs(TreeNode* node , int &ans) {\\n        if(node == NULL) return 0;\\n        int l = max(0, dfs(node->left, ans));\\n        int r = max(0, dfs(node->right, ans));\\n        ans = max(ans, l + r + node->val);\\n        return max(l, r) + node->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262932,
                "title": "simple-c-solution-recursion",
                "content": "Solution -->\\n```\\nclass Solution {\\npublic:\\n    int sum(TreeNode* root, int& ans)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        int left=sum(root->left,ans);\\n        int right=sum(root->right,ans);\\n        \\n        int temp=max(max(left,right)+root->val,root->val);\\n        temp=max(temp,left+right+root->val);\\n        ans=max(ans,temp);\\n        return max(max(left,right)+root->val,root->val);\\n    }\\n    \\n    int maxPathSum(TreeNode* root) \\n    {\\n        int res = INT_MIN;\\n        sum(root, res);\\n        return res;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum(TreeNode* root, int& ans)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        int left=sum(root->left,ans);\\n        int right=sum(root->right,ans);\\n        \\n        int temp=max(max(left,right)+root->val,root->val);\\n        temp=max(temp,left+right+root->val);\\n        ans=max(ans,temp);\\n        return max(max(left,right)+root->val,root->val);\\n    }\\n    \\n    int maxPathSum(TreeNode* root) \\n    {\\n        int res = INT_MIN;\\n        sum(root, res);\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2254617,
                "title": "aditya-varma-dp-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int solve(TreeNode *root, int &res)\\n    {\\n        if (root == NULL)\\n            return 0;\\n\\n        int l = solve(root->left, res);\\n        int r = solve(root->right, res);\\n\\n        int temp = max(max(l, r) + root->val, root->val);\\n        int ans = max(temp, l + r + root->val);\\n        res = max(res, ans);\\n        return temp;\\n    }\\n\\n    int maxPathSum(TreeNode *root)\\n    {\\n        int res = INT_MIN;\\n        solve(root, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int solve(TreeNode *root, int &res)\\n    {\\n        if (root == NULL)\\n            return 0;\\n\\n        int l = solve(root->left, res);\\n        int r = solve(root->right, res);\\n\\n        int temp = max(max(l, r) + root->val, root->val);\\n        int ans = max(temp, l + r + root->val);\\n        res = max(res, ans);\\n        return temp;\\n    }\\n\\n    int maxPathSum(TreeNode *root)\\n    {\\n        int res = INT_MIN;\\n        solve(root, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177649,
                "title": "c-simple-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mx=-1001;\\n    int getans(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        int left=max(0,getans(root->left));\\n        int right=max(0,getans(root->right));\\n        \\n        mx=max(mx,root->val+left+right);\\n        return max(left,right)+root->val;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int k= getans(root);\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mx=-1001;\\n    int getans(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        int left=max(0,getans(root->left));\\n        int right=max(0,getans(root->right));\\n        \\n        mx=max(mx,root->val+left+right);\\n        return max(left,right)+root->val;\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int k= getans(root);\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105359,
                "title": "java-commented-beats-100",
                "content": "**Idea**: At any point in time we need to maintain the best at that node but the value that we bubble up must be part of a path (cannot have both children), so we must choose the best of current value with left subtree, right subtree or the current node\\'s value itself. But our actual maximum may go through the root, so we can keep track of it separately.\\nRest is explained with comments.\\n\\n```\\nclass Solution {\\n\\t// to maintain the actual maximum sum of path\\n    int max = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        path(root);\\n        return max;\\n    }\\n    \\n    private int path(TreeNode node) {\\n\\t\\t// base case\\n        if(node == null) {\\n            return 0;\\n        }\\n        \\n\\t\\t// traverse left and right subtrees\\n        int left = path(node.left);\\n        int right = path(node.right);\\n        \\n\\t\\t// get the best of left subtree + current node\\'s val vs. right subtree + current node\\'s val vs. current node\\'s val \\n\\t\\t// as this value will ensure either of the path (left, right or just from the current node itself but not both the children)\\n\\t\\t// we return this to the parent\\n        int leftOrRightOrCurrent = \\n            Math.max(Math.max(left + node.val, right + node.val), node.val);\\n\\t\\t\\n\\t\\t// maximum of current node\\'s val vs. all the above possibilities to see if this is actually the max path?\\n\\t\\t// best max path upto this node is this (localMaxima)\\n        int localMaxima = Math.max(left + right + node.val, leftOrRightOrCurrent);\\n            \\n        // overall maximum\\n\\t\\t// compare the localMaxima with overall tree\\'s max value, this will be our answer\\n        max = Math.max(localMaxima, max);\\n        \\n\\t\\t// return to parent as discussed earlier\\n        return leftOrRightOrCurrent;\\n    }\\n}\\n```\\n\\n**Time Complexity: O(N)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\t// to maintain the actual maximum sum of path\\n    int max = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        path(root);\\n        return max;\\n    }\\n    \\n    private int path(TreeNode node) {\\n\\t\\t// base case\\n        if(node == null) {\\n            return 0;\\n        }\\n        \\n\\t\\t// traverse left and right subtrees\\n        int left = path(node.left);\\n        int right = path(node.right);\\n        \\n\\t\\t// get the best of left subtree + current node\\'s val vs. right subtree + current node\\'s val vs. current node\\'s val \\n\\t\\t// as this value will ensure either of the path (left, right or just from the current node itself but not both the children)\\n\\t\\t// we return this to the parent\\n        int leftOrRightOrCurrent = \\n            Math.max(Math.max(left + node.val, right + node.val), node.val);\\n\\t\\t\\n\\t\\t// maximum of current node\\'s val vs. all the above possibilities to see if this is actually the max path?\\n\\t\\t// best max path upto this node is this (localMaxima)\\n        int localMaxima = Math.max(left + right + node.val, leftOrRightOrCurrent);\\n            \\n        // overall maximum\\n\\t\\t// compare the localMaxima with overall tree\\'s max value, this will be our answer\\n        max = Math.max(localMaxima, max);\\n        \\n\\t\\t// return to parent as discussed earlier\\n        return leftOrRightOrCurrent;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017695,
                "title": "java-best-solution-easy",
                "content": "IF YOU FIND THE SOLUTION HELPFULL , KINDLY UPVOTE.\\nThank You\\n\\n```\\npublic class Solution {\\n  int max = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n      helper(root);\\n      return max;\\n    }\\n  int helper(TreeNode root) {\\n    if(root == null) return 0;\\n    int left = Math.max(helper(root.left), 0);\\n    int right = Math.max(helper(root.right), 0);  \\n    \\n    max = Math.max(max, root.val + left + right);\\n    return root.val + Math.max(left, right);\\n  }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n  int max = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n      helper(root);\\n      return max;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1944012,
                "title": "beats-96-91-5-lines-logic-c",
                "content": "1. First thing is we have to traverse every node. So it needs a DFS solution.\\n2. On every node, we need to find out maximum left and right downward path. Node should only focus on its children and grandchildren.\\n3. At every node, if its left or right path is > 0, then only it is going to increase the sum. So we use **max(leftSum, 0)** and **max(rightSum, 0)**\\n4. At every node, we calculate node->val + left + right and compare it with answer till now and update the answer if the current node has a better value.\\n5. Tricky and important part what should DFS return at every node. Whatever current DFS node will return will be used by its parent. \\ne.g. \\n____________________________________1\\n___________________________2_____________3\\n________________________4___5_________6___7\\n\\nSo it should return current **node->val + max(left,right)**. Because parent cannot use its children\\'s both left and right sum. In above example, DFS(2) should return 2 + max(4,5), because 1 can include only 4 or 5 in its path\\n\\n```\\nclass Solution {\\nprivate:\\n    int DFS(TreeNode* root, int& ans) {\\n        if(root == NULL) return 0;\\n        int left = max(DFS(root->left, ans), 0);\\n        int right = max(DFS(root->right, ans), 0);\\n\\n        int sum = root->val + left + right;\\n        ans = max(ans, sum);\\n        return root->val + max(left, right);\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        DFS(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int DFS(TreeNode* root, int& ans) {\\n        if(root == NULL) return 0;\\n        int left = max(DFS(root->left, ans), 0);\\n        int right = max(DFS(root->right, ans), 0);\\n\\n        int sum = root->val + left + right;\\n        ans = max(ans, sum);\\n        return root->val + max(left, right);\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int ans = INT_MIN;\\n        DFS(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870416,
                "title": "we-just-have-to-find-the-diameter-java-beats-100-with-explanation",
                "content": "**Approach and Intuition:-**  In this question, the catch is to find the diameter of the binary tree, with little changes. Instead of just finding the left and right height of a particular node in the tree, we find the maximum left and right heights of that node, including it. The remaining steps are similar to the \\'diameter\\' problem, but we need to ensure that while returning the ```max(lh,rh)```, we need to add ```root.val``` to it, because the path passes through that node too. \\n\\n**Code:-**\\n\\n```\\n    int ans=Integer.MIN_VALUE;;\\n    public int maxPathSum(TreeNode root)\\n    {\\n        height(root);\\n        return ans;\\n    }\\n    public int height(TreeNode root)\\n    {\\n        if (root==null) return 0;\\n        int lh=Math.max(0,height(root.left));\\n        int rh=Math.max(0,height(root.right));\\n        ans=Math.max(ans,lh+rh+root.val);\\n        return Math.max(lh,rh)+root.val;\\n    }\\n```\\t\\n\\n**Time Complexity:-**  O(n), where n is the number of nodes\\n**Space Complexity:-**  O(h), where h is the height of the binary tree",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```max(lh,rh)```\n```root.val```\n```\\n    int ans=Integer.MIN_VALUE;;\\n    public int maxPathSum(TreeNode root)\\n    {\\n        height(root);\\n        return ans;\\n    }\\n    public int height(TreeNode root)\\n    {\\n        if (root==null) return 0;\\n        int lh=Math.max(0,height(root.left));\\n        int rh=Math.max(0,height(root.right));\\n        ans=Math.max(ans,lh+rh+root.val);\\n        return Math.max(lh,rh)+root.val;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1712502,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1567490,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1712498,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1575621,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1568229,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1568300,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1567489,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1573705,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1568163,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1568185,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1712502,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1567490,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1712498,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1575621,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1568229,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1568300,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1567489,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1573705,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1568163,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1568185,
                "content": [
                    {
                        "username": "Joald",
                        "content": "Definitely medium at best, quite simple."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "[@zweitekonto96](/zweitekonto96) \\nwhat is DAG or SSSP?\\n"
                    },
                    {
                        "username": "abhigyanhedau2",
                        "content": "Between Medium and Hard though, for beginners"
                    },
                    {
                        "username": "titiu7",
                        "content": "I agree. Felt like a medium!"
                    },
                    {
                        "username": "zweitekonto96",
                        "content": "medium only if you recognize the DAG and SSSP"
                    },
                    {
                        "username": "YYANN",
                        "content": "I agree. This problem shouldn\\'t have been tagged as \\'Hard\\'."
                    },
                    {
                        "username": "GCarterII",
                        "content": "That was my though too! I thought that yesterday\\'s question was significantly more challenging, at least for my poor addled brain. XD"
                    },
                    {
                        "username": "vkr1997",
                        "content": "I am failing this testcase: [5,4,8,11,null,13,4,7,2,null,null,null,1]. Why is the answer to this 48 and not 55 (sum of all nodes)?\\n"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "question is ....why are you adding all the nodes?\\nYou have to add the biggest path from one leaf to another "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Yeah this threw me off aswell. Essentially the only time you can go both ways is from a relative root other wise you can not include both paths sums of left and right. You are essentially looking for a sequence so if you where to draw out the connection from each node it would be a path without any branches in it which means that only a relative root node is allowed to go both ways. This should of been better explained in the problem "
                    },
                    {
                        "username": "sagartech",
                        "content": "There should be a linear path (single line path) from one end to the second end"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because there is no way to go over all nodes in a single path without revisiting any nodes. If you revisit a node, this is not a valid path"
                    },
                    {
                        "username": "ganeshkamath89",
                        "content": "because maximum path goes like 7 + 11 + 4 + 5 + 8 + 13 = 48.\nthe values 2, 4, 1 are not part of the maximum path\n\n5 has children 4, 8\n4 has child 11 which has children 7, 2\n8 has children 13 (no children) and 4 has child 1\n\n\nSee the tree below to know how the sum can be verified.\n```\n      5\n     /  \\\n    4    8\n   /    / \\\n  11   13  4\n /   \\      \\\n7     2      1\n```\n\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Lowkey easier than yesterday\\'s medium lmao"
                    },
                    {
                        "username": "freeze_francis",
                        "content": "This question was part of the initial screening round of Amazon.\\nFor folks preparing for FAANG interview please read my interview experience.\\nhttps://freezefrancis.medium.com/amazon-sde-interview-experience-on-campus-e8444ee791b"
                    },
                    {
                        "username": "sebagomez",
                        "content": "I have one of the tests failing because it is said to be expected 48, while my algo returns 55.\\nCounting the nodes, (running by hand) I also get 55... is there anything I\\'m not getting or is it a failing test?\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "george14215",
                        "content": "For this input:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nexpected = 48\\nactual = 55\\n\\nAll the nodes are positive, why isn\\'t the answer the sum of the entire tree?"
                    },
                    {
                        "username": "_Tanmay",
                        "content": "you cannot visit a node twice"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "becuase they are not in the same line"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "[@dpei7077](/dpei7077) \" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "dpei7077",
                        "content": "because the whole tree cannot make a path."
                    },
                    {
                        "username": "chaitanyakintali",
                        "content": "Guys, Can some one explain why the output for the test case \\n[5,4,8,11,null,13,4,7,2,null,null,null,1] is 48 not 55. If we add all the elements which is a valid path, it sums upto 55. Why is the answer 48 ???????????"
                    },
                    {
                        "username": "sandipt335",
                        "content": "bhai ko testcase se tree banane nahi aata. "
                    },
                    {
                        "username": "devanshuyadav",
                        "content": "The expected path is 7 -> 11 -> 4 -> 5 -> 8 ->13, where their sum = 7 + 11 + 4 + 5 + 8 + 13 = 48.\\nNote that for Node 8, we can either choose the left sub-tree (13) OR the right sub-tree (4 which has another child 1) in order to form a path & 13 gives the maximum sum overall. We can\\'t go for both the nodes for that won\\'t be a \\'Path\\'."
                    },
                    {
                        "username": "i-var",
                        "content": "Hi, path Cost for that sample comes to 48 bcz to make a path you can only goes either to left or to right, final path should be linear when streched out. \\nfor this case path with max sum i.e. 48 will be,\\n7->11->4->5->8->13.\\nHope I\\'ve cleared you confusion.\\n"
                    },
                    {
                        "username": "sirdan1995",
                        "content": "do we stictly need to start from leaf node and end with leaf node?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "[@synbat_d](/synbat_d) what a confusing problem description, thx for the clarification"
                    },
                    {
                        "username": "synbat_d",
                        "content": "no, path can end without reaching leaf node"
                    },
                    {
                        "username": "Josh_jxs",
                        "content": "Description of Aglorithm\\n1) Create a source node s. Create directed edges with weight 0 connecting from s to every node in the tree\\n2) Create a sink node t. Create directed edges with weight 0 connecting from every node in the tree to t.\\n3) For every node v excluding the root and the leaves, we create two nodes v1 and v2. We form an edge between v1 and v2 with the weight of the value at v. We connect v1 to the parent of v and v2 to the children of v with edge weights of 0. \\n4) For the root, we also create two more nodes r1 and r2. r1 connects to the left child of r, and r2 connects to the right child of r. The weight of the edge between r1 and r2 is the value at r.\\n5) For all the leave nodes, we create an edge with an weight of the value at the corresponding leaf. The edge connects the each leaf node to their corresponding parent.\\n6) Since we want to determine the max weighted path, we must negate all the edge weights in the graph before running a SSSP algorithm.\\n7) Since the modified graph will be a Directed Acyclic Graph (DAG), we can run DAG relaxation to determine the weight of the shortest path. \\n8) We negate the result from step 4 to determine the max weighted path.\\n\\nTime Analysis:\\nThere will be O(n) nodes in the graph since for each node in the binary tree, we create one more.\\nThere are O(n) edges in the graph since for each node in the binary tree, we create at most three edges.\\nThe overall runtime DAG relaxation is O(V+E), which will be O(n) in this case. \\n\\n"
                    },
                    {
                        "username": "leandroborgnia",
                        "content": "TLDR: Just go to solutions, there is several solutions which take advantage of the fact this is a binary tree, and any path has to use some node as root of their path. That makes the problem solvable in O(n) since there are at most O(n) roots, and each can get O(1) information from their child to decide if they are an optimal path, instead of having to solve it exponentially.\\n\\nIm sorry to tell you this but solutions trying to use either Dijkstra/Bellman Ford/Relaxation don\\'t work or are exponential in time.\\n\\nReasons:\\n1) Having nodes carrying the information requires to transform the graph making a new one where nodes are edges as you showed in your algorithm.\\n2) The given graph comes with negative values. Trying to translate the problem converting nodes to edges for the these algorithms still mantains edges with negative numbers. Having negative numbers implies wrong answers for Dijkstra and relaxation, and Ford can only detect Loops, not solve the shortest path tree. \\n3) Your solution has 2 problems:\\na) It has negative cycles (so cant use any of the algorithms mentioned). Example: if a node is negative, and a child of it is also negative, there will be a cycle between vparent2 and vchild1, unless you try to set it in only one direction (downwards from the root as you show in your solution), in which case it will not be maximal, since you wouldn\\'t be able to go \"Up the tree\" and your solution would not be the maximum and would be wrong.\\nb) As shown in the previous point, if you either choose to go up the tree or down so that there are no negative cycles, you would be in a way, choosing which node is the root of your path, limiting your choices and giving a smaller than maximum solution. So as long as this problem has negative edges, your solution doesnt work as implied (either gives a smaller answer or returns negative cycles)\\n\\n4) I was all day trying to fit Dijkstra or Relaxation into this problem lol XD, if anyone can help I would appreciate. The best I could find is that you could solve shortest single path and relate it to matching, I\\'m scheptical and didn\\'t understand the explanation here:\\nhttps://courses.engr.illinois.edu/cs498374/fa2014/notes/26-sssp.pdf\\nThis would also be an O(n^2log(n)) solution in this problem with trees, so it would be pretty bad.\\n\\nAnother option i devised, is that using your solution, you would be able to make a graph FOR EACH node as you described, making each node root of its own graph, and have all left children pointing upwards to the tree, while all right children pointing downwards. But that would require O(n) graphs, each solved using relaxation for DAGs (O(n) for each DAG), so the time complexity would be O(n^2) total for all DAGs. Also, Space complexity would be the O(n^2) unless you delete each DAG after calculatin it\\'s optimum. So it would be a pretty terrible solution.\\n\\nConclusion: this problem is hard for those that know Dijkstra/relaxation/Ford, etc and want to somehow fit it into the problem and will most likely have a hard time and fail (I still cant find an O(n) solution that uses relaxation or some Shortest path algorithm). It will be easy for anyone thinking about having any node as root of their path."
                    },
                    {
                        "username": "i-var",
                        "content": "[@Ak_15](/Ak_15)  I\\'ve also posted clean c++ code in solution section, if you wish you can go through it. by the way no need to thanks bro."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Thank You Buddy !!! This is my first hard question .... i was searching for algo instead of ans.... Thanks Once again :))"
                    },
                    {
                        "username": "satheeshbabu",
                        "content": "For the test vector [1,-2,-3,1,3,-2,null,-1]\\ncorrect answer is mentioned as 4. Isn\\'t it 3?"
                    },
                    {
                        "username": "jainsoumya647",
                        "content": "Maybe algo is giving 4 because your algo adding 3+1. However, your tree should break as it is not directly connected node 1 with node 3"
                    },
                    {
                        "username": "stridemann",
                        "content": "correct answer is mentioned as 3, not 4. (but yes, for some reason my algo also gives wrong result 4)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "Why 3 ? 4 is the correct answer. Even just following the inorder traversal, we can verify that 3+1 = 4 is the max path sum."
                    },
                    {
                        "username": "keerti_2109",
                        "content": "did you understand?\\n"
                    }
                ]
            },
            {
                "id": 1719855,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1575882,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1568161,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1568372,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1831659,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1574509,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1570162,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1573688,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1569581,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1569384,
                "content": [
                    {
                        "username": "nuodi",
                        "content": "How come [2,-1] has answer 2 ???  So a single node can be presented as a path? this doesn\\'t make sense to me "
                    },
                    {
                        "username": "asharma95",
                        "content": "![image](https://assets.leetcode.com/users/images/d0d4e7e2-f182-48f7-ba35-e6f1b061bea0_1634865660.6986976.png)\\nI\\'m having a problem where when I submit the code it says I have the wrong answere of 42 which impossible for a binary tree with one node of zero. However when I copy and paste the test case into the compiler it says I have the right answer. Is anyone else having the same problem? Look at my accepted answere at the buttom right corn and my wrong answere on the left."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Please try to flush globals after each test case because leetcode compiler will use one instance of your program to check for all testcases."
                    },
                    {
                        "username": "praveenbelkar18",
                        "content": "I am having exact same issue. not sure what is going wrong with code OR it is bug from code execution engine ?"
                    },
                    {
                        "username": "yywalnut",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\nI thought the max path sum is 55. Why is the answer 48? Thanks!"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "ande_ka_funda",
                        "content": "I was asked to not only find the Maximum Path sum (as desribed), but also print the path . Prefferably in Inorder.\\n\\nCoulnd\\'t do it in O(n) time, but can be done in o(n^2) time."
                    },
                    {
                        "username": "hemanthjagaari",
                        "content": "Can you Explain how to print the Maximum path "
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is exactly the same with # 543, find the diameter of a tree. That one is marked as easy. If you are solving this kind of splitting tree problem at the first time, don't worry at this moment because they are all the same."
                    },
                    {
                        "username": "adhoc",
                        "content": "//Maximum from left\\nint left=utilHelper.left;\\n\\n// maximum from right;\\nint right=utilHelper.right;\\n//checking for local maximum\\nint localMax=Math.max(Math.max(left,right)+root.val,root.val);\\n//checking for globalMax\\nglobalMax=Math.max(globalMax,Math.max(left+right+root.val,localMax));"
                    },
                    {
                        "username": "aks309",
                        "content": "[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nWhat is the max path for the above test case:\\n\\nMy understanding is whole tree: that is 55. But the output expected is 48. Not sure how. Any help.\\n"
                    },
                    {
                        "username": "YYANN",
                        "content": "you can\\'t include all the nodes in this tree in the path. a path must not have any bifurcations."
                    },
                    {
                        "username": "vg5",
                        "content": "I am not following why we are taking max(leftNode, 0) or max(rightNode, 0). What will happen if all nodes are negative? Please paste link if you have explanation for all negative value nodes."
                    },
                    {
                        "username": "peng19",
                        "content": "For test case [5,4,8,11,null,13,4,7,2,null,null,null,1], why is the expected value 48? Shouldn\\'t it be 55 which is all the vals added together?"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "\" A node can only appear in the sequence at most once. \"\\nIn a tree, (except one node) you cannot visit both of the children of any node without visiting the parent node twice!"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "I don\\'t understand. should not it be 55?"
                    }
                ]
            },
            {
                "id": 1571258,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1568939,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1968277,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1913206,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1713496,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1713041,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1712996,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1576840,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1574948,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1574635,
                "content": [
                    {
                        "username": "zlasd",
                        "content": "When you use Custom Testcase with a empty array like \"[]\", the expected answer will be the smallest int -2147483648, but I think the answer should be 0. Is it wrong?\\n![0_1474429308384_canvas.png](/uploads/files/1474429309724-canvas.png)"
                    },
                    {
                        "username": "linwei2",
                        "content": "> along the parent-child connections\\n\\nmeaning path can be either from parent to child or from child to parent, right? So the given example [1,2,3] returns 6 because 2->1->3 right?\\n\\nAny clarification will be appreciated."
                    },
                    {
                        "username": "shivamkabra07",
                        "content": "class Solution {\\n    int maxSum;\\n\\n    public int maxPathSum(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    public int helper(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n\\n        int left = Math.max(0, maxPathSum(root.left));\\n        int right = Math.max(0, maxPathSum(root.right));\\n\\n        maxSum = Math.max(maxSum, root.val+left+right);\\n\\n        return Math.max(left, right)+root.val;\\n\\n\\n    }\\n\\n    \\n}\\n\\n\\nwhy am i getting wrong answer for testcase [-2,1]"
                    },
                    {
                        "username": "imt2022073",
                        "content": "should path be complete from a leaf node to other or it can be okay if we leave path in between"
                    },
                    {
                        "username": "spookie886",
                        "content": "Same question here"
                    },
                    {
                        "username": "TheFatBallerina",
                        "content": "Why does my C code show Time Limit Exceeded at 91st test?\n`#define max(a,b) a>b?a:b`\n`int maxPathSum(struct TreeNode* root) {`\n`    int ans=INT_MIN;`\n`    int helper(struct TreeNode * root){`\n`        if(!root) return 0;`\n`        int left = max(helper(root->left),0);`\n`        int right = max(helper(root->right),0);`\n`        ans = max(ans , left+right+root->val);`\n`        return max(left+root->val,right+root->val);`\n`    }`\n`    helper(root);`\n`    return ans;`\n`}`\ni have tried changing it but it always shows a TLE at this testcase, does anyone have any idea why?\nhttps://pastebin.com/fZe8iwMQ\n"
                    },
                    {
                        "username": "GCarterII",
                        "content": "It appears to be a problem of 'double evaluation'. Now, this is based upon the flimsiest of understandings of C, but looking into it SO here (https://stackoverflow.com/questions/3437404/min-and-max-in-c) recommends not using a MAX macro like you did, when I changed your max definition to : \n```  \n#define max(a,b) \\\n   ({ __typeof__ (a) _a = (a); \\\n       __typeof__ (b) _b = (b); \\\n     _a > _b ? _a : _b; })\n```\nIt ran just fine and well within time. Another post on SO that I found useful to understand what was going on was this: https://stackoverflow.com/questions/39439181/what-is-double-evaluation-and-why-should-it-be-avoided\n\nHope that helps you!"
                    },
                    {
                        "username": "efim666",
                        "content": "Thought process of arriving at DFS solution\\n\\n// hm. this is the task that could be hard due to thinking up of the algo, not implementation.\\n// so, if we\\'re doing dfs, we\\'re visiting nodes and as inputs can have:\\n// - sum from the root to here (or previous max path)\\n// - sum in the left subtree\\n// - sum in the right subtree\\n//\\n// then previous path could be max and unconnected; or there could be another \"positive and connected\" so that potentially adding to children\\n// when returning from child it can also have some max unconnected and possibly positive & connected\\n//\\n// would I look over all possible connections this way?\\n// let\\'s say i\\'m in a node and have info on all 6 - for each (previous, leftChild, rightChild) i have (max unconnected) (positive connected)\\n// then the max-sum-path is either not going through the chlid-edge and one of (max unconnected), or goes through and max of possible positive connected paths + this.value\\n//\\n// problem here is that for left part of the tree the \"previous max unconnected\" is not actual max unconnected over the tree.\\n// and that\\'s potential problem because in the right tree there might be something connected to it to make that path more important\\n// but, if we\\'re finding some path bigger than that in the left tree, it will return to some node in the (prev unconnected) as unconnected max,\\n// and following nodes will be able to comopare them\\n// this seems to work.\\n//\\n// for proof i\\'d likely need induction?\\n// let\\'s just code this, if that\\'s possible at all?\\n//\\n// well, things are likely even simpler. no need to pass in parent information into children,\\n// only return from children maxUnconnected and maxConnected (to the parent Node). then in the root make final desicion.\\n\\n// ok, first implementation fails both tests, giving results that are smaller than required.\\n// that was because in the root of the recursion I used\\n//\\n// dfsSearchMaxSumPath(root)._2 - because of thought that I don\\'t want to force pick maxPath that goes through the root\\n// instead of\\n// val maxPaths = dfsSearchMaxSumPath(root)\\n// Math.max(maxPaths._1, maxPaths._2)\\n//\\n// but that was choosing max path that forced not to go through the root\\n//\\n// next - Wrong answer for : root = [-3]\\n// that\\'s because of my \"end of recursion return of (0,0) for null leaves\"\\n// what\\'s the best way then?\\n// Constraints:\\n// The number of nodes in the tree is in the range [1, 3 * 104].\\n// -1000 <= Node.val <= 1000\\n// it\\'s to add           node.value // if both left and right subtrees are negative\\n// right? and then I\\'d want to not have Int overflow\\n// so null node should be worse that the worst node? i.e -1001?\\n//\\n// that broke my \"calculate connected\" since it also didn\\'t include \"just node.value\"\\n// and for the node with 2 null children we were forcing sum with negative\\n"
                    },
                    {
                        "username": "enamoured07",
                        "content": "Hind:  \\u201CThose who forget history are condemned to repeat it\\u201D #DP\\nTry to get the answer for subtree. and perform some step with the current node using that subtree answer. \\n\\nBest of Luck"
                    },
                    {
                        "username": "shravek",
                        "content": "DoorDash Phone interview Max Path Sum between alive nodes; where alive nodes are leaf nodes of tree"
                    },
                    {
                        "username": "rakibulh9",
                        "content": "My submission is failing for this input [1,2,null,3,null,4,null,5]\\nCan this be a valid tree?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes! It looks like this. ( I replaced blank to dot(.), because this editor doesn't work for a blank spacing.)\n.................1\n.............../\n.............2\n............/\n..........3\n........./\n.......4\n....../\n.....5"
                    },
                    {
                        "username": "user6214s",
                        "content": "leetcode gives the following representation for a binary tree where the node with val 4 only has a right child with val 1 and where its sibling, with val 13, has no children:\\n\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nAm I missing something or does this acctually describe a tree where the 1-node is the right child of the 13-node and the 4-node has no children?  The 1 is the 13th entry in the list and the 6th node on the list is 13 not 4."
                    }
                ]
            },
            {
                "id": 1574522,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1574241,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1573743,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1573728,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1573179,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1573082,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1573043,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1573000,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1572765,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1572530,
                "content": [
                    {
                        "username": "smali",
                        "content": "I drew the tree and since all numbers are positive and connected, the answer should be 55. However, expected is 48 in the system. Why?\\n\\nInput: [5,4,8,11,null,13,4,7,2,null,null,null,1]\\nOutput: 55\\nExpected: 48\\n"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "because it adds upto 48 having a path like this (from bottom left of 7 uptill 5 then down to right 8 and 13 leaf node) so it has the values like -> 7+11+4+5+8+13 = 48"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/08/leetcode-problem-124-binary-tree.html\\nFor more solutions with explanations, Refer https://randomtechupdates.blogspot.com"
                    },
                    {
                        "username": "CNU_01",
                        "content": "https://randomtechupdates.blogspot.com/2020/05/leet-code-problem-124-binary-tree.html"
                    },
                    {
                        "username": "sbrshkappa",
                        "content": "The javascript test case for Input: `[0]` seems to be expecting the wrong answer of Expected: `42`. When I do a custom test case with the same input, the expected output is `0`. Looks like there is a bug in the JS test case. Is anyone else facing the same problem?\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882562.png)\\n\\n![image](https://assets.leetcode.com/users/sbrshkappa/image_1588882599.png)\\n"
                    },
                    {
                        "username": "saharshjain",
                        "content": "Make sure you haven\\'t taken global variables outside the function. Keep all variables inside. I faced the same issue. I think they are not running testcases separately thus sharing of vars is happening."
                    },
                    {
                        "username": "ali1112",
                        "content": "[1,2,null,3,null,4,null,5]\\n\\nHow this tree will look like if  draw this in graphical form?\\nwhich node is the parent of node value 4?\\n\\n0  1   2   3  4   5   6  7\\n[1,2,null,3,null,4,null,5]\\n\\nparent\\'s index  of node (value 4, index 5) should be at index 2, but value at index 2 is null.\\n\\nLittle cofused, please help me draw this tree."
                    },
                    {
                        "username": "dionwang",
                        "content": "Five years ago, this is a hard problem. But now it is an easy problem(leetcode 543).Sigh!"
                    },
                    {
                        "username": "gooca",
                        "content": "Why does [1,1,1,1,1,1,1] return 5? There\\'s no way I\\'m the only one confused"
                    },
                    {
                        "username": "Ashwin117",
                        "content": "I feel so stupid...I misunderstood this problem. My solution failed for this testcase:\\n[5,4,8,11,null,13,4,7,2,null,null,null,1]\\n\\nI got 55 but the answer is 48 ( I didn\\'t realize the definition of \"path\"). I didn\\'t know why for a while until I looked at the discussion board...then I was inspired to tweak my solution to get everything working.\\n\\n\\nI feel like an idiot. I had a phone screen earlier this week, and I screwed up because I misunderstood the problem. I don\\'t know why I keep misunderstanding things. Any tips on how to avoid/manage this? I have the ability to solve...but this stupid misunderstanding thing is screwing me over..."
                    },
                    {
                        "username": "xiaoxiangyue",
                        "content": "in my opinion, the answer shuld be 55, add them all together. \\nBut the expected answer is 48, how to get the 48?"
                    },
                    {
                        "username": "ngleet",
                        "content": "Why is output of [1, 2, 3] is 6 but [5,4,8,11,null,13,4,7,2,null,null,null,1] = 48 instead of 55?"
                    }
                ]
            },
            {
                "id": 1571918,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 1571256,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 1571257,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 1571259,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 1571260,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 1569854,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 1569832,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 1574464,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 2053458,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 2049353,
                "content": [
                    {
                        "username": "hanzhoutang",
                        "content": "When I try sample [1,2,3,4,5] the expected value is 11 instead of 15. Does anybody feel it\\'s strange and controversial? I mean, according to the define of \"path\" in this problem, the reuslt should be 15, isn\\'t it?\\n"
                    },
                    {
                        "username": "hanzhoutang",
                        "content": "**When the tree has nodes [1,2,1,10,10,1,1] , waht's the answer?**\\n![a tree which nodes are[1,2,1,10,10,1,1]](https://hanzhoutang.github.io/img/tree.png)\\n*The answer of example code is 22, but it may be 26?*"
                    },
                    {
                        "username": "mcopes",
                        "content": "I am curious about the top down solution, even if it is not efficient and it gets TLE."
                    },
                    {
                        "username": "yangyang",
                        "content": "I have a wrong result submission here while I doubt whether it's correct.\\nInput:\\t{1,-2,-3,1,3,-2,#,-1}\\nOutput:\\t2\\nExpected:\\t3\\nI think it should be 1 + -2 + 3 =2 \\nAnyone can help explain this please?"
                    },
                    {
                        "username": "princessmaja",
                        "content": "I found the solution to this problem in the \\n[old leet code discuss forum][1].\\n\\nI don't understand this line of code:\\n\\n     csum = max(node->val, max(node->val + lsum, node->val + rsum));\\n\\nWhy do we need to check if current node is greater than the sum of itself and its left and right subtree? Is it because a binary tree can contain negative numbers? If it contained only positive numbers, that check would be unnecessary, right? Or am I completely wrong here?\\n\\n  [1]: http://discuss.leetcode.com/questions/288/binary-tree-maximum-path-sum/356"
                    },
                    {
                        "username": "mindful_swe",
                        "content": "This question doesn\\'t seem Hard question, It should be put into Medium category rather than Hard."
                    },
                    {
                        "username": "ayush33",
                        "content": "how on earth can this problem be rated HARD??\\nit should be Easy-Medium or at max Medium."
                    },
                    {
                        "username": "user2733A",
                        "content": "![image](https://assets.leetcode.com/users/images/2a42beb2-3c92-4199-a2d3-0cea02bf0600_1602289027.1318507.png)\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Binary Tree Zigzag Level Order Traversal was far harder for me than this \\'hard\\' problem."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Initially I was thinking along the lines of Kadane\\'s algorithm + dfs. \\nTook me a while to figure out the correct solution, which was surprisingly easy."
                    }
                ]
            },
            {
                "id": 2044402,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 2043278,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 2043258,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 2029786,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 2015070,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 2011346,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 2001542,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 1995849,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 1985488,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 1976870,
                "content": [
                    {
                        "username": "Oyseen-W",
                        "content": "Why `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]` expects `16`, instead of `15`?"
                    },
                    {
                        "username": "talkjoey",
                        "content": "Not sure why expected output for this is 2 when it should be 1: [2,-1] \\nTest case #32"
                    },
                    {
                        "username": "trashw1n",
                        "content": "first hard i solved without any help lmao (that too under 10 minutes)"
                    },
                    {
                        "username": "matheusbafutto",
                        "content": "So happy was got to the editorial solution without needing to look! Even if it did take me 30 to 35 mins to do it :)"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "`Path => one way path` (cannot split in two directions in between)"
                    },
                    {
                        "username": "Tanmay2411",
                        "content": "Lol, I solved this question in just 14 lines... \\nEasiest hard question."
                    },
                    {
                        "username": "FoRKsH",
                        "content": "Hint\\nA path isn\\'t always leaf to leaf !"
                    },
                    {
                        "username": "aditya249645",
                        "content": "loved this question !!!"
                    },
                    {
                        "username": "weraponpat",
                        "content": "This should be easy level"
                    },
                    {
                        "username": "smarty_mk007",
                        "content": "This problem is more on the easier side."
                    }
                ]
            },
            {
                "id": 1968407,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1960420,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1954087,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1949563,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1948314,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1944726,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1936781,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1929615,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1904357,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1891895,
                "content": [
                    {
                        "username": "user3356Hq",
                        "content": "The test vector format limits a tree depth implicitly. Simple recursive algorithms accepted fail on JVM with Stack Overflow error on a linear sequence of nodes of length=30000."
                    },
                    {
                        "username": "pyush98",
                        "content": "This is the same problem as diameter of binary tree except you add the values instead of calculating depths and you eliminate negatives..."
                    },
                    {
                        "username": "josephcscarpa",
                        "content": "Yuh this def a medium sHaRaN"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "can someone let me know what is the problem with this code only 35 test cases are being passed \\n\\nIf someone knows please explain me I would really appreciate that\\n\\n\\nclass Solution {\\n   int  maxsum=Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        helper(root);\\n        return maxsum;\\n        \\n    }\\n    public int  helper(TreeNode root)\\n    {\\n        if(root==null)\\n           return 0;\\n       \\n         int ls=helper(root.left);\\n         int rs=helper(root.right);\\n        int s=ls+rs+root.val;\\n        if(s>maxsum)\\n            maxsum=s;\\n        return s;\\n\\n       \\n    }\\n}"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "you only need to return sum of root.val and maximum of left and right subtree.\\nCheck out my solution for reference\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/3694240/beats-99-2-c-solution-beats-99-2-detailed-and-easy-explanation/"
                    },
                    {
                        "username": "Sumitk999",
                        "content": "not even medium, it\\'s instant solution for one who has solved diameter of a tree problem"
                    },
                    {
                        "username": "randCoder",
                        "content": "Can somebody help me understand how answer for below tree is 20? Shouldn\\'t the path pass through leaf nodes?\\n\\n[-10,-9,20,null,null,-15,-7]"
                    },
                    {
                        "username": "spookie886",
                        "content": "Does a path have to include leaves?"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "for the testcase [2, -1, -2], shouldn\\'t the answer be 1? Expected output is 2 though, how?\\n\\n `     2      `\\n  ` /      \\\\`\\n`-1       -2`\\n\\nDoes \\'path\\' mean any path in the tree or only leaf to leaf?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question should be medium based on the concept involved. But it is categorized hard just because the question doesn\\'t explicitly discuss the edge cases and clarifies upon what all can be valid paths."
                    },
                    {
                        "username": "hemantkb2",
                        "content": "There seems to be a problem with accepted solution. \n\nFor the following test-case:\n\n```\n        10\n\n-20             -30\n```\n\n\nThe actual answer should be -10, however 10 is also accepted. "
                    },
                    {
                        "username": "dwsyip",
                        "content": "It doesn\\'t have to start or end in the leaf nodes or any other node to be specific. The minimum requirement is the path should not empty."
                    }
                ]
            },
            {
                "id": 1891194,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1881384,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1867463,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1809989,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1784664,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1741884,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1728215,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1723785,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1720514,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1719123,
                "content": [
                    {
                        "username": "user5763R",
                        "content": "Is path of single node also path or not? Path where you stay in some node."
                    },
                    {
                        "username": "KiranK111",
                        "content": "Can anyone please help me out whats wrong in my code:\\n\\nclass Solution:\\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\\n        ans= [root.val]\\n        def msp(root):\\n            if root==None:\\n                return 0\\n\\n            l = msp(root.left)\\n            r = msp(root.right)\\n            ans[0]=max(ans[0],(max(l,0)+max(r,0)+root.val))\\n            return max(l,0)+max(r,0)+root.val\\n        msp(root)\\n        return ans[0]"
                    },
                    {
                        "username": "nandapavan_26",
                        "content": "Intuition:\\nDFS and max between left and right subtree.\\n\\nApproach:\\nUse dfs ,at any node the situation is like it may contribute to the answer or it can not contribute to the answer.\\n\\n1)if it can contribute to the answer then it result is root->val+max from right subtree and + maximum left subtree \\n=> ans=max(ans,,root->val+max(0,right.mx)+max(0,left.mx));\\nelse do not consider that node.\\n\\nComplexity:\\nTime complexity: O(n)"
                    },
                    {
                        "username": "HoldenFordd",
                        "content": "Everyone has the same solution with different Title given to their post \\uD83D\\uDE02"
                    },
                    {
                        "username": "nimeshpareek25",
                        "content": "HINT: 1) left_sum + right_sum + node_value \\n          2) maintain a sum_count and for every node calculate \\n              max(sum_count,ls+rs+node->val)\\n          3) return max(ls+rs)+node->val\\n          4) make sure that while calling function for ls and rs you take \\n             max(0,sum(node->left,sum_count))\\n          5) for c++ coders you can make a different function named as sum ans in \\n              the function pass sum_count as reference, TreeNode root\\n\\n         This will handle all the negative roots also \\n\\n   \\n "
                    },
                    {
                        "username": "ramadanizm",
                        "content": "why test case 1 root = -3 does not pass --> my output  = 0 but the expected should be -3 ?\\n```\\nclass MaxHeightandPath{\\n  int maxSum ;\\n  int maxHeight;\\n  public MaxHeightandPath(int maxSum , int maxHeight){\\nthis.maxSum = maxSum;\\nthis.maxHeight = maxHeight;\\n  }\\n}\\n\\n\\nclass Solution {\\n  \\n  public MaxHeightandPath max_gain_helper(TreeNode node) {\\n    if (node == null) return new MaxHeightandPath (0,0);\\n\\nMaxHeightandPath left = max_gain_helper(node.left );\\nMaxHeightandPath right = max_gain_helper(node.right );\\n\\n    int maxSum = Math.max( Math.max(left.maxSum , right.maxSum ), node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0) );  // left .maxsum = right.maxsum?????\\n    int maxheight = node.val + Math.max(left.maxHeight, 0) + Math.max(right.maxHeight, 0); // return max height sum not length to this node\\n    return new MaxHeightandPath(maxSum, maxheight);\\n  }\\n\\n  public int maxPathSum(TreeNode root) {\\n    MaxHeightandPath result =  max_gain_helper(root);\\n    return result.maxSum;\\n  }\\n}\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/124_binatyTREE_max_path.cpp"
                    },
                    {
                        "username": "runninglzc",
                        "content": "I coded a solution assuming 1 node is not \\'NON-EMPTY\\', since there is no \\'PATH\\'... Problem description is very unclear."
                    },
                    {
                        "username": "Dark_kryptonian23",
                        "content": "Guys help me to debug this code!! This is always giving me 0\\n\\n  ```public:\\n    int maxPathSum(TreeNode* root) {\\n        int maxiPathSum = 0;\\n        maximum(root,maxiPathSum);\\n        return maxiPathSum;\\n        \\n    }\\nprivate:\\n    void maximum(TreeNode* root, int maxiPathSum){\\n        if(!root) return;\\n\\n       \\n        maxiPathSum += root -> val;\\n        if(root -> val > maxiPathSum){\\n            maxiPathSum = root -> val;\\n        }\\n        \\n        \\n         maximum(root -> left, maxiPathSum);\\n         maximum(root -> right, maxiPathSum);\\n\\n    }\\n}```"
                    },
                    {
                        "username": "GCarterII",
                        "content": "Your code looks like C/C++, and I\\'m pretty ignorant of them, but my first thought would be: \\nAre you passing the \\'maxiPathSum\\' by reference, or by value? \\nIf value, it would explain your constant 0 result. \\n\\nAlso, looks like your solution could use a bit of work, as the logic is missing some key points of the question.\\n\\nGood luck!"
                    }
                ]
            },
            {
                "id": 1714502,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713611,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713526,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713491,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713442,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713415,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713277,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713269,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713171,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            },
            {
                "id": 1713050,
                "content": [
                    {
                        "username": "Zhe_FunCoding",
                        "content": "The problem can actually solved in one traversal.\\nTips\\n1. Each node is responsible to make a decision for itself and the subtree.\\n2. There are some diff scenarios to consider. In order to create the final path : \\n   - only itself is selected\\n   - itself and one of its children are selected\\n   - itself and either one of or both children forms the max path\\n3. All nodes should know what\\'s the current max is. \\nGood luck"
                    },
                    {
                        "username": "sidd0203",
                        "content": "Can anyone explain how this problem is related to Dynamic Programming ?"
                    },
                    {
                        "username": "Balwierz",
                        "content": "The description does not state if the path can be an empty set of nodes.\\nCan it be?"
                    },
                    {
                        "username": "GCarterII",
                        "content": "apparently not, I just ran a test case with all negative nodes and the result is the smallest negative single node. In the question's defense an empty set would not be a path.\n\nETA: the description includes: Given the root of a binary tree, return the maximum path sum of any `non-empty` path."
                    },
                    {
                        "username": "piyush4299",
                        "content": "IMO, the crucial tip which I found a little tricky to get at first was negative sum from left and right subtree are eventually going to degrade/decrease the overall path sum so consider neglecting it by comparing it to 0."
                    },
                    {
                        "username": "bhaskar2840",
                        "content": "```class Solution {\\npublic:\\n    int dfs(TreeNode* root,int &ans){\\n        if(!root){\\n            return 0;\\n        }\\n        int lMax=dfs(root->left,ans);\\n        int rMax=dfs(root->right,ans);\\n        if(lMax<0){\\n            lMax=0;\\n        }\\n        if(rMax<0){\\n            rMax=0;\\n        }\\n        ans=max(ans,root->val+lMax+rMax);\\n        return root->val+max(lMax,rMax);\\n    }\\n    int maxPathSum(TreeNode* root) {\\n        int ans=INT_MIN;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mufassir",
                        "content": "Think about the Kadane\\'s Algorithm. Modify it a little and you will have your algorithm."
                    },
                    {
                        "username": "ashishshukla14",
                        "content": "Can a path may contain single node "
                    },
                    {
                        "username": "sparklingness",
                        "content": "Yes, you can!"
                    },
                    {
                        "username": "allabout_raj",
                        "content": "// Java Solution (Please Upvote)\\n//Approach-01\\n\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    public int maxPathSum(TreeNode root) {\\n        findMaxPathSum(root);\\n        return maxSum;\\n    }\\n\\n    public int findMaxPathSum(TreeNode root) {\\n         if(root == null) return 0;   \\n         int left =   Math.max(0, findMaxPathSum(root.left));   //why compare with 0\\n        //if 3,-12,-2 so findmax =-12 instead of returning -12 return 0 so comp with 0\\n         int right =  Math.max(0, findMaxPathSum(root.right));        \\n         maxSum = Math.max(maxSum , left + right + root.val);\\n         return Math.max(left, right) + root.val;\\n    }\\n}"
                    },
                    {
                        "username": "jason19990305",
                        "content": " `[9,6,-3,null,null,-6,2,null,null,2,null,-6,-6,-6]`\\nMy code output is 15. But expected output is 16. How to path sum to 16 from this tree?"
                    },
                    {
                        "username": "jason19990305",
                        "content": "[@amansingh4958](/amansingh4958) Thanks! I modify my code and submit complete."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "6 + 9 + (-3) + 2 + 2 = 16\\nThis is the calculation for the above test case"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I don\\'t understand what the path is from the description."
                    }
                ]
            }
        ]
    },
    {
        "title": "Basic Calculator",
        "question_content": "<p>Given a string <code>s</code> representing a valid expression, implement a basic calculator to evaluate it, and return <em>the result of the evaluation</em>.</p>\n\n<p><strong>Note:</strong> You are <strong>not</strong> allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;1 + 1&quot;\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot; 2-1 + 2 &quot;\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(1+(4+5+2)-3)+(6+8)&quot;\n<strong>Output:</strong> 23\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of digits, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, and <code>&#39; &#39;</code>.</li>\n\t<li><code>s</code> represents a valid expression.</li>\n\t<li><code>&#39;+&#39;</code> is <strong>not</strong> used as a unary operation (i.e., <code>&quot;+1&quot;</code> and <code>&quot;+(2 + 3)&quot;</code> is invalid).</li>\n\t<li><code>&#39;-&#39;</code> could be used as a unary operation (i.e., <code>&quot;-1&quot;</code> and <code>&quot;-(2 + 3)&quot;</code> is valid).</li>\n\t<li>There will be no two consecutive operators in the input.</li>\n\t<li>Every number and running calculation will fit in a signed 32-bit integer.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 62361,
                "title": "iterative-java-solution-with-stack",
                "content": "Simple iterative solution by identifying characters one by one. One important thing is that the input is valid, which means the parentheses are always paired and in order.\\nOnly 5 possible input we need to pay attention:\\n\\n 1. digit: it should be one digit from the current number\\n 2. '+': number is over, we can add the previous number and start a new number\\n 3. '-': same as above\\n 4. '(': push the previous result and the sign into the stack, set result to 0, just calculate the new result within the parenthesis.\\n 5. ')': pop out the top two numbers from stack, first one is the sign before this pair of parenthesis, second is the temporary result before this pair of parenthesis. We add them together.\\n \\n \\nFinally if there is only one number, from the above solution, we haven't add the number to the result, so we do a check see if the number is zero.\\n\\n----------\\n\\n\\n    public int calculate(String s) {\\n        Stack<Integer> stack = new Stack<Integer>();\\n        int result = 0;\\n        int number = 0;\\n        int sign = 1;\\n        for(int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n            if(Character.isDigit(c)){\\n                number = 10 * number + (int)(c - '0');\\n            }else if(c == '+'){\\n                result += sign * number;\\n                number = 0;\\n                sign = 1;\\n            }else if(c == '-'){\\n                result += sign * number;\\n                number = 0;\\n                sign = -1;\\n            }else if(c == '('){\\n                //we push the result first, then sign;\\n                stack.push(result);\\n                stack.push(sign);\\n                //reset the sign and result for the value in the parenthesis\\n                sign = 1;   \\n                result = 0;\\n            }else if(c == ')'){\\n                result += sign * number;  \\n                number = 0;\\n                result *= stack.pop();    //stack.pop() is the sign before the parenthesis\\n                result += stack.pop();   //stack.pop() now is the result calculated before the parenthesis\\n                \\n            }\\n        }\\n        if(number != 0) result += sign * number;\\n        return result;\\n    }",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Iterator"
                ],
                "code": "Simple iterative solution by identifying characters one by one. One important thing is that the input is valid, which means the parentheses are always paired and in order.\\nOnly 5 possible input we need to pay attention:\\n\\n 1. digit: it should be one digit from the current number\\n 2. '+': number is over, we can add the previous number and start a new number\\n 3. '-': same as above\\n 4. '(': push the previous result and the sign into the stack, set result to 0, just calculate the new result within the parenthesis.\\n 5. ')': pop out the top two numbers from stack, first one is the sign before this pair of parenthesis, second is the temporary result before this pair of parenthesis. We add them together.\\n \\n \\nFinally if there is only one number, from the above solution, we haven't add the number to the result, so we do a check see if the number is zero.\\n\\n----------\\n\\n\\n    public int calculate(String s) {\\n        Stack<Integer> stack = new Stack<Integer>();\\n        int result = 0;\\n        int number = 0;\\n        int sign = 1;\\n        for(int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n            if(Character.isDigit(c)){\\n                number = 10 * number + (int)(c - '0');\\n            }else if(c == '+'){\\n                result += sign * number;\\n                number = 0;\\n                sign = 1;\\n            }else if(c == '-'){\\n                result += sign * number;\\n                number = 0;\\n                sign = -1;\\n            }else if(c == '('){\\n                //we push the result first, then sign;\\n                stack.push(result);\\n                stack.push(sign);\\n                //reset the sign and result for the value in the parenthesis\\n                sign = 1;   \\n                result = 0;\\n            }else if(c == ')'){\\n                result += sign * number;  \\n                number = 0;\\n                result *= stack.pop();    //stack.pop() is the sign before the parenthesis\\n                result += stack.pop();   //stack.pop() now is the result calculated before the parenthesis\\n                \\n            }\\n        }\\n        if(number != 0) result += sign * number;\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 62362,
                "title": "java-easy-version-to-understand",
                "content": "    public static int calculate(String s) {\\n\\t\\tint len = s.length(), sign = 1, result = 0;\\n\\t\\tStack<Integer> stack = new Stack<Integer>();\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (Character.isDigit(s.charAt(i))) {\\n\\t\\t\\t\\tint sum = s.charAt(i) - '0';\\n\\t\\t\\t\\twhile (i + 1 < len && Character.isDigit(s.charAt(i + 1))) {\\n\\t\\t\\t\\t\\tsum = sum * 10 + s.charAt(i + 1) - '0';\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tresult += sum * sign;\\n\\t\\t\\t} else if (s.charAt(i) == '+')\\n\\t\\t\\t\\tsign = 1;\\n\\t\\t\\telse if (s.charAt(i) == '-')\\n\\t\\t\\t\\tsign = -1;\\n\\t\\t\\telse if (s.charAt(i) == '(') {\\n\\t\\t\\t\\tstack.push(result);\\n\\t\\t\\t\\tstack.push(sign);\\n\\t\\t\\t\\tresult = 0;\\n\\t\\t\\t\\tsign = 1;\\n\\t\\t\\t} else if (s.charAt(i) == ')') {\\n\\t\\t\\t\\tresult = result * stack.pop() + stack.pop();\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}",
                "solutionTags": [],
                "code": "    public static int calculate(String s) {\\n\\t\\tint len = s.length(), sign = 1, result = 0;\\n\\t\\tStack<Integer> stack = new Stack<Integer>();\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (Character.isDigit(s.charAt(i))) {\\n\\t\\t\\t\\tint sum = s.charAt(i) - '0';\\n\\t\\t\\t\\twhile (i + 1 < len && Character.isDigit(s.charAt(i + 1))) {\\n\\t\\t\\t\\t\\tsum = sum * 10 + s.charAt(i + 1) - '0';\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tresult += sum * sign;\\n\\t\\t\\t} else if (s.charAt(i) == '+')\\n\\t\\t\\t\\tsign = 1;\\n\\t\\t\\telse if (s.charAt(i) == '-')\\n\\t\\t\\t\\tsign = -1;\\n\\t\\t\\telse if (s.charAt(i) == '(') {\\n\\t\\t\\t\\tstack.push(result);\\n\\t\\t\\t\\tstack.push(sign);\\n\\t\\t\\t\\tresult = 0;\\n\\t\\t\\t\\tsign = 1;\\n\\t\\t\\t} else if (s.charAt(i) == ')') {\\n\\t\\t\\t\\tresult = result * stack.pop() + stack.pop();\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1456850,
                "title": "python-basic-calculator-i-ii-iii-easy-solution-detailed-explanation",
                "content": "This algorithm works for `Basic Calculator (BC I)` problem, where we can have only `+ - ( )` operations, for `Basic Calculator II (BC II)`, where we can have only `+ - * /` operations and also for `Basic Calculator III (BC III)`, where we can have all `+ - * / ( )` operations.\\n\\n### Stack of monomials\\nThe idea is to use both stack and recursion (which can be seen as 2 stack, because recursion use implicit stack). First, let us consider, that we do not have any brackets. Then let us keep the stack of monomial, consider the example `s = 1*2 - 3\\\\4*5 + 6`.  Then we want our stack to be equal to `[1*2, -3\\\\4*5, 6]`, let us do it step by step:\\n1. Put 1 into stack, we have `stack = [1]`.\\n2. We can see that operation is equal to `*`, so we pop the last element from our stack and put new element: `1*2`, now `stack = [1*2]`.\\n3. Now, operation is equal to `-`, so we  put `-3` to stack and we have `stack = [1*2, -3]` now\\n4. Now, operation is equal to `\\\\`, so we pop the last element from stack and put `-3\\\\4` instead, `stack = [1*2, -3\\\\4]`\\n5. Now, operation is equal to `*`, so we pop last element from stack and put `-3\\\\4*5` instead, `stack = [1*2, -3\\\\4*5]`.\\n6. Finally, operation is equal to `+`, so we put `6` to stack: `stack = [1*2, -3\\\\4*5, 6]`\\n\\nNow, all we need to do is to return sum of all elements in stack.\\n\\n### How to deal with brackets\\nIf we want to be able to process the brackets properly, all we need to do is to call our calculator recursively! When we see the open bracket `(`, we call calculator with the rest of our string, and when we see closed bracket \\')\\', we give back the value of expression inside brackets and the place where we need to start when we go out of recursion.\\n\\n\\n### Complexity\\nEven though we have stack and also have recursion, we process every element only once, so time complexity is `O(n)`. However we pass slice of string as argument each time we meet bracket, so time complexity can go upto `O(n^2)` on example like `(1+(1+(... +)))` with `O(n)` open brackets. Space complexity is potentially `O(n)`, because we need to keep stacks, but each element not more than once.\\n\\n``` \\nclass Solution:\\n    def calculate(self, s):\\n        def update(op, v):\\n            if op == \"+\": stack.append(v)\\n            if op == \"-\": stack.append(-v)\\n            if op == \"*\": stack.append(stack.pop() * v)           #for BC II and BC III\\n            if op == \"/\": stack.append(int(stack.pop() / v))      #for BC II and BC III\\n    \\n        it, num, stack, sign = 0, 0, [], \"+\"\\n        \\n        while it < len(s):\\n            if s[it].isdigit():\\n                num = num * 10 + int(s[it])\\n            elif s[it] in \"+-*/\":\\n                update(sign, num)\\n                num, sign = 0, s[it]\\n            elif s[it] == \"(\":                                        # For BC I and BC III\\n                num, j = self.calculate(s[it + 1:])\\n                it = it + j\\n            elif s[it] == \")\":                                        # For BC I and BC III\\n                update(sign, num)\\n                return sum(stack), it + 1\\n            it += 1\\n        update(sign, num)\\n        return sum(stack)\\n```\\n\\n#### Solution 2\\nThe problem of previous code is that we pass slice of string as parameter. In python it works quite fast, because function is implemented in C and it works very fast. If we want to have honest linear time, we need to pass index as parameter. (there is alternative way like I used in problem **1896** https://leetcode.com/problems/minimum-cost-to-change-the-final-value-of-expression/discuss/1267304/Python-Recursion-dfs-solution-explained, where we can precalculate pairs of open and closing brackets)\\n\\n#### Complexity\\nNow time complexity it is `O(n)`, space is still `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def calculate(self, s):    \\n        def calc(it):\\n            def update(op, v):\\n                if op == \"+\": stack.append(v)\\n                if op == \"-\": stack.append(-v)\\n                if op == \"*\": stack.append(stack.pop() * v)\\n                if op == \"/\": stack.append(int(stack.pop() / v))\\n        \\n            num, stack, sign = 0, [], \"+\"\\n            \\n            while it < len(s):\\n                if s[it].isdigit():\\n                    num = num * 10 + int(s[it])\\n                elif s[it] in \"+-*/\":\\n                    update(sign, num)\\n                    num, sign = 0, s[it]\\n                elif s[it] == \"(\":\\n                    num, j = calc(it + 1)\\n                    it = j - 1\\n                elif s[it] == \")\":\\n                    update(sign, num)\\n                    return sum(stack), it + 1\\n                it += 1\\n            update(sign, num)\\n            return sum(stack)\\n\\n        return calc(0)\\n```",
                "solutionTags": [
                    "Stack",
                    "Recursion"
                ],
                "code": "``` \\nclass Solution:\\n    def calculate(self, s):\\n        def update(op, v):\\n            if op == \"+\": stack.append(v)\\n            if op == \"-\": stack.append(-v)\\n            if op == \"*\": stack.append(stack.pop() * v)           #for BC II and BC III\\n            if op == \"/\": stack.append(int(stack.pop() / v))      #for BC II and BC III\\n    \\n        it, num, stack, sign = 0, 0, [], \"+\"\\n        \\n        while it < len(s):\\n            if s[it].isdigit():\\n                num = num * 10 + int(s[it])\\n            elif s[it] in \"+-*/\":\\n                update(sign, num)\\n                num, sign = 0, s[it]\\n            elif s[it] == \"(\":                                        # For BC I and BC III\\n                num, j = self.calculate(s[it + 1:])\\n                it = it + j\\n            elif s[it] == \")\":                                        # For BC I and BC III\\n                update(sign, num)\\n                return sum(stack), it + 1\\n            it += 1\\n        update(sign, num)\\n        return sum(stack)\\n```\n```python\\nclass Solution:\\n    def calculate(self, s):    \\n        def calc(it):\\n            def update(op, v):\\n                if op == \"+\": stack.append(v)\\n                if op == \"-\": stack.append(-v)\\n                if op == \"*\": stack.append(stack.pop() * v)\\n                if op == \"/\": stack.append(int(stack.pop() / v))\\n        \\n            num, stack, sign = 0, [], \"+\"\\n            \\n            while it < len(s):\\n                if s[it].isdigit():\\n                    num = num * 10 + int(s[it])\\n                elif s[it] in \"+-*/\":\\n                    update(sign, num)\\n                    num, sign = 0, s[it]\\n                elif s[it] == \"(\":\\n                    num, j = calc(it + 1)\\n                    it = j - 1\\n                elif s[it] == \")\":\\n                    update(sign, num)\\n                    return sum(stack), it + 1\\n                it += 1\\n            update(sign, num)\\n            return sum(stack)\\n\\n        return calc(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62344,
                "title": "easy-18-lines-c-16-lines-python",
                "content": "Keep a global running total and a stack of signs (+1 or -1), one for each open scope. The \"global\" outermost sign is +1.\\n\\n- Each number consumes a sign.\\n- Each `+` and `-` causes a new sign.\\n- Each `(` duplicates the current sign so it can be used for the first term inside the new scope. That's also why I start with `[1, 1]` - the global sign 1 and a duplicate to be used for the first term, since expressions start like `3...` or `(...`, not like `+3...` or `+(...`.\\n- Each `)` closes the current scope and thus drops the current sign.\\n\\nAlso see the example trace below my programs.\\n\\n**C++:**\\n\\n    int calculate(string s) {\\n        int total = 0;\\n        vector<int> signs(2, 1);\\n        for (int i=0; i<s.size(); i++) {\\n            char c = s[i];\\n            if (c >= '0') {\\n                int number = 0;\\n                while (i < s.size()  &&  s[i] >= '0')\\n                    number = 10 * number + s[i++] - '0';\\n                total += signs.back() * number;\\n                signs.pop_back();\\n                i--;\\n            }\\n            else if (c == ')')\\n                signs.pop_back();\\n            else if (c != ' ')\\n                signs.push_back(signs.back() * (c == '-' ? -1 : 1));\\n        }\\n        return total;\\n    }\\n\\n**Python:**\\n\\n    def calculate(self, s):\\n        total = 0\\n        i, signs = 0, [1, 1]\\n        while i < len(s):\\n            c = s[i]\\n            if c.isdigit():\\n                start = i\\n                while i < len(s) and s[i].isdigit():\\n                    i += 1\\n                total += signs.pop() * int(s[start:i])\\n                continue\\n            if c in '+-(':\\n                signs += signs[-1] * (1, -1)[c == '-'],\\n            elif c == ')':\\n                signs.pop()\\n            i += 1\\n        return total\\n\\n**Example trace:**\\n\\nHere's an example trace for input `3-(2+(9-4))`.\\n\\n      remaining   sign stack      total\\n    3-(2+(9-4))   [1, 1]            0\\n     -(2+(9-4))   [1]               3\\n      (2+(9-4))   [1, -1]           3\\n       2+(9-4))   [1, -1, -1]       3\\n        +(9-4))   [1, -1]           1\\n         (9-4))   [1, -1, -1]       1\\n          9-4))   [1, -1, -1, -1]   1\\n           -4))   [1, -1, -1]      -8\\n            4))   [1, -1, -1, 1]   -8\\n             ))   [1, -1, -1]      -4\\n              )   [1, -1]          -4\\n                  [1]              -4\\n\\nIf you want to see traces for other examples, you can add this at the start inside the loop and after the loop (that's for the Python solution, where it's all easier):\\n\\n    print '%11s   %-16s %2d' % (s[i:], signs, total)",
                "solutionTags": [
                    "C++",
                    "Python"
                ],
                "code": "Keep a global running total and a stack of signs (+1 or -1), one for each open scope. The \"global\" outermost sign is +1.\\n\\n- Each number consumes a sign.\\n- Each `+` and `-` causes a new sign.\\n- Each `(` duplicates the current sign so it can be used for the first term inside the new scope. That's also why I start with `[1, 1]` - the global sign 1 and a duplicate to be used for the first term, since expressions start like `3...` or `(...`, not like `+3...` or `+(...`.\\n- Each `)` closes the current scope and thus drops the current sign.\\n\\nAlso see the example trace below my programs.\\n\\n**C++:**\\n\\n    int calculate(string s) {\\n        int total = 0;\\n        vector<int> signs(2, 1);\\n        for (int i=0; i<s.size(); i++) {\\n            char c = s[i];\\n            if (c >= '0') {\\n                int number = 0;\\n                while (i < s.size()  &&  s[i] >= '0')\\n                    number = 10 * number + s[i++] - '0';\\n                total += signs.back() * number;\\n                signs.pop_back();\\n                i--;\\n            }\\n            else if (c == ')')\\n                signs.pop_back();\\n            else if (c != ' ')\\n                signs.push_back(signs.back() * (c == '-' ? -1 : 1));\\n        }\\n        return total;\\n    }\\n\\n**Python:**\\n\\n    def calculate(self, s):\\n        total = 0\\n        i, signs = 0, [1, 1]\\n        while i < len(s):\\n            c = s[i]\\n            if c.isdigit():\\n                start = i\\n                while i < len(s) and s[i].isdigit():\\n                    i += 1\\n                total += signs.pop() * int(s[start:i])\\n                continue\\n            if c in '+-(':\\n                signs += signs[-1] * (1, -1)[c == '-'],\\n            elif c == ')':\\n                signs.pop()\\n            i += 1\\n        return total\\n\\n**Example trace:**\\n\\nHere's an example trace for input `3-(2+(9-4))`.\\n\\n      remaining   sign stack      total\\n    3-(2+(9-4))   [1, 1]            0\\n     -(2+(9-4))   [1]               3\\n      (2+(9-4))   [1, -1]           3\\n       2+(9-4))   [1, -1, -1]       3\\n        +(9-4))   [1, -1]           1\\n         (9-4))   [1, -1, -1]       1\\n          9-4))   [1, -1, -1, -1]   1\\n           -4))   [1, -1, -1]      -8\\n            4))   [1, -1, -1, 1]   -8\\n             ))   [1, -1, -1]      -4\\n              )   [1, -1]          -4\\n                  [1]              -4\\n\\nIf you want to see traces for other examples, you can add this at the start inside the loop and after the loop (that's for the Python solution, where it's all easier):\\n\\n    print '%11s   %-16s %2d' % (s[i:], signs, total)",
                "codeTag": "Python3"
            },
            {
                "id": 62424,
                "title": "python-concise-solution-with-stack",
                "content": "        \\n    def calculate(self, s):\\n        res, num, sign, stack = 0, 0, 1, []\\n        for ss in s:\\n            if ss.isdigit():\\n                num = 10*num + int(ss)\\n            elif ss in [\"-\", \"+\"]:\\n                res += sign*num\\n                num = 0\\n                sign = [-1, 1][ss==\"+\"]\\n            elif ss == \"(\":\\n                stack.append(res)\\n                stack.append(sign)\\n                sign, res = 1, 0\\n            elif ss == \")\":\\n                res += sign*num\\n                res *= stack.pop()\\n                res += stack.pop()\\n                num = 0\\n        return res + num*sign",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "        \\n    def calculate(self, s):\\n        res, num, sign, stack = 0, 0, 1, []\\n        for ss in s:\\n            if ss.isdigit():\\n                num = 10*num + int(ss)\\n            elif ss in [\"-\", \"+\"]:\\n                res += sign*num\\n                num = 0\\n                sign = [-1, 1][ss==\"+\"]\\n            elif ss == \"(\":\\n                stack.append(res)\\n                stack.append(sign)\\n                sign, res = 1, 0\\n            elif ss == \")\":\\n                res += sign*num\\n                res *= stack.pop()\\n                res += stack.pop()\\n                num = 0\\n        return res + num*sign",
                "codeTag": "Python3"
            },
            {
                "id": 62377,
                "title": "16-ms-solution-in-c-with-stacks",
                "content": "    class Solution {\\n    public:\\n        int calculate(string s) {\\n            stack <int> nums, ops;\\n            int num = 0;\\n            int rst = 0;\\n            int sign = 1;\\n            for (char c : s) { \\n                if (isdigit(c)) {\\n                    num = num * 10 + c - '0';\\n                }\\n                else {\\n                    rst += sign * num;\\n                    num = 0;\\n                    if (c == '+') sign = 1;\\n                    if (c == '-') sign = -1;\\n                    if (c == '(') {\\n                        nums.push(rst);\\n                        ops.push(sign);\\n                        rst = 0;\\n                        sign = 1;\\n                    }\\n                    if (c == ')' && ops.size()) {\\n                        rst = ops.top() * rst + nums.top();\\n                        ops.pop(); nums.pop();\\n                    }\\n                }\\n            }\\n            rst += sign * num;\\n            return rst;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int calculate(string s) {\\n            stack <int> nums, ops;\\n            int num = 0;\\n            int rst = 0;\\n            int sign = 1;\\n            for (char c : s) { \\n                if (isdigit(c)) {\\n                    num = num * 10 + c - '0';\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1457045,
                "title": "c-explained-stacks-beginner-friendly-easy-to-understand",
                "content": "# ***Approach***\\n```\\nThis is a very good stacks problem , we are given an expression in form of string with \\nchars as [nums , \\'(\\' , \\')\\' , \\'+\\' , \\'-\\' , \\' \\']\\n\\nNote : we can totally ignore \\' \\' and  \\'+\\'.\\n    \\nLogic:\\n        what we are going to do is very simple , \\n        first intilaize two vars , sum and sign\\n        sum = 0\\n        sign = +1\\n            \\n        traverse the string:\\n            if(ch is digit)\\n                num = get_full_num; // may be multidigit\\n                add it to sum , sum += (num * sign)\\n                reset sign to +1\\n            else if(ch is \\'(\\')\\n                save current state of sum and sign in stack\\n                reset sum and sign\\n            else if(ch is \\')\\')\\n                sum = val_at_top + (sign_at_top * sum)\\n                pop;\\n            else if(ch is \\'-\\')\\n                toggle sign\\n                \\n       the use of sum and sign are to evaluate current expression inside a () braces or completely outside\\n       stack is used to store the state of sum and sign take example\\n       1 + 2 + 3 - (5 + 6) => 6 - (5 + 6)\\n                when we encounter \\'(\\' saving state means\\n                stack will store pair(6 , -) and first calculate (5 + 6)\\n                once (5 + 6) is calculated which is 11\\n                pop from stack => sum = (6 + (sum * -1)) = (6 + (11 * -1)) = -5 ans\\n```\\n# ***Code***\\n```\\nclass Solution {\\npublic:\\n   int calculate(string s) {\\n       stack<pair<int,int>> st; // pair(prev_calc_value , sign before next bracket () )\\n       \\n       long long int sum = 0;\\n       int sign = +1;\\n       \\n       for(int i = 0 ; i < s.size() ; ++i)\\n       {\\n           char ch = s[i];\\n           \\n           if(isdigit(ch))\\n           {\\n               long long int num = 0;\\n               while(i < s.size() and isdigit(s[i]))\\n               {\\n                   num = (num * 10) + s[i] - \\'0\\';\\n                   i++;\\n               }\\n               i--; // as for loop also increase i , so if we don\\'t decrease i here a sign will be skipped\\n               sum += (num * sign);\\n               sign = +1; // reseting sign\\n           }\\n           else if(ch == \\'(\\')\\n           {\\n               // Saving current state of (sum , sign) in stack\\n               st.push(make_pair(sum , sign));\\n               \\n               // Reseting sum and sign for inner bracket calculation\\n               sum = 0; \\n               sign = +1;\\n           }\\n           else if(ch == \\')\\')\\n           {\\n               sum = st.top().first + (st.top().second * sum);\\n               st.pop();\\n           }\\n           else if(ch == \\'-\\')\\n           {\\n               // toggle sign\\n               sign = (-1 * sign);\\n           }\\n       }\\n       return sum;\\n   }\\n};\\n```\\n# ***If you liked the solution , Please Upvote!!!***",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nThis is a very good stacks problem , we are given an expression in form of string with \\nchars as [nums , \\'(\\' , \\')\\' , \\'+\\' , \\'-\\' , \\' \\']\\n\\nNote : we can totally ignore \\' \\' and  \\'+\\'.\\n    \\nLogic:\\n        what we are going to do is very simple , \\n        first intilaize two vars , sum and sign\\n        sum = 0\\n        sign = +1\\n            \\n        traverse the string:\\n            if(ch is digit)\\n                num = get_full_num; // may be multidigit\\n                add it to sum , sum += (num * sign)\\n                reset sign to +1\\n            else if(ch is \\'(\\')\\n                save current state of sum and sign in stack\\n                reset sum and sign\\n            else if(ch is \\')\\')\\n                sum = val_at_top + (sign_at_top * sum)\\n                pop;\\n            else if(ch is \\'-\\')\\n                toggle sign\\n                \\n       the use of sum and sign are to evaluate current expression inside a () braces or completely outside\\n       stack is used to store the state of sum and sign take example\\n       1 + 2 + 3 - (5 + 6) => 6 - (5 + 6)\\n                when we encounter \\'(\\' saving state means\\n                stack will store pair(6 , -) and first calculate (5 + 6)\\n                once (5 + 6) is calculated which is 11\\n                pop from stack => sum = (6 + (sum * -1)) = (6 + (11 * -1)) = -5 ans\\n```\n```\\nclass Solution {\\npublic:\\n   int calculate(string s) {\\n       stack<pair<int,int>> st; // pair(prev_calc_value , sign before next bracket () )\\n       \\n       long long int sum = 0;\\n       int sign = +1;\\n       \\n       for(int i = 0 ; i < s.size() ; ++i)\\n       {\\n           char ch = s[i];\\n           \\n           if(isdigit(ch))\\n           {\\n               long long int num = 0;\\n               while(i < s.size() and isdigit(s[i]))\\n               {\\n                   num = (num * 10) + s[i] - \\'0\\';\\n                   i++;\\n               }\\n               i--; // as for loop also increase i , so if we don\\'t decrease i here a sign will be skipped\\n               sum += (num * sign);\\n               sign = +1; // reseting sign\\n           }\\n           else if(ch == \\'(\\')\\n           {\\n               // Saving current state of (sum , sign) in stack\\n               st.push(make_pair(sum , sign));\\n               \\n               // Reseting sum and sign for inner bracket calculation\\n               sum = 0; \\n               sign = +1;\\n           }\\n           else if(ch == \\')\\')\\n           {\\n               sum = st.top().first + (st.top().second * sum);\\n               st.pop();\\n           }\\n           else if(ch == \\'-\\')\\n           {\\n               // toggle sign\\n               sign = (-1 * sign);\\n           }\\n       }\\n       return sum;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831471,
                "title": "python3-stack-approach-with-detailed-explanations-o-n",
                "content": "(1) The trick is to use ```sign``` to store the \\'+\\' and \\'-\\' during the process.\\n```sign = 1 for \\'+\\'``` and ```sign = -1 for \\'-\\'```\\n\\n(2) We use ```num``` to hold the current number that we are constructing, and ```sign``` to hold the \\'+\\' (1) or \\'-\\' (-1) **BEFORE** the current number.\\n\\n(3) The evaluation happends whenever we see a operator, we add the ```num * sign``` to the last element in the ```stack```.\\n\\n\\n(4) Whenever we see ```(``` we will put ```sign``` into the stack and a ```0``` at the end ```stack[-1] = 0```, ```stack[-1]``` will be updated when we are evaluating the expression inside this ```()```.\\n\\n```stack``` holds the evaluation results where the last element is the one we are currently working on. For example, if we are evaluating things inside a ```()```, stack[-1] should represent the current evaluation result inside this ```()```.\\n```e.g., \\ns = \"1+2+(3+4)\" and we are currently at the number 4,\\nstack = [3, 1, 3], the first 3 is 1+2, the 1 is the sign of the (), and the last 3 is the number we are working on.\\n```\\n\\n(5) Whenever we see ```)``` we know that there has to be a ```(``` before, and the current stack should looks like this: \\n\\n[........, ```sign```, everything in this ```()``` ending with the current ```)``` except the current ```num``` and ```sign``` we are holding], \\n\\nso we will\\n\\t- pop the last element and combine it with the current ```num``` and ```sign``` we are holding.\\n\\t- pop the last element again which is the ```sign``` for this ```()```, and muitiply them together.\\n\\t- add everything we get from this ```()``` to the last element in the stack\\n\\n(6) At the end, we need to add the current ```num``` and ```sign``` we are holding to the result (note that if the expression ended with a ```)```, ```num``` will be 0).\\n\\n```python\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n    \\t\\n    \\t### num is the current number we are constructing\\n    \\t\\n    \\t### sign is the \\'+\\' or \\'-\\' before the current number we are constructing/holding\\n    \\t### Note that we initialize sign with 1 to represent \\'+\\'\\n    \\t\\n    \\t### The last element in the stack will be the number we are updating during the \\n    \\t### process, so put a 0 in it.\\n        num, sign, stack = 0, 1, [0]\\n\\n        for c in s:\\n\\n        \\t### Constructing the number.\\n            if c.isdigit():\\n                num = num*10 + int(c)\\n\\n            ### Skip the space\\n            elif c==\\' \\':\\n                continue\\n\\n            ### When we see \\'+\\', we need to multiply the current number we are holding with the \\n            ### sign before this number, and update the last element in the stack.\\n            ### We also need to reset num to 0 and sign to 1\\n            elif c == \\'+\\':\\n                stack[-1] += num * sign\\n                sign = 1\\n                num = 0\\n\\n            ### Doing the same thing as \\'+\\', but reset sign to -1\\n            elif c == \\'-\\':\\n                stack[-1] += num * sign\\n                sign = -1\\n                num = 0\\n\\n            ### We add sign to stack which represent the sign of this ()\\n            ### We also add a 0 so we can keep update while evaluating the expression inside this ()\\n            ### Reset num and sign again\\n            elif c == \\'(\\':\\n                stack.extend([sign,0])\\n                sign = 1\\n                num = 0\\n\\n            ### pop the last element and combine it with the current num and sign we are holding (the last element inside this \\'()\\' ).\\n\\t\\t\\t### pop the last element again which is the sign for this \\'()\\' and muitiply them together.\\n\\t\\t\\t### add everything we get inside this \\'()\\' to the last element in the stack.\\n            elif c == \\')\\':\\n                lastNum = (stack.pop() + num*sign) * stack.pop()\\n                stack[-1] += lastNum\\n                sign = 1\\n                num = 0\\n                \\n        ### stack should only contain one element representing everything except the last number if the expression ended with a number, so add the current num we are holding to the result.\\n        return stack[-1]+num*sign\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```sign```\n```sign = 1 for \\'+\\'```\n```sign = -1 for \\'-\\'```\n```num```\n```sign```\n```num * sign```\n```stack```\n```(```\n```sign```\n```0```\n```stack[-1] = 0```\n```stack[-1]```\n```()```\n```stack```\n```()```\n```()```\n```e.g., \\ns = \"1+2+(3+4)\" and we are currently at the number 4,\\nstack = [3, 1, 3], the first 3 is 1+2, the 1 is the sign of the (), and the last 3 is the number we are working on.\\n```\n```)```\n```(```\n```sign```\n```()```\n```)```\n```num```\n```sign```\n```num```\n```sign```\n```sign```\n```()```\n```()```\n```num```\n```sign```\n```)```\n```num```\n```python\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n    \\t\\n    \\t### num is the current number we are constructing\\n    \\t\\n    \\t### sign is the \\'+\\' or \\'-\\' before the current number we are constructing/holding\\n    \\t### Note that we initialize sign with 1 to represent \\'+\\'\\n    \\t\\n    \\t### The last element in the stack will be the number we are updating during the \\n    \\t### process, so put a 0 in it.\\n        num, sign, stack = 0, 1, [0]\\n\\n        for c in s:\\n\\n        \\t### Constructing the number.\\n            if c.isdigit():\\n                num = num*10 + int(c)\\n\\n            ### Skip the space\\n            elif c==\\' \\':\\n                continue\\n\\n            ### When we see \\'+\\', we need to multiply the current number we are holding with the \\n            ### sign before this number, and update the last element in the stack.\\n            ### We also need to reset num to 0 and sign to 1\\n            elif c == \\'+\\':\\n                stack[-1] += num * sign\\n                sign = 1\\n                num = 0\\n\\n            ### Doing the same thing as \\'+\\', but reset sign to -1\\n            elif c == \\'-\\':\\n                stack[-1] += num * sign\\n                sign = -1\\n                num = 0\\n\\n            ### We add sign to stack which represent the sign of this ()\\n            ### We also add a 0 so we can keep update while evaluating the expression inside this ()\\n            ### Reset num and sign again\\n            elif c == \\'(\\':\\n                stack.extend([sign,0])\\n                sign = 1\\n                num = 0\\n\\n            ### pop the last element and combine it with the current num and sign we are holding (the last element inside this \\'()\\' ).\\n\\t\\t\\t### pop the last element again which is the sign for this \\'()\\' and muitiply them together.\\n\\t\\t\\t### add everything we get inside this \\'()\\' to the last element in the stack.\\n            elif c == \\')\\':\\n                lastNum = (stack.pop() + num*sign) * stack.pop()\\n                stack[-1] += lastNum\\n                sign = 1\\n                num = 0\\n                \\n        ### stack should only contain one element representing everything except the last number if the expression ended with a number, so add the current num we are holding to the result.\\n        return stack[-1]+num*sign\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62372,
                "title": "accepted-java-infix-to-postfix-based-solution-with-explaination-600ms",
                "content": "The solution has 2 steps:\\n\\n  1. parse the input string and convert it to postfix notation.\\n  2. evaluate the postfix string from step 1.\\n\\n**Infix to postfix conversion** \\n\\nconverting a simple expression string that doesn't contain brackets to postfix is explained [here][1]. You can imagine the expression between brackets as a new simple expression (which we know how to convert to postfix). So when we encounter opening bracket \"(\" push it to the top stack. When we encounter a closing bracket \")\" keep popping from stack until we find the matching \"(\", here we are removing all operators that belong to the expression between brackets. Then pop the \"(\" from the stack.\\n\\nOne more thing to take into consideration, we don't want any operator to pop the \"(\" from the stack except the \")\". We can handle this be assigning the \"(\" the lowest rank such that no operator can pop it.\\n\\n\\n**Evaluate postfix expression**\\n\\npostfix evaluation is explained [here][2]\\n\\nIf you have any ideas how to cut down the run time, please share your ideas :D.\\n\\nDisclaimer: I didn't write the included links, however I find them simple and neat.\\n\\n\\n    public class Solution {\\n    \\tint rank(char op){\\n    \\t    // the bigger the number, the higher the rank\\n    \\t    switch(op){\\n    \\t        case '+':return 1;\\n    \\t        case '-':return 1;\\n    \\t        case '*':return 2;\\n    \\t        case '/':return 2;\\n    \\t        default :return 0; // '(' \\n    \\t    }\\n    \\t}\\n    \\tList<Object> infixToPostfix(String s) {\\n    \\t\\tStack<Character> operators = new Stack<Character>();\\n    \\t\\tList<Object> postfix = new LinkedList<Object>();\\n    \\n    \\t\\tint numberBuffer = 0;\\n    \\t\\tboolean bufferingOperand = false;\\n    \\t\\tfor (char c : s.toCharArray()) {\\n    \\t\\t\\tif (c >= '0' && c <= '9') {\\n    \\t\\t\\t\\tnumberBuffer = numberBuffer * 10 + c - '0';\\n    \\t\\t\\t\\tbufferingOperand = true;\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tif(bufferingOperand)\\n    \\t\\t\\t\\t\\tpostfix.add(numberBuffer);\\n    \\t\\t\\t\\tnumberBuffer = 0;\\n    \\t\\t\\t\\tbufferingOperand = false;\\n    \\t\\t\\t\\t\\n    \\t\\t\\t\\tif (c == ' '|| c == '\\\\t')\\n    \\t\\t\\t\\t\\tcontinue;\\n    \\t\\t\\t\\t\\n    \\t\\t\\t\\tif (c == '(') {\\n    \\t\\t\\t\\t\\toperators.push('(');\\n    \\t\\t\\t\\t} else if (c == ')') {\\n    \\t\\t\\t\\t\\twhile (operators.peek() != '(')\\n    \\t\\t\\t\\t\\t\\tpostfix.add(operators.pop());\\n    \\t\\t\\t\\t\\toperators.pop(); // popping \"(\"\\n    \\t\\t\\t\\t} else { // operator\\n    \\t\\t\\t\\t\\twhile (!operators.isEmpty() && rank(c) <= rank(operators.peek()))\\n    \\t\\t\\t\\t\\t\\tpostfix.add(operators.pop());\\n    \\t\\t\\t\\t\\toperators.push(c);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\n    \\t\\t}\\n    \\t\\tif (bufferingOperand)\\n    \\t\\t\\tpostfix.add(numberBuffer);\\n    \\n    \\t\\twhile (!operators.isEmpty())\\n    \\t\\t\\tpostfix.add(operators.pop());\\n    \\n    \\t\\treturn postfix;\\n    \\t}\\n    \\n    \\tint evaluatePostfix(List<Object> postfix) {\\n    \\t\\tStack<Integer> operands = new Stack<Integer>();\\n    \\t\\tint a = 0, b = 0;\\n    \\t\\tfor (Object s : postfix) {\\n    \\t\\t\\tif(s instanceof Character){\\n    \\t\\t\\t\\tchar c = (Character) s;\\n    \\t\\t\\t\\tb = operands.pop();\\n    \\t\\t\\t\\ta = operands.pop();\\n    \\t\\t\\t\\tswitch (c) {\\n    \\t\\t\\t\\t\\tcase '+': operands.push(a + b); break;\\n    \\t\\t\\t\\t\\tcase '-': operands.push(a - b); break;\\n    \\t\\t\\t\\t\\tcase '*': operands.push(a * b); break;\\n    \\t\\t\\t\\t\\tdefault : operands.push(a / b); \\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}else { // instanceof Integer\\n    \\t\\t\\t\\toperands.push((Integer)s);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn operands.pop();\\n    \\t}\\n    \\n    \\tpublic int calculate(String s) {\\n    \\t\\treturn evaluatePostfix(infixToPostfix(s));\\n    \\t}\\n    \\n    }\\n\\n\\n  [1]: http://scriptasylum.com/tutorials/infix_postfix/algorithms/infix-postfix/\\n  [2]: http://scriptasylum.com/tutorials/infix_postfix/algorithms/postfix-evaluation/",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\n    \\tint rank(char op){\\n    \\t    // the bigger the number, the higher the rank\\n    \\t    switch(op){\\n    \\t        case '+':return 1;\\n    \\t        case '-':return 1;\\n    \\t        case '*':return 2;\\n    \\t        case '/':return 2;\\n    \\t        default :return 0; // '(' \\n    \\t    }",
                "codeTag": "Java"
            },
            {
                "id": 62345,
                "title": "24-line-c-o-n-recursive-solution-20ms-and-intuitive",
                "content": "Each invocation of evaluate() evaluates whatever inside a pair of parenthese. Nested parenthese will be handled by recursive calls.\\n\\nSo \"(1+(4+5+2)-3)+(6+8)\"\\n\\n->\\n\\n(1+(9+2)-3)+(6+8)\\n\\n->\\n\\n(1+11-3)+(6+8)\\n\\n->\\n\\n(12-3)+(6+8)\\n\\n->\\n\\n9+(6+8)\\n\\n->\\n\\n9+14\\n\\n->\\n\\n23\\n\\n\\n    class Solution {\\n    public:\\n        int calculate(string s) {\\n            int pos=0;\\n            return evaluate(s,pos);\\n        }\\n        \\n        int evaluate(string& s, int& i) {\\n            int res = 0;\\n            bool negFlag=false;\\n            while(i<s.size()&&s[i]!=')') {\\n                if(s[i]=='+'||s[i]==' ') \\n                    i++;\\n                else if(s[i]=='-') {\\n                    i++;\\n                    negFlag=true;\\n                }\\n                else if(s[i]=='(') {\\n                    i++;\\n                    res+=negFlag?-evaluate(s,i):evaluate(s,i);\\n                    negFlag=false;\\n                }\\n                else {// numeric chars\\n                    int num=0;\\n                    while(i<s.size()&&isdigit(s[i]))\\n                        num = num*10 + s[i++]-'0';\\n                    res+=negFlag?-num:num;\\n                    negFlag=false;\\n                }\\n            }\\n            i++; // skip the current ')'\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int calculate(string s) {\\n            int pos=0;\\n            return evaluate(s,pos);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 546092,
                "title": "simple-python-solution-using-stack-with-explanation-inline",
                "content": "```\\n    def calculate(self, s: str) -> int:\\n        \"\"\"\\n        1. Take 3 containers:\\n        num -> to store current num value only\\n        sign -> to store sign value, initially +1\\n        res -> to store sum\\n        When ( comes these containers used for calculate sum of intergers within () brackets.\\n        --------------------\\n        2. When c is + or -\\n        Move num to res, because we need to empty num for next integer value.\\n        set num = 0\\n        sign = update with c\\n        --------------------\\n        3. When c is \\'(\\'\\n        Here, we need num, res, sign to calculate sum of integers within ()\\n        So, move num and sign to stack => [num, sign]\\n        Now reset - res = 0, num = 0, sign = 1 (default)\\n        --------------------\\n        4. When c is \\')\\' -> 2-(3+4), Here res=3, num=4, sign=1 stack [2, -] \\n        res +=sign*num -> calculate sum for num first, then pop items from stack, res=7\\n        res *=stack.pop() - > Pop sign(+ or -) to multiply with res, res = 7*(-1)\\n        res +=stack.pop() - > Pop integer and add with prev. sum, res = -7 + 2 - 5\\n        --------------------\\n        Simple Example: 2 - 3\\n        Initially res will have 2,i.e. res = 2\\n        then store \\'-\\' in sign. it will be used when 3 comes. ie. sign = -1\\n        Now 3 comes => res = res + num*sign\\n        Return statement: res+num*sign => res = 2 + 3(-1) = 2 - 3 = -1\\n        \"\"\"\\n        num = 0\\n        sign = 1\\n        res = 0\\n        stack = []\\n        for i in range(len(s)): # iterate till last character\\n            c = s[i]\\n            if c.isdigit(): # process if there is digit\\n                num = num*10 + int(c) # for consecutive digits 98 => 9x10 + 8 = 98\\n            elif c in \\'-+\\': # check for - and +\\n                res += num*sign\\n                sign = -1 if c == \\'-\\' else 1\\n                num = 0\\n            elif c == \\'(\\':\\n                stack.append(res)\\n                stack.append(sign)\\n                res = 0\\n                sign = 1\\n            elif c == \\')\\':\\n                res +=sign*num\\n                res *=stack.pop()\\n                res +=stack.pop()\\n                num = 0\\n        return res + num*sign\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\n    def calculate(self, s: str) -> int:\\n        \"\"\"\\n        1. Take 3 containers:\\n        num -> to store current num value only\\n        sign -> to store sign value, initially +1\\n        res -> to store sum\\n        When ( comes these containers used for calculate sum of intergers within () brackets.\\n        --------------------\\n        2. When c is + or -\\n        Move num to res, because we need to empty num for next integer value.\\n        set num = 0\\n        sign = update with c\\n        --------------------\\n        3. When c is \\'(\\'\\n        Here, we need num, res, sign to calculate sum of integers within ()\\n        So, move num and sign to stack => [num, sign]\\n        Now reset - res = 0, num = 0, sign = 1 (default)\\n        --------------------\\n        4. When c is \\')\\' -> 2-(3+4), Here res=3, num=4, sign=1 stack [2, -] \\n        res +=sign*num -> calculate sum for num first, then pop items from stack, res=7\\n        res *=stack.pop() - > Pop sign(+ or -) to multiply with res, res = 7*(-1)\\n        res +=stack.pop() - > Pop integer and add with prev. sum, res = -7 + 2 - 5\\n        --------------------\\n        Simple Example: 2 - 3\\n        Initially res will have 2,i.e. res = 2\\n        then store \\'-\\' in sign. it will be used when 3 comes. ie. sign = -1\\n        Now 3 comes => res = res + num*sign\\n        Return statement: res+num*sign => res = 2 + 3(-1) = 2 - 3 = -1\\n        \"\"\"\\n        num = 0\\n        sign = 1\\n        res = 0\\n        stack = []\\n        for i in range(len(s)): # iterate till last character\\n            c = s[i]\\n            if c.isdigit(): # process if there is digit\\n                num = num*10 + int(c) # for consecutive digits 98 => 9x10 + 8 = 98\\n            elif c in \\'-+\\': # check for - and +\\n                res += num*sign\\n                sign = -1 if c == \\'-\\' else 1\\n                num = 0\\n            elif c == \\'(\\':\\n                stack.append(res)\\n                stack.append(sign)\\n                res = 0\\n                sign = 1\\n            elif c == \\')\\':\\n                res +=sign*num\\n                res *=stack.pop()\\n                res +=stack.pop()\\n                num = 0\\n        return res + num*sign\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 62418,
                "title": "python-with-stack",
                "content": "This [solution][1] uses stack to store previous result and sign when encounter a \"(\"\\n\\nFor this problem storing sign is enough, and will be faster.\\n\\n    def calculate(self, s):\\n        res, num, sign, stack = 0, 0, 1, [1]\\n        for i in s+\"+\":\\n            if i.isdigit():\\n                num = 10*num + int(i)\\n            elif i in \"+-\":\\n                res += num * sign * stack[-1]\\n                sign = 1 if i==\"+\" else -1\\n                num = 0\\n            elif i == \"(\":\\n                stack.append(sign * stack[-1])\\n                sign = 1\\n            elif i == \")\":\\n                res += num * sign * stack[-1]\\n                num = 0\\n                stack.pop()\\n        return res\\n\\n\\n  [1]: https://leetcode.com/discuss/61237/python-concise-solution-with-stack",
                "solutionTags": [
                    "Python"
                ],
                "code": "This [solution][1] uses stack to store previous result and sign when encounter a \"(\"\\n\\nFor this problem storing sign is enough, and will be faster.\\n\\n    def calculate(self, s):\\n        res, num, sign, stack = 0, 0, 1, [1]\\n        for i in s+\"+\":\\n            if i.isdigit():\\n                num = 10*num + int(i)\\n            elif i in \"+-\":\\n                res += num * sign * stack[-1]\\n                sign = 1 if i==\"+\" else -1\\n                num = 0\\n            elif i == \"(\":\\n                stack.append(sign * stack[-1])\\n                sign = 1\\n            elif i == \")\":\\n                res += num * sign * stack[-1]\\n                num = 0\\n                stack.pop()\\n        return res\\n\\n\\n  [1]: https://leetcode.com/discuss/61237/python-concise-solution-with-stack",
                "codeTag": "Python3"
            },
            {
                "id": 62430,
                "title": "java-solution-stack",
                "content": "My approach is based on the fact that the final arithmetic operation on each number is not only depend on the sign directly operating on it, but all signs associated with each unmatched '(' before that number.\\n\\ne.g.\\n5 - ( 6 + ( 4 - 7 ) ), if we remove all parentheses, the expression becomes 5 - 6 - 4 + 7.\\n\\nsign:\\n\\n6: (-1)(1) = -1\\n\\n4: (-1)(1)(1) = -1\\n\\n7: (-1)(1)(-1) = 1\\n\\nThe effect of associated signs are cumulative, stack is builded based on this. Any improvement is welcome.\\n\\n    public int calculate(String s) {\\n        Deque<Integer> stack = new LinkedList<>();\\n        int rs = 0;\\n        int sign = 1;\\n        stack.push(1);\\n        for (int i = 0; i < s.length(); i++){\\n            if (s.charAt(i) == ' ') continue;\\n            else if (s.charAt(i) == '('){\\n                stack.push(stack.peekFirst() * sign);\\n                sign = 1;\\n            }\\n            else if (s.charAt(i) == ')') stack.pop();\\n            else if (s.charAt(i) == '+') sign = 1;\\n            else if (s.charAt(i) == '-') sign = -1;\\n            else{\\n                int temp = s.charAt(i) - '0';\\n                while (i + 1 < s.length() && Character.isDigit(s.charAt(i + 1)))\\n                    temp = temp * 10 + s.charAt(++i) - '0';\\n                rs += sign * stack.peekFirst() * temp;\\n            }\\n        }\\n        return rs;\\n    }",
                "solutionTags": [],
                "code": "My approach is based on the fact that the final arithmetic operation on each number is not only depend on the sign directly operating on it, but all signs associated with each unmatched '(' before that number.\\n\\ne.g.\\n5 - ( 6 + ( 4 - 7 ) ), if we remove all parentheses, the expression becomes 5 - 6 - 4 + 7.\\n\\nsign:\\n\\n6: (-1)(1) = -1\\n\\n4: (-1)(1)(1) = -1\\n\\n7: (-1)(1)(-1) = 1\\n\\nThe effect of associated signs are cumulative, stack is builded based on this. Any improvement is welcome.\\n\\n    public int calculate(String s) {\\n        Deque<Integer> stack = new LinkedList<>();\\n        int rs = 0;\\n        int sign = 1;\\n        stack.push(1);\\n        for (int i = 0; i < s.length(); i++){\\n            if (s.charAt(i) == ' ') continue;\\n            else if (s.charAt(i) == '('){\\n                stack.push(stack.peekFirst() * sign);\\n                sign = 1;\\n            }\\n            else if (s.charAt(i) == ')') stack.pop();\\n            else if (s.charAt(i) == '+') sign = 1;\\n            else if (s.charAt(i) == '-') sign = -1;\\n            else{\\n                int temp = s.charAt(i) - '0';\\n                while (i + 1 < s.length() && Character.isDigit(s.charAt(i + 1)))\\n                    temp = temp * 10 + s.charAt(++i) - '0';\\n                rs += sign * stack.peekFirst() * temp;\\n            }\\n        }\\n        return rs;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 62449,
                "title": "simple-c-in-24-ms",
                "content": "    class Solution {\\n    public:\\n        int calculate(string s) {\\n            // the given expression is always valid!!!\\n            // only + and - !!!\\n            // every + and - can be flipped base on it's depth in ().\\n            stack<int> signs;\\n            int sign = 1;\\n            int num = 0;\\n            int ans = 0;\\n            \\n            // always transform s into ( s )\\n            signs.push(1);\\n            \\n            for (auto c : s) {\\n                if (c >= '0' && c <= '9') {\\n                    num = 10 * num + c - '0';\\n                } else if (c == '+' || c == '-') {\\n                    ans = ans + signs.top() * sign * num;\\n                    num = 0;\\n                    sign = (c == '+' ? 1 : -1);\\n                } else if (c == '(') {\\n                    signs.push(sign * signs.top());\\n                    sign = 1;\\n                } else if (c == ')') {\\n                    ans = ans + signs.top() * sign * num;\\n                    num = 0;\\n                    signs.pop();\\n                    sign = 1;\\n                }\\n            }\\n            \\n            if (num) {\\n                ans = ans + signs.top() * sign * num;\\n            }\\n            \\n            return ans;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int calculate(string s) {\\n            // the given expression is always valid!!!\\n            // only + and - !!!\\n            // every + and - can be flipped base on it's depth in ().\\n            stack<int> signs;\\n            int sign = 1;\\n            int num = 0;\\n            int ans = 0;\\n            \\n            // always transform s into ( s )\\n            signs.push(1);\\n            \\n            for (auto c : s) {\\n                if (c >= '0' && c <= '9') {\\n                    num = 10 * num + c - '0';\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2017431,
                "title": "stop-hating-parsing-problems-and-start-having-fun",
                "content": "I hate parsing problems only when solved the way Leetcode suggested (using stack). The most intuitive way (that I learned 10+ years ago and it somehow sticks with me) is to use parsing grammar. That actually makes parsing quite fun!\\n\\nThis problem can be converted to a recursive pseudo-grammar notation like this:\\n\\n```plan\\nexpr: factor [+/-] factor [+/-] factor ...\\nfactor: num | -num | (expr) | -(expr)\\n```\\n\\nIt says an expression (`expr`) can be a few `factor`s that are separated by `+` or `-`. On the other hand `factor` can optionally start with an unary operation `-` followed by either a number like `123` or just another `expr` (recursively).\\n\\nNow we just need to implement `factor` and `expr` functions and they can call each other. Another thing that makes it simple is a tokenizer which is like a stream wrapping a string. Tokenizer just keeps an index pointing to the current character on the string that we\\'re parsing.\\n\\nHere is a simple implementation of a tokenizer that also takes care of the white-spaces, so there are less things to be worried about:\\n\\n```python\\nclass Tokenizer:\\n    def __init__(self, s):\\n        self.s = s\\n        self.pc = 0\\n        self.skip_whitespaces()\\n        \\n    def has_next(self):\\n        return self.pc < len(self.s)\\n        \\n    def next(self):\\n        self.pc += 1\\n        self.skip_whitespaces()\\n            \\n    def skip_whitespaces(self):\\n        while self.has_next() and self.current() == \\' \\':\\n            self.pc += 1\\n        \\n    def is_digit(self):\\n        return self.current().isdigit()\\n        \\n    def current(self):\\n        return self.s[self.pc]\\n```\\n\\nNow let\\'s implement the main parser:\\n\\n```python\\ndef calculate(s: str) -> int:\\n    \\n    tokenizer = Tokenizer(s)\\n    op_map = {\\n        \\'+\\': lambda a,b: a+b,\\n        \\'-\\': lambda a,b: a-b\\n    }\\n    \\n    def num():\\n        n = 0\\n        while tokenizer.has_next() and tokenizer.is_digit():\\n            n = (n * 10) + int(tokenizer.current())\\n            tokenizer.next()\\n        return n\\n\\n    # factor:  [-]num | [-](expr)\\n    def factor():\\n        # Handle unary operator\\n        neg = 1\\n        if tokenizer.current() == \\'-\\':\\n            tokenizer.next()\\n            neg = -1\\n        \\n        if tokenizer.current() == \\'(\\':\\n            tokenizer.next() # Skip \\'(\\'\\n            n = expr()\\n            tokenizer.next() # Skip \\')\\'\\n        elif tokenizer.is_digit():\\n            n = num()\\n        else:\\n            raise ValueError(f\\'Unexpected token: {tokenizer.current()}\\')\\n            \\n        return n * neg\\n    \\n    # expr: factor [+-] factor [+-] factor ...\\n    def expr():\\n        acc = factor()\\n        while tokenizer.has_next() and tokenizer.current() in op_map:\\n            op = tokenizer.current()\\n            tokenizer.next() # Skip the operator\\n            acc = op_map[op](acc, factor())\\n        return acc\\n    \\n    return expr()\\n```\\n\\nThe beauty of this solution is that it works with all other kinds of calculator problems. For example the grammar for a calculator with operator precedence is simply like this:\\n\\n```plan\\nexpr: term [+-] term [+-] term ...\\nterm = factor [*/] factor [*/] factor ...\\nfactor: num | -num | (expr) | -(expr)\\n```\\n\\nLooking at it in a recursive way, handles the operator precedence in an intuitive way. Isn\\'t it more beautiful and simpler?\\n\\nMore reading: https://www.sigmdel.ca/michel/program/delphi/parser/parser1_en.html\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```plan\\nexpr: factor [+/-] factor [+/-] factor ...\\nfactor: num | -num | (expr) | -(expr)\\n```\n```python\\nclass Tokenizer:\\n    def __init__(self, s):\\n        self.s = s\\n        self.pc = 0\\n        self.skip_whitespaces()\\n        \\n    def has_next(self):\\n        return self.pc < len(self.s)\\n        \\n    def next(self):\\n        self.pc += 1\\n        self.skip_whitespaces()\\n            \\n    def skip_whitespaces(self):\\n        while self.has_next() and self.current() == \\' \\':\\n            self.pc += 1\\n        \\n    def is_digit(self):\\n        return self.current().isdigit()\\n        \\n    def current(self):\\n        return self.s[self.pc]\\n```\n```python\\ndef calculate(s: str) -> int:\\n    \\n    tokenizer = Tokenizer(s)\\n    op_map = {\\n        \\'+\\': lambda a,b: a+b,\\n        \\'-\\': lambda a,b: a-b\\n    }\\n    \\n    def num():\\n        n = 0\\n        while tokenizer.has_next() and tokenizer.is_digit():\\n            n = (n * 10) + int(tokenizer.current())\\n            tokenizer.next()\\n        return n\\n\\n    # factor:  [-]num | [-](expr)\\n    def factor():\\n        # Handle unary operator\\n        neg = 1\\n        if tokenizer.current() == \\'-\\':\\n            tokenizer.next()\\n            neg = -1\\n        \\n        if tokenizer.current() == \\'(\\':\\n            tokenizer.next() # Skip \\'(\\'\\n            n = expr()\\n            tokenizer.next() # Skip \\')\\'\\n        elif tokenizer.is_digit():\\n            n = num()\\n        else:\\n            raise ValueError(f\\'Unexpected token: {tokenizer.current()}\\')\\n            \\n        return n * neg\\n    \\n    # expr: factor [+-] factor [+-] factor ...\\n    def expr():\\n        acc = factor()\\n        while tokenizer.has_next() and tokenizer.current() in op_map:\\n            op = tokenizer.current()\\n            tokenizer.next() # Skip the operator\\n            acc = op_map[op](acc, factor())\\n        return acc\\n    \\n    return expr()\\n```\n```plan\\nexpr: term [+-] term [+-] term ...\\nterm = factor [*/] factor [*/] factor ...\\nfactor: num | -num | (expr) | -(expr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62421,
                "title": "3ms-java-concise-and-fast-recursive-solution-with-comments-beats-99-61",
                "content": "    public int calculate(String s) {\\n        if (s.length() == 0) return 0;\\n        s = \"(\" + s + \")\";\\n        int[] p = {0};\\n        return eval(s, p);\\n    }\\n    // calculate value between parentheses\\n    private int eval(String s, int[] p){\\n        int val = 0;\\n        int i = p[0]; \\n        int oper = 1; //1:+ -1:-\\n        int num = 0;\\n        while(i < s.length()){\\n            char c = s.charAt(i);\\n            switch(c){\\n                case '+': val = val + oper * num; num = 0; oper = 1; i++; break;// end of number and set operator\\n                case '-': val = val + oper * num; num = 0; oper = -1; i++; break;// end of number and set operator\\n                case '(': p[0] = i + 1; val = val + oper * eval(s, p); i = p[0]; break; // start a new eval\\n                case ')': p[0] = i + 1; return val + oper * num; // end current eval and return. Note that we need to deal with the last num\\n                case ' ': i++; continue;\\n                default : num = num * 10 + c - '0'; i++;\\n            }\\n        }\\n        return val;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "    public int calculate(String s) {\\n        if (s.length() == 0) return 0;\\n        s = \"(\" + s + \")\";\\n        int[] p = {0};\\n        return eval(s, p);\\n    }\\n    // calculate value between parentheses\\n    private int eval(String s, int[] p){\\n        int val = 0;\\n        int i = p[0]; \\n        int oper = 1; //1:+ -1:-\\n        int num = 0;\\n        while(i < s.length()){\\n            char c = s.charAt(i);\\n            switch(c){\\n                case '+': val = val + oper * num; num = 0; oper = 1; i++; break;// end of number and set operator\\n                case '-': val = val + oper * num; num = 0; oper = -1; i++; break;// end of number and set operator\\n                case '(': p[0] = i + 1; val = val + oper * eval(s, p); i = p[0]; break; // start a new eval\\n                case ')': p[0] = i + 1; return val + oper * num; // end current eval and return. Note that we need to deal with the last num\\n                case ' ': i++; continue;\\n                default : num = num * 10 + c - '0'; i++;\\n            }\\n        }\\n        return val;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2344042,
                "title": "java-2ms-100-recursion-easy-to-understand",
                "content": "PLEASE UPVOTE IF YOU FIND THIS SOLUTION HELPFUL, THANK YOU\\n\\nTC: O(n), where n is the length of the string\\nSC: O(number of brackets), which is less than n/2;\\n```\\nclass Solution {\\n    int idx; // this index traverse the string in one pass, between different level of recursion\\n    public int calculate(String s) {\\n        idx = 0; // Initialization should be here\\n        return calc(s);\\n    }\\n    \\n    private int calc(String s) {\\n        int res = 0, num = 0, sign = 1;\\n        while (idx < s.length()) {\\n            char c = s.charAt(idx++);\\n            if (c >= \\'0\\' && c <= \\'9\\') num = num * 10 + c - \\'0\\';\\n            else if (c == \\'(\\') num = calc(s); // ( is start of a new sub-problem, Let recursion solve the sub-problem\\n            else if (c == \\')\\') return res + sign * num;\\n            else if (c == \\'+\\' || c == \\'-\\') { // only when we meet a new sign, we know a while number has been read\\n                res += sign * num;\\n                num = 0;\\n                sign = c == \\'-\\' ? -1 : 1;\\n            }\\n        }\\n        return res + sign * num; // last number is not processed yet\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int idx; // this index traverse the string in one pass, between different level of recursion\\n    public int calculate(String s) {\\n        idx = 0; // Initialization should be here\\n        return calc(s);\\n    }\\n    \\n    private int calc(String s) {\\n        int res = 0, num = 0, sign = 1;\\n        while (idx < s.length()) {\\n            char c = s.charAt(idx++);\\n            if (c >= \\'0\\' && c <= \\'9\\') num = num * 10 + c - \\'0\\';\\n            else if (c == \\'(\\') num = calc(s); // ( is start of a new sub-problem, Let recursion solve the sub-problem\\n            else if (c == \\')\\') return res + sign * num;\\n            else if (c == \\'+\\' || c == \\'-\\') { // only when we meet a new sign, we know a while number has been read\\n                res += sign * num;\\n                num = 0;\\n                sign = c == \\'-\\' ? -1 : 1;\\n            }\\n        }\\n        return res + sign * num; // last number is not processed yet\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62432,
                "title": "ac-c-solution-with-two-stacks",
                "content": "Yet another stack-based solution. Very similar to the solution given by @jiannan [here][1] with a few minor differences.\\n\\nThe basic idea is to scan from left to right. Push every (, + and - to an 'operator' stack, and every number to an 'number' stack. In this process, whenever a RIGHT operand is added to the 'number' stack, we can do a computation using the top two numbers in the 'number' stack with the operation specified by the top of the operator stack. \\n\\nThere are only two situations when a RIGHT operand appears in the number stack: \\n1. A number that is the RIGHT operand, .e.g 4 as in 3 + 4, is pushed;\\n2. A braced block that is the RIGHT operand, e.g. (4+5) as in 3 + (4 + 5), is terminated and its result is added to the number stack.\\n\\nHow do we know if a number added is the RIGHT or LEFT operand? The idea is, whenever a RIGHT operand appears, there must be an unused '+' or '-' left in the 'operator' stack.\\n\\n    int calculate(string s) {\\n        stack<char> ops;\\n        stack<int> nums;\\n        int curnum = 0;\\n         \\n        for (int i = 0; i < s.size(); ++i) {\\n            char c = s[i];\\n            if (c == ' ') continue;   // Skip spaces\\n            if (c == '(' || c == '+' || c == '-') {ops.push(c); continue;}  // Store these operators for later\\n            \\n            // Only do calculation when 1. a braced block is terminated, 2. When the second operand isn added\\n            if (c == ')') ops.pop(); \\n            else if (isdigit(c)) {\\n                curnum = curnum * 10 + c -'0';\\n                if (i+1<s.size() && isdigit(s[i+1])) continue;    //This number is not finished\\n                nums.push(curnum);      // Otherwise, this number is ready and must be pushed to stack\\n                curnum = 0;             // Reset cursum;\\n            }\\n            \\n            if (ops.empty() || ops.top()=='(') continue;    // If, however, there is no more computational operators in stack\\n            // then either we have just added the LEFT operand, or if the braced block just terminated is a LEFT operand.\\n            // Either way, we cannot do computation yet.\\n            // Otherwise, it is safe to do the computation, assuming the expression is always valid:\\n            \\n            int n2 = nums.top(); nums.pop();                \\n            if (ops.top() == '+') nums.top() += n2;\\n            else if (ops.top() == '-') nums.top() -= n2;\\n            ops.pop();\\n        }\\n        return nums.top();\\n    }\\n\\n  [1]: https://leetcode.com/discuss/39458/64-ms-c-easy-solution",
                "solutionTags": [],
                "code": "Yet another stack-based solution. Very similar to the solution given by @jiannan [here][1] with a few minor differences.\\n\\nThe basic idea is to scan from left to right. Push every (, + and - to an 'operator' stack, and every number to an 'number' stack. In this process, whenever a RIGHT operand is added to the 'number' stack, we can do a computation using the top two numbers in the 'number' stack with the operation specified by the top of the operator stack. \\n\\nThere are only two situations when a RIGHT operand appears in the number stack: \\n1. A number that is the RIGHT operand, .e.g 4 as in 3 + 4, is pushed;\\n2. A braced block that is the RIGHT operand, e.g. (4+5) as in 3 + (4 + 5), is terminated and its result is added to the number stack.\\n\\nHow do we know if a number added is the RIGHT or LEFT operand? The idea is, whenever a RIGHT operand appears, there must be an unused '+' or '-' left in the 'operator' stack.\\n\\n    int calculate(string s) {\\n        stack<char> ops;\\n        stack<int> nums;\\n        int curnum = 0;\\n         \\n        for (int i = 0; i < s.size(); ++i) {\\n            char c = s[i];\\n            if (c == ' ') continue;   // Skip spaces\\n            if (c == '(' || c == '+' || c == '-') {ops.push(c); continue;}  // Store these operators for later\\n            \\n            // Only do calculation when 1. a braced block is terminated, 2. When the second operand isn added\\n            if (c == ')') ops.pop(); \\n            else if (isdigit(c)) {\\n                curnum = curnum * 10 + c -'0';\\n                if (i+1<s.size() && isdigit(s[i+1])) continue;    //This number is not finished\\n                nums.push(curnum);      // Otherwise, this number is ready and must be pushed to stack\\n                curnum = 0;             // Reset cursum;\\n            }\\n            \\n            if (ops.empty() || ops.top()=='(') continue;    // If, however, there is no more computational operators in stack\\n            // then either we have just added the LEFT operand, or if the braced block just terminated is a LEFT operand.\\n            // Either way, we cannot do computation yet.\\n            // Otherwise, it is safe to do the computation, assuming the expression is always valid:\\n            \\n            int n2 = nums.top(); nums.pop();                \\n            if (ops.top() == '+') nums.top() += n2;\\n            else if (ops.top() == '-') nums.top() -= n2;\\n            ops.pop();\\n        }\\n        return nums.top();\\n    }\\n\\n  [1]: https://leetcode.com/discuss/39458/64-ms-c-easy-solution",
                "codeTag": "Unknown"
            },
            {
                "id": 2831900,
                "title": "c-solution",
                "content": "``` C++ []\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int result=0;\\n        int sum=0;\\n        int sign=1;\\n        stack<int>st;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(isdigit(s[i]))\\n            {\\n                sum=s[i] -\\'0\\';\\n                while(i+1<n && isdigit(s[i+1]))\\n                {\\n                    sum = sum*10 + (s[i+1] -\\'0\\');\\n                    i++;\\n                }\\n                result+=sum*sign;\\n            }\\n            \\n            else if(s[i] == \\'+\\')\\n            {\\n                sign=1;\\n            }\\n            else if (s[i] == \\'-\\')\\n            {\\n                sign=-1;\\n            }\\n            else if (s[i] == \\'(\\')\\n            {\\n                st.push(result);\\n                st.push(sign);\\n                result=0;\\n                sign=1;\\n            }\\n            else if(s[i] == \\')\\')\\n            {\\n                int xsign=st.top();\\n                st.pop();\\n                int xresult= st.top();\\n                st.pop();\\n                result=result*xsign + xresult;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n*Upvote if it helped you*",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int result=0;\\n        int sum=0;\\n        int sign=1;\\n        stack<int>st;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(isdigit(s[i]))\\n            {\\n                sum=s[i] -\\'0\\';\\n                while(i+1<n && isdigit(s[i+1]))\\n                {\\n                    sum = sum*10 + (s[i+1] -\\'0\\');\\n                    i++;\\n                }\\n                result+=sum*sign;\\n            }\\n            \\n            else if(s[i] == \\'+\\')\\n            {\\n                sign=1;\\n            }\\n            else if (s[i] == \\'-\\')\\n            {\\n                sign=-1;\\n            }\\n            else if (s[i] == \\'(\\')\\n            {\\n                st.push(result);\\n                st.push(sign);\\n                result=0;\\n                sign=1;\\n            }\\n            else if(s[i] == \\')\\')\\n            {\\n                int xsign=st.top();\\n                st.pop();\\n                int xresult= st.top();\\n                st.pop();\\n                result=result*xsign + xresult;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549777,
                "title": "c-easy-solution-string-math-stack-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* The intuition behind the code is to use a stack to store the intermediate results of the evaluation.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) When the algorithm encounters a digit, it parses the digits as a number and pushes the number onto the stack.\\n2) When the algorithm encounters an operator, it pops two numbers off the stack, performs the operation, and pushes the result back onto the stack.\\n3) When the algorithm encounters a left parenthesis, it pushes the current state of the stack onto a new stack.\\n4) When the algorithm encounters a right parenthesis, it pops the top stack, performs the operations on the numbers on the top of the stack, and pushes the result back onto the stack.\\n5) After iterating over the entire string, the algorithm pops the top number off the stack and returns it as the result of the expression.\\n# Complexity\\n- Time complexity: $$O(S)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(S)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        long long int sum = 0;\\n        int sign = 1;\\n        stack<pair<int,int>> st;\\n\\n        for(int i=0; i<s.size();i++){\\n            if(isdigit(s[i])){\\n                long long int num = 0;\\n                while(i<s.size() && isdigit(s[i])){\\n                    num = num * 10 + (s[i] - \\'0\\');\\n                    i++;\\n                }\\n                i--;\\n                sum += num * sign;\\n                sign = 1;\\n            }\\n            else if(s[i] == \\'(\\'){\\n                st.push({sum, sign});\\n                sum = 0;\\n                sign = 1;\\n            }\\n            else if(s[i] == \\')\\'){\\n                sum = st.top().first + (st.top().second * sum);\\n                st.pop();\\n\\n            }\\n            else if(s[i] == \\'-\\'){\\n                sign = -1 * sign;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/9e265da5-ca9a-438b-ad37-cb3fde6b73ab_1684698427.2365825.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        long long int sum = 0;\\n        int sign = 1;\\n        stack<pair<int,int>> st;\\n\\n        for(int i=0; i<s.size();i++){\\n            if(isdigit(s[i])){\\n                long long int num = 0;\\n                while(i<s.size() && isdigit(s[i])){\\n                    num = num * 10 + (s[i] - \\'0\\');\\n                    i++;\\n                }\\n                i--;\\n                sum += num * sign;\\n                sign = 1;\\n            }\\n            else if(s[i] == \\'(\\'){\\n                st.push({sum, sign});\\n                sum = 0;\\n                sign = 1;\\n            }\\n            else if(s[i] == \\')\\'){\\n                sum = st.top().first + (st.top().second * sum);\\n                st.pop();\\n\\n            }\\n            else if(s[i] == \\'-\\'){\\n                sign = -1 * sign;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831476,
                "title": "java-solution-using-stack-with-o-n",
                "content": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        int sum = 0;\\n        int sign = 1;\\n        Stack<Integer>st = new Stack<>();\\n        for(int i = 0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(Character.isDigit(ch)){\\n                int val = 0;\\n                 while(i < s.length() && Character.isDigit(s.charAt(i))){\\n                     val = val * 10 + (s.charAt(i) - \\'0\\');\\n                     i++;\\n                 }\\n             i--;\\n             val = val * sign;\\n             sign = 1;\\n             sum += val;   \\n            }\\n            else if(ch == \\'(\\'){\\n              st.push(sum);\\n              st.push(sign);\\n                sum = 0;\\n                sign = 1;\\n            }\\n            else if(ch == \\')\\'){\\n                sum *= st.pop();\\n                sum += st.pop();\\n            }\\n            else if(ch == \\'-\\'){\\n                sign*= -1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        int sum = 0;\\n        int sign = 1;\\n        Stack<Integer>st = new Stack<>();\\n        for(int i = 0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(Character.isDigit(ch)){\\n                int val = 0;\\n                 while(i < s.length() && Character.isDigit(s.charAt(i))){\\n                     val = val * 10 + (s.charAt(i) - \\'0\\');\\n                     i++;\\n                 }\\n             i--;\\n             val = val * sign;\\n             sign = 1;\\n             sum += val;   \\n            }\\n            else if(ch == \\'(\\'){\\n              st.push(sum);\\n              st.push(sign);\\n                sum = 0;\\n                sign = 1;\\n            }\\n            else if(ch == \\')\\'){\\n                sum *= st.pop();\\n                sum += st.pop();\\n            }\\n            else if(ch == \\'-\\'){\\n                sign*= -1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62464,
                "title": "64-ms-c-easy-solution",
                "content": "    class Solution {\\n    public:\\n        int calculate(string s) {\\n            int n = s.size();\\n            stack<int> s1;\\n            stack<char> s2;\\n            string v;\\n            for(int i = n - 1; i >= 0; i--){\\n                if(s[i] == ')' || s[i] == '+' || s[i] == '-') s2.push(s[i]);\\n                else if(s[i] >= '0' && s[i] <= '9'){\\n                    v = s[i] + v;\\n                    if(i == 0 || s[i - 1] < '0' || s[i - 1] > '9'){\\n                        s1.push(stoi(v)); \\n                        v = \"\";\\n                    }\\n                } else if(s[i] == '('){\\n                    while(s2.top() != ')') cal(s1, s2);\\n                    s2.pop();\\n                }\\n            }\\n            while(!s2.empty()) cal(s1, s2);\\n            return s1.top();\\n        }\\n    \\n        void cal(stack<int> &s1, stack<char> &s2){\\n            int v1 = s1.top(); s1.pop();\\n            int v2 = s1.top(); s1.pop();\\n            char c = s2.top(); s2.pop();\\n            if(c == '+') s1.push(v1 + v2);\\n            if(c == '-') s1.push(v1 - v2);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int calculate(string s) {\\n            int n = s.size();\\n            stack<int> s1;\\n            stack<char> s2;\\n            string v;\\n            for(int i = n - 1; i >= 0; i--){\\n                if(s[i] == ')' || s[i] == '+' || s[i] == '-') s2.push(s[i]);\\n                else if(s[i] >= '0' && s[i] <= '9'){\\n                    v = s[i] + v;\\n                    if(i == 0 || s[i - 1] < '0' || s[i - 1] > '9'){\\n                        s1.push(stoi(v)); \\n                        v = \"\";\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 414898,
                "title": "infix-to-postfix-a-general-approach-to-similar-questions",
                "content": "Similar questions:\\n\\n1. [Basic Calculator](https://leetcode.com/problems/basic-calculator/) | [Solution](https://leetcode.com/problems/basic-calculator/discuss/414898/Infix-to-Postfix-a-general-approach-to-similar-questions) (this one)\\n2. [Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/) | [Solution](https://leetcode.com/problems/basic-calculator-ii/discuss/414897/Infix-to-Postfix-a-general-approach-to-similar-questions)\\n3. [Basic Calculator III](https://leetcode.com/problems/basic-calculator-iii/) | [Solution](https://leetcode.com/problems/basic-calculator-iii/discuss/414896/Infix-to-Postfix-a-general-approach-to-similar-questions)\\n\\nThese questions all ask we to evaluate a infix expression with simple math operators in it. \\nWhats infix? For infix expression(the one we use daily) binary operators appear between two operand. And for postfix, operator appears after operand, even for unary operand.\\n\\nInfix: \\n`1 -  (1 + 2)`\\nPostfix:\\n`1 1 2 + -`\\n\\nEvaluating postfix expressions is much easier and simpler than infix ones, so the general idea is to convert infix expression to a postfix one, and evaluate postfix expression with the help of stack.\\n\\nThe general solution comes in two parts:\\n1. Convert infix expression to postfix expression\\n2. Evaluate postfix expression\\n\\n---\\n\\n1. Convert\\n\\nHere is the algorithm I found online: \\nhttps://condor.depaul.edu/ichu/csc415/notes/notes9/Infix.htm\\n\\nFor this question, the code looks like this. For the code for other questions, please see the link above.\\n\\n```python\\ndef calculate(self, s: str) -> int:\\n\\tstack = []\\n\\t# postfix result\\n\\toutput = []\\n\\n\\trank = {\\n\\t\\t\\'+\\': 1,\\n\\t\\t\\'-\\': 1,\\n\\t\\t\\'*\\': 2,\\n\\t\\t\\'/\\': 2,\\n\\t}\\n\\n\\t# None means no number is parsed\\n\\tnum = None\\n\\n\\tfor c in s:\\n\\t\\tif c == \\' \\':\\n\\t\\t\\tcontinue\\n\\n\\t\\tif c in \"0123456789\":\\n\\t\\t\\tif num is None:\\n\\t\\t\\t\\tnum = 0\\n\\t\\t\\tnum = num * 10 + int(c)\\n\\t\\t\\tcontinue\\n\\n\\t\\t# c is opeartor or ()\\n\\t\\t# output prev num to output\\n\\t\\tif num is not None:\\n\\t\\t\\toutput.append(num)\\n\\t\\t\\tnum = None\\n\\n\\t\\tif c == \\'(\\':\\n\\t\\t\\tstack.append(\\'(\\')\\n\\t\\telif c == \\')\\':\\n\\t\\t\\t# pop until (\\n\\t\\t\\twhile stack[-1] != \\'(\\':\\n\\t\\t\\t\\toutput.append(stack.pop())\\n\\n\\t\\t\\t# pop (\\n\\t\\t\\tstack.pop()\\n\\t\\telse:\\n\\t\\t\\t# pop all aperator with higher or equal rank in stack, until meet (\\n\\t\\t\\twhile stack and stack[-1] != \\'(\\' and rank[stack[-1]] >= rank[c]:\\n\\t\\t\\t\\toutput.append(stack.pop())\\n\\n\\t\\t\\t# push cur operator\\n\\t\\t\\tstack.append(c)\\n\\n\\t# handle leftover\\n\\tif num != None:\\n\\t\\toutput.append(num)\\n\\twhile stack:\\n\\t\\toutput.append(stack.pop())\\n\\n\\treturn self.eval(output)\\n```\\n\\n2. Evaluate\\n\\nThis part is almost the same for all three questions.\\n\\n```\\ndef eval(self, postfix):\\n\\tstack = []\\n\\tfor token in postfix:\\n\\t\\tif token == \\'+\\':\\n\\t\\t\\ta = stack.pop()\\n\\t\\t\\tb = stack.pop()\\n\\n\\t\\t\\tstack.append(a + b)\\n\\t\\telif token == \\'-\\':\\n\\t\\t\\tb = stack.pop()\\n\\t\\t\\ta = stack.pop()\\n\\n\\t\\t\\tstack.append(a - b)\\n\\t\\telif token == \\'*\\':\\n\\t\\t\\ta = stack.pop()\\n\\t\\t\\tb = stack.pop()\\n\\n\\t\\t\\tstack.append(a * b)\\n\\t\\telif token == \\'/\\':\\n\\t\\t\\tb = stack.pop()\\n\\t\\t\\ta = stack.pop()\\n\\n\\t\\t\\tstack.append(a // b)\\n\\t\\telse:\\n\\t\\t\\tstack.append(token)\\n\\n\\treturn stack[-1]\\n```\\n\\nI not sure about the time complexity, i think it should be O(n) because we go through the input once, and in the worst case we have to go through the stack once too to pop all the operators in it.",
                "solutionTags": [],
                "code": "```python\\ndef calculate(self, s: str) -> int:\\n\\tstack = []\\n\\t# postfix result\\n\\toutput = []\\n\\n\\trank = {\\n\\t\\t\\'+\\': 1,\\n\\t\\t\\'-\\': 1,\\n\\t\\t\\'*\\': 2,\\n\\t\\t\\'/\\': 2,\\n\\t}\\n\\n\\t# None means no number is parsed\\n\\tnum = None\\n\\n\\tfor c in s:\\n\\t\\tif c == \\' \\':\\n\\t\\t\\tcontinue\\n\\n\\t\\tif c in \"0123456789\":\\n\\t\\t\\tif num is None:\\n\\t\\t\\t\\tnum = 0\\n\\t\\t\\tnum = num * 10 + int(c)\\n\\t\\t\\tcontinue\\n\\n\\t\\t# c is opeartor or ()\\n\\t\\t# output prev num to output\\n\\t\\tif num is not None:\\n\\t\\t\\toutput.append(num)\\n\\t\\t\\tnum = None\\n\\n\\t\\tif c == \\'(\\':\\n\\t\\t\\tstack.append(\\'(\\')\\n\\t\\telif c == \\')\\':\\n\\t\\t\\t# pop until (\\n\\t\\t\\twhile stack[-1] != \\'(\\':\\n\\t\\t\\t\\toutput.append(stack.pop())\\n\\n\\t\\t\\t# pop (\\n\\t\\t\\tstack.pop()\\n\\t\\telse:\\n\\t\\t\\t# pop all aperator with higher or equal rank in stack, until meet (\\n\\t\\t\\twhile stack and stack[-1] != \\'(\\' and rank[stack[-1]] >= rank[c]:\\n\\t\\t\\t\\toutput.append(stack.pop())\\n\\n\\t\\t\\t# push cur operator\\n\\t\\t\\tstack.append(c)\\n\\n\\t# handle leftover\\n\\tif num != None:\\n\\t\\toutput.append(num)\\n\\twhile stack:\\n\\t\\toutput.append(stack.pop())\\n\\n\\treturn self.eval(output)\\n```\n```\\ndef eval(self, postfix):\\n\\tstack = []\\n\\tfor token in postfix:\\n\\t\\tif token == \\'+\\':\\n\\t\\t\\ta = stack.pop()\\n\\t\\t\\tb = stack.pop()\\n\\n\\t\\t\\tstack.append(a + b)\\n\\t\\telif token == \\'-\\':\\n\\t\\t\\tb = stack.pop()\\n\\t\\t\\ta = stack.pop()\\n\\n\\t\\t\\tstack.append(a - b)\\n\\t\\telif token == \\'*\\':\\n\\t\\t\\ta = stack.pop()\\n\\t\\t\\tb = stack.pop()\\n\\n\\t\\t\\tstack.append(a * b)\\n\\t\\telif token == \\'/\\':\\n\\t\\t\\tb = stack.pop()\\n\\t\\t\\ta = stack.pop()\\n\\n\\t\\t\\tstack.append(a // b)\\n\\t\\telse:\\n\\t\\t\\tstack.append(token)\\n\\n\\treturn stack[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1246403,
                "title": "c-easy-using-basic-method-of-solving",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int calculate(string s) {\\n        //we basically calculate everything at a time and update it in result varibale\\n        int result=0;\\n        int sign=1; //1 represents +ve -1 represents -ve\\n        int j=0;\\n        int len=s.length();\\n        stack<int> stk;\\n        \\n        while(j<len){ \\n            if(s[j]==\\'+\\')\\n            {\\n                sign=1;\\n            }\\n            else if(s[j]==\\'-\\')\\n            {\\n                //we got a negative value\\n                sign=-1;\\n            }\\n            else if(isdigit(s[j]))\\n            {\\n                //get the number \\n                int num=s[j]-\\'0\\';\\n                while(j+1<len && isdigit(s[j+1])){\\n                    num=num*10+(s[j+1]-\\'0\\');\\n                    j++;\\n                }\\n                //now add it to the result along with sign\\n                result+=num*sign;\\n            }\\n            else if(s[j]==\\'(\\')\\n            {\\n                //we push the current result and current sign into the stack\\n                stk.push(result);\\n                stk.push(sign);\\n                result=0;\\n                sign=1;\\n            }\\n            else if(s[j]==\\')\\')\\n            {\\n                //get the last result and the sign from the stack\\n                int xsign=stk.top();\\n                stk.pop();\\n                int xresult=stk.top();\\n                stk.pop();\\n                //add the curr result in parenthesis to prev result and update the entire result\\n                result=result*xsign + xresult;\\n                //xsign will be the sign before the begin of parenthesis\\n            }\\n            j++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int calculate(string s) {\\n        //we basically calculate everything at a time and update it in result varibale\\n        int result=0;\\n        int sign=1; //1 represents +ve -1 represents -ve\\n        int j=0;\\n        int len=s.length();\\n        stack<int> stk;\\n        \\n        while(j<len){ \\n            if(s[j]==\\'+\\')\\n            {\\n                sign=1;\\n            }\\n            else if(s[j]==\\'-\\')\\n            {\\n                //we got a negative value\\n                sign=-1;\\n            }\\n            else if(isdigit(s[j]))\\n            {\\n                //get the number \\n                int num=s[j]-\\'0\\';\\n                while(j+1<len && isdigit(s[j+1])){\\n                    num=num*10+(s[j+1]-\\'0\\');\\n                    j++;\\n                }\\n                //now add it to the result along with sign\\n                result+=num*sign;\\n            }\\n            else if(s[j]==\\'(\\')\\n            {\\n                //we push the current result and current sign into the stack\\n                stk.push(result);\\n                stk.push(sign);\\n                result=0;\\n                sign=1;\\n            }\\n            else if(s[j]==\\')\\')\\n            {\\n                //get the last result and the sign from the stack\\n                int xsign=stk.top();\\n                stk.pop();\\n                int xresult=stk.top();\\n                stk.pop();\\n                //add the curr result in parenthesis to prev result and update the entire result\\n                result=result*xsign + xresult;\\n                //xsign will be the sign before the begin of parenthesis\\n            }\\n            j++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833545,
                "title": "c-simple-solution-one-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int calculate(string s) \\n    {\\n        stack<int>st; \\n        int ans=0; \\n        long long cur_val = 0, sign=1; \\n       \\n        for (char c : s) \\n        { \\n            if(isdigit(c)) \\n            {\\n                // extract the number\\n                cur_val = 10*cur_val + (c-\\'0\\'); \\n            }\\n            else if(c==\\'+\\')\\n            {\\n                ans += cur_val*sign; \\n                cur_val = 0;\\n                sign = 1;   \\n            }\\n            else if(c==\\'-\\')\\n            {\\n                ans += cur_val*sign; \\n                cur_val = 0; \\n                sign = -1; \\n            }\\n            else if(c==\\'(\\')\\n            {\\n                st.push(ans);    \\n                st.push(sign); \\n                ans = 0; \\n                sign = 1;\\n            }\\n            else if(c==\\')\\')\\n            { \\n                ans += cur_val*sign; \\n                cur_val = 0;\\n                \\n                ans = ans*st.top(); // multiplying with sign\\n                st.pop();\\n                ans = ans + st.top(); // multiplying with number\\n                st.pop();\\n            }\\n        }\\n        \\n        ans += cur_val*sign; \\n        return ans; \\n    }\\n};\\n```\\n***Thanks for Upvoting !***\\n\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int calculate(string s) \\n    {\\n        stack<int>st; \\n        int ans=0; \\n        long long cur_val = 0, sign=1; \\n       \\n        for (char c : s) \\n        { \\n            if(isdigit(c)) \\n            {\\n                // extract the number\\n                cur_val = 10*cur_val + (c-\\'0\\'); \\n            }\\n            else if(c==\\'+\\')\\n            {\\n                ans += cur_val*sign; \\n                cur_val = 0;\\n                sign = 1;   \\n            }\\n            else if(c==\\'-\\')\\n            {\\n                ans += cur_val*sign; \\n                cur_val = 0; \\n                sign = -1; \\n            }\\n            else if(c==\\'(\\')\\n            {\\n                st.push(ans);    \\n                st.push(sign); \\n                ans = 0; \\n                sign = 1;\\n            }\\n            else if(c==\\')\\')\\n            { \\n                ans += cur_val*sign; \\n                cur_val = 0;\\n                \\n                ans = ans*st.top(); // multiplying with sign\\n                st.pop();\\n                ans = ans + st.top(); // multiplying with number\\n                st.pop();\\n            }\\n        }\\n        \\n        ans += cur_val*sign; \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974370,
                "title": "c-easy-to-understand-stack-detailed-explanations",
                "content": "**Code flow With diagram**\\n\\n![image](https://assets.leetcode.com/users/images/2fd1c4a5-c106-4eb3-bd3d-83c9d8c7d5b0_1650696375.4016645.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n       \\n        int n = s.length();\\n        stack<int> stk ;\\n        int res = 0;\\n        int sign = 1;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            \\n            if(s[i] == \\'+\\')\\n                sign = 1;\\n            else if(s[i] == \\'-\\')\\n                sign = -1;\\n            else if(isdigit(s[i])){\\n                long long temp = 0;\\n                \\n                while(i < n and isdigit(s[i])){\\n                    temp = temp*10 + s[i] - \\'0\\';\\n                    i++;\\n                }\\n                i--;\\n                res = res + sign*temp;\\n            }\\n            else if(s[i] == \\'(\\'){\\n                stk.push(res);\\n                stk.push(sign);\\n                res = 0;\\n                sign = 1;\\n            }\\n            else if(s[i] == \\')\\'){\\n                int curr_sign = stk.top(); stk.pop();\\n                int curr_val = stk.top(); stk.pop();\\n                \\n                res = curr_val + curr_sign * res;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**If you find this is helpful**\\n**Please Upvote this solution !!**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n       \\n        int n = s.length();\\n        stack<int> stk ;\\n        int res = 0;\\n        int sign = 1;\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            \\n            if(s[i] == \\'+\\')\\n                sign = 1;\\n            else if(s[i] == \\'-\\')\\n                sign = -1;\\n            else if(isdigit(s[i])){\\n                long long temp = 0;\\n                \\n                while(i < n and isdigit(s[i])){\\n                    temp = temp*10 + s[i] - \\'0\\';\\n                    i++;\\n                }\\n                i--;\\n                res = res + sign*temp;\\n            }\\n            else if(s[i] == \\'(\\'){\\n                stk.push(res);\\n                stk.push(sign);\\n                res = 0;\\n                sign = 1;\\n            }\\n            else if(s[i] == \\')\\'){\\n                int curr_sign = stk.top(); stk.pop();\\n                int curr_val = stk.top(); stk.pop();\\n                \\n                res = curr_val + curr_sign * res;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689035,
                "title": "python-3-using-recursion-without-stack",
                "content": "```\\nclass Solution:\\n    def calculate(self, s):\\n        def evaluate(i):\\n            res, digit, sign = 0, 0, 1\\n            \\n            while i < len(s):\\n                if s[i].isdigit():\\n                    digit = digit * 10 + int(s[i])\\n                elif s[i] in \\'+-\\':\\n                    res += digit * sign\\n                    digit = 0\\n                    sign = 1 if s[i] == \\'+\\' else -1\\n                elif s[i] == \\'(\\':\\n                    subres, i = evaluate(i+1)\\n                    res += sign * subres\\n                elif s[i] == \\')\\':\\n                    res += digit * sign\\n                    return res, i\\n                i += 1\\n\\n            return res + digit * sign\\n        \\n        return evaluate(0)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def calculate(self, s):\\n        def evaluate(i):\\n            res, digit, sign = 0, 0, 1\\n            \\n            while i < len(s):\\n                if s[i].isdigit():\\n                    digit = digit * 10 + int(s[i])\\n                elif s[i] in \\'+-\\':\\n                    res += digit * sign\\n                    digit = 0\\n                    sign = 1 if s[i] == \\'+\\' else -1\\n                elif s[i] == \\'(\\':\\n                    subres, i = evaluate(i+1)\\n                    res += sign * subres\\n                elif s[i] == \\')\\':\\n                    res += digit * sign\\n                    return res, i\\n                i += 1\\n\\n            return res + digit * sign\\n        \\n        return evaluate(0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625909,
                "title": "javascript-iterative-stack-with-comments",
                "content": "```\\nvar calculate = function(s) {\\n    let sign = 1, sum = 0;\\n    \\n    const stack = []; \\n    for (let i = 0; i < s.length; i += 1) {\\n        if (s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n            let num = 0\\n\\t\\t\\t// num can be multiple digits, iterate to build full num.\\n            while (s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n                num = (num * 10) + (s[i] - \\'0\\');\\n                i += 1;\\n            }\\n\\t\\t\\t// add your completed sum.\\n            sum += (num * sign);\\n\\t\\t\\t// while loop from earlier causes our index to move forward once, bring it back\\n            i -= 1;\\n        } else if (s[i] === \\'+\\') {\\n            sign = 1;\\n        } else if (s[i] === \\'-\\') {\\n            sign = -1;\\n        } else if (s[i] === \\'(\\') {\\n\\t\\t\\t// open parens signifies that we should calculate the inside of the parens first and store the outer sum and sign in stack. \\n\\t\\t\\t// we can later retrieve the values in our stack once we find a closing bracket.\\n            stack.push(sum);\\n            stack.push(sign);\\n            sum = 0\\n\\t\\t\\t// we used our sign, reset it to default.\\n            sign = 1;\\n        } else if (s[i] === \\')\\') {\\n\\t\\t\\t// closing bracket assumes we\\'ve calculated the sum inside the parens. \\n\\t\\t\\t// Earlier, we pushed the sum first into our stack. First pop will be the sign. Second pop will be the outer sum.\\n            sum = stack.pop() * sum;\\n            sum += stack.pop();\\n        }\\n    }\\n    \\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar calculate = function(s) {\\n    let sign = 1, sum = 0;\\n    \\n    const stack = []; \\n    for (let i = 0; i < s.length; i += 1) {\\n        if (s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n            let num = 0\\n\\t\\t\\t// num can be multiple digits, iterate to build full num.\\n            while (s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n                num = (num * 10) + (s[i] - \\'0\\');\\n                i += 1;\\n            }\\n\\t\\t\\t// add your completed sum.\\n            sum += (num * sign);\\n\\t\\t\\t// while loop from earlier causes our index to move forward once, bring it back\\n            i -= 1;\\n        } else if (s[i] === \\'+\\') {\\n            sign = 1;\\n        } else if (s[i] === \\'-\\') {\\n            sign = -1;\\n        } else if (s[i] === \\'(\\') {\\n\\t\\t\\t// open parens signifies that we should calculate the inside of the parens first and store the outer sum and sign in stack. \\n\\t\\t\\t// we can later retrieve the values in our stack once we find a closing bracket.\\n            stack.push(sum);\\n            stack.push(sign);\\n            sum = 0\\n\\t\\t\\t// we used our sign, reset it to default.\\n            sign = 1;\\n        } else if (s[i] === \\')\\') {\\n\\t\\t\\t// closing bracket assumes we\\'ve calculated the sum inside the parens. \\n\\t\\t\\t// Earlier, we pushed the sum first into our stack. First pop will be the sign. Second pop will be the outer sum.\\n            sum = stack.pop() * sum;\\n            sum += stack.pop();\\n        }\\n    }\\n    \\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1483709,
                "title": "n-th-tribonacci-number-one-pass-w-explanation-c-python-java",
                "content": "**IDEA**\\n*One Pass*\\n\\nTo calculate N-th Tribonacci Number\\n* `T[0] = 0`\\n* `T[1] = 1`\\n* `T[2] = 1`\\n* `T[n] = T[n-3] + T[n-2] + T[n-1]`, `n >= 3`\\n\\nWe only need to store three values at a time. We can use \\n* 3 variables\\n* A static array and modulo-3 indexing.\\n\\n**TIME COMPLEXITY - O(N)**\\n**SPACE COMPLEXITY - O(1)**\\n\\n**SOLUTION**\\n*Using 3 variables*\\n`IN C++`\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if (n < 2) \\n            return n;\\n        int a = 0, b = 1, c = 1, d = a + b + c;\\n        while (n-- > 2) {\\n            d = a + b + c, a = b, b = c, c = d;\\n        }\\n        return c;\\n    }\\n};\\n```\\n`IN JAVA`\\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if (n < 2) return n;\\n        int a = 0, b = 1, c = 1, d;\\n        while (n-- > 2) {\\n            d = a + b + c;\\n            a = b;\\n            b = c;\\n            c = d;\\n        }\\n        return c;\\n    }\\n}\\n```\\n`IN PYTHON`\\n```\\ndef tribonacci(self, n):\\n        a, b, c = 1, 0, 0\\n        for _ in xrange(n): a, b, c = b, c, a + b + c\\n        return c\\n```\\n*Using Static Array*\\n`IN C++`\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int a[3] = {0 , 1 , 1} ;\\n        for(int i = 3 ; i <= n ; i++)\\n        {\\n            a[i%3] += a[(i+1)%3] + a[(i+2)%3] ;\\n        }\\n        return a[n%3] ;\\n    }\\n};\\n```\\n`IN JAVA`\\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        int a[] = {0, 1, 1};\\n        for (int i = 3; i <= n; i++)\\n            a[i % 3] = a[0] + a[1] + a[2];\\n        return a[n % 3];\\n    }\\n}\\n```\\n`IN PYTHON`\\n```\\nclass Solution(object):\\n    def tribonacci(self, n):\\n        a = [0, 1, 1]\\n        for i in xrange(3, n + 1):\\n            a[i % 3] = sum(a)\\n        return a[n % 3]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if (n < 2) \\n            return n;\\n        int a = 0, b = 1, c = 1, d = a + b + c;\\n        while (n-- > 2) {\\n            d = a + b + c, a = b, b = c, c = d;\\n        }\\n        return c;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if (n < 2) return n;\\n        int a = 0, b = 1, c = 1, d;\\n        while (n-- > 2) {\\n            d = a + b + c;\\n            a = b;\\n            b = c;\\n            c = d;\\n        }\\n        return c;\\n    }\\n}\\n```\n```\\ndef tribonacci(self, n):\\n        a, b, c = 1, 0, 0\\n        for _ in xrange(n): a, b, c = b, c, a + b + c\\n        return c\\n```\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int a[3] = {0 , 1 , 1} ;\\n        for(int i = 3 ; i <= n ; i++)\\n        {\\n            a[i%3] += a[(i+1)%3] + a[(i+2)%3] ;\\n        }\\n        return a[n%3] ;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        int a[] = {0, 1, 1};\\n        for (int i = 3; i <= n; i++)\\n            a[i % 3] = a[0] + a[1] + a[2];\\n        return a[n % 3];\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def tribonacci(self, n):\\n        a = [0, 1, 1]\\n        for i in xrange(3, n + 1):\\n            a[i % 3] = sum(a)\\n        return a[n % 3]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686489,
                "title": "optimal-generic-solution-for-basic-calculator-i-ii-iii-time-and-space-o-n",
                "content": "I found the similar template solution on these three 3 problems:\\n[Basic Calculator](https://leetcode.com/problems/basic-calculator/)  :   The expression string may contain open ( and closing parentheses ), the + , - operators, non-negative integers and empty spaces .\\n[Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/)  : The expression string contains only non-negative integers, +, -, *, / operators \\n[Basic Calculator III ](https://leetcode.com/problems/basic-calculator-iii/) : The expression string contains only non-negative integers, +, -, *, / operators , open ( and closing parentheses ) and empty spaces \\n\\n\\nSolution for [Basic Calculator III ](https://leetcode.com/problems/basic-calculator-iii/)\\n\\n```\\nclass Solution {\\n    // recursive Time and Space O(N)\\n    int i = 0;\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        int result = 0, tmp = 0, num = 0;\\n        char op = \\'+\\';\\n        \\n        while (i < s.length()) {\\n            char c = s.charAt(i++);\\n            if (Character.isDigit(c)) {\\n                tmp = tmp * 10 + c - \\'0\\';\\n            } else if (c == \\'(\\') {\\n                tmp = calculate(s);     // string parse index is tracked by i\\n            } else if (c == \\')\\') {\\n                break;\\n            } else if (c != \\' \\') {\\n                //process the numerical value of string so far; based on what \\'op\\' we have before it\\n                num = cal(num, tmp, op);\\n                if (c == \\'+\\' || c == \\'-\\') {\\n                    result += num;\\n                    num = 0;\\n                }\\n                //reset \\'tmp\\' and op for next character  processing\\n                tmp = 0;\\n                op = c;\\n            }\\n        }\\n        return result + cal(num, tmp, op);\\n    }\\n    private int cal(int num, int tmp, char op) {\\n        if (op == \\'+\\') return num + tmp;\\n        else if (op == \\'-\\') return num - tmp;\\n        else if (op == \\'*\\') return num * tmp;\\n        else return num / tmp;\\n    }\\n}\\n```\\n\\nSolution for [Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/)\\n```\\nclass Solution {        // 3 + 2 * 5\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        int num = 0, tmp = 0, res = 0;\\n        char op = \\'+\\';\\n        for (char c : s.toCharArray()) {\\n            if (Character.isDigit(c)) {\\n                tmp = tmp*10 + c - \\'0\\';\\n            } else if (c != \\' \\') {\\n\\t\\t\\t\\t//process the numerical value of string so far; based on what \\'op\\' we have before it\\n                num = cal(num, tmp, op);\\n                if (c == \\'+\\' || c == \\'-\\') {\\n                    res += num;\\n                    num = 0;\\n                }\\n\\t\\t\\t\\t// reset\\n                tmp = 0;\\n                op = c;\\n            }\\n        }\\n        return res + cal(num, tmp, op);\\n    }\\n    private int cal(int num, int tmp, char op) {\\n        if (op == \\'+\\') return num + tmp;\\n        else if (op == \\'-\\') return num - tmp;\\n        else if (op == \\'*\\') return num * tmp;\\n        else    return num / tmp;\\n    }\\n}\\n```\\n\\n\\nSolution for [Basic Calculator](https://leetcode.com/problems/basic-calculator/)\\n\\n```\\nclass Solution {\\n    // Time O(N) Space O(N) for recursive or stack\\n    int i = 0;\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        int tmp = 0, sign = 1, result = 0;\\n        while (i < s.length()) {\\n            char c = s.charAt(i++);\\n            if (Character.isDigit(c)) {\\n                tmp = tmp * 10 + c - \\'0\\';\\n            } else if (c == \\'(\\') {\\n                tmp = calculate(s);\\n            } else if (c == \\')\\') {\\n                break;\\n            } else if (c == \\'+\\' || c == \\'-\\') {\\n                result += sign * tmp;\\n                tmp = 0;\\n                sign = (c == \\'+\\')? 1 : -1;\\n            }\\n        }\\n        result += sign * tmp;\\n        return result;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // recursive Time and Space O(N)\\n    int i = 0;\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        int result = 0, tmp = 0, num = 0;\\n        char op = \\'+\\';\\n        \\n        while (i < s.length()) {\\n            char c = s.charAt(i++);\\n            if (Character.isDigit(c)) {\\n                tmp = tmp * 10 + c - \\'0\\';\\n            } else if (c == \\'(\\') {\\n                tmp = calculate(s);     // string parse index is tracked by i\\n            } else if (c == \\')\\') {\\n                break;\\n            } else if (c != \\' \\') {\\n                //process the numerical value of string so far; based on what \\'op\\' we have before it\\n                num = cal(num, tmp, op);\\n                if (c == \\'+\\' || c == \\'-\\') {\\n                    result += num;\\n                    num = 0;\\n                }\\n                //reset \\'tmp\\' and op for next character  processing\\n                tmp = 0;\\n                op = c;\\n            }\\n        }\\n        return result + cal(num, tmp, op);\\n    }\\n    private int cal(int num, int tmp, char op) {\\n        if (op == \\'+\\') return num + tmp;\\n        else if (op == \\'-\\') return num - tmp;\\n        else if (op == \\'*\\') return num * tmp;\\n        else return num / tmp;\\n    }\\n}\\n```\n```\\nclass Solution {        // 3 + 2 * 5\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        int num = 0, tmp = 0, res = 0;\\n        char op = \\'+\\';\\n        for (char c : s.toCharArray()) {\\n            if (Character.isDigit(c)) {\\n                tmp = tmp*10 + c - \\'0\\';\\n            } else if (c != \\' \\') {\\n\\t\\t\\t\\t//process the numerical value of string so far; based on what \\'op\\' we have before it\\n                num = cal(num, tmp, op);\\n                if (c == \\'+\\' || c == \\'-\\') {\\n                    res += num;\\n                    num = 0;\\n                }\\n\\t\\t\\t\\t// reset\\n                tmp = 0;\\n                op = c;\\n            }\\n        }\\n        return res + cal(num, tmp, op);\\n    }\\n    private int cal(int num, int tmp, char op) {\\n        if (op == \\'+\\') return num + tmp;\\n        else if (op == \\'-\\') return num - tmp;\\n        else if (op == \\'*\\') return num * tmp;\\n        else    return num / tmp;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    // Time O(N) Space O(N) for recursive or stack\\n    int i = 0;\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        int tmp = 0, sign = 1, result = 0;\\n        while (i < s.length()) {\\n            char c = s.charAt(i++);\\n            if (Character.isDigit(c)) {\\n                tmp = tmp * 10 + c - \\'0\\';\\n            } else if (c == \\'(\\') {\\n                tmp = calculate(s);\\n            } else if (c == \\')\\') {\\n                break;\\n            } else if (c == \\'+\\' || c == \\'-\\') {\\n                result += sign * tmp;\\n                tmp = 0;\\n                sign = (c == \\'+\\')? 1 : -1;\\n            }\\n        }\\n        result += sign * tmp;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227625,
                "title": "224-time-93-3-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis code implements a basic calculator to evaluate a given expression represented as a string s.\\n\\nThe algorithm processes the string character by character and maintains three variables ans, num, and sign, and a stack stack.\\n\\nans stores the running total of the expression evaluated so far, num stores the currently processed number, and sign stores the sign of the current environment. The stack keeps track of nested environments by storing the sign of the previous environment.\\n\\nThe algorithm then iterates through each character c in the string s and does the following:\\n\\n- If c is a digit, it appends it to num.\\n- If c is a left parenthesis (, it appends the current sign to the stack and sets sign to 1 (since the current environment is positive).\\n- If c is a right parenthesis ), it pops the last sign from the stack and sets sign to it.\\n- If c is a plus + or minus -, it updates the ans by adding the current sign * num to it, updates the sign to 1 or -1 depending on the current operator, and sets num to 0.\\n\\nFinally, the function returns the updated ans value plus the last sign * num.\\n\\nOverall, this algorithm works in linear time with respect to the length of the input string, since each character is processed once.\\n\\n# Complexity\\n- Time complexity:\\n93.3%\\n\\n- Space complexity:\\n72.30%\\n# Code\\n```\\nclass Solution:\\n  def calculate(self, s: str) -> int:\\n    ans = 0\\n    num = 0\\n    sign = 1\\n    stack = [sign]  # stack[-1]: current env\\'s sign\\n\\n    for c in s:\\n      if c.isdigit():\\n        num = num * 10 + (ord(c) - ord(\\'0\\'))\\n      elif c == \\'(\\':\\n        stack.append(sign)\\n      elif c == \\')\\':\\n        stack.pop()\\n      elif c == \\'+\\' or c == \\'-\\':\\n        ans += sign * num\\n        sign = (1 if c == \\'+\\' else -1) * stack[-1]\\n        num = 0\\n\\n    return ans + sign * num\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n  def calculate(self, s: str) -> int:\\n    ans = 0\\n    num = 0\\n    sign = 1\\n    stack = [sign]  # stack[-1]: current env\\'s sign\\n\\n    for c in s:\\n      if c.isdigit():\\n        num = num * 10 + (ord(c) - ord(\\'0\\'))\\n      elif c == \\'(\\':\\n        stack.append(sign)\\n      elif c == \\')\\':\\n        stack.pop()\\n      elif c == \\'+\\' or c == \\'-\\':\\n        ans += sign * num\\n        sign = (1 if c == \\'+\\' else -1) * stack[-1]\\n        num = 0\\n\\n    return ans + sign * num\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832860,
                "title": "c-dijkstra-s-shunting-yard-algorithm",
                "content": "There are much shorter solutions for this problem. The approach taken here is a little bit more generic and can easily adopted for other problems.\\n\\n# Approach 1: Dijkstra\\'s shunting yard algorithm\\n\\nThis approach is slightly more generic than it would need to be to solve this problem. It also handles multiplication and division. Checkout wikipedia for more details. I am not linking directly to it, as am worried that the LC automatic content moderator will flag the post.\\n\\n```cpp\\nclass Solution {\\nprivate:\\n    // Operator precedence.\\n    static int prec(char ch) {\\n        switch (ch) {\\n            case \\'(\\':\\n                // Use the lowest because we handled this differently.\\n                return -1;\\n\\n            case \\'+\\':\\n            case \\'-\\':\\n                return 0;\\n\\n            case \\'*\\':\\n            case \\'/\\':\\n                return 1;\\n\\n            case \\'_\\':\\n                // Use \\'_\\' for unary minus.\\n                return 2;\\n        }\\n        assert(false);\\n        return -1;\\n    }\\n    \\n    // Apply operators.\\n    static void apply(stack<int>& out, char op) {\\n        // Unary minus.\\n        if (op == \\'_\\') {\\n            out.top() *= -1;\\n            return;\\n        }\\n\\n        const int right = out.top(); out.pop();\\n        const int left = out.top(); out.pop();\\n        switch (op) {\\n            case \\'+\\':\\n                out.push(left + right);\\n                break;\\n            case \\'-\\':\\n                out.push(left - right);\\n                break;\\n            case \\'*\\':\\n                out.push(left * right);\\n                break;\\n            case \\'/\\':\\n                out.push(left / right);\\n                break;\\n            default:\\n                assert(false);\\n        }\\n    }\\n\\npublic:\\n    static int calculate(string s) {\\n        // Handling unary \\'-\\' from wcipeg.com:\\n        // A minus sign is always binary if it immediately follows an operand\\n        // or a right parenthesis, and it is always unary if it immediately\\n        // follows another operator or a left parenthesis, or if it occurs at\\n        // the very beginning of the input. The algorithm must be modified in\\n        // order to distinguish between the two.\\n\\n        // ... so we always push the last number\\n        s.push_back(\\' \\');\\n        \\n        stack<int> out;\\n        stack<char> st;\\n        \\n        char prev = \\' \\';\\n        string num;\\n        for (char ch : s) {\\n            if (isdigit(ch)) {\\n                num.push_back(ch);\\n                prev = \\'1\\';\\n            } else {\\n                if (!empty(num)) {\\n                    out.push(stoi(num));\\n                    num.clear();\\n                }\\n                \\n                if (ch == \\' \\') continue;\\n                \\n                if (ch == \\'(\\') {\\n                    st.push(\\'(\\');\\n                } else if (ch == \\')\\') {\\n                    while (st.top() != \\'(\\') {\\n                        apply(out, st.top());\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                } else {\\n                    // Unary minus.\\n                    if (ch == \\'-\\' && prev != \\'1\\' && prev != \\')\\') {\\n                        ch = \\'_\\';\\n                    }\\n                    while (!empty(st) && prec(ch) <= prec(st.top())) {\\n                        apply(out, st.top());\\n                        st.pop();\\n                    }\\n                    st.push(ch);\\n                }\\n\\n                prev = ch;\\n            }\\n        }\\n        \\n        while (!empty(st)) {\\n            apply(out, st.top());\\n            st.pop();\\n        }\\n\\n        assert(size(out) == 1);\\n        return out.top();\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ be the length of the input string then the\\n  * Time complexity is $$O(n)$$, and the \\n  * Space complexity is $$O(n)$$.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\nprivate:\\n    // Operator precedence.\\n    static int prec(char ch) {\\n        switch (ch) {\\n            case \\'(\\':\\n                // Use the lowest because we handled this differently.\\n                return -1;\\n\\n            case \\'+\\':\\n            case \\'-\\':\\n                return 0;\\n\\n            case \\'*\\':\\n            case \\'/\\':\\n                return 1;\\n\\n            case \\'_\\':\\n                // Use \\'_\\' for unary minus.\\n                return 2;\\n        }\\n        assert(false);\\n        return -1;\\n    }\\n    \\n    // Apply operators.\\n    static void apply(stack<int>& out, char op) {\\n        // Unary minus.\\n        if (op == \\'_\\') {\\n            out.top() *= -1;\\n            return;\\n        }\\n\\n        const int right = out.top(); out.pop();\\n        const int left = out.top(); out.pop();\\n        switch (op) {\\n            case \\'+\\':\\n                out.push(left + right);\\n                break;\\n            case \\'-\\':\\n                out.push(left - right);\\n                break;\\n            case \\'*\\':\\n                out.push(left * right);\\n                break;\\n            case \\'/\\':\\n                out.push(left / right);\\n                break;\\n            default:\\n                assert(false);\\n        }\\n    }\\n\\npublic:\\n    static int calculate(string s) {\\n        // Handling unary \\'-\\' from wcipeg.com:\\n        // A minus sign is always binary if it immediately follows an operand\\n        // or a right parenthesis, and it is always unary if it immediately\\n        // follows another operator or a left parenthesis, or if it occurs at\\n        // the very beginning of the input. The algorithm must be modified in\\n        // order to distinguish between the two.\\n\\n        // ... so we always push the last number\\n        s.push_back(\\' \\');\\n        \\n        stack<int> out;\\n        stack<char> st;\\n        \\n        char prev = \\' \\';\\n        string num;\\n        for (char ch : s) {\\n            if (isdigit(ch)) {\\n                num.push_back(ch);\\n                prev = \\'1\\';\\n            } else {\\n                if (!empty(num)) {\\n                    out.push(stoi(num));\\n                    num.clear();\\n                }\\n                \\n                if (ch == \\' \\') continue;\\n                \\n                if (ch == \\'(\\') {\\n                    st.push(\\'(\\');\\n                } else if (ch == \\')\\') {\\n                    while (st.top() != \\'(\\') {\\n                        apply(out, st.top());\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                } else {\\n                    // Unary minus.\\n                    if (ch == \\'-\\' && prev != \\'1\\' && prev != \\')\\') {\\n                        ch = \\'_\\';\\n                    }\\n                    while (!empty(st) && prec(ch) <= prec(st.top())) {\\n                        apply(out, st.top());\\n                        st.pop();\\n                    }\\n                    st.push(ch);\\n                }\\n\\n                prev = ch;\\n            }\\n        }\\n        \\n        while (!empty(st)) {\\n            apply(out, st.top());\\n            st.pop();\\n        }\\n\\n        assert(size(out) == 1);\\n        return out.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 153199,
                "title": "do-it-the-hard-way-real-lexer-and-parser",
                "content": "```py\\ndigits = set(\\'0123456789\\')\\n\\n\\ndef lexer(s):\\n    stack = []\\n    nums = \\'\\'\\n    for c in s:\\n        if c in digits:\\n            nums += c\\n        else:\\n            if len(nums) > 0:\\n                stack.append(int(nums))\\n                nums = \\'\\'\\n            if c != \\' \\':\\n                stack.append(c)\\n    if len(nums) > 0:\\n        stack.append(int(nums))\\n    return stack[::-1]\\n\\n\\n\"\"\"\\nterm = NUM | (expr)\\nexpr = term op_terms\\nop_terms = None | op_term op_terms\\nop_term = + term | - term\\n\"\"\"\\n\\n\\ndef parser_term(tokens):\\n    t = tokens.pop()\\n    if isinstance(t, int):\\n        return t\\n    elif t == \\'(\\':\\n        content = parser_expr(tokens)\\n        back = tokens.pop()\\n        assert back == \\')\\'\\n        return content\\n    else:\\n        print(tokens)\\n        raise Exception()\\n\\n\\ndef parser_expr(tokens):\\n    lhs = parser_term(tokens)\\n    if not tokens:\\n        return lhs\\n    op_terms = parser_op_terms(tokens)\\n    return lhs + op_terms\\n\\n\\ndef parser_op_terms(tokens):\\n    ret = 0\\n    while True:\\n        op_term = parser_op_term(tokens)\\n        if op_term is None:\\n            return ret\\n        ret += op_term\\n\\n\\ndef parser_op_term(tokens):\\n    if not tokens:\\n        return None\\n    t = tokens.pop()\\n    if t == \\'+\\':\\n        return parser_term(tokens)\\n    elif t == \\'-\\':\\n        return - parser_term(tokens)\\n    else:\\n        tokens.append(t)\\n        return None\\n\\n\\nclass Solution(object):\\n    def calculate(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        return parser_expr(lexer(s))\\n        \\n```",
                "solutionTags": [],
                "code": "```py\\ndigits = set(\\'0123456789\\')\\n\\n\\ndef lexer(s):\\n    stack = []\\n    nums = \\'\\'\\n    for c in s:\\n        if c in digits:\\n            nums += c\\n        else:\\n            if len(nums) > 0:\\n                stack.append(int(nums))\\n                nums = \\'\\'\\n            if c != \\' \\':\\n                stack.append(c)\\n    if len(nums) > 0:\\n        stack.append(int(nums))\\n    return stack[::-1]\\n\\n\\n\"\"\"\\nterm = NUM | (expr)\\nexpr = term op_terms\\nop_terms = None | op_term op_terms\\nop_term = + term | - term\\n\"\"\"\\n\\n\\ndef parser_term(tokens):\\n    t = tokens.pop()\\n    if isinstance(t, int):\\n        return t\\n    elif t == \\'(\\':\\n        content = parser_expr(tokens)\\n        back = tokens.pop()\\n        assert back == \\')\\'\\n        return content\\n    else:\\n        print(tokens)\\n        raise Exception()\\n\\n\\ndef parser_expr(tokens):\\n    lhs = parser_term(tokens)\\n    if not tokens:\\n        return lhs\\n    op_terms = parser_op_terms(tokens)\\n    return lhs + op_terms\\n\\n\\ndef parser_op_terms(tokens):\\n    ret = 0\\n    while True:\\n        op_term = parser_op_term(tokens)\\n        if op_term is None:\\n            return ret\\n        ret += op_term\\n\\n\\ndef parser_op_term(tokens):\\n    if not tokens:\\n        return None\\n    t = tokens.pop()\\n    if t == \\'+\\':\\n        return parser_term(tokens)\\n    elif t == \\'-\\':\\n        return - parser_term(tokens)\\n    else:\\n        tokens.append(t)\\n        return None\\n\\n\\nclass Solution(object):\\n    def calculate(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        return parser_expr(lexer(s))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 120868,
                "title": "javascript-in-68ms-beat-100",
                "content": "```\\nvar calculate = function(s) {\\n    let result = 0, sign = 1;\\n    const stack = [], opStack = [];\\n    \\n    for(let i = 0; i < s.length; i++){\\n        const curr = s.charAt(i);\\n        if(curr === \\' \\'){ \\n            continue;\\n        } else if(curr === \\'+\\'){ \\n            sign = 1;\\n        } else if(curr === \\'-\\'){ \\n            sign = -1;\\n        } else if(curr >= \\'0\\' && curr <= \\'9\\'){\\n            let num = curr;\\n            while(i+1 < s.length && s.charAt(i+1) >= \\'0\\' && s.charAt(i+1) <= \\'9\\'){\\n                num += s.charAt(i+1);\\n                i++;\\n            }\\n            result += sign * parseInt(num);\\n        } else if(curr === \\'(\\'){\\n            stack.push(result);  \\n            result = 0;  \\n            opStack.push(sign);  \\n            sign = 1;\\n        } else if(curr === \\')\\'){\\n            result = opStack.pop() * result + stack.pop();  \\n            sign = 1;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar calculate = function(s) {\\n    let result = 0, sign = 1;\\n    const stack = [], opStack = [];\\n    \\n    for(let i = 0; i < s.length; i++){\\n        const curr = s.charAt(i);\\n        if(curr === \\' \\'){ \\n            continue;\\n        } else if(curr === \\'+\\'){ \\n            sign = 1;\\n        } else if(curr === \\'-\\'){ \\n            sign = -1;\\n        } else if(curr >= \\'0\\' && curr <= \\'9\\'){\\n            let num = curr;\\n            while(i+1 < s.length && s.charAt(i+1) >= \\'0\\' && s.charAt(i+1) <= \\'9\\'){\\n                num += s.charAt(i+1);\\n                i++;\\n            }\\n            result += sign * parseInt(num);\\n        } else if(curr === \\'(\\'){\\n            stack.push(result);  \\n            result = 0;  \\n            opStack.push(sign);  \\n            sign = 1;\\n        } else if(curr === \\')\\'){\\n            result = opStack.pop() * result + stack.pop();  \\n            sign = 1;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 62443,
                "title": "simple-java-solution-with-recursion",
                "content": "        import java.util.*;\\n    \\n    public class Solution {\\n        public int calculate(String s) {\\n            return calc(new StringTokenizer(s, \" ()+-\", true));\\n        }\\n        \\n        int calc(StringTokenizer st){\\n            int sofar = 0;\\n            boolean plus = true; // last seen operator.\\n            while(st.hasMoreTokens()){\\n                int val =0;\\n                String next = st.nextToken();\\n                switch(next){\\n                    case \"(\":\\n                        val = calc(st);\\n                        sofar += (plus ?  val : -val);\\n                        break;\\n                    case \")\":\\n                        return sofar;\\n                    case \"+\":\\n                        plus = true;\\n                        break;\\n                    case \"-\":\\n                        plus = false;\\n                        break;\\n                    case \" \": // no-op\\n                        break;\\n                    default:\\n                        val = Integer.parseInt(next);\\n                        sofar += (plus ?  val : -val);\\n                        break;\\n                }\\n                \\n            }\\n            \\n            return sofar;\\n        }\\n    }\\n\\n\\nExplained: \\ncalc(), the working horse, is using a simple strategy: if \"(\" spotted, dive one level deeper in recursion. when it sees matching \")\", return with an integer value of expression between \"(...)\" . Each call of calc() handles expression within one pair of \"(...)\".\\n\\nWithin one pair of \"(..)\", generally there are only two cases: operator and operand. It's easy to handle them respectively. Slightly tricky thing is remembering last seen operator which is + or -.",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public int calculate(String s) {\\n            return calc(new StringTokenizer(s, \" ()+-\", true));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3403529,
                "title": "self-explanatory-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSimplest Iterative Approacg usubg Stack\\nThe code is itself self explanatory\\n# Code\\n```\\nclass Solution {\\n    public int calculate(String s) {\\n    Stack<Integer> stack = new Stack<Integer>();\\n    int result = 0;\\n    int number = 0;\\n    int sign = 1;\\n    for(int i = 0; i < s.length(); i++){\\n        char c = s.charAt(i);\\n        if(Character.isDigit(c)){\\n            number = 10 * number + (int)(c - \\'0\\');\\n        }else if(c == \\'+\\'){\\n            result += sign * number;\\n            number = 0;\\n            sign = 1;\\n        }else if(c == \\'-\\'){\\n            result += sign * number;\\n            number = 0;\\n            sign = -1;\\n        }else if(c == \\'(\\'){\\n            //we push the result first, then sign;\\n            stack.push(result);\\n            stack.push(sign);\\n            //reset the sign and result for the value in the parenthesis\\n            sign = 1;   \\n            result = 0;\\n        }else if(c == \\')\\'){\\n            result += sign * number;  \\n            number = 0;\\n            result *= stack.pop();    //stack.pop() is the sign before the parenthesis\\n            result += stack.pop();   //stack.pop() now is the result calculated before the parenthesis\\n            \\n        }\\n    }\\n    if(number != 0) result += sign * number;\\n    return result;\\n}\\n}\\n```\\n![471ac8c9-5c1b-4052-a76c-b8019c47bb11_1679937665.6666765.png](https://assets.leetcode.com/users/images/a268707f-dfc4-4df7-9595-d0db33e6f8b6_1681197417.9673645.png)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int calculate(String s) {\\n    Stack<Integer> stack = new Stack<Integer>();\\n    int result = 0;\\n    int number = 0;\\n    int sign = 1;\\n    for(int i = 0; i < s.length(); i++){\\n        char c = s.charAt(i);\\n        if(Character.isDigit(c)){\\n            number = 10 * number + (int)(c - \\'0\\');\\n        }else if(c == \\'+\\'){\\n            result += sign * number;\\n            number = 0;\\n            sign = 1;\\n        }else if(c == \\'-\\'){\\n            result += sign * number;\\n            number = 0;\\n            sign = -1;\\n        }else if(c == \\'(\\'){\\n            //we push the result first, then sign;\\n            stack.push(result);\\n            stack.push(sign);\\n            //reset the sign and result for the value in the parenthesis\\n            sign = 1;   \\n            result = 0;\\n        }else if(c == \\')\\'){\\n            result += sign * number;  \\n            number = 0;\\n            result *= stack.pop();    //stack.pop() is the sign before the parenthesis\\n            result += stack.pop();   //stack.pop() now is the result calculated before the parenthesis\\n            \\n        }\\n    }\\n    if(number != 0) result += sign * number;\\n    return result;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 429098,
                "title": "python3-solution-after-tokenization-60ms-beat-99-75",
                "content": "Please see and vote for my solutions for these similar problems\\n[224. Basic Calculator](https://leetcode.com/problems/basic-calculator/discuss/429098/Python3-solution-after-tokenization-(60ms-beat-99.75))\\n[227. Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/discuss/429100/Python3-solution-after-tokenization-(56ms-beat-99.92))\\n[282. Expression Add Operators](https://leetcode.com/problems/expression-add-operators/discuss/310707/Clean-Python-DFS-solution)\\n[772. Basic Calculator III](https://leetcode.com/problems/basic-calculator-iii/discuss/429132/Python3-solution-after-tokenization-(40ms-beat-93.59))\\n\\n```\\n    def calculate(self, s):\\n        for ch in [\\'+\\', \\'-\\', \\'(\\', \\')\\']:\\n            s = s.replace(ch, \\' \\' + ch + \\' \\')\\n        sign = 1\\n        stack = [0]\\n        for token in s.split():\\n            if token in \\'+-\\':\\n                sign = 1 if token == \\'+\\' else -1\\n            elif token == \\'(\\':\\n                stack.extend([sign, 0])\\n                sign = 1\\n            elif token == \\')\\':\\n                value = stack.pop() * stack.pop()\\n                stack[-1] += value\\n            else:\\n                stack[-1] += sign * int(token)\\n        return stack[-1]\\n```",
                "solutionTags": [],
                "code": "```\\n    def calculate(self, s):\\n        for ch in [\\'+\\', \\'-\\', \\'(\\', \\')\\']:\\n            s = s.replace(ch, \\' \\' + ch + \\' \\')\\n        sign = 1\\n        stack = [0]\\n        for token in s.split():\\n            if token in \\'+-\\':\\n                sign = 1 if token == \\'+\\' else -1\\n            elif token == \\'(\\':\\n                stack.extend([sign, 0])\\n                sign = 1\\n            elif token == \\')\\':\\n                value = stack.pop() * stack.pop()\\n                stack[-1] += value\\n            else:\\n                stack[-1] += sign * int(token)\\n        return stack[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 62386,
                "title": "java-one-pass-recursion-method-3ms-beat-99",
                "content": "```\\npublic class Solution {\\n    public int calculate(String s) {\\n        if (s.length() == 0) return 0;\\n        return calculateHelper(s, 0, new int[]{s.length()});\\n    }\\n        \\n    private int calculateHelper(String s, int start, int[] end) {\\n        int sum = 0;\\n        int res = 0;\\n        char sign = '+';\\n        for (int i = start; i < end[0]; i++) {\\n            char temp = s.charAt(i);\\n            if (temp >= '0' && temp <= '9') {\\n                sum = sum * 10 + (temp - '0');\\n            }\\n            if (temp == '+' || temp == '-' || temp == ')' || i == end[0] - 1) {\\n                res = (sign == '+') ? res + sum : res - sum; \\n                if (temp != ')') sign = temp;\\n                sum = 0;\\n            }\\n            // Return condition for recursion\\n            if (temp == ')' || i == end[0] - 1) {\\n                end[0] = i;\\n                return res;\\n            }\\n            if (temp == '(') {\\n                int[] newEnd = {end[0]};\\n                sum = calculateHelper(s, i + 1, newEnd);\\n                if (newEnd[0] == end[0] - 1) {\\n                    res = (sign == '+') ? res + sum : res - sum; \\n                }\\n                i = newEnd[0]; // Set i to the last recursion end point\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int calculate(String s) {\\n        if (s.length() == 0) return 0;\\n        return calculateHelper(s, 0, new int[]{s.length()});\\n    }\\n        \\n    private int calculateHelper(String s, int start, int[] end) {\\n        int sum = 0;\\n        int res = 0;\\n        char sign = '+';\\n        for (int i = start; i < end[0]; i++) {\\n            char temp = s.charAt(i);\\n            if (temp >= '0' && temp <= '9') {\\n                sum = sum * 10 + (temp - '0');\\n            }\\n            if (temp == '+' || temp == '-' || temp == ')' || i == end[0] - 1) {\\n                res = (sign == '+') ? res + sum : res - sum; \\n                if (temp != ')') sign = temp;\\n                sum = 0;\\n            }\\n            // Return condition for recursion\\n            if (temp == ')' || i == end[0] - 1) {\\n                end[0] = i;\\n                return res;\\n            }\\n            if (temp == '(') {\\n                int[] newEnd = {end[0]};\\n                sum = calculateHelper(s, i + 1, newEnd);\\n                if (newEnd[0] == end[0] - 1) {\\n                    res = (sign == '+') ? res + sum : res - sum; \\n                }\\n                i = newEnd[0]; // Set i to the last recursion end point\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832718,
                "title": "python-faster-than-98-o-n-stack-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/96403984-e4da-4825-aacd-83323d7db386_1668934190.883803.png)\\n\\n\\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        output, curr, sign, stack = 0, 0, 1, []\\n        for c in s:\\n            if c.isdigit():\\n                curr = (curr * 10) + int(c)\\n            \\n            elif c in \\'+-\\':\\n                output += curr * sign\\n                curr = 0\\n                if c == \\'+\\':\\n                    sign = 1\\n\\n                else:\\n                    sign = -1\\n            \\n            elif c == \\'(\\':\\n                stack.append(output)\\n                stack.append(sign)\\n                sign = 1\\n                output = 0\\n            \\n            elif c == \\')\\':\\n                output += curr * sign\\n                output *= stack.pop()    #sign\\n                output += stack.pop()    #last output\\n                curr = 0\\n\\n        return output + (curr * sign)\\n```\\n# Please upvote if you find this helpful.",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        output, curr, sign, stack = 0, 0, 1, []\\n        for c in s:\\n            if c.isdigit():\\n                curr = (curr * 10) + int(c)\\n            \\n            elif c in \\'+-\\':\\n                output += curr * sign\\n                curr = 0\\n                if c == \\'+\\':\\n                    sign = 1\\n\\n                else:\\n                    sign = -1\\n            \\n            elif c == \\'(\\':\\n                stack.append(output)\\n                stack.append(sign)\\n                sign = 1\\n                output = 0\\n            \\n            elif c == \\')\\':\\n                output += curr * sign\\n                output *= stack.pop()    #sign\\n                output += stack.pop()    #last output\\n                curr = 0\\n\\n        return output + (curr * sign)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62446,
                "title": "java-solution-use-stack",
                "content": "    public int calculate(String s) {\\n        int res =0,val=0;\\n        int sign = 1;\\n        Stack<Integer> st = new Stack<Integer>();\\n        s.trim();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i) == '('){\\n                st.push(sign);\\n            }else if(s.charAt(i) == ')'){\\n                st.pop();\\n            }else if(s.charAt(i) == '+' || s.charAt(i) == '-'){\\n                res += sign*val;\\n                val = 0;\\n                if(!st.isEmpty()) {\\n                    sign = s.charAt(i) =='-'?st.peek()*(-1):st.peek();\\n                }else {\\n                    sign = s.charAt(i) =='-'?-1:1;\\n                }\\n            }else if(s.charAt(i) !=' '){\\n                val = val*10 + (s.charAt(i)-'0');\\n            }\\n        }\\n        res += val*sign;\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    public int calculate(String s) {\\n        int res =0,val=0;\\n        int sign = 1;\\n        Stack<Integer> st = new Stack<Integer>();\\n        s.trim();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i) == '('){\\n                st.push(sign);\\n            }else if(s.charAt(i) == ')'){\\n                st.pop();\\n            }else if(s.charAt(i) == '+' || s.charAt(i) == '-'){\\n                res += sign*val;\\n                val = 0;\\n                if(!st.isEmpty()) {\\n                    sign = s.charAt(i) =='-'?st.peek()*(-1):st.peek();\\n                }else {\\n                    sign = s.charAt(i) =='-'?-1:1;\\n                }\\n            }else if(s.charAt(i) !=' '){\\n                val = val*10 + (s.charAt(i)-'0');\\n            }\\n        }\\n        res += val*sign;\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2579719,
                "title": "c-with-comments-stack-easy-solution",
                "content": "///\\n\\nclass Solution {\\npublic:\\n\\n    int stringTointeger(string str)   //To convert the given string into integer (since we don\\'t have to use any built-in function)\\n    {\\n        int sum = 0;\\n        for(int i = 0 ; i < str.length() ; i++)\\n        {\\n            sum = sum*10 + (str[i]-\\'0\\');\\n        }\\n        return sum;\\n    }\\n    \\n    int calculate(string s) {\\n        int num = 0, ans = 0 , i = 0, sign = 1;\\n        stack<int> st;\\n        \\n        while(i < s.length())\\n        {\\n            if(s[i] >= 48 && s[i] <= 57)   //if we encounter with any digit (0---9)\\n            {\\n                string number;\\n                while(s[i]>= 48 && s[i] <= 57)  // store the whole digit in a new string \\n                {\\n                    number += s[i];\\n                    i++;\\n                }\\n                i--;   // i will be one index forward after coming out from while loop, so we\\'ll decrement it to its right place\\n                num = stringTointeger(number);  // converting digit string to num \\n                num *= sign;                   // multiplying with sign and storing to ans\\n                ans += num;\\n            }\\n            \\n            else if(s[i] == \\'+\\')\\n                sign = 1;\\n            else if(s[i] == \\'-\\')\\n                sign = -1;\\n            else if(s[i] == \\'(\\')    // if we encounter this, we\\'ll push our current answer with its sign \\n            {                       // then we\\'ll consider new ans to be 0 and number to be positive and repeat the same steps\\n                st.push(ans);\\n                st.push(sign);\\n                ans = 0;\\n                sign = 1;\\n            }\\n            else if(s[i] == \\')\\')  // when the whole bracket is done , we\\'ll multiplty it with previous num sign stored in stack \\n            {                     // and then adding the previous ans to our current ans \\n                ans *= st.top();\\n                st.pop();\\n                ans += st.top();\\n                st.pop();\\n            }\\n            i++;\\n        }\\n      return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int stringTointeger(string str)   //To convert the given string into integer (since we don\\'t have to use any built-in function)\\n    {\\n        int sum = 0;\\n        for(int i = 0 ; i < str.length() ; i++)\\n        {\\n            sum = sum*10 + (str[i]-\\'0\\');\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1488171,
                "title": "explaining-transform-to-chessboard-c",
                "content": "**The key idea is:**\\nIf the grid has a solution, we can arrive at the solution by looking only at the first row and the first column. This happens because each solution step moves the entire row or entire column.\\n\\n**How to know if the table has a solution?**\\nThe dimensions are dependent, so we need to check that when correcting the first row or first column, the values in the middle of the table are resolved too.\\n\\nThe code below shows how we analyze this:\\n```c++\\nfor (int i=1; i<board.size(); i++) {\\n    for (int j=1; j<board[i].size(); j++) {\\n        if (((board[0][0] ^ board[i][0]) ^ (board[i][j] ^ board[0][j])) == 1) {\\n            return -1;\\n        }\\n    }\\n}\\n```\\n\\nThis code compares whether the middle value has the same parity with the edge values.\\n\\n[![Image from Gyazo](https://i.gyazo.com/1dc9dbe67d99ded468cd73efb0a2a03e.png)](https://gyazo.com/1dc9dbe67d99ded468cd73efb0a2a03e)\\n\\n- if the blue cells have different values, the green cells must also have different values.\\n- if blue cells have equal values, green cells must also have equal values.\\n\\nIf neither of the above two conditions are true, we have a table that is impossible to solve. \\nThis looks like magic right? Let\\'s look at the solved table:\\n<p>\\n<img src=\"https://i.gyazo.com/f3e3ee7360a38024e12ef928fef72cc9.png\" width=\"30%\">\\n</p>\\n\\nBetween two adjacent lines, one is the conjugate of the other and the same applies for columns. When we swap a row or a column from an solved table, we have two scenarios:\\n\\n1. Swap identical row or collumn\\n2. Swap conjugated row or collumn\\n\\nNo matter how many operations you do, we will always fall into these two scenarios. In summary, the code above checks if the current table has this property.\\n\\nBefore calculating the number of steps to reach the solution. We need to do one more validation, this one is much simpler.\\n\\nThis validation consists of counting the number of 1s and 0s in the first row and in the first column:\\n```c++\\nfor (int i=0; i<N; i++) {\\n\\tif (board[0][i]) onesInFirstRow++;\\n\\telse zerosInFirstRow++;\\n\\n\\tif (board[i][0]) onesInFirstCol++;\\n\\telse zerosInFirstCol++;\\n}\\n\\nif (abs(onesInFirstRow - zerosInFirstRow) > 1) return -1;\\nif (abs(onesInFirstCol - zerosInFirstCol) > 1) return -1;\\n```\\n\\n- If the difference between zeros and ones is greater than 1, it\\'s impossible solve this table.\\n\\n\\nNow to calculate the minimum number of steps, we need to solve the first column and the first row individually and sum each result.\\n\\n**Solving to first row and column**\\n\\nTo solve this, we have two scenarios:\\n1. N even\\n2. N odd\\n\\nWhen N is even, we have two solutions:\\n\\n- **[0,1,...,0,1]** (starting with 0)\\n- **[1,0,...,1,0]** (starting with 1)\\n\\n\\nWe know that each swap can fix two elements as we can see in the example below:\\n\\n- **[0,0,1,1]**  --> **[0,1,0,1]**  (swap second with third item)\\n\\nSo, the number of moviments needed to transform a row or a collumn to any two possible solution is:\\n\\n- number of wrong elements divided by 2\\n\\nAs one solution is the inverse of the other, we can say that:\\n\\n- **solution_start_one** = N - **solution_start_zero**\\n\\nTherefore, when N is even, the answer will be the smallest value between the two possible solutions.\\n\\n```c++\\n// This for compare the first row and column \\n// with the solution that starts with one\\nfor (int i=0; i<N; i++) {\\n\\tif (board[0][i] == i%2) rowMovesNeeded++;\\n\\tif (board[i][0] == i%2) colMovesNeeded++;\\n} \\n\\nif (N % 2 == 0) {\\n\\tcolMovesNeeded = min(colMovesNeeded, N-colMovesNeeded);\\n\\trowMovesNeeded = min(rowMovesNeeded, N-rowMovesNeeded);\\n\\t\\n\\treturn (colMovesNeeded + rowMovesNeeded) / 2;\\n} \\n\\n// solve when N is odd\\n```\\n\\nWhen N is odd, we have only one solution:\\n\\n- **[1,0,..,0,1]** (when the row or column has more ones)\\n- **[0,1,..,1,0]** (when the row or column has more zeros)\\n\\nIf we have more zeros, we only use the value to solution that begin with zero. So with odd N we need analyze the number of zeros and use the correct solution to each case.\\n\\n```c++\\nif (onesInFirstCol < zerosInFirstCol) {\\n\\tcolMovesNeeded = N - colMovesNeeded;\\n}\\n\\nif (onesInFirstRow < zerosInFirstRow) {\\n\\trowMovesNeeded = N - rowMovesNeeded;\\n}\\n\\nreturn (colMovesNeeded + rowMovesNeeded) / 2;\\n```\\n\\nThe code for this question is quite simple, but the idea behind it is quite complex. I really enjoyed the insights that this problem required.\\n\\nThe final code is:\\n```c++\\nclass Solution {\\npublic:\\n\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int N = board.size();\\n        int colMovesNeeded = 0, rowMovesNeeded = 0;\\n        int onesInFirstCol = 0, onesInFirstRow = 0;\\n        int zerosInFirstCol = 0, zerosInFirstRow = 0;\\n\\n        for (int i=1; i<board.size(); i++) {\\n            for (int j=1; j<board[i].size(); j++) {\\n                if (((board[0][0] ^ board[i][0]) ^ (board[i][j] ^ board[0][j])) == 1) {\\n                    return -1;\\n                }\\n            }\\n        }\\n        \\n        for (int i=0; i<N; i++) {\\n            if (board[0][i]) onesInFirstRow++;\\n            else zerosInFirstRow++;\\n            \\n            if (board[i][0]) onesInFirstCol++;\\n            else zerosInFirstCol++;\\n        }\\n        \\n        if (abs(onesInFirstRow - zerosInFirstRow) > 1) return -1;\\n        if (abs(onesInFirstCol - zerosInFirstCol) > 1) return -1;\\n        \\n        for (int i=0; i<N; i++) {\\n            if (board[0][i] == i%2) rowMovesNeeded++;\\n            if (board[i][0] == i%2) colMovesNeeded++;\\n        }    \\n        \\n        \\n        if (N % 2 == 1) {\\n            \\n            if (onesInFirstCol < zerosInFirstCol) {\\n                colMovesNeeded = N - colMovesNeeded;\\n            }\\n            \\n            if (onesInFirstRow < zerosInFirstRow) {\\n                rowMovesNeeded = N - rowMovesNeeded;\\n            }\\n            \\n        } else {\\n            colMovesNeeded = min(colMovesNeeded, N-colMovesNeeded);\\n            rowMovesNeeded = min(rowMovesNeeded, N-rowMovesNeeded);\\n        }\\n        \\n\\n        \\n        return (colMovesNeeded + rowMovesNeeded) / 2;\\n    }\\n};\\n```\\nI am sorry for my english. I\\'m just a young brazilian boy trying to help this community.",
                "solutionTags": [],
                "code": "```c++\\nfor (int i=1; i<board.size(); i++) {\\n    for (int j=1; j<board[i].size(); j++) {\\n        if (((board[0][0] ^ board[i][0]) ^ (board[i][j] ^ board[0][j])) == 1) {\\n            return -1;\\n        }\\n    }\\n}\\n```\n```c++\\nfor (int i=0; i<N; i++) {\\n\\tif (board[0][i]) onesInFirstRow++;\\n\\telse zerosInFirstRow++;\\n\\n\\tif (board[i][0]) onesInFirstCol++;\\n\\telse zerosInFirstCol++;\\n}\\n\\nif (abs(onesInFirstRow - zerosInFirstRow) > 1) return -1;\\nif (abs(onesInFirstCol - zerosInFirstCol) > 1) return -1;\\n```\n```c++\\n// This for compare the first row and column \\n// with the solution that starts with one\\nfor (int i=0; i<N; i++) {\\n\\tif (board[0][i] == i%2) rowMovesNeeded++;\\n\\tif (board[i][0] == i%2) colMovesNeeded++;\\n} \\n\\nif (N % 2 == 0) {\\n\\tcolMovesNeeded = min(colMovesNeeded, N-colMovesNeeded);\\n\\trowMovesNeeded = min(rowMovesNeeded, N-rowMovesNeeded);\\n\\t\\n\\treturn (colMovesNeeded + rowMovesNeeded) / 2;\\n} \\n\\n// solve when N is odd\\n```\n```c++\\nif (onesInFirstCol < zerosInFirstCol) {\\n\\tcolMovesNeeded = N - colMovesNeeded;\\n}\\n\\nif (onesInFirstRow < zerosInFirstRow) {\\n\\trowMovesNeeded = N - rowMovesNeeded;\\n}\\n\\nreturn (colMovesNeeded + rowMovesNeeded) / 2;\\n```\n```c++\\nclass Solution {\\npublic:\\n\\n    int movesToChessboard(vector<vector<int>>& board) {\\n        int N = board.size();\\n        int colMovesNeeded = 0, rowMovesNeeded = 0;\\n        int onesInFirstCol = 0, onesInFirstRow = 0;\\n        int zerosInFirstCol = 0, zerosInFirstRow = 0;\\n\\n        for (int i=1; i<board.size(); i++) {\\n            for (int j=1; j<board[i].size(); j++) {\\n                if (((board[0][0] ^ board[i][0]) ^ (board[i][j] ^ board[0][j])) == 1) {\\n                    return -1;\\n                }\\n            }\\n        }\\n        \\n        for (int i=0; i<N; i++) {\\n            if (board[0][i]) onesInFirstRow++;\\n            else zerosInFirstRow++;\\n            \\n            if (board[i][0]) onesInFirstCol++;\\n            else zerosInFirstCol++;\\n        }\\n        \\n        if (abs(onesInFirstRow - zerosInFirstRow) > 1) return -1;\\n        if (abs(onesInFirstCol - zerosInFirstCol) > 1) return -1;\\n        \\n        for (int i=0; i<N; i++) {\\n            if (board[0][i] == i%2) rowMovesNeeded++;\\n            if (board[i][0] == i%2) colMovesNeeded++;\\n        }    \\n        \\n        \\n        if (N % 2 == 1) {\\n            \\n            if (onesInFirstCol < zerosInFirstCol) {\\n                colMovesNeeded = N - colMovesNeeded;\\n            }\\n            \\n            if (onesInFirstRow < zerosInFirstRow) {\\n                rowMovesNeeded = N - rowMovesNeeded;\\n            }\\n            \\n        } else {\\n            colMovesNeeded = min(colMovesNeeded, N-colMovesNeeded);\\n            rowMovesNeeded = min(rowMovesNeeded, N-rowMovesNeeded);\\n        }\\n        \\n\\n        \\n        return (colMovesNeeded + rowMovesNeeded) / 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456881,
                "title": "basic-calculator-with-explanation-stack",
                "content": "We know that things in the parentheses should be on higher priority. \\nHere, we need to calculate the numbers on the same level. Whenever we see a `(`, put the intermediate result into the stack, and start new calculation right after this `(`. When we see a `)`, pop the add/minus the result with the last item in the stack.\\n\\nWe need to pay attention to 5 possible inputs\\n\\n- digit: it should be one digit from the current number and consecutive digits forms sum\\n-  `+`: set the sign to 1;\\n-  `-`: set the sgin to -1\\n-  `(`: push the previous result and the sign into the stack, set result to 0, just calculate the new result within the parenthesis.\\n- `)`: pop out the top two numbers from stack, first one is the sign before this pair of parenthesis, second is the temporary result before this pair of parenthesis. We add them together.\\n\\n***Java Solution***\\n```\\nint len = s.length(), sign = 1, result = 0;\\nStack<Integer> stack = new Stack<Integer>();\\nfor (int i = 0; i < len; i++) {\\n\\tif (Character.isDigit(s.charAt(i))) {\\n\\t\\tint sum = s.charAt(i) - \\'0\\';\\n\\t\\twhile (i + 1 < len && Character.isDigit(s.charAt(i + 1))) {\\n\\t\\t\\tsum = sum * 10 + s.charAt(i + 1) - \\'0\\';\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tresult += sum * sign;\\n\\t} else if (s.charAt(i) == \\'+\\')\\n\\t\\tsign = 1;\\n\\telse if (s.charAt(i) == \\'-\\')\\n\\t\\tsign = -1;\\n\\telse if (s.charAt(i) == \\'(\\') {\\n\\t\\tstack.push(result);\\n\\t\\tstack.push(sign);\\n\\t\\tresult = 0;\\n\\t\\tsign = 1;\\n\\t} else if (s.charAt(i) == \\')\\') {\\n\\t\\tresult = result * stack.pop() + stack.pop();\\n\\t}\\n\\n}\\nreturn result;\\n```\\n\\n___\\n\\n***Python Solution***\\n```\\nclass Solution(object):\\n    def calculate(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        stack = []\\n        # 1 means positive, -1 means negative\\n        # we declare it as an integer because we want to put the +- in the stack too\\n        sign = 1\\n        num = 0\\n        i = 0\\n        while i < len(s):\\n            if s[i].isdigit():\\n                # construct a multi-digits number if any, e.g. \"23\" = 2*10+3 = 23\\n                j = i\\n                num = 0\\n                while j < len(s) and s[j].isdigit():\\n                    num = num*10 + int(s[j])\\n                    j += 1\\n                # sum up the intermediate result\\n                res += sign * num\\n                i = j\\n            elif s[i] == \\'+\\':\\n                # the next number will be using +\\n                sign = 1\\n                i += 1\\n            elif s[i] == \\'-\\':\\n                # the next number will be using -\\n                sign = -1\\n                i += 1\\n            elif s[i] == \\'(\\':\\n                # put the intermediate result(from the front) and sign into the stack\\n                stack.append(res)\\n                stack.append(sign)\\n                # since we have put the intermediate result in stack,\\n                # we can reset the things for calculation starting from this (\\n                res = 0\\n                sign = 1\\n                i += 1\\n            elif s[i] == \\')\\':\\n                # last item is the sign we saved for calculation e.g. 1+(2+3) the 1st +\\n                sign = stack.pop()\\n                # previousLevelResult the intermediate result before this level, (xxx)\\n                previousLevelResult = stack.pop()\\n                # sign*res is the result within the current (xxx)\\n                res = previousLevelResult + sign * res\\n                i += 1\\n            else:\\n                i += 1\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Stack"
                ],
                "code": "```\\nint len = s.length(), sign = 1, result = 0;\\nStack<Integer> stack = new Stack<Integer>();\\nfor (int i = 0; i < len; i++) {\\n\\tif (Character.isDigit(s.charAt(i))) {\\n\\t\\tint sum = s.charAt(i) - \\'0\\';\\n\\t\\twhile (i + 1 < len && Character.isDigit(s.charAt(i + 1))) {\\n\\t\\t\\tsum = sum * 10 + s.charAt(i + 1) - \\'0\\';\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tresult += sum * sign;\\n\\t} else if (s.charAt(i) == \\'+\\')\\n\\t\\tsign = 1;\\n\\telse if (s.charAt(i) == \\'-\\')\\n\\t\\tsign = -1;\\n\\telse if (s.charAt(i) == \\'(\\') {\\n\\t\\tstack.push(result);\\n\\t\\tstack.push(sign);\\n\\t\\tresult = 0;\\n\\t\\tsign = 1;\\n\\t} else if (s.charAt(i) == \\')\\') {\\n\\t\\tresult = result * stack.pop() + stack.pop();\\n\\t}\\n\\n}\\nreturn result;\\n```\n```\\nclass Solution(object):\\n    def calculate(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        stack = []\\n        # 1 means positive, -1 means negative\\n        # we declare it as an integer because we want to put the +- in the stack too\\n        sign = 1\\n        num = 0\\n        i = 0\\n        while i < len(s):\\n            if s[i].isdigit():\\n                # construct a multi-digits number if any, e.g. \"23\" = 2*10+3 = 23\\n                j = i\\n                num = 0\\n                while j < len(s) and s[j].isdigit():\\n                    num = num*10 + int(s[j])\\n                    j += 1\\n                # sum up the intermediate result\\n                res += sign * num\\n                i = j\\n            elif s[i] == \\'+\\':\\n                # the next number will be using +\\n                sign = 1\\n                i += 1\\n            elif s[i] == \\'-\\':\\n                # the next number will be using -\\n                sign = -1\\n                i += 1\\n            elif s[i] == \\'(\\':\\n                # put the intermediate result(from the front) and sign into the stack\\n                stack.append(res)\\n                stack.append(sign)\\n                # since we have put the intermediate result in stack,\\n                # we can reset the things for calculation starting from this (\\n                res = 0\\n                sign = 1\\n                i += 1\\n            elif s[i] == \\')\\':\\n                # last item is the sign we saved for calculation e.g. 1+(2+3) the 1st +\\n                sign = stack.pop()\\n                # previousLevelResult the intermediate result before this level, (xxx)\\n                previousLevelResult = stack.pop()\\n                # sign*res is the result within the current (xxx)\\n                res = previousLevelResult + sign * res\\n                i += 1\\n            else:\\n                i += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327015,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int n = s.size();\\n        stack<int> stk;\\n        int sum=0,sign=1;\\n        \\n        for(int i=0;i<n;++i){\\n            char ch = s[i];\\n            if(isdigit(ch)){\\n                int val=0;\\n                while(i<n && isdigit(s[i])){\\n                    val = val*10 + (s[i]-\\'0\\');\\n                    ++i;\\n                }\\n                --i;\\n                val *= sign;\\n                sum += val;\\n                sign = 1;\\n            }else if(ch==\\'(\\'){\\n                stk.push(sum);\\n                stk.push(sign);\\n                sum=0;\\n                sign = 1;\\n            }else if(ch==\\')\\'){\\n                sum *= stk.top(); stk.pop();\\n                sum += stk.top(); stk.pop();\\n            }else if(ch==\\'-\\'){\\n                sign = -1;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int n = s.size();\\n        stack<int> stk;\\n        int sum=0,sign=1;\\n        \\n        for(int i=0;i<n;++i){\\n            char ch = s[i];\\n            if(isdigit(ch)){\\n                int val=0;\\n                while(i<n && isdigit(s[i])){\\n                    val = val*10 + (s[i]-\\'0\\');\\n                    ++i;\\n                }\\n                --i;\\n                val *= sign;\\n                sum += val;\\n                sign = 1;\\n            }else if(ch==\\'(\\'){\\n                stk.push(sum);\\n                stk.push(sign);\\n                sum=0;\\n                sign = 1;\\n            }else if(ch==\\')\\'){\\n                sum *= stk.top(); stk.pop();\\n                sum += stk.top(); stk.pop();\\n            }else if(ch==\\'-\\'){\\n                sign = -1;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142162,
                "title": "beats-100-stack-recursion-java-scala-python",
                "content": "It is inductive to loop through `s` and take action according to the current character.\\n* **Common ground** for both solutions \\nWhenever we meet `\\'+\\'` or `\\'-\\'`, we update current `curSign`.\\nWhenever we meet `\\' \\'`, we do nothing but move on.\\nWhenever we meet a number, we update current `result`.\\n* **Difference** between two solutions lies in how to do with contents between the parenthesis.\\n**Solution using stack**: \\nWhen we meet `\\'(\\'`, `stack.push(result); stack.push(curSign);`\\nWhen we meet `\\')\\'`, `result = stack.pop() * result + stack.pop();`.\\n**Solution using Recursion**: \\nWhen we meet `\\'(\\'`, `result += curSign * calculateAfter(s);`\\nWhen we meet `\\')\\'`, `return result` to terminate current recursion.\\nPlase note that the problem shares the same structure with its subproblems - evaluate expression within the parenthesis. There are two types of base cases - `i == s.length()` for the outmost recursion, `case \\')\\'` for inner recursion layers.\\n> Java\\n\\n**Using Stack**\\n```\\n    public int calculate(String s) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int i = 0, curSign = 1, curNum = 0, result = 0;\\n        \\n        while (i < s.length()) {\\n            char ch = s.charAt(i);\\n            switch(ch) {\\n                case \\' \\':\\n                    break;\\n                case \\'+\\':\\n                    curSign = 1;\\n                    break;\\n                case \\'-\\':\\n                    curSign = -1;\\n                    break;\\n                case \\'(\\':\\n                    stack.push(result);\\n                    stack.push(curSign);\\n                    result = 0;\\n                    curSign = 1;\\n                    break;\\n                case \\')\\':\\n                    result = stack.pop() * result + stack.pop();\\n                    break;\\n                default:\\n                    int num = ch - \\'0\\';\\n                    while (i + 1 < s.length() && Character.isDigit(s.charAt(i + 1))) {\\n                        num = num * 10 + s.charAt(++i) - \\'0\\';\\n                    }\\n                    curNum = num;\\n                    result += curSign * curNum;\\n            } \\n            i++;\\n        }\\n        \\n        return result;\\n    }\\n```\\n\\n**Recursion**\\n```\\n    private static int i;\\n    \\n    public int calculate(String s) {\\n        i = 0;\\n        return calculateAfter(s);\\n    }\\n    \\n    private int calculateAfter(String s) {\\n        // Base case.\\n        if (i == s.length()) \\n            return 0;\\n        \\n        int curSign = 1, curNum = 0, result = 0;\\n        while (i < s.length()) {\\n            char ch = s.charAt(i);\\n            switch(ch) {\\n                case \\' \\':\\n                    break;\\n                case \\'+\\':\\n                    curSign = 1;\\n                    break;\\n                case \\'-\\':\\n                    curSign = -1;\\n                    break;\\n                case \\'(\\':\\n                    i++;\\n                    result += curSign * calculateAfter(s);\\n                    curSign = 1;\\n                    break;\\n                case \\')\\':\\n                    // Base case.\\n                    return result;\\n                default:\\n                    int num = ch - \\'0\\';\\n                    while (i + 1 < s.length() && Character.isDigit(s.charAt(i + 1))) {\\n                        num = num * 10 + s.charAt(++i) - \\'0\\';\\n                    }\\n                    curNum = num;\\n                    result += curSign * curNum;\\n            } \\n            i++;\\n        }\\n        \\n        return result;\\n    }\\n```\\n> Scala\\n```\\n    def calculate(s: String): Int = {\\n        var i = 0\\n        \\n        def evaluate(s: String): Int = {\\n            var curSign = 1 // 1 if plus operator, -1 if minus operator.\\n            var curResult = 0 \\n            \\n            while (i < s.length()) {\\n                s(i) match {\\n                    case \\'+\\' => curSign = 1\\n                    case \\'-\\' => curSign = -1\\n                    case \\' \\' => \\n                    case \\'(\\' => {\\n                        i += 1\\n                        curResult += curSign * evaluate(s)\\n                        curSign = 1\\n                    }\\n                    case \\')\\' => return curResult\\n                    case _ => { // If s(i) is a digit.\\n                        // Get the current whole number.\\n                        var curNum = s(i) - \\'0\\' \\n                        while (i + 1 < s.length() && Character.isDigit(s(i + 1))) {\\n                            curNum = curNum * 10 +  s(i + 1) - \\'0\\'\\n                            i += 1\\n                        }\\n                        \\n                        curResult += curSign * curNum \\n                        curSign = 1\\n                    }\\n                }\\n                \\n                i += 1\\n            }\\n            \\n            return curResult\\n        }\\n        \\n        evaluate(s)\\n    }\\n```\\n> Python\\n```\\n    def calculate(self, s):\\n  \\n      def evaluation(s):\\n        nonlocal i\\n        curSign, curResult = 1, 0\\n        \\n        while i < len(s):\\n          if s[i] == \\' \\': \\n            i += 1\\n            continue\\n          elif s[i] == \\'+\\':\\n            curSign = 1\\n          elif s[i] == \\'-\\':\\n            curSign = -1\\n          elif s[i] == \\'(\\':\\n            i += 1\\n            curResult += curSign * evaluation(s)\\n            curSign = 1\\n          elif s[i] == \\')\\':\\n            return curResult\\n          else:  # s[i] is digit.\\n            curNum = int(s[i])\\n            while i + 1 < len(s) and s[i + 1].isdigit():\\n              curNum = curNum * 10 + int(s[i + 1])\\n              i += 1\\n            curResult += curNum * curSign\\n            curSign = 1\\n          i += 1\\n          \\n        return curResult\\n      \\n      i = 0\\n      return evaluation(s)\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n    public int calculate(String s) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int i = 0, curSign = 1, curNum = 0, result = 0;\\n        \\n        while (i < s.length()) {\\n            char ch = s.charAt(i);\\n            switch(ch) {\\n                case \\' \\':\\n                    break;\\n                case \\'+\\':\\n                    curSign = 1;\\n                    break;\\n                case \\'-\\':\\n                    curSign = -1;\\n                    break;\\n                case \\'(\\':\\n                    stack.push(result);\\n                    stack.push(curSign);\\n                    result = 0;\\n                    curSign = 1;\\n                    break;\\n                case \\')\\':\\n                    result = stack.pop() * result + stack.pop();\\n                    break;\\n                default:\\n                    int num = ch - \\'0\\';\\n                    while (i + 1 < s.length() && Character.isDigit(s.charAt(i + 1))) {\\n                        num = num * 10 + s.charAt(++i) - \\'0\\';\\n                    }\\n                    curNum = num;\\n                    result += curSign * curNum;\\n            } \\n            i++;\\n        }\\n        \\n        return result;\\n    }\\n```\n```\\n    private static int i;\\n    \\n    public int calculate(String s) {\\n        i = 0;\\n        return calculateAfter(s);\\n    }\\n    \\n    private int calculateAfter(String s) {\\n        // Base case.\\n        if (i == s.length()) \\n            return 0;\\n        \\n        int curSign = 1, curNum = 0, result = 0;\\n        while (i < s.length()) {\\n            char ch = s.charAt(i);\\n            switch(ch) {\\n                case \\' \\':\\n                    break;\\n                case \\'+\\':\\n                    curSign = 1;\\n                    break;\\n                case \\'-\\':\\n                    curSign = -1;\\n                    break;\\n                case \\'(\\':\\n                    i++;\\n                    result += curSign * calculateAfter(s);\\n                    curSign = 1;\\n                    break;\\n                case \\')\\':\\n                    // Base case.\\n                    return result;\\n                default:\\n                    int num = ch - \\'0\\';\\n                    while (i + 1 < s.length() && Character.isDigit(s.charAt(i + 1))) {\\n                        num = num * 10 + s.charAt(++i) - \\'0\\';\\n                    }\\n                    curNum = num;\\n                    result += curSign * curNum;\\n            } \\n            i++;\\n        }\\n        \\n        return result;\\n    }\\n```\n```\\n    def calculate(s: String): Int = {\\n        var i = 0\\n        \\n        def evaluate(s: String): Int = {\\n            var curSign = 1 // 1 if plus operator, -1 if minus operator.\\n            var curResult = 0 \\n            \\n            while (i < s.length()) {\\n                s(i) match {\\n                    case \\'+\\' => curSign = 1\\n                    case \\'-\\' => curSign = -1\\n                    case \\' \\' => \\n                    case \\'(\\' => {\\n                        i += 1\\n                        curResult += curSign * evaluate(s)\\n                        curSign = 1\\n                    }\\n                    case \\')\\' => return curResult\\n                    case _ => { // If s(i) is a digit.\\n                        // Get the current whole number.\\n                        var curNum = s(i) - \\'0\\' \\n                        while (i + 1 < s.length() && Character.isDigit(s(i + 1))) {\\n                            curNum = curNum * 10 +  s(i + 1) - \\'0\\'\\n                            i += 1\\n                        }\\n                        \\n                        curResult += curSign * curNum \\n                        curSign = 1\\n                    }\\n                }\\n                \\n                i += 1\\n            }\\n            \\n            return curResult\\n        }\\n        \\n        evaluate(s)\\n    }\\n```\n```\\n    def calculate(self, s):\\n  \\n      def evaluation(s):\\n        nonlocal i\\n        curSign, curResult = 1, 0\\n        \\n        while i < len(s):\\n          if s[i] == \\' \\': \\n            i += 1\\n            continue\\n          elif s[i] == \\'+\\':\\n            curSign = 1\\n          elif s[i] == \\'-\\':\\n            curSign = -1\\n          elif s[i] == \\'(\\':\\n            i += 1\\n            curResult += curSign * evaluation(s)\\n            curSign = 1\\n          elif s[i] == \\')\\':\\n            return curResult\\n          else:  # s[i] is digit.\\n            curNum = int(s[i])\\n            while i + 1 < len(s) and s[i + 1].isdigit():\\n              curNum = curNum * 10 + int(s[i + 1])\\n              i += 1\\n            curResult += curNum * curSign\\n            curSign = 1\\n          i += 1\\n          \\n        return curResult\\n      \\n      i = 0\\n      return evaluation(s)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 62346,
                "title": "c-13ms-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<int>stk, op;\\n        int res = 0, sign = 1;\\n        for(int i = 0; i < s.size(); i++){\\n            char c = s[i];\\n            if(isdigit(c)){\\n                int num = c - '0';\\n                while(i + 1 < s.size() && isdigit(s[i + 1])){\\n                    num = num * 10 + s[i + 1] - '0';\\n                    i++;\\n                }\\n                res += num * sign;\\n            }\\n            else if(c == '+') sign = 1;\\n            else if(c == '-') sign = -1;\\n            else if(c == '('){\\n                stk.push(res);\\n                op.push(sign);\\n                res = 0;\\n                sign = 1;\\n            }\\n            else if(c == ')'){\\n                res = res * op.top();\\n                op.pop();\\n                res += stk.top();\\n                stk.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<int>stk, op;\\n        int res = 0, sign = 1;\\n        for(int i = 0; i < s.size(); i++){\\n            char c = s[i];\\n            if(isdigit(c)){\\n                int num = c - '0';\\n                while(i + 1 < s.size() && isdigit(s[i + 1])){\\n                    num = num * 10 + s[i + 1] - '0';\\n                    i++;\\n                }\\n                res += num * sign;\\n            }\\n            else if(c == '+') sign = 1;\\n            else if(c == '-') sign = -1;\\n            else if(c == '('){\\n                stk.push(res);\\n                op.push(sign);\\n                res = 0;\\n                sign = 1;\\n            }\\n            else if(c == ')'){\\n                res = res * op.top();\\n                op.pop();\\n                res += stk.top();\\n                stk.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62472,
                "title": "detailed-explained-easy-java-general-solution-using-reverse-polish-notation",
                "content": "Basic idea: parse the given regular expression by an order of reverse polish notation and calculate while parsing.\\n\\nSteps:\\n\\n 1. Use two stack to store operators and values(name: \"operator\" and \"result\").\\n 2. Use one map to define the priority of operators.\\n 3. Use \"#\" as an ending indicator, push \"#\" to operator and add it to the given string in the end.\\n 4. Scan the given string character by charcter.\\n\\n    4.1 If the current character is a digit, continue to retrive the whole\\n    number and push it to \"result\" stack. \\n\\n    4.2 if the current character is an operator(call it holding operator here), compare the holding operator with the top operator in \"operator\" stack by priority defined in the map. Keep popping the operator from stack until the holding operator's priority is less than the current one's. Send the popped operators to result stack to activiate calculation by their popped order. Then push the holding operator to \"operator\" stack.\\n \\n    4.3 If the current character is '(', push it to \"operator\" stack;\\n        \\n       4.4 if the current character is ')', keep popping the operators in \"operator\" stack until ')' occurs, leave both parenthesis and\\n    send all popped operators to result stack to activate calculation by\\n    their popped order.\\n    \\n       4.5 Repeat 4.1~4.4 until a \"#\" is scanned, then pop out all operators in \"operator\" stack and send them to calculation until # occurred.\\n\\n 5. Return what left in \"result\" stack. And this solution can be used not only for + and -, but also for almost all operators included, as long as priority order is defined.\\n\\n \\n\\n\\n\\n\\n\\npublic class Solution {\\n\\n    public int calculate(String s) {\\n\\n        Stack<Character> operator = new Stack<Character>();\\n\\t\\tStack<Integer> result = new Stack<Integer>();\\n\\n\\t\\tHashMap<Character, Integer> priority = new HashMap<Character, Integer>() {\\n\\t\\t\\t{\\n\\t\\t\\t\\tput('#', 0);\\n\\t\\t\\t\\tput('+', 1);\\n\\t\\t\\t\\tput('-', 1);\\n\\t\\t\\t\\tput('*', 2);\\n\\t\\t\\t\\tput('/', 2);\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\ts = s.replace(\" \", \"\");\\n\\n\\t\\ts = s + '#';\\n\\t\\toperator.push('#');\\n\\n\\t\\tint i = 0;\\n\\n\\t\\twhile (i < s.length()) {\\n\\t\\t\\t\\n\\t\\t\\tif (Character.isDigit(s.charAt(i))) {\\n\\t\\t\\t\\tint j = i + 1;\\n\\t\\t\\t\\twhile (j < s.length()) {\\n\\t\\t\\t\\t\\tif (!Character.isDigit(s.charAt(j)))\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tresult.push(Integer.parseInt(s.substring(i, j)));\\n\\t\\t\\t\\ti = j;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tswitch (s.charAt(i)) {\\n\\t\\t\\t\\tcase ('('): {\\n\\t\\t\\t\\t\\toperator.push('(');\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcase (')'): {\\n\\n\\t\\t\\t\\t\\tchar temp = operator.pop();\\n\\t\\t\\t\\t\\twhile (temp != '(') {\\n\\t\\t\\t\\t\\t\\tcalculate(temp, result);\\n\\t\\t\\t\\t\\t\\ttemp = operator.pop();\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcase ('#'): {\\n\\n\\t\\t\\t\\t\\twhile (!operator.isEmpty())\\n\\t\\t\\t\\t\\t\\tcalculate(operator.pop(), result);\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdefault: {\\n\\t\\t\\t\\t\\tchar current = operator.pop();\\n\\t\\t\\t\\t\\tchar holding = s.charAt(i);\\n\\t\\t\\t\\t\\twhile (current !='(' && priority.get(holding) <= priority.get(current)) {\\n\\t\\t\\t\\t\\t\\tcalculate(current, result);\\n\\t\\t\\t\\t\\t\\tcurrent = operator.pop();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\toperator.push(current);\\n\\t\\t\\t\\t\\toperator.push(holding);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result.pop();\\n\\t}\\n\\n\\tprivate void calculate(char operator, Stack<Integer> s) {\\n\\t\\t// TODO Auto-generated method stub\\n\\t\\tint temp;\\n\\t\\tswitch (operator) {\\n\\t\\tcase '+': {\\n\\t\\t\\ttemp = s.pop();\\n\\t\\t\\ts.push(s.pop() + temp);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tcase '-': {\\n\\t\\t\\ttemp = s.pop();\\n\\t\\t\\ts.push(s.pop() - temp);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tcase '*': {\\n\\t\\t\\ttemp = s.pop();\\n\\t\\t\\ts.push(s.pop() * temp);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tcase '/': {\\n\\t\\t\\ttemp = s.pop();\\n\\t\\t\\ts.push(s.pop() / temp);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tdefault:\\n\\t\\t\\tbreak;\\n\\t\\t}\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int calculate(String s) {\\n\\n        Stack<Character> operator = new Stack<Character>();\\n\\t\\tStack<Integer> result = new Stack<Integer>();\\n\\n\\t\\tHashMap<Character, Integer> priority = new HashMap<Character, Integer>() {\\n\\t\\t\\t{\\n\\t\\t\\t\\tput('#', 0);\\n\\t\\t\\t\\tput('+', 1);\\n\\t\\t\\t\\tput('-', 1);\\n\\t\\t\\t\\tput('*', 2);\\n\\t\\t\\t\\tput('/', 2);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4011331,
                "title": "beats-75-easy-java-solution-using-stack-with-detailed-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a stack st to store intermediate results during the evaluation.\\n2. Initialize variables ans (to store the final result), num (to accumulate the current number being processed), and sign (to track the current sign, which can be either 1 or -1).\\n3. Iterate through each character of the input string s using a for loop.\\n4. For each character c in the input string:\\n- If c is a digit, accumulate it into the num variable. This is done to handle multi-digit numbers.\\n- If c is a + sign, it indicates an addition operation. Add sign * num to the ans, reset num to 0, and set sign to 1.\\n- If c is a - sign, it indicates a subtraction operation. Add sign * num to the ans, reset num to 0, and set sign to -1.\\n- If c is an open parenthesis (, it indicates the start of a subexpression. Push the current ans and sign onto the stack to save the context. Reset ans to 0 and set sign to 1 for the new subexpression.\\n- If c is a closing parenthesis ), it indicates the end of a subexpression. First, add sign * num to ans to calculate the result within the parentheses. Then, multiply the result by the last saved sign value from the stack and add it to the last saved result value from the stack.\\n5. After processing all characters in the input string, if num is not zero, add sign * num to ans to handle any remaining number.\\n6. Finally, return the value of ans, which represents the result of evaluating the mathematical expression.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int calculate(String s) {\\n        Stack<Integer> st=new Stack();\\n        int ans=0,num=0,sign=1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char c=s.charAt(i);\\n            if(Character.isDigit(c))\\n                num=num*10+(int)(c-\\'0\\');\\n            else if(c==\\'+\\'){\\n                ans+=sign*num;\\n                num=0;\\n                sign=1;\\n            }\\n            else if(c==\\'-\\'){\\n                ans+=sign*num;\\n                num=0;\\n                sign=-1;              \\n            }\\n            else if(c==\\'(\\'){\\n                st.push(ans);\\n                st.push(sign);\\n                sign=1;\\n                ans=0;\\n            }\\n            else if(c==\\')\\'){\\n                ans+=sign*num;\\n                num=0;\\n                ans*=st.pop();\\n                ans+=st.pop();\\n            }\\n        }\\n        if(num!=0)\\n            ans+=sign*num;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        Stack<Integer> st=new Stack();\\n        int ans=0,num=0,sign=1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char c=s.charAt(i);\\n            if(Character.isDigit(c))\\n                num=num*10+(int)(c-\\'0\\');\\n            else if(c==\\'+\\'){\\n                ans+=sign*num;\\n                num=0;\\n                sign=1;\\n            }\\n            else if(c==\\'-\\'){\\n                ans+=sign*num;\\n                num=0;\\n                sign=-1;              \\n            }\\n            else if(c==\\'(\\'){\\n                st.push(ans);\\n                st.push(sign);\\n                sign=1;\\n                ans=0;\\n            }\\n            else if(c==\\')\\'){\\n                ans+=sign*num;\\n                num=0;\\n                ans*=st.pop();\\n                ans+=st.pop();\\n            }\\n        }\\n        if(num!=0)\\n            ans+=sign*num;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832688,
                "title": "c-recuesion-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int idx = 0;\\n        return helper(s,idx);      \\n    }\\n\\n    int helper(string s, int& idx) {\\n        int res = 0;\\n        int sign = 1; // \\'+\\'=1, \\'-\\'=-1\\n        int number = 0;\\n        \\n        for(;idx<s.size(); idx++){\\n            char x=s[idx]; //current char\\n\\n            if(x==\\' \\') continue;\\n            else if(x==\\'+\\'||x==\\'-\\') {\\n                res+= sign*(number);\\n                number=0;\\n                sign = (x==\\'+\\')?1:-1;\\n            }\\n            else if(x==\\'(\\') res += sign*helper(s, ++idx);\\n            else if(x==\\')\\') break;\\n            else number = number*10+(x-\\'0\\');\\n        }  \\n        return res+sign*(number);      \\n    }\\n};\\n```\\nupvote if it helps, thanks!",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int idx = 0;\\n        return helper(s,idx);      \\n    }\\n\\n    int helper(string s, int& idx) {\\n        int res = 0;\\n        int sign = 1; // \\'+\\'=1, \\'-\\'=-1\\n        int number = 0;\\n        \\n        for(;idx<s.size(); idx++){\\n            char x=s[idx]; //current char\\n\\n            if(x==\\' \\') continue;\\n            else if(x==\\'+\\'||x==\\'-\\') {\\n                res+= sign*(number);\\n                number=0;\\n                sign = (x==\\'+\\')?1:-1;\\n            }\\n            else if(x==\\'(\\') res += sign*helper(s, ++idx);\\n            else if(x==\\')\\') break;\\n            else number = number*10+(x-\\'0\\');\\n        }  \\n        return res+sign*(number);      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832375,
                "title": "easy-stack-solution-in-c-java-javascript",
                "content": "# C++\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int res = 0, sum = 0, sign = 1;\\n        stack<int> myStack({1});\\n        for(auto ch: s){\\n            if(isdigit(ch)) sum = sum * 10 + (ch - \\'0\\');\\n            else{\\n                res += sum * sign * myStack.top();\\n                sum = 0;\\n                if(ch == \\'-\\') sign = -1;\\n                else if(ch == \\'+\\') sign = 1;\\n                else if(ch == \\'(\\') myStack.push(myStack.top() * sign), sign = 1;\\n                else if(ch == \\')\\') myStack.pop();\\n            }\\n        }\\n        return res += (sum * sign);\\n    }\\n};\\n```\\n# JAVA\\n```\\nclass Solution {\\n    public int calculate(String s) {\\n        int res = 0, sum = 0, sign = 1;\\n        Stack<Integer> myStack = new Stack<>();\\n        myStack.push(1);\\n        for(char ch: s.toCharArray()){\\n            if(Character.isDigit(ch)) sum = sum * 10 + (ch - \\'0\\');\\n            else{\\n                res += sum * sign * myStack.peek();\\n                sum = 0;\\n                if(ch == \\'-\\') sign = -1;\\n                else if(ch == \\'+\\') sign = 1;\\n                else if(ch == \\'(\\'){\\n                    myStack.push(myStack.peek() * sign);\\n                    sign = 1;\\n                } else if(ch == \\')\\') myStack.pop();\\n            }\\n        }\\n        return res += sign * sum;\\n    }\\n}\\n```\\n# JAVASCRIPT\\n```\\nvar calculate = function(s) {\\n    let res = 0, sum = 0, sign = 1;\\n    let myStack = [];\\n    myStack.push(1);\\n    const isDigit = (ch) => {\\n        return ch >= \\'0\\' && ch <= \\'9\\';\\n    }\\n    for(let ch of s){\\n        if(isDigit(ch)) sum = sum * 10 + (ch - \\'0\\');\\n        else{\\n            res += sum * sign * myStack[myStack.length - 1];\\n            sum = 0;\\n            if(ch === \\'-\\') sign = -1;\\n            else if(ch === \\'+\\') sign = 1;\\n            else if(ch === \\'(\\') {myStack.push(myStack[myStack.length - 1] * sign); sign = 1;}\\n            else if(ch === \\')\\') myStack.pop(); \\n        }\\n    }\\n    return res += (sign * sum);\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int res = 0, sum = 0, sign = 1;\\n        stack<int> myStack({1});\\n        for(auto ch: s){\\n            if(isdigit(ch)) sum = sum * 10 + (ch - \\'0\\');\\n            else{\\n                res += sum * sign * myStack.top();\\n                sum = 0;\\n                if(ch == \\'-\\') sign = -1;\\n                else if(ch == \\'+\\') sign = 1;\\n                else if(ch == \\'(\\') myStack.push(myStack.top() * sign), sign = 1;\\n                else if(ch == \\')\\') myStack.pop();\\n            }\\n        }\\n        return res += (sum * sign);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int calculate(String s) {\\n        int res = 0, sum = 0, sign = 1;\\n        Stack<Integer> myStack = new Stack<>();\\n        myStack.push(1);\\n        for(char ch: s.toCharArray()){\\n            if(Character.isDigit(ch)) sum = sum * 10 + (ch - \\'0\\');\\n            else{\\n                res += sum * sign * myStack.peek();\\n                sum = 0;\\n                if(ch == \\'-\\') sign = -1;\\n                else if(ch == \\'+\\') sign = 1;\\n                else if(ch == \\'(\\'){\\n                    myStack.push(myStack.peek() * sign);\\n                    sign = 1;\\n                } else if(ch == \\')\\') myStack.pop();\\n            }\\n        }\\n        return res += sign * sum;\\n    }\\n}\\n```\n```\\nvar calculate = function(s) {\\n    let res = 0, sum = 0, sign = 1;\\n    let myStack = [];\\n    myStack.push(1);\\n    const isDigit = (ch) => {\\n        return ch >= \\'0\\' && ch <= \\'9\\';\\n    }\\n    for(let ch of s){\\n        if(isDigit(ch)) sum = sum * 10 + (ch - \\'0\\');\\n        else{\\n            res += sum * sign * myStack[myStack.length - 1];\\n            sum = 0;\\n            if(ch === \\'-\\') sign = -1;\\n            else if(ch === \\'+\\') sign = 1;\\n            else if(ch === \\'(\\') {myStack.push(myStack[myStack.length - 1] * sign); sign = 1;}\\n            else if(ch === \\')\\') myStack.pop(); \\n        }\\n    }\\n    return res += (sign * sum);\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233404,
                "title": "simple-c-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        //we basically calculate everything at a time and update it in result varibale\\n        int result=0;\\n        int sign=1; //1 rep +ve -1 rep -ve\\n        int j=0;\\n        int len=s.length();\\n        stack<int> stk;\\n        while(j<len){ \\n            if(s[j]==\\'+\\')\\n            {\\n                sign=1;\\n            }\\n            else if(s[j]==\\'-\\')\\n            {\\n                //we got a negative value\\n                sign=-1;\\n            }\\n            else if(isdigit(s[j]))\\n            {\\n                //get the number \\n                int num=s[j]-\\'0\\';\\n                while(j+1<len && isdigit(s[j+1])){\\n                    num=num*10+(s[j+1]-\\'0\\');\\n                    j++;\\n                }\\n                //now add it to the result along with sign\\n                result+=num*sign;\\n            }\\n            else if(s[j]==\\'(\\')\\n            {\\n                //we push the current result and current sign into the stack\\n                stk.push(result);\\n                stk.push(sign);\\n                result=0;\\n                sign=1;\\n            }\\n            else if(s[j]==\\')\\')\\n            {\\n                //get the last result and the sign from the stack\\n                int xsign=stk.top();\\n                stk.pop();\\n                int xresult=stk.top();\\n                stk.pop();\\n                //add the curr result in parenthesis to prev result and update the entire result\\n                result=result*xsign + xresult;\\n                //xsign will be the sign before the begin of parenthesis\\n            }\\n            j++;\\n        }\\n        return result;\\n    }\\n};\\n```\\n**Please upvote if this helps :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        //we basically calculate everything at a time and update it in result varibale\\n        int result=0;\\n        int sign=1; //1 rep +ve -1 rep -ve\\n        int j=0;\\n        int len=s.length();\\n        stack<int> stk;\\n        while(j<len){ \\n            if(s[j]==\\'+\\')\\n            {\\n                sign=1;\\n            }\\n            else if(s[j]==\\'-\\')\\n            {\\n                //we got a negative value\\n                sign=-1;\\n            }\\n            else if(isdigit(s[j]))\\n            {\\n                //get the number \\n                int num=s[j]-\\'0\\';\\n                while(j+1<len && isdigit(s[j+1])){\\n                    num=num*10+(s[j+1]-\\'0\\');\\n                    j++;\\n                }\\n                //now add it to the result along with sign\\n                result+=num*sign;\\n            }\\n            else if(s[j]==\\'(\\')\\n            {\\n                //we push the current result and current sign into the stack\\n                stk.push(result);\\n                stk.push(sign);\\n                result=0;\\n                sign=1;\\n            }\\n            else if(s[j]==\\')\\')\\n            {\\n                //get the last result and the sign from the stack\\n                int xsign=stk.top();\\n                stk.pop();\\n                int xresult=stk.top();\\n                stk.pop();\\n                //add the curr result in parenthesis to prev result and update the entire result\\n                result=result*xsign + xresult;\\n                //xsign will be the sign before the begin of parenthesis\\n            }\\n            j++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227155,
                "title": "javascript-simple-solution-with-explanation",
                "content": "Runtime: 132 ms, faster than 25.48% of JavaScript online submissions for Basic Calculator.\\nMemory Usage: 48 MB, less than 23.77% of JavaScript online submissions for Basic Calculator.\\n\\nhow this code works :\\nUntil \")\" of stringS appears, always push s[i] into stack, when  \")\" appears, pop stack into temp until the last index of stack is \"(\"\\nand reverse temp and then start counting.\\nsome of cases like \"-1+2\" or \"5+(+1+2)\", will additional push zero into stack, like \"**0**-1+2\", \"5+(**0**+1+2)\"\\n\\n```\\nvar calculate = function(s) {\\n    s = \"(\"+s+\")\"\\n    let stack = [];\\n    let temp = [];\\n    for(let i = 0; i < s.length; i++){\\n        if(s[i]===\" \") continue;\\n        if(s[i]===\")\"){     \\n            while(stack[stack.length-1]!==\"(\") temp.push(stack.pop());                   \\n            stack.pop();\\n            stack.push(count(temp));\\n            continue;\\n        }\\n         if(isNum(stack[stack.length-1])&&isNum(s[i])){\\n            stack[stack.length-1]+=s[i];   \\n            continue;             \\n        } \\n        if(s[i]===\"-\"||s[i]===\"+\"){\\n             if(stack.length===0||stack[stack.length-1]===\"(\") stack.push(\"0\");    \\n        }\\n        stack.push(s[i]);\\n    }\\n    return stack[0];\\n};\\n    \\nfunction count(temp) {\\n   temp = temp.reverse();\\n      while(temp.length!==1){\\n          if(temp[1]===\"+\") temp[0]=(+temp[0])+(+temp[2]);\\n          if(temp[1]===\"-\") temp[0]=(+temp[0])-(+temp[2]);\\n          temp.splice(1,2);\\n      }\\n    return temp.pop();\\n}\\n    \\nfunction isNum(str) {\\n  return /[0-9]+/.test(str);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar calculate = function(s) {\\n    s = \"(\"+s+\")\"\\n    let stack = [];\\n    let temp = [];\\n    for(let i = 0; i < s.length; i++){\\n        if(s[i]===\" \") continue;\\n        if(s[i]===\")\"){     \\n            while(stack[stack.length-1]!==\"(\") temp.push(stack.pop());                   \\n            stack.pop();\\n            stack.push(count(temp));\\n            continue;\\n        }\\n         if(isNum(stack[stack.length-1])&&isNum(s[i])){\\n            stack[stack.length-1]+=s[i];   \\n            continue;             \\n        } \\n        if(s[i]===\"-\"||s[i]===\"+\"){\\n             if(stack.length===0||stack[stack.length-1]===\"(\") stack.push(\"0\");    \\n        }\\n        stack.push(s[i]);\\n    }\\n    return stack[0];\\n};\\n    \\nfunction count(temp) {\\n   temp = temp.reverse();\\n      while(temp.length!==1){\\n          if(temp[1]===\"+\") temp[0]=(+temp[0])+(+temp[2]);\\n          if(temp[1]===\"-\") temp[0]=(+temp[0])-(+temp[2]);\\n          temp.splice(1,2);\\n      }\\n    return temp.pop();\\n}\\n    \\nfunction isNum(str) {\\n  return /[0-9]+/.test(str);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 564036,
                "title": "c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n      int res = 0;\\n      int num = 0, sign = 1; // 1 for positiove and - 1 for negative\\n      stack<int> stk;\\n      for(int i = 0; i < s.size(); ++i) {\\n         while(i < s.size() && isdigit(s[i])) {\\n           num = num * 10 + (s[i] - \\'0\\');\\n           ++i;\\n         }\\n         res += (num * sign);\\n         num = 0;\\n         if(s[i] == \\'+\\') {\\n            sign = 1;\\n         }else if( s[i] == \\'-\\') {\\n            sign = - 1;\\n         }else if(s[i] == \\'(\\') {\\n            stk.push(res);\\n            res = 0;\\n            stk.push(sign);\\n            sign = 1;\\n         }else if(s[i] == \\')\\') {\\n            res *= stk.top();\\n            stk.pop();\\n            res += stk.top();\\n            stk.pop();\\n        }\\n      }\\n      return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n      int res = 0;\\n      int num = 0, sign = 1; // 1 for positiove and - 1 for negative\\n      stack<int> stk;\\n      for(int i = 0; i < s.size(); ++i) {\\n         while(i < s.size() && isdigit(s[i])) {\\n           num = num * 10 + (s[i] - \\'0\\');\\n           ++i;\\n         }\\n         res += (num * sign);\\n         num = 0;\\n         if(s[i] == \\'+\\') {\\n            sign = 1;\\n         }else if( s[i] == \\'-\\') {\\n            sign = - 1;\\n         }else if(s[i] == \\'(\\') {\\n            stk.push(res);\\n            res = 0;\\n            stk.push(sign);\\n            sign = 1;\\n         }else if(s[i] == \\')\\') {\\n            res *= stk.top();\\n            stk.pop();\\n            res += stk.top();\\n            stk.pop();\\n        }\\n      }\\n      return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62351,
                "title": "ultimate-solutions-in-java-for-all-follow-ups",
                "content": "Hi guys, here I list solutions for 6 different versions of the problem, some of them are inspired by code from other people.\\nSorry I don't have time to write explanation or comment but I believe all of them are not too hard to understand. I may add some explanations in the future if I have some time.\\nPlease leave your comments about these solutions and give me an up-vote if they help. \\nThank you guys! Fighting!\\n\\nVersion 1: Support [ + - ]\\n-------\\n(not tested)\\n```\\nclass Solution {\\n    \\n    public int calculate(String s) {\\n        int len = s.length(), sign = 1, res = 0, num = 0;\\n        for (int i = 0; i < len; i++) {\\n            char c = s.charAt(i);\\n            if (c == ' ') continue;\\n            if (Character.isDigit(c)) {\\n                num = num * 10 + c - '0';\\n                if (i == len - 1 || !Character.isDigit(s.charAt(i + 1))) {\\n                    res += sign * num;\\n                    num = 0;\\n                }\\n            } else { // + or -\\n                if (c == '+') sign = 1;\\n                if (c == '-') sign = -1;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n}\\n```\\n\\n\\nVersion 2: Support [ + - ( ) ] (this problem)\\n-------\\n```\\nclass Solution {\\n    \\n    public int calculate(String s) {\\n        int len = s.length(), sign = 1, res = 0, num = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 0; i < len; i++) {\\n            char c = s.charAt(i);\\n            if (c == ' ') continue; //\\u53ea\\u8981\\u6570\\u5b57\\u4e0d\\u4f1a\\u88ab\\u62c6\\u5f00\\uff0c\\u7528\\u8fd9\\u4e2a\\u5c31\\u6ca1\\u95ee\\u9898\\u3002\\n            if (Character.isDigit(c)) {\\n                num = num * 10 + c - '0';\\n                if (i == len - 1 || !Character.isDigit(s.charAt(i + 1))) {\\n                    res += sign * num;\\n                    num = 0;\\n                }\\n            } else { // + - ( )\\n                if (c == '+') {\\n                    sign = 1;\\n                }\\n                if (c == '-') {\\n                    sign = -1;\\n                }\\n                if (c == '(') {\\n                    stack.push(res);\\n                    stack.push(sign);\\n                    res = 0;\\n                    sign = 1;\\n                }\\n                if (c == ')') {\\n                    res = res * stack.pop() + stack.pop();\\n                }               \\n            }\\n        }\\n        return res;\\n    }\\n    \\n}\\n```\\n\\nVersion 3: Support [ + - * / ]\\n---------\\n```\\nclass Solution {\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        int len = s.length();\\n        int num = 0;\\n        char sign = '+';\\n        int curr = 0, res = 0; //important, use curr to store value of last segment.\\n        for (int i = 0; i < len; i++) {\\n            if (s.charAt(i) == ' ') continue;\\n            if (!Character.isDigit(s.charAt(i))) {\\n                num = 0;\\n                sign = s.charAt(i);\\n                if (sign == '+' || sign == '-') {\\n                    res += curr;\\n                    curr = 0; // not necessary\\n                }\\n            } else {\\n                num = num * 10 + s.charAt(i) - '0';\\n                if (i == len - 1 || !Character.isDigit(s.charAt(i + 1))) {\\n                    if (sign == '+') curr = num;\\n                    if (sign == '-') curr = -num;\\n                    if (sign == '*') curr *= num;\\n                    if (sign == '/') curr /= num;\\n                }\\n            }         \\n        }\\n        res += curr; // add last segment\\n        return res;\\n    }\\n}\\n\\n```\\n\\nVersion 4: Support [ + - * / ( ) ]\\n--------\\nShould be easily derived from Version 6, just remove anything related to ^.\\n\\n\\nVersion 5: Support [ + - * / ^ ]\\n-----------------\\n```\\nclass Solution {\\n    \\n    public int calculate(String s) {\\n        // remove spaces //\\u8fd9\\u90e8\\u5206\\u4e5f\\u53ef\\u4ee5\\u653e\\u5728\\u4e0b\\u9762\\u5224\\u65ad\\uff0c\\u4e00\\u53e5\\u641e\\u5b9a\\uff0c\\u662f\\u7a7a\\u683c\\u7684\\u65f6\\u5019\\u8df3\\u8fc7\\n        String[] strs = s.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < strs.length; i++) {\\n            sb.append(strs[i]);\\n        }\\n        s = sb.toString();\\n        \\n        // init\\n        if (s == null || sb.length() == 0) return 0;\\n        int num = 0;\\n        Stack<Integer> numStack = new Stack<>();\\n        Stack<Character> opStack = new Stack<>();\\n        Map<Character, Integer> map = new HashMap<>();\\n        map.put('+', 1); map.put('-', 1);\\n        map.put('*', 2); map.put('/', 2);\\n        map.put('^', 3);\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (Character.isDigit(c)) {\\n                num = num * 10 + c - '0';\\n                if (i == s.length() - 1 || !Character.isDigit(s.charAt(i + 1))) {\\n                    numStack.push(num);\\n                    num = 0;                  \\n                }\\n            } else { // op: + - * / ^\\n                if (opStack.empty() || map.get(c) > map.get(opStack.peek())) {\\n                    opStack.push(c);\\n                } else {\\n                    while (!opStack.empty() && map.get(c) <= map.get(opStack.peek())) {\\n                        helper(numStack, opStack);\\n                    }\\n                    opStack.push(c);\\n                }                     \\n            }           \\n        }\\n        \\n        while (!opStack.empty()) {\\n            helper(numStack, opStack);\\n        }\\n        return numStack.pop();\\n    }\\n    \\n    private void helper(Stack<Integer> numStack, Stack<Character> opStack) {\\n        int b = numStack.pop();\\n        int a = numStack.pop();\\n        char op = opStack.pop();\\n        if (op == '+') numStack.push(a + b);\\n        if (op == '-') numStack.push(a - b);\\n        if (op == '*') numStack.push(a * b);\\n        if (op == '/') numStack.push(a / b);\\n        if (op == '^') numStack.push((int)Math.pow(a, b));\\n    }\\n\\n}\\n```\\n\\nVersion 6: Support [ + - * / ^ ( ) ]\\n---------------\\n```\\nclass Solution {\\n    \\n    public int calculate(String s) {\\n        // remove spaces //\\u8fd9\\u90e8\\u5206\\u4e5f\\u53ef\\u4ee5\\u653e\\u5728\\u4e0b\\u9762\\u5224\\u65ad\\uff0c\\u4e00\\u53e5\\u641e\\u5b9a\\uff0c\\u662f\\u7a7a\\u683c\\u7684\\u65f6\\u5019\\u8df3\\u8fc7\\n        String[] strs = s.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < strs.length; i++) {\\n            sb.append(strs[i]);\\n        }\\n        s = sb.toString();\\n        \\n        // init\\n        if (s == null || sb.length() == 0) return 0;\\n        int num = 0;\\n        Stack<Integer> numStack = new Stack<>();\\n        Stack<Character> opStack = new Stack<>();\\n        Map<Character, Integer> map = new HashMap<>();\\n        map.put('+', 1); map.put('-', 1);\\n        map.put('*', 2); map.put('/', 2);\\n        map.put('^', 3);\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (Character.isDigit(c)) {\\n                num = num * 10 + c - '0';\\n                if (i == s.length() - 1 || !Character.isDigit(s.charAt(i + 1))) {\\n                    numStack.push(num);\\n                    num = 0;                  \\n                }\\n            } else { // op or ()\\n                if (c == '(') {\\n                    opStack.push(c);\\n                }\\n                if (c == ')') {\\n                    while (!opStack.empty() && opStack.peek() != '(') {\\n                        helper(numStack, opStack);\\n                    }\\n                    opStack.pop(); // pop the '('\\n                }\\n                if (map.containsKey(c)) { // + - * / ^\\n                    if (opStack.empty() || opStack.peek() == '(' || map.get(c) > map.get(opStack.peek())) {\\n                        opStack.push(c);\\n                    } else {\\n                        while (!opStack.empty() && opStack.peek() != '(' && map.get(c) <= map.get(opStack.peek())) {\\n                            helper(numStack, opStack);\\n                        }\\n                        opStack.push(c);\\n                    }                 \\n                }              \\n            }           \\n        }\\n        \\n        while (!opStack.empty()) {\\n            helper(numStack, opStack);\\n        }\\n        return numStack.pop();\\n    }\\n    \\n    private void helper(Stack<Integer> numStack, Stack<Character> opStack) {\\n        int b = numStack.pop();\\n        int a = numStack.pop();\\n        char op = opStack.pop();\\n        if (op == '+') numStack.push(a + b);\\n        if (op == '-') numStack.push(a - b);\\n        if (op == '*') numStack.push(a * b);\\n        if (op == '/') numStack.push(a / b);\\n        if (op == '^') numStack.push((int)Math.pow(a, b));\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int calculate(String s) {\\n        int len = s.length(), sign = 1, res = 0, num = 0;\\n        for (int i = 0; i < len; i++) {\\n            char c = s.charAt(i);\\n            if (c == ' ') continue;\\n            if (Character.isDigit(c)) {\\n                num = num * 10 + c - '0';\\n                if (i == len - 1 || !Character.isDigit(s.charAt(i + 1))) {\\n                    res += sign * num;\\n                    num = 0;\\n                }\\n            } else { // + or -\\n                if (c == '+') sign = 1;\\n                if (c == '-') sign = -1;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    \\n    public int calculate(String s) {\\n        int len = s.length(), sign = 1, res = 0, num = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 0; i < len; i++) {\\n            char c = s.charAt(i);\\n            if (c == ' ') continue; //\\u53ea\\u8981\\u6570\\u5b57\\u4e0d\\u4f1a\\u88ab\\u62c6\\u5f00\\uff0c\\u7528\\u8fd9\\u4e2a\\u5c31\\u6ca1\\u95ee\\u9898\\u3002\\n            if (Character.isDigit(c)) {\\n                num = num * 10 + c - '0';\\n                if (i == len - 1 || !Character.isDigit(s.charAt(i + 1))) {\\n                    res += sign * num;\\n                    num = 0;\\n                }\\n            } else { // + - ( )\\n                if (c == '+') {\\n                    sign = 1;\\n                }\\n                if (c == '-') {\\n                    sign = -1;\\n                }\\n                if (c == '(') {\\n                    stack.push(res);\\n                    stack.push(sign);\\n                    res = 0;\\n                    sign = 1;\\n                }\\n                if (c == ')') {\\n                    res = res * stack.pop() + stack.pop();\\n                }               \\n            }\\n        }\\n        return res;\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        int len = s.length();\\n        int num = 0;\\n        char sign = '+';\\n        int curr = 0, res = 0; //important, use curr to store value of last segment.\\n        for (int i = 0; i < len; i++) {\\n            if (s.charAt(i) == ' ') continue;\\n            if (!Character.isDigit(s.charAt(i))) {\\n                num = 0;\\n                sign = s.charAt(i);\\n                if (sign == '+' || sign == '-') {\\n                    res += curr;\\n                    curr = 0; // not necessary\\n                }\\n            } else {\\n                num = num * 10 + s.charAt(i) - '0';\\n                if (i == len - 1 || !Character.isDigit(s.charAt(i + 1))) {\\n                    if (sign == '+') curr = num;\\n                    if (sign == '-') curr = -num;\\n                    if (sign == '*') curr *= num;\\n                    if (sign == '/') curr /= num;\\n                }\\n            }         \\n        }\\n        res += curr; // add last segment\\n        return res;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    \\n    public int calculate(String s) {\\n        // remove spaces //\\u8fd9\\u90e8\\u5206\\u4e5f\\u53ef\\u4ee5\\u653e\\u5728\\u4e0b\\u9762\\u5224\\u65ad\\uff0c\\u4e00\\u53e5\\u641e\\u5b9a\\uff0c\\u662f\\u7a7a\\u683c\\u7684\\u65f6\\u5019\\u8df3\\u8fc7\\n        String[] strs = s.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < strs.length; i++) {\\n            sb.append(strs[i]);\\n        }\\n        s = sb.toString();\\n        \\n        // init\\n        if (s == null || sb.length() == 0) return 0;\\n        int num = 0;\\n        Stack<Integer> numStack = new Stack<>();\\n        Stack<Character> opStack = new Stack<>();\\n        Map<Character, Integer> map = new HashMap<>();\\n        map.put('+', 1); map.put('-', 1);\\n        map.put('*', 2); map.put('/', 2);\\n        map.put('^', 3);\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (Character.isDigit(c)) {\\n                num = num * 10 + c - '0';\\n                if (i == s.length() - 1 || !Character.isDigit(s.charAt(i + 1))) {\\n                    numStack.push(num);\\n                    num = 0;                  \\n                }\\n            } else { // op: + - * / ^\\n                if (opStack.empty() || map.get(c) > map.get(opStack.peek())) {\\n                    opStack.push(c);\\n                } else {\\n                    while (!opStack.empty() && map.get(c) <= map.get(opStack.peek())) {\\n                        helper(numStack, opStack);\\n                    }\\n                    opStack.push(c);\\n                }                     \\n            }           \\n        }\\n        \\n        while (!opStack.empty()) {\\n            helper(numStack, opStack);\\n        }\\n        return numStack.pop();\\n    }\\n    \\n    private void helper(Stack<Integer> numStack, Stack<Character> opStack) {\\n        int b = numStack.pop();\\n        int a = numStack.pop();\\n        char op = opStack.pop();\\n        if (op == '+') numStack.push(a + b);\\n        if (op == '-') numStack.push(a - b);\\n        if (op == '*') numStack.push(a * b);\\n        if (op == '/') numStack.push(a / b);\\n        if (op == '^') numStack.push((int)Math.pow(a, b));\\n    }\\n\\n}\\n```\n```\\nclass Solution {\\n    \\n    public int calculate(String s) {\\n        // remove spaces //\\u8fd9\\u90e8\\u5206\\u4e5f\\u53ef\\u4ee5\\u653e\\u5728\\u4e0b\\u9762\\u5224\\u65ad\\uff0c\\u4e00\\u53e5\\u641e\\u5b9a\\uff0c\\u662f\\u7a7a\\u683c\\u7684\\u65f6\\u5019\\u8df3\\u8fc7\\n        String[] strs = s.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < strs.length; i++) {\\n            sb.append(strs[i]);\\n        }\\n        s = sb.toString();\\n        \\n        // init\\n        if (s == null || sb.length() == 0) return 0;\\n        int num = 0;\\n        Stack<Integer> numStack = new Stack<>();\\n        Stack<Character> opStack = new Stack<>();\\n        Map<Character, Integer> map = new HashMap<>();\\n        map.put('+', 1); map.put('-', 1);\\n        map.put('*', 2); map.put('/', 2);\\n        map.put('^', 3);\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (Character.isDigit(c)) {\\n                num = num * 10 + c - '0';\\n                if (i == s.length() - 1 || !Character.isDigit(s.charAt(i + 1))) {\\n                    numStack.push(num);\\n                    num = 0;                  \\n                }\\n            } else { // op or ()\\n                if (c == '(') {\\n                    opStack.push(c);\\n                }\\n                if (c == ')') {\\n                    while (!opStack.empty() && opStack.peek() != '(') {\\n                        helper(numStack, opStack);\\n                    }\\n                    opStack.pop(); // pop the '('\\n                }\\n                if (map.containsKey(c)) { // + - * / ^\\n                    if (opStack.empty() || opStack.peek() == '(' || map.get(c) > map.get(opStack.peek())) {\\n                        opStack.push(c);\\n                    } else {\\n                        while (!opStack.empty() && opStack.peek() != '(' && map.get(c) <= map.get(opStack.peek())) {\\n                            helper(numStack, opStack);\\n                        }\\n                        opStack.push(c);\\n                    }                 \\n                }              \\n            }           \\n        }\\n        \\n        while (!opStack.empty()) {\\n            helper(numStack, opStack);\\n        }\\n        return numStack.pop();\\n    }\\n    \\n    private void helper(Stack<Integer> numStack, Stack<Character> opStack) {\\n        int b = numStack.pop();\\n        int a = numStack.pop();\\n        char op = opStack.pop();\\n        if (op == '+') numStack.push(a + b);\\n        if (op == '-') numStack.push(a - b);\\n        if (op == '*') numStack.push(a * b);\\n        if (op == '/') numStack.push(a / b);\\n        if (op == '^') numStack.push((int)Math.pow(a, b));\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804998,
                "title": "c-easy-solution-using-stack-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int sum=0;\\n        int sign=1;\\n        stack<int> stac;\\n        for (int i=0;i<s.length();i++){\\n            char ch=s[i];\\n            if (isdigit(ch)){\\n                int val=0;\\n                while(i<s.length() && isdigit(s[i])){\\n                    val=val*10+(s[i]-\\'0\\');\\n                    i++;\\n                }\\n                i--;\\n                sum=sum+sign*val;\\n                sign=1;\\n            }else if (ch==\\'(\\'){\\n                stac.push(sum);\\n                stac.push(sign);\\n                sum=0;\\n                sign=1;\\n            }\\n            else if (ch==\\')\\'){\\n                sum=stac.top()*sum;\\n                stac.pop();\\n                sum=sum+stac.top();\\n                stac.pop();\\n            }\\n            else if (ch==\\'-\\'){\\n                sign*=-1;\\n            }\\n        }\\n        return sum ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int sum=0;\\n        int sign=1;\\n        stack<int> stac;\\n        for (int i=0;i<s.length();i++){\\n            char ch=s[i];\\n            if (isdigit(ch)){\\n                int val=0;\\n                while(i<s.length() && isdigit(s[i])){\\n                    val=val*10+(s[i]-\\'0\\');\\n                    i++;\\n                }\\n                i--;\\n                sum=sum+sign*val;\\n                sign=1;\\n            }else if (ch==\\'(\\'){\\n                stac.push(sum);\\n                stac.push(sign);\\n                sum=0;\\n                sign=1;\\n            }\\n            else if (ch==\\')\\'){\\n                sum=stac.top()*sum;\\n                stac.pop();\\n                sum=sum+stac.top();\\n                stac.pop();\\n            }\\n            else if (ch==\\'-\\'){\\n                sign*=-1;\\n            }\\n        }\\n        return sum ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735632,
                "title": "best-c-using-stack-solution-and-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse stack approch\\n\\n# Complexity\\n- Time complexity:\\nO(n) //as n is length of input string\\n\\n- Space complexity:\\nO(n) // as we use stack\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int len=s.length();\\n        stack<int> st;\\n        \\n        int sign=1;  //initially take +ve sign\\n        int currNum=0;\\n        int ans=0;\\n\\n        for(int i=0;i<len;i++){\\n            if(isdigit(s[i])){\\n                currNum=s[i]-\\'0\\';\\n\\n                while(i+1<len && isdigit(s[i+1])){\\n                    currNum=(currNum*10)+(s[i+1]-\\'0\\');\\n                    i++;\\n                }\\n                currNum=currNum*sign;\\n                ans+=currNum;\\n                currNum=0;\\n            }\\n            else if(s[i]==\\'+\\'){\\n                sign=1;\\n            }\\n            else if(s[i]==\\'-\\'){\\n                sign=-1;\\n            }\\n            else if(s[i]==\\'(\\'){\\n                st.push(ans);\\n                st.push(sign);\\n\\n                sign=1;\\n                currNum=0;\\n                ans=0;\\n            }\\n\\n            else if(s[i]==\\')\\'){\\n                int prevSign=st.top();\\n                ans=ans*prevSign;\\n                st.pop();\\n\\n                int prevAns=st.top();\\n                ans+=prevAns;\\n                st.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int len=s.length();\\n        stack<int> st;\\n        \\n        int sign=1;  //initially take +ve sign\\n        int currNum=0;\\n        int ans=0;\\n\\n        for(int i=0;i<len;i++){\\n            if(isdigit(s[i])){\\n                currNum=s[i]-\\'0\\';\\n\\n                while(i+1<len && isdigit(s[i+1])){\\n                    currNum=(currNum*10)+(s[i+1]-\\'0\\');\\n                    i++;\\n                }\\n                currNum=currNum*sign;\\n                ans+=currNum;\\n                currNum=0;\\n            }\\n            else if(s[i]==\\'+\\'){\\n                sign=1;\\n            }\\n            else if(s[i]==\\'-\\'){\\n                sign=-1;\\n            }\\n            else if(s[i]==\\'(\\'){\\n                st.push(ans);\\n                st.push(sign);\\n\\n                sign=1;\\n                currNum=0;\\n                ans=0;\\n            }\\n\\n            else if(s[i]==\\')\\'){\\n                int prevSign=st.top();\\n                ans=ans*prevSign;\\n                st.pop();\\n\\n                int prevAns=st.top();\\n                ans+=prevAns;\\n                st.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294226,
                "title": "easiest-solution-ever-pls-take-a-look",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int calculate(String s) {\\n        int sign = 1;\\n        int sum = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i = 0; i<s.length(); i++){\\n            if(s.charAt(i)>=\\'0\\' && s.charAt(i)<=\\'9\\'){\\n                int num = 0;\\n                while(i<s.length() && s.charAt(i)>=\\'0\\' && s.charAt(i)<=\\'9\\'){\\n                    num = num * 10 + s.charAt(i) - \\'0\\';\\n                    i++;\\n                }\\n                sum += num * sign;\\n                i--;\\n            }\\n            else if(s.charAt(i)==\\'+\\') sign = 1;\\n            else if(s.charAt(i)==\\'-\\') sign = -1;\\n            else if(s.charAt(i)==\\'(\\'){\\n                stack.push(sum);\\n                stack.push(sign);\\n                sum = 0;\\n                sign = 1;\\n            }\\n            else if(s.charAt(i)==\\')\\'){\\n                sum = stack.pop() * sum;\\n                sum += stack.pop();\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        int sign = 1;\\n        int sum = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        for(int i = 0; i<s.length(); i++){\\n            if(s.charAt(i)>=\\'0\\' && s.charAt(i)<=\\'9\\'){\\n                int num = 0;\\n                while(i<s.length() && s.charAt(i)>=\\'0\\' && s.charAt(i)<=\\'9\\'){\\n                    num = num * 10 + s.charAt(i) - \\'0\\';\\n                    i++;\\n                }\\n                sum += num * sign;\\n                i--;\\n            }\\n            else if(s.charAt(i)==\\'+\\') sign = 1;\\n            else if(s.charAt(i)==\\'-\\') sign = -1;\\n            else if(s.charAt(i)==\\'(\\'){\\n                stack.push(sum);\\n                stack.push(sign);\\n                sum = 0;\\n                sign = 1;\\n            }\\n            else if(s.charAt(i)==\\')\\'){\\n                sum = stack.pop() * sum;\\n                sum += stack.pop();\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832292,
                "title": "most-intuitive-2-approaches-stack-and-recursion",
                "content": "**Recursion based:**\\n\\n```\\nclass Solution {\\nprivate:\\n    int calculateUtil(string &s, int &i) {\\n        int res = 0, curr = 0, prev_oper = 1;\\n        while(i < s.size()) {\\n            \\n            if(s[i] == \\'(\\') \\n                curr = calculateUtil(s, ++i);\\n\\n            else if(s[i] == \\')\\') \\n                break;\\n\\n            else if(s[i] == \\'+\\') {\\n                res += curr*prev_oper;\\n                prev_oper = 1;\\n                curr = 0;\\n            }\\n\\n            else if(s[i] == \\'-\\') {\\n                res += curr*prev_oper;\\n                prev_oper = -1;\\n                curr = 0;\\n            }\\n\\n            else if(s[i] != \\' \\')\\n                curr = curr*10+(s[i]-\\'0\\');\\n\\n            ++i;\\n        }\\n\\n        return res += curr*prev_oper;\\n    }\\npublic:\\n    int calculate(string s) {\\n        int i = 0;\\n        return calculateUtil(s,i);\\n    }\\n};\\n```\\n\\n-----------------\\n\\n**Stack based:**\\n\\n```\\nclass Solution {\\npublic:\\n   int calculate(string s) {\\n       stack<pair<int, int>> st;                    // pair(prev_calc_value , sign before next bracket () )\\n       \\n       long long int sum = 0;\\n       int sign = +1;\\n       \\n       for(int i = 0 ; i < s.size() ; i++) {\\n           \\n           char ch = s[i];\\n           \\n           if(isdigit(ch)) {\\n               long long int num = 0;\\n               while(i < s.size() and isdigit(s[i]))\\n               {\\n                   num = (num * 10) + s[i] - \\'0\\'; i++;\\n               }\\n               i--;                                 // as for loop also increase i , so if we don\\'t decrease i here a sign will be skipped\\n               sum += (num * sign);\\n               sign = +1;                           // reseting sign\\n           }\\n           else if(ch == \\'(\\') {\\n               \\n               st.push(make_pair(sum , sign));      // Saving current state of (sum , sign) in stack\\n               \\n               sum = 0;                             // Reseting sum and sign for inner bracket calculation\\n               sign = +1;\\n           }\\n           else if(ch == \\')\\') {\\n               sum = st.top().first + (st.top().second * sum);\\n               st.pop();\\n           }\\n           else if(ch == \\'-\\')\\n               sign = (-1 * sign);                  // toggle sign\\n       }\\n       return sum;\\n   }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int calculateUtil(string &s, int &i) {\\n        int res = 0, curr = 0, prev_oper = 1;\\n        while(i < s.size()) {\\n            \\n            if(s[i] == \\'(\\') \\n                curr = calculateUtil(s, ++i);\\n\\n            else if(s[i] == \\')\\') \\n                break;\\n\\n            else if(s[i] == \\'+\\') {\\n                res += curr*prev_oper;\\n                prev_oper = 1;\\n                curr = 0;\\n            }\\n\\n            else if(s[i] == \\'-\\') {\\n                res += curr*prev_oper;\\n                prev_oper = -1;\\n                curr = 0;\\n            }\\n\\n            else if(s[i] != \\' \\')\\n                curr = curr*10+(s[i]-\\'0\\');\\n\\n            ++i;\\n        }\\n\\n        return res += curr*prev_oper;\\n    }\\npublic:\\n    int calculate(string s) {\\n        int i = 0;\\n        return calculateUtil(s,i);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n   int calculate(string s) {\\n       stack<pair<int, int>> st;                    // pair(prev_calc_value , sign before next bracket () )\\n       \\n       long long int sum = 0;\\n       int sign = +1;\\n       \\n       for(int i = 0 ; i < s.size() ; i++) {\\n           \\n           char ch = s[i];\\n           \\n           if(isdigit(ch)) {\\n               long long int num = 0;\\n               while(i < s.size() and isdigit(s[i]))\\n               {\\n                   num = (num * 10) + s[i] - \\'0\\'; i++;\\n               }\\n               i--;                                 // as for loop also increase i , so if we don\\'t decrease i here a sign will be skipped\\n               sum += (num * sign);\\n               sign = +1;                           // reseting sign\\n           }\\n           else if(ch == \\'(\\') {\\n               \\n               st.push(make_pair(sum , sign));      // Saving current state of (sum , sign) in stack\\n               \\n               sum = 0;                             // Reseting sum and sign for inner bracket calculation\\n               sign = +1;\\n           }\\n           else if(ch == \\')\\') {\\n               sum = st.top().first + (st.top().second * sum);\\n               st.pop();\\n           }\\n           else if(ch == \\'-\\')\\n               sign = (-1 * sign);                  // toggle sign\\n       }\\n       return sum;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831636,
                "title": "swift-easy-to-understand-and-simple-solution",
                "content": "Solution:\\n```\\nclass Solution {\\n    func calculate(_ s: String) -> Int {\\n        var result = 0\\n        var num = 0\\n        var sign = 1\\n        var stack = [sign]\\n        \\n        for char in s {\\n            switch char {\\n            case \"+\", \"-\":\\n                result += num * sign\\n                sign = stack.last! * (char == \"+\" ? 1 : -1)\\n                num = 0\\n            case \"(\":\\n                stack.append(sign)\\n            case \")\":\\n                stack.removeLast()\\n            case \" \":\\n                break\\n            default:\\n                num = num * 10 + char.wholeNumberValue!\\n            }\\n        }\\n        \\n        return result + num * sign\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func calculate(_ s: String) -> Int {\\n        var result = 0\\n        var num = 0\\n        var sign = 1\\n        var stack = [sign]\\n        \\n        for char in s {\\n            switch char {\\n            case \"+\", \"-\":\\n                result += num * sign\\n                sign = stack.last! * (char == \"+\" ? 1 : -1)\\n                num = 0\\n            case \"(\":\\n                stack.append(sign)\\n            case \")\":\\n                stack.removeLast()\\n            case \" \":\\n                break\\n            default:\\n                num = num * 10 + char.wholeNumberValue!\\n            }\\n        }\\n        \\n        return result + num * sign\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2035196,
                "title": "two-methods-using-stack-dfs-in-python-explained-to-details",
                "content": "**Two Methods:**\\none using stack\\none using DFS\\n\\n**Method 1:**\\nUse **stack**!\\n\\n**Initiate:**\\n* a running number\\n* a running result\\n* a running sign\\n\\nWhen we reach a **\"(\"**, we append the current res and sign to the stack.\\nWhen we reach a **\")\"**, we pop the before stored res and sign.\\n\\n**TIme:** O(n)\\n**Space:** O(n)\\n\\n```\\nclass Solution:\\n      \\n    def calculate(self, s: str) -> int:\\n\\n        stack = []\\n        num = 0 # Running number\\n        res = 0 # Running result\\n        sign = 1 # Running sign, 1 means positive, -1 means negative  \\n\\n        for char in s:\\n            \\n            if char.isdigit():\\n                num = (num * 10) + int(char)\\n\\n            elif char == \\'+\\':\\n                res += sign * num\\n                sign = 1\\n                num = 0\\n\\n            elif char == \\'-\\':\\n                res += sign * num\\n                sign = -1\\n                num = 0\\n\\n            elif char == \\'(\\':\\n                stack.append(res)\\n                stack.append(sign)\\n\\n                num = 0\\n                sign = 1\\n                res = 0\\n\\n            elif char == \\')\\':\\n                res += sign * num\\n\\n                res *= stack.pop() # stack pop previously stored sign\\n                res += stack.pop() # stack pop previously stored operand\\n\\n                num = 0\\n\\n        return res + sign * num\\n```\\n\\n\\n**Method 2:**\\nUse **DFS**!\\n\\nThis solution could be easily extended to **\"Q772: Basic Calculator III\"**\\n**Reference:**\\nhttps://leetcode.com/problems/basic-calculator-iii/\\nhttps://leetcode.com/problems/basic-calculator-iii/discuss/2035890/Greatly-Explained-DFS-%2B-Deque-%2B-Stack-Solution-in-Python-Easy-to-Understand!!!\\n\\nTake it as a **tree**!\\nEvery time we reach a **\"(\"**, we go to **next level**!\\n\\n**For example:**\\n**3 + ((7 + 6) - (8 + 5))**\\n7 + 6 is in level 2\\n8 + 5 is in level 2\\n13 - 13 is in level 1\\n3 + 0 is in level 0\\n\\n**Time:** O(n)\\n**Space:** O(n)\\n\\n```\\nclass Solution:\\n      \\n    def calculate(self, s: str) -> int:\\n\\n        queue = deque(s.replace(\\' \\',\\'\\'))\\n        return self.helper(queue)\\n    \\n    def helper(self, q):\\n        \\n        res = []       \\n        num = 0\\n        sign = \\'+\\'\\n        \\n        while q:\\n            x = q.popleft()\\n            if x == \\'(\\':\\n                num = self.helper(q) # go to next level\\n            if x.isdigit():\\n                num = num * 10 + int(x)\\n            if not x.isdigit() or not q:\\n                if sign ==\\'+\\':\\n                    res.append(num)\\n                elif sign ==\\'-\\':\\n                    res.append(-1 * num)\\n                sign = x\\n                num = 0\\n            if x == \\')\\':\\n                break\\n        \\n        return sum(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n      \\n    def calculate(self, s: str) -> int:\\n\\n        stack = []\\n        num = 0 # Running number\\n        res = 0 # Running result\\n        sign = 1 # Running sign, 1 means positive, -1 means negative  \\n\\n        for char in s:\\n            \\n            if char.isdigit():\\n                num = (num * 10) + int(char)\\n\\n            elif char == \\'+\\':\\n                res += sign * num\\n                sign = 1\\n                num = 0\\n\\n            elif char == \\'-\\':\\n                res += sign * num\\n                sign = -1\\n                num = 0\\n\\n            elif char == \\'(\\':\\n                stack.append(res)\\n                stack.append(sign)\\n\\n                num = 0\\n                sign = 1\\n                res = 0\\n\\n            elif char == \\')\\':\\n                res += sign * num\\n\\n                res *= stack.pop() # stack pop previously stored sign\\n                res += stack.pop() # stack pop previously stored operand\\n\\n                num = 0\\n\\n        return res + sign * num\\n```\n```\\nclass Solution:\\n      \\n    def calculate(self, s: str) -> int:\\n\\n        queue = deque(s.replace(\\' \\',\\'\\'))\\n        return self.helper(queue)\\n    \\n    def helper(self, q):\\n        \\n        res = []       \\n        num = 0\\n        sign = \\'+\\'\\n        \\n        while q:\\n            x = q.popleft()\\n            if x == \\'(\\':\\n                num = self.helper(q) # go to next level\\n            if x.isdigit():\\n                num = num * 10 + int(x)\\n            if not x.isdigit() or not q:\\n                if sign ==\\'+\\':\\n                    res.append(num)\\n                elif sign ==\\'-\\':\\n                    res.append(-1 * num)\\n                sign = x\\n                num = 0\\n            if x == \\')\\':\\n                break\\n        \\n        return sum(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458648,
                "title": "go-solution",
                "content": "https://github.com/ganeshskudva/Leetcode-Golang\\n\\nInspired by [this](https://leetcode.com/problems/basic-calculator/discuss/62361/Iterative-Java-solution-with-stack) solution\\n```\\nfunc calculate(s string) int {\\n\\tif len(s) == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tresult, sign, num := 0, 1, 0\\n\\n\\tvar st []int\\n\\tst = append(st, sign)\\n\\n\\tfor i := range s {\\n\\t\\tif s[i] >= \\'0\\' && s[i] <= \\'9\\' {\\n\\t\\t\\tnum = num*10 + int(s[i]-\\'0\\')\\n\\t\\t} else if s[i] == \\'+\\' || s[i] == \\'-\\' {\\n\\t\\t\\tresult += sign * num\\n\\t\\t\\tsign = st[len(st)-1]\\n\\t\\t\\tif s[i] != \\'+\\' {\\n\\t\\t\\t\\tsign *= -1\\n\\t\\t\\t}\\n\\t\\t\\tnum = 0\\n\\t\\t} else if s[i] == \\'(\\' {\\n\\t\\t\\tst = append(st, sign)\\n\\t\\t} else if s[i] == \\')\\' {\\n\\t\\t\\tst = st[:len(st)-1]\\n\\t\\t}\\n\\t}\\n\\n\\tresult += sign * num\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc calculate(s string) int {\\n\\tif len(s) == 0 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tresult, sign, num := 0, 1, 0\\n\\n\\tvar st []int\\n\\tst = append(st, sign)\\n\\n\\tfor i := range s {\\n\\t\\tif s[i] >= \\'0\\' && s[i] <= \\'9\\' {\\n\\t\\t\\tnum = num*10 + int(s[i]-\\'0\\')\\n\\t\\t} else if s[i] == \\'+\\' || s[i] == \\'-\\' {\\n\\t\\t\\tresult += sign * num\\n\\t\\t\\tsign = st[len(st)-1]\\n\\t\\t\\tif s[i] != \\'+\\' {\\n\\t\\t\\t\\tsign *= -1\\n\\t\\t\\t}\\n\\t\\t\\tnum = 0\\n\\t\\t} else if s[i] == \\'(\\' {\\n\\t\\t\\tst = append(st, sign)\\n\\t\\t} else if s[i] == \\')\\' {\\n\\t\\t\\tst = st[:len(st)-1]\\n\\t\\t}\\n\\t}\\n\\n\\tresult += sign * num\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1457033,
                "title": "java-stacks-solution",
                "content": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        int sum=0;\\n        int sign=1;\\n        Stack<Integer> stack=new Stack();\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            if(Character.isDigit(c)){\\n                int val=0;\\n                while(i<s.length() && Character.isDigit(s.charAt(i))){\\n                    val=val*10+s.charAt(i)-\\'0\\';\\n                    i++;\\n                }\\n                i--;\\n                val=val*sign;\\n                sum+=val;\\n                sign=1; //reset the sign\\n            }\\n            else if(c==\\'(\\'){\\n                stack.push(sum);\\n                stack.push(sign);\\n                sum=0;\\n                sign=1;\\n            }else if(c==\\')\\'){\\n                sum*=stack.pop();\\n                sum+=stack.pop();\\n            }else if(c==\\'-\\'){\\n                sign*=-1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        int sum=0;\\n        int sign=1;\\n        Stack<Integer> stack=new Stack();\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            if(Character.isDigit(c)){\\n                int val=0;\\n                while(i<s.length() && Character.isDigit(s.charAt(i))){\\n                    val=val*10+s.charAt(i)-\\'0\\';\\n                    i++;\\n                }\\n                i--;\\n                val=val*sign;\\n                sum+=val;\\n                sign=1; //reset the sign\\n            }\\n            else if(c==\\'(\\'){\\n                stack.push(sum);\\n                stack.push(sign);\\n                sum=0;\\n                sign=1;\\n            }else if(c==\\')\\'){\\n                sum*=stack.pop();\\n                sum+=stack.pop();\\n            }else if(c==\\'-\\'){\\n                sign*=-1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446691,
                "title": "c-explained-stacks-beginner-friendly",
                "content": "# ***Approach***\\n```\\nThis is a very good stacks problem , we are given an expression in form of string with \\nchars as [nums , \\'(\\' , \\')\\' , \\'+\\' , \\'-\\' , \\' \\']\\n\\nNote : we can totally ignore \\' \\' and  \\'+\\'.\\n    \\nLogic:\\n        what we are going to do is very simple , \\n        first intilaize two vars , sum and sign\\n        sum = 0\\n        sign = +1\\n            \\n        traverse the string:\\n            if(ch is digit)\\n                num = get_full_num; // may be multidigit\\n                add it to sum , sum += (num * sign)\\n                reset sign to +1\\n            else if(ch is \\'(\\')\\n                save current state of sum and sign in stack\\n                reset sum and sign\\n            else if(ch is \\')\\')\\n                sum = val_at_top + (sign_at_top * sum)\\n                pop;\\n            else if(ch is \\'-\\')\\n                toggle sign\\n                \\n       the use of sum and sign are to evaluate current expression inside a () braces or completely outside\\n       stack is used to store the state of sum and sign take example\\n       1 + 2 + 3 - (5 + 6) => 6 - (5 + 6)\\n                when we encounter saving state means\\n                stack will store pair(6 , -) and first calculate (5 + 6)\\n                once (5 + 6) is calculated which is 11\\n                pop from stack => sum = (6 + (sum * -1)) = (6 + (11 * -1)) = -5 ans\\n ```\\n # ***Code***\\n ```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<pair<int,int>> st; // pair(prev_calc_value , sign before next bracket () )\\n        \\n        long long int sum = 0;\\n        int sign = +1;\\n        \\n        for(int i = 0 ; i < s.size() ; ++i)\\n        {\\n            char ch = s[i];\\n            \\n            if(isdigit(ch))\\n            {\\n                long long int num = 0;\\n                while(i < s.size() and isdigit(s[i]))\\n                {\\n                    num = (num * 10) + s[i] - \\'0\\';\\n                    i++;\\n                }\\n                i--; // as for loop also increase i , so if we don\\'t decrease i here a sign will be skipped\\n                sum += (num * sign);\\n                sign = +1; // reseting sign\\n            }\\n            else if(ch == \\'(\\')\\n            {\\n                // Saving current state of (sum , sign) in stack\\n                st.push(make_pair(sum , sign));\\n                \\n                // Reseting sum and sign for inner bracket calculation\\n                sum = 0; \\n                sign = +1;\\n            }\\n            else if(ch == \\')\\')\\n            {\\n                sum = st.top().first + (st.top().second * sum);\\n                st.pop();\\n            }\\n            else if(ch == \\'-\\')\\n            {\\n                // toggle sign\\n                sign = (-1 * sign);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```\\n# ***If you liked the solution , Please Upvote!!!***",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nThis is a very good stacks problem , we are given an expression in form of string with \\nchars as [nums , \\'(\\' , \\')\\' , \\'+\\' , \\'-\\' , \\' \\']\\n\\nNote : we can totally ignore \\' \\' and  \\'+\\'.\\n    \\nLogic:\\n        what we are going to do is very simple , \\n        first intilaize two vars , sum and sign\\n        sum = 0\\n        sign = +1\\n            \\n        traverse the string:\\n            if(ch is digit)\\n                num = get_full_num; // may be multidigit\\n                add it to sum , sum += (num * sign)\\n                reset sign to +1\\n            else if(ch is \\'(\\')\\n                save current state of sum and sign in stack\\n                reset sum and sign\\n            else if(ch is \\')\\')\\n                sum = val_at_top + (sign_at_top * sum)\\n                pop;\\n            else if(ch is \\'-\\')\\n                toggle sign\\n                \\n       the use of sum and sign are to evaluate current expression inside a () braces or completely outside\\n       stack is used to store the state of sum and sign take example\\n       1 + 2 + 3 - (5 + 6) => 6 - (5 + 6)\\n                when we encounter saving state means\\n                stack will store pair(6 , -) and first calculate (5 + 6)\\n                once (5 + 6) is calculated which is 11\\n                pop from stack => sum = (6 + (sum * -1)) = (6 + (11 * -1)) = -5 ans\\n ```\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<pair<int,int>> st; // pair(prev_calc_value , sign before next bracket () )\\n        \\n        long long int sum = 0;\\n        int sign = +1;\\n        \\n        for(int i = 0 ; i < s.size() ; ++i)\\n        {\\n            char ch = s[i];\\n            \\n            if(isdigit(ch))\\n            {\\n                long long int num = 0;\\n                while(i < s.size() and isdigit(s[i]))\\n                {\\n                    num = (num * 10) + s[i] - \\'0\\';\\n                    i++;\\n                }\\n                i--; // as for loop also increase i , so if we don\\'t decrease i here a sign will be skipped\\n                sum += (num * sign);\\n                sign = +1; // reseting sign\\n            }\\n            else if(ch == \\'(\\')\\n            {\\n                // Saving current state of (sum , sign) in stack\\n                st.push(make_pair(sum , sign));\\n                \\n                // Reseting sum and sign for inner bracket calculation\\n                sum = 0; \\n                sign = +1;\\n            }\\n            else if(ch == \\')\\')\\n            {\\n                sum = st.top().first + (st.top().second * sum);\\n                st.pop();\\n            }\\n            else if(ch == \\'-\\')\\n            {\\n                // toggle sign\\n                sign = (-1 * sign);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344266,
                "title": "python-recursive-easy-to-understand",
                "content": "The approach here is somewhat similar to https://leetcode.com/problems/construct-binary-tree-from-string/ in the sense that an opening parenthesis signals a new subexpression and therefore a signal that we need to recurse. Each entry on the call stack is responsible for evaluating it\\'s assigned subexpression and returning the result of that subexpression as well as the last index of that expression. The method call one level up on the stack resumes where the subexpression left off.\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        \\n        def recurs(s, start):\\n            operand = result = 0\\n            nextSign = 1 # 1 for positive, -1 for negative (used to change sign of operand since we\\'re always adding)\\n            i = start\\n            while i < len(s) - 1:\\n                i += 1\\n                c = s[i]\\n                \\n                if c == \" \":\\n                    continue\\n\\n                if c.isdigit():\\n                    # add digit to operand (could be multiple)\\n                    operand = 10 * operand + int(c)\\n                elif c == \"(\":\\n                    # new sub-expression - recurs\\n                    end, operand = recurs(s, i)\\n                    i = end\\n                elif c == \")\":\\n                    # sub-expression ended - exit\\n                    break\\n                else:\\n                    # operator\\n                    result += nextSign * operand\\n                    nextSign = 1 if c == \"+\" else -1\\n                    operand = 0\\n\\n            return i, result + (nextSign * operand)\\n        \\n        return recurs(s, -1)[1]\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        \\n        def recurs(s, start):\\n            operand = result = 0\\n            nextSign = 1 # 1 for positive, -1 for negative (used to change sign of operand since we\\'re always adding)\\n            i = start\\n            while i < len(s) - 1:\\n                i += 1\\n                c = s[i]\\n                \\n                if c == \" \":\\n                    continue\\n\\n                if c.isdigit():\\n                    # add digit to operand (could be multiple)\\n                    operand = 10 * operand + int(c)\\n                elif c == \"(\":\\n                    # new sub-expression - recurs\\n                    end, operand = recurs(s, i)\\n                    i = end\\n                elif c == \")\":\\n                    # sub-expression ended - exit\\n                    break\\n                else:\\n                    # operator\\n                    result += nextSign * operand\\n                    nextSign = 1 if c == \"+\" else -1\\n                    operand = 0\\n\\n            return i, result + (nextSign * operand)\\n        \\n        return recurs(s, -1)[1]\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1254459,
                "title": "python-concise-solution-with-stack",
                "content": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        \\n        num=0\\n        res=0\\n        sign=1\\n        stack=[]\\n        \\n        for char in s:\\n            if char.isdigit():\\n                num=num*10+int(char)\\n            elif char in [\"-\",\"+\"]:\\n                res=res+num*sign\\n                num=0\\n                if char==\"-\":\\n                    sign=-1\\n                else:\\n                    sign=1\\n            elif char==\"(\":\\n                stack.append(res)\\n                stack.append(sign)\\n                sign=1\\n                res=0\\n            elif char==\")\":\\n                res+=sign*num\\n                res*=stack.pop()## process sign\\n                res+=stack.pop() ##process with old value\\n                num=0\\n        \\n        return res+num*sign\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        \\n        num=0\\n        res=0\\n        sign=1\\n        stack=[]\\n        \\n        for char in s:\\n            if char.isdigit():\\n                num=num*10+int(char)\\n            elif char in [\"-\",\"+\"]:\\n                res=res+num*sign\\n                num=0\\n                if char==\"-\":\\n                    sign=-1\\n                else:\\n                    sign=1\\n            elif char==\"(\":\\n                stack.append(res)\\n                stack.append(sign)\\n                sign=1\\n                res=0\\n            elif char==\")\":\\n                res+=sign*num\\n                res*=stack.pop()## process sign\\n                res+=stack.pop() ##process with old value\\n                num=0\\n        \\n        return res+num*sign\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62483,
                "title": "ac-python-solution",
                "content": "    class Solution:\\n    def calculate(self, s):\\n        s = '+(+' + s + ')'\\n        s = s.replace('+-', '-').replace('++', '+') # for the corner case '-5', '+5'\\n        stack = []\\n        for i in s:\\n            if i == ')':\\n                total = 0\\n                while stack[-1] != '(':\\n                    total += int(stack.pop())\\n                stack.pop()\\n                sign = 1 if stack.pop() == '+' else -1\\n                stack.append(sign * total)\\n            elif i.isdigit() and stack[-1][-1] in '+-0123456789':\\n                stack[-1] += i\\n            elif i != ' ':\\n                stack.append(i)\\n        return stack[0]",
                "solutionTags": [],
                "code": "    class Solution:\\n    def calculate(self, s):\\n        s = '+(+' + s + ')'\\n        s = s.replace('+-', '-').replace('++', '+') # for the corner case '-5', '+5'\\n        stack = []\\n        for i in s:\\n            if i == ')':\\n                total = 0\\n                while stack[-1] != '(':\\n                    total += int(stack.pop())\\n                stack.pop()\\n                sign = 1 if stack.pop() == '+' else -1\\n                stack.append(sign * total)\\n            elif i.isdigit() and stack[-1][-1] in '+-0123456789':\\n                stack[-1] += i\\n            elif i != ' ':\\n                stack.append(i)\\n        return stack[0]",
                "codeTag": "Java"
            },
            {
                "id": 3745689,
                "title": "very-easy-to-understand-as-relatable-with-real-math-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**At begining :**  I can\\'t visualize the solution , i thought about a problem **Evaluate Reverse Polish Notation** , can\\'t think beyond this than i search for solution .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Very easy approach** as we do generally we start from begining and we take the value and evaluate it. As we **get \\'(\\'** we put our calculated ans and prev sign to stack as we did in our real math problem . Than in same way start calculating the ans for value untill we **get\\')\\'** .\\n\\n\\nThan after **we first give sign to the value which we calculated inside the bracket** ( for this we push the ans first and than sign ) and after this we add that vlaue with previous one .\\n\\n**This is the same way as we solved our real math problems .**\\n\\n**Plz give your approach in comment , this will very helpful for me**\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n**O(n)** \\nwhere n : length of given string \\n\\n- Space complexity:\\n **O(n)**\\n****Bold**** As i use a stack \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n      stack<int> st;\\n\\n      int sign =1, ans=0;\\n      for(int i=0;i<s.size();i++){\\n          if(s[i]>=\\'0\\'){\\n              int num=0;\\n              while( i<s.size() && s[i]>=\\'0\\')\\n              num = (num *10) +(s[i++] -\\'0\\');\\n              i--;\\n             \\n             ans+=(sign * num);\\n             \\n          }\\n\\n          else if( s[i]== \\'+\\')\\n          sign = 1;\\n          else if(s[i]== \\'-\\')\\n          sign =-1;\\n\\n          else if(s[i]==\\'(\\'){\\n              st.push(ans);\\n              st.push(sign);\\n\\n              ans=0;\\n              sign =1;\\n          }\\n          else if(s[i]== \\')\\'){\\n              ans*=st.top();\\n              st.pop();\\n              ans+=st.top();\\n              st.pop();\\n\\n          }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n      stack<int> st;\\n\\n      int sign =1, ans=0;\\n      for(int i=0;i<s.size();i++){\\n          if(s[i]>=\\'0\\'){\\n              int num=0;\\n              while( i<s.size() && s[i]>=\\'0\\')\\n              num = (num *10) +(s[i++] -\\'0\\');\\n              i--;\\n             \\n             ans+=(sign * num);\\n             \\n          }\\n\\n          else if( s[i]== \\'+\\')\\n          sign = 1;\\n          else if(s[i]== \\'-\\')\\n          sign =-1;\\n\\n          else if(s[i]==\\'(\\'){\\n              st.push(ans);\\n              st.push(sign);\\n\\n              ans=0;\\n              sign =1;\\n          }\\n          else if(s[i]== \\')\\'){\\n              ans*=st.top();\\n              st.pop();\\n              ans+=st.top();\\n              st.pop();\\n\\n          }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832590,
                "title": "swift-tokenizer",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nTokenizer concept please refer to this post\\n[Stop hating parsing problems and start having fun!](https://leetcode.com/problems/basic-calculator/solutions/2017431/stop-hating-parsing-problems-and-start-having-fun/)\\n\\nSome solution are great, pretty short, beautiful and good performance,\\nbut the more important thing to me is can I remember it in a interview several monthes after?\\n\\nThe concept should be very simple\\nif the number included sign, then the result is the summary of all numbers\\n\\n    1 - 1 = 1 + (-1) \\n\\nSecond thing is I have to deal with long numbers from string\\n\\n    num = num * 10 + digit\\n\\nLast is the expression `1 + 2 - (3 + 4)`\\nwe can treat `(3 + 4)` as another `calculate(\"3+4\")`\\n\\n    1 + 2 - 7\\n\\nAlso, recursive actually is a call stack\\nin this case, recursive is as same as push the existing result to `stack`\\nand proceed from top by `pop` after expression result returned\\n\\nAnd it\\'s easy to find out one information missed when expression back,\\nwe need to cache the `lastSign` in front of expression\\n\\n    1 + 2 - (+ 3 + 4)\\n          ^: last sign\\n\\nExtract parsing logic to Tokenizer seems let code longer,\\nbut each function become simpler which means less mistake in interview\\nerasing the space by replacing also for the same purpose\\nwe always can improve when the interview time is available\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Tokenizer {\\n    let s: String\\n    var index: String.Index\\n    var lastSign = 1 // for expression back\\n    init(_ s: String) {\\n        self.s = s\\n        self.index = s.startIndex\\n    }\\n\\n    func nextNum() -> Int {\\n        var num = 0\\n        var sign = 1\\n        if index < s.endIndex, \"-+\".contains(s[index]) {\\n            if s[index] == \"-\" { sign = -1 }\\n            next()\\n        }\\n        while index < s.endIndex, let n = Int(String(s[index])) {\\n            num = num * 10 + n\\n            next()\\n        }\\n        lastSign = sign\\n        return num * sign\\n    }\\n\\n    func hasNext() -> Bool {\\n        index < s.endIndex\\n    }\\n\\n    func next() {\\n        index = s.index(after: index)\\n    }\\n\\n    func isExpressionStart() -> Bool {\\n        index < s.endIndex && s[index] == \"(\"\\n    }\\n\\n    func isExpressionEnd() -> Bool {\\n        index < s.endIndex && s[index] == \")\"\\n    }\\n}\\n\\nclass Solution {\\n    func calculate(_ s: String) -> Int {\\n        // O(n), can move space handle to tokenizer for improvement\\n        let tokenizer = Tokenizer(s.replacingOccurrences(of: \" \", with: \"\"))\\n        var calculateStack = [Int]()\\n        var signStack = [Int]()\\n        var result = 0\\n        while tokenizer.hasNext() {\\n            result += tokenizer.nextNum()\\n            // -(1+2), nextNum: 0 -> no impact to the result\\n            if tokenizer.isExpressionStart() {\\n                calculateStack.append(result)\\n                signStack.append(tokenizer.lastSign)\\n                result = 0\\n                tokenizer.next()\\n            } else if tokenizer.isExpressionEnd() {\\n                // 1+(1+2), stack: [1], result: 1 + 3\\n                // (1+1), stack: [0], result: 0 + 2\\n                // 2 - 3 + (1 + 4) stack: -1, sign: 1\\n                // 2 - 3 - (1 + 1) stack: -1, sign: -1\\n                result = calculateStack.removeLast() + result * signStack.removeLast()\\n                tokenizer.next()\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Tokenizer {\\n    let s: String\\n    var index: String.Index\\n    var lastSign = 1 // for expression back\\n    init(_ s: String) {\\n        self.s = s\\n        self.index = s.startIndex\\n    }\\n\\n    func nextNum() -> Int {\\n        var num = 0\\n        var sign = 1\\n        if index < s.endIndex, \"-+\".contains(s[index]) {\\n            if s[index] == \"-\" { sign = -1 }\\n            next()\\n        }\\n        while index < s.endIndex, let n = Int(String(s[index])) {\\n            num = num * 10 + n\\n            next()\\n        }\\n        lastSign = sign\\n        return num * sign\\n    }\\n\\n    func hasNext() -> Bool {\\n        index < s.endIndex\\n    }\\n\\n    func next() {\\n        index = s.index(after: index)\\n    }\\n\\n    func isExpressionStart() -> Bool {\\n        index < s.endIndex && s[index] == \"(\"\\n    }\\n\\n    func isExpressionEnd() -> Bool {\\n        index < s.endIndex && s[index] == \")\"\\n    }\\n}\\n\\nclass Solution {\\n    func calculate(_ s: String) -> Int {\\n        // O(n), can move space handle to tokenizer for improvement\\n        let tokenizer = Tokenizer(s.replacingOccurrences(of: \" \", with: \"\"))\\n        var calculateStack = [Int]()\\n        var signStack = [Int]()\\n        var result = 0\\n        while tokenizer.hasNext() {\\n            result += tokenizer.nextNum()\\n            // -(1+2), nextNum: 0 -> no impact to the result\\n            if tokenizer.isExpressionStart() {\\n                calculateStack.append(result)\\n                signStack.append(tokenizer.lastSign)\\n                result = 0\\n                tokenizer.next()\\n            } else if tokenizer.isExpressionEnd() {\\n                // 1+(1+2), stack: [1], result: 1 + 3\\n                // (1+1), stack: [0], result: 0 + 2\\n                // 2 - 3 + (1 + 4) stack: -1, sign: 1\\n                // 2 - 3 - (1 + 1) stack: -1, sign: -1\\n                result = calculateStack.removeLast() + result * signStack.removeLast()\\n                tokenizer.next()\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831465,
                "title": "c-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n\\n        public int Calculate(string s)\\n        {\\n            int result = 0;\\n            int i = 0;\\n            Stack<int> stack = new Stack<int>();\\n            int sign = 1;\\n            int num = 0;\\n            while (i < s.Length)\\n            {\\n                switch (s[i])\\n                {\\n                    case \\'+\\':\\n                        sign = 1;\\n                        break;\\n                    case \\'-\\':\\n                        sign = -1;\\n                        break;\\n                    case \\'(\\':\\n                        stack.Push(result);\\n                        stack.Push(sign);\\n                        result = 0;\\n                        sign = 1;\\n                        break;\\n                    case \\')\\':\\n                        int lastSign = stack.Pop();\\n                        result *= lastSign;\\n                        int lastNum = stack.Pop();\\n                        result += lastNum;\\n\\n                        break;\\n                    case \\' \\':\\n                        break;\\n                    default:\\n                        if (char.IsDigit(s[i]))\\n                        {\\n                            StringBuilder stringBuilder = new StringBuilder();\\n                            stringBuilder.Append(s[i]);\\n                            while (i+1 < s.Length && char.IsDigit(s[i+1]))\\n                            {\\n                                stringBuilder.Append(s[++i]);\\n                            }\\n\\n                            num = int.Parse(stringBuilder.ToString());\\n                            num *= sign;\\n                            result+=num;\\n                            sign = 1;\\n                        }\\n                        break;\\n                }\\n                i++;\\n            }\\n\\n            return result;\\n        }\\n      \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n        public int Calculate(string s)\\n        {\\n            int result = 0;\\n            int i = 0;\\n            Stack<int> stack = new Stack<int>();\\n            int sign = 1;\\n            int num = 0;\\n            while (i < s.Length)\\n            {\\n                switch (s[i])\\n                {\\n                    case \\'+\\':\\n                        sign = 1;\\n                        break;\\n                    case \\'-\\':\\n                        sign = -1;\\n                        break;\\n                    case \\'(\\':\\n                        stack.Push(result);\\n                        stack.Push(sign);\\n                        result = 0;\\n                        sign = 1;\\n                        break;\\n                    case \\')\\':\\n                        int lastSign = stack.Pop();\\n                        result *= lastSign;\\n                        int lastNum = stack.Pop();\\n                        result += lastNum;\\n\\n                        break;\\n                    case \\' \\':\\n                        break;\\n                    default:\\n                        if (char.IsDigit(s[i]))\\n                        {\\n                            StringBuilder stringBuilder = new StringBuilder();\\n                            stringBuilder.Append(s[i]);\\n                            while (i+1 < s.Length && char.IsDigit(s[i+1]))\\n                            {\\n                                stringBuilder.Append(s[++i]);\\n                            }\\n\\n                            num = int.Parse(stringBuilder.ToString());\\n                            num *= sign;\\n                            result+=num;\\n                            sign = 1;\\n                        }\\n                        break;\\n                }\\n                i++;\\n            }\\n\\n            return result;\\n        }\\n      \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831413,
                "title": "python3-using-stack",
                "content": "class Solution:\\n\\n    def calculate(self, s: str) -> int:\\n        sums = 0\\n        i = 0\\n        sign = 1\\n        stack = []\\n        length = len(s)\\n        while i<length:\\n            char = s[i]\\n            if char.isdigit():\\n                val = 0\\n                while i<length and s[i].isdigit():\\n                    val = val*10 + int(s[i])\\n                    i+=1\\n                i-=1\\n                sums+=val*sign\\n                sign = 1\\n            elif char == \\'(\\':\\n                stack.append(sums)\\n                stack.append(sign)\\n                sums,sign = 0,1\\n            elif char == \\')\\':\\n                sums*=stack.pop()\\n                sums+=stack.pop()\\n            elif char ==\\'-\\':\\n                sign*=-1\\n            i+=1\\n            \\n        return sums",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def calculate(self, s: str) -> int:\\n        sums = 0\\n        i = 0\\n        sign = 1\\n        stack = []\\n        length = len(s)\\n        while i<length:\\n            char = s[i]\\n            if char.isdigit():\\n                val = 0\\n                while i<length and s[i].isdigit():\\n                    val = val*10 + int(s[i])\\n                    i+=1\\n                i-=1\\n                sums+=val*sign\\n                sign = 1\\n            elif char == \\'(\\':\\n                stack.append(sums)\\n                stack.append(sign)\\n                sums,sign = 0,1\\n            elif char == \\')\\':\\n                sums*=stack.pop()\\n                sums+=stack.pop()\\n            elif char ==\\'-\\':\\n                sign*=-1\\n            i+=1\\n            \\n        return sums",
                "codeTag": "Java"
            },
            {
                "id": 2744618,
                "title": "standard-method-to-solve-all-basic-calculator-questions",
                "content": "Basic idea is as follows :\\n1. Collect the number and store it in a stack\\n2. Update sign variable when you get \\'+\\' or \\'-\\'\\n3. Recurse whenever you see \\'(\\'\\n4. Return the value whenever you see \\')\\'\\n\\nHere we could have done without stack but I wanted to establish a common implementation for all the 3 Basic calculator implementation.\\n\\n```\\nclass Solution {\\n    \\n    int i;    \\n    public int calculate(String s) {\\n        i = 0;\\n        return recurse(s);\\n    }\\n    \\n    public int recurse(String s) {\\n        int sign = 1;\\n        Stack<Integer> st = new Stack<>();\\n        \\n        while (i < s.length()) {\\n            char ch = s.charAt(i);\\n            if (ch == \\' \\') {\\n                i++;\\n                continue;\\n            }\\n            else if (Character.isDigit(ch)) {\\n                int num = 0;\\n                while (i < s.length() && Character.isDigit(s.charAt(i))) {\\n                    num = num*10 + (s.charAt(i) - \\'0\\');\\n                    i++;\\n                }\\n                st.push((sign*num));\\n            }\\n            else if (ch == \\'+\\' || ch == \\'-\\') {\\n                sign = (ch == \\'+\\') ? 1 : -1;\\n                i++;\\n            }\\n            else if (ch == \\'(\\') {\\n                i++;\\n                int num = recurse(s);\\n                st.push(sign*num);\\n            } \\n            else if (ch == \\')\\') {\\n                i++;\\n                break;\\n            }\\n        }\\n        \\n        int res = 0;\\n        while (!st.isEmpty()) {\\n            res += st.pop();\\n        }\\n        return res;\\n        \\n    }\\n    \\n}\\n```\\n\\nBasic Calculator II : https://leetcode.com/problems/basic-calculator-ii/discuss/2744642/Standard-method-to-solve-all-basic-calculator-questions\\nBasic Calculator III : https://leetcode.com/problems/basic-calculator-iii/discuss/2744645/Standard-method-to-solve-all-basic-calculator-questions",
                "solutionTags": [
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int i;    \\n    public int calculate(String s) {\\n        i = 0;\\n        return recurse(s);\\n    }\\n    \\n    public int recurse(String s) {\\n        int sign = 1;\\n        Stack<Integer> st = new Stack<>();\\n        \\n        while (i < s.length()) {\\n            char ch = s.charAt(i);\\n            if (ch == \\' \\') {\\n                i++;\\n                continue;\\n            }\\n            else if (Character.isDigit(ch)) {\\n                int num = 0;\\n                while (i < s.length() && Character.isDigit(s.charAt(i))) {\\n                    num = num*10 + (s.charAt(i) - \\'0\\');\\n                    i++;\\n                }\\n                st.push((sign*num));\\n            }\\n            else if (ch == \\'+\\' || ch == \\'-\\') {\\n                sign = (ch == \\'+\\') ? 1 : -1;\\n                i++;\\n            }\\n            else if (ch == \\'(\\') {\\n                i++;\\n                int num = recurse(s);\\n                st.push(sign*num);\\n            } \\n            else if (ch == \\')\\') {\\n                i++;\\n                break;\\n            }\\n        }\\n        \\n        int res = 0;\\n        while (!st.isEmpty()) {\\n            res += st.pop();\\n        }\\n        return res;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671982,
                "title": "python-simple-solutions-stack-98",
                "content": "\\u2714\\uFE0F Solution\\nComplexity\\nNow time complexity it is O(n), space is still O(n).\\n\\n```class Solution:\\n    def calculate(self, s: str) -> int:\\n        stack = []\\n        p = 0\\n        sign = 1\\n        total = 0\\n        while p < len(s):\\n            char = s[p]\\n            if char.isdigit():\\n                num = 0\\n                while p < len(s) and s[p].isdigit():\\n                    num = num*10 + int(s[p])\\n                    p += 1\\n                p -= 1\\n                num *= sign\\n                total += num\\n                sign = 1\\n            elif char == \\'(\\':\\n                stack.append(total)\\n                stack.append(sign)\\n                total, sign = 0, 1\\n            elif char == \\')\\':\\n                total *= stack.pop()\\n                total += stack.pop()\\n            elif char == \\'-\\':\\n                sign = -1\\n            p += 1\\n        return total\\n\\n```\\n\\n# ****\\u2714\\uFE0F UP VOTE IF HELPFUL",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```class Solution:\\n    def calculate(self, s: str) -> int:\\n        stack = []\\n        p = 0\\n        sign = 1\\n        total = 0\\n        while p < len(s):\\n            char = s[p]\\n            if char.isdigit():\\n                num = 0\\n                while p < len(s) and s[p].isdigit():\\n                    num = num*10 + int(s[p])\\n                    p += 1\\n                p -= 1\\n                num *= sign\\n                total += num\\n                sign = 1\\n            elif char == \\'(\\':\\n                stack.append(total)\\n                stack.append(sign)\\n                total, sign = 0, 1\\n            elif char == \\')\\':\\n                total *= stack.pop()\\n                total += stack.pop()\\n            elif char == \\'-\\':\\n                sign = -1\\n            p += 1\\n        return total\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2274264,
                "title": "python-solution-beats-97",
                "content": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        stack = []\\n        operand = 0\\n        res = 0 # for the ongoing result\\n        sign = 1 # 1 means +ve, -1 means -ve\\n        \\n        for ch in s:\\n            if ch.isdigit():\\n                operand = operand * 10 + int(ch)\\n            \\n            \\n            elif ch == \\'+\\':\\n                #evaluate expression to the left\\n                res += sign * operand\\n                #save the sign\\n                sign = 1\\n                #reset operand\\n                operand = 0\\n            elif ch == \\'-\\':\\n                res += sign * operand\\n                sign = -1\\n                operand  = 0\\n            \\n            elif ch == \\'(\\':\\n                #push the result and then the sign\\n                stack.append(res)\\n                stack.append(sign)\\n                sign = 1\\n                res = 0\\n            \\n            elif ch == \\')\\':\\n                res += sign * operand\\n                res *= stack.pop()\\n                res += stack.pop()\\n                operand = 0\\n        return res + sign*operand\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        stack = []\\n        operand = 0\\n        res = 0 # for the ongoing result\\n        sign = 1 # 1 means +ve, -1 means -ve\\n        \\n        for ch in s:\\n            if ch.isdigit():\\n                operand = operand * 10 + int(ch)\\n            \\n            \\n            elif ch == \\'+\\':\\n                #evaluate expression to the left\\n                res += sign * operand\\n                #save the sign\\n                sign = 1\\n                #reset operand\\n                operand = 0\\n            elif ch == \\'-\\':\\n                res += sign * operand\\n                sign = -1\\n                operand  = 0\\n            \\n            elif ch == \\'(\\':\\n                #push the result and then the sign\\n                stack.append(res)\\n                stack.append(sign)\\n                sign = 1\\n                res = 0\\n            \\n            elif ch == \\')\\':\\n                res += sign * operand\\n                res *= stack.pop()\\n                res += stack.pop()\\n                operand = 0\\n        return res + sign*operand\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880227,
                "title": "shunting-yard-algorithm-with-unary-reverse-polish-notation-rpn-java",
                "content": "Here\\'s my basic implementation of the Shunting Yard algorithm - https://en.wikipedia.org/wiki/Shunting-yard_algorithm - to convert an infix expression to postfix expression or Reverse Polish Notation (RPN) - https://en.wikipedia.org/wiki/Reverse_Polish_notation - and then evaluating the result. This also handles the unary operator. The same logic can be used for all 3 basic calculator problems - I, II, and III:\\n\\n```\\nclass Solution {\\n    public int calculate(String s) {        \\n        // Shunting Yard algorithm implementation\\n        Queue<String> queue = new ArrayDeque();\\n        Deque<Character> stack = new ArrayDeque();\\n        int len = s.length();        \\n        boolean checkUnary = true;\\n        for (int i = 0; i < len; i++) {\\n            char c = s.charAt(i);\\n            if (Character.isWhitespace(c))\\n                continue;\\n            \\n            if (checkUnary) {\\n                checkUnary = false;\\n                if (c == \\'+\\' || c == \\'-\\')\\n                    queue.add(\"0\");\\n            }\\n            \\n            if (Character.isDigit(c)) {\\n                int num = c - \\'0\\';\\n                while (i + 1 < len && Character.isDigit(s.charAt(i + 1))) {\\n                    num = num * 10 + s.charAt(i + 1) - \\'0\\';\\n                    i++;\\n                }\\n                queue.add(String.valueOf(num));\\n            } else if (c == \\'(\\') {\\n                checkUnary = true;\\n                stack.push(c);\\n            } else if (c == \\')\\') {\\n                while (stack.peek() != \\'(\\')\\n                    queue.add(String.valueOf(stack.pop()));\\n                \\n                stack.pop();\\n            } else {\\n                while (!stack.isEmpty() && stack.peek() != \\'(\\' && getPrecedence(c) <= getPrecedence(stack.peek()))\\n                    queue.add(String.valueOf(stack.pop()));\\n                      \\n                stack.push(c);\\n            }\\n        }\\n        \\n        while (!stack.isEmpty())\\n            queue.add(String.valueOf(stack.pop())); \\n        \\n        // Elements in the queue are now set up in Reverse-Polish notation (RPN)\\n        // So \"2*(5+5*2)/3+(6/2+8)\" is now \"2 5 5 2 * + * 3 / 6 2 / 8 + +\"\\n        \\n        // Evaluate RPN to get the result\\n        return evaluateRPN(queue);\\n    }\\n    \\n    // Operator precedence - PEMDAS rule. All 4 have same left-associativity.\\n    private int getPrecedence(char c) {\\n        if (c == \\'*\\' || c == \\'/\\')\\n            return 2;\\n        else // \\'+\\' or \\'-\\'\\n            return 1;\\n    }\\n    \\n    private int evaluateRPN(Queue<String> queue) {        \\n        Deque<Integer> numstack = new ArrayDeque();\\n        int first = 0, second = 0;\\n        while (!queue.isEmpty()) {\\n            String token = queue.poll();\\n            if (token.equals(\"+\")) {\\n                second = numstack.pop();\\n                first = numstack.pop();\\n                numstack.push(first + second);\\n            } else if (token.equals(\"-\")) {\\n                second = numstack.pop();\\n                first = numstack.pop();\\n                numstack.push(first - second);\\n            } else if (token.equals(\"*\")) {\\n                second = numstack.pop();\\n                first = numstack.pop();\\n                numstack.push(first * second);\\n            } else if (token.equals(\"/\")) {\\n                second = numstack.pop();\\n                first = numstack.pop();\\n                numstack.push(first / second);\\n            } else\\n                numstack.push(Integer.valueOf(token));\\n        }\\n        return numstack.pop();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int calculate(String s) {        \\n        // Shunting Yard algorithm implementation\\n        Queue<String> queue = new ArrayDeque();\\n        Deque<Character> stack = new ArrayDeque();\\n        int len = s.length();        \\n        boolean checkUnary = true;\\n        for (int i = 0; i < len; i++) {\\n            char c = s.charAt(i);\\n            if (Character.isWhitespace(c))\\n                continue;\\n            \\n            if (checkUnary) {\\n                checkUnary = false;\\n                if (c == \\'+\\' || c == \\'-\\')\\n                    queue.add(\"0\");\\n            }\\n            \\n            if (Character.isDigit(c)) {\\n                int num = c - \\'0\\';\\n                while (i + 1 < len && Character.isDigit(s.charAt(i + 1))) {\\n                    num = num * 10 + s.charAt(i + 1) - \\'0\\';\\n                    i++;\\n                }\\n                queue.add(String.valueOf(num));\\n            } else if (c == \\'(\\') {\\n                checkUnary = true;\\n                stack.push(c);\\n            } else if (c == \\')\\') {\\n                while (stack.peek() != \\'(\\')\\n                    queue.add(String.valueOf(stack.pop()));\\n                \\n                stack.pop();\\n            } else {\\n                while (!stack.isEmpty() && stack.peek() != \\'(\\' && getPrecedence(c) <= getPrecedence(stack.peek()))\\n                    queue.add(String.valueOf(stack.pop()));\\n                      \\n                stack.push(c);\\n            }\\n        }\\n        \\n        while (!stack.isEmpty())\\n            queue.add(String.valueOf(stack.pop())); \\n        \\n        // Elements in the queue are now set up in Reverse-Polish notation (RPN)\\n        // So \"2*(5+5*2)/3+(6/2+8)\" is now \"2 5 5 2 * + * 3 / 6 2 / 8 + +\"\\n        \\n        // Evaluate RPN to get the result\\n        return evaluateRPN(queue);\\n    }\\n    \\n    // Operator precedence - PEMDAS rule. All 4 have same left-associativity.\\n    private int getPrecedence(char c) {\\n        if (c == \\'*\\' || c == \\'/\\')\\n            return 2;\\n        else // \\'+\\' or \\'-\\'\\n            return 1;\\n    }\\n    \\n    private int evaluateRPN(Queue<String> queue) {        \\n        Deque<Integer> numstack = new ArrayDeque();\\n        int first = 0, second = 0;\\n        while (!queue.isEmpty()) {\\n            String token = queue.poll();\\n            if (token.equals(\"+\")) {\\n                second = numstack.pop();\\n                first = numstack.pop();\\n                numstack.push(first + second);\\n            } else if (token.equals(\"-\")) {\\n                second = numstack.pop();\\n                first = numstack.pop();\\n                numstack.push(first - second);\\n            } else if (token.equals(\"*\")) {\\n                second = numstack.pop();\\n                first = numstack.pop();\\n                numstack.push(first * second);\\n            } else if (token.equals(\"/\")) {\\n                second = numstack.pop();\\n                first = numstack.pop();\\n                numstack.push(first / second);\\n            } else\\n                numstack.push(Integer.valueOf(token));\\n        }\\n        return numstack.pop();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662949,
                "title": "python-actually-working-shunting-yard-that-passes-all-edge-cases",
                "content": "Many of the existing shunting yard examples do not pass all edge cases. This is a working example, in python, of how we can get it to pass 100%. The problem with the textbook wikipedia implementation and many solutions is we don\\'t treat `-4` separately from `5-4`. So we parse every `-` as an operator, but in some cases, this is not true. \\n\\nWe have two choices on how to move forward:\\n\\n1. Handle unary operators separately\\n2. Massage the string to remove all unary operators\\n\\nI chose option 2, but ideally option 1 is the right answer. \\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        if not s:\\n            return 0\\n        \\n        sanitized = self.sanitize_string(s)\\n        \\n        converted = self.convert_postfix(sanitized)\\n        \\n        return self.process_postfix(converted)\\n    \\n    def convert_postfix(self, tokens: List[str]) -> List[str]:\\n        ans = []\\n        stack = []\\n        # both of the ones below can be extended to support many operation types (*/** etc)\\n        ops = [\"+\", \"-\"]\\n        precedence = { \\'+\\': 1, \\'-\\': 1 }\\n        \\n        for ch in tokens:\\n            if ch.isdigit():\\n                ans.append(ch)\\n            elif ch in ops:\\n                while stack and stack[-1] != \"(\" and precedence[stack[-1]] >= precedence[ch]:\\n                    ans.append(stack.pop())\\n                    \\n                stack.append(ch)\\n            elif ch == \"(\":\\n                stack.append(ch)\\n            elif ch == \")\":\\n                while stack and stack[-1] != \"(\":\\n                    ans.append(stack.pop())\\n                \\n                if stack and stack[-1] == \"(\":\\n                    stack.pop()\\n        while stack:\\n            ans.append(stack.pop())\\n        \\n        return ans\\n        \\n    \\n    def process_postfix(self, tokens: List[str]) -> int:\\n        stack = []\\n        ops = [\"+\", \"-\"]\\n        \\n        for token in tokens:\\n            if token not in ops:\\n                # normal digit\\n                stack.append(token)\\n            else:\\n                # operator\\n                op1 = int(stack.pop())\\n                op2 = int(stack.pop())\\n                \\n                if token == \"+\":\\n                    stack.append(op2 + op1)\\n                elif token == \"-\":\\n                    stack.append(op2 - op1)     \\n\\n        return stack.pop()\\n    \\n    \"\"\"\\n        this is needed to create valid postfix expressions for shunting yard\\n        eg: 1 - (-2) creates a postfix of 1 2 - - which is invalid\\n        instead we convert to 1 0 2 - -\\n    \"\"\"\\n    def sanitize_string(self, s: str) -> List[str]:\\n        # trim whitespace around string\\n        s = s.strip()\\n        \\n        # convert starting - to 0 - X\\n        if s[0] == \"-\":\\n            s = \"0\" + s\\n        \\n        # convert this to create a valid postfix express\\n        s = s.replace(\"(-\", \"(0-\")\\n        \\n        # create space around for splits\\n        for op in \"+-()\":\\n            s = s.replace(op, \\' \\' + op + \\' \\')\\n        \\n        return s.split()\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        if not s:\\n            return 0\\n        \\n        sanitized = self.sanitize_string(s)\\n        \\n        converted = self.convert_postfix(sanitized)\\n        \\n        return self.process_postfix(converted)\\n    \\n    def convert_postfix(self, tokens: List[str]) -> List[str]:\\n        ans = []\\n        stack = []\\n        # both of the ones below can be extended to support many operation types (*/** etc)\\n        ops = [\"+\", \"-\"]\\n        precedence = { \\'+\\': 1, \\'-\\': 1 }\\n        \\n        for ch in tokens:\\n            if ch.isdigit():\\n                ans.append(ch)\\n            elif ch in ops:\\n                while stack and stack[-1] != \"(\" and precedence[stack[-1]] >= precedence[ch]:\\n                    ans.append(stack.pop())\\n                    \\n                stack.append(ch)\\n            elif ch == \"(\":\\n                stack.append(ch)\\n            elif ch == \")\":\\n                while stack and stack[-1] != \"(\":\\n                    ans.append(stack.pop())\\n                \\n                if stack and stack[-1] == \"(\":\\n                    stack.pop()\\n        while stack:\\n            ans.append(stack.pop())\\n        \\n        return ans\\n        \\n    \\n    def process_postfix(self, tokens: List[str]) -> int:\\n        stack = []\\n        ops = [\"+\", \"-\"]\\n        \\n        for token in tokens:\\n            if token not in ops:\\n                # normal digit\\n                stack.append(token)\\n            else:\\n                # operator\\n                op1 = int(stack.pop())\\n                op2 = int(stack.pop())\\n                \\n                if token == \"+\":\\n                    stack.append(op2 + op1)\\n                elif token == \"-\":\\n                    stack.append(op2 - op1)     \\n\\n        return stack.pop()\\n    \\n    \"\"\"\\n        this is needed to create valid postfix expressions for shunting yard\\n        eg: 1 - (-2) creates a postfix of 1 2 - - which is invalid\\n        instead we convert to 1 0 2 - -\\n    \"\"\"\\n    def sanitize_string(self, s: str) -> List[str]:\\n        # trim whitespace around string\\n        s = s.strip()\\n        \\n        # convert starting - to 0 - X\\n        if s[0] == \"-\":\\n            s = \"0\" + s\\n        \\n        # convert this to create a valid postfix express\\n        s = s.replace(\"(-\", \"(0-\")\\n        \\n        # create space around for splits\\n        for op in \"+-()\":\\n            s = s.replace(op, \\' \\' + op + \\' \\')\\n        \\n        return s.split()\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1477423,
                "title": "java-stack-iterative-solution-o-n-time-o-n-space",
                "content": "\\n```\\n  public int calculate(String s) {\\n\\n    Deque<Integer> signs = new ArrayDeque<>();\\n    signs.add(1);\\n\\n    int result = 0;\\n    int sign = 1;\\n\\n    int curr = 0;\\n\\n    for (int i = 0; i < s.length(); i++) {\\n      char currChar = s.charAt(i);\\n\\n      if (Character.isDigit(currChar)) {\\n        curr *= 10;\\n        curr += Character.getNumericValue(currChar);\\n      } else {\\n        result += curr * sign;\\n        curr = 0;\\n      }\\n\\n      if (currChar == \\'-\\') {\\n        sign = signs.peek() * -1;\\n      } else if (currChar == \\'+\\') {\\n        sign = signs.peek();\\n      } else if (currChar == \\'(\\') {\\n        signs.push(sign);\\n      } else if (currChar == \\')\\') {\\n        signs.pop();\\n      }\\n    }\\n\\n    return result + curr * sign;\\n  }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n  public int calculate(String s) {\\n\\n    Deque<Integer> signs = new ArrayDeque<>();\\n    signs.add(1);\\n\\n    int result = 0;\\n    int sign = 1;\\n\\n    int curr = 0;\\n\\n    for (int i = 0; i < s.length(); i++) {\\n      char currChar = s.charAt(i);\\n\\n      if (Character.isDigit(currChar)) {\\n        curr *= 10;\\n        curr += Character.getNumericValue(currChar);\\n      } else {\\n        result += curr * sign;\\n        curr = 0;\\n      }\\n\\n      if (currChar == \\'-\\') {\\n        sign = signs.peek() * -1;\\n      } else if (currChar == \\'+\\') {\\n        sign = signs.peek();\\n      } else if (currChar == \\'(\\') {\\n        signs.push(sign);\\n      } else if (currChar == \\')\\') {\\n        signs.pop();\\n      }\\n    }\\n\\n    return result + curr * sign;\\n  }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 698175,
                "title": "java-clean-code-easy-to-understand-o-n-time-complexity-4-ms-time-95-faster",
                "content": "```\\nclass Solution {\\n \\n\\tpublic int calculate (String s) {\\n\\t\\t\\n\\t\\tStack<Integer> stack = new Stack<>();\\n\\t\\tint evaluation = 0;\\n\\t\\tint operand = 0;\\n\\t\\tint sign = 1;\\n \\n\\t\\tfor (char c : s.toCharArray ()) {\\n\\t\\t\\tif (Character.isDigit (c)) {\\n\\t\\t\\t\\toperand = operand * 10 + c - \\'0\\';\\n\\t\\t\\t}\\n\\t\\t\\telse if (c == \\'+\\') {\\n\\t\\t\\t\\tevaluation += sign * operand;\\n\\t\\t\\t\\toperand = 0;\\n\\t\\t\\t\\tsign = 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (c == \\'-\\') {\\n\\t\\t\\t\\tevaluation += sign * operand;\\n\\t\\t\\t\\tsign = -1;\\n\\t\\t\\t\\toperand = 0;\\n\\t\\t\\t}\\n \\n\\t\\t\\telse if (c == \\'(\\') {\\n\\t\\t\\t\\tstack.push (evaluation);\\n\\t\\t\\t\\tstack.push (sign);\\n\\t\\t\\t\\tevaluation = 0;\\n\\t\\t\\t\\tsign = 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (c == \\')\\') {\\n\\t\\t\\t\\tevaluation += sign * operand;\\n\\t\\t\\t\\tevaluation *= stack.pop ();\\n\\t\\t\\t\\tevaluation += stack.pop ();\\n\\t\\t\\t\\toperand = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n \\n\\t\\treturn evaluation + sign * operand;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n \\n\\tpublic int calculate (String s) {\\n\\t\\t\\n\\t\\tStack<Integer> stack = new Stack<>();\\n\\t\\tint evaluation = 0;\\n\\t\\tint operand = 0;\\n\\t\\tint sign = 1;\\n \\n\\t\\tfor (char c : s.toCharArray ()) {\\n\\t\\t\\tif (Character.isDigit (c)) {\\n\\t\\t\\t\\toperand = operand * 10 + c - \\'0\\';\\n\\t\\t\\t}\\n\\t\\t\\telse if (c == \\'+\\') {\\n\\t\\t\\t\\tevaluation += sign * operand;\\n\\t\\t\\t\\toperand = 0;\\n\\t\\t\\t\\tsign = 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (c == \\'-\\') {\\n\\t\\t\\t\\tevaluation += sign * operand;\\n\\t\\t\\t\\tsign = -1;\\n\\t\\t\\t\\toperand = 0;\\n\\t\\t\\t}\\n \\n\\t\\t\\telse if (c == \\'(\\') {\\n\\t\\t\\t\\tstack.push (evaluation);\\n\\t\\t\\t\\tstack.push (sign);\\n\\t\\t\\t\\tevaluation = 0;\\n\\t\\t\\t\\tsign = 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (c == \\')\\') {\\n\\t\\t\\t\\tevaluation += sign * operand;\\n\\t\\t\\t\\tevaluation *= stack.pop ();\\n\\t\\t\\t\\tevaluation += stack.pop ();\\n\\t\\t\\t\\toperand = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n \\n\\t\\treturn evaluation + sign * operand;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 368944,
                "title": "c-two-stacks-solution-with-clear-explanations",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        // Stack to store numbers\\n        stack<int> nums;\\n        \\n        // Stack to store operators\\n        stack<char> ops;\\n        \\n        for(int i=0; i<s.size(); ++i) {\\n            char ch = s[i];\\n            \\n            // If current is space, skip it\\n            if(ch == \\' \\') continue;\\n            \\n            // If current is a number\\n            else if(isdigit(ch)) {\\n                // Long type to prevent integer overflow\\n                long num = 0;\\n                \\n                while(i<s.size() && isdigit(s[i])) {\\n                    num = num * 10 + s[i] - \\'0\\';\\n                    ++i;\\n                }\\n                nums.push(num);\\n                --i;\\n            }\\n            // If current is left bracket\\n            else if(ch == \\'(\\') ops.push(ch);\\n            \\n            // If current is right bracket\\n            // Solve entire bracket\\n            else if(ch == \\')\\') {\\n                while(!ops.empty() && ops.top() != \\'(\\') {\\n                    int num2 = nums.top();\\n                    nums.pop();\\n                    int num1 = nums.top();\\n                    nums.pop();\\n\\n                    int out = applyOp(num1, num2, ops.top());\\n                    ops.pop();\\n                    nums.push(out);\\n                }\\n                // Pop left bracket\\n                ops.pop();\\n                \\n            }\\n            // If current is an operator\\n            else {\\n                // While top of \\'ops\\' has same or greater  \\n                // precedence to current token, which \\n                // is an operator. Apply operator on top  \\n                // of \\'ops\\' to top two elements in nums stack. \\n                while(!ops.empty() && precedence(ops.top()) >= precedence(ch)) {\\n                    int num2 = nums.top();\\n                    nums.pop();\\n                    int num1 = nums.top();\\n                    nums.pop();\\n\\n                    int out = applyOp(num1, num2, ops.top());\\n                    ops.pop();\\n                    nums.push(out);\\n                }\\n                ops.push(ch);\\n            }\\n        }\\n        \\n        // Entire expression has been parsed at this \\n        // point, apply remaining ops to remaining \\n        // values. \\n        while(!ops.empty()) {\\n            int num2 = nums.top();\\n            nums.pop();\\n            int num1 = nums.top();\\n            nums.pop();\\n\\n            int out = applyOp(num1, num2, ops.top());\\n            ops.pop();\\n            \\n            nums.push(out);\\n        }\\n        \\n        return nums.top();\\n    }\\n    \\n    int applyOp(int a, int b, char op) {\\n        int out = 0;\\n        \\n        switch(op){ \\n            case \\'+\\': out = a + b; break;\\n            case \\'-\\': out = a - b; break;\\n            case \\'*\\': out = a * b; break;\\n            case \\'/\\': out = a / b; break;\\n        }\\n        return out;\\n    }\\n    \\n    int precedence(char op) {\\n        if(op == \\'+\\' || op == \\'-\\') return 1;\\n        else if (op == \\'*\\' || op == \\'/\\') return 2;\\n        else return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        // Stack to store numbers\\n        stack<int> nums;\\n        \\n        // Stack to store operators\\n        stack<char> ops;\\n        \\n        for(int i=0; i<s.size(); ++i) {\\n            char ch = s[i];\\n            \\n            // If current is space, skip it\\n            if(ch == \\' \\') continue;\\n            \\n            // If current is a number\\n            else if(isdigit(ch)) {\\n                // Long type to prevent integer overflow\\n                long num = 0;\\n                \\n                while(i<s.size() && isdigit(s[i])) {\\n                    num = num * 10 + s[i] - \\'0\\';\\n                    ++i;\\n                }\\n                nums.push(num);\\n                --i;\\n            }\\n            // If current is left bracket\\n            else if(ch == \\'(\\') ops.push(ch);\\n            \\n            // If current is right bracket\\n            // Solve entire bracket\\n            else if(ch == \\')\\') {\\n                while(!ops.empty() && ops.top() != \\'(\\') {\\n                    int num2 = nums.top();\\n                    nums.pop();\\n                    int num1 = nums.top();\\n                    nums.pop();\\n\\n                    int out = applyOp(num1, num2, ops.top());\\n                    ops.pop();\\n                    nums.push(out);\\n                }\\n                // Pop left bracket\\n                ops.pop();\\n                \\n            }\\n            // If current is an operator\\n            else {\\n                // While top of \\'ops\\' has same or greater  \\n                // precedence to current token, which \\n                // is an operator. Apply operator on top  \\n                // of \\'ops\\' to top two elements in nums stack. \\n                while(!ops.empty() && precedence(ops.top()) >= precedence(ch)) {\\n                    int num2 = nums.top();\\n                    nums.pop();\\n                    int num1 = nums.top();\\n                    nums.pop();\\n\\n                    int out = applyOp(num1, num2, ops.top());\\n                    ops.pop();\\n                    nums.push(out);\\n                }\\n                ops.push(ch);\\n            }\\n        }\\n        \\n        // Entire expression has been parsed at this \\n        // point, apply remaining ops to remaining \\n        // values. \\n        while(!ops.empty()) {\\n            int num2 = nums.top();\\n            nums.pop();\\n            int num1 = nums.top();\\n            nums.pop();\\n\\n            int out = applyOp(num1, num2, ops.top());\\n            ops.pop();\\n            \\n            nums.push(out);\\n        }\\n        \\n        return nums.top();\\n    }\\n    \\n    int applyOp(int a, int b, char op) {\\n        int out = 0;\\n        \\n        switch(op){ \\n            case \\'+\\': out = a + b; break;\\n            case \\'-\\': out = a - b; break;\\n            case \\'*\\': out = a * b; break;\\n            case \\'/\\': out = a / b; break;\\n        }\\n        return out;\\n    }\\n    \\n    int precedence(char op) {\\n        if(op == \\'+\\' || op == \\'-\\') return 1;\\n        else if (op == \\'*\\' || op == \\'/\\') return 2;\\n        else return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190148,
                "title": "python-stack-solution",
                "content": "```\\nclass Solution(object):\\n    def calculate(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        for ch in [\\'+\\', \\'-\\', \\'(\\', \\')\\']:\\n            s = s.replace(ch, \\' \\' + ch + \\' \\')\\n\\n        sign = 1\\n        stack = [0]\\n        for each in s.split():\\n            if each in [\\'+\\', \\'-\\']:\\n                sign = [1, -1][each == \\'-\\']\\n            elif each == \\'(\\':\\n                stack.extend([sign, 0])\\n                sign = 1\\n            elif each == \\')\\':\\n                value = stack.pop() * stack.pop()\\n                stack[-1] += value\\n            else:\\n                stack[-1] += sign * int(each)\\n        return stack[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def calculate(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        for ch in [\\'+\\', \\'-\\', \\'(\\', \\')\\']:\\n            s = s.replace(ch, \\' \\' + ch + \\' \\')\\n\\n        sign = 1\\n        stack = [0]\\n        for each in s.split():\\n            if each in [\\'+\\', \\'-\\']:\\n                sign = [1, -1][each == \\'-\\']\\n            elif each == \\'(\\':\\n                stack.extend([sign, 0])\\n                sign = 1\\n            elif each == \\')\\':\\n                value = stack.pop() * stack.pop()\\n                stack[-1] += value\\n            else:\\n                stack[-1] += sign * int(each)\\n        return stack[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62401,
                "title": "general-kill-reverse-polish-notation",
                "content": "This kind of problems has a general kill. First [convert the infix notation into postfix notation](https://en.wikipedia.org/wiki/Shunting-yard_algorithm), and then [compute the postfix notation](https://en.wikipedia.org/wiki/Reverse_Polish_notation).\\n\\n```\\nfrom collections import deque\\n\\n\\nclass Solution(object):\\n    def calculate(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        def infix_to_postfix(s):\\n            S = deque()\\n            t = []\\n            n = len(s)\\n            i = 0\\n            while i < n:\\n                c = s[i]\\n                if c.isdigit():\\n                    j = i\\n                    while j < n and s[j].isdigit():\\n                        j += 1\\n                    t.append(s[i:j])\\n                    i = j\\n                elif c == '(':\\n                    S.append(c)\\n                    i += 1\\n                elif c == ')':\\n                    while S[-1] != '(':\\n                        t.append(S.pop())\\n                    S.pop()\\n                    i += 1\\n                else:  # operators\\n                    while S and S[-1] != '(' and w[S[-1]] >= w[c]:\\n                        t.append(S.pop())\\n                    S.append(c)\\n                    i += 1\\n            while S:\\n                t.append(S.pop())\\n            return t\\n\\n        def eval_postfix(t):\\n            S = deque()\\n            for item in t:\\n                if item[0].isdigit():\\n                    S.append(item)\\n                else:\\n                    op2 = int(S.pop())\\n                    op1 = int(S.pop())\\n                    if item == '+':\\n                        S.append(op1+op2)\\n                    elif item == '-':\\n                        S.append(op1-op2)\\n                    else:  # *\\n                        S.append(op1*op2)\\n            return int(S[-1])\\n\\n        s = s.replace(' ', '')\\n        if not s:\\n            return 0\\n        w = {'+': 1, '-': 1, '*': 2}\\n        return eval_postfix(infix_to_postfix(s))\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\n\\n\\nclass Solution(object):\\n    def calculate(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        def infix_to_postfix(s):\\n            S = deque()\\n            t = []\\n            n = len(s)\\n            i = 0\\n            while i < n:\\n                c = s[i]\\n                if c.isdigit():\\n                    j = i\\n                    while j < n and s[j].isdigit():\\n                        j += 1\\n                    t.append(s[i:j])\\n                    i = j\\n                elif c == '(':\\n                    S.append(c)\\n                    i += 1\\n                elif c == ')':\\n                    while S[-1] != '(':\\n                        t.append(S.pop())\\n                    S.pop()\\n                    i += 1\\n                else:  # operators\\n                    while S and S[-1] != '(' and w[S[-1]] >= w[c]:\\n                        t.append(S.pop())\\n                    S.append(c)\\n                    i += 1\\n            while S:\\n                t.append(S.pop())\\n            return t\\n\\n        def eval_postfix(t):\\n            S = deque()\\n            for item in t:\\n                if item[0].isdigit():\\n                    S.append(item)\\n                else:\\n                    op2 = int(S.pop())\\n                    op1 = int(S.pop())\\n                    if item == '+':\\n                        S.append(op1+op2)\\n                    elif item == '-':\\n                        S.append(op1-op2)\\n                    else:  # *\\n                        S.append(op1*op2)\\n            return int(S[-1])\\n\\n        s = s.replace(' ', '')\\n        if not s:\\n            return 0\\n        w = {'+': 1, '-': 1, '*': 2}\\n        return eval_postfix(infix_to_postfix(s))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62465,
                "title": "python-192ms-solution-with-stack",
                "content": "    class Solution(object):\\n        def calculate(self, s):\\n            nums = []\\n            sign = 1\\n            num = 0\\n            rst = 0\\n        \\n            for c in s:\\n                if c.isdigit():\\n                    num = num*10 + int(c)\\n                    continue\\n                rst += sign*num\\n                num = 0\\n            \\n                if c == \"-\": sign = -1\\n                elif c == \"+\": sign = 1\\n                elif c == \"(\":\\n                    nums.append(rst)\\n                    nums.append(sign)\\n                    sign = 1\\n                    rst = 0\\n                elif c == \")\":\\n                    rst *= nums.pop()\\n                    rst += nums.pop()\\n\\n            return rst + sign * num",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def calculate(self, s):\\n            nums = []\\n            sign = 1\\n            num = 0\\n            rst = 0\\n        \\n            for c in s:\\n                if c.isdigit():\\n                    num = num*10 + int(c)\\n                    continue\\n                rst += sign*num\\n                num = 0\\n            \\n                if c == \"-\": sign = -1\\n                elif c == \"+\": sign = 1\\n                elif c == \"(\":\\n                    nums.append(rst)\\n                    nums.append(sign)\\n                    sign = 1\\n                    rst = 0\\n                elif c == \")\":\\n                    rst *= nums.pop()\\n                    rst += nums.pop()\\n\\n            return rst + sign * num",
                "codeTag": "Java"
            },
            {
                "id": 62488,
                "title": "1-pass-o-n-c-solution",
                "content": "A plus sign can be ignored since it has no effect.\\nA minus sign negates the signs contained within a pair of parentheses. \\n\\nA ')' matches the nearest '(', so we can use a stack structure to keep track of the negation context.\\nWhen we encounter '(', save the current context and negate it.\\nWhen ')', restore the previous context.\\n\\n    #include<cstdlib>\\n    #include<string>\\n    #include<vector>\\n    using namespace std;\\n    class Solution {\\n    public:\\n        int calculate(string s) {\\n            typedef long long ll;\\n            vector<int> ctx;\\n            int contextNumberMult = 1;\\n            int localNumberMult = 1;\\n            int ans=0;\\n            for (const char *x = s.c_str();*x;x++){\\n                switch(*x){\\n                case '-':\\n                    localNumberMult = -1;\\n                    break;\\n                case '(':\\n                    contextNumberMult *= localNumberMult;\\n                    ctx.push_back(localNumberMult);\\n                    localNumberMult = 1;\\n                    break;\\n                case ')':\\n                    contextNumberMult *= ctx.back();\\n                    ctx.pop_back();\\n                case ' ':\\n                case '+':\\n                    break;\\n                default:{\\n                    char *end;\\n                    ll n=strtol(x,&end,10);\\n                    ans += n * contextNumberMult  * localNumberMult ;\\n                    localNumberMult = 1;\\n                    x = end-1;\\n                }}\\n            }\\n            return ans;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int calculate(string s) {\\n            typedef long long ll;\\n            vector<int> ctx;\\n            int contextNumberMult = 1;\\n            int localNumberMult = 1;\\n            int ans=0;\\n            for (const char *x = s.c_str();*x;x++){\\n                switch(*x){\\n                case '-':\\n                    localNumberMult = -1;\\n                    break;\\n                case '(':\\n                    contextNumberMult *= localNumberMult;\\n                    ctx.push_back(localNumberMult);\\n                    localNumberMult = 1;\\n                    break;\\n                case ')':\\n                    contextNumberMult *= ctx.back();\\n                    ctx.pop_back();\\n                case ' ':\\n                case '+':\\n                    break;\\n                default:{\\n                    char *end;\\n                    ll n=strtol(x,&end,10);\\n                    ans += n * contextNumberMult  * localNumberMult ;\\n                    localNumberMult = 1;\\n                    x = end-1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3871086,
                "title": "simple-solution-using-stack-and-without-recursion",
                "content": "# Intuition\\nExpression inside the brackets should be evaluated first.\\n# Approach\\nTo solve this problem, first you need to have knowledge to make a calculator without brackets.\\n\\nHere: -\\nFunction \"solve\" just solve any regular expression like: -\\n 21 + 3 - 6;\\nThis function doesn\\'t get \"(\" and \")\" as input.\\n\\nSteps: -\\n1. First convert all the numbers, brackets, operators into     string and store in a vector.\\n2. Traverse the vector from left to right and when we encounter \")\" search for \"(\" in the stack and store strings between these brackets in a different vector.\\n3. Call for solve function with this vector.\\n4. continue this until no brackets remains.\\n5. at last a simple expression will be there without any brackets, call for solve and return this.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2).\\n- Space complexity:\\nO(n).\\n# Code\\n```\\nclass Solution {\\npublic:\\n  string solve(vector<string>v){\\n    stack<string>st;\\n    for(int i=0;i<v.size();i++){\\n      if(v[i] == \"-\"){\\n        int x = 0;\\n        if(st.empty() == false){\\n          x = stoi(st.top());\\n          st.pop();\\n        }\\n        int y = stoi(v[i+1]);\\n        st.push(to_string(x-y));\\n        i++;\\n      }else if(v[i] ==\"+\"){\\n        int x = 0;\\n        if(st.empty() == false){\\n          x = stoi(st.top());\\n          st.pop();\\n        }\\n        int y = stoi(v[i+1]);\\n        st.push(to_string(x+y));\\n        i++;\\n      }else{\\n        st.push(v[i]);\\n      }\\n    }\\n    return st.top();\\n  }\\n  int calculate(string s) {\\n    vector<string>nums;\\n    string temp;\\n//--------------------------------------------------//\\n/*\\n  removed unnecessary spaces and converted each element to \\n  string and stored in a vector.\\n*/\\n    for(int i=0;i<s.size();i++){\\n      if(s[i] == \\' \\'){\\n        continue;\\n      }\\n      if(isdigit(s[i])){\\n        temp += s[i];\\n      }else{\\n        if(temp.empty() == false){\\n          nums.push_back(temp);\\n        }\\n        string t;\\n        t += s[i];\\n        nums.push_back(t);\\n        temp.clear();\\n      }\\n    }\\n    if(temp.empty() == false){\\n      nums.push_back(temp);\\n    }\\n//--------------------------------------------------//\\n    stack<string>st;\\n    for(int i=0;i<nums.size();i++){\\n      vector<string>t;\\n      if(nums[i] == \")\"){\\n        while(st.empty() == false && st.top() != \"(\"){\\n          t.push_back(st.top());\\n          st.pop();\\n        }\\n        st.pop();\\n        reverse(t.begin(),t.end());\\n        string ans = solve(t);\\n        st.push(ans);\\n      }else{\\n        st.push(nums[i]);\\n      }\\n    }\\n    vector<string>v1;\\n    while(st.empty() == false){\\n      v1.push_back(st.top());\\n      st.pop();\\n    }\\n    reverse(v1.begin(),v1.end());\\n    return stoi(solve(v1));\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  string solve(vector<string>v){\\n    stack<string>st;\\n    for(int i=0;i<v.size();i++){\\n      if(v[i] == \"-\"){\\n        int x = 0;\\n        if(st.empty() == false){\\n          x = stoi(st.top());\\n          st.pop();\\n        }\\n        int y = stoi(v[i+1]);\\n        st.push(to_string(x-y));\\n        i++;\\n      }else if(v[i] ==\"+\"){\\n        int x = 0;\\n        if(st.empty() == false){\\n          x = stoi(st.top());\\n          st.pop();\\n        }\\n        int y = stoi(v[i+1]);\\n        st.push(to_string(x+y));\\n        i++;\\n      }else{\\n        st.push(v[i]);\\n      }\\n    }\\n    return st.top();\\n  }\\n  int calculate(string s) {\\n    vector<string>nums;\\n    string temp;\\n//--------------------------------------------------//\\n/*\\n  removed unnecessary spaces and converted each element to \\n  string and stored in a vector.\\n*/\\n    for(int i=0;i<s.size();i++){\\n      if(s[i] == \\' \\'){\\n        continue;\\n      }\\n      if(isdigit(s[i])){\\n        temp += s[i];\\n      }else{\\n        if(temp.empty() == false){\\n          nums.push_back(temp);\\n        }\\n        string t;\\n        t += s[i];\\n        nums.push_back(t);\\n        temp.clear();\\n      }\\n    }\\n    if(temp.empty() == false){\\n      nums.push_back(temp);\\n    }\\n//--------------------------------------------------//\\n    stack<string>st;\\n    for(int i=0;i<nums.size();i++){\\n      vector<string>t;\\n      if(nums[i] == \")\"){\\n        while(st.empty() == false && st.top() != \"(\"){\\n          t.push_back(st.top());\\n          st.pop();\\n        }\\n        st.pop();\\n        reverse(t.begin(),t.end());\\n        string ans = solve(t);\\n        st.push(ans);\\n      }else{\\n        st.push(nums[i]);\\n      }\\n    }\\n    vector<string>v1;\\n    while(st.empty() == false){\\n      v1.push_back(st.top());\\n      st.pop();\\n    }\\n    reverse(v1.begin(),v1.end());\\n    return stoi(solve(v1));\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674943,
                "title": "easy-c-solution-beats-98-3",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n\\n        int n = s.length();\\n\\n        stack<int> st;\\n\\n        int number = 0;\\n        int result = 0;\\n        int sign = 1; // consider positive at the start\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            if(isdigit(s[i]))\\n            {\\n                number = number*10 + (s[i]-\\'0\\');\\n            }\\n            else if(s[i]==\\'+\\')\\n            {\\n                result+= (number*sign);\\n                number = 0;\\n                sign = 1;\\n            }\\n            else if(s[i]==\\'-\\')\\n            {\\n                result+= (number*sign);\\n                number = 0;\\n                sign = -1;\\n            }\\n            else if(s[i]==\\'(\\')\\n            {\\n                st.push(result);\\n                st.push(sign);\\n                result = 0;\\n                number = 0; \\n                sign = 1;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                result += (number*sign);\\n                number = 0;\\n\\n                int stack_sign = st.top();\\n                st.pop();\\n                int last_result = st.top();\\n                st.pop();\\n\\n                result *= stack_sign;\\n                result += last_result;\\n            }\\n        }\\n\\n        result += (number*sign );\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n\\n        int n = s.length();\\n\\n        stack<int> st;\\n\\n        int number = 0;\\n        int result = 0;\\n        int sign = 1; // consider positive at the start\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            if(isdigit(s[i]))\\n            {\\n                number = number*10 + (s[i]-\\'0\\');\\n            }\\n            else if(s[i]==\\'+\\')\\n            {\\n                result+= (number*sign);\\n                number = 0;\\n                sign = 1;\\n            }\\n            else if(s[i]==\\'-\\')\\n            {\\n                result+= (number*sign);\\n                number = 0;\\n                sign = -1;\\n            }\\n            else if(s[i]==\\'(\\')\\n            {\\n                st.push(result);\\n                st.push(sign);\\n                result = 0;\\n                number = 0; \\n                sign = 1;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                result += (number*sign);\\n                number = 0;\\n\\n                int stack_sign = st.top();\\n                st.pop();\\n                int last_result = st.top();\\n                st.pop();\\n\\n                result *= stack_sign;\\n                result += last_result;\\n            }\\n        }\\n\\n        result += (number*sign );\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570931,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public int calculate(String s) {\\n    Stack<Integer> stack = new Stack<Integer>();\\n    int result = 0;\\n    int number = 0;\\n    int sign = 1;\\n    for(int i = 0; i < s.length(); i++){\\n        char c = s.charAt(i);\\n        if(Character.isDigit(c)){\\n            number = 10 * number + (int)(c - \\'0\\');\\n        }else if(c == \\'+\\'){\\n            result += sign * number;\\n            number = 0;\\n            sign = 1;\\n        }else if(c == \\'-\\'){\\n            result += sign * number;\\n            number = 0;\\n            sign = -1;\\n        }else if(c == \\'(\\'){\\n            //we push the result first, then sign;\\n            stack.push(result);\\n            stack.push(sign);\\n            //reset the sign and result for the value in the parenthesis\\n            sign = 1;   \\n            result = 0;\\n        }else if(c == \\')\\'){\\n            result += sign * number;  \\n            number = 0;\\n            result *= stack.pop();    //stack.pop() is the sign before the parenthesis\\n            result += stack.pop();   //stack.pop() now is the result calculated before the parenthesis\\n            \\n        }\\n    }\\n    if(number != 0) result += sign * number;\\n    return result;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int calculate(String s) {\\n    Stack<Integer> stack = new Stack<Integer>();\\n    int result = 0;\\n    int number = 0;\\n    int sign = 1;\\n    for(int i = 0; i < s.length(); i++){\\n        char c = s.charAt(i);\\n        if(Character.isDigit(c)){\\n            number = 10 * number + (int)(c - \\'0\\');\\n        }else if(c == \\'+\\'){\\n            result += sign * number;\\n            number = 0;\\n            sign = 1;\\n        }else if(c == \\'-\\'){\\n            result += sign * number;\\n            number = 0;\\n            sign = -1;\\n        }else if(c == \\'(\\'){\\n            //we push the result first, then sign;\\n            stack.push(result);\\n            stack.push(sign);\\n            //reset the sign and result for the value in the parenthesis\\n            sign = 1;   \\n            result = 0;\\n        }else if(c == \\')\\'){\\n            result += sign * number;  \\n            number = 0;\\n            result *= stack.pop();    //stack.pop() is the sign before the parenthesis\\n            result += stack.pop();   //stack.pop() now is the result calculated before the parenthesis\\n            \\n        }\\n    }\\n    if(number != 0) result += sign * number;\\n    return result;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871262,
                "title": "eval",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar calculate = function(s) \\n{\\n    return eval(s);\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar calculate = function(s) \\n{\\n    return eval(s);\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2834342,
                "title": "easy-understanding-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int n=s.size();\\n        int sum=0;\\n        int sign=1;\\n  \\n        stack<int>st;\\n        for(int i=0;i<n;i++){\\n            if(s[i]>=\\'0\\' && s[i]<=\\'9\\'){\\n                int num=0;\\n                while(s.size()>i && s[i]>=\\'0\\' && s[i]<=\\'9\\'){\\n                    num=num*10+(s[i]-\\'0\\');\\n                    i++;\\n                }\\n                sum+=num*sign;\\n                i--;\\n            }\\n            else if(s[i]==\\'+\\'){\\n                sign=1;\\n            }\\n            else if(s[i]==\\'-\\'){\\n                sign=-1;\\n            }\\n            else if(s[i]==\\'(\\'){\\n                st.push(sum);\\n                st.push(sign);\\n                sum=0;\\n                sign=1;\\n            }\\n            else if(s[i]==\\')\\'){\\n                sum=st.top()*sum;\\n                st.pop();\\n                sum+=st.top();\\n                st.pop();          \\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int n=s.size();\\n        int sum=0;\\n        int sign=1;\\n  \\n        stack<int>st;\\n        for(int i=0;i<n;i++){\\n            if(s[i]>=\\'0\\' && s[i]<=\\'9\\'){\\n                int num=0;\\n                while(s.size()>i && s[i]>=\\'0\\' && s[i]<=\\'9\\'){\\n                    num=num*10+(s[i]-\\'0\\');\\n                    i++;\\n                }\\n                sum+=num*sign;\\n                i--;\\n            }\\n            else if(s[i]==\\'+\\'){\\n                sign=1;\\n            }\\n            else if(s[i]==\\'-\\'){\\n                sign=-1;\\n            }\\n            else if(s[i]==\\'(\\'){\\n                st.push(sum);\\n                st.push(sign);\\n                sum=0;\\n                sign=1;\\n            }\\n            else if(s[i]==\\')\\'){\\n                sum=st.top()*sum;\\n                st.pop();\\n                sum+=st.top();\\n                st.pop();          \\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834273,
                "title": "golang-100-100",
                "content": "```\\nfunc calculate(s string) int {\\n\\tresult, _ := calculateFrom(s, 0)\\n\\treturn result\\n}\\n\\nfunc calculateFrom(s string, idFrom int) (result, idEnd int) {\\n\\tresult, currNum, sign := 0, 0, 1\\n\\n\\tfor idEnd = idFrom; idEnd < len(s) && s[idEnd] != \\')\\'; idEnd++ {\\n\\t\\tswitch {\\n\\t\\tcase s[idEnd] >= \\'0\\':\\n\\t\\t\\tcurrNum = currNum*10 + int(s[idEnd]-\\'0\\')\\n\\t\\tcase s[idEnd] == \\'(\\':\\n\\t\\t\\tcurrNum, idEnd = calculateFrom(s, idEnd+1)\\n\\t\\tcase s[idEnd] == \\'-\\' || s[idEnd] == \\'+\\':\\n\\t\\t\\tresult, currNum = result+currNum*sign, 0\\n\\t\\t\\tsign = 44 - int(s[idEnd]) // \\'-\\'=45; \\'+\\'=43\\n\\t\\t}\\n\\t}\\n\\n\\treturn result + currNum*sign, idEnd\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc calculate(s string) int {\\n\\tresult, _ := calculateFrom(s, 0)\\n\\treturn result\\n}\\n\\nfunc calculateFrom(s string, idFrom int) (result, idEnd int) {\\n\\tresult, currNum, sign := 0, 0, 1\\n\\n\\tfor idEnd = idFrom; idEnd < len(s) && s[idEnd] != \\')\\'; idEnd++ {\\n\\t\\tswitch {\\n\\t\\tcase s[idEnd] >= \\'0\\':\\n\\t\\t\\tcurrNum = currNum*10 + int(s[idEnd]-\\'0\\')\\n\\t\\tcase s[idEnd] == \\'(\\':\\n\\t\\t\\tcurrNum, idEnd = calculateFrom(s, idEnd+1)\\n\\t\\tcase s[idEnd] == \\'-\\' || s[idEnd] == \\'+\\':\\n\\t\\t\\tresult, currNum = result+currNum*sign, 0\\n\\t\\t\\tsign = 44 - int(s[idEnd]) // \\'-\\'=45; \\'+\\'=43\\n\\t\\t}\\n\\t}\\n\\n\\treturn result + currNum*sign, idEnd\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2834230,
                "title": "java-easy-solution-using-stack-o-n-90-100-faster",
                "content": "# Iterative 90% Faster\\n```\\nclass Solution {\\n    public int calculate(String s) {\\n        int result = 0,sign = 1;\\n        Stack<Integer> stack = new Stack<>();\\n        \\n        for(int i = 0 ; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n            \\n            if(Character.isDigit(ch)){\\n                int num = 0;\\n                while(i < s.length() && Character.isDigit(s.charAt(i))){\\n                    num = num * 10 + (s.charAt(i) - \\'0\\');\\n                    i++;\\n                }\\n                i--;\\n                num = num * sign;\\n                sign = 1;\\n                result += num;\\n            }else if(ch == \\'(\\'){\\n                stack.push(result);\\n                stack.push(sign);\\n                result = 0;\\n                sign = 1;\\n            }else  if( ch == \\')\\'){\\n                result *= stack.pop();\\n                result += stack.pop();\\n                \\n            }else if(ch == \\'+\\'){\\n                sign = 1;\\n            }else if( ch == \\'-\\'){\\n                sign = -1;\\n            }else{\\n                continue;\\n            }\\n        }\\n    return result;\\n    }\\n}\\n```\\n# Recursive 100% Faster 2ms\\n```\\nclass Solution {\\n    int idx; // this index traverse the string in one pass, between different level of recursion\\n    public int calculate(String s) {\\n        idx = 0; // Initialization should be here\\n        return calc(s);\\n    }\\n    \\n    private int calc(String s) {\\n        int res = 0, num = 0, sign = 1;\\n        while (idx < s.length()) {\\n            char c = s.charAt(idx++);\\n            if (c >= \\'0\\' && c <= \\'9\\') num = num * 10 + c - \\'0\\';\\n            else if (c == \\'(\\') num = calc(s); // ( is start of a new sub-problem, Let recursion solve the sub-problem\\n            else if (c == \\')\\') return res + sign * num;\\n            else if (c == \\'+\\' || c == \\'-\\') { // only when we meet a new sign, we know a while number has been read\\n                res += sign * num;\\n                num = 0;\\n                sign = c == \\'-\\' ? -1 : 1;\\n            }\\n        }\\n        return res + sign * num; // last number is not processed yet\\n    }\\n}\\n```\\n**please Upvote**",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        int result = 0,sign = 1;\\n        Stack<Integer> stack = new Stack<>();\\n        \\n        for(int i = 0 ; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n            \\n            if(Character.isDigit(ch)){\\n                int num = 0;\\n                while(i < s.length() && Character.isDigit(s.charAt(i))){\\n                    num = num * 10 + (s.charAt(i) - \\'0\\');\\n                    i++;\\n                }\\n                i--;\\n                num = num * sign;\\n                sign = 1;\\n                result += num;\\n            }else if(ch == \\'(\\'){\\n                stack.push(result);\\n                stack.push(sign);\\n                result = 0;\\n                sign = 1;\\n            }else  if( ch == \\')\\'){\\n                result *= stack.pop();\\n                result += stack.pop();\\n                \\n            }else if(ch == \\'+\\'){\\n                sign = 1;\\n            }else if( ch == \\'-\\'){\\n                sign = -1;\\n            }else{\\n                continue;\\n            }\\n        }\\n    return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int idx; // this index traverse the string in one pass, between different level of recursion\\n    public int calculate(String s) {\\n        idx = 0; // Initialization should be here\\n        return calc(s);\\n    }\\n    \\n    private int calc(String s) {\\n        int res = 0, num = 0, sign = 1;\\n        while (idx < s.length()) {\\n            char c = s.charAt(idx++);\\n            if (c >= \\'0\\' && c <= \\'9\\') num = num * 10 + c - \\'0\\';\\n            else if (c == \\'(\\') num = calc(s); // ( is start of a new sub-problem, Let recursion solve the sub-problem\\n            else if (c == \\')\\') return res + sign * num;\\n            else if (c == \\'+\\' || c == \\'-\\') { // only when we meet a new sign, we know a while number has been read\\n                res += sign * num;\\n                num = 0;\\n                sign = c == \\'-\\' ? -1 : 1;\\n            }\\n        }\\n        return res + sign * num; // last number is not processed yet\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834192,
                "title": "java-code-using-stack-easy-implementation-with-explanation-line-by-line",
                "content": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        int n = s.length();\\n        int sum = 0;\\n        int sign = 1;\\n        Stack<Integer> st = new Stack<Integer>();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n             // number\\n            if(s.charAt(i)>=\\'0\\' &&  s.charAt(i)<=\\'9\\')\\n            {\\n                int num = 0;\\n                while(i<n && s.charAt(i)>=\\'0\\' && s.charAt(i)<=\\'9\\' )    //Eg: 125  (it will work for single and multiple digit number )\\n                {\\n                    num =num*10 + (s.charAt(i)-\\'0\\') ;    //we are converting Character to Integer by subtracting ASCII value of Char \\'0\\'\\n                    i++;\\n                }\\n                sum = sum + num*sign;    // eg: sum = sum + 125*(+1) =125\\n                i--;                    // we are doing  i-- becoz in last step we have gone to next value by incrementing i.e i++\\n            }\\n            \\n            else if(s.charAt(i)==\\'+\\'){\\n                sign = 1;\\n            }\\n            \\n            else if(s.charAt(i)==\\'-\\'){  \\n                sign = -1;\\n            }\\n            \\n            else if(s.charAt(i)==\\'(\\'){     // when there is opening bracket - push SUM in stack , and Push sign(+ve,-ve) in Stack . NOTE: For +ve ( we use +1 ) , for -ve (we use -1)\\n                st.push(sum);\\n                st.push(sign);\\n                sum=0;\\n                sign=1;\\n            }\\n            \\n            else if(s.charAt(i)==\\')\\') {          // when there is closing bracket- 1st pop SIGN (1 or -1 ) using st.pop(). Secondly pop Number that is present .\\n                sum = sum*st.pop();           //multiply number with sign -1 or +1\\n                sum = sum + st.pop();\\n            }\\n            \\n        }//forLoop_End\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        int n = s.length();\\n        int sum = 0;\\n        int sign = 1;\\n        Stack<Integer> st = new Stack<Integer>();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n             // number\\n            if(s.charAt(i)>=\\'0\\' &&  s.charAt(i)<=\\'9\\')\\n            {\\n                int num = 0;\\n                while(i<n && s.charAt(i)>=\\'0\\' && s.charAt(i)<=\\'9\\' )    //Eg: 125  (it will work for single and multiple digit number )\\n                {\\n                    num =num*10 + (s.charAt(i)-\\'0\\') ;    //we are converting Character to Integer by subtracting ASCII value of Char \\'0\\'\\n                    i++;\\n                }\\n                sum = sum + num*sign;    // eg: sum = sum + 125*(+1) =125\\n                i--;                    // we are doing  i-- becoz in last step we have gone to next value by incrementing i.e i++\\n            }\\n            \\n            else if(s.charAt(i)==\\'+\\'){\\n                sign = 1;\\n            }\\n            \\n            else if(s.charAt(i)==\\'-\\'){  \\n                sign = -1;\\n            }\\n            \\n            else if(s.charAt(i)==\\'(\\'){     // when there is opening bracket - push SUM in stack , and Push sign(+ve,-ve) in Stack . NOTE: For +ve ( we use +1 ) , for -ve (we use -1)\\n                st.push(sum);\\n                st.push(sign);\\n                sum=0;\\n                sign=1;\\n            }\\n            \\n            else if(s.charAt(i)==\\')\\') {          // when there is closing bracket- 1st pop SIGN (1 or -1 ) using st.pop(). Secondly pop Number that is present .\\n                sum = sum*st.pop();           //multiply number with sign -1 or +1\\n                sum = sum + st.pop();\\n            }\\n            \\n        }//forLoop_End\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400438,
                "title": "calculator-i-ii-iii-with-one-recursive-template",
                "content": "One template to solve all the calculator problems\\n\\n1. when we have \\'(\\' => we go into the recursion call\\n2. when we have num => process the num\\n3. All we left now is the operators => Handle the current num; \\nIf we have \\'*\\' and \\'/\\', we can use a stack (or a vector) to calculate the result\\nAnd we have to update the current operator in the end\\n\\n**Calculator I**\\nwe have \\'+\\', \\'-\\', and \\'(\\' & \\')\\'\\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int i = 0;\\n        return parseExpr(s, i);\\n    }\\n    \\n    int parseExpr(string& s, int& i) {\\n        int res = 0;\\n        char op = \\'+\\';\\n        for (; i < s.length() && op != \\')\\'; i++) {\\n            if (s[i] == \\' \\') continue;\\n            int n = s[i] == \\'(\\' ? parseExpr(s, ++i) : parseNum(s, i);\\n\\t\\t\\t\\n\\t\\t\\t// put the number into the result\\n            switch(op) {\\n                case \\'+\\' : res += n; break;\\n                case \\'-\\' : res -= n; break;\\n            }\\n\\t\\t\\t// +, -, ) left\\n            op = s[i];\\n        }\\n        return res;\\n    }\\n    \\n    int parseNum(string& s, int& i) {\\n        int n = 0;\\n        while(i < s.length() && isdigit(s[i]))\\n            n = s[i++] - \\'0\\' + 10 * n;\\n        return n;\\n    }\\n};\\n```\\n\\n**Calculator II**\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int i = 0;\\n        return parseExpr(s, i);\\n    }\\n    \\n    int parseExpr(string& s, int& i) {\\n        vector<int> nums;\\n        char op = \\'+\\';\\n        for (; i < s.length(); i++) {\\n            if (s[i] == \\' \\') continue;\\n            int n = parseNum(s, i);\\n            switch(op) {\\n                case \\'+\\' : nums.push_back(n); break;\\n                case \\'-\\' : nums.push_back(-n); break;\\n                case \\'*\\' : nums.back() *= n; break;\\n                case \\'/\\' : nums.back() /= n; break;\\n            }            \\n            op = s[i];\\n        }\\n        return accumulate(nums.begin(), nums.end(), 0);\\n    }\\n    \\n    int parseNum(string& s, int& i) {\\n        int n = 0;\\n        while(i < s.length() && isdigit(s[i]))\\n            n = s[i++] - \\'0\\' + 10 * n;\\n        return n;\\n    }\\n};\\n```\\n**Calculator III**\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int i = 0;\\n        return parseExpr(s, i);\\n    }\\n    \\n    int parseExpr(string& s, int& i) {\\n        vector<int> nums;\\n        char op = \\'+\\';\\n        for (; i < s.length() && op != \\')\\'; i++) {\\n            if (s[i] == \\' \\') continue;\\n            int n = s[i] == \\'(\\' ? parseExpr(s, ++i) : parseNum(s, i);\\n            switch(op) {\\n                case \\'+\\' : nums.push_back(n); break;\\n                case \\'-\\' : nums.push_back(-n); break;\\n                case \\'*\\' : nums.back() *= n; break;\\n                case \\'/\\' : nums.back() /= n; break;\\n            }            \\n            op = s[i];\\n        }\\n        return accumulate(nums.begin(), nums.end(), 0);\\n    }\\n    \\n     int parseNum(string& s, int& i) {     \\n        int n = 0;\\n        while(i < s.length() && isdigit(s[i]))\\n            n = s[i++] - \\'0\\' + 10 * n;\\n        return n;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int i = 0;\\n        return parseExpr(s, i);\\n    }\\n    \\n    int parseExpr(string& s, int& i) {\\n        int res = 0;\\n        char op = \\'+\\';\\n        for (; i < s.length() && op != \\')\\'; i++) {\\n            if (s[i] == \\' \\') continue;\\n            int n = s[i] == \\'(\\' ? parseExpr(s, ++i) : parseNum(s, i);\\n\\t\\t\\t\\n\\t\\t\\t// put the number into the result\\n            switch(op) {\\n                case \\'+\\' : res += n; break;\\n                case \\'-\\' : res -= n; break;\\n            }\\n\\t\\t\\t// +, -, ) left\\n            op = s[i];\\n        }\\n        return res;\\n    }\\n    \\n    int parseNum(string& s, int& i) {\\n        int n = 0;\\n        while(i < s.length() && isdigit(s[i]))\\n            n = s[i++] - \\'0\\' + 10 * n;\\n        return n;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int i = 0;\\n        return parseExpr(s, i);\\n    }\\n    \\n    int parseExpr(string& s, int& i) {\\n        vector<int> nums;\\n        char op = \\'+\\';\\n        for (; i < s.length(); i++) {\\n            if (s[i] == \\' \\') continue;\\n            int n = parseNum(s, i);\\n            switch(op) {\\n                case \\'+\\' : nums.push_back(n); break;\\n                case \\'-\\' : nums.push_back(-n); break;\\n                case \\'*\\' : nums.back() *= n; break;\\n                case \\'/\\' : nums.back() /= n; break;\\n            }            \\n            op = s[i];\\n        }\\n        return accumulate(nums.begin(), nums.end(), 0);\\n    }\\n    \\n    int parseNum(string& s, int& i) {\\n        int n = 0;\\n        while(i < s.length() && isdigit(s[i]))\\n            n = s[i++] - \\'0\\' + 10 * n;\\n        return n;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int i = 0;\\n        return parseExpr(s, i);\\n    }\\n    \\n    int parseExpr(string& s, int& i) {\\n        vector<int> nums;\\n        char op = \\'+\\';\\n        for (; i < s.length() && op != \\')\\'; i++) {\\n            if (s[i] == \\' \\') continue;\\n            int n = s[i] == \\'(\\' ? parseExpr(s, ++i) : parseNum(s, i);\\n            switch(op) {\\n                case \\'+\\' : nums.push_back(n); break;\\n                case \\'-\\' : nums.push_back(-n); break;\\n                case \\'*\\' : nums.back() *= n; break;\\n                case \\'/\\' : nums.back() /= n; break;\\n            }            \\n            op = s[i];\\n        }\\n        return accumulate(nums.begin(), nums.end(), 0);\\n    }\\n    \\n     int parseNum(string& s, int& i) {     \\n        int n = 0;\\n        while(i < s.length() && isdigit(s[i]))\\n            n = s[i++] - \\'0\\' + 10 * n;\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130978,
                "title": "java-stack-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        int sum=0;\\n        int sign=1;\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char x=s.charAt(i);\\n            if(Character.isDigit(x)){\\n                int num=0;\\n                while(i<s.length() && Character.isDigit(s.charAt(i))){\\n                    num=num*10 + (s.charAt(i)-\\'0\\');\\n                    i++;\\n                }\\n                i--;\\n                num=num*sign;\\n                sum+=num;\\n                sign=1;\\n            }\\n            else if(x==\\'(\\'){\\n                st.push(sum);\\n                st.push(sign);\\n                sum=0;\\n                sign=1;\\n            }\\n            else if(x==\\')\\'){\\n                sum*=st.pop();\\n                sum+=st.pop();\\n            }\\n            else if(x==\\'-\\'){\\n                sign*=-1;\\n            }\\n            else {\\n                continue;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        int sum=0;\\n        int sign=1;\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char x=s.charAt(i);\\n            if(Character.isDigit(x)){\\n                int num=0;\\n                while(i<s.length() && Character.isDigit(s.charAt(i))){\\n                    num=num*10 + (s.charAt(i)-\\'0\\');\\n                    i++;\\n                }\\n                i--;\\n                num=num*sign;\\n                sum+=num;\\n                sign=1;\\n            }\\n            else if(x==\\'(\\'){\\n                st.push(sum);\\n                st.push(sign);\\n                sum=0;\\n                sign=1;\\n            }\\n            else if(x==\\')\\'){\\n                sum*=st.pop();\\n                sum+=st.pop();\\n            }\\n            else if(x==\\'-\\'){\\n                sign*=-1;\\n            }\\n            else {\\n                continue;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645587,
                "title": "c-easy-solution-w-comments",
                "content": "**Code :**\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<pair<int, int>> stk; //to store value calculated till now & sign\\n        long long int sum = 0, num = 0;\\n        int  sign = 1; //to store the current sign\\n        \\n        for(int i=0; i<s.size(); i++){\\n            if(isdigit(s[i])){\\n                //If it\\'s a multidigit number\\n                while(i < s.size() && isdigit(s[i])){\\n                    num = num*10 + (s[i] - \\'0\\');\\n                    i++;\\n                } \\n                i--;\\n                sum += num*sign;\\n                sign = 1; //reset sign\\n                num = 0;  //reset num\\n            }\\n            else if(s[i] == \\'(\\'){\\n                stk.push(make_pair(sum, sign)); //push the calculated sum & sign\\n                //reset sum & sign\\n                sum = 0;\\n                sign = 1;\\n            \\n            }else if(s[i] == \\'+\\'){ \\n                sign = 1; //sign is positive\\n            }else if(s[i] == \\'-\\'){\\n                sign = sign*(-1);  //toggle sign\\n            }else if(s[i] == \\')\\'){\\n                sum = stk.top().first + (stk.top().second)*sum; //After finishing calculating inside bracket value, add / subtract it from the previously calculated sum\\n                stk.pop();\\n                \\n            }else continue; //in case of empty spaces\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\\n\\n**Do upvote if you like :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<pair<int, int>> stk; //to store value calculated till now & sign\\n        long long int sum = 0, num = 0;\\n        int  sign = 1; //to store the current sign\\n        \\n        for(int i=0; i<s.size(); i++){\\n            if(isdigit(s[i])){\\n                //If it\\'s a multidigit number\\n                while(i < s.size() && isdigit(s[i])){\\n                    num = num*10 + (s[i] - \\'0\\');\\n                    i++;\\n                } \\n                i--;\\n                sum += num*sign;\\n                sign = 1; //reset sign\\n                num = 0;  //reset num\\n            }\\n            else if(s[i] == \\'(\\'){\\n                stk.push(make_pair(sum, sign)); //push the calculated sum & sign\\n                //reset sum & sign\\n                sum = 0;\\n                sign = 1;\\n            \\n            }else if(s[i] == \\'+\\'){ \\n                sign = 1; //sign is positive\\n            }else if(s[i] == \\'-\\'){\\n                sign = sign*(-1);  //toggle sign\\n            }else if(s[i] == \\')\\'){\\n                sum = stk.top().first + (stk.top().second)*sum; //After finishing calculating inside bracket value, add / subtract it from the previously calculated sum\\n                stk.pop();\\n                \\n            }else continue; //in case of empty spaces\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1521441,
                "title": "easy-c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) \\n    {\\n        int res = 0, sign = 1;\\n        \\n        stack<int> st;\\n        for(int i = 0; i < s.size(); i++)\\n        {            \\n            char c = s[i];\\n            if(c >= \\'0\\' && c <= \\'9\\')\\n            {\\n                int num = 0;\\n                while(i < s.size() && s[i]>=\\'0\\' && s[i]<= \\'9\\')\\n                    num = num * 10 + (s[i++] - \\'0\\');\\n                res += sign * num;\\n                i--;\\n            }\\n            else if(c ==\\'+\\') sign = 1;\\n            else if(c ==\\'-\\') sign = -1;\\n            else if(c ==\\'(\\')\\n            { \\n                st.push(res);\\n                st.push(sign);\\n                res = 0;\\n                sign = 1;\\n            }\\n            else if(c ==\\')\\')\\n            {\\n                res *= st.top(); \\n                st.pop();\\n                res += st.top(); \\n                st.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) \\n    {\\n        int res = 0, sign = 1;\\n        \\n        stack<int> st;\\n        for(int i = 0; i < s.size(); i++)\\n        {            \\n            char c = s[i];\\n            if(c >= \\'0\\' && c <= \\'9\\')\\n            {\\n                int num = 0;\\n                while(i < s.size() && s[i]>=\\'0\\' && s[i]<= \\'9\\')\\n                    num = num * 10 + (s[i++] - \\'0\\');\\n                res += sign * num;\\n                i--;\\n            }\\n            else if(c ==\\'+\\') sign = 1;\\n            else if(c ==\\'-\\') sign = -1;\\n            else if(c ==\\'(\\')\\n            { \\n                st.push(res);\\n                st.push(sign);\\n                res = 0;\\n                sign = 1;\\n            }\\n            else if(c ==\\')\\')\\n            {\\n                res *= st.top(); \\n                st.pop();\\n                res += st.top(); \\n                st.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1459827,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    int calculate(string s) \\n    {        \\n        stack<int> values;    \\n        int result = 0;\\n        int sign = 1;\\n        for(int i = 0; i < s.length(); i++) \\n        {\\n            if(s[i] == \\' \\') continue;    \\n            if(isdigit(s[i])) \\n            {\\n                int val = 0;    \\n                while(i < s.length() && isdigit(s[i])) \\n                {\\n                    val = val * 10 + (s[i] - \\'0\\');\\n                    i++;\\n                }\\n                result+= (val * sign);\\n                i--;\\n            }\\n            else if(s[i] == \\'+\\') sign = 1;\\n            else if(s[i] == \\'-\\') sign = -1;\\n            else if(s[i] == \\'(\\') \\n            {    \\n                values.push(result);\\n                values.push(sign);   \\n                result = 0;\\n                sign = 1;\\n            }\\n            else \\n            {    \\n                result *= values.top();\\n                values.pop();\\n                result += values.top();\\n                values.pop();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int calculate(string s) \\n    {        \\n        stack<int> values;    \\n        int result = 0;\\n        int sign = 1;\\n        for(int i = 0; i < s.length(); i++) \\n        {\\n            if(s[i] == \\' \\') continue;    \\n            if(isdigit(s[i])) \\n            {\\n                int val = 0;    \\n                while(i < s.length() && isdigit(s[i])) \\n                {\\n                    val = val * 10 + (s[i] - \\'0\\');\\n                    i++;\\n                }\\n                result+= (val * sign);\\n                i--;\\n            }\\n            else if(s[i] == \\'+\\') sign = 1;\\n            else if(s[i] == \\'-\\') sign = -1;\\n            else if(s[i] == \\'(\\') \\n            {    \\n                values.push(result);\\n                values.push(sign);   \\n                result = 0;\\n                sign = 1;\\n            }\\n            else \\n            {    \\n                result *= values.top();\\n                values.pop();\\n                result += values.top();\\n                values.pop();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457982,
                "title": "clear-go-solution",
                "content": "```\\nfunc calculate(s string) int {\\n\\tresult, num, op := 0, 0, add\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tswitch s[i] {\\n\\t\\tcase \\' \\':\\n\\t\\tcase \\'+\\':\\n\\t\\t\\tresult, num = op(result, num), 0\\n\\t\\t\\top = add\\n\\t\\tcase \\'-\\':\\n\\t\\t\\tresult, num = op(result, num), 0\\n\\t\\t\\top = sub\\n\\t\\tcase \\'(\\':\\n\\t\\t\\tend := findMatch(s, i)\\n\\t\\t\\tnum, i = calculate(s[i+1:end]), end\\n\\t\\tdefault:\\n\\t\\t\\tnum *= 10\\n\\t\\t\\tnum += int(s[i] - \\'0\\')\\n\\t\\t}\\n\\t}\\n\\n\\tresult, num = op(result, num), 0\\n\\treturn result\\n}\\n\\nfunc findMatch(s string, start int) int {\\n\\tlevel := 0\\n\\tfor i := start; i < len(s); i++ {\\n\\t\\tswitch s[i] {\\n\\t\\tcase \\'(\\':\\n\\t\\t\\tlevel++\\n\\t\\tcase \\')\\':\\n\\t\\t\\tlevel--\\n\\t\\t\\tif level == 0 {\\n\\t\\t\\t\\treturn i\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn len(s) - 1\\n}\\n\\nfunc add(a, b int) int {\\n\\treturn a + b\\n}\\n\\nfunc sub(a, b int) int {\\n\\treturn a - b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc calculate(s string) int {\\n\\tresult, num, op := 0, 0, add\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tswitch s[i] {\\n\\t\\tcase \\' \\':\\n\\t\\tcase \\'+\\':\\n\\t\\t\\tresult, num = op(result, num), 0\\n\\t\\t\\top = add\\n\\t\\tcase \\'-\\':\\n\\t\\t\\tresult, num = op(result, num), 0\\n\\t\\t\\top = sub\\n\\t\\tcase \\'(\\':\\n\\t\\t\\tend := findMatch(s, i)\\n\\t\\t\\tnum, i = calculate(s[i+1:end]), end\\n\\t\\tdefault:\\n\\t\\t\\tnum *= 10\\n\\t\\t\\tnum += int(s[i] - \\'0\\')\\n\\t\\t}\\n\\t}\\n\\n\\tresult, num = op(result, num), 0\\n\\treturn result\\n}\\n\\nfunc findMatch(s string, start int) int {\\n\\tlevel := 0\\n\\tfor i := start; i < len(s); i++ {\\n\\t\\tswitch s[i] {\\n\\t\\tcase \\'(\\':\\n\\t\\t\\tlevel++\\n\\t\\tcase \\')\\':\\n\\t\\t\\tlevel--\\n\\t\\t\\tif level == 0 {\\n\\t\\t\\t\\treturn i\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn len(s) - 1\\n}\\n\\nfunc add(a, b int) int {\\n\\treturn a + b\\n}\\n\\nfunc sub(a, b int) int {\\n\\treturn a - b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1457042,
                "title": "c-accepted-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int n = s.size(), result = 0, sign = 1;\\n        stack<int> stk;\\n        for (int i = 0; i < n; i++) {\\n            if (isdigit(s[i])) {\\n                int num = s[i] - \\'0\\';\\n                while (i + 1 < n && isdigit(s[i + 1])) {\\n                    num = num * 10 + (s[++i] - \\'0\\');\\n                }\\n                result += sign * num;\\n            } else if (s[i] == \\'+\\') {\\n                sign = 1;\\n            } else if (s[i] == \\'-\\') {\\n                sign = -1;\\n            } else if (s[i] == \\'(\\') {\\n                stk.push(result);\\n                stk.push(sign);\\n                result = 0;\\n                sign = 1;\\n            } else if (s[i] == \\')\\') {\\n                result *= stk.top();\\n                stk.pop();\\n                result += stk.top();\\n                stk.pop();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int n = s.size(), result = 0, sign = 1;\\n        stack<int> stk;\\n        for (int i = 0; i < n; i++) {\\n            if (isdigit(s[i])) {\\n                int num = s[i] - \\'0\\';\\n                while (i + 1 < n && isdigit(s[i + 1])) {\\n                    num = num * 10 + (s[++i] - \\'0\\');\\n                }\\n                result += sign * num;\\n            } else if (s[i] == \\'+\\') {\\n                sign = 1;\\n            } else if (s[i] == \\'-\\') {\\n                sign = -1;\\n            } else if (s[i] == \\'(\\') {\\n                stk.push(result);\\n                stk.push(sign);\\n                result = 0;\\n                sign = 1;\\n            } else if (s[i] == \\')\\') {\\n                result *= stk.top();\\n                stk.pop();\\n                result += stk.top();\\n                stk.pop();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457029,
                "title": "c-easy-recursion",
                "content": "```\\nclass Solution {\\n    int ret_pos;\\npublic:\\n    int calculate(string s,int i=0) {\\n        int first=0,sum=0;\\n        int sign=1 ;\\n        while(i<s.length() && s[i]!=\\')\\')\\n        {\\n            while(s[i]==\\' \\')i++;\\n            if(s[i]==\\'-\\' ){sign = -1;i++;}\\n            if(s[i]==\\'+\\'){sign =1;i++;}\\n            while(s[i]==\\' \\')i++;\\n            if(s[i]==\\'(\\')\\n            {\\n                first = calculate(s,i+1);\\n                i = ret_pos;\\n            }\\n            else if(isdigit(s[i]))\\n            {\\n                int j=i;\\n                first =0;\\n                while(isdigit(s[j]))\\n                {\\n                    first*=10;\\n                    first +=s[j]-\\'0\\';\\n                    j++;\\n                }\\n                i=j;\\n            }\\n            sum+=sign*first;\\n            first = 0 ;\\n            sign=1;\\n            if(s[i] == \\')\\')\\n            {\\n                ret_pos = i+1;\\n                return  sum;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int ret_pos;\\npublic:\\n    int calculate(string s,int i=0) {\\n        int first=0,sum=0;\\n        int sign=1 ;\\n        while(i<s.length() && s[i]!=\\')\\')\\n        {\\n            while(s[i]==\\' \\')i++;\\n            if(s[i]==\\'-\\' ){sign = -1;i++;}\\n            if(s[i]==\\'+\\'){sign =1;i++;}\\n            while(s[i]==\\' \\')i++;\\n            if(s[i]==\\'(\\')\\n            {\\n                first = calculate(s,i+1);\\n                i = ret_pos;\\n            }\\n            else if(isdigit(s[i]))\\n            {\\n                int j=i;\\n                first =0;\\n                while(isdigit(s[j]))\\n                {\\n                    first*=10;\\n                    first +=s[j]-\\'0\\';\\n                    j++;\\n                }\\n                i=j;\\n            }\\n            sum+=sign*first;\\n            first = 0 ;\\n            sign=1;\\n            if(s[i] == \\')\\')\\n            {\\n                ret_pos = i+1;\\n                return  sum;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096842,
                "title": "simple-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<int> st;\\n        int ans=0;\\n        st.push(1),st.push(1);\\n        //s[0] == \\'-\\'? st.push(-1) : st.push(1);\\n        for(int i=0;i<s.size();){\\n            if(s[i] >= \\'0\\'){\\n                int num=0;\\n                while(s[i]>=\\'0\\')\\n                    num = (s[i++] - \\'0\\') + num*10;\\n                ans = ans + st.top() * num;\\n                st.pop();\\n            }else if(s[i] == \\'+\\' || s[i] == \\'-\\'){\\n                s[i] == \\'-\\' ? st.push(st.top() * -1) : st.push(st.top() * 1);\\n                i++;\\n            }\\n            else if(s[i] == \\'(\\') st.push(st.top()), i++;\\n            else if(s[i] == \\')\\') st.pop(),i++;\\n            else i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<int> st;\\n        int ans=0;\\n        st.push(1),st.push(1);\\n        //s[0] == \\'-\\'? st.push(-1) : st.push(1);\\n        for(int i=0;i<s.size();){\\n            if(s[i] >= \\'0\\'){\\n                int num=0;\\n                while(s[i]>=\\'0\\')\\n                    num = (s[i++] - \\'0\\') + num*10;\\n                ans = ans + st.top() * num;\\n                st.pop();\\n            }else if(s[i] == \\'+\\' || s[i] == \\'-\\'){\\n                s[i] == \\'-\\' ? st.push(st.top() * -1) : st.push(st.top() * 1);\\n                i++;\\n            }\\n            else if(s[i] == \\'(\\') st.push(st.top()), i++;\\n            else if(s[i] == \\')\\') st.pop(),i++;\\n            else i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 885944,
                "title": "4ms-linear-solution-with-a-stack-of",
                "content": "The idea is that: each sign before a number within a negative block is flipped:\\n`-(1+2+3+4)` => `-1-2-3-4`\\nAnd it is nested:\\n`1-(2+3-(4-5))` => `1-(2+3-4+5)`=> `1-2-3+4-5`\\nThe gist is to push the sign +/- onto a stack, whenever we counter the combination of `+(` or `-(`. \\nWhen we push `-` onto the stack, we remember that we flip. We also need to flip it back when we pop it from the stack.\\n\\n```\\nint oc=0;\\nchar ostack[512];\\n\\nvoid push(char c) { ostack[oc++] = c;}\\n\\nvoid pop() {oc --;}\\n\\nint calculate(char * s){\\n    oc = 0;\\n    int num = 0; // current number to read\\n    int sum = 0; // current sum\\n    char lastSign = \\'+\\';\\n    bool positive = true;\\n    for(char* c=s;*c;c++) {\\n        if (*c==\\' \\') continue; //skip spaces\\n        \\n        if (\\'0\\' <= *c && *c <= \\'9\\') { // we have a digit\\n            num *= 10;  num += *c - \\'0\\';\\n            if (c[1] < \\'0\\' || c[1] > \\'9\\') { // detect end of number\\n                if (lastSign == \\'-\\') { // this is a negative number\\n                    num = -num;\\n                }\\n                if (positive) { // result of the flip-flop\\n                    sum += num;\\n                } else {\\n                    sum -= num;\\n                }\\n                num = 0;\\n            }\\n        } else  {\\n            if (*c == \\'(\\') {\\n                if(lastSign == \\'-\\') {\\n                    positive = !positive; // FLIP!\\n                }\\n                push(lastSign);\\n                lastSign = \\'+\\';\\n            } else if (*c == \\')\\') {\\n                if (oc > 0 && ostack[oc-1] == \\'-\\') { \\n                    positive = !positive;  // FLIP BACK!\\n                }\\n                pop();\\n            } else if (*c == \\'+\\') {\\n                lastSign = *c;\\n            } else if (*c == \\'-\\') {\\n                lastSign = *c;\\n            }\\n        }\\n    }\\n    return sum;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint oc=0;\\nchar ostack[512];\\n\\nvoid push(char c) { ostack[oc++] = c;}\\n\\nvoid pop() {oc --;}\\n\\nint calculate(char * s){\\n    oc = 0;\\n    int num = 0; // current number to read\\n    int sum = 0; // current sum\\n    char lastSign = \\'+\\';\\n    bool positive = true;\\n    for(char* c=s;*c;c++) {\\n        if (*c==\\' \\') continue; //skip spaces\\n        \\n        if (\\'0\\' <= *c && *c <= \\'9\\') { // we have a digit\\n            num *= 10;  num += *c - \\'0\\';\\n            if (c[1] < \\'0\\' || c[1] > \\'9\\') { // detect end of number\\n                if (lastSign == \\'-\\') { // this is a negative number\\n                    num = -num;\\n                }\\n                if (positive) { // result of the flip-flop\\n                    sum += num;\\n                } else {\\n                    sum -= num;\\n                }\\n                num = 0;\\n            }\\n        } else  {\\n            if (*c == \\'(\\') {\\n                if(lastSign == \\'-\\') {\\n                    positive = !positive; // FLIP!\\n                }\\n                push(lastSign);\\n                lastSign = \\'+\\';\\n            } else if (*c == \\')\\') {\\n                if (oc > 0 && ostack[oc-1] == \\'-\\') { \\n                    positive = !positive;  // FLIP BACK!\\n                }\\n                pop();\\n            } else if (*c == \\'+\\') {\\n                lastSign = *c;\\n            } else if (*c == \\'-\\') {\\n                lastSign = *c;\\n            }\\n        }\\n    }\\n    return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 830231,
                "title": "c-solution-using-recursion-instead-of-a-stack",
                "content": "```\\nclass Solution {\\npublic:    \\n    int get_num(string& s, int& i) {\\n        int num = 0;\\n        while (s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n            num *= 10;\\n            num += (s[i++] - \\'0\\');\\n        }\\n        return num;\\n    }\\n    \\n    \\n    int get_next(string& s, int& i) {\\n        while (s[i] == \\' \\') ++i;\\n        int ans;\\n        if (s[i] == \\'(\\') {\\n            ans = evaluate(s, ++i);\\n        } else {\\n            ans = get_num(s, i);\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    int evaluate (string& s, int& i) {\\n        int sign = 1, ans = 0;\\n        while (i < s.size() && s[i] != \\')\\') {\\n            if (s[i] == \\' \\') { ++i; continue; }\\n            if (s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n                ans += get_num(s, i);\\n            } else if (s[i] == \\'+\\' || s[i] == \\'-\\') {\\n                sign = s[i] == \\'+\\' ? 1 : -1;\\n                ans += sign * get_next(s, ++i);\\n            } else {\\n                ans += evaluate(s, ++i);\\n            }\\n        }\\n        ++i;\\n        return ans;\\n    }\\n    \\n    \\n    int calculate(string s) {\\n        int i = 0;\\n        return evaluate(s, i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    int get_num(string& s, int& i) {\\n        int num = 0;\\n        while (s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n            num *= 10;\\n            num += (s[i++] - \\'0\\');\\n        }\\n        return num;\\n    }\\n    \\n    \\n    int get_next(string& s, int& i) {\\n        while (s[i] == \\' \\') ++i;\\n        int ans;\\n        if (s[i] == \\'(\\') {\\n            ans = evaluate(s, ++i);\\n        } else {\\n            ans = get_num(s, i);\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    int evaluate (string& s, int& i) {\\n        int sign = 1, ans = 0;\\n        while (i < s.size() && s[i] != \\')\\') {\\n            if (s[i] == \\' \\') { ++i; continue; }\\n            if (s[i] >= \\'0\\' && s[i] <= \\'9\\') {\\n                ans += get_num(s, i);\\n            } else if (s[i] == \\'+\\' || s[i] == \\'-\\') {\\n                sign = s[i] == \\'+\\' ? 1 : -1;\\n                ans += sign * get_next(s, ++i);\\n            } else {\\n                ans += evaluate(s, ++i);\\n            }\\n        }\\n        ++i;\\n        return ans;\\n    }\\n    \\n    \\n    int calculate(string s) {\\n        int i = 0;\\n        return evaluate(s, i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785669,
                "title": "3ms-easy-recursive-java-without-stack",
                "content": "```\\n    int index = 0;\\n    public int calculate(String s) {\\n        int sum = 0;\\n        int sign = 1;\\n        while(index<s.length()){\\n            char c = s.charAt(index);\\n            if(c==\\'(\\'){\\n                ++index;\\n                int subRes = calculate(s);\\n                sum += sign*subRes;\\n            }else if(c==\\')\\'){\\n                return sum;\\n            }else if(c==\\'+\\'){\\n                sign=1;\\n            }else if(c==\\'-\\'){\\n                sign=-1;\\n            }else if(Character.isDigit(c)){\\n                int num = c-\\'0\\';\\n                while(index+1<s.length() && Character.isDigit(s.charAt(index+1))){\\n                    num = 10*num+s.charAt(++index)-\\'0\\';\\n                }\\n                sum += sign*num;\\n            }\\n            ++index;\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n    int index = 0;\\n    public int calculate(String s) {\\n        int sum = 0;\\n        int sign = 1;\\n        while(index<s.length()){\\n            char c = s.charAt(index);\\n            if(c==\\'(\\'){\\n                ++index;\\n                int subRes = calculate(s);\\n                sum += sign*subRes;\\n            }else if(c==\\')\\'){\\n                return sum;\\n            }else if(c==\\'+\\'){\\n                sign=1;\\n            }else if(c==\\'-\\'){\\n                sign=-1;\\n            }else if(Character.isDigit(c)){\\n                int num = c-\\'0\\';\\n                while(index+1<s.length() && Character.isDigit(s.charAt(index+1))){\\n                    num = 10*num+s.charAt(++index)-\\'0\\';\\n                }\\n                sum += sign*num;\\n            }\\n            ++index;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 670544,
                "title": "go-stack",
                "content": "```\\nfunc calculate(s string) int {\\n    cur := 0\\n    sign := 1\\n    num := 0\\n    res_stack :=  []int{}\\n    sign_stack := []int{}\\n    \\n    for i := 0; i < len(s); i++ {\\n        if s[i] == \\' \\' {\\n            continue\\n        } else if s[i] >= \\'0\\' && s[i] <= \\'9\\' {\\n            num = num * 10 + int(s[i] - \\'0\\')\\n        } else if s[i] == \\'+\\' {\\n            cur += num * sign\\n            num = 0\\n            sign = 1\\n        } else if s[i] == \\'-\\' {\\n            cur += num * sign\\n            num = 0\\n            sign = -1\\n        } else if s[i] == \\'(\\' {\\n            res_stack = append(res_stack, cur)\\n            sign_stack = append(sign_stack, sign)\\n            cur = 0\\n            sign = 1\\n        } else if s[i] == \\')\\' {\\n            cur += sign * num\\n            num = 0\\n            sign = sign_stack[len(sign_stack) - 1]\\n            sign_stack = sign_stack[:len(sign_stack) - 1]\\n            \\n            cur = sign * cur + res_stack[len(res_stack) - 1]\\n            res_stack = res_stack[:len(res_stack) - 1]           \\n        } else {\\n            fmt.Println(\"fuck\")\\n        }\\n    }    \\n    return cur + num * sign    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc calculate(s string) int {\\n    cur := 0\\n    sign := 1\\n    num := 0\\n    res_stack :=  []int{}\\n    sign_stack := []int{}\\n    \\n    for i := 0; i < len(s); i++ {\\n        if s[i] == \\' \\' {\\n            continue\\n        } else if s[i] >= \\'0\\' && s[i] <= \\'9\\' {\\n            num = num * 10 + int(s[i] - \\'0\\')\\n        } else if s[i] == \\'+\\' {\\n            cur += num * sign\\n            num = 0\\n            sign = 1\\n        } else if s[i] == \\'-\\' {\\n            cur += num * sign\\n            num = 0\\n            sign = -1\\n        } else if s[i] == \\'(\\' {\\n            res_stack = append(res_stack, cur)\\n            sign_stack = append(sign_stack, sign)\\n            cur = 0\\n            sign = 1\\n        } else if s[i] == \\')\\' {\\n            cur += sign * num\\n            num = 0\\n            sign = sign_stack[len(sign_stack) - 1]\\n            sign_stack = sign_stack[:len(sign_stack) - 1]\\n            \\n            cur = sign * cur + res_stack[len(res_stack) - 1]\\n            res_stack = res_stack[:len(res_stack) - 1]           \\n        } else {\\n            fmt.Println(\"fuck\")\\n        }\\n    }    \\n    return cur + num * sign    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 571448,
                "title": "o-n-with-detailed-explanation-novel-approach-with-single-stack-pseudocode-kotlin",
                "content": "For this problem, there is no need to implement a generic expression evaluation algorithm, as all operators that exist in the expression have same priority (namely, `+` and `-`).\\n\\n**If there were no paretheses**, the approach would be as simple as this (pseudocode):\\n\\n```\\nacc = 0   // accumulator\\nprevSign = +1\\n\\nfor (token in s) {  // suppose we tokenized s into signs and numbers\\n    if (token in [\\'+\\', \\'-\\'])  prevSign = (token == \\'+\\' ? +1 : -1)\\n    else acc += prevSign * toInt(token)\\n}\\n\\nreturn acc\\n```\\n\\nLet\\'s think, what exactly do paretheses change in the approach above?  \\n\\nIf there were no minus signs (`-`) directly before opening parenthesis, nothing changes, e.g:\\n\\n```(1 + (2 - 3 + (4) - 5))```\\nis the same as:\\n```1 + 2 - 3 + 4 - 5 ```\\n\\nhowever, \\n```1 - (2 + 3 - (4 + 5)) ```\\nis **not** the same as:\\n```1 - 2 + 3 - 4 + 5 ```\\n**but!**  it\\'s the same as:\\n```1 - 2 - 3 + 4 + 5 ```\\n\\nDo you see what happened there?  When there is a minus sign directly before the opening parenthesis, all the signs within that parentheses pair are inverted!  And if there is another nested \"negative opening parentheses\" it inverts signs again! Even number of inversions amount to no change of sign ( `-1 * -1 * -1 * -1 = 1`), while odd number results in single inversion (`-1 * -1 * -1 = -1`).\\n\\nSo the logical modification for the algorithm above is to know how many levels of nested \"negative opening paretheses\" are we currently in. To do that, simple `sign = 1` variable would suffice, which is inverted when \"negative opening parethesis\" is encoutered or when closing parethesis is encountered, that corresponds to \"negative opening parethesis\". \\n\\nNow, \"negative opening parethesis\" is easy, but how to know whether closing parethesis corresponds to \"negative\" or \"positive\" opening parethesis? To do that we need a stack that holds signs of opening paretheses. When encountering opening parenthesis, put it\\'s sign into stack. When encoutering closing parethesis, pop sign from stack \\u2014 that would be the sign of corresponding opening parethesis.\\n\\nLet\\'s put all of this together:\\n\\n```\\nacc = 0   // accumulator\\nprevSign = +1  // previously encountered sign/operator\\nsignStack = []  // signs of opening parentheses\\nparenSigns = +1  // overall sign of current group of parentheses\\n\\nfor (token in s) {  // suppose we tokenized s into signs, numbers and parentheses\\n    if (token in [\\'+\\', \\'-\\'])  prevSign = (token == \\'+\\' ? +1 : -1)\\n\\telse if (token == \\'(\\')  {\\n\\t  signStack.push(prevSign)\\n\\t  if (prevSign < 0) parenSigns *= -1  // invert sign of nested paretheses\\n\\t  prevSign = +1 // after the opening parethesis, we assume sign is always positive (as in the start of new expression)\\n\\t} else if (token == \\')\\') {\\n\\t  if (signStack.pop() < 0) parenSigns *= -1 // revert sign back\\n\\t} else acc += prevSign * parenSigns * toInt(token)\\n}\\n\\nreturn acc\\n```\\n\\n\\n\\nAnd now in Kotlin:\\n```\\nclass Solution {\\n    \\n    fun calculate(s: String): Int {\\n        var acc = 0        \\n        var i = 0\\n        \\n        val signStack = LinkedList<Int>()  \\n        var parenSigns = 1\\n        var prevSign = 1\\n        \\n        while (i < s.length) {\\n            val c = s[i]\\n            when(c) {\\n                \\' \\' -> {}\\n                \\'(\\' -> { \\n                    signStack.push(prevSign)\\n                    if (prevSign < 0) parenSigns *= -1\\n                    prevSign = 1\\n                }\\n                \\')\\' -> if (signStack.pop() < 0) parenSigns *= -1\\n                \\'+\\' ->  prevSign = 1\\n                \\'-\\' -> prevSign = -1\\n                else -> { // parse whole number\\n                    var n = 0\\n                    while(i < s.length && \\'0\\' <= s[i] && s[i] <= \\'9\\') {\\n                        n = n * 10 + (s[i] - \\'0\\')\\n                        i++\\n                    }\\n                    i--\\n                    acc += n * parenSigns * prevSign\\n                }\\n            }\\n            i++\\n        }\\n     \\n        return acc\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nacc = 0   // accumulator\\nprevSign = +1\\n\\nfor (token in s) {  // suppose we tokenized s into signs and numbers\\n    if (token in [\\'+\\', \\'-\\'])  prevSign = (token == \\'+\\' ? +1 : -1)\\n    else acc += prevSign * toInt(token)\\n}\\n\\nreturn acc\\n```\n```(1 + (2 - 3 + (4) - 5))```\n```1 + 2 - 3 + 4 - 5 ```\n```1 - (2 + 3 - (4 + 5)) ```\n```1 - 2 + 3 - 4 + 5 ```\n```1 - 2 - 3 + 4 + 5 ```\n```\\nacc = 0   // accumulator\\nprevSign = +1  // previously encountered sign/operator\\nsignStack = []  // signs of opening parentheses\\nparenSigns = +1  // overall sign of current group of parentheses\\n\\nfor (token in s) {  // suppose we tokenized s into signs, numbers and parentheses\\n    if (token in [\\'+\\', \\'-\\'])  prevSign = (token == \\'+\\' ? +1 : -1)\\n\\telse if (token == \\'(\\')  {\\n\\t  signStack.push(prevSign)\\n\\t  if (prevSign < 0) parenSigns *= -1  // invert sign of nested paretheses\\n\\t  prevSign = +1 // after the opening parethesis, we assume sign is always positive (as in the start of new expression)\\n\\t} else if (token == \\')\\') {\\n\\t  if (signStack.pop() < 0) parenSigns *= -1 // revert sign back\\n\\t} else acc += prevSign * parenSigns * toInt(token)\\n}\\n\\nreturn acc\\n```\n```\\nclass Solution {\\n    \\n    fun calculate(s: String): Int {\\n        var acc = 0        \\n        var i = 0\\n        \\n        val signStack = LinkedList<Int>()  \\n        var parenSigns = 1\\n        var prevSign = 1\\n        \\n        while (i < s.length) {\\n            val c = s[i]\\n            when(c) {\\n                \\' \\' -> {}\\n                \\'(\\' -> { \\n                    signStack.push(prevSign)\\n                    if (prevSign < 0) parenSigns *= -1\\n                    prevSign = 1\\n                }\\n                \\')\\' -> if (signStack.pop() < 0) parenSigns *= -1\\n                \\'+\\' ->  prevSign = 1\\n                \\'-\\' -> prevSign = -1\\n                else -> { // parse whole number\\n                    var n = 0\\n                    while(i < s.length && \\'0\\' <= s[i] && s[i] <= \\'9\\') {\\n                        n = n * 10 + (s[i] - \\'0\\')\\n                        i++\\n                    }\\n                    i--\\n                    acc += n * parenSigns * prevSign\\n                }\\n            }\\n            i++\\n        }\\n     \\n        return acc\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504818,
                "title": "java-recursion",
                "content": "```java\\npublic static enum Operation {\\n\\tPLUS,\\n\\tMINUS;\\n}\\nint i = 0;\\n\\npublic int calculate(String s) {\\n\\tint num = 0;\\n\\tOperation operation = null;\\n\\twhile (i < s.length()) {\\n\\t\\tswitch (s.charAt(i)) {\\n\\t\\t\\tcase \\' \\':\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\'(\\':\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tnum = operate(num, operation, calculate(s));\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\')\\':\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\treturn num;\\n\\t\\t\\tcase \\'+\\':\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\toperation = Operation.PLUS;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\'-\\':\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\toperation = Operation.MINUS;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tint digit = getDigit(s);\\n\\t\\t\\t\\tnum = operate(num, operation, digit);\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\treturn num;\\n}\\n\\npublic int operate(int num1, Operation operation, int num2) {\\n\\tif (operation == null) {\\n\\t\\treturn num2;\\n\\t}\\n\\tswitch (operation) {\\n\\t\\tcase PLUS:\\n\\t\\t\\treturn num1 + num2;\\n\\t\\tcase MINUS:\\n\\t\\t\\treturn num1 - num2;\\n\\t}\\n\\tthrow new IllegalStateException();\\n}\\n\\npublic int getDigit(String s) {\\n\\tint start = i;\\n\\twhile (i < s.length() && Character.isDigit(s.charAt(i))) {\\n\\t\\ti++;\\n\\t}\\n\\treturn Integer.parseInt(s.substring(start, i));\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic static enum Operation {\\n\\tPLUS,\\n\\tMINUS;\\n}\\nint i = 0;\\n\\npublic int calculate(String s) {\\n\\tint num = 0;\\n\\tOperation operation = null;\\n\\twhile (i < s.length()) {\\n\\t\\tswitch (s.charAt(i)) {\\n\\t\\t\\tcase \\' \\':\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\'(\\':\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tnum = operate(num, operation, calculate(s));\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\')\\':\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\treturn num;\\n\\t\\t\\tcase \\'+\\':\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\toperation = Operation.PLUS;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\'-\\':\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\toperation = Operation.MINUS;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tint digit = getDigit(s);\\n\\t\\t\\t\\tnum = operate(num, operation, digit);\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\treturn num;\\n}\\n\\npublic int operate(int num1, Operation operation, int num2) {\\n\\tif (operation == null) {\\n\\t\\treturn num2;\\n\\t}\\n\\tswitch (operation) {\\n\\t\\tcase PLUS:\\n\\t\\t\\treturn num1 + num2;\\n\\t\\tcase MINUS:\\n\\t\\t\\treturn num1 - num2;\\n\\t}\\n\\tthrow new IllegalStateException();\\n}\\n\\npublic int getDigit(String s) {\\n\\tint start = i;\\n\\twhile (i < s.length() && Character.isDigit(s.charAt(i))) {\\n\\t\\ti++;\\n\\t}\\n\\treturn Integer.parseInt(s.substring(start, i));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502247,
                "title": "simple-python-stack-solution",
                "content": "```\\ndef calculate(self, s):\\n        s, stack = s.strip(), []\\n        s = \\'(\\' + s + \\')\\'\\n        for char in s:\\n            if char != \\')\\':\\n                stack.append(char)\\n            else:\\n                add, subtract = [], []\\n                while stack[-1] != \\'(\\':\\n                    num1 = \\'\\'\\n                    while stack[-1] not in [\\'+\\',\\'-\\', \\'(\\']:\\n                        num1 = stack.pop(-1) + num1\\n                    symbol = stack.pop(-1) if stack[-1] in [\\'+\\',\\'-\\'] else \\'+\\'\\n                    if symbol == \\'+\\':\\n                        add.append(int(num1))\\n                    else:\\n                        subtract.append(int(num1))\\n                stack.pop(-1)\\n                stack.append(str(sum(add)-sum(subtract)))\\n        return stack[-1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef calculate(self, s):\\n        s, stack = s.strip(), []\\n        s = \\'(\\' + s + \\')\\'\\n        for char in s:\\n            if char != \\')\\':\\n                stack.append(char)\\n            else:\\n                add, subtract = [], []\\n                while stack[-1] != \\'(\\':\\n                    num1 = \\'\\'\\n                    while stack[-1] not in [\\'+\\',\\'-\\', \\'(\\']:\\n                        num1 = stack.pop(-1) + num1\\n                    symbol = stack.pop(-1) if stack[-1] in [\\'+\\',\\'-\\'] else \\'+\\'\\n                    if symbol == \\'+\\':\\n                        add.append(int(num1))\\n                    else:\\n                        subtract.append(int(num1))\\n                stack.pop(-1)\\n                stack.append(str(sum(add)-sum(subtract)))\\n        return stack[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 459447,
                "title": "java-expression-tree",
                "content": "Build the expression tree of the input string in linear time with a stack. Then traverse the tree and get the value of the input expression. This method is not as fast but could be applied to other expression porblems such as polish and reverse polish notation.\\n\\nCode:\\nclass Solution {\\n    public class Node{\\n        String ch;\\n        int level;\\n        Node left;\\n        Node right;\\n        \\n        Node(String ch, int level){\\n            this.ch = ch;\\n            this.level = level;\\n            left = null;\\n            right = null;\\n        }\\n    }\\n    \\n    public void helper(Stack<Node> s, Node n){ // build the tree with a monotonous stack according to the level\\n        if(s.isEmpty()){\\n            s.push(n);\\n            return;\\n        }\\n        \\n        while(!s.isEmpty() && n.level <= s.peek().level){\\n            Node out = s.pop();\\n            \\n            if(s.isEmpty()){\\n                n.left = out;\\n            }else{\\n                s.peek().right = null;\\n                if(n.level > s.peek().level){\\n                    n.left = out;\\n                }else{\\n                    s.peek().right = out;\\n                }\\n            }\\n        }\\n        \\n        if(!s.isEmpty()) s.peek().right = n;\\n        s.push(n);\\n    }\\n    \\n    public int dfs(Node n){\\n        if(!n.ch.equals(\"+\") && !n.ch.equals(\"-\")){\\n            return Integer.parseInt(n.ch);\\n        }\\n        \\n        int left = dfs(n.left);\\n        int right = dfs(n.right);\\n        if(n.ch.equals(\"+\")) return left + right;\\n        return left - right;\\n        \\n    }\\n    \\n    public int calculate(String s) {\\n        int level = 0;\\n        char[] ch = s.toCharArray();\\n        Stack<Node> stack = new Stack<>();\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            if(ch[i] == \\' \\') continue;\\n            if(ch[i] == \\'(\\'){\\n                level+=10;\\n            }else if(ch[i] == \\')\\'){\\n                level-=10;\\n            }else if(ch[i] == \\'+\\' || ch[i] == \\'-\\'){ // + and - have the same level\\n                Node cur = new Node(String.valueOf(ch[i]), level);\\n                helper(stack, cur);\\n            }else{ // digits have the maximum level and donnot take parenthesis into account\\n                StringBuilder sb = new StringBuilder(\"\");\\n                while(i < s.length() && Character.isDigit(ch[i])){\\n                    sb.append(ch[i]);\\n                    i++;\\n                }\\n                i--;\\n                Node cur = new Node(sb.toString(), Integer.MAX_VALUE);\\n                helper(stack, cur);\\n            }\\n        }\\n        \\n        if(stack.isEmpty()) return 0;\\n        \\n        while(stack.size() > 1) stack.pop();\\n        \\n        \\n        return dfs(stack.peek());\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public class Node{\\n        String ch;\\n        int level;\\n        Node left;\\n        Node right;\\n        \\n        Node(String ch, int level){\\n            this.ch = ch;\\n            this.level = level;\\n            left = null;\\n            right = null;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 405389,
                "title": "java-recursion-2ms-beat-99",
                "content": "Different strategies for \\'(\\', \\')\\', digit, \\'+\\', \\'-\\' and the rest. A global pointer in[] p moves in one direction. Hence, the time complexity is O(n)\\n```\\nclass Solution {\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        return parse(s, new int[]{0});\\n    }\\n    \\n    private int parse(String s, int[] p) {\\n        int res = 0;\\n        int sign = 1;\\n        while (p[0] < s.length()) {\\n            if (s.charAt(p[0]) == \\'(\\') {\\n                p[0]++;\\n                res += sign * parse(s, p);\\n                continue;\\n            } else if (s.charAt(p[0]) == \\')\\') {\\n                p[0]++;\\n                return res;\\n            } else if (Character.isDigit(s.charAt(p[0]))) {\\n                res += sign * getNum(s, p);\\n                continue;\\n            } else if (s.charAt(p[0]) == \\'+\\') {\\n                sign = 1;\\n            } else if (s.charAt(p[0]) == \\'-\\') {\\n                sign = -1;\\n            }\\n            p[0]++;\\n        }\\n        return res;\\n    }\\n    \\n    private int getNum(String s, int[] p) {\\n        int num = 0;\\n        while (p[0] < s.length() && Character.isDigit(s.charAt(p[0]))) {\\n            num = s.charAt(p[0]++) - \\'0\\' + num * 10;\\n        }\\n        return num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        return parse(s, new int[]{0});\\n    }\\n    \\n    private int parse(String s, int[] p) {\\n        int res = 0;\\n        int sign = 1;\\n        while (p[0] < s.length()) {\\n            if (s.charAt(p[0]) == \\'(\\') {\\n                p[0]++;\\n                res += sign * parse(s, p);\\n                continue;\\n            } else if (s.charAt(p[0]) == \\')\\') {\\n                p[0]++;\\n                return res;\\n            } else if (Character.isDigit(s.charAt(p[0]))) {\\n                res += sign * getNum(s, p);\\n                continue;\\n            } else if (s.charAt(p[0]) == \\'+\\') {\\n                sign = 1;\\n            } else if (s.charAt(p[0]) == \\'-\\') {\\n                sign = -1;\\n            }\\n            p[0]++;\\n        }\\n        return res;\\n    }\\n    \\n    private int getNum(String s, int[] p) {\\n        int num = 0;\\n        while (p[0] < s.length() && Character.isDigit(s.charAt(p[0]))) {\\n            num = s.charAt(p[0]++) - \\'0\\' + num * 10;\\n        }\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 255794,
                "title": "2-approaches-in-go-golang",
                "content": "1st approach: naive approach\\n---\\n```\\n/*\\n\\t1st approach:\\n\\t- use 2 stacks\\n\\t- the basic idea is to save each operator with the level of parenthesis, see type OpStack\\n\\t- when there is a ), sum up the result on the same parenthesis level, and decrement the global parenthesis level\\n\\n\\te.g. 1+2-(3+4-(5+6))+7\\n\\titerations on each token:\\n\\t1:\\tnumstack = [1]\\n\\t+:\\topstack = [(+,0)]\\n\\t2:\\tnumstack = [1,2]\\n\\t-:\\topstack = [(+,0),(-,0)]\\n\\t(:\\tparenthesesCount 0->1\\n\\t3:\\tnumstack = [1,2,3]\\n\\t+:\\topstack = [(+,0),(-,0),(+,1)]\\n\\t4:\\tnumstack = [1,2,3,4]\\n\\t-:\\topstack = [(+,0),(-,0),(+,1),(-,1)]\\n\\t(:\\tparenthesesCount 1->2\\n\\t5:\\tnumstack = [1,2,3,4,5]\\n\\t+:\\topstack = [(+,0),(-,0),(+,1),(-,1),(+,2)]\\n\\t6:\\tnumstack = [1,2,3,4,5,6]\\n\\t):\\tnumstack = [1,2,3,4,11], opstack = [(+,0),(-,0),(+,1),(-,1)], parenthesesCount 2->1\\n\\t):\\tnumstack = [1,2,-4], opstack = [(+,0),(-,0)], parenthesesCount 1->0\\n\\t+:\\topstack = [(+,0),(-,0),(+,0)]\\n\\t7+\\tnumstack = [1,2,-4,7]\\n\\tend: iterate the numstack and calculate 1+2-(-4)+7=>14\\n\\n\\tTime\\tO(2n) the nested loop actually just runs one time time\\n\\tSpace O(n)\\n\\t28 ms, faster than 25.49%\\n*/\\ntype OpStack struct {\\n\\toperator byte\\n\\tlevel    int\\n}\\n\\nfunc calculate(s string) int {\\n\\tparenthesesCount := 0\\n\\toperatorStack := []OpStack{}\\n\\tnumberStack := []int{}\\n\\ti := 0\\n\\tfor i < len(s) {\\n\\t    // construct a multi-digits number if any, e.g. \"23\" = 2*10+3 = 23\\n\\t\\tif unicode.IsDigit(rune(s[i])) == true {\\n\\t\\t\\tcurNum := 0\\n\\t\\t\\tj := i\\n\\t\\t\\tfor j < len(s) && unicode.IsDigit(rune(s[j])) == true {\\n\\t\\t\\t\\tcurNum = curNum*10 + int(s[j]-\\'0\\')\\n\\t\\t\\t\\tj++\\n\\t\\t\\t}\\n\\t\\t\\tnumberStack = append(numberStack, curNum)\\n\\t\\t\\ti = j\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif s[i] == \\'+\\' || s[i] == \\'-\\' {\\n\\t\\t\\toperatorStack = append(operatorStack, OpStack{s[i], parenthesesCount})\\n\\t\\t}\\n\\t\\tif s[i] == \\'(\\' {\\n\\t\\t\\tparenthesesCount++\\n\\t\\t}\\n\\t\\tif s[i] == \\')\\' {\\n\\t\\t\\tif len(operatorStack) == 0 {\\n\\t\\t\\t\\tparenthesesCount--\\n\\t\\t\\t\\ti++\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\t// pop the items on the same level for calculation\\n\\t\\t\\tlevel := operatorStack[len(operatorStack)-1].level\\n\\t\\t\\tarr := []int{}\\n\\t\\t\\toperators := []byte{}\\n\\n\\t\\t\\tpop := numberStack[len(numberStack)-1]\\n\\t\\t\\tnumberStack = numberStack[:len(numberStack)-1]\\n\\t\\t\\tarr = append([]int{pop}, arr...)\\n\\t\\t\\tfor len(operatorStack) > 0 && operatorStack[len(operatorStack)-1].level == level {\\n\\t\\t\\t\\tpop := numberStack[len(numberStack)-1]\\n\\t\\t\\t\\tnumberStack = numberStack[:len(numberStack)-1]\\n\\t\\t\\t\\tarr = append([]int{pop}, arr...)\\n\\n\\t\\t\\t\\tpopOp := operatorStack[len(operatorStack)-1]\\n\\t\\t\\t\\toperatorStack = operatorStack[:len(operatorStack)-1]\\n\\t\\t\\t\\toperators = append([]byte{popOp.operator}, operators...)\\n\\t\\t\\t}\\n\\t\\t\\t// calculate the result within the current \"(...)\"\\n\\t\\t\\ttemp := 0\\n\\t\\t\\top := \\'+\\'\\n\\t\\t\\tfor _, num := range arr {\\n\\t\\t\\t\\tif op == \\'+\\' {\\n\\t\\t\\t\\t\\ttemp += num\\n\\t\\t\\t\\t} else if op == \\'-\\' {\\n\\t\\t\\t\\t\\ttemp -= num\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif len(operators) > 0 {\\n\\t\\t\\t\\t\\top = rune(operators[0])\\n\\t\\t\\t\\t\\toperators = operators[1:]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tnumberStack = append(numberStack, temp)\\n\\t\\t\\tparenthesesCount--\\n\\t\\t}\\n\\t\\ti++\\n\\t}\\n\\t// calculate if there are still operators in the stack\\n\\ttemp := numberStack[0]\\n\\tnumberStack = numberStack[1:]\\n\\tfor len(operatorStack) > 0 {\\n\\t\\top := rune(operatorStack[0].operator)\\n\\t\\toperatorStack = operatorStack[1:]\\n\\n\\t\\tpop := numberStack[0]\\n\\t\\tnumberStack = numberStack[1:]\\n\\t\\tif op == \\'+\\' {\\n\\t\\t\\ttemp += pop\\n\\t\\t} else if op == \\'-\\' {\\n\\t\\t\\ttemp -= pop\\n\\t\\t}\\n\\t}\\n\\n\\treturn temp\\n}\\n```\\nI first cam up with the above approach, because it was straightforward but it is very tedious, \\n- we use 2 stacks\\n- as well as defining a type struct\\n- once we see a `)`, we need to iterate back to calculate the sum which slow down the overall calculation.\\n\\nBut then I was inspired by @southpenguin with his/her concise [approach in java](https://leetcode.com/problems/basic-calculator/discuss/62361/Iterative-Java-solution-with-stack) and rewrote it in golang\\n\\n2nd Approach\\n---\\n```\\n/*\\n\\t2nd approach: suggested solution at https://leetcode.com/problems/basic-calculator/discuss/62361/Iterative-Java-solution-with-stack\\n\\t- use 1 stack\\n\\t- calculate the numbers on the same level\\n\\t- when we see (, put the intermediate result into a stack, and new calculation start from the (\\n\\t- when we see ), pop the add/minus the result with the last item in the stack\\n\\n\\tTime\\tO(n) the nested loop actually just runs one time time\\n\\tSpace O(n)\\n\\t4 ms, faster than 90.20%\\n*/\\nfunc calculate1(s string) int {\\n\\tres := 0\\n\\tstack := make([]int, 0, len(s))\\n\\t// 1 means positive, -1 means negative\\n\\t// we declare it as an integer because we want to put the +- in the stack too\\n\\tsign := 1\\n\\tnum := 0\\n\\t// iteration\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tswitch s[i] {\\n\\t\\tcase \\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\', \\'0\\':\\n\\t\\t\\t// construct a multi-digits number if any, e.g. \"23\" = 2*10+3 = 23\\n\\t\\t\\tj := i\\n\\t\\t\\tnum = 0\\n\\t\\t\\tfor j < len(s) && unicode.IsDigit(rune(s[j])) == true {\\n\\t\\t\\t\\tnum = num*10 + int(s[j]-\\'0\\')\\n\\t\\t\\t\\tj++\\n\\t\\t\\t}\\n\\t\\t\\t// sum up the intermediate result\\n\\t\\t\\tres += sign * num\\n\\t\\t\\t// since forloop add 1 at the end of closure, we -1\\n\\t\\t\\ti = j - 1\\n\\t\\tcase \\'+\\':\\n\\t\\t\\t// positive\\n\\t\\t\\tsign = 1\\n\\t\\tcase \\'-\\':\\n\\t\\t\\t// negative\\n\\t\\t\\tsign = -1\\n\\t\\tcase \\'(\\':\\n\\t\\t\\t// put the intermediate result(from the front) and sign into the stack\\n\\t\\t\\tstack = append(stack, res)\\n\\t\\t\\tstack = append(stack, sign)\\n\\t\\t\\t// since we have put the intermediate result in stack,\\n\\t\\t\\t// we can reset the things for calculation starting from this (\\n\\t\\t\\tres = 0\\n\\t\\t\\tsign = 1\\n\\t\\tcase \\')\\':\\n\\t\\t\\t// last item is the sign we saved for calculation e.g. 1+(2+3) the 1st +\\n\\t\\t\\tsign = stack[len(stack)-1]\\n\\t\\t\\t// previousLevelResult the intermediate result before this level, \"(...)\"\\n\\t\\t\\tpreviousLevelResult := stack[len(stack)-2]\\n\\t\\t\\t// pop them\\n\\t\\t\\tstack = stack[:len(stack)-2]\\n\\t\\t\\t// sign*res is the result within the current level, \"(...)\"\\n\\t\\t\\tres = previousLevelResult + sign*res\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\t1st approach:\\n\\t- use 2 stacks\\n\\t- the basic idea is to save each operator with the level of parenthesis, see type OpStack\\n\\t- when there is a ), sum up the result on the same parenthesis level, and decrement the global parenthesis level\\n\\n\\te.g. 1+2-(3+4-(5+6))+7\\n\\titerations on each token:\\n\\t1:\\tnumstack = [1]\\n\\t+:\\topstack = [(+,0)]\\n\\t2:\\tnumstack = [1,2]\\n\\t-:\\topstack = [(+,0),(-,0)]\\n\\t(:\\tparenthesesCount 0->1\\n\\t3:\\tnumstack = [1,2,3]\\n\\t+:\\topstack = [(+,0),(-,0),(+,1)]\\n\\t4:\\tnumstack = [1,2,3,4]\\n\\t-:\\topstack = [(+,0),(-,0),(+,1),(-,1)]\\n\\t(:\\tparenthesesCount 1->2\\n\\t5:\\tnumstack = [1,2,3,4,5]\\n\\t+:\\topstack = [(+,0),(-,0),(+,1),(-,1),(+,2)]\\n\\t6:\\tnumstack = [1,2,3,4,5,6]\\n\\t):\\tnumstack = [1,2,3,4,11], opstack = [(+,0),(-,0),(+,1),(-,1)], parenthesesCount 2->1\\n\\t):\\tnumstack = [1,2,-4], opstack = [(+,0),(-,0)], parenthesesCount 1->0\\n\\t+:\\topstack = [(+,0),(-,0),(+,0)]\\n\\t7+\\tnumstack = [1,2,-4,7]\\n\\tend: iterate the numstack and calculate 1+2-(-4)+7=>14\\n\\n\\tTime\\tO(2n) the nested loop actually just runs one time time\\n\\tSpace O(n)\\n\\t28 ms, faster than 25.49%\\n*/\\ntype OpStack struct {\\n\\toperator byte\\n\\tlevel    int\\n}\\n\\nfunc calculate(s string) int {\\n\\tparenthesesCount := 0\\n\\toperatorStack := []OpStack{}\\n\\tnumberStack := []int{}\\n\\ti := 0\\n\\tfor i < len(s) {\\n\\t    // construct a multi-digits number if any, e.g. \"23\" = 2*10+3 = 23\\n\\t\\tif unicode.IsDigit(rune(s[i])) == true {\\n\\t\\t\\tcurNum := 0\\n\\t\\t\\tj := i\\n\\t\\t\\tfor j < len(s) && unicode.IsDigit(rune(s[j])) == true {\\n\\t\\t\\t\\tcurNum = curNum*10 + int(s[j]-\\'0\\')\\n\\t\\t\\t\\tj++\\n\\t\\t\\t}\\n\\t\\t\\tnumberStack = append(numberStack, curNum)\\n\\t\\t\\ti = j\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif s[i] == \\'+\\' || s[i] == \\'-\\' {\\n\\t\\t\\toperatorStack = append(operatorStack, OpStack{s[i], parenthesesCount})\\n\\t\\t}\\n\\t\\tif s[i] == \\'(\\' {\\n\\t\\t\\tparenthesesCount++\\n\\t\\t}\\n\\t\\tif s[i] == \\')\\' {\\n\\t\\t\\tif len(operatorStack) == 0 {\\n\\t\\t\\t\\tparenthesesCount--\\n\\t\\t\\t\\ti++\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\t// pop the items on the same level for calculation\\n\\t\\t\\tlevel := operatorStack[len(operatorStack)-1].level\\n\\t\\t\\tarr := []int{}\\n\\t\\t\\toperators := []byte{}\\n\\n\\t\\t\\tpop := numberStack[len(numberStack)-1]\\n\\t\\t\\tnumberStack = numberStack[:len(numberStack)-1]\\n\\t\\t\\tarr = append([]int{pop}, arr...)\\n\\t\\t\\tfor len(operatorStack) > 0 && operatorStack[len(operatorStack)-1].level == level {\\n\\t\\t\\t\\tpop := numberStack[len(numberStack)-1]\\n\\t\\t\\t\\tnumberStack = numberStack[:len(numberStack)-1]\\n\\t\\t\\t\\tarr = append([]int{pop}, arr...)\\n\\n\\t\\t\\t\\tpopOp := operatorStack[len(operatorStack)-1]\\n\\t\\t\\t\\toperatorStack = operatorStack[:len(operatorStack)-1]\\n\\t\\t\\t\\toperators = append([]byte{popOp.operator}, operators...)\\n\\t\\t\\t}\\n\\t\\t\\t// calculate the result within the current \"(...)\"\\n\\t\\t\\ttemp := 0\\n\\t\\t\\top := \\'+\\'\\n\\t\\t\\tfor _, num := range arr {\\n\\t\\t\\t\\tif op == \\'+\\' {\\n\\t\\t\\t\\t\\ttemp += num\\n\\t\\t\\t\\t} else if op == \\'-\\' {\\n\\t\\t\\t\\t\\ttemp -= num\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif len(operators) > 0 {\\n\\t\\t\\t\\t\\top = rune(operators[0])\\n\\t\\t\\t\\t\\toperators = operators[1:]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tnumberStack = append(numberStack, temp)\\n\\t\\t\\tparenthesesCount--\\n\\t\\t}\\n\\t\\ti++\\n\\t}\\n\\t// calculate if there are still operators in the stack\\n\\ttemp := numberStack[0]\\n\\tnumberStack = numberStack[1:]\\n\\tfor len(operatorStack) > 0 {\\n\\t\\top := rune(operatorStack[0].operator)\\n\\t\\toperatorStack = operatorStack[1:]\\n\\n\\t\\tpop := numberStack[0]\\n\\t\\tnumberStack = numberStack[1:]\\n\\t\\tif op == \\'+\\' {\\n\\t\\t\\ttemp += pop\\n\\t\\t} else if op == \\'-\\' {\\n\\t\\t\\ttemp -= pop\\n\\t\\t}\\n\\t}\\n\\n\\treturn temp\\n}\\n```\n```\\n/*\\n\\t2nd approach: suggested solution at https://leetcode.com/problems/basic-calculator/discuss/62361/Iterative-Java-solution-with-stack\\n\\t- use 1 stack\\n\\t- calculate the numbers on the same level\\n\\t- when we see (, put the intermediate result into a stack, and new calculation start from the (\\n\\t- when we see ), pop the add/minus the result with the last item in the stack\\n\\n\\tTime\\tO(n) the nested loop actually just runs one time time\\n\\tSpace O(n)\\n\\t4 ms, faster than 90.20%\\n*/\\nfunc calculate1(s string) int {\\n\\tres := 0\\n\\tstack := make([]int, 0, len(s))\\n\\t// 1 means positive, -1 means negative\\n\\t// we declare it as an integer because we want to put the +- in the stack too\\n\\tsign := 1\\n\\tnum := 0\\n\\t// iteration\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tswitch s[i] {\\n\\t\\tcase \\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\', \\'0\\':\\n\\t\\t\\t// construct a multi-digits number if any, e.g. \"23\" = 2*10+3 = 23\\n\\t\\t\\tj := i\\n\\t\\t\\tnum = 0\\n\\t\\t\\tfor j < len(s) && unicode.IsDigit(rune(s[j])) == true {\\n\\t\\t\\t\\tnum = num*10 + int(s[j]-\\'0\\')\\n\\t\\t\\t\\tj++\\n\\t\\t\\t}\\n\\t\\t\\t// sum up the intermediate result\\n\\t\\t\\tres += sign * num\\n\\t\\t\\t// since forloop add 1 at the end of closure, we -1\\n\\t\\t\\ti = j - 1\\n\\t\\tcase \\'+\\':\\n\\t\\t\\t// positive\\n\\t\\t\\tsign = 1\\n\\t\\tcase \\'-\\':\\n\\t\\t\\t// negative\\n\\t\\t\\tsign = -1\\n\\t\\tcase \\'(\\':\\n\\t\\t\\t// put the intermediate result(from the front) and sign into the stack\\n\\t\\t\\tstack = append(stack, res)\\n\\t\\t\\tstack = append(stack, sign)\\n\\t\\t\\t// since we have put the intermediate result in stack,\\n\\t\\t\\t// we can reset the things for calculation starting from this (\\n\\t\\t\\tres = 0\\n\\t\\t\\tsign = 1\\n\\t\\tcase \\')\\':\\n\\t\\t\\t// last item is the sign we saved for calculation e.g. 1+(2+3) the 1st +\\n\\t\\t\\tsign = stack[len(stack)-1]\\n\\t\\t\\t// previousLevelResult the intermediate result before this level, \"(...)\"\\n\\t\\t\\tpreviousLevelResult := stack[len(stack)-2]\\n\\t\\t\\t// pop them\\n\\t\\t\\tstack = stack[:len(stack)-2]\\n\\t\\t\\t// sign*res is the result within the current level, \"(...)\"\\n\\t\\t\\tres = previousLevelResult + sign*res\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 236171,
                "title": "cannot-pass-the-test-case-2147483640-55",
                "content": "I run into overflow issues since int cannot handle such large number. Any insights on how to handle this?\\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int sign = 1, curr = 0, result = 0;\\n        stack<int> nums;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (isdigit(s[i])) {\\n                curr = s[i] - \\'0\\';\\n                while ( i + 1 < s.length() && isdigit(s[i + 1])) {\\n                    curr = curr*10 + (s[i + 1] - \\'0\\');\\n                    ++i;\\n                }\\n                result += sign*curr;\\n                sign = 1;\\n            } else if (s[i] == \\'+\\') {\\n                sign = 1;\\n            } else if (s[i] == \\'-\\') {\\n                sign = -1;\\n            } else if (s[i] == \\'(\\') {\\n                nums.push(result);\\n                nums.push(sign);\\n                sign = 1;\\n                result = 0;\\n            } else if (s[i] == \\')\\') {\\n                result *= nums.top();\\n                nums.pop();\\n                result += nums.top();\\n                nums.pop();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int sign = 1, curr = 0, result = 0;\\n        stack<int> nums;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (isdigit(s[i])) {\\n                curr = s[i] - \\'0\\';\\n                while ( i + 1 < s.length() && isdigit(s[i + 1])) {\\n                    curr = curr*10 + (s[i + 1] - \\'0\\');\\n                    ++i;\\n                }\\n                result += sign*curr;\\n                sign = 1;\\n            } else if (s[i] == \\'+\\') {\\n                sign = 1;\\n            } else if (s[i] == \\'-\\') {\\n                sign = -1;\\n            } else if (s[i] == \\'(\\') {\\n                nums.push(result);\\n                nums.push(sign);\\n                sign = 1;\\n                result = 0;\\n            } else if (s[i] == \\')\\') {\\n                result *= nums.top();\\n                nums.pop();\\n                result += nums.top();\\n                nums.pop();\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 194363,
                "title": "simple-parser-solution-in-python",
                "content": "In case you guys don\\'t know here is the grammar for the language of arithmetic expressions (http://www.cs.gordon.edu/courses/cps222/examples-2015/Recursion/grammar.pdf)\\n\\nSince we don\\'t need to support * and / it\\'s easy. Our Grammar is way restricted:\\n```\\n## Grammar\\nE  := T Op E | T\\nOp := + | -\\nT  := ( E ) | Num  \\n```\\n\\nAll we need is to split the input into tokens using regex (spare some effort removing whitespaces and building up the numbers).\\nMy simple regex: `\"\\\\d+|\\\\(|\\\\)|\\\\+|\\\\-\"`\\n\\nThen we build the recursive descent parser -> a parse method for every non-terminal (aka vars on the left side). But since we have only 2 (E and T) it\\'s fairly easy.\\n\\n```\\nimport re\\n\\nclass BinOp(object):\\n    def __init__(self, left, right):\\n        self.left = left\\n        self.right = right\\n\\nclass Plus(BinOp):\\n    def eval(self): return self.left.eval() + self.right.eval()\\n\\nclass Minus(BinOp):\\n    def eval(self): return self.left.eval() - self.right.eval()\\n\\nclass Number(object):\\n    def __init__(self, val): self.val = int(val)\\n    def eval(self): return self.val\\n\\nclass Parser(object):\\n    def lookahead(self): return self.tokens[self.idx]\\n    \\n    def consume(self): \\n        token = self.lookahead()\\n        self.idx += 1\\n        return token\\n    \\n    def parse(self, tokens): \\n        if len(tokens) == 0: return Number(0)\\n\\n        self.idx = 0\\n        self.tokens = tokens    \\n        return self.__parse_e__()\\n    \\n    def __parse_e__(self):\\n        t = self.__parse_v__()\\n        \\n        while self.idx < len(self.tokens) and self.lookahead() in [\\'+\\', \\'-\\']:\\n            op = self.consume()\\n            t1 = self.__parse_v__()\\n            t = Plus(t, t1) if op == \\'+\\' else Minus(t, t1)\\n            \\n        return t\\n    \\n    def __parse_v__(self):\\n        node = None\\n        if self.lookahead() == \\'(\\':\\n            self.consume() ## \\')\\'\\n            node = self.__parse_e__()\\n            self.consume() ## \\')\\'\\n        else:\\n            node = Number(self.consume())\\n        \\n        return node\\n\\nclass Solution(object):\\n    def calculate(self, s):\\n        def scan(s): return re.findall(\"\\\\d+|\\\\(|\\\\)|\\\\+|\\\\-\", filter(lambda char: char != \\' \\', s))\\n        \\n        tokens = scan(s)\\n        tree = Parser().parse(tokens)\\n        return tree.eval()\\n```",
                "solutionTags": [],
                "code": "```\\n## Grammar\\nE  := T Op E | T\\nOp := + | -\\nT  := ( E ) | Num  \\n```\n```\\nimport re\\n\\nclass BinOp(object):\\n    def __init__(self, left, right):\\n        self.left = left\\n        self.right = right\\n\\nclass Plus(BinOp):\\n    def eval(self): return self.left.eval() + self.right.eval()\\n\\nclass Minus(BinOp):\\n    def eval(self): return self.left.eval() - self.right.eval()\\n\\nclass Number(object):\\n    def __init__(self, val): self.val = int(val)\\n    def eval(self): return self.val\\n\\nclass Parser(object):\\n    def lookahead(self): return self.tokens[self.idx]\\n    \\n    def consume(self): \\n        token = self.lookahead()\\n        self.idx += 1\\n        return token\\n    \\n    def parse(self, tokens): \\n        if len(tokens) == 0: return Number(0)\\n\\n        self.idx = 0\\n        self.tokens = tokens    \\n        return self.__parse_e__()\\n    \\n    def __parse_e__(self):\\n        t = self.__parse_v__()\\n        \\n        while self.idx < len(self.tokens) and self.lookahead() in [\\'+\\', \\'-\\']:\\n            op = self.consume()\\n            t1 = self.__parse_v__()\\n            t = Plus(t, t1) if op == \\'+\\' else Minus(t, t1)\\n            \\n        return t\\n    \\n    def __parse_v__(self):\\n        node = None\\n        if self.lookahead() == \\'(\\':\\n            self.consume() ## \\')\\'\\n            node = self.__parse_e__()\\n            self.consume() ## \\')\\'\\n        else:\\n            node = Number(self.consume())\\n        \\n        return node\\n\\nclass Solution(object):\\n    def calculate(self, s):\\n        def scan(s): return re.findall(\"\\\\d+|\\\\(|\\\\)|\\\\+|\\\\-\", filter(lambda char: char != \\' \\', s))\\n        \\n        tokens = scan(s)\\n        tree = Parser().parse(tokens)\\n        return tree.eval()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62368,
                "title": "c-clean-code-iterative-recursion",
                "content": "**Iterative Solution using stack**\\n```\\n/**\\n * 1. update result - end of number; end of ')'\\n *    res += sign * num;\\n * 2. every operand num have a sign;\\n * 3. push temp result & sign on stack - begin of another \"(\"\\n */\\n```\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<tuple<int, int>> stk;\\n        int res = 0;\\n        int sign = 1;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (isdigit(s[i])) {\\n                int start = i;\\n                while (isdigit(s[i + 1])) { i++; }\\n                res += sign * stoi(s.substr(start, i + 1 - start));\\n            }\\n            else {\\n                if (s[i] == '+') {\\n                    sign = 1;\\n                }\\n                else if (s[i] == '-') {\\n                    sign = -1;\\n                }\\n                else if (s[i] == '(') {\\n                    stk.push(tuple<int, int>(sign, res));\\n                    sign = 1;\\n                    res = 0;\\n                }\\n                else if (s[i] == ')') {\\n                    res = res * get<0>(stk.top()) + get<1>(stk.top());\\n                    stk.pop();\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**StackFrame**\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<StackFrame> stk;\\n        int res = 0;\\n        int sign = 1;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] == '+') {\\n                sign = 1;\\n            }\\n            else if (s[i] == '-') {\\n                sign = -1;\\n            }\\n            else if (isdigit(s[i])) {\\n                int start = i;\\n                while (i + 1 < s.length() && isdigit(s[i + 1])) { i++; }\\n                res += sign * stoi(s.substr(start, i + 1 - start));\\n            }\\n            else if (s[i] == '(') {\\n                stk.push(StackFrame(res, sign));\\n                res = 0;\\n                sign = 1;\\n            }\\n            else if (s[i] == ')') {\\n                res = stk.top().base + stk.top().sign * res;\\n                stk.pop();\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\nprivate:\\n    struct StackFrame {\\n        int base;\\n        int sign;\\n        StackFrame(int base, int sign) : base(base), sign(sign) {};\\n    };\\n};\\n```\\n**Recursion Solution**\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int i = 0;\\n        return calculate(s, i);\\n    }\\n\\nprivate:\\n    int calculate(string& s, int& i) {\\n        int res = 0;\\n        int sign = 1;\\n        for (; i < s.length(); i++) {\\n            if (isdigit(s[i])) {\\n                int start = i;\\n                while (i + 1 < s.length() && isdigit(s[i + 1])) { i++; }\\n                res += sign * stoi(s.substr(start, i + 1 - start));\\n            }\\n            else if (s[i] == '(') {\\n                res += sign * calculate(s, ++i);\\n            }\\n            else if (s[i] == ')') {\\n                return res;\\n            }\\n            else if (s[i] == '+') {\\n                sign = 1;\\n            }\\n            else if (s[i] == '-') {\\n                sign = -1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * 1. update result - end of number; end of ')'\\n *    res += sign * num;\\n * 2. every operand num have a sign;\\n * 3. push temp result & sign on stack - begin of another \"(\"\\n */\\n```\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<tuple<int, int>> stk;\\n        int res = 0;\\n        int sign = 1;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (isdigit(s[i])) {\\n                int start = i;\\n                while (isdigit(s[i + 1])) { i++; }\\n                res += sign * stoi(s.substr(start, i + 1 - start));\\n            }\\n            else {\\n                if (s[i] == '+') {\\n                    sign = 1;\\n                }\\n                else if (s[i] == '-') {\\n                    sign = -1;\\n                }\\n                else if (s[i] == '(') {\\n                    stk.push(tuple<int, int>(sign, res));\\n                    sign = 1;\\n                    res = 0;\\n                }\\n                else if (s[i] == ')') {\\n                    res = res * get<0>(stk.top()) + get<1>(stk.top());\\n                    stk.pop();\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<StackFrame> stk;\\n        int res = 0;\\n        int sign = 1;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] == '+') {\\n                sign = 1;\\n            }\\n            else if (s[i] == '-') {\\n                sign = -1;\\n            }\\n            else if (isdigit(s[i])) {\\n                int start = i;\\n                while (i + 1 < s.length() && isdigit(s[i + 1])) { i++; }\\n                res += sign * stoi(s.substr(start, i + 1 - start));\\n            }\\n            else if (s[i] == '(') {\\n                stk.push(StackFrame(res, sign));\\n                res = 0;\\n                sign = 1;\\n            }\\n            else if (s[i] == ')') {\\n                res = stk.top().base + stk.top().sign * res;\\n                stk.pop();\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\nprivate:\\n    struct StackFrame {\\n        int base;\\n        int sign;\\n        StackFrame(int base, int sign) : base(base), sign(sign) {};\\n    };\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int i = 0;\\n        return calculate(s, i);\\n    }\\n\\nprivate:\\n    int calculate(string& s, int& i) {\\n        int res = 0;\\n        int sign = 1;\\n        for (; i < s.length(); i++) {\\n            if (isdigit(s[i])) {\\n                int start = i;\\n                while (i + 1 < s.length() && isdigit(s[i + 1])) { i++; }\\n                res += sign * stoi(s.substr(start, i + 1 - start));\\n            }\\n            else if (s[i] == '(') {\\n                res += sign * calculate(s, ++i);\\n            }\\n            else if (s[i] == ')') {\\n                return res;\\n            }\\n            else if (s[i] == '+') {\\n                sign = 1;\\n            }\\n            else if (s[i] == '-') {\\n                sign = -1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62404,
                "title": "general-solution-for-expression-that-contains-and-negative-integer",
                "content": "```Calculator I``` only contains ```+, -, (, )```, and ```Calculator II``` only contains ```+, -, *, /```, but during interview, we could be asked to write the code which need to take all these factors into consideration. So I come up with this solution, maybe some day LeetCode will add this ```Calculator III```.\\n```\\npublic class Solution {\\n    public int calculate(String s) {\\n        if(s == null || s.length() == 0) return 0;\\n\\n        // deal with the negative numbers\\n        if(s.charAt(0) == '-') s = \"0\" + s;\\n        s = s.replace(\"(-\", \"(0-\");\\n\\n        Stack<Character> ops = new Stack<>();\\n        Stack<Integer> nums = new Stack<>();\\n        char[] sArray = s.toCharArray();\\n\\n        for(int i = 0; i < sArray.length; i++) {\\n            char c = sArray[i];\\n            if(c >= '0' && c <= '9') {\\n                // get a complete number\\n                int currNum = c - '0';\\n                while(i + 1 < sArray.length && sArray[i + 1] >= '0' && sArray[i + 1] <= '9') {\\n                    currNum = 10 * currNum + (sArray[++i] - '0');\\n                }\\n\\n                // it is safe to make a calculation only if the previous sign is * or /\\n                if(!ops.isEmpty() && (ops.peek() == '*' || ops.peek() == '/')) {\\n                    int num2 = currNum, num1 = nums.pop();\\n                    nums.push(operation(num1, num2, ops.pop()));\\n                } else {\\n                    // if don't make a calculation, don't forget to push this new number\\n                    nums.push(currNum);\\n                }\\n            } else if(c == '+' || c == '-') {\\n                // it is safe to make a calculation only if the previous sign is not (\\n                if(!ops.isEmpty() && ops.peek() != '(') {\\n                    int num2 = nums.pop(), num1 = nums.pop();\\n                    nums.push(operation(num1, num2, ops.pop()));\\n                }\\n                ops.push(c);\\n            } else if(c == '*' || c == '/') {\\n                ops.push(c);\\n            } else if(c == '(') {\\n                ops.push(c);\\n            } else if(c == ')') {\\n                // make as many calculations as possible until the previous sign is (\\n                while(ops.peek() != '(') {\\n                    int num2 = nums.pop(), num1 = nums.pop();\\n                    nums.push(operation(num1, num2, ops.pop()));\\n                }\\n\\n                // don't forget to pop out the matching '('\\n                ops.pop();\\n            }\\n        }\\n\\n        // before return, pop out two stacks and do the rest of calculations\\n        while(!ops.isEmpty()) {\\n            int num2 = nums.pop(), num1 = nums.pop();\\n            nums.push(operation(num1, num2, ops.pop()));\\n        }\\n        return nums.peek();\\n    }\\n\\n    private int operation(int num1, int num2, char op) {\\n        if(op == '+') return num1 + num2;\\n        else if(op == '-') return num1 - num2;\\n        else if(op == '*') return num1 * num2;\\n        else return num1 / num2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Calculator I```\n```+, -, (, )```\n```Calculator II```\n```+, -, *, /```\n```Calculator III```\n```\\npublic class Solution {\\n    public int calculate(String s) {\\n        if(s == null || s.length() == 0) return 0;\\n\\n        // deal with the negative numbers\\n        if(s.charAt(0) == '-') s = \"0\" + s;\\n        s = s.replace(\"(-\", \"(0-\");\\n\\n        Stack<Character> ops = new Stack<>();\\n        Stack<Integer> nums = new Stack<>();\\n        char[] sArray = s.toCharArray();\\n\\n        for(int i = 0; i < sArray.length; i++) {\\n            char c = sArray[i];\\n            if(c >= '0' && c <= '9') {\\n                // get a complete number\\n                int currNum = c - '0';\\n                while(i + 1 < sArray.length && sArray[i + 1] >= '0' && sArray[i + 1] <= '9') {\\n                    currNum = 10 * currNum + (sArray[++i] - '0');\\n                }\\n\\n                // it is safe to make a calculation only if the previous sign is * or /\\n                if(!ops.isEmpty() && (ops.peek() == '*' || ops.peek() == '/')) {\\n                    int num2 = currNum, num1 = nums.pop();\\n                    nums.push(operation(num1, num2, ops.pop()));\\n                } else {\\n                    // if don't make a calculation, don't forget to push this new number\\n                    nums.push(currNum);\\n                }\\n            } else if(c == '+' || c == '-') {\\n                // it is safe to make a calculation only if the previous sign is not (\\n                if(!ops.isEmpty() && ops.peek() != '(') {\\n                    int num2 = nums.pop(), num1 = nums.pop();\\n                    nums.push(operation(num1, num2, ops.pop()));\\n                }\\n                ops.push(c);\\n            } else if(c == '*' || c == '/') {\\n                ops.push(c);\\n            } else if(c == '(') {\\n                ops.push(c);\\n            } else if(c == ')') {\\n                // make as many calculations as possible until the previous sign is (\\n                while(ops.peek() != '(') {\\n                    int num2 = nums.pop(), num1 = nums.pop();\\n                    nums.push(operation(num1, num2, ops.pop()));\\n                }\\n\\n                // don't forget to pop out the matching '('\\n                ops.pop();\\n            }\\n        }\\n\\n        // before return, pop out two stacks and do the rest of calculations\\n        while(!ops.isEmpty()) {\\n            int num2 = nums.pop(), num1 = nums.pop();\\n            nums.push(operation(num1, num2, ops.pop()));\\n        }\\n        return nums.peek();\\n    }\\n\\n    private int operation(int num1, int num2, char op) {\\n        if(op == '+') return num1 + num2;\\n        else if(op == '-') return num1 - num2;\\n        else if(op == '*') return num1 * num2;\\n        else return num1 / num2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62455,
                "title": "java-one-pass-solution-with-one-stack",
                "content": "The idea is to use a stack to record \"-\" or \"+\" sign before a \"(\". \\n\\n    public class Solution {\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        LinkedList<Integer> stack = new LinkedList<>();\\n        stack.push(1);\\n        int sign = 1;\\n        int start = 0;\\n        long rst = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == '+') {\\n                sign = 1;\\n            } else if (s.charAt(i) == '-') {\\n                sign = -1;\\n            } else if (s.charAt(i) == '(') {\\n                stack.push(sign * stack.peek());\\n                sign = 1;\\n            } else if (s.charAt(i) == ')') {\\n                stack.pop();\\n            }\\n            if (isDigit(s, i) && (i == 0 || !isDigit(s, i - 1))) {\\n                start = i;\\n            }\\n            if (isDigit(s, i) && (i == s.length() - 1 || !isDigit(s, i + 1))) {\\n                // find a number\\n                long num = Long.parseLong(s.substring(start, i + 1));\\n                num = num * sign * stack.peek();\\n                rst += num;\\n            }\\n        }\\n        return (int)rst;\\n    }\\n    boolean isDigit(String s, int i) {\\n        return s.charAt(i) >= '0' && s.charAt(i) <= '9';\\n    }",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 62461,
                "title": "recursive-function-java",
                "content": "    public class Solution {\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        return rec(s);\\n    }\\n    public int rec(String s){\\n        int curNum = 0;\\n        int preNum = 0;\\n        char oper = ' ';\\n        int i = 0;\\n        while (i < s.length()){\\n            char c = s.charAt(i);\\n            if (c == ' ') {\\n                i++;\\n                continue;\\n            }\\n            else if (c <= '9' && c >= '0') {\\n                curNum = curNum * 10 + c - '0';\\n                i++;\\n                continue;\\n            }\\n            else if (c == '+' || c == '-'){\\n                if (oper != ' '){\\n                    if (oper == '+') preNum = curNum + preNum;\\n                    else preNum = preNum - curNum;\\n                }\\n                else preNum = curNum;\\n                curNum = 0;\\n                oper = c;\\n                i++;\\n            }\\n            else {\\n                int index = i + 1;\\n                int count = 0;\\n                while (s.charAt(index) != ')' || count > 0) {\\n                    if (s.charAt(index) == '(') count++;\\n                    if (s.charAt(index) == ')') count--;\\n                    index++;\\n                }\\n                curNum = rec(s.substring(i + 1, index));\\n                i = index + 1;\\n            }\\n        }\\n        if (oper == ' ') return curNum;\\n        if (oper == '+') return preNum + curNum;\\n        else return preNum - curNum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        return rec(s);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 62466,
                "title": "java-short-solution-java8-new-syntax",
                "content": "    public class Solution {\\n\\n\\tprivate int num = 0;\\n\\tprivate int ans = 0;\\t\\n\\tprivate int sign = 1;\\n\\n    public int calculate(String s) {\\n    \\tStack<Integer> signs = new Stack<Integer>();\\n    \\ts = \"(\" + s + \")\";  // Every \"s\" can be viewed as \"+(s)\". Since we use \"sign = 1\" \\n    \\t\\t\\t\\t\\t\\t// to represent the proceeding \"+\", skip it from the string.\\n    \\t\\n\\t\\ts.chars().filter((c) -> (\"0123456789+-()\".contains(String.valueOf((char) (c))))).forEach((c) -> {\\n\\t\\t\\tif (c >= '0' && c <= '9') {\\n\\t\\t\\t\\tnum = 10 * num + c - '0';\\n\\t\\t\\t} else if (c == '+' || c == '-') {\\n\\t\\t\\t\\tans = ans + signs.peek() * sign * num;\\n\\t\\t\\t\\tnum = 0;\\n\\t\\t\\t\\tsign = (c == '+') ? 1 : -1;\\n\\t\\t\\t} else if (c == '(') {\\n\\t\\t\\t\\tif (!signs.isEmpty())\\n\\t\\t\\t\\t\\tsigns.push(sign * signs.peek());\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tsigns.push(sign);\\n\\t\\t\\t\\tsign = 1;\\n\\t\\t\\t} else if (c == ')') {\\n\\t\\t\\t\\tans = ans + signs.pop() * sign * num;\\n\\t\\t\\t\\tnum = 0;\\n\\t\\t\\t\\tsign = 1;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\treturn ans;\\n    }\\t\\n)",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n\\tprivate int num = 0;\\n\\tprivate int ans = 0;\\t\\n\\tprivate int sign = 1;\\n\\n    public int calculate(String s) {\\n    \\tStack<Integer> signs = new Stack<Integer>();\\n    \\ts = \"(\" + s + \")\";  // Every \"s\" can be viewed as \"+(s)\". Since we use \"sign = 1\" \\n    \\t\\t\\t\\t\\t\\t// to represent the proceeding \"+\", skip it from the string.\\n    \\t\\n\\t\\ts.chars().filter((c) -> (\"0123456789+-()\".contains(String.valueOf((char) (c))))).forEach((c) -> {\\n\\t\\t\\tif (c >= '0' && c <= '9') {\\n\\t\\t\\t\\tnum = 10 * num + c - '0';\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 62481,
                "title": "c-o-n-with-two-bool-signs-and-one-stack",
                "content": "Use one bool \"sign\" to get the operator before current number;\\nuse another bool \"presign\" to trace the actual operator of the nearest \"(\" before current number;\\n(actual operator means transfer operator inside \"( )\"  into global by virtually \"removing\" outer parenthesis)\\n\\nIf sign and presign are the same, means \"+\" and \"+\", or \"-\" and \"-\", so add it to result\\nelse reduce it from result.\\n\\nFor multiple layers parenthesis, use a stack as a buffer to recognize corresponding layer.\\n\\n    class Solution {\\n    public:\\n    \\tint calculate(string s)\\n    \\t{\\n        \\tint len = s.length();\\n        \\tint sum = 0;\\n        \\tbool presign = true, sign = true;\\n        \\tstack<int> stk;\\n        \\t\\n        \\tfor(int ii=0; ii<len; ++ii)\\n        \\t{\\n        \\t\\tchar cc = s[ii];\\n        \\t\\t\\n        \\t\\tif(' ' == cc)\\n        \\t\\t\\tcontinue;\\n        \\t\\tif('+' == cc)\\n        \\t\\t\\tsign = true;\\n        \\t\\telse if('-' == cc)\\n        \\t\\t\\tsign = false;\\n        \\t\\telse if('(' == cc)\\n        \\t\\t{\\n        \\t\\t\\tstk.push(presign);\\n        \\t\\t\\tpresign = (true == sign)?presign:(!presign);\\n        \\t\\t\\tsign = true;\\n        \\t\\t}\\n        \\t\\telse if(')' == cc)\\n        \\t\\t{\\n        \\t\\t\\tpresign = stk.top();\\n        \\t\\t\\tstk.pop();\\n        \\t\\t\\tsign = true;\\n        \\t\\t}\\n        \\t\\telse\\n        \\t\\t{\\n        \\t\\t\\tint num = s[ii] - '0';\\n        \\t\\t\\twhile(isdigit(s[++ii]))\\n        \\t\\t\\t\\tnum = 10*num + s[ii] - '0';\\n        \\t\\t\\tii--;\\t\\n    \\n        \\t\\t\\tsum += (sign==presign)? num : (0-num);\\n        \\t\\t}\\n        \\t}\\n    \\t\\treturn sum;\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tint calculate(string s)\\n    \\t{\\n        \\tint len = s.length();\\n        \\tint sum = 0;\\n        \\tbool presign = true, sign = true;\\n        \\tstack<int> stk;\\n        \\t\\n        \\tfor(int ii=0; ii<len; ++ii)\\n        \\t{\\n        \\t\\tchar cc = s[ii];\\n        \\t\\t\\n        \\t\\tif(' ' == cc)\\n        \\t\\t\\tcontinue;\\n        \\t\\tif('+' == cc)\\n        \\t\\t\\tsign = true;\\n        \\t\\telse if('-' == cc)\\n        \\t\\t\\tsign = false;\\n        \\t\\telse if('(' == cc)\\n        \\t\\t{\\n        \\t\\t\\tstk.push(presign);\\n        \\t\\t\\tpresign = (true == sign)?presign:(!presign);\\n        \\t\\t\\tsign = true;\\n        \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 62515,
                "title": "accepted-java-solution-easy-understood-with-explanations-no-need-to-convert-to-postfix-rnp",
                "content": "Explanations are in lines. \\nNo need to convert to RNP.\\nClear logic, easy to follow.\\n\\n\\n    public class Solution {\\n        public static int calculate(String expression)\\n        {\\n            char[] tokens = expression.toCharArray();\\n     \\n             // Stack for numbers: 'values'\\n            Stack<Integer> values = new Stack<Integer>();\\n     \\n            // Stack for Operators: 'ops'\\n            Stack<Character> ops = new Stack<Character>();\\n     \\n            for (int i = 0; i < tokens.length; i++)\\n            {\\n                 // Current token is a whitespace, skip it\\n                if (tokens[i] == ' ')\\n                    continue;\\n     \\n                // Current token is a number, push it to stack for numbers\\n                if (tokens[i] >= '0' && tokens[i] <= '9')\\n                {\\n                    StringBuffer sbuf = new StringBuffer();\\n                    // There may be more than one digits in number\\n                    while (i < tokens.length && tokens[i] >= '0' && tokens[i] <= '9')\\n                        sbuf.append(tokens[i++]);\\n                    values.push(Integer.parseInt(sbuf.toString()));\\n                    i--;\\n                    \\n                }\\n     \\n                // Current token is an opening brace, push it to 'ops'\\n                else if (tokens[i] == '(')\\n                    ops.push(tokens[i]);\\n     \\n                // Closing brace encountered, solve entire brace\\n                else if (tokens[i] == ')')\\n                {\\n                \\t\\n                    while (ops.peek() != '('){\\n                    \\tvalues.push(applyOp(ops.pop(), values.pop(), values.pop()));\\n                    }\\n                    if(ops.size()!=0){\\n                    \\tops.pop();\\n                    }\\n                    \\n                }\\n     \\n                // Current token is an operator.\\n                else if (tokens[i] == '+' || tokens[i] == '-' ||\\n                         tokens[i] == '*' || tokens[i] == '/')\\n                {\\n                    // While top of 'ops' has same or greater precedence to current\\n                    // token, which is an operator. Apply operator on top of 'ops'\\n                    // to top two elements in values stack\\n                    while (!ops.empty() && hasPrecedence(tokens[i], ops.peek()))\\n                      values.push(applyOp(ops.pop(), values.pop(), values.pop()));\\n     \\n                    // Push current token to 'ops'.\\n                    ops.push(tokens[i]);\\n                }\\n            }\\n     \\n            // Entire expression has been parsed at this point, apply remaining\\n            // ops to remaining values\\n            \\n            while (!ops.empty())\\n            {\\tif(values.size()==1)\\n                return values.pop();\\n                values.push(applyOp(ops.pop(), values.pop(), values.pop()));\\n            }\\n     \\n            // Top of 'values' contains result, return it\\n            return values.pop();\\n        }\\n     \\n        // Returns true if 'op2' has higher or same precedence as 'op1',\\n        // otherwise returns false.\\n        public static boolean hasPrecedence(char op1, char op2)\\n        {\\n            if (op2 == '(' || op2 == ')')\\n                return false;\\n            if ((op1 == '*' || op1 == '/') && (op2 == '+' || op2 == '-'))\\n                return false;\\n            else\\n                return true;\\n        }\\n     \\n        // A utility method to apply an operator 'op' on operands 'a'\\n        // and 'b'. Return the result.\\n        public static int applyOp(char op, int b, int a)\\n        {\\n            switch (op)\\n            {\\n            case '+':\\n                return a + b;\\n            case '-':\\n                return a - b;\\n            case '*':\\n                return a * b;\\n            case '/':\\n                if (b == 0)\\n                    throw new\\n                    UnsupportedOperationException(\"Cannot divide by zero\");\\n                return a / b;\\n            }\\n            return 0;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public static int calculate(String expression)\\n        {\\n            char[] tokens = expression.toCharArray();\\n     \\n             // Stack for numbers: 'values'\\n            Stack<Integer> values = new Stack<Integer>();\\n     \\n            // Stack for Operators: 'ops'\\n            Stack<Character> ops = new Stack<Character>();\\n     \\n            for (int i = 0; i < tokens.length; i++)\\n            {\\n                 // Current token is a whitespace, skip it\\n                if (tokens[i] == ' ')\\n                    continue;\\n     \\n                // Current token is a number, push it to stack for numbers\\n                if (tokens[i] >= '0' && tokens[i] <= '9')\\n                {\\n                    StringBuffer sbuf = new StringBuffer();\\n                    // There may be more than one digits in number\\n                    while (i < tokens.length && tokens[i] >= '0' && tokens[i] <= '9')\\n                        sbuf.append(tokens[i++]);\\n                    values.push(Integer.parseInt(sbuf.toString()));\\n                    i--;\\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4026801,
                "title": "unique-recursive-solution",
                "content": "# Intuition\\nUsing the approach for Basic Calculator - 2 and using that recursively whenever we encounter an opening bracket..because starting of opening bracket is like a fresh problem.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int i = 0;\\n        return helper(s, i);\\n    }\\n\\n    int helper(string& s, int& i) {\\n        int ans = 0, interim = 0; \\n        long long num = 0;\\n        char op = \\'+\\';\\n        while (i < s.size()) {\\n            if (isdigit(s[i])) \\n            {\\n                num = 0;\\n                while (i < s.size() && isdigit(s[i])) {\\n                    num = num * 10 + s[i] - \\'0\\';\\n                    i++;\\n                }\\n                \\n                if (op == \\'+\\' || op == \\'-\\') \\n                {\\n                    ans += interim;\\n                    if(op == \\'-\\') interim= -1*num;\\n                    else interim = num;\\n                } \\n                else if (op == \\'*\\') \\n                {\\n                    interim *= num;\\n                } \\n                else if (op == \\'/\\') \\n                {\\n                    interim /= num;\\n                }\\n            } \\n            else if (s[i] == \\'(\\') \\n            {\\n                i++; // skip the \\'(\\'\\n                num = helper(s, i);\\n                \\n                if (op == \\'+\\' || op == \\'-\\') \\n                {\\n                    ans += interim;\\n                    if(op == \\'-\\') interim= -1*num;\\n                    else interim = num;\\n                } \\n                else if (op == \\'*\\') \\n                {\\n                    interim *= num;\\n                } \\n                else if (op == \\'/\\') \\n                {\\n                    interim /= num;\\n                }\\n            } \\n            else if (s[i] == \\')\\') \\n            {\\n                i++; // skip the \\')\\'\\n                break; // exit the current level of recursion\\n            } \\n            else \\n            {\\n                if (s[i] != \\' \\') op = s[i];\\n                i++;\\n            }\\n        }\\n        ans += interim;\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Dynamic Programming",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int i = 0;\\n        return helper(s, i);\\n    }\\n\\n    int helper(string& s, int& i) {\\n        int ans = 0, interim = 0; \\n        long long num = 0;\\n        char op = \\'+\\';\\n        while (i < s.size()) {\\n            if (isdigit(s[i])) \\n            {\\n                num = 0;\\n                while (i < s.size() && isdigit(s[i])) {\\n                    num = num * 10 + s[i] - \\'0\\';\\n                    i++;\\n                }\\n                \\n                if (op == \\'+\\' || op == \\'-\\') \\n                {\\n                    ans += interim;\\n                    if(op == \\'-\\') interim= -1*num;\\n                    else interim = num;\\n                } \\n                else if (op == \\'*\\') \\n                {\\n                    interim *= num;\\n                } \\n                else if (op == \\'/\\') \\n                {\\n                    interim /= num;\\n                }\\n            } \\n            else if (s[i] == \\'(\\') \\n            {\\n                i++; // skip the \\'(\\'\\n                num = helper(s, i);\\n                \\n                if (op == \\'+\\' || op == \\'-\\') \\n                {\\n                    ans += interim;\\n                    if(op == \\'-\\') interim= -1*num;\\n                    else interim = num;\\n                } \\n                else if (op == \\'*\\') \\n                {\\n                    interim *= num;\\n                } \\n                else if (op == \\'/\\') \\n                {\\n                    interim /= num;\\n                }\\n            } \\n            else if (s[i] == \\')\\') \\n            {\\n                i++; // skip the \\')\\'\\n                break; // exit the current level of recursion\\n            } \\n            else \\n            {\\n                if (s[i] != \\' \\') op = s[i];\\n                i++;\\n            }\\n        }\\n        ans += interim;\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708272,
                "title": "simple-explanation-for-a-very-complicated-problem",
                "content": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        # sign == 1 means +\\n        # sign == -1 means -\\n        # By default the sign is + i.e. 1\\n        \\n        current, output, sign, stack = 0, 0, 1, []\\n        \\n        for c in s:\\n            #Here we are trying to find the current number\\n            #since current number can be of multiple digits hence we need to do \\n            #these calculations. \\n            if c.isdigit(): \\n                current = current * 10 + int(c)\\n                \\n            #when we see a sign, we will update our current number to + or -.\\n            #To do so, we will use the sign we saw last time, remmeber the sign\\n            #is + by default. So, if we did not see any sign last time, then \\n            #the number is made positive. \\n            #we set output to current and current to zero, bc from now on we want\\n            #to find new current(second value for our calculation)\\n            #We also update the sign variable to -1 or +1, because we will use this\\n            #to assign sign to the next value we will find. \\n            elif c in \\'+-\\':\\n                output += current*sign\\n                current = 0 \\n                if c == \\'-\\':\\n                    sign = -1\\n                else:\\n                    sign = 1\\n                    \\n            #If we see \\'(\\', we will append output and sign to the stack. \\n            #We need to do this because if we see \\'(\\' we will 100% see \\')\\'\\n            #And when we see \\')\\' we will use the stack to get the value and sign for\\n            #the calculation. \\n            #we will also reset output and sign, because inside \\'(\\', we will have\\n            #to do new calculations and we can use stack to do this unifinished \\n            #calculation.\\n            elif c == \\'(\\':\\n                stack.append(output)\\n                stack.append(sign)\\n                output = 0\\n                sign = 1\\n                \\n            \\n            #We we see \\')\\', that means first we need to finished the inner \\n            #calculation ie between (). If you notice when we get \\')\\', we have not\\n            #finished the calculation because we come directly to this branch. \\n            #in order to finish last calculation of (), we have to write two\\n            #statements here. Once last calculation is complete, we not put a sign\\n            #to the output, this is because whatever was the sign before \\'(\\'\\n            #that should be the sign of the whole expression(output).\\n            #eg 1 - (3+2) means 1 - (5) and sign of 5 should be \\'-\\'\\n            #so we put sign to output and add it to the stack top. \\n            #This may be addition or subtraction depending on the sign. \\n            elif c == \\')\\':\\n                output += current * sign \\n                current = 0\\n                \\n                output = output * stack.pop() #This is also a sign ie -1 or 1\\n                output += stack.pop() #this is the last result\\n                \\n        \\n        #If there are no left or right parans in the equation, in that case\\n        #We will have to add current * sign(making current negative if thats the\\n\\t\\t#case) to the output and return that. \\n        return output + (current * sign)\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        # sign == 1 means +\\n        # sign == -1 means -\\n        # By default the sign is + i.e. 1\\n        \\n        current, output, sign, stack = 0, 0, 1, []\\n        \\n        for c in s:\\n            #Here we are trying to find the current number\\n            #since current number can be of multiple digits hence we need to do \\n            #these calculations. \\n            if c.isdigit(): \\n                current = current * 10 + int(c)\\n                \\n            #when we see a sign, we will update our current number to + or -.\\n            #To do so, we will use the sign we saw last time, remmeber the sign\\n            #is + by default. So, if we did not see any sign last time, then \\n            #the number is made positive. \\n            #we set output to current and current to zero, bc from now on we want\\n            #to find new current(second value for our calculation)\\n            #We also update the sign variable to -1 or +1, because we will use this\\n            #to assign sign to the next value we will find. \\n            elif c in \\'+-\\':\\n                output += current*sign\\n                current = 0 \\n                if c == \\'-\\':\\n                    sign = -1\\n                else:\\n                    sign = 1\\n                    \\n            #If we see \\'(\\', we will append output and sign to the stack. \\n            #We need to do this because if we see \\'(\\' we will 100% see \\')\\'\\n            #And when we see \\')\\' we will use the stack to get the value and sign for\\n            #the calculation. \\n            #we will also reset output and sign, because inside \\'(\\', we will have\\n            #to do new calculations and we can use stack to do this unifinished \\n            #calculation.\\n            elif c == \\'(\\':\\n                stack.append(output)\\n                stack.append(sign)\\n                output = 0\\n                sign = 1\\n                \\n            \\n            #We we see \\')\\', that means first we need to finished the inner \\n            #calculation ie between (). If you notice when we get \\')\\', we have not\\n            #finished the calculation because we come directly to this branch. \\n            #in order to finish last calculation of (), we have to write two\\n            #statements here. Once last calculation is complete, we not put a sign\\n            #to the output, this is because whatever was the sign before \\'(\\'\\n            #that should be the sign of the whole expression(output).\\n            #eg 1 - (3+2) means 1 - (5) and sign of 5 should be \\'-\\'\\n            #so we put sign to output and add it to the stack top. \\n            #This may be addition or subtraction depending on the sign. \\n            elif c == \\')\\':\\n                output += current * sign \\n                current = 0\\n                \\n                output = output * stack.pop() #This is also a sign ie -1 or 1\\n                output += stack.pop() #this is the last result\\n                \\n        \\n        #If there are no left or right parans in the equation, in that case\\n        #We will have to add current * sign(making current negative if thats the\\n\\t\\t#case) to the output and return that. \\n        return output + (current * sign)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687154,
                "title": "binbin-solved-another-hard-question-very-happy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        res = 0\\n        pre_op = \"+\"\\n        s += \"+\"\\n        num = 0\\n        stack = []\\n        for i in s:\\n            #print(i)\\n            #print(num,res,pre_op,stack)\\n            if i.isdigit():\\n                num = num*10 + int(i)\\n            elif i == \" \":\\n                continue\\n            elif i in [\"+\",\"-\"]:\\n                if pre_op == \"+\":\\n                    res += num\\n                else:\\n                    res -= num\\n                pre_op = i\\n                num = 0\\n            elif i == \"(\":\\n                stack.append(res)\\n                stack.append(pre_op)\\n                res = 0\\n                num = 0\\n                pre_op = \"+\"\\n            elif i == \")\":\\n                if pre_op == \"+\":\\n                    res += num\\n                else:\\n                    res -= num\\n                if stack[-1] == \"+\":\\n                    #res += num\\n                    stack.pop()\\n                    res += stack.pop()\\n                elif stack[-1] == \"-\":\\n                   # res -= num\\n                    stack.pop()\\n                    res = stack.pop() - res\\n                num = 0\\n                pre_op = \"+\"\\n        return res \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        res = 0\\n        pre_op = \"+\"\\n        s += \"+\"\\n        num = 0\\n        stack = []\\n        for i in s:\\n            #print(i)\\n            #print(num,res,pre_op,stack)\\n            if i.isdigit():\\n                num = num*10 + int(i)\\n            elif i == \" \":\\n                continue\\n            elif i in [\"+\",\"-\"]:\\n                if pre_op == \"+\":\\n                    res += num\\n                else:\\n                    res -= num\\n                pre_op = i\\n                num = 0\\n            elif i == \"(\":\\n                stack.append(res)\\n                stack.append(pre_op)\\n                res = 0\\n                num = 0\\n                pre_op = \"+\"\\n            elif i == \")\":\\n                if pre_op == \"+\":\\n                    res += num\\n                else:\\n                    res -= num\\n                if stack[-1] == \"+\":\\n                    #res += num\\n                    stack.pop()\\n                    res += stack.pop()\\n                elif stack[-1] == \"-\":\\n                   # res -= num\\n                    stack.pop()\\n                    res = stack.pop() - res\\n                num = 0\\n                pre_op = \"+\"\\n        return res \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683723,
                "title": "c-solution-easy",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<int> st;\\n        int sum =0;\\n        int sign =1;\\n        int n = s.size(); \\n\\n        for(int i=0; i<n; i++){\\n            //check if number\\n            if(s[i]>=\\'0\\' && s[i]<=\\'9\\'){\\n                int num =0;\\n                while(i<n && s[i]>=\\'0\\' && s[i]<=\\'9\\'){\\n                    num = num*10 + (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                sum = sum + sign* num;\\n                i--;\\n            }\\n    \\n            //check if sign \\'-\\' or \\'+\\'\\n\\n            else if(s[i] == \\'+\\'){\\n                sign = 1;\\n            }\\n            else if(s[i] == \\'-\\'){\\n                sign = -1;\\n            }\\n            //check if \\'(\\' or \\')\\'\\n            else if(s[i] == \\'(\\'){\\n                st.push(sum);\\n                st.push(sign);\\n                sum =0;\\n                sign =1;\\n            }\\n            else if(s[i] == \\')\\'){\\n                sum = sum* st.top();\\n                st.pop();\\n                sum = sum +  st.top();\\n                st.pop();\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<int> st;\\n        int sum =0;\\n        int sign =1;\\n        int n = s.size(); \\n\\n        for(int i=0; i<n; i++){\\n            //check if number\\n            if(s[i]>=\\'0\\' && s[i]<=\\'9\\'){\\n                int num =0;\\n                while(i<n && s[i]>=\\'0\\' && s[i]<=\\'9\\'){\\n                    num = num*10 + (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                sum = sum + sign* num;\\n                i--;\\n            }\\n    \\n            //check if sign \\'-\\' or \\'+\\'\\n\\n            else if(s[i] == \\'+\\'){\\n                sign = 1;\\n            }\\n            else if(s[i] == \\'-\\'){\\n                sign = -1;\\n            }\\n            //check if \\'(\\' or \\')\\'\\n            else if(s[i] == \\'(\\'){\\n                st.push(sum);\\n                st.push(sign);\\n                sum =0;\\n                sign =1;\\n            }\\n            else if(s[i] == \\')\\'){\\n                sum = sum* st.top();\\n                st.pop();\\n                sum = sum +  st.top();\\n                st.pop();\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613339,
                "title": "very-simple-c-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int i=0;\\n        int n=s.size();\\n        int ans=0;\\n        stack<int>st;\\n        int sign=1;\\n        while(i<n) {\\n            char c=s[i];\\n            if(isdigit(c)) {\\n                int num=0;\\n                while(i<n && isdigit(s[i])) {\\n                    num=num*10+(s[i]-\\'0\\');\\n                    i++;\\n                }\\n                ans+=sign*num;\\n            } \\n            else if(c==\\'+\\') {\\n                sign=1;\\n                i++;\\n            } \\n            else if(c==\\'-\\') {\\n                sign=-1;\\n                i++;\\n            } \\n            else if(c==\\'(\\') {\\n                st.push(ans);\\n                st.push(sign);\\n                ans=0;\\n                sign=1;\\n                i++;\\n            } \\n            else if(c==\\')\\') {\\n                int prevSign=st.top();\\n                st.pop();\\n                int prevAns=st.top();\\n                st.pop();\\n                ans=prevAns+(prevSign * ans);\\n                i++;\\n            } \\n            else{\\n                i++;  \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int i=0;\\n        int n=s.size();\\n        int ans=0;\\n        stack<int>st;\\n        int sign=1;\\n        while(i<n) {\\n            char c=s[i];\\n            if(isdigit(c)) {\\n                int num=0;\\n                while(i<n && isdigit(s[i])) {\\n                    num=num*10+(s[i]-\\'0\\');\\n                    i++;\\n                }\\n                ans+=sign*num;\\n            } \\n            else if(c==\\'+\\') {\\n                sign=1;\\n                i++;\\n            } \\n            else if(c==\\'-\\') {\\n                sign=-1;\\n                i++;\\n            } \\n            else if(c==\\'(\\') {\\n                st.push(ans);\\n                st.push(sign);\\n                ans=0;\\n                sign=1;\\n                i++;\\n            } \\n            else if(c==\\')\\') {\\n                int prevSign=st.top();\\n                st.pop();\\n                int prevAns=st.top();\\n                st.pop();\\n                ans=prevAns+(prevSign * ans);\\n                i++;\\n            } \\n            else{\\n                i++;  \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920297,
                "title": "beats-99-codedominar-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        stack = []\\n        cur,ans = 0,0\\n        sign = 1\\n        for c in s:\\n            if c.isdigit():\\n                cur = cur*10 + int(c)\\n            elif c in \\'+-\\':\\n                ans += sign*cur\\n                sign = -1 if c == \\'-\\' else 1\\n                cur = 0\\n            elif c == \\'(\\':\\n                stack.append(ans)\\n                stack.append(sign)\\n                ans = 0\\n                sign = 1\\n            elif c == \\')\\':\\n                ans += sign*cur\\n                ans *= stack.pop()\\n                ans += stack.pop()\\n                cur = 0\\n        return ans + sign*cur\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        stack = []\\n        cur,ans = 0,0\\n        sign = 1\\n        for c in s:\\n            if c.isdigit():\\n                cur = cur*10 + int(c)\\n            elif c in \\'+-\\':\\n                ans += sign*cur\\n                sign = -1 if c == \\'-\\' else 1\\n                cur = 0\\n            elif c == \\'(\\':\\n                stack.append(ans)\\n                stack.append(sign)\\n                ans = 0\\n                sign = 1\\n            elif c == \\')\\':\\n                ans += sign*cur\\n                ans *= stack.pop()\\n                ans += stack.pop()\\n                cur = 0\\n        return ans + sign*cur\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880532,
                "title": "simple-approach-c-easy-to-understand",
                "content": "# Intuition\\nuse stack and iterating from end \\n\\n# Approach\\napproch is simply to iterate from end of string and in first iteration we just evaluates all brackets in expression and in second expression we can simply evaluate all values and get final answer\\n\\n# Complexity\\n- Time complexity:\\ntime complexity to this solution is O(3n) which finally evaluates to  o(n)\\n\\n- Space complexity:\\nspace complexity to this solution is o(n) for stroing whole string in stack \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<char> st;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]!=\\' \\'){\\n                if(st.empty()){\\n                    st.push(s[i]);\\n                }else{\\n                    if(s[i]==\\'(\\'){\\n\\n                        int bracket_evaluation=0;\\n                        \\n                        \\n                        while(st.top()!=\\')\\'){\\n                            int symbol=1;\\n                            int d=0;\\n                            if(st.top()==\\'-\\'){\\n\\n                                //removing symbol\\n                                st.pop();\\n                                symbol=-1;\\n\\n                            }else{\\n\\n                                if(st.top()==\\'+\\'){\\n                                    //removing symbol\\n                                    st.pop();\\n                                }\\n\\n                            }\\n                            if(!st.empty() && st.top()==\\'-\\'){\\n                                st.pop();\\n                                symbol*=-1;\\n                            }\\n\\n                            //making the integer if it is greater than 9\\n                            while(st.top()-\\'0\\'<=9 && st.top()-\\'0\\'>=0){\\n                                d=(d*10)+(st.top()-\\'0\\');\\n                                st.pop();\\n                            }\\n                            d*=symbol;\\n                            //aading value to total bracket evaluation\\n                            bracket_evaluation+=d;\\n                        }\\n                        \\n                        //removing the opening bracket from stack\\n                        st.pop();\\n                        bool negative=false;\\n                        if(bracket_evaluation<0){\\n                            bracket_evaluation*=-1;\\n                            negative=true;\\n                        }\\n                        //push final evaluation in stack in correct order\\n                        string m=to_string(bracket_evaluation);\\n                        cout<<m<<endl;\\n                        for(int k=m.size()-1;k>=0;k--){\\n                            st.push(m[k]);\\n                        }\\n                        if(negative){\\n                            st.push(\\'-\\');\\n                        }\\n                    }else{\\n                        st.push(s[i]);\\n                    }\\n                }\\n            }\\n        }\\n        long long final_evaluation=0;\\n        while(!st.empty()){\\n            //making the integer if it is greater than 9\\n            long long d=0;\\n            int symbol=1;\\n            //checking its symbol and then addition to result\\n            if(!st.empty() && st.top()==\\'-\\'){\\n                st.pop();\\n                symbol=-1;\\n            }else{\\n                if(!st.empty() && st.top()==\\'+\\'){\\n                    st.pop();\\n                }\\n            }\\n            if(!st.empty() && st.top()==\\'-\\'){\\n                st.pop();\\n                symbol*=-1;\\n            }\\n            while(!st.empty() && st.top()-\\'0\\'<=9 && st.top()-\\'0\\'>=0){\\n                d=(d*10)+st.top()-\\'0\\';\\n                st.pop();\\n            }\\n            d*=symbol;\\n            final_evaluation+=d;\\n        }\\n        \\n        return final_evaluation;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<char> st;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]!=\\' \\'){\\n                if(st.empty()){\\n                    st.push(s[i]);\\n                }else{\\n                    if(s[i]==\\'(\\'){\\n\\n                        int bracket_evaluation=0;\\n                        \\n                        \\n                        while(st.top()!=\\')\\'){\\n                            int symbol=1;\\n                            int d=0;\\n                            if(st.top()==\\'-\\'){\\n\\n                                //removing symbol\\n                                st.pop();\\n                                symbol=-1;\\n\\n                            }else{\\n\\n                                if(st.top()==\\'+\\'){\\n                                    //removing symbol\\n                                    st.pop();\\n                                }\\n\\n                            }\\n                            if(!st.empty() && st.top()==\\'-\\'){\\n                                st.pop();\\n                                symbol*=-1;\\n                            }\\n\\n                            //making the integer if it is greater than 9\\n                            while(st.top()-\\'0\\'<=9 && st.top()-\\'0\\'>=0){\\n                                d=(d*10)+(st.top()-\\'0\\');\\n                                st.pop();\\n                            }\\n                            d*=symbol;\\n                            //aading value to total bracket evaluation\\n                            bracket_evaluation+=d;\\n                        }\\n                        \\n                        //removing the opening bracket from stack\\n                        st.pop();\\n                        bool negative=false;\\n                        if(bracket_evaluation<0){\\n                            bracket_evaluation*=-1;\\n                            negative=true;\\n                        }\\n                        //push final evaluation in stack in correct order\\n                        string m=to_string(bracket_evaluation);\\n                        cout<<m<<endl;\\n                        for(int k=m.size()-1;k>=0;k--){\\n                            st.push(m[k]);\\n                        }\\n                        if(negative){\\n                            st.push(\\'-\\');\\n                        }\\n                    }else{\\n                        st.push(s[i]);\\n                    }\\n                }\\n            }\\n        }\\n        long long final_evaluation=0;\\n        while(!st.empty()){\\n            //making the integer if it is greater than 9\\n            long long d=0;\\n            int symbol=1;\\n            //checking its symbol and then addition to result\\n            if(!st.empty() && st.top()==\\'-\\'){\\n                st.pop();\\n                symbol=-1;\\n            }else{\\n                if(!st.empty() && st.top()==\\'+\\'){\\n                    st.pop();\\n                }\\n            }\\n            if(!st.empty() && st.top()==\\'-\\'){\\n                st.pop();\\n                symbol*=-1;\\n            }\\n            while(!st.empty() && st.top()-\\'0\\'<=9 && st.top()-\\'0\\'>=0){\\n                d=(d*10)+st.top()-\\'0\\';\\n                st.pop();\\n            }\\n            d*=symbol;\\n            final_evaluation+=d;\\n        }\\n        \\n        return final_evaluation;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2834479,
                "title": "python3-o-n-stack-solution",
                "content": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        val_stack = []\\n        cur_num = 0\\n        total = 0\\n        sign = 1\\n        for c in s:\\n            if c.isdigit():\\n                cur_num*=10\\n                cur_num+=int(c)\\n            elif c==\\'+\\':\\n                total+=cur_num*sign\\n                cur_num = 0\\n                sign = 1\\n            elif c==\\'-\\':\\n                total+=cur_num*sign\\n                cur_num = 0\\n                sign = -1\\n            elif c==\\'(\\':\\n                val_stack.append(total)\\n                val_stack.append(sign)\\n                sign = 1\\n                total = 0\\n            elif c==\\')\\':\\n                total += sign * cur_num\\n                cur_num = 0\\n                total *= val_stack.pop()\\n                total += val_stack.pop()\\n        if cur_num: total += sign * cur_num\\n        return total\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        val_stack = []\\n        cur_num = 0\\n        total = 0\\n        sign = 1\\n        for c in s:\\n            if c.isdigit():\\n                cur_num*=10\\n                cur_num+=int(c)\\n            elif c==\\'+\\':\\n                total+=cur_num*sign\\n                cur_num = 0\\n                sign = 1\\n            elif c==\\'-\\':\\n                total+=cur_num*sign\\n                cur_num = 0\\n                sign = -1\\n            elif c==\\'(\\':\\n                val_stack.append(total)\\n                val_stack.append(sign)\\n                sign = 1\\n                total = 0\\n            elif c==\\')\\':\\n                total += sign * cur_num\\n                cur_num = 0\\n                total *= val_stack.pop()\\n                total += val_stack.pop()\\n        if cur_num: total += sign * cur_num\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834082,
                "title": "c-easy-explanation-stack-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    int calculate(string s) {\\n        \\n        int number = 0;\\n        int result = 0;\\n        int sigh = 1;\\n        \\n        stack<int>st;\\n        \\n        for(int i = 0;i<s.size();i++){\\n\\n          if(isdigit(s[i])){  //if s[i] is digite\\n\\n          number = 10*number+(s[i]-\\'0\\'); //find out the current number\\n              \\n          \\n          }\\n           \\n           else if(s[i] == \\'+\\'){\\n \\n               result += number*sigh;\\n               \\n               number = 0;\\n               sigh = 1;\\n               \\n           \\n           \\n           }\\n            else if(s[i] == \\'-\\'){\\n \\n               result += number*sigh;\\n               \\n               number = 0;\\n               sigh = -1;\\n               \\n           \\n           \\n           }\\n            else if(s[i] == \\'(\\'){\\n \\n                st.push(result);\\n                st.push(sigh);\\n                number = 0;\\n                result = 0;\\n                sigh = 1;\\n                \\n\\n            \\n            }\\n            else if(s[i] == \\')\\'){\\n \\n                result += number*sigh;\\n                number = 0;\\n                int top = st.top();\\n                st.pop();\\n                result *= top;\\n                \\n                top = st.top();\\n                st.pop();\\n                \\n                result +=top;\\n                \\n                \\n             \\n            \\n            }\\n            \\n            \\n        \\n        }\\n        \\n        result += number*sigh;\\n        \\n        return result;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int calculate(string s) {\\n        \\n        int number = 0;\\n        int result = 0;\\n        int sigh = 1;\\n        \\n        stack<int>st;\\n        \\n        for(int i = 0;i<s.size();i++){\\n\\n          if(isdigit(s[i])){  //if s[i] is digite\\n\\n          number = 10*number+(s[i]-\\'0\\'); //find out the current number\\n              \\n          \\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2834072,
                "title": "java-stack-not-that-easy",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int calculate(String s) {\\n        int n = s.length();\\n        int sign = 1, sum = 0;\\n\\n        Stack<Integer> stack = new Stack<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            char c = s.charAt(i);\\n\\n            if (Character.isDigit(c)) {\\n                int currNo = c - \\'0\\';\\n                while (i + 1 < n && Character.isDigit(s.charAt(i + 1))) {\\n                    currNo = currNo * 10 + s.charAt(i + 1) - \\'0\\';\\n                    i++;\\n                }\\n\\t\\t\\t\\t\\n                currNo *= sign;\\n                sum += currNo;\\n                sign = 1;\\n            }\\n\\t\\t\\t\\n            else if (c == \\'+\\') sign = 1;\\n            else if (c == \\'-\\') sign = -1;\\n            else if (c == \\'(\\') {\\n                stack.push(sum);\\n                stack.push(sign);\\n                sum = 0;\\n                sign = 1;\\n            }\\n\\t\\t\\t\\n            else if (c == \\')\\') {\\n                sum *= stack.pop();     // stack.pop() = previous sign\\n                sum += stack.pop();     // stack.pop() = previous sum so far\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        int n = s.length();\\n        int sign = 1, sum = 0;\\n\\n        Stack<Integer> stack = new Stack<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            char c = s.charAt(i);\\n\\n            if (Character.isDigit(c)) {\\n                int currNo = c - \\'0\\';\\n                while (i + 1 < n && Character.isDigit(s.charAt(i + 1))) {\\n                    currNo = currNo * 10 + s.charAt(i + 1) - \\'0\\';\\n                    i++;\\n                }\\n\\t\\t\\t\\t\\n                currNo *= sign;\\n                sum += currNo;\\n                sign = 1;\\n            }\\n\\t\\t\\t\\n            else if (c == \\'+\\') sign = 1;\\n            else if (c == \\'-\\') sign = -1;\\n            else if (c == \\'(\\') {\\n                stack.push(sum);\\n                stack.push(sign);\\n                sum = 0;\\n                sign = 1;\\n            }\\n\\t\\t\\t\\n            else if (c == \\')\\') {\\n                sum *= stack.pop();     // stack.pop() = previous sign\\n                sum += stack.pop();     // stack.pop() = previous sum so far\\n            }\\n        }\\n\\n        return sum;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833805,
                "title": "easy-c-solution-stack-o-n",
                "content": "class Solution {\\npublic:\\n\\n    int calculate(string s) {\\n        \\n        int i,n=s.size(),sum=0,sign=1;\\n        stack<int> st;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n            {\\n                int num=0;\\n                while(n>i && s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n                {\\n                    num =num*10 +(s[i]-\\'0\\');\\n                    i++;\\n                }\\n                sum+=num*sign;\\n                i--;\\n            }\\n            else if(s[i]==\\'+\\')\\n            {\\n                sign=1;\\n            }\\n            else if(s[i]==\\'-\\')\\n            {\\n                sign=-1;\\n            }\\n            else if(s[i]==\\'(\\')\\n            {\\n                st.push(sum);\\n                st.push(sign);\\n                sum=0;\\n                sign=1;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                sum=st.top()*sum;\\n                st.pop();\\n                sum+=st.top();\\n                st.pop();\\n            }\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int calculate(string s) {\\n        \\n        int i,n=s.size(),sum=0,sign=1;\\n        stack<int> st;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n            {\\n                int num=0;\\n                while(n>i && s[i]>=\\'0\\' && s[i]<=\\'9\\')\\n                {\\n                    num =num*10 +(s[i]-\\'0\\');\\n                    i++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2833547,
                "title": "python-stack",
                "content": "Keep a stack of numbers and symbols like \"()+-\".\\nSince the only operations are addition and subtraction, one can just compute the expression from left to right, that is, as soon as you find each term. Withtout parentheses, that means that we\\'re going to be considering just one operation at a time, reducing everything to the left of the current operator:\\n1. If you see a number and the stack is empty, push it (it\\'s the first term in a series of operations).\\n2. If you see an operator, push it (this is to keep track of the current operation)\\n3. If you see a number and the top of the stack is an operator (which is always the case without parentheses since the strings are valid), then the top of the stack (stack[-1]) is going to determine the operation, and the second-to-top of the stack (stack[-2]) is going to be the first operand. Just perform the operation on the left operand and the current number and push it to the stack.\\n4. If the stack is empty and you see a \\'-\\' operand, append 0 and then \\'-\\' to the stack. (ie you get the negative number with a convenient expression)\\n\\nWith parentheses it\\'s not much different. Just keep track of the current level of depth. Actyally, the only things that change are:\\n* In points 1. and 4. of the previous list, the \"stack is empty\" condition now changes to \"stack is empty or top of the stack is \\'(\\'.\\n* When you see \\')\\', the stack must be something like [ ..., \\'(\\', number, \\')\\'  ], and you just have to replace it by [ ..., number]\\n\\n\\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        currNum = None\\n        stack = []\\n        \\n        result = None\\n        \\n        ops = { \\'+\\': lambda x, y: x + y, \\'-\\': lambda x, y: x - y }\\n        \\n        i = 0\\n        while i < len(s):\\n            # print(stack)\\n            if s[i] in \"+\":\\n                stack.append(s[i])\\n            elif s[i] == \\'-\\':\\n                if not stack or stack[-1] == \\'(\\':\\n                    stack.append(0)\\n                stack.append(s[i])\\n            elif s[i] == \\'(\\':\\n                stack.append(\\'(\\')\\n            elif s[i] == \\' \\':\\n                None\\n            else:\\n                if s[i].isdigit():\\n                    currNum = int(s[i])\\n                    i+=1\\n                    while i < len(s) and s[i].isdigit():\\n                        currNum *= 10\\n                        currNum += int(s[i])\\n                        i+=1\\n                    i -= 1\\n                elif s[i] == \\')\\':\\n                    currNum = stack.pop()\\n                    stack.pop()\\n                if stack and stack[-1] in \\'+-\\':\\n                    stack.append(ops[stack.pop()](stack.pop(), currNum))\\n                else:\\n                    stack.append(currNum)\\n            i+=1\\n        return stack.pop()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        currNum = None\\n        stack = []\\n        \\n        result = None\\n        \\n        ops = { \\'+\\': lambda x, y: x + y, \\'-\\': lambda x, y: x - y }\\n        \\n        i = 0\\n        while i < len(s):\\n            # print(stack)\\n            if s[i] in \"+\":\\n                stack.append(s[i])\\n            elif s[i] == \\'-\\':\\n                if not stack or stack[-1] == \\'(\\':\\n                    stack.append(0)\\n                stack.append(s[i])\\n            elif s[i] == \\'(\\':\\n                stack.append(\\'(\\')\\n            elif s[i] == \\' \\':\\n                None\\n            else:\\n                if s[i].isdigit():\\n                    currNum = int(s[i])\\n                    i+=1\\n                    while i < len(s) and s[i].isdigit():\\n                        currNum *= 10\\n                        currNum += int(s[i])\\n                        i+=1\\n                    i -= 1\\n                elif s[i] == \\')\\':\\n                    currNum = stack.pop()\\n                    stack.pop()\\n                if stack and stack[-1] in \\'+-\\':\\n                    stack.append(ops[stack.pop()](stack.pop(), currNum))\\n                else:\\n                    stack.append(currNum)\\n            i+=1\\n        return stack.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832981,
                "title": "java-easy-to-understand-solution-with-comments",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int calculate(String s) {\\n        Stack<Integer>st = new Stack<>();  //to handle parenthesis\\n        int n=s.length();\\n        int sum = 0;\\n        int sign = 1;         // if we have to do addition of negative number\\n        for(int i = 0;i<n;i++){\\n            char ch = s.charAt(i);\\n            if(Character.isDigit(ch)){\\n                int val = 0;\\n                 while(i<n && Character.isDigit(s.charAt(i))){  //if digit length>1\\n                     val = val * 10 + (s.charAt(i)-\\'0\\');\\n                     i++;\\n                 }\\n             i--;       //to move i pointer to previous position\\n                        //or you can use new pointer then we dont have to do it\\n             val = val * sign;\\n             sign = 1;\\n             sum += val;   \\n            }\\n            else if(ch == \\'(\\'){   //parenthesis handle\\n              st.push(sum);\\n              st.push(sign);\\n                sum = 0;\\n                sign = 1;\\n            }\\n            else if(ch == \\')\\'){\\n                sum *= st.pop();\\n                sum += st.pop();\\n            }\\n            else if(ch==\\'-\\'){\\n                sign*=-1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int calculate(String s) {\\n        Stack<Integer>st = new Stack<>();  //to handle parenthesis\\n        int n=s.length();\\n        int sum = 0;\\n        int sign = 1;         // if we have to do addition of negative number\\n        for(int i = 0;i<n;i++){\\n            char ch = s.charAt(i);\\n            if(Character.isDigit(ch)){\\n                int val = 0;\\n                 while(i<n && Character.isDigit(s.charAt(i))){  //if digit length>1\\n                     val = val * 10 + (s.charAt(i)-\\'0\\');\\n                     i++;\\n                 }\\n             i--;       //to move i pointer to previous position\\n                        //or you can use new pointer then we dont have to do it\\n             val = val * sign;\\n             sign = 1;\\n             sum += val;   \\n            }\\n            else if(ch == \\'(\\'){   //parenthesis handle\\n              st.push(sum);\\n              st.push(sign);\\n                sum = 0;\\n                sign = 1;\\n            }\\n            else if(ch == \\')\\'){\\n                sum *= st.pop();\\n                sum += st.pop();\\n            }\\n            else if(ch==\\'-\\'){\\n                sign*=-1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832157,
                "title": "c-easy-solution-beginner-friendly-stack",
                "content": "\\t/* required : i/p : arthmatic expresiontion conting only + or - or ( ) \\n\\t\\to/p : answer to expresiont \\n\\n\\t\\te.g : 1 + 2 - 3 + 4 = 5 ( how we doing 1 add because + sign and 3 subtract before is negative sign )\\n\\n\\t\\tproble is complex expresion : \\n\\t\\t( 1 + 2 - ( 4 - 5))    :for 1 and 2 logic works but inner braket what to do ? \\n\\n\\t\\t2 ways : move - inseide the breaket for compute braket answer and add with anser \\n\\t\\tor subtract according to sing before braket . \\n\\n\\t\\tproble : how to solve breaket \\n\\t\\tstack madhey previdous ans maintina and inner braket solve . karen \\n\\n\\n\\t */\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint calculate(string s) {\\n\\n\\t\\t\\tlong long  int sum =  0; \\n\\t\\t\\tint sign = 1 ;\\n\\t\\t\\tstack<pair<long long,int>> st;\\n\\t\\t\\tfor( int i = 0 ; i < s.size() ; ++i )\\n\\t\\t\\t{\\n\\t\\t\\t\\tchar ch = s[i];\\n\\n\\t\\t\\t\\tif( isdigit(ch))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// read entire digit compplete \\n\\t\\t\\t\\t\\tlong long num = 0 ;\\n\\t\\t\\t\\t\\twhile( i < s.size() && isdigit(s[i]))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnum = num*10 + s[i]-\\'0\\';\\n\\t\\t\\t\\t\\t\\t++i;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tsum += (num * sign);\\n\\t\\t\\t\\t\\t--i; // 1 extra read apter digit \\n\\t\\t\\t\\t\\tsign = 1; // reset sign \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if( ch == \\'(\\') // store priviously computed ans and sing   \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tst.push({sum,sign});\\n\\t\\t\\t\\t\\tsum = 0 ;\\n\\t\\t\\t\\t\\tsign = 1;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if( ch == \\')\\') // adding or subtracing  computed sum to ans and removing priviously stored ans .  \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsum =st.top().first + (sum * st.top().second); // contrubuting inner braket in total\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if ( ch ==\\'-\\') // toggle the sing \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsign = -1 * sign;   \\n\\t\\t\\t\\t}\\n\\n\\n\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint calculate(string s) {\\n\\n\\t\\t\\tlong long  int sum =  0; \\n\\t\\t\\tint sign = 1 ;\\n\\t\\t\\tstack<pair<long long,int>> st;\\n\\t\\t\\tfor( int i = 0 ; i < s.size() ; ++i )\\n\\t\\t\\t{\\n\\t\\t\\t\\tchar ch = s[i];\\n\\n\\t\\t\\t\\tif( isdigit(ch))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// read entire digit compplete \\n\\t\\t\\t\\t\\tlong long num = 0 ;\\n\\t\\t\\t\\t\\twhile( i < s.size() && isdigit(s[i]))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnum = num*10 + s[i]-\\'0\\';\\n\\t\\t\\t\\t\\t\\t++i;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2831635,
                "title": "c-stack-nice-question",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int sign = 1;\\n        int result = 0;\\n        int number = 0;\\n        \\n        int n = s.size();\\n        stack<int> st;\\n        \\n        for(int i = 0; i < n; i++) {\\n            char c = s[i];\\n            if(c >= \\'0\\' && c <= \\'9\\') {\\n                number = number * 10 + (c - \\'0\\');\\n            }\\n            if(c == \\'-\\') {\\n                // number completed.\\n                // update result\\n                result += (sign) * (number);\\n                number = 0;\\n                sign = -1;\\n            }\\n            if(c == \\'+\\') {\\n                // number completed\\n                // update result\\n                result += (sign) * (number);\\n                number = 0;\\n                sign = 1;\\n            }\\n            if(c == \\'(\\') {\\n                // number completed, result updated already before when we encountered +/- before opening bracket\\n                st.push(result);\\n                st.push(sign); // so that sign remains at the top (signifies sign before opening bracket was encountered)\\n                result = 0; // building result between brackets from scratch\\n                sign = 1;\\n            }\\n            if(c == \\')\\') {\\n                // number is completed\\n                // update result\\n                result += (sign) * (number);\\n                number = 0;\\n                result *= st.top(); // multiplying with sign before opening bracket\\n                st.pop();\\n                result += st.top(); // result constructed before current context.\\n                st.pop();\\n            }\\n        }\\n        \\n        \\n        // last no space character in case is a number itself , we need to use the number also.\\n        result += (sign) * number;\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int sign = 1;\\n        int result = 0;\\n        int number = 0;\\n        \\n        int n = s.size();\\n        stack<int> st;\\n        \\n        for(int i = 0; i < n; i++) {\\n            char c = s[i];\\n            if(c >= \\'0\\' && c <= \\'9\\') {\\n                number = number * 10 + (c - \\'0\\');\\n            }\\n            if(c == \\'-\\') {\\n                // number completed.\\n                // update result\\n                result += (sign) * (number);\\n                number = 0;\\n                sign = -1;\\n            }\\n            if(c == \\'+\\') {\\n                // number completed\\n                // update result\\n                result += (sign) * (number);\\n                number = 0;\\n                sign = 1;\\n            }\\n            if(c == \\'(\\') {\\n                // number completed, result updated already before when we encountered +/- before opening bracket\\n                st.push(result);\\n                st.push(sign); // so that sign remains at the top (signifies sign before opening bracket was encountered)\\n                result = 0; // building result between brackets from scratch\\n                sign = 1;\\n            }\\n            if(c == \\')\\') {\\n                // number is completed\\n                // update result\\n                result += (sign) * (number);\\n                number = 0;\\n                result *= st.top(); // multiplying with sign before opening bracket\\n                st.pop();\\n                result += st.top(); // result constructed before current context.\\n                st.pop();\\n            }\\n        }\\n        \\n        \\n        // last no space character in case is a number itself , we need to use the number also.\\n        result += (sign) * number;\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831586,
                "title": "js-multiple-approaches-easy-to-understand",
                "content": "\\nI just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/11/basic-calculator.html\\nIt has solutions to almost every problem on Leetcode, and I recommend checking it out.\\nNote: You can bookmark it as a resource, and approach. Other approaches are in above blog\\n<br>\\n\\n```\\nvar calculate = function(s) {\\n    s = \"(\"+s+\")\"\\n    let stack = [];\\n    let temp = [];\\n    for(let i = 0; i < s.length; i++){\\n        if(s[i]===\" \") continue;\\n        if(s[i]===\")\"){     \\n            while(stack[stack.length-1]!==\"(\") temp.push(stack.pop());                   \\n            stack.pop();\\n            stack.push(count(temp));\\n            continue;\\n        }\\n         if(isNum(stack[stack.length-1])&&isNum(s[i])){\\n            stack[stack.length-1]+=s[i];   \\n            continue;             \\n        } \\n        if(s[i]===\"-\"||s[i]===\"+\"){\\n             if(stack.length===0||stack[stack.length-1]===\"(\") stack.push(\"0\");    \\n        }\\n        stack.push(s[i]);\\n    }\\n    return stack[0];\\n};\\n    \\nfunction count(temp) {\\n let res = Number(temp.pop());\\n while(temp.length > 0) {\\n   let sign = temp.pop();\\n        if (sign === \\'+\\') {\\n            res  +=  Number(temp.pop());\\n        } else {\\n            res  -=  Number(temp.pop());\\n        }\\n  }  \\n    return res;\\n}\\nfunction isNum(str) {\\n  return /[0-9]+/.test(str);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar calculate = function(s) {\\n    s = \"(\"+s+\")\"\\n    let stack = [];\\n    let temp = [];\\n    for(let i = 0; i < s.length; i++){\\n        if(s[i]===\" \") continue;\\n        if(s[i]===\")\"){     \\n            while(stack[stack.length-1]!==\"(\") temp.push(stack.pop());                   \\n            stack.pop();\\n            stack.push(count(temp));\\n            continue;\\n        }\\n         if(isNum(stack[stack.length-1])&&isNum(s[i])){\\n            stack[stack.length-1]+=s[i];   \\n            continue;             \\n        } \\n        if(s[i]===\"-\"||s[i]===\"+\"){\\n             if(stack.length===0||stack[stack.length-1]===\"(\") stack.push(\"0\");    \\n        }\\n        stack.push(s[i]);\\n    }\\n    return stack[0];\\n};\\n    \\nfunction count(temp) {\\n let res = Number(temp.pop());\\n while(temp.length > 0) {\\n   let sign = temp.pop();\\n        if (sign === \\'+\\') {\\n            res  +=  Number(temp.pop());\\n        } else {\\n            res  -=  Number(temp.pop());\\n        }\\n  }  \\n    return res;\\n}\\nfunction isNum(str) {\\n  return /[0-9]+/.test(str);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2831481,
                "title": "rust-stack-solution-with-comments",
                "content": "thanks [southpenguin](https://leetcode.com/problems/basic-calculator/discuss/62361/Iterative-Java-solution-with-stack) for the idea\\n```\\nimpl Solution {\\n    pub fn calculate(s: String) -> i32 {        \\n        let s = s.chars().collect::<Vec<char>>();\\n        let mut stack = vec![];\\n        \\n        let (mut cur_sign, mut cur_num, mut final_result) = (1, 0, 0);\\n                \\n        for c in s {\\n            match c {\\n                \\' \\' => {},\\n                \\'(\\' => {\\n                    // push the current calculated result for popping after\\n                    // the upcoming parenthesis has been calculated in full\\n                    stack.push(final_result);\\n                    // push the current sign for popping after the\\n                    // upcoming parenthesis has been calculated in full\\n                    stack.push(cur_sign);\\n                    // result and sign can be reset as we are entering\\n                    // a new calculation domain (i.e., in the parenthesis)\\n                    final_result = 0;\\n                    cur_sign = 1;\\n                },\\n                \\')\\' => {\\n                    // add our current stored number to the final solution\\n                    final_result += cur_sign * cur_num;\\n                    // this would be the sign before the opening parenthesis\\n                    final_result *= stack.pop().unwrap();\\n                    // this would be the result prior to the just-solved parenthesis\\n                    final_result += stack.pop().unwrap();\\n                    // reset num and sign for upcoming value\\n                    cur_num = 0;\\n                    cur_sign = 1;\\n                },\\n                \\'+\\' => {\\n                    // we can add our current stored number to the final solution\\n                    // before updating the num + sign values for the next number\\n                    final_result += cur_sign * cur_num;\\n                    cur_num = 0;\\n                    cur_sign = 1;\\n                },\\n                \\'-\\' => {\\n                    // we can subtract our current stored number to the final solution\\n                    // before updating the num + sign values for the next number\\n                    final_result += cur_sign * cur_num;\\n                    cur_num = 0;\\n                    cur_sign = -1;\\n                },\\n                _ => {\\n                    // add a new least-significant digit\\n                    cur_num *= 10;\\n                    cur_num += (c as i32) - 0x30;\\n                }\\n            }\\n        }\\n        \\n        // if we have any stragglers, add to the result\\n        final_result + (cur_sign * cur_num)    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Stack"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn calculate(s: String) -> i32 {        \\n        let s = s.chars().collect::<Vec<char>>();\\n        let mut stack = vec![];\\n        \\n        let (mut cur_sign, mut cur_num, mut final_result) = (1, 0, 0);\\n                \\n        for c in s {\\n            match c {\\n                \\' \\' => {},\\n                \\'(\\' => {\\n                    // push the current calculated result for popping after\\n                    // the upcoming parenthesis has been calculated in full\\n                    stack.push(final_result);\\n                    // push the current sign for popping after the\\n                    // upcoming parenthesis has been calculated in full\\n                    stack.push(cur_sign);\\n                    // result and sign can be reset as we are entering\\n                    // a new calculation domain (i.e., in the parenthesis)\\n                    final_result = 0;\\n                    cur_sign = 1;\\n                },\\n                \\')\\' => {\\n                    // add our current stored number to the final solution\\n                    final_result += cur_sign * cur_num;\\n                    // this would be the sign before the opening parenthesis\\n                    final_result *= stack.pop().unwrap();\\n                    // this would be the result prior to the just-solved parenthesis\\n                    final_result += stack.pop().unwrap();\\n                    // reset num and sign for upcoming value\\n                    cur_num = 0;\\n                    cur_sign = 1;\\n                },\\n                \\'+\\' => {\\n                    // we can add our current stored number to the final solution\\n                    // before updating the num + sign values for the next number\\n                    final_result += cur_sign * cur_num;\\n                    cur_num = 0;\\n                    cur_sign = 1;\\n                },\\n                \\'-\\' => {\\n                    // we can subtract our current stored number to the final solution\\n                    // before updating the num + sign values for the next number\\n                    final_result += cur_sign * cur_num;\\n                    cur_num = 0;\\n                    cur_sign = -1;\\n                },\\n                _ => {\\n                    // add a new least-significant digit\\n                    cur_num *= 10;\\n                    cur_num += (c as i32) - 0x30;\\n                }\\n            }\\n        }\\n        \\n        // if we have any stragglers, add to the result\\n        final_result + (cur_sign * cur_num)    \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2831403,
                "title": "daily-leetcoding-challenge-november-day-20",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/basic-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Stack and String Reversal\n\n  \n**Approach 2:** Stack and No String Reversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/basic-calculator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2703291,
                "title": "easy-best-solution-in-c-stack",
                "content": "# Code\\n**PLease Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int size=s.size(),i=0,ans=0,prevSum=0;\\n        char prevOperation=\\'+\\';\\n        stack<pair<int,char>> sta;\\n        while(i<size){\\n            if(s[i]==\\' \\'){\\n                i++;\\n                continue;\\n            }\\n            int num=0;\\n            while(i<size && isdigit(s[i]))\\n                num = num*10 + (s[i++]-\\'0\\');\\n            if(prevOperation==\\'+\\')\\n                prevSum += num;\\n            else if(prevOperation==\\'-\\')\\n                prevSum += -1*num;\\n            if(s[i]==\\'(\\'){\\n                sta.push({prevSum,prevOperation});\\n                prevSum=0;\\n                prevOperation=\\'+\\';\\n                i++;\\n                continue;\\n            }\\n            else if(s[i]==\\')\\'){\\n                pair<int,char> p=sta.top();\\n                sta.pop();\\n                if(p.second==\\'-\\')\\n                    prevSum = -1*prevSum + p.first;\\n                else\\n                    prevSum = prevSum + p.first;\\n            }\\n            prevOperation=s[i++];\\n        }\\n        return prevSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int size=s.size(),i=0,ans=0,prevSum=0;\\n        char prevOperation=\\'+\\';\\n        stack<pair<int,char>> sta;\\n        while(i<size){\\n            if(s[i]==\\' \\'){\\n                i++;\\n                continue;\\n            }\\n            int num=0;\\n            while(i<size && isdigit(s[i]))\\n                num = num*10 + (s[i++]-\\'0\\');\\n            if(prevOperation==\\'+\\')\\n                prevSum += num;\\n            else if(prevOperation==\\'-\\')\\n                prevSum += -1*num;\\n            if(s[i]==\\'(\\'){\\n                sta.push({prevSum,prevOperation});\\n                prevSum=0;\\n                prevOperation=\\'+\\';\\n                i++;\\n                continue;\\n            }\\n            else if(s[i]==\\')\\'){\\n                pair<int,char> p=sta.top();\\n                sta.pop();\\n                if(p.second==\\'-\\')\\n                    prevSum = -1*prevSum + p.first;\\n                else\\n                    prevSum = prevSum + p.first;\\n            }\\n            prevOperation=s[i++];\\n        }\\n        return prevSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692939,
                "title": "simple-c-in-6ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int n = s.size();\\n        stack<int>st;\\n        long long int sum = 0;\\n        int sign  = 1;\\n        for(int i=0;i<n;i++)\\n        {\\n            int ch = s[i];\\n            if(isdigit(s[i]))\\n            {\\n                long long int num =0;\\n                while(i<n and isdigit(s[i]))\\n                {\\n                    num = num*10 + (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                i--;\\n                num *= sign;\\n                sum += num;\\n                sign = 1;\\n            }\\n            else if(ch==\\'(\\')\\n            {\\n                st.push(sum);\\n                st.push(sign);\\n                sum = 0;\\n                sign = 1;\\n            }\\n            else if(ch==\\')\\')\\n            {\\n                sum *= st.top();\\n                st.pop();\\n                sum += st.top();\\n                st.pop();\\n            }\\n            else if(ch==\\'-\\')\\n            {\\n                sign *= -1;\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        int n = s.size();\\n        stack<int>st;\\n        long long int sum = 0;\\n        int sign  = 1;\\n        for(int i=0;i<n;i++)\\n        {\\n            int ch = s[i];\\n            if(isdigit(s[i]))\\n            {\\n                long long int num =0;\\n                while(i<n and isdigit(s[i]))\\n                {\\n                    num = num*10 + (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                i--;\\n                num *= sign;\\n                sum += num;\\n                sign = 1;\\n            }\\n            else if(ch==\\'(\\')\\n            {\\n                st.push(sum);\\n                st.push(sign);\\n                sum = 0;\\n                sign = 1;\\n            }\\n            else if(ch==\\')\\')\\n            {\\n                sum *= st.top();\\n                st.pop();\\n                sum += st.top();\\n                st.pop();\\n            }\\n            else if(ch==\\'-\\')\\n            {\\n                sign *= -1;\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677640,
                "title": "c-using-stack-easy-to-understand",
                "content": "~~~\\nclass Solution {\\npublic:\\n   int calculate(string s) {\\n       stack<pair<int,int>> st; // pair(prev_calc_value , sign before next bracket () )\\n       \\n       long long int sum = 0;\\n       int sign = +1;\\n       \\n       for(int i = 0 ; i < s.size() ; ++i)\\n       {\\n           char ch = s[i];\\n           \\n           if(isdigit(ch))\\n           {\\n               long long int num = 0;\\n               while(i < s.size() and isdigit(s[i]))\\n               {\\n                   num = (num * 10) + s[i] - \\'0\\';\\n                   i++;\\n               }\\n               i--; // as for loop also increase i , so if we don\\'t decrease i here a sign will be skipped\\n               sum += (num * sign);\\n               sign = +1; // reseting sign\\n           }\\n           else if(ch == \\'(\\')\\n           {\\n               // Saving current state of (sum , sign) in stack\\n               st.push(make_pair(sum , sign));\\n               \\n               // Reseting sum and sign for inner bracket calculation\\n               sum = 0; \\n               sign = +1;\\n           }\\n           else if(ch == \\')\\')\\n           {\\n               sum = st.top().first + (st.top().second * sum);\\n               st.pop();\\n           }\\n           else if(ch == \\'-\\')\\n           {\\n               // toggle sign\\n               sign = (-1 * sign);\\n           }\\n       }\\n       return sum;\\n   }\\n};\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   int calculate(string s) {\\n       stack<pair<int,int>> st; // pair(prev_calc_value , sign before next bracket () )\\n       \\n       long long int sum = 0;\\n       int sign = +1;\\n       \\n       for(int i = 0 ; i < s.size() ; ++i)\\n       {\\n           char ch = s[i];\\n           \\n           if(isdigit(ch))\\n           {\\n               long long int num = 0;\\n               while(i < s.size() and isdigit(s[i]))\\n               {\\n                   num = (num * 10) + s[i] - \\'0\\';\\n                   i++;\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 2633989,
                "title": "java-explanation-easy-understanding-solution",
                "content": "**1. first i replaced all empty space with \"\"\\nString===>( 1 + (  4 + 5+ 2  )  -   3    )   +   (    6   +   8    )\\nindex===> 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18\\n2. in function \"bracketSolver\" i send values in between index 4 to 8 both inclusive and solve it and return its value and replce it like this\\nString===>( 1 + 11 -  3  ) + (  6   +  8    )\\nindex===> 0 1 2 34 5 6 7 8 9 10 11 12 13\\n3\\nString===>9 + (  6 + 8  )\\nindex===> 0 1  2 3 4 5 6\\n4\\nString===>9 + 14\\nindex===> 0 1  23\\n5\\nString===>23\\nindex===> 01**\\n\\n```\\nclass Solution224 {\\n    public int bracketSolver(String ss) {\\n        int ans = 0, res = 0, sign = 0;\\n        for (int i = 0; i <= ss.length() - 1; i++) {\\n            if (Character.isDigit(ss.charAt(i))) {\\n                ans = (ans * 10) + (ss.charAt(i) - 48);\\n                if (i == ss.length() - 1 || ss.charAt(i + 1) == \\'+\\' || ss.charAt(i + 1) == \\'-\\') {\\n                    if (sign == 1) {\\n                        ans = -ans;\\n                        sign = 0;\\n                    }\\n                    res += ans;\\n                    ans = 0;\\n                }\\n            } else if (ss.charAt(i) == \\'-\\')\\n                sign = 1;\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n        StringBuilder ss = new StringBuilder(s.replaceAll(\" \", \"\"));\\n        int ei, si, res;\\n        while (ss.indexOf(\")\") >= 0) {\\n            ei = ss.indexOf(\")\");\\n            si = ss.lastIndexOf(\"(\", ei);\\n            res = bracketSolver(ss.substring(si + 1, ei));\\n            if (si - 1 >= 0 && ss.charAt(si - 1) == \\'-\\') {\\n                res = -res;\\n                si = si - 1;\\n            } else if (si - 1 >= 0 && ss.charAt(si - 1) == \\'+\\')\\n                si = si - 1;\\n            if (res >= 0)\\n                ss.replace(si, ei + 1, \"+\" + res);\\n            else\\n                ss.replace(si, ei + 1, String.valueOf(res));\\n        }\\n        return bracketSolver(ss.toString());\\n    }\\n}\\n```\\n\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE !**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution224 {\\n    public int bracketSolver(String ss) {\\n        int ans = 0, res = 0, sign = 0;\\n        for (int i = 0; i <= ss.length() - 1; i++) {\\n            if (Character.isDigit(ss.charAt(i))) {\\n                ans = (ans * 10) + (ss.charAt(i) - 48);\\n                if (i == ss.length() - 1 || ss.charAt(i + 1) == \\'+\\' || ss.charAt(i + 1) == \\'-\\') {\\n                    if (sign == 1) {\\n                        ans = -ans;\\n                        sign = 0;\\n                    }\\n                    res += ans;\\n                    ans = 0;\\n                }\\n            } else if (ss.charAt(i) == \\'-\\')\\n                sign = 1;\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n        StringBuilder ss = new StringBuilder(s.replaceAll(\" \", \"\"));\\n        int ei, si, res;\\n        while (ss.indexOf(\")\") >= 0) {\\n            ei = ss.indexOf(\")\");\\n            si = ss.lastIndexOf(\"(\", ei);\\n            res = bracketSolver(ss.substring(si + 1, ei));\\n            if (si - 1 >= 0 && ss.charAt(si - 1) == \\'-\\') {\\n                res = -res;\\n                si = si - 1;\\n            } else if (si - 1 >= 0 && ss.charAt(si - 1) == \\'+\\')\\n                si = si - 1;\\n            if (res >= 0)\\n                ss.replace(si, ei + 1, \"+\" + res);\\n            else\\n                ss.replace(si, ei + 1, String.valueOf(res));\\n        }\\n        return bracketSolver(ss.toString());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556064,
                "title": "recursion",
                "content": "The problem is same as the basic calculator, but the only thing changes is that braces are included.\\nWhen we encounter \\'(\\', just call the same the function for solving value of the expression inside the braces, when we encouter \\')\\' just return result put num = 0.\\n****\\n```\\nclass Solution {\\n    int pos = 0;\\n    public int calculate(String s) {\\n         pos = 0;\\n           return solve(s);\\n    }\\n\\n    private  int solve(String s) {\\n        int sign = 1; // initial take as positive\\n        int num = 0;\\n        int res = 0;\\n        while (pos < s.length()) {\\n            char curr = s.charAt(pos++);\\n            if (curr == \\' \\'){\\n                continue;\\n            }else if (isNum(curr)) {\\n                num = num * 10 + curr - \\'0\\';\\n            } else if (curr == \\'(\\') {\\n                num = solve(s);\\n            } else if(curr == \\')\\') {\\n                res += num * sign;\\n                return res;\\n            } else {\\n               res += sign * num;\\n               sign = curr == \\'-\\' ? -1 : 1;\\n               num = 0;\\n            }\\n    }\\n   int ret = res + (sign * num);\\n        return ret;\\n}\\n\\n    private  boolean isNum(char curr) {\\n        int num = curr - \\'0\\';\\n        return num >= 0 && num <= 9;\\n    }\\n    \\n}\\n```\\n**Thanks for viewing.**\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int pos = 0;\\n    public int calculate(String s) {\\n         pos = 0;\\n           return solve(s);\\n    }\\n\\n    private  int solve(String s) {\\n        int sign = 1; // initial take as positive\\n        int num = 0;\\n        int res = 0;\\n        while (pos < s.length()) {\\n            char curr = s.charAt(pos++);\\n            if (curr == \\' \\'){\\n                continue;\\n            }else if (isNum(curr)) {\\n                num = num * 10 + curr - \\'0\\';\\n            } else if (curr == \\'(\\') {\\n                num = solve(s);\\n            } else if(curr == \\')\\') {\\n                res += num * sign;\\n                return res;\\n            } else {\\n               res += sign * num;\\n               sign = curr == \\'-\\' ? -1 : 1;\\n               num = 0;\\n            }\\n    }\\n   int ret = res + (sign * num);\\n        return ret;\\n}\\n\\n    private  boolean isNum(char curr) {\\n        int num = curr - \\'0\\';\\n        return num >= 0 && num <= 9;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535635,
                "title": "python-solution",
                "content": "Not super fast, but I think quite intuitive:\\n\\n```python\\nclass Solution:\\n    def calc(self, s: str) -> int:\\n        \"\"\" calc simple math without () \"\"\"\\n        stack = []\\n        op = \"+\"\\n        for tok in re.findall(r\"\\\\d+|[-+*]\", s):\\n            if tok.isnumeric():\\n                if op == \"+\":\\n                    stack.append(int(tok))\\n                elif op == \"-\":\\n                    stack.append(-int(tok))\\n                elif op == \"*\":\\n                    stack.append(stack.pop() * int(tok))\\n            else:\\n                op = tok\\n        return sum(stack)\\n    \\n    def calculate(self, s: str) -> int:\\n        s = s.replace(\" \", \"\")\\n        while True:\\n            # deal with most inner (...) each time\\n            sub = re.search(\"\\\\([^()]+\\\\)\", s)\\n            if not sub:\\n                break\\n            subexp = sub.group(0)\\n            subval = self.calc(subexp[1:-1])\\n            s = s.replace(subexp, str(subval))\\n            if subval < 0:\\n                s = s.replace(\"--\", \"+\")  # \"1-(-2)\" tyope of case\\n        return self.calc(s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def calc(self, s: str) -> int:\\n        \"\"\" calc simple math without () \"\"\"\\n        stack = []\\n        op = \"+\"\\n        for tok in re.findall(r\"\\\\d+|[-+*]\", s):\\n            if tok.isnumeric():\\n                if op == \"+\":\\n                    stack.append(int(tok))\\n                elif op == \"-\":\\n                    stack.append(-int(tok))\\n                elif op == \"*\":\\n                    stack.append(stack.pop() * int(tok))\\n            else:\\n                op = tok\\n        return sum(stack)\\n    \\n    def calculate(self, s: str) -> int:\\n        s = s.replace(\" \", \"\")\\n        while True:\\n            # deal with most inner (...) each time\\n            sub = re.search(\"\\\\([^()]+\\\\)\", s)\\n            if not sub:\\n                break\\n            subexp = sub.group(0)\\n            subval = self.calc(subexp[1:-1])\\n            s = s.replace(subexp, str(subval))\\n            if subval < 0:\\n                s = s.replace(\"--\", \"+\")  # \"1-(-2)\" tyope of case\\n        return self.calc(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2523653,
                "title": "java-recursion-100-fast-easy",
                "content": "**<-------------//VoteUp if you like the solution**\\n\\n```\\nclass Solution {\\n    \\n    int pos = 0;\\n    \\n    public int calculate(String s) {\\n        pos = 0;\\n        return solve(s);\\n    }\\n    \\n    public int solve(String s) {\\n        \\n        int len = s.length();\\n        int res = 0;\\n        int num = 0;\\n        int signNum = 1;//positive sign for start\\n        while(pos < len) {\\n            \\n            char cur_char = s.charAt(pos++);\\n            \\n            if(cur_char == \\' \\') {\\n                continue;\\n            }\\n            else if(isNum(cur_char)){\\n                num = num * 10 + cur_char-\\'0\\';\\n            } \\n            else if(cur_char == \\'(\\'){\\n                //pos++;\\n                num = solve(s);\\n            } \\n            else if(cur_char == \\')\\'){\\n                res += signNum * num;\\n                \\n                return res;\\n            } \\n            else{\\n                res += signNum * num;\\n                signNum = cur_char == \\'-\\'?-1:1;\\n                num = 0;\\n                \\n            }\\n            \\n        }\\n        \\n        int ret = res + signNum * num;\\n        \\n        return ret;\\n    }\\n    \\n    public boolean isNum(char c){\\n        int a = c - \\'0\\';\\n        \\n        if(a >= 0 && a <= 9){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int pos = 0;\\n    \\n    public int calculate(String s) {\\n        pos = 0;\\n        return solve(s);\\n    }\\n    \\n    public int solve(String s) {\\n        \\n        int len = s.length();\\n        int res = 0;\\n        int num = 0;\\n        int signNum = 1;//positive sign for start\\n        while(pos < len) {\\n            \\n            char cur_char = s.charAt(pos++);\\n            \\n            if(cur_char == \\' \\') {\\n                continue;\\n            }\\n            else if(isNum(cur_char)){\\n                num = num * 10 + cur_char-\\'0\\';\\n            } \\n            else if(cur_char == \\'(\\'){\\n                //pos++;\\n                num = solve(s);\\n            } \\n            else if(cur_char == \\')\\'){\\n                res += signNum * num;\\n                \\n                return res;\\n            } \\n            else{\\n                res += signNum * num;\\n                signNum = cur_char == \\'-\\'?-1:1;\\n                num = 0;\\n                \\n            }\\n            \\n        }\\n        \\n        int ret = res + signNum * num;\\n        \\n        return ret;\\n    }\\n    \\n    public boolean isNum(char c){\\n        int a = c - \\'0\\';\\n        \\n        if(a >= 0 && a <= 9){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448567,
                "title": "over-engineered-solution-using-ast-visitor",
                "content": "```python\\nfrom abc import ABC, abstractmethod\\nfrom dataclasses import dataclass\\nfrom enum import auto, Enum\\nfrom typing import Optional, Generic, TypeVar\\n\\nT = TypeVar(\\'T\\')\\n\\n\\nclass Node(ABC):\\n    @abstractmethod\\n    def accept(self, visitor):\\n        ...\\n\\n\\n@dataclass(frozen=True)\\nclass Addition(Node):\\n    left: Node\\n    right: Node\\n\\n    def accept(self, visitor):\\n        return visitor.visit_addition(self)\\n\\n\\n@dataclass(frozen=True)\\nclass Subtraction(Node):\\n    left: Node\\n    right: Node\\n\\n    def accept(self, visitor):\\n        return visitor.visit_subtraction(self)\\n\\n\\n@dataclass(frozen=True)\\nclass Multiplication(Node):\\n    left: Node\\n    right: Node\\n\\n    def accept(self, visitor):\\n        return visitor.visit_multiplication(self)\\n\\n\\n@dataclass(frozen=True)\\nclass Division(Node):\\n    left: Node\\n    right: Node\\n\\n    def accept(self, visitor):\\n        return visitor.visit_division(self)\\n\\n@dataclass(frozen=True)\\nclass Modulus(Node):\\n    left: Node\\n    right: Node\\n\\n    def accept(self, visitor):\\n        return visitor.visit_modulus(self)\\n\\n\\n@dataclass(frozen=True)\\nclass UnaryMinus(Node):\\n    value: Node\\n\\n    def accept(self, visitor):\\n        return visitor.visit_unary_minus(self)\\n\\n\\n@dataclass(frozen=True)\\nclass Literal(Node):\\n    value: int\\n\\n    def accept(self, visitor):\\n        return visitor.visit_literal(self)\\n\\n    \\nclass TokenType(Enum):\\n    PLUS = auto()\\n    MINUS = auto()\\n    MUL = auto()\\n    DIV = auto()\\n    MOD = auto()\\n    LPRAREN = auto()\\n    RPAREN = auto()\\n    INTEGER = auto()\\n\\n\\n@dataclass(frozen=True)\\nclass Token:\\n    type: TokenType\\n    value: Optional[int] = None\\n\\n\\nKEYWORDS = {\\n    \\'+\\': TokenType.PLUS,\\n    \\'-\\': TokenType.MINUS,\\n    \\'*\\': TokenType.MUL,\\n    \\'/\\': TokenType.DIV,\\n    \\'%\\': TokenType.MOD,\\n    \\'(\\': TokenType.LPRAREN,\\n    \\')\\': TokenType.RPAREN\\n}\\n\\n\\nclass Lexer:\\n    def __init__(self, expression: str):\\n        self.expression = expression\\n        self.pos = 0\\n        self.tokens = []\\n\\n    def lex(self):\\n        while self.pos < len(self.expression):\\n            value = self.expression[self.pos]\\n\\n            if value in \\' \\\\r\\\\n\\\\t\\':\\n                self.advance()\\n                continue\\n\\n            if ttype := KEYWORDS.get(value):\\n                self.insert(Token(ttype))\\n            elif value.isdigit():\\n                self.lex_number()\\n            else:\\n                raise ValueError(f\\'Invalid symbol: {value}\\')\\n\\n    def lex_number(self):\\n        start = self.pos\\n        self.advance()\\n\\n        while self.pos < len(self.expression) and self.expression[self.pos].isdigit():\\n            self.advance()\\n\\n        end = self.pos\\n        self.revert()\\n        self.insert(Token(TokenType.INTEGER, int(self.expression[start:end])))\\n\\n    def insert(self, token: Token):\\n        self.tokens.append(token)\\n        self.advance()\\n\\n    def advance(self):\\n        self.pos += 1\\n\\n    def revert(self):\\n        self.pos -= 1\\n\\n\\nclass Parser:\\n    def __init__(self, expression: str):\\n        lexer = Lexer(expression)\\n        lexer.lex()\\n        self.tokens = lexer.tokens\\n        self.pos = 0\\n\\n    def parse(self) -> Node:\\n        return self.parse_plus()\\n\\n    def parse_plus(self) -> Node:\\n        result = self.parse_mul()\\n\\n        while True:\\n            if self.accept(TokenType.PLUS):\\n                result = Addition(result, self.parse_mul())\\n            elif self.accept(TokenType.MINUS):\\n                result = Subtraction(result, self.parse_mul())\\n            else:\\n                break\\n\\n        return result\\n\\n    def parse_mul(self) -> Node:\\n        result = self.parse_unary()\\n\\n        while True:\\n            if self.accept(TokenType.MUL):\\n                result = Multiplication(result, self.parse_unary())\\n            elif self.accept(TokenType.DIV):\\n                result = Division(result, self.parse_unary())\\n            elif self.accept(TokenType.MOD):\\n                result = Modulus(result, self.parse_unary())\\n            else:\\n                break\\n\\n        return result\\n\\n    def parse_unary(self) -> Node:\\n        if self.accept(TokenType.MINUS):\\n            return UnaryMinus(self.parse_unary())\\n\\n        return self.parse_primary()\\n\\n    def parse_primary(self) -> Node:\\n        if self.accept(TokenType.LPRAREN):\\n            result = self.parse()\\n            self.expect(TokenType.RPAREN)\\n            return result\\n        elif token := self.accept(TokenType.INTEGER):\\n            return Literal(token.value)\\n\\n        raise ValueError(f\\'Invalid expression\\')\\n\\n    def accept(self, ttype: TokenType) -> Optional[Token]:\\n        current = self.current_token\\n\\n        if current and current.type == ttype:\\n            self.advance()\\n            return current\\n\\n    def expect(self, ttype: TokenType) -> Token:\\n        if token := self.accept(ttype):\\n            return token\\n\\n        raise ValueError(f\\'Expected: {ttype}\\')\\n\\n    @property\\n    def current_token(self) -> Optional[Token]:\\n        if self.pos < len(self.tokens):\\n            return self.tokens[self.pos]\\n\\n    def advance(self):\\n        self.pos += 1\\n\\n\\nclass Visitor(ABC, Generic[T]):\\n    @abstractmethod\\n    def visit_addition(self, node: Addition) -> T:\\n        ...\\n\\n    @abstractmethod\\n    def visit_subtraction(self, node: Subtraction) -> T:\\n        ...\\n\\n    @abstractmethod\\n    def visit_multiplication(self, node: Multiplication) -> T:\\n        ...\\n\\n    @abstractmethod\\n    def visit_division(self, node: Division) -> T:\\n        ...\\n\\n    @abstractmethod\\n    def visit_modulus(self, node: Modulus) -> T:\\n        ...\\n\\n    @abstractmethod\\n    def visit_unary_minus(self, node: UnaryMinus) -> T:\\n        ...\\n\\n    @abstractmethod\\n    def visit_literal(self, node: Literal) -> T:\\n        ...\\n\\n\\nclass Calculator(Visitor[int]):\\n    def execute(self, node: Node) -> int:\\n        return node.accept(self)\\n\\n    def visit_addition(self, node: Addition) -> int:\\n        return self.execute(node.left) + self.execute(node.right)\\n\\n    def visit_subtraction(self, node: Subtraction) -> int:\\n        return self.execute(node.left) - self.execute(node.right)\\n\\n    def visit_multiplication(self, node: Multiplication) -> int:\\n        return self.execute(node.left) * self.execute(node.right)\\n\\n    def visit_division(self, node: Division) -> int:\\n        return self.execute(node.left) // self.execute(node.right)\\n\\n    def visit_modulus(self, node: Modulus) -> T:\\n        return self.execute(node.left) % self.execute(node.right)\\n\\n    def visit_unary_minus(self, node: UnaryMinus) -> int:\\n        return -self.execute(node.value)\\n\\n    def visit_literal(self, node: Literal) -> int:\\n        return node.value\\n\\n\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        parser = Parser(s)\\n        root = parser.parse()\\n\\n        calculator = Calculator()\\n        return calculator.execute(root)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nfrom abc import ABC, abstractmethod\\nfrom dataclasses import dataclass\\nfrom enum import auto, Enum\\nfrom typing import Optional, Generic, TypeVar\\n\\nT = TypeVar(\\'T\\')\\n\\n\\nclass Node(ABC):\\n    @abstractmethod\\n    def accept(self, visitor):\\n        ...\\n\\n\\n@dataclass(frozen=True)\\nclass Addition(Node):\\n    left: Node\\n    right: Node\\n\\n    def accept(self, visitor):\\n        return visitor.visit_addition(self)\\n\\n\\n@dataclass(frozen=True)\\nclass Subtraction(Node):\\n    left: Node\\n    right: Node\\n\\n    def accept(self, visitor):\\n        return visitor.visit_subtraction(self)\\n\\n\\n@dataclass(frozen=True)\\nclass Multiplication(Node):\\n    left: Node\\n    right: Node\\n\\n    def accept(self, visitor):\\n        return visitor.visit_multiplication(self)\\n\\n\\n@dataclass(frozen=True)\\nclass Division(Node):\\n    left: Node\\n    right: Node\\n\\n    def accept(self, visitor):\\n        return visitor.visit_division(self)\\n\\n@dataclass(frozen=True)\\nclass Modulus(Node):\\n    left: Node\\n    right: Node\\n\\n    def accept(self, visitor):\\n        return visitor.visit_modulus(self)\\n\\n\\n@dataclass(frozen=True)\\nclass UnaryMinus(Node):\\n    value: Node\\n\\n    def accept(self, visitor):\\n        return visitor.visit_unary_minus(self)\\n\\n\\n@dataclass(frozen=True)\\nclass Literal(Node):\\n    value: int\\n\\n    def accept(self, visitor):\\n        return visitor.visit_literal(self)\\n\\n    \\nclass TokenType(Enum):\\n    PLUS = auto()\\n    MINUS = auto()\\n    MUL = auto()\\n    DIV = auto()\\n    MOD = auto()\\n    LPRAREN = auto()\\n    RPAREN = auto()\\n    INTEGER = auto()\\n\\n\\n@dataclass(frozen=True)\\nclass Token:\\n    type: TokenType\\n    value: Optional[int] = None\\n\\n\\nKEYWORDS = {\\n    \\'+\\': TokenType.PLUS,\\n    \\'-\\': TokenType.MINUS,\\n    \\'*\\': TokenType.MUL,\\n    \\'/\\': TokenType.DIV,\\n    \\'%\\': TokenType.MOD,\\n    \\'(\\': TokenType.LPRAREN,\\n    \\')\\': TokenType.RPAREN\\n}\\n\\n\\nclass Lexer:\\n    def __init__(self, expression: str):\\n        self.expression = expression\\n        self.pos = 0\\n        self.tokens = []\\n\\n    def lex(self):\\n        while self.pos < len(self.expression):\\n            value = self.expression[self.pos]\\n\\n            if value in \\' \\\\r\\\\n\\\\t\\':\\n                self.advance()\\n                continue\\n\\n            if ttype := KEYWORDS.get(value):\\n                self.insert(Token(ttype))\\n            elif value.isdigit():\\n                self.lex_number()\\n            else:\\n                raise ValueError(f\\'Invalid symbol: {value}\\')\\n\\n    def lex_number(self):\\n        start = self.pos\\n        self.advance()\\n\\n        while self.pos < len(self.expression) and self.expression[self.pos].isdigit():\\n            self.advance()\\n\\n        end = self.pos\\n        self.revert()\\n        self.insert(Token(TokenType.INTEGER, int(self.expression[start:end])))\\n\\n    def insert(self, token: Token):\\n        self.tokens.append(token)\\n        self.advance()\\n\\n    def advance(self):\\n        self.pos += 1\\n\\n    def revert(self):\\n        self.pos -= 1\\n\\n\\nclass Parser:\\n    def __init__(self, expression: str):\\n        lexer = Lexer(expression)\\n        lexer.lex()\\n        self.tokens = lexer.tokens\\n        self.pos = 0\\n\\n    def parse(self) -> Node:\\n        return self.parse_plus()\\n\\n    def parse_plus(self) -> Node:\\n        result = self.parse_mul()\\n\\n        while True:\\n            if self.accept(TokenType.PLUS):\\n                result = Addition(result, self.parse_mul())\\n            elif self.accept(TokenType.MINUS):\\n                result = Subtraction(result, self.parse_mul())\\n            else:\\n                break\\n\\n        return result\\n\\n    def parse_mul(self) -> Node:\\n        result = self.parse_unary()\\n\\n        while True:\\n            if self.accept(TokenType.MUL):\\n                result = Multiplication(result, self.parse_unary())\\n            elif self.accept(TokenType.DIV):\\n                result = Division(result, self.parse_unary())\\n            elif self.accept(TokenType.MOD):\\n                result = Modulus(result, self.parse_unary())\\n            else:\\n                break\\n\\n        return result\\n\\n    def parse_unary(self) -> Node:\\n        if self.accept(TokenType.MINUS):\\n            return UnaryMinus(self.parse_unary())\\n\\n        return self.parse_primary()\\n\\n    def parse_primary(self) -> Node:\\n        if self.accept(TokenType.LPRAREN):\\n            result = self.parse()\\n            self.expect(TokenType.RPAREN)\\n            return result\\n        elif token := self.accept(TokenType.INTEGER):\\n            return Literal(token.value)\\n\\n        raise ValueError(f\\'Invalid expression\\')\\n\\n    def accept(self, ttype: TokenType) -> Optional[Token]:\\n        current = self.current_token\\n\\n        if current and current.type == ttype:\\n            self.advance()\\n            return current\\n\\n    def expect(self, ttype: TokenType) -> Token:\\n        if token := self.accept(ttype):\\n            return token\\n\\n        raise ValueError(f\\'Expected: {ttype}\\')\\n\\n    @property\\n    def current_token(self) -> Optional[Token]:\\n        if self.pos < len(self.tokens):\\n            return self.tokens[self.pos]\\n\\n    def advance(self):\\n        self.pos += 1\\n\\n\\nclass Visitor(ABC, Generic[T]):\\n    @abstractmethod\\n    def visit_addition(self, node: Addition) -> T:\\n        ...\\n\\n    @abstractmethod\\n    def visit_subtraction(self, node: Subtraction) -> T:\\n        ...\\n\\n    @abstractmethod\\n    def visit_multiplication(self, node: Multiplication) -> T:\\n        ...\\n\\n    @abstractmethod\\n    def visit_division(self, node: Division) -> T:\\n        ...\\n\\n    @abstractmethod\\n    def visit_modulus(self, node: Modulus) -> T:\\n        ...\\n\\n    @abstractmethod\\n    def visit_unary_minus(self, node: UnaryMinus) -> T:\\n        ...\\n\\n    @abstractmethod\\n    def visit_literal(self, node: Literal) -> T:\\n        ...\\n\\n\\nclass Calculator(Visitor[int]):\\n    def execute(self, node: Node) -> int:\\n        return node.accept(self)\\n\\n    def visit_addition(self, node: Addition) -> int:\\n        return self.execute(node.left) + self.execute(node.right)\\n\\n    def visit_subtraction(self, node: Subtraction) -> int:\\n        return self.execute(node.left) - self.execute(node.right)\\n\\n    def visit_multiplication(self, node: Multiplication) -> int:\\n        return self.execute(node.left) * self.execute(node.right)\\n\\n    def visit_division(self, node: Division) -> int:\\n        return self.execute(node.left) // self.execute(node.right)\\n\\n    def visit_modulus(self, node: Modulus) -> T:\\n        return self.execute(node.left) % self.execute(node.right)\\n\\n    def visit_unary_minus(self, node: UnaryMinus) -> int:\\n        return -self.execute(node.value)\\n\\n    def visit_literal(self, node: Literal) -> int:\\n        return node.value\\n\\n\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        parser = Parser(s)\\n        root = parser.parse()\\n\\n        calculator = Calculator()\\n        return calculator.execute(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418881,
                "title": "c-recursion-time-better-than-99-43-space-better-than-100-00",
                "content": "```\\nclass Solution {\\npublic:\\n    int cal(string &s, int &j)\\n    {\\n        int sum =0;\\n        char ch = \\'+\\';\\n        int tmp = 0;\\n        while(j<s.length())\\n        {\\n            while(j<s.length() && s[j]!=\\'(\\' && s[j]!=\\')\\')\\n            {\\n                if(s[j]>=\\'0\\' && s[j]<=\\'9\\')\\n                {\\n                    tmp = tmp*10 + (s[j]-\\'0\\');\\n                    \\n                }else if(s[j] != \\' \\')\\n                {\\n                    if(ch == \\'+\\')\\n                        sum+=tmp;\\n                    else\\n                        sum-=tmp;\\n                    \\n                    ch = s[j];\\n                    tmp =0;\\n                }\\n                j++;\\n            }\\n            \\n            if(ch == \\'+\\')\\n                sum+=tmp;\\n            else\\n                sum-=tmp;\\n            \\n            if(j<s.length())\\n            {\\n                if(s[j]==\\')\\')\\n                {\\n                    j++;\\n                    return sum;\\n                }\\n                \\n                else if(ch == \\'+\\')\\n                        sum+=cal(s,++j);\\n                else\\n                        sum-=cal(s,++j);\\n            }\\n        }\\n        return sum;\\n    }\\n    int calculate(string &s) {\\n        int  j =0;\\n        int sum =0;\\n        \\n        while(j<s.length())\\n        {\\n            sum+=cal(s,j);\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cal(string &s, int &j)\\n    {\\n        int sum =0;\\n        char ch = \\'+\\';\\n        int tmp = 0;\\n        while(j<s.length())\\n        {\\n            while(j<s.length() && s[j]!=\\'(\\' && s[j]!=\\')\\')\\n            {\\n                if(s[j]>=\\'0\\' && s[j]<=\\'9\\')\\n                {\\n                    tmp = tmp*10 + (s[j]-\\'0\\');\\n                    \\n                }else if(s[j] != \\' \\')\\n                {\\n                    if(ch == \\'+\\')\\n                        sum+=tmp;\\n                    else\\n                        sum-=tmp;\\n                    \\n                    ch = s[j];\\n                    tmp =0;\\n                }\\n                j++;\\n            }\\n            \\n            if(ch == \\'+\\')\\n                sum+=tmp;\\n            else\\n                sum-=tmp;\\n            \\n            if(j<s.length())\\n            {\\n                if(s[j]==\\')\\')\\n                {\\n                    j++;\\n                    return sum;\\n                }\\n                \\n                else if(ch == \\'+\\')\\n                        sum+=cal(s,++j);\\n                else\\n                        sum-=cal(s,++j);\\n            }\\n        }\\n        return sum;\\n    }\\n    int calculate(string &s) {\\n        int  j =0;\\n        int sum =0;\\n        \\n        while(j<s.length())\\n        {\\n            sum+=cal(s,j);\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247299,
                "title": "my-java-solution",
                "content": "```\\nclass Solution {\\n    //Time Complexity O(N)\\n    //Space Complexity O(N) at most\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        \\n        Pair<Integer, Integer> resultPair = calculateFrom(s, 0);\\n        return resultPair.getKey();\\n    }\\n    \\n    public Pair<Integer, Integer> calculateFrom(String s, int fromIdx) {\\n        if (fromIdx >= s.length()) {\\n            return new Pair(0, fromIdx + 1);\\n        }\\n        \\n        int result = 0;\\n        int sign = 1;\\n        int i = fromIdx;\\n        \\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            \\n            if (c == \\'-\\') {\\n                sign = -1;\\n                i++;\\n                continue;\\n            }\\n            \\n            if (c == \\'+\\' || c == \\' \\') {\\n                i++;\\n                continue;\\n            }\\n            \\n            if (c == \\'(\\') {\\n                Pair<Integer, Integer> pair = calculateFrom(s, i + 1);\\n                result += sign * pair.getKey();\\n                sign = 1;\\n                i = pair.getValue();\\n                continue;\\n            }\\n            \\n            if (c == \\')\\') {\\n                return new Pair(result, i + 1);\\n            }\\n            \\n            //else, evaluate next number\\n            int num = 0;\\n            while (i < s.length() && Character.isDigit(s.charAt(i))) {\\n                num = num * 10 + (s.charAt(i) - \\'0\\');\\n                i++;\\n            }\\n            result += sign * num;\\n            sign = 1;\\n        }        \\n        \\n        return new Pair(result, s.length());\\n    }\\n}\\n```\\nSolution using Stack:\\n```\\nclass Solution {\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        \\n        Stack<Integer> numStack = new Stack<>();\\n        Stack<Integer> signStack = new Stack<>();\\n        \\n        int result = 0;\\n        int sign = 1;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            \\n            if (c == \\'-\\') {\\n                sign = -1;\\n                continue;\\n            }\\n            \\n            if (c == \\'+\\' || c == \\' \\') {\\n                continue;\\n            }\\n            \\n            if (c == \\'(\\') {\\n                numStack.push(result);\\n                result = 0;\\n                signStack.push(sign);\\n                sign = 1;\\n                continue;\\n            }\\n            \\n            if (c == \\')\\') {\\n                result = signStack.pop() * result + numStack.pop();\\n                sign = 1;\\n                continue;\\n            }\\n            \\n            int num = 0;\\n            while (i < s.length() && Character.isDigit(s.charAt(i))) {\\n                num = num * 10 + (s.charAt(i) - \\'0\\');\\n                i++;\\n            }\\n            i--;\\n            result += sign * num;\\n            sign = 1;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //Time Complexity O(N)\\n    //Space Complexity O(N) at most\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        \\n        Pair<Integer, Integer> resultPair = calculateFrom(s, 0);\\n        return resultPair.getKey();\\n    }\\n    \\n    public Pair<Integer, Integer> calculateFrom(String s, int fromIdx) {\\n        if (fromIdx >= s.length()) {\\n            return new Pair(0, fromIdx + 1);\\n        }\\n        \\n        int result = 0;\\n        int sign = 1;\\n        int i = fromIdx;\\n        \\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            \\n            if (c == \\'-\\') {\\n                sign = -1;\\n                i++;\\n                continue;\\n            }\\n            \\n            if (c == \\'+\\' || c == \\' \\') {\\n                i++;\\n                continue;\\n            }\\n            \\n            if (c == \\'(\\') {\\n                Pair<Integer, Integer> pair = calculateFrom(s, i + 1);\\n                result += sign * pair.getKey();\\n                sign = 1;\\n                i = pair.getValue();\\n                continue;\\n            }\\n            \\n            if (c == \\')\\') {\\n                return new Pair(result, i + 1);\\n            }\\n            \\n            //else, evaluate next number\\n            int num = 0;\\n            while (i < s.length() && Character.isDigit(s.charAt(i))) {\\n                num = num * 10 + (s.charAt(i) - \\'0\\');\\n                i++;\\n            }\\n            result += sign * num;\\n            sign = 1;\\n        }        \\n        \\n        return new Pair(result, s.length());\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int calculate(String s) {\\n        if (s == null || s.length() == 0) {\\n            return 0;\\n        }\\n        \\n        Stack<Integer> numStack = new Stack<>();\\n        Stack<Integer> signStack = new Stack<>();\\n        \\n        int result = 0;\\n        int sign = 1;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            \\n            if (c == \\'-\\') {\\n                sign = -1;\\n                continue;\\n            }\\n            \\n            if (c == \\'+\\' || c == \\' \\') {\\n                continue;\\n            }\\n            \\n            if (c == \\'(\\') {\\n                numStack.push(result);\\n                result = 0;\\n                signStack.push(sign);\\n                sign = 1;\\n                continue;\\n            }\\n            \\n            if (c == \\')\\') {\\n                result = signStack.pop() * result + numStack.pop();\\n                sign = 1;\\n                continue;\\n            }\\n            \\n            int num = 0;\\n            while (i < s.length() && Character.isDigit(s.charAt(i))) {\\n                num = num * 10 + (s.charAt(i) - \\'0\\');\\n                i++;\\n            }\\n            i--;\\n            result += sign * num;\\n            sign = 1;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196880,
                "title": "stack-proper-comments-added-c",
                "content": "Implementation\\n\\n**Using Stack\\nTime Complexity = O(N)\\nSpace Complexity = O(N)**\\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        \\n        // will use stack to store the res & sign (for the current bracket)\\n        stack<int> st;\\n        \\n        // intially taking sign as 1, sign can be 1(positive) & -1(negative)\\n        int res = 0, sign = 1, size = s.size();\\n        \\n        // iterating over the string\\n        for(int i = 0; i < size; i++){\\n            \\n            // if current char is digit, then\\n            // collect the digit and multiply it with current sign and add into the res\\n            if(isdigit(s[i])){\\n                // taking long bcz (num * 10) in this statement there can be chance of integer overflow\\n                // i.e, s = \"2147483647\", to handle these type of cases\\n                long num = s[i] - \\'0\\';\\n                while(i+1 < size && isdigit(s[i+1])){\\n                    num = num * 10 + s[i+1] - \\'0\\';\\n                    i++;\\n                }\\n                \\n                res += num * sign;\\n            }\\n            \\n            // if current char is \\'+\\' then change the sign to 1, it means positive\\n            else if(s[i] == \\'+\\'){\\n                sign = 1;\\n            }\\n            \\n            // if current char is \\'-\\' then change the sign to 1, it means negative\\n            else if(s[i] == \\'-\\'){\\n                sign = -1;\\n            }\\n            \\n            // if current char is \\'(\\', then push the res & sign, and reinitialize res as 0, and sign as 1(positive)\\n            else if(s[i] == \\'(\\'){\\n                st.push(res);\\n                st.push(sign);\\n                res = 0;\\n                sign = 1;\\n            }\\n            \\n            // if current char is \\')\\', then multiply the res with sign(immediate top of the stack), and add the res(next top of the stack), and simultaneously pop the value from stack as well\\n            else if(s[i] == \\')\\'){\\n                int sign = st.top(); st.pop();\\n                int value = st.top(); st.pop();\\n                res = res * sign + value;\\n            }\\n        }\\n        \\n        // return the res\\n        return res;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Math",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        \\n        // will use stack to store the res & sign (for the current bracket)\\n        stack<int> st;\\n        \\n        // intially taking sign as 1, sign can be 1(positive) & -1(negative)\\n        int res = 0, sign = 1, size = s.size();\\n        \\n        // iterating over the string\\n        for(int i = 0; i < size; i++){\\n            \\n            // if current char is digit, then\\n            // collect the digit and multiply it with current sign and add into the res\\n            if(isdigit(s[i])){\\n                // taking long bcz (num * 10) in this statement there can be chance of integer overflow\\n                // i.e, s = \"2147483647\", to handle these type of cases\\n                long num = s[i] - \\'0\\';\\n                while(i+1 < size && isdigit(s[i+1])){\\n                    num = num * 10 + s[i+1] - \\'0\\';\\n                    i++;\\n                }\\n                \\n                res += num * sign;\\n            }\\n            \\n            // if current char is \\'+\\' then change the sign to 1, it means positive\\n            else if(s[i] == \\'+\\'){\\n                sign = 1;\\n            }\\n            \\n            // if current char is \\'-\\' then change the sign to 1, it means negative\\n            else if(s[i] == \\'-\\'){\\n                sign = -1;\\n            }\\n            \\n            // if current char is \\'(\\', then push the res & sign, and reinitialize res as 0, and sign as 1(positive)\\n            else if(s[i] == \\'(\\'){\\n                st.push(res);\\n                st.push(sign);\\n                res = 0;\\n                sign = 1;\\n            }\\n            \\n            // if current char is \\')\\', then multiply the res with sign(immediate top of the stack), and add the res(next top of the stack), and simultaneously pop the value from stack as well\\n            else if(s[i] == \\')\\'){\\n                int sign = st.top(); st.pop();\\n                int value = st.top(); st.pop();\\n                res = res * sign + value;\\n            }\\n        }\\n        \\n        // return the res\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174510,
                "title": "c-stack-math-time-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<string> st;\\n        int n=s.size();\\n        st.push(\"(\");\\n        s.push_back(\\')\\');\\n        int res=0;\\n        for(int i=0;i<=n;){\\n            if(s[i]==\\' \\'){\\n                i++;\\n            }else if(s[i]==\\'(\\'){\\n                st.push(\"(\");\\n                i++;\\n            }else if(s[i]>=\\'0\\' and s[i]<=\\'9\\'){\\n                string str=\"\";\\n                while(s[i]>=\\'0\\' and s[i]<=\\'9\\'){\\n                    str+=s[i];\\n                    i++;\\n                }\\n                \\n                st.push(str);\\n            }else if(s[i]==\\'-\\' and s[i+1]==\\'(\\'){\\n                st.push(\"-\");\\n                i++;\\n            }else if(s[i]==\\'-\\'){\\n                string str=\"-\";\\n                i++;\\n                while(s[i]>=\\'0\\' and s[i]<=\\'9\\'){\\n                    str+=s[i];\\n                    i++;\\n                }\\n                \\n                st.push(str);\\n            }else if(s[i]==\\')\\'){\\n                int val=0;\\n                while(st.top()!=\"(\"){\\n                    val+=stoi(st.top());\\n                    st.pop();\\n                }\\n                st.pop();\\n                if(!st.empty() and st.top()==\"-\"){\\n                    val=val*-1;\\n                    st.pop();\\n                }\\n                st.push(to_string(val));\\n                i++;\\n            }else{\\n                i++;\\n            }  \\n        }\\n        return stoi(st.top());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<string> st;\\n        int n=s.size();\\n        st.push(\"(\");\\n        s.push_back(\\')\\');\\n        int res=0;\\n        for(int i=0;i<=n;){\\n            if(s[i]==\\' \\'){\\n                i++;\\n            }else if(s[i]==\\'(\\'){\\n                st.push(\"(\");\\n                i++;\\n            }else if(s[i]>=\\'0\\' and s[i]<=\\'9\\'){\\n                string str=\"\";\\n                while(s[i]>=\\'0\\' and s[i]<=\\'9\\'){\\n                    str+=s[i];\\n                    i++;\\n                }\\n                \\n                st.push(str);\\n            }else if(s[i]==\\'-\\' and s[i+1]==\\'(\\'){\\n                st.push(\"-\");\\n                i++;\\n            }else if(s[i]==\\'-\\'){\\n                string str=\"-\";\\n                i++;\\n                while(s[i]>=\\'0\\' and s[i]<=\\'9\\'){\\n                    str+=s[i];\\n                    i++;\\n                }\\n                \\n                st.push(str);\\n            }else if(s[i]==\\')\\'){\\n                int val=0;\\n                while(st.top()!=\"(\"){\\n                    val+=stoi(st.top());\\n                    st.pop();\\n                }\\n                st.pop();\\n                if(!st.empty() and st.top()==\"-\"){\\n                    val=val*-1;\\n                    st.pop();\\n                }\\n                st.push(to_string(val));\\n                i++;\\n            }else{\\n                i++;\\n            }  \\n        }\\n        return stoi(st.top());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043695,
                "title": "224-basic-calculator",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n\\t// sum to calculate the total result of evaluation\\n         int sum=0;\\n  // sign to tell whether its going to be positive or negative\\t\\t \\n        int sign=1;\\n        stack<int> st;\\n        for(int i=0;i<s.size();i++){\\n            // if the current s[i] is digit\\n            if(isdigit(s[i])){\\n\\t    // value to get the value of  multiple digits  like\\n        // 3124+1 will give 3124 it will end loop at + so we do i-- to  go back \\n      // one step to not miss this\\n                int val=0;\\n                while(i<s.size()&&isdigit(s[i])){\\n                    val=val*10+(s[i]-\\'0\\');\\n                    i++;\\n                }\\n                i--;\\n\\t\\t// to get the sign of val, mulitply it with sign and then reset the sign for next ones\\n                val=val*sign;\\n                sign=1;\\n\\t\\t// add the val to our sum\\n                sum+=val;\\n            }\\n            \\n            else if(s[i]==\\'(\\'){\\n\\t// whenever we encounter an \\'(\\' push the sum and sign to stack and reset them\\t\\t\\n                st.push(sum);\\n                st.push(sign);\\n                sum=0;\\n                sign=+1;\\n            }\\n            \\n            else if(s[i]==\\')\\'){\\n\\t// when we get \\')\\' this means an end of parantheses  so multiply with stack top\\n\\t// which will give us the sign of sum and pop it\\n                sum*=st.top();\\n                st.pop();\\n// after getting the sum add it with our previous sum stored in stack to get the total resultant\\n// and pop it after that\\n                sum+=st.top();\\n                st.pop();\\n            }\\n            \\n            else if(s[i]==\\'-\\'){\\n\\t\\t\\t// if we encounter a - sign just mulitply it our sign\\n                sign*=-1;\\n            }\\n        }\\n        // return our total sum or evaluation\\n        return sum;\\n    }\\n};\\n\\n// give your feedbacks regarding this and **upvote if you like the solution** \\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int calculate(string s) {\\n\\t// sum to calculate the total result of evaluation\\n         int sum=0;\\n  // sign to tell whether its going to be positive or negative\\t\\t \\n        int sign=1;\\n        stack<int> st;\\n        for(int i=0;i<s.size();i++){\\n            // if the current s[i] is digit\\n            if(isdigit(s[i])){\\n\\t    // value to get the value of  multiple digits  like\\n        // 3124+1 will give 3124 it will end loop at + so we do i-- to  go back \\n      // one step to not miss this\\n                int val=0;\\n                while(i<s.size()&&isdigit(s[i])){\\n                    val=val*10+(s[i]-\\'0\\');\\n                    i++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1986385,
                "title": "cpp-stack-commented",
                "content": "```\\nint basicCalculator(string str) {\\n\\t//good, hard question lot of steps are there\\n\\tint sum = 0;\\n\\tint sign = 1;\\n\\tstack<int> st;\\n\\n\\tfor (int i = 0; i < str.size(); i++) {\\n\\t\\tchar ch = str[i];\\n\\t\\tif (isdigit(ch)) {\\n\\t\\t\\t//get the whole number, like if ch is \\'1\\' then iterate further to get the number like \\'15\\'\\n\\t\\t\\tint val = 0;\\n\\t\\t\\twhile (i < str.size() and isdigit(str[i])) {\\n\\t\\t\\t\\tval = val * 10 + (str[i] - \\'0\\');\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\ti--;//coz, i ab ek no digit pe aa gya, or outer for loop se vo ek age or bdh jaega, ek char miss kr dega islie i-- kia\\n\\t\\t\\tval = val * sign;\\n\\t\\t\\tsign = 1;//sign ko reset kia\\n\\t\\t\\tsum += val;\\n\\t\\t}\\n\\t\\telse if (ch == \\'(\\') {\\n\\t\\t\\t//sum dalo stack pe, sign dalo stack pe or fir sign and sum ko reset kro\\n\\t\\t\\tst.push(sum);\\n\\t\\t\\tst.push(sign);\\n\\t\\t\\t//reset sign and sum;\\n\\t\\t\\tsum = 0;\\n\\t\\t\\tsign = 1;\\n\\t\\t}\\n\\t\\telse if (ch == \\')\\') {\\n\\t\\t\\t//stack se sign nikalo or use sum se multiply krdo\\n\\t\\t\\tsum *= st.top();\\n\\t\\t\\tst.pop();\\n\\t\\t\\t//sum me stack ka top add krdo\\n\\t\\t\\tsum += st.top();\\n\\t\\t\\tst.pop();\\n\\t\\t}\\n\\t\\telse if (ch == \\'-\\') {\\n\\t\\t\\t//minus hota h to sign ko reverse krte hai,bachpn me math me pda tha\\n\\t\\t\\tsign *= -1; //sign ko toggle kia hai\\n\\t\\t}\\n\\t}\\n\\treturn sum;\\n}",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nint basicCalculator(string str) {\\n\\t//good, hard question lot of steps are there\\n\\tint sum = 0;\\n\\tint sign = 1;\\n\\tstack<int> st;\\n\\n\\tfor (int i = 0; i < str.size(); i++) {\\n\\t\\tchar ch = str[i];\\n\\t\\tif (isdigit(ch)) {\\n\\t\\t\\t//get the whole number, like if ch is \\'1\\' then iterate further to get the number like \\'15\\'\\n\\t\\t\\tint val = 0;\\n\\t\\t\\twhile (i < str.size() and isdigit(str[i])) {\\n\\t\\t\\t\\tval = val * 10 + (str[i] - \\'0\\');\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\ti--;//coz, i ab ek no digit pe aa gya, or outer for loop se vo ek age or bdh jaega, ek char miss kr dega islie i-- kia\\n\\t\\t\\tval = val * sign;\\n\\t\\t\\tsign = 1;//sign ko reset kia\\n\\t\\t\\tsum += val;\\n\\t\\t}\\n\\t\\telse if (ch == \\'(\\') {\\n\\t\\t\\t//sum dalo stack pe, sign dalo stack pe or fir sign and sum ko reset kro\\n\\t\\t\\tst.push(sum);\\n\\t\\t\\tst.push(sign);\\n\\t\\t\\t//reset sign and sum;\\n\\t\\t\\tsum = 0;\\n\\t\\t\\tsign = 1;\\n\\t\\t}\\n\\t\\telse if (ch == \\')\\') {\\n\\t\\t\\t//stack se sign nikalo or use sum se multiply krdo\\n\\t\\t\\tsum *= st.top();\\n\\t\\t\\tst.pop();\\n\\t\\t\\t//sum me stack ka top add krdo\\n\\t\\t\\tsum += st.top();\\n\\t\\t\\tst.pop();\\n\\t\\t}\\n\\t\\telse if (ch == \\'-\\') {\\n\\t\\t\\t//minus hota h to sign ko reverse krte hai,bachpn me math me pda tha\\n\\t\\t\\tsign *= -1; //sign ko toggle kia hai\\n\\t\\t}\\n\\t}\\n\\treturn sum;\\n}",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1791140,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1689917,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1565470,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1568578,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1690608,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1573016,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1575487,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1570456,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1575320,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1574065,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1791140,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1689917,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1565470,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1568578,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1690608,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1573016,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1575487,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1570456,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1575320,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1574065,
                "content": [
                    {
                        "username": "anonydon89",
                        "content": "a basic calculator shouldnt be allowed to have parenthesis. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "True, they dont exist "
                    },
                    {
                        "username": "zzandland",
                        "content": "Damn should have read the description first. I thought multiplication and division were also part of the requirements and implemented that as well.."
                    },
                    {
                        "username": "lkwq007",
                        "content": "Input:\\n`\"-2+ 1\"`\\n`\"- (3 + (4 + 5))\"`\\n\\nHowever, the problem clearly states that\\n> \\'-\\' could be used as a unary operation but it has to be inside parentheses"
                    },
                    {
                        "username": "beingforthem",
                        "content": "This seems like a bad judge, because it wants \"1 - -1\" = 0, instead of 2."
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n"
                    },
                    {
                        "username": "viveksingh10",
                        "content": "As per the \"Constraints\" \"There will be no two consecutive operators in the input.\" Hence the above expression is invalid. "
                    },
                    {
                        "username": "nirutgupta",
                        "content": "they are now throwing invalid expression for this! "
                    },
                    {
                        "username": "chymcakmilan",
                        "content": "If first item is not number or bracket, just add 0 ..it makes it much easier.\\n `\"-2+ 1\"` becomes `0 - 2 + 1`"
                    },
                    {
                        "username": "aishu8333",
                        "content": "In my case, whenever \\'-\\'  comes in string,  check the top element of stack is numeric or not. If not push \\'0\\' & then push \\'-\\'. "
                    },
                    {
                        "username": "TheAsh",
                        "content": "I think that the problem description should include information on the desired efficiency. I\\'m probably not the only one who first designed a working solution that got rejected after test `36` because of its runtime, and then had to go back and write a solution in `O(N)`. I find it frustrating when information that can be easily added to the problem statement has to be inferred from test cases. Regarding this problem, jus adding something along the lines of \"just make a single pass on the input string\" would be fine."
                    },
                    {
                        "username": "twoseat",
                        "content": "I understand your frustration but I think that removes a layer of complexity from the question. giving information like \"just make a single pass on the input string\" is kind of a hint on how you should approach this question."
                    },
                    {
                        "username": "SummerGram",
                        "content": "Why -1 - -1 is equal to -2?"
                    },
                    {
                        "username": "Nishant_Mainwal",
                        "content": "Given \"There will be no two consecutive operators in the input\". Hence this input is not correct."
                    },
                    {
                        "username": "zero_to_twelve",
                        "content": "Test case:\\n<code>\"+48 - -2\"</code>\\n\\nAnswer should be 50, not 46.\\n\\n"
                    },
                    {
                        "username": "_PAIN",
                        "content": "There will be no two consecutive operators in the input.\\nit is mentioned\\n\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@FaangLeetcoder](/CuriousProgrammer) It looks like the question is updated, and this expression is an invalid expression now."
                    },
                    {
                        "username": "DumbProgrammer",
                        "content": "+ cannot be used as a unary operator as mentioned in the problem statement"
                    },
                    {
                        "username": "yanglisde",
                        "content": "No one tested on this test case?"
                    },
                    {
                        "username": "gbeness",
                        "content": "I don\\'t know if this is a valid scenario but if you run \"5--2\", it should resolve 7 but instead it gives 3. Algo may need ot be adjusted to account for this, as I think this is a valid string."
                    }
                ]
            },
            {
                "id": 1803550,
                "content": [
                    {
                        "username": "Sofiyan_M",
                        "content": "This question is based on the Application of Stack for Evaluation of infix Expression"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Annoyingly this was timing out on Run, even after I\\'d tried 2 approaches to optimise it... I tried Submitting it and it passed. It\\'s frustrating that the Run test is not representative of Submission."
                    },
                    {
                        "username": "Divyaporwal",
                        "content": "take care of the test case like this\\n\"1-(     -2)\""
                    },
                    {
                        "username": "PainKKKiller",
                        "content": "I\\'ve got trouble with this test. Figuring out how to parse (-2) as negative number"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    },
                    {
                        "username": "ushnish",
                        "content": "[@YYANN](/YYANN) Could you share your code here? I find it hard to understand how you could answer this question in 15-20 minutes"
                    },
                    {
                        "username": "djslim",
                        "content": "mmh even top leetcoders consider this one as hard/annoying problem: https://www.youtube.com/watch?v=nZY6p5PbWss"
                    },
                    {
                        "username": "YYANN",
                        "content": "[@nirutgupta78](/nirutgupta78) i usually spend 2-3 hours on hard problems. i spent less than 20 minutes on this one. i solved it with just a series of if statements. i expect a little more depth from a \\'hard\\' question."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "well I feel it was a good question, like handling the negative number. [@YYANN](/YYANN)How much time have you spent on it?"
                    },
                    {
                        "username": "triyankk",
                        "content": " `class Solution:`\\n    `def calculate(self, s: str) -> int:`        \\n        `return eval(s) `\\nI\\'m able to solve most of the Testcases with this but some expressions are throwing too many parenthesis error. can anyone help with it?"
                    },
                    {
                        "username": "thisismrsanjay",
                        "content": "Beware it looks simple \\n s =\"2147483647\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "today I understood that even though + and - may have same priority, they should always be computed from left to right"
                    },
                    {
                        "username": "phanidharguttikonda",
                        "content": "1-(     -2) for this type of inputs the conversion of the postfix  and prefix is n bad idea i think\\n"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The testcases except the last is easy to pass, but\n`s=\"- (3 - (- (4 + 5) ) )\"` is the **pain**.\nHere is the RPN \n`[3, 4, 5, '+', '-', '-', '-']`\nthe correct evaluation stands for `-6`, but `-12` is expecting.\nIs it an another way to solve this RPN propeply? \n**PS:** it was solved thx to one indian site.\n**Be sure** in case of unary minus to PREPEND the leading zero like\n`-2 + 1` => `0 - 2 + 1` "
                    },
                    {
                        "username": "subscriber6436",
                        "content": "[@ushnish](/ushnish)  yes, it is, after some minutes i fix this and came across after the prev. task:)"
                    },
                    {
                        "username": "ushnish",
                        "content": "So the answer to the expression above is -12 not -6, not sure how you\\u2019re getting that. And this question is different from RPN, there is a separate LC question for RPN"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "So exhausting to reconsider all the possibilities."
                    }
                ]
            },
            {
                "id": 1696720,
                "content": [
                    {
                        "username": "Sofiyan_M",
                        "content": "This question is based on the Application of Stack for Evaluation of infix Expression"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Annoyingly this was timing out on Run, even after I\\'d tried 2 approaches to optimise it... I tried Submitting it and it passed. It\\'s frustrating that the Run test is not representative of Submission."
                    },
                    {
                        "username": "Divyaporwal",
                        "content": "take care of the test case like this\\n\"1-(     -2)\""
                    },
                    {
                        "username": "PainKKKiller",
                        "content": "I\\'ve got trouble with this test. Figuring out how to parse (-2) as negative number"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    },
                    {
                        "username": "ushnish",
                        "content": "[@YYANN](/YYANN) Could you share your code here? I find it hard to understand how you could answer this question in 15-20 minutes"
                    },
                    {
                        "username": "djslim",
                        "content": "mmh even top leetcoders consider this one as hard/annoying problem: https://www.youtube.com/watch?v=nZY6p5PbWss"
                    },
                    {
                        "username": "YYANN",
                        "content": "[@nirutgupta78](/nirutgupta78) i usually spend 2-3 hours on hard problems. i spent less than 20 minutes on this one. i solved it with just a series of if statements. i expect a little more depth from a \\'hard\\' question."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "well I feel it was a good question, like handling the negative number. [@YYANN](/YYANN)How much time have you spent on it?"
                    },
                    {
                        "username": "triyankk",
                        "content": " `class Solution:`\\n    `def calculate(self, s: str) -> int:`        \\n        `return eval(s) `\\nI\\'m able to solve most of the Testcases with this but some expressions are throwing too many parenthesis error. can anyone help with it?"
                    },
                    {
                        "username": "thisismrsanjay",
                        "content": "Beware it looks simple \\n s =\"2147483647\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "today I understood that even though + and - may have same priority, they should always be computed from left to right"
                    },
                    {
                        "username": "phanidharguttikonda",
                        "content": "1-(     -2) for this type of inputs the conversion of the postfix  and prefix is n bad idea i think\\n"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The testcases except the last is easy to pass, but\n`s=\"- (3 - (- (4 + 5) ) )\"` is the **pain**.\nHere is the RPN \n`[3, 4, 5, '+', '-', '-', '-']`\nthe correct evaluation stands for `-6`, but `-12` is expecting.\nIs it an another way to solve this RPN propeply? \n**PS:** it was solved thx to one indian site.\n**Be sure** in case of unary minus to PREPEND the leading zero like\n`-2 + 1` => `0 - 2 + 1` "
                    },
                    {
                        "username": "subscriber6436",
                        "content": "[@ushnish](/ushnish)  yes, it is, after some minutes i fix this and came across after the prev. task:)"
                    },
                    {
                        "username": "ushnish",
                        "content": "So the answer to the expression above is -12 not -6, not sure how you\\u2019re getting that. And this question is different from RPN, there is a separate LC question for RPN"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "So exhausting to reconsider all the possibilities."
                    }
                ]
            },
            {
                "id": 1690782,
                "content": [
                    {
                        "username": "Sofiyan_M",
                        "content": "This question is based on the Application of Stack for Evaluation of infix Expression"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Annoyingly this was timing out on Run, even after I\\'d tried 2 approaches to optimise it... I tried Submitting it and it passed. It\\'s frustrating that the Run test is not representative of Submission."
                    },
                    {
                        "username": "Divyaporwal",
                        "content": "take care of the test case like this\\n\"1-(     -2)\""
                    },
                    {
                        "username": "PainKKKiller",
                        "content": "I\\'ve got trouble with this test. Figuring out how to parse (-2) as negative number"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    },
                    {
                        "username": "ushnish",
                        "content": "[@YYANN](/YYANN) Could you share your code here? I find it hard to understand how you could answer this question in 15-20 minutes"
                    },
                    {
                        "username": "djslim",
                        "content": "mmh even top leetcoders consider this one as hard/annoying problem: https://www.youtube.com/watch?v=nZY6p5PbWss"
                    },
                    {
                        "username": "YYANN",
                        "content": "[@nirutgupta78](/nirutgupta78) i usually spend 2-3 hours on hard problems. i spent less than 20 minutes on this one. i solved it with just a series of if statements. i expect a little more depth from a \\'hard\\' question."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "well I feel it was a good question, like handling the negative number. [@YYANN](/YYANN)How much time have you spent on it?"
                    },
                    {
                        "username": "triyankk",
                        "content": " `class Solution:`\\n    `def calculate(self, s: str) -> int:`        \\n        `return eval(s) `\\nI\\'m able to solve most of the Testcases with this but some expressions are throwing too many parenthesis error. can anyone help with it?"
                    },
                    {
                        "username": "thisismrsanjay",
                        "content": "Beware it looks simple \\n s =\"2147483647\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "today I understood that even though + and - may have same priority, they should always be computed from left to right"
                    },
                    {
                        "username": "phanidharguttikonda",
                        "content": "1-(     -2) for this type of inputs the conversion of the postfix  and prefix is n bad idea i think\\n"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The testcases except the last is easy to pass, but\n`s=\"- (3 - (- (4 + 5) ) )\"` is the **pain**.\nHere is the RPN \n`[3, 4, 5, '+', '-', '-', '-']`\nthe correct evaluation stands for `-6`, but `-12` is expecting.\nIs it an another way to solve this RPN propeply? \n**PS:** it was solved thx to one indian site.\n**Be sure** in case of unary minus to PREPEND the leading zero like\n`-2 + 1` => `0 - 2 + 1` "
                    },
                    {
                        "username": "subscriber6436",
                        "content": "[@ushnish](/ushnish)  yes, it is, after some minutes i fix this and came across after the prev. task:)"
                    },
                    {
                        "username": "ushnish",
                        "content": "So the answer to the expression above is -12 not -6, not sure how you\\u2019re getting that. And this question is different from RPN, there is a separate LC question for RPN"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "So exhausting to reconsider all the possibilities."
                    }
                ]
            },
            {
                "id": 1690577,
                "content": [
                    {
                        "username": "Sofiyan_M",
                        "content": "This question is based on the Application of Stack for Evaluation of infix Expression"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Annoyingly this was timing out on Run, even after I\\'d tried 2 approaches to optimise it... I tried Submitting it and it passed. It\\'s frustrating that the Run test is not representative of Submission."
                    },
                    {
                        "username": "Divyaporwal",
                        "content": "take care of the test case like this\\n\"1-(     -2)\""
                    },
                    {
                        "username": "PainKKKiller",
                        "content": "I\\'ve got trouble with this test. Figuring out how to parse (-2) as negative number"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    },
                    {
                        "username": "ushnish",
                        "content": "[@YYANN](/YYANN) Could you share your code here? I find it hard to understand how you could answer this question in 15-20 minutes"
                    },
                    {
                        "username": "djslim",
                        "content": "mmh even top leetcoders consider this one as hard/annoying problem: https://www.youtube.com/watch?v=nZY6p5PbWss"
                    },
                    {
                        "username": "YYANN",
                        "content": "[@nirutgupta78](/nirutgupta78) i usually spend 2-3 hours on hard problems. i spent less than 20 minutes on this one. i solved it with just a series of if statements. i expect a little more depth from a \\'hard\\' question."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "well I feel it was a good question, like handling the negative number. [@YYANN](/YYANN)How much time have you spent on it?"
                    },
                    {
                        "username": "triyankk",
                        "content": " `class Solution:`\\n    `def calculate(self, s: str) -> int:`        \\n        `return eval(s) `\\nI\\'m able to solve most of the Testcases with this but some expressions are throwing too many parenthesis error. can anyone help with it?"
                    },
                    {
                        "username": "thisismrsanjay",
                        "content": "Beware it looks simple \\n s =\"2147483647\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "today I understood that even though + and - may have same priority, they should always be computed from left to right"
                    },
                    {
                        "username": "phanidharguttikonda",
                        "content": "1-(     -2) for this type of inputs the conversion of the postfix  and prefix is n bad idea i think\\n"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The testcases except the last is easy to pass, but\n`s=\"- (3 - (- (4 + 5) ) )\"` is the **pain**.\nHere is the RPN \n`[3, 4, 5, '+', '-', '-', '-']`\nthe correct evaluation stands for `-6`, but `-12` is expecting.\nIs it an another way to solve this RPN propeply? \n**PS:** it was solved thx to one indian site.\n**Be sure** in case of unary minus to PREPEND the leading zero like\n`-2 + 1` => `0 - 2 + 1` "
                    },
                    {
                        "username": "subscriber6436",
                        "content": "[@ushnish](/ushnish)  yes, it is, after some minutes i fix this and came across after the prev. task:)"
                    },
                    {
                        "username": "ushnish",
                        "content": "So the answer to the expression above is -12 not -6, not sure how you\\u2019re getting that. And this question is different from RPN, there is a separate LC question for RPN"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "So exhausting to reconsider all the possibilities."
                    }
                ]
            },
            {
                "id": 2071733,
                "content": [
                    {
                        "username": "Sofiyan_M",
                        "content": "This question is based on the Application of Stack for Evaluation of infix Expression"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Annoyingly this was timing out on Run, even after I\\'d tried 2 approaches to optimise it... I tried Submitting it and it passed. It\\'s frustrating that the Run test is not representative of Submission."
                    },
                    {
                        "username": "Divyaporwal",
                        "content": "take care of the test case like this\\n\"1-(     -2)\""
                    },
                    {
                        "username": "PainKKKiller",
                        "content": "I\\'ve got trouble with this test. Figuring out how to parse (-2) as negative number"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    },
                    {
                        "username": "ushnish",
                        "content": "[@YYANN](/YYANN) Could you share your code here? I find it hard to understand how you could answer this question in 15-20 minutes"
                    },
                    {
                        "username": "djslim",
                        "content": "mmh even top leetcoders consider this one as hard/annoying problem: https://www.youtube.com/watch?v=nZY6p5PbWss"
                    },
                    {
                        "username": "YYANN",
                        "content": "[@nirutgupta78](/nirutgupta78) i usually spend 2-3 hours on hard problems. i spent less than 20 minutes on this one. i solved it with just a series of if statements. i expect a little more depth from a \\'hard\\' question."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "well I feel it was a good question, like handling the negative number. [@YYANN](/YYANN)How much time have you spent on it?"
                    },
                    {
                        "username": "triyankk",
                        "content": " `class Solution:`\\n    `def calculate(self, s: str) -> int:`        \\n        `return eval(s) `\\nI\\'m able to solve most of the Testcases with this but some expressions are throwing too many parenthesis error. can anyone help with it?"
                    },
                    {
                        "username": "thisismrsanjay",
                        "content": "Beware it looks simple \\n s =\"2147483647\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "today I understood that even though + and - may have same priority, they should always be computed from left to right"
                    },
                    {
                        "username": "phanidharguttikonda",
                        "content": "1-(     -2) for this type of inputs the conversion of the postfix  and prefix is n bad idea i think\\n"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The testcases except the last is easy to pass, but\n`s=\"- (3 - (- (4 + 5) ) )\"` is the **pain**.\nHere is the RPN \n`[3, 4, 5, '+', '-', '-', '-']`\nthe correct evaluation stands for `-6`, but `-12` is expecting.\nIs it an another way to solve this RPN propeply? \n**PS:** it was solved thx to one indian site.\n**Be sure** in case of unary minus to PREPEND the leading zero like\n`-2 + 1` => `0 - 2 + 1` "
                    },
                    {
                        "username": "subscriber6436",
                        "content": "[@ushnish](/ushnish)  yes, it is, after some minutes i fix this and came across after the prev. task:)"
                    },
                    {
                        "username": "ushnish",
                        "content": "So the answer to the expression above is -12 not -6, not sure how you\\u2019re getting that. And this question is different from RPN, there is a separate LC question for RPN"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "So exhausting to reconsider all the possibilities."
                    }
                ]
            },
            {
                "id": 2064534,
                "content": [
                    {
                        "username": "Sofiyan_M",
                        "content": "This question is based on the Application of Stack for Evaluation of infix Expression"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Annoyingly this was timing out on Run, even after I\\'d tried 2 approaches to optimise it... I tried Submitting it and it passed. It\\'s frustrating that the Run test is not representative of Submission."
                    },
                    {
                        "username": "Divyaporwal",
                        "content": "take care of the test case like this\\n\"1-(     -2)\""
                    },
                    {
                        "username": "PainKKKiller",
                        "content": "I\\'ve got trouble with this test. Figuring out how to parse (-2) as negative number"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    },
                    {
                        "username": "ushnish",
                        "content": "[@YYANN](/YYANN) Could you share your code here? I find it hard to understand how you could answer this question in 15-20 minutes"
                    },
                    {
                        "username": "djslim",
                        "content": "mmh even top leetcoders consider this one as hard/annoying problem: https://www.youtube.com/watch?v=nZY6p5PbWss"
                    },
                    {
                        "username": "YYANN",
                        "content": "[@nirutgupta78](/nirutgupta78) i usually spend 2-3 hours on hard problems. i spent less than 20 minutes on this one. i solved it with just a series of if statements. i expect a little more depth from a \\'hard\\' question."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "well I feel it was a good question, like handling the negative number. [@YYANN](/YYANN)How much time have you spent on it?"
                    },
                    {
                        "username": "triyankk",
                        "content": " `class Solution:`\\n    `def calculate(self, s: str) -> int:`        \\n        `return eval(s) `\\nI\\'m able to solve most of the Testcases with this but some expressions are throwing too many parenthesis error. can anyone help with it?"
                    },
                    {
                        "username": "thisismrsanjay",
                        "content": "Beware it looks simple \\n s =\"2147483647\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "today I understood that even though + and - may have same priority, they should always be computed from left to right"
                    },
                    {
                        "username": "phanidharguttikonda",
                        "content": "1-(     -2) for this type of inputs the conversion of the postfix  and prefix is n bad idea i think\\n"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The testcases except the last is easy to pass, but\n`s=\"- (3 - (- (4 + 5) ) )\"` is the **pain**.\nHere is the RPN \n`[3, 4, 5, '+', '-', '-', '-']`\nthe correct evaluation stands for `-6`, but `-12` is expecting.\nIs it an another way to solve this RPN propeply? \n**PS:** it was solved thx to one indian site.\n**Be sure** in case of unary minus to PREPEND the leading zero like\n`-2 + 1` => `0 - 2 + 1` "
                    },
                    {
                        "username": "subscriber6436",
                        "content": "[@ushnish](/ushnish)  yes, it is, after some minutes i fix this and came across after the prev. task:)"
                    },
                    {
                        "username": "ushnish",
                        "content": "So the answer to the expression above is -12 not -6, not sure how you\\u2019re getting that. And this question is different from RPN, there is a separate LC question for RPN"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "So exhausting to reconsider all the possibilities."
                    }
                ]
            },
            {
                "id": 2058441,
                "content": [
                    {
                        "username": "Sofiyan_M",
                        "content": "This question is based on the Application of Stack for Evaluation of infix Expression"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Annoyingly this was timing out on Run, even after I\\'d tried 2 approaches to optimise it... I tried Submitting it and it passed. It\\'s frustrating that the Run test is not representative of Submission."
                    },
                    {
                        "username": "Divyaporwal",
                        "content": "take care of the test case like this\\n\"1-(     -2)\""
                    },
                    {
                        "username": "PainKKKiller",
                        "content": "I\\'ve got trouble with this test. Figuring out how to parse (-2) as negative number"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    },
                    {
                        "username": "ushnish",
                        "content": "[@YYANN](/YYANN) Could you share your code here? I find it hard to understand how you could answer this question in 15-20 minutes"
                    },
                    {
                        "username": "djslim",
                        "content": "mmh even top leetcoders consider this one as hard/annoying problem: https://www.youtube.com/watch?v=nZY6p5PbWss"
                    },
                    {
                        "username": "YYANN",
                        "content": "[@nirutgupta78](/nirutgupta78) i usually spend 2-3 hours on hard problems. i spent less than 20 minutes on this one. i solved it with just a series of if statements. i expect a little more depth from a \\'hard\\' question."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "well I feel it was a good question, like handling the negative number. [@YYANN](/YYANN)How much time have you spent on it?"
                    },
                    {
                        "username": "triyankk",
                        "content": " `class Solution:`\\n    `def calculate(self, s: str) -> int:`        \\n        `return eval(s) `\\nI\\'m able to solve most of the Testcases with this but some expressions are throwing too many parenthesis error. can anyone help with it?"
                    },
                    {
                        "username": "thisismrsanjay",
                        "content": "Beware it looks simple \\n s =\"2147483647\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "today I understood that even though + and - may have same priority, they should always be computed from left to right"
                    },
                    {
                        "username": "phanidharguttikonda",
                        "content": "1-(     -2) for this type of inputs the conversion of the postfix  and prefix is n bad idea i think\\n"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The testcases except the last is easy to pass, but\n`s=\"- (3 - (- (4 + 5) ) )\"` is the **pain**.\nHere is the RPN \n`[3, 4, 5, '+', '-', '-', '-']`\nthe correct evaluation stands for `-6`, but `-12` is expecting.\nIs it an another way to solve this RPN propeply? \n**PS:** it was solved thx to one indian site.\n**Be sure** in case of unary minus to PREPEND the leading zero like\n`-2 + 1` => `0 - 2 + 1` "
                    },
                    {
                        "username": "subscriber6436",
                        "content": "[@ushnish](/ushnish)  yes, it is, after some minutes i fix this and came across after the prev. task:)"
                    },
                    {
                        "username": "ushnish",
                        "content": "So the answer to the expression above is -12 not -6, not sure how you\\u2019re getting that. And this question is different from RPN, there is a separate LC question for RPN"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "So exhausting to reconsider all the possibilities."
                    }
                ]
            },
            {
                "id": 2056993,
                "content": [
                    {
                        "username": "Sofiyan_M",
                        "content": "This question is based on the Application of Stack for Evaluation of infix Expression"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Annoyingly this was timing out on Run, even after I\\'d tried 2 approaches to optimise it... I tried Submitting it and it passed. It\\'s frustrating that the Run test is not representative of Submission."
                    },
                    {
                        "username": "Divyaporwal",
                        "content": "take care of the test case like this\\n\"1-(     -2)\""
                    },
                    {
                        "username": "PainKKKiller",
                        "content": "I\\'ve got trouble with this test. Figuring out how to parse (-2) as negative number"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    },
                    {
                        "username": "ushnish",
                        "content": "[@YYANN](/YYANN) Could you share your code here? I find it hard to understand how you could answer this question in 15-20 minutes"
                    },
                    {
                        "username": "djslim",
                        "content": "mmh even top leetcoders consider this one as hard/annoying problem: https://www.youtube.com/watch?v=nZY6p5PbWss"
                    },
                    {
                        "username": "YYANN",
                        "content": "[@nirutgupta78](/nirutgupta78) i usually spend 2-3 hours on hard problems. i spent less than 20 minutes on this one. i solved it with just a series of if statements. i expect a little more depth from a \\'hard\\' question."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "well I feel it was a good question, like handling the negative number. [@YYANN](/YYANN)How much time have you spent on it?"
                    },
                    {
                        "username": "triyankk",
                        "content": " `class Solution:`\\n    `def calculate(self, s: str) -> int:`        \\n        `return eval(s) `\\nI\\'m able to solve most of the Testcases with this but some expressions are throwing too many parenthesis error. can anyone help with it?"
                    },
                    {
                        "username": "thisismrsanjay",
                        "content": "Beware it looks simple \\n s =\"2147483647\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "today I understood that even though + and - may have same priority, they should always be computed from left to right"
                    },
                    {
                        "username": "phanidharguttikonda",
                        "content": "1-(     -2) for this type of inputs the conversion of the postfix  and prefix is n bad idea i think\\n"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The testcases except the last is easy to pass, but\n`s=\"- (3 - (- (4 + 5) ) )\"` is the **pain**.\nHere is the RPN \n`[3, 4, 5, '+', '-', '-', '-']`\nthe correct evaluation stands for `-6`, but `-12` is expecting.\nIs it an another way to solve this RPN propeply? \n**PS:** it was solved thx to one indian site.\n**Be sure** in case of unary minus to PREPEND the leading zero like\n`-2 + 1` => `0 - 2 + 1` "
                    },
                    {
                        "username": "subscriber6436",
                        "content": "[@ushnish](/ushnish)  yes, it is, after some minutes i fix this and came across after the prev. task:)"
                    },
                    {
                        "username": "ushnish",
                        "content": "So the answer to the expression above is -12 not -6, not sure how you\\u2019re getting that. And this question is different from RPN, there is a separate LC question for RPN"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "So exhausting to reconsider all the possibilities."
                    }
                ]
            },
            {
                "id": 2035750,
                "content": [
                    {
                        "username": "Sofiyan_M",
                        "content": "This question is based on the Application of Stack for Evaluation of infix Expression"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Annoyingly this was timing out on Run, even after I\\'d tried 2 approaches to optimise it... I tried Submitting it and it passed. It\\'s frustrating that the Run test is not representative of Submission."
                    },
                    {
                        "username": "Divyaporwal",
                        "content": "take care of the test case like this\\n\"1-(     -2)\""
                    },
                    {
                        "username": "PainKKKiller",
                        "content": "I\\'ve got trouble with this test. Figuring out how to parse (-2) as negative number"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    },
                    {
                        "username": "ushnish",
                        "content": "[@YYANN](/YYANN) Could you share your code here? I find it hard to understand how you could answer this question in 15-20 minutes"
                    },
                    {
                        "username": "djslim",
                        "content": "mmh even top leetcoders consider this one as hard/annoying problem: https://www.youtube.com/watch?v=nZY6p5PbWss"
                    },
                    {
                        "username": "YYANN",
                        "content": "[@nirutgupta78](/nirutgupta78) i usually spend 2-3 hours on hard problems. i spent less than 20 minutes on this one. i solved it with just a series of if statements. i expect a little more depth from a \\'hard\\' question."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "well I feel it was a good question, like handling the negative number. [@YYANN](/YYANN)How much time have you spent on it?"
                    },
                    {
                        "username": "triyankk",
                        "content": " `class Solution:`\\n    `def calculate(self, s: str) -> int:`        \\n        `return eval(s) `\\nI\\'m able to solve most of the Testcases with this but some expressions are throwing too many parenthesis error. can anyone help with it?"
                    },
                    {
                        "username": "thisismrsanjay",
                        "content": "Beware it looks simple \\n s =\"2147483647\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "today I understood that even though + and - may have same priority, they should always be computed from left to right"
                    },
                    {
                        "username": "phanidharguttikonda",
                        "content": "1-(     -2) for this type of inputs the conversion of the postfix  and prefix is n bad idea i think\\n"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The testcases except the last is easy to pass, but\n`s=\"- (3 - (- (4 + 5) ) )\"` is the **pain**.\nHere is the RPN \n`[3, 4, 5, '+', '-', '-', '-']`\nthe correct evaluation stands for `-6`, but `-12` is expecting.\nIs it an another way to solve this RPN propeply? \n**PS:** it was solved thx to one indian site.\n**Be sure** in case of unary minus to PREPEND the leading zero like\n`-2 + 1` => `0 - 2 + 1` "
                    },
                    {
                        "username": "subscriber6436",
                        "content": "[@ushnish](/ushnish)  yes, it is, after some minutes i fix this and came across after the prev. task:)"
                    },
                    {
                        "username": "ushnish",
                        "content": "So the answer to the expression above is -12 not -6, not sure how you\\u2019re getting that. And this question is different from RPN, there is a separate LC question for RPN"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "So exhausting to reconsider all the possibilities."
                    }
                ]
            },
            {
                "id": 1998615,
                "content": [
                    {
                        "username": "Sofiyan_M",
                        "content": "This question is based on the Application of Stack for Evaluation of infix Expression"
                    },
                    {
                        "username": "rikkiprince",
                        "content": "Annoyingly this was timing out on Run, even after I\\'d tried 2 approaches to optimise it... I tried Submitting it and it passed. It\\'s frustrating that the Run test is not representative of Submission."
                    },
                    {
                        "username": "Divyaporwal",
                        "content": "take care of the test case like this\\n\"1-(     -2)\""
                    },
                    {
                        "username": "PainKKKiller",
                        "content": "I\\'ve got trouble with this test. Figuring out how to parse (-2) as negative number"
                    },
                    {
                        "username": "YYANN",
                        "content": "why is this problem tagged as \\'hard\\'?"
                    },
                    {
                        "username": "ushnish",
                        "content": "[@YYANN](/YYANN) Could you share your code here? I find it hard to understand how you could answer this question in 15-20 minutes"
                    },
                    {
                        "username": "djslim",
                        "content": "mmh even top leetcoders consider this one as hard/annoying problem: https://www.youtube.com/watch?v=nZY6p5PbWss"
                    },
                    {
                        "username": "YYANN",
                        "content": "[@nirutgupta78](/nirutgupta78) i usually spend 2-3 hours on hard problems. i spent less than 20 minutes on this one. i solved it with just a series of if statements. i expect a little more depth from a \\'hard\\' question."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "well I feel it was a good question, like handling the negative number. [@YYANN](/YYANN)How much time have you spent on it?"
                    },
                    {
                        "username": "triyankk",
                        "content": " `class Solution:`\\n    `def calculate(self, s: str) -> int:`        \\n        `return eval(s) `\\nI\\'m able to solve most of the Testcases with this but some expressions are throwing too many parenthesis error. can anyone help with it?"
                    },
                    {
                        "username": "thisismrsanjay",
                        "content": "Beware it looks simple \\n s =\"2147483647\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "today I understood that even though + and - may have same priority, they should always be computed from left to right"
                    },
                    {
                        "username": "phanidharguttikonda",
                        "content": "1-(     -2) for this type of inputs the conversion of the postfix  and prefix is n bad idea i think\\n"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The testcases except the last is easy to pass, but\n`s=\"- (3 - (- (4 + 5) ) )\"` is the **pain**.\nHere is the RPN \n`[3, 4, 5, '+', '-', '-', '-']`\nthe correct evaluation stands for `-6`, but `-12` is expecting.\nIs it an another way to solve this RPN propeply? \n**PS:** it was solved thx to one indian site.\n**Be sure** in case of unary minus to PREPEND the leading zero like\n`-2 + 1` => `0 - 2 + 1` "
                    },
                    {
                        "username": "subscriber6436",
                        "content": "[@ushnish](/ushnish)  yes, it is, after some minutes i fix this and came across after the prev. task:)"
                    },
                    {
                        "username": "ushnish",
                        "content": "So the answer to the expression above is -12 not -6, not sure how you\\u2019re getting that. And this question is different from RPN, there is a separate LC question for RPN"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "So exhausting to reconsider all the possibilities."
                    }
                ]
            },
            {
                "id": 1927140,
                "content": [
                    {
                        "username": "nd4312",
                        "content": "With common sense, it makes sense that the input  `2(3 + 4)` is invalid particularly since multiplication and division operators are not valid operators, but shouldn\\'t this be explicit? e.g \"A number cannot follow an open parenthesis\"?"
                    },
                    {
                        "username": "mahesh105",
                        "content": "If you read question carefully, you do not need these constraints."
                    },
                    {
                        "username": "nguyenminhhoabinhthachhoa",
                        "content": "Does this problem involve  multiplication and division operations?"
                    },
                    {
                        "username": "ushnish",
                        "content": "No but basic calculator iii does"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "fun hint: always treat subtraction as if it were a unary operation, and then ignore all other non numerical, non bracket symbols.  treat everything like it\\'s addition. "
                    },
                    {
                        "username": "sibedir",
                        "content": "\"()\"\tExpected = 0\n\"()()\"\tInvalid expression\n\"()+()\"\tExpected = 0\n\nStrange behavior for sure )))\n\nIt appears that\n\"()\" is equivalent to \"0\"\nIt means that\n\"()()\" is equivalent to \"0 0\"\n\"()+()\" is equivalent to \"0+0\"\n\nOk"
                    },
                    {
                        "username": "destinygamer243",
                        "content": "`class Solution {\\npublic:\\n    int calculate(string s, int& i){\\n        int num = 0,tmp  = 0;\\n    \\n        while(isdigit(s[i])){\\n            tmp *=10;\\n            tmp += (s[i]-\\'0\\');\\n            i++;\\n        }\\n        num += tmp;\\n        while(i<s.size() && s[i]!=\\')\\'){\\n            cout<<i<<\" {\"<<s[i]<<\"} \"<<num<<\" || \"<<tmp<<endl;\\n            if(s[i]==\\'-\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num -= tmp;\\n            }else if(s[i]==\\'+\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num += tmp;\\n            }else if(s[i]==\\'(\\'){\\n                if(i==0 || s[i-1]==\\'+\\')num += calculate(s,++i);\\n                else num-=calculate(s,++i);\\n                i++;\\n            }\\n\\n        }\\n        cout<<num<<endl;\\n        return num;\\n    }\\n\\n    int calculate(string s) {\\n        string tmp = \"\";\\n        for(auto c: s)if(c!=\\' \\')tmp+=c; \\n        int i =0;\\n        return calculate(tmp,i);\\n    }\\n};`\\n\\n\\nNot sure why this is giving TLE for the big testcase. I see that answers using an STL stack are able to pass this. Can anyone please provide clarity? I am doing recursive calling instead."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "halllllllis",
                        "content": "My code works well in C++, basically taking the same approach in the calculator II solution and connect it with Calculator I. \\n\\nHowever, when I transfer my C++ code into Python3(The exact same code), it does not work. \\n\\nAny help would be greatly appreciated!\\n\\nBelow is my implementation in both C++ and Python \\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        if(s.empty())return 0;\\n        int idx = 0;\\n        const int sz = s.size();\\n        function<int()>eval = [&](){\\n            \\n            char op = \\'+\\';\\n            int val = 0,last=  0,res = 0;\\n            //cout<<\"start: \"<<idx<<\\' \\';\\n            while(idx<sz){\\n                //cout<<\"idx: \"<<idx<<\" val: \"<<val<<\" last: \"<<last<<\" res: \"<<res<<endl;\\n                char ch = s[idx];\\n                if(isdigit(ch)){\\n                    val = val*10+(ch-\\'0\\');\\n                }else if(ch==\\'(\\'){\\n                    idx++;\\n                    val = eval();\\n                }\\n                \\n                if((!isdigit(ch)&&!iswspace(ch))||idx==sz-1){\\n                    if(op==\\'+\\'||op==\\'-\\'){\\n                        res +=last;\\n                        last = (op==\\'+\\'?val:-val);\\n                    }else if(op==\\'/\\'){\\n                        last/=val;\\n\\n                    }else if(op==\\'*\\'){\\n                        last*=val;\\n                    }\\n                    if(ch==\\')\\'){\\n                        //idx++;\\n                        break;\\n                    }\\n                    op  =ch;\\n                    val = 0;\\n                }\\n                idx++;\\n            }\\n            return res+last;\\n        };\\n        return eval();\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        idx = 0\\n        sz = len(s)\\n        def eval():\\n            nonlocal sz\\n            nonlocal idx\\n            sum,last,curr = 0,0,0\\n            op = \\'+\\'\\n            while(idx<sz):\\n                ch = s[idx]\\n                if ch.isdigit():\\n                    curr = curr*10+(ord(ch)-ord(\\'0\\'))\\n                elif ch==\\'(\\':\\n                    idx+=1\\n                    curr = eval()\\n                if(not ch.isdigit() and not ch.isspace()) or (idx==sz-1):\\n                    if op==\\'+\\' or op==\\'-\\':\\n                        sum += last \\n                        last = curr if op==\\'+\\' else -curr\\n                    elif op==\\'/\\':\\n                        last//=curr\\n                        \\n                    elif op==\\'*\\':\\n                        last*=curr\\n                    elif op== \\')\\':\\n                    \\n                        break\\n                    op = ch\\n                    curr = 0\\n                idx+=1\\n            return sum+last\\n        return eval()\\n\\n```"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "Idk why my stdout gives correct anseer but output is undefijed reeeeeeeeeeee"
                    },
                    {
                        "username": "wild_knight",
                        "content": " `TIP`\\n1.convert the expression to a postfix expression \\n2.Evaluate the postfix expression\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1915816,
                "content": [
                    {
                        "username": "nd4312",
                        "content": "With common sense, it makes sense that the input  `2(3 + 4)` is invalid particularly since multiplication and division operators are not valid operators, but shouldn\\'t this be explicit? e.g \"A number cannot follow an open parenthesis\"?"
                    },
                    {
                        "username": "mahesh105",
                        "content": "If you read question carefully, you do not need these constraints."
                    },
                    {
                        "username": "nguyenminhhoabinhthachhoa",
                        "content": "Does this problem involve  multiplication and division operations?"
                    },
                    {
                        "username": "ushnish",
                        "content": "No but basic calculator iii does"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "fun hint: always treat subtraction as if it were a unary operation, and then ignore all other non numerical, non bracket symbols.  treat everything like it\\'s addition. "
                    },
                    {
                        "username": "sibedir",
                        "content": "\"()\"\tExpected = 0\n\"()()\"\tInvalid expression\n\"()+()\"\tExpected = 0\n\nStrange behavior for sure )))\n\nIt appears that\n\"()\" is equivalent to \"0\"\nIt means that\n\"()()\" is equivalent to \"0 0\"\n\"()+()\" is equivalent to \"0+0\"\n\nOk"
                    },
                    {
                        "username": "destinygamer243",
                        "content": "`class Solution {\\npublic:\\n    int calculate(string s, int& i){\\n        int num = 0,tmp  = 0;\\n    \\n        while(isdigit(s[i])){\\n            tmp *=10;\\n            tmp += (s[i]-\\'0\\');\\n            i++;\\n        }\\n        num += tmp;\\n        while(i<s.size() && s[i]!=\\')\\'){\\n            cout<<i<<\" {\"<<s[i]<<\"} \"<<num<<\" || \"<<tmp<<endl;\\n            if(s[i]==\\'-\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num -= tmp;\\n            }else if(s[i]==\\'+\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num += tmp;\\n            }else if(s[i]==\\'(\\'){\\n                if(i==0 || s[i-1]==\\'+\\')num += calculate(s,++i);\\n                else num-=calculate(s,++i);\\n                i++;\\n            }\\n\\n        }\\n        cout<<num<<endl;\\n        return num;\\n    }\\n\\n    int calculate(string s) {\\n        string tmp = \"\";\\n        for(auto c: s)if(c!=\\' \\')tmp+=c; \\n        int i =0;\\n        return calculate(tmp,i);\\n    }\\n};`\\n\\n\\nNot sure why this is giving TLE for the big testcase. I see that answers using an STL stack are able to pass this. Can anyone please provide clarity? I am doing recursive calling instead."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "halllllllis",
                        "content": "My code works well in C++, basically taking the same approach in the calculator II solution and connect it with Calculator I. \\n\\nHowever, when I transfer my C++ code into Python3(The exact same code), it does not work. \\n\\nAny help would be greatly appreciated!\\n\\nBelow is my implementation in both C++ and Python \\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        if(s.empty())return 0;\\n        int idx = 0;\\n        const int sz = s.size();\\n        function<int()>eval = [&](){\\n            \\n            char op = \\'+\\';\\n            int val = 0,last=  0,res = 0;\\n            //cout<<\"start: \"<<idx<<\\' \\';\\n            while(idx<sz){\\n                //cout<<\"idx: \"<<idx<<\" val: \"<<val<<\" last: \"<<last<<\" res: \"<<res<<endl;\\n                char ch = s[idx];\\n                if(isdigit(ch)){\\n                    val = val*10+(ch-\\'0\\');\\n                }else if(ch==\\'(\\'){\\n                    idx++;\\n                    val = eval();\\n                }\\n                \\n                if((!isdigit(ch)&&!iswspace(ch))||idx==sz-1){\\n                    if(op==\\'+\\'||op==\\'-\\'){\\n                        res +=last;\\n                        last = (op==\\'+\\'?val:-val);\\n                    }else if(op==\\'/\\'){\\n                        last/=val;\\n\\n                    }else if(op==\\'*\\'){\\n                        last*=val;\\n                    }\\n                    if(ch==\\')\\'){\\n                        //idx++;\\n                        break;\\n                    }\\n                    op  =ch;\\n                    val = 0;\\n                }\\n                idx++;\\n            }\\n            return res+last;\\n        };\\n        return eval();\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        idx = 0\\n        sz = len(s)\\n        def eval():\\n            nonlocal sz\\n            nonlocal idx\\n            sum,last,curr = 0,0,0\\n            op = \\'+\\'\\n            while(idx<sz):\\n                ch = s[idx]\\n                if ch.isdigit():\\n                    curr = curr*10+(ord(ch)-ord(\\'0\\'))\\n                elif ch==\\'(\\':\\n                    idx+=1\\n                    curr = eval()\\n                if(not ch.isdigit() and not ch.isspace()) or (idx==sz-1):\\n                    if op==\\'+\\' or op==\\'-\\':\\n                        sum += last \\n                        last = curr if op==\\'+\\' else -curr\\n                    elif op==\\'/\\':\\n                        last//=curr\\n                        \\n                    elif op==\\'*\\':\\n                        last*=curr\\n                    elif op== \\')\\':\\n                    \\n                        break\\n                    op = ch\\n                    curr = 0\\n                idx+=1\\n            return sum+last\\n        return eval()\\n\\n```"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "Idk why my stdout gives correct anseer but output is undefijed reeeeeeeeeeee"
                    },
                    {
                        "username": "wild_knight",
                        "content": " `TIP`\\n1.convert the expression to a postfix expression \\n2.Evaluate the postfix expression\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1900294,
                "content": [
                    {
                        "username": "nd4312",
                        "content": "With common sense, it makes sense that the input  `2(3 + 4)` is invalid particularly since multiplication and division operators are not valid operators, but shouldn\\'t this be explicit? e.g \"A number cannot follow an open parenthesis\"?"
                    },
                    {
                        "username": "mahesh105",
                        "content": "If you read question carefully, you do not need these constraints."
                    },
                    {
                        "username": "nguyenminhhoabinhthachhoa",
                        "content": "Does this problem involve  multiplication and division operations?"
                    },
                    {
                        "username": "ushnish",
                        "content": "No but basic calculator iii does"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "fun hint: always treat subtraction as if it were a unary operation, and then ignore all other non numerical, non bracket symbols.  treat everything like it\\'s addition. "
                    },
                    {
                        "username": "sibedir",
                        "content": "\"()\"\tExpected = 0\n\"()()\"\tInvalid expression\n\"()+()\"\tExpected = 0\n\nStrange behavior for sure )))\n\nIt appears that\n\"()\" is equivalent to \"0\"\nIt means that\n\"()()\" is equivalent to \"0 0\"\n\"()+()\" is equivalent to \"0+0\"\n\nOk"
                    },
                    {
                        "username": "destinygamer243",
                        "content": "`class Solution {\\npublic:\\n    int calculate(string s, int& i){\\n        int num = 0,tmp  = 0;\\n    \\n        while(isdigit(s[i])){\\n            tmp *=10;\\n            tmp += (s[i]-\\'0\\');\\n            i++;\\n        }\\n        num += tmp;\\n        while(i<s.size() && s[i]!=\\')\\'){\\n            cout<<i<<\" {\"<<s[i]<<\"} \"<<num<<\" || \"<<tmp<<endl;\\n            if(s[i]==\\'-\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num -= tmp;\\n            }else if(s[i]==\\'+\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num += tmp;\\n            }else if(s[i]==\\'(\\'){\\n                if(i==0 || s[i-1]==\\'+\\')num += calculate(s,++i);\\n                else num-=calculate(s,++i);\\n                i++;\\n            }\\n\\n        }\\n        cout<<num<<endl;\\n        return num;\\n    }\\n\\n    int calculate(string s) {\\n        string tmp = \"\";\\n        for(auto c: s)if(c!=\\' \\')tmp+=c; \\n        int i =0;\\n        return calculate(tmp,i);\\n    }\\n};`\\n\\n\\nNot sure why this is giving TLE for the big testcase. I see that answers using an STL stack are able to pass this. Can anyone please provide clarity? I am doing recursive calling instead."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "halllllllis",
                        "content": "My code works well in C++, basically taking the same approach in the calculator II solution and connect it with Calculator I. \\n\\nHowever, when I transfer my C++ code into Python3(The exact same code), it does not work. \\n\\nAny help would be greatly appreciated!\\n\\nBelow is my implementation in both C++ and Python \\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        if(s.empty())return 0;\\n        int idx = 0;\\n        const int sz = s.size();\\n        function<int()>eval = [&](){\\n            \\n            char op = \\'+\\';\\n            int val = 0,last=  0,res = 0;\\n            //cout<<\"start: \"<<idx<<\\' \\';\\n            while(idx<sz){\\n                //cout<<\"idx: \"<<idx<<\" val: \"<<val<<\" last: \"<<last<<\" res: \"<<res<<endl;\\n                char ch = s[idx];\\n                if(isdigit(ch)){\\n                    val = val*10+(ch-\\'0\\');\\n                }else if(ch==\\'(\\'){\\n                    idx++;\\n                    val = eval();\\n                }\\n                \\n                if((!isdigit(ch)&&!iswspace(ch))||idx==sz-1){\\n                    if(op==\\'+\\'||op==\\'-\\'){\\n                        res +=last;\\n                        last = (op==\\'+\\'?val:-val);\\n                    }else if(op==\\'/\\'){\\n                        last/=val;\\n\\n                    }else if(op==\\'*\\'){\\n                        last*=val;\\n                    }\\n                    if(ch==\\')\\'){\\n                        //idx++;\\n                        break;\\n                    }\\n                    op  =ch;\\n                    val = 0;\\n                }\\n                idx++;\\n            }\\n            return res+last;\\n        };\\n        return eval();\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        idx = 0\\n        sz = len(s)\\n        def eval():\\n            nonlocal sz\\n            nonlocal idx\\n            sum,last,curr = 0,0,0\\n            op = \\'+\\'\\n            while(idx<sz):\\n                ch = s[idx]\\n                if ch.isdigit():\\n                    curr = curr*10+(ord(ch)-ord(\\'0\\'))\\n                elif ch==\\'(\\':\\n                    idx+=1\\n                    curr = eval()\\n                if(not ch.isdigit() and not ch.isspace()) or (idx==sz-1):\\n                    if op==\\'+\\' or op==\\'-\\':\\n                        sum += last \\n                        last = curr if op==\\'+\\' else -curr\\n                    elif op==\\'/\\':\\n                        last//=curr\\n                        \\n                    elif op==\\'*\\':\\n                        last*=curr\\n                    elif op== \\')\\':\\n                    \\n                        break\\n                    op = ch\\n                    curr = 0\\n                idx+=1\\n            return sum+last\\n        return eval()\\n\\n```"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "Idk why my stdout gives correct anseer but output is undefijed reeeeeeeeeeee"
                    },
                    {
                        "username": "wild_knight",
                        "content": " `TIP`\\n1.convert the expression to a postfix expression \\n2.Evaluate the postfix expression\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1895892,
                "content": [
                    {
                        "username": "nd4312",
                        "content": "With common sense, it makes sense that the input  `2(3 + 4)` is invalid particularly since multiplication and division operators are not valid operators, but shouldn\\'t this be explicit? e.g \"A number cannot follow an open parenthesis\"?"
                    },
                    {
                        "username": "mahesh105",
                        "content": "If you read question carefully, you do not need these constraints."
                    },
                    {
                        "username": "nguyenminhhoabinhthachhoa",
                        "content": "Does this problem involve  multiplication and division operations?"
                    },
                    {
                        "username": "ushnish",
                        "content": "No but basic calculator iii does"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "fun hint: always treat subtraction as if it were a unary operation, and then ignore all other non numerical, non bracket symbols.  treat everything like it\\'s addition. "
                    },
                    {
                        "username": "sibedir",
                        "content": "\"()\"\tExpected = 0\n\"()()\"\tInvalid expression\n\"()+()\"\tExpected = 0\n\nStrange behavior for sure )))\n\nIt appears that\n\"()\" is equivalent to \"0\"\nIt means that\n\"()()\" is equivalent to \"0 0\"\n\"()+()\" is equivalent to \"0+0\"\n\nOk"
                    },
                    {
                        "username": "destinygamer243",
                        "content": "`class Solution {\\npublic:\\n    int calculate(string s, int& i){\\n        int num = 0,tmp  = 0;\\n    \\n        while(isdigit(s[i])){\\n            tmp *=10;\\n            tmp += (s[i]-\\'0\\');\\n            i++;\\n        }\\n        num += tmp;\\n        while(i<s.size() && s[i]!=\\')\\'){\\n            cout<<i<<\" {\"<<s[i]<<\"} \"<<num<<\" || \"<<tmp<<endl;\\n            if(s[i]==\\'-\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num -= tmp;\\n            }else if(s[i]==\\'+\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num += tmp;\\n            }else if(s[i]==\\'(\\'){\\n                if(i==0 || s[i-1]==\\'+\\')num += calculate(s,++i);\\n                else num-=calculate(s,++i);\\n                i++;\\n            }\\n\\n        }\\n        cout<<num<<endl;\\n        return num;\\n    }\\n\\n    int calculate(string s) {\\n        string tmp = \"\";\\n        for(auto c: s)if(c!=\\' \\')tmp+=c; \\n        int i =0;\\n        return calculate(tmp,i);\\n    }\\n};`\\n\\n\\nNot sure why this is giving TLE for the big testcase. I see that answers using an STL stack are able to pass this. Can anyone please provide clarity? I am doing recursive calling instead."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "halllllllis",
                        "content": "My code works well in C++, basically taking the same approach in the calculator II solution and connect it with Calculator I. \\n\\nHowever, when I transfer my C++ code into Python3(The exact same code), it does not work. \\n\\nAny help would be greatly appreciated!\\n\\nBelow is my implementation in both C++ and Python \\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        if(s.empty())return 0;\\n        int idx = 0;\\n        const int sz = s.size();\\n        function<int()>eval = [&](){\\n            \\n            char op = \\'+\\';\\n            int val = 0,last=  0,res = 0;\\n            //cout<<\"start: \"<<idx<<\\' \\';\\n            while(idx<sz){\\n                //cout<<\"idx: \"<<idx<<\" val: \"<<val<<\" last: \"<<last<<\" res: \"<<res<<endl;\\n                char ch = s[idx];\\n                if(isdigit(ch)){\\n                    val = val*10+(ch-\\'0\\');\\n                }else if(ch==\\'(\\'){\\n                    idx++;\\n                    val = eval();\\n                }\\n                \\n                if((!isdigit(ch)&&!iswspace(ch))||idx==sz-1){\\n                    if(op==\\'+\\'||op==\\'-\\'){\\n                        res +=last;\\n                        last = (op==\\'+\\'?val:-val);\\n                    }else if(op==\\'/\\'){\\n                        last/=val;\\n\\n                    }else if(op==\\'*\\'){\\n                        last*=val;\\n                    }\\n                    if(ch==\\')\\'){\\n                        //idx++;\\n                        break;\\n                    }\\n                    op  =ch;\\n                    val = 0;\\n                }\\n                idx++;\\n            }\\n            return res+last;\\n        };\\n        return eval();\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        idx = 0\\n        sz = len(s)\\n        def eval():\\n            nonlocal sz\\n            nonlocal idx\\n            sum,last,curr = 0,0,0\\n            op = \\'+\\'\\n            while(idx<sz):\\n                ch = s[idx]\\n                if ch.isdigit():\\n                    curr = curr*10+(ord(ch)-ord(\\'0\\'))\\n                elif ch==\\'(\\':\\n                    idx+=1\\n                    curr = eval()\\n                if(not ch.isdigit() and not ch.isspace()) or (idx==sz-1):\\n                    if op==\\'+\\' or op==\\'-\\':\\n                        sum += last \\n                        last = curr if op==\\'+\\' else -curr\\n                    elif op==\\'/\\':\\n                        last//=curr\\n                        \\n                    elif op==\\'*\\':\\n                        last*=curr\\n                    elif op== \\')\\':\\n                    \\n                        break\\n                    op = ch\\n                    curr = 0\\n                idx+=1\\n            return sum+last\\n        return eval()\\n\\n```"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "Idk why my stdout gives correct anseer but output is undefijed reeeeeeeeeeee"
                    },
                    {
                        "username": "wild_knight",
                        "content": " `TIP`\\n1.convert the expression to a postfix expression \\n2.Evaluate the postfix expression\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1746914,
                "content": [
                    {
                        "username": "nd4312",
                        "content": "With common sense, it makes sense that the input  `2(3 + 4)` is invalid particularly since multiplication and division operators are not valid operators, but shouldn\\'t this be explicit? e.g \"A number cannot follow an open parenthesis\"?"
                    },
                    {
                        "username": "mahesh105",
                        "content": "If you read question carefully, you do not need these constraints."
                    },
                    {
                        "username": "nguyenminhhoabinhthachhoa",
                        "content": "Does this problem involve  multiplication and division operations?"
                    },
                    {
                        "username": "ushnish",
                        "content": "No but basic calculator iii does"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "fun hint: always treat subtraction as if it were a unary operation, and then ignore all other non numerical, non bracket symbols.  treat everything like it\\'s addition. "
                    },
                    {
                        "username": "sibedir",
                        "content": "\"()\"\tExpected = 0\n\"()()\"\tInvalid expression\n\"()+()\"\tExpected = 0\n\nStrange behavior for sure )))\n\nIt appears that\n\"()\" is equivalent to \"0\"\nIt means that\n\"()()\" is equivalent to \"0 0\"\n\"()+()\" is equivalent to \"0+0\"\n\nOk"
                    },
                    {
                        "username": "destinygamer243",
                        "content": "`class Solution {\\npublic:\\n    int calculate(string s, int& i){\\n        int num = 0,tmp  = 0;\\n    \\n        while(isdigit(s[i])){\\n            tmp *=10;\\n            tmp += (s[i]-\\'0\\');\\n            i++;\\n        }\\n        num += tmp;\\n        while(i<s.size() && s[i]!=\\')\\'){\\n            cout<<i<<\" {\"<<s[i]<<\"} \"<<num<<\" || \"<<tmp<<endl;\\n            if(s[i]==\\'-\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num -= tmp;\\n            }else if(s[i]==\\'+\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num += tmp;\\n            }else if(s[i]==\\'(\\'){\\n                if(i==0 || s[i-1]==\\'+\\')num += calculate(s,++i);\\n                else num-=calculate(s,++i);\\n                i++;\\n            }\\n\\n        }\\n        cout<<num<<endl;\\n        return num;\\n    }\\n\\n    int calculate(string s) {\\n        string tmp = \"\";\\n        for(auto c: s)if(c!=\\' \\')tmp+=c; \\n        int i =0;\\n        return calculate(tmp,i);\\n    }\\n};`\\n\\n\\nNot sure why this is giving TLE for the big testcase. I see that answers using an STL stack are able to pass this. Can anyone please provide clarity? I am doing recursive calling instead."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "halllllllis",
                        "content": "My code works well in C++, basically taking the same approach in the calculator II solution and connect it with Calculator I. \\n\\nHowever, when I transfer my C++ code into Python3(The exact same code), it does not work. \\n\\nAny help would be greatly appreciated!\\n\\nBelow is my implementation in both C++ and Python \\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        if(s.empty())return 0;\\n        int idx = 0;\\n        const int sz = s.size();\\n        function<int()>eval = [&](){\\n            \\n            char op = \\'+\\';\\n            int val = 0,last=  0,res = 0;\\n            //cout<<\"start: \"<<idx<<\\' \\';\\n            while(idx<sz){\\n                //cout<<\"idx: \"<<idx<<\" val: \"<<val<<\" last: \"<<last<<\" res: \"<<res<<endl;\\n                char ch = s[idx];\\n                if(isdigit(ch)){\\n                    val = val*10+(ch-\\'0\\');\\n                }else if(ch==\\'(\\'){\\n                    idx++;\\n                    val = eval();\\n                }\\n                \\n                if((!isdigit(ch)&&!iswspace(ch))||idx==sz-1){\\n                    if(op==\\'+\\'||op==\\'-\\'){\\n                        res +=last;\\n                        last = (op==\\'+\\'?val:-val);\\n                    }else if(op==\\'/\\'){\\n                        last/=val;\\n\\n                    }else if(op==\\'*\\'){\\n                        last*=val;\\n                    }\\n                    if(ch==\\')\\'){\\n                        //idx++;\\n                        break;\\n                    }\\n                    op  =ch;\\n                    val = 0;\\n                }\\n                idx++;\\n            }\\n            return res+last;\\n        };\\n        return eval();\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        idx = 0\\n        sz = len(s)\\n        def eval():\\n            nonlocal sz\\n            nonlocal idx\\n            sum,last,curr = 0,0,0\\n            op = \\'+\\'\\n            while(idx<sz):\\n                ch = s[idx]\\n                if ch.isdigit():\\n                    curr = curr*10+(ord(ch)-ord(\\'0\\'))\\n                elif ch==\\'(\\':\\n                    idx+=1\\n                    curr = eval()\\n                if(not ch.isdigit() and not ch.isspace()) or (idx==sz-1):\\n                    if op==\\'+\\' or op==\\'-\\':\\n                        sum += last \\n                        last = curr if op==\\'+\\' else -curr\\n                    elif op==\\'/\\':\\n                        last//=curr\\n                        \\n                    elif op==\\'*\\':\\n                        last*=curr\\n                    elif op== \\')\\':\\n                    \\n                        break\\n                    op = ch\\n                    curr = 0\\n                idx+=1\\n            return sum+last\\n        return eval()\\n\\n```"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "Idk why my stdout gives correct anseer but output is undefijed reeeeeeeeeeee"
                    },
                    {
                        "username": "wild_knight",
                        "content": " `TIP`\\n1.convert the expression to a postfix expression \\n2.Evaluate the postfix expression\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1724080,
                "content": [
                    {
                        "username": "nd4312",
                        "content": "With common sense, it makes sense that the input  `2(3 + 4)` is invalid particularly since multiplication and division operators are not valid operators, but shouldn\\'t this be explicit? e.g \"A number cannot follow an open parenthesis\"?"
                    },
                    {
                        "username": "mahesh105",
                        "content": "If you read question carefully, you do not need these constraints."
                    },
                    {
                        "username": "nguyenminhhoabinhthachhoa",
                        "content": "Does this problem involve  multiplication and division operations?"
                    },
                    {
                        "username": "ushnish",
                        "content": "No but basic calculator iii does"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "fun hint: always treat subtraction as if it were a unary operation, and then ignore all other non numerical, non bracket symbols.  treat everything like it\\'s addition. "
                    },
                    {
                        "username": "sibedir",
                        "content": "\"()\"\tExpected = 0\n\"()()\"\tInvalid expression\n\"()+()\"\tExpected = 0\n\nStrange behavior for sure )))\n\nIt appears that\n\"()\" is equivalent to \"0\"\nIt means that\n\"()()\" is equivalent to \"0 0\"\n\"()+()\" is equivalent to \"0+0\"\n\nOk"
                    },
                    {
                        "username": "destinygamer243",
                        "content": "`class Solution {\\npublic:\\n    int calculate(string s, int& i){\\n        int num = 0,tmp  = 0;\\n    \\n        while(isdigit(s[i])){\\n            tmp *=10;\\n            tmp += (s[i]-\\'0\\');\\n            i++;\\n        }\\n        num += tmp;\\n        while(i<s.size() && s[i]!=\\')\\'){\\n            cout<<i<<\" {\"<<s[i]<<\"} \"<<num<<\" || \"<<tmp<<endl;\\n            if(s[i]==\\'-\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num -= tmp;\\n            }else if(s[i]==\\'+\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num += tmp;\\n            }else if(s[i]==\\'(\\'){\\n                if(i==0 || s[i-1]==\\'+\\')num += calculate(s,++i);\\n                else num-=calculate(s,++i);\\n                i++;\\n            }\\n\\n        }\\n        cout<<num<<endl;\\n        return num;\\n    }\\n\\n    int calculate(string s) {\\n        string tmp = \"\";\\n        for(auto c: s)if(c!=\\' \\')tmp+=c; \\n        int i =0;\\n        return calculate(tmp,i);\\n    }\\n};`\\n\\n\\nNot sure why this is giving TLE for the big testcase. I see that answers using an STL stack are able to pass this. Can anyone please provide clarity? I am doing recursive calling instead."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "halllllllis",
                        "content": "My code works well in C++, basically taking the same approach in the calculator II solution and connect it with Calculator I. \\n\\nHowever, when I transfer my C++ code into Python3(The exact same code), it does not work. \\n\\nAny help would be greatly appreciated!\\n\\nBelow is my implementation in both C++ and Python \\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        if(s.empty())return 0;\\n        int idx = 0;\\n        const int sz = s.size();\\n        function<int()>eval = [&](){\\n            \\n            char op = \\'+\\';\\n            int val = 0,last=  0,res = 0;\\n            //cout<<\"start: \"<<idx<<\\' \\';\\n            while(idx<sz){\\n                //cout<<\"idx: \"<<idx<<\" val: \"<<val<<\" last: \"<<last<<\" res: \"<<res<<endl;\\n                char ch = s[idx];\\n                if(isdigit(ch)){\\n                    val = val*10+(ch-\\'0\\');\\n                }else if(ch==\\'(\\'){\\n                    idx++;\\n                    val = eval();\\n                }\\n                \\n                if((!isdigit(ch)&&!iswspace(ch))||idx==sz-1){\\n                    if(op==\\'+\\'||op==\\'-\\'){\\n                        res +=last;\\n                        last = (op==\\'+\\'?val:-val);\\n                    }else if(op==\\'/\\'){\\n                        last/=val;\\n\\n                    }else if(op==\\'*\\'){\\n                        last*=val;\\n                    }\\n                    if(ch==\\')\\'){\\n                        //idx++;\\n                        break;\\n                    }\\n                    op  =ch;\\n                    val = 0;\\n                }\\n                idx++;\\n            }\\n            return res+last;\\n        };\\n        return eval();\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        idx = 0\\n        sz = len(s)\\n        def eval():\\n            nonlocal sz\\n            nonlocal idx\\n            sum,last,curr = 0,0,0\\n            op = \\'+\\'\\n            while(idx<sz):\\n                ch = s[idx]\\n                if ch.isdigit():\\n                    curr = curr*10+(ord(ch)-ord(\\'0\\'))\\n                elif ch==\\'(\\':\\n                    idx+=1\\n                    curr = eval()\\n                if(not ch.isdigit() and not ch.isspace()) or (idx==sz-1):\\n                    if op==\\'+\\' or op==\\'-\\':\\n                        sum += last \\n                        last = curr if op==\\'+\\' else -curr\\n                    elif op==\\'/\\':\\n                        last//=curr\\n                        \\n                    elif op==\\'*\\':\\n                        last*=curr\\n                    elif op== \\')\\':\\n                    \\n                        break\\n                    op = ch\\n                    curr = 0\\n                idx+=1\\n            return sum+last\\n        return eval()\\n\\n```"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "Idk why my stdout gives correct anseer but output is undefijed reeeeeeeeeeee"
                    },
                    {
                        "username": "wild_knight",
                        "content": " `TIP`\\n1.convert the expression to a postfix expression \\n2.Evaluate the postfix expression\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1715878,
                "content": [
                    {
                        "username": "nd4312",
                        "content": "With common sense, it makes sense that the input  `2(3 + 4)` is invalid particularly since multiplication and division operators are not valid operators, but shouldn\\'t this be explicit? e.g \"A number cannot follow an open parenthesis\"?"
                    },
                    {
                        "username": "mahesh105",
                        "content": "If you read question carefully, you do not need these constraints."
                    },
                    {
                        "username": "nguyenminhhoabinhthachhoa",
                        "content": "Does this problem involve  multiplication and division operations?"
                    },
                    {
                        "username": "ushnish",
                        "content": "No but basic calculator iii does"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "fun hint: always treat subtraction as if it were a unary operation, and then ignore all other non numerical, non bracket symbols.  treat everything like it\\'s addition. "
                    },
                    {
                        "username": "sibedir",
                        "content": "\"()\"\tExpected = 0\n\"()()\"\tInvalid expression\n\"()+()\"\tExpected = 0\n\nStrange behavior for sure )))\n\nIt appears that\n\"()\" is equivalent to \"0\"\nIt means that\n\"()()\" is equivalent to \"0 0\"\n\"()+()\" is equivalent to \"0+0\"\n\nOk"
                    },
                    {
                        "username": "destinygamer243",
                        "content": "`class Solution {\\npublic:\\n    int calculate(string s, int& i){\\n        int num = 0,tmp  = 0;\\n    \\n        while(isdigit(s[i])){\\n            tmp *=10;\\n            tmp += (s[i]-\\'0\\');\\n            i++;\\n        }\\n        num += tmp;\\n        while(i<s.size() && s[i]!=\\')\\'){\\n            cout<<i<<\" {\"<<s[i]<<\"} \"<<num<<\" || \"<<tmp<<endl;\\n            if(s[i]==\\'-\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num -= tmp;\\n            }else if(s[i]==\\'+\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num += tmp;\\n            }else if(s[i]==\\'(\\'){\\n                if(i==0 || s[i-1]==\\'+\\')num += calculate(s,++i);\\n                else num-=calculate(s,++i);\\n                i++;\\n            }\\n\\n        }\\n        cout<<num<<endl;\\n        return num;\\n    }\\n\\n    int calculate(string s) {\\n        string tmp = \"\";\\n        for(auto c: s)if(c!=\\' \\')tmp+=c; \\n        int i =0;\\n        return calculate(tmp,i);\\n    }\\n};`\\n\\n\\nNot sure why this is giving TLE for the big testcase. I see that answers using an STL stack are able to pass this. Can anyone please provide clarity? I am doing recursive calling instead."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "halllllllis",
                        "content": "My code works well in C++, basically taking the same approach in the calculator II solution and connect it with Calculator I. \\n\\nHowever, when I transfer my C++ code into Python3(The exact same code), it does not work. \\n\\nAny help would be greatly appreciated!\\n\\nBelow is my implementation in both C++ and Python \\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        if(s.empty())return 0;\\n        int idx = 0;\\n        const int sz = s.size();\\n        function<int()>eval = [&](){\\n            \\n            char op = \\'+\\';\\n            int val = 0,last=  0,res = 0;\\n            //cout<<\"start: \"<<idx<<\\' \\';\\n            while(idx<sz){\\n                //cout<<\"idx: \"<<idx<<\" val: \"<<val<<\" last: \"<<last<<\" res: \"<<res<<endl;\\n                char ch = s[idx];\\n                if(isdigit(ch)){\\n                    val = val*10+(ch-\\'0\\');\\n                }else if(ch==\\'(\\'){\\n                    idx++;\\n                    val = eval();\\n                }\\n                \\n                if((!isdigit(ch)&&!iswspace(ch))||idx==sz-1){\\n                    if(op==\\'+\\'||op==\\'-\\'){\\n                        res +=last;\\n                        last = (op==\\'+\\'?val:-val);\\n                    }else if(op==\\'/\\'){\\n                        last/=val;\\n\\n                    }else if(op==\\'*\\'){\\n                        last*=val;\\n                    }\\n                    if(ch==\\')\\'){\\n                        //idx++;\\n                        break;\\n                    }\\n                    op  =ch;\\n                    val = 0;\\n                }\\n                idx++;\\n            }\\n            return res+last;\\n        };\\n        return eval();\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        idx = 0\\n        sz = len(s)\\n        def eval():\\n            nonlocal sz\\n            nonlocal idx\\n            sum,last,curr = 0,0,0\\n            op = \\'+\\'\\n            while(idx<sz):\\n                ch = s[idx]\\n                if ch.isdigit():\\n                    curr = curr*10+(ord(ch)-ord(\\'0\\'))\\n                elif ch==\\'(\\':\\n                    idx+=1\\n                    curr = eval()\\n                if(not ch.isdigit() and not ch.isspace()) or (idx==sz-1):\\n                    if op==\\'+\\' or op==\\'-\\':\\n                        sum += last \\n                        last = curr if op==\\'+\\' else -curr\\n                    elif op==\\'/\\':\\n                        last//=curr\\n                        \\n                    elif op==\\'*\\':\\n                        last*=curr\\n                    elif op== \\')\\':\\n                    \\n                        break\\n                    op = ch\\n                    curr = 0\\n                idx+=1\\n            return sum+last\\n        return eval()\\n\\n```"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "Idk why my stdout gives correct anseer but output is undefijed reeeeeeeeeeee"
                    },
                    {
                        "username": "wild_knight",
                        "content": " `TIP`\\n1.convert the expression to a postfix expression \\n2.Evaluate the postfix expression\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1691052,
                "content": [
                    {
                        "username": "nd4312",
                        "content": "With common sense, it makes sense that the input  `2(3 + 4)` is invalid particularly since multiplication and division operators are not valid operators, but shouldn\\'t this be explicit? e.g \"A number cannot follow an open parenthesis\"?"
                    },
                    {
                        "username": "mahesh105",
                        "content": "If you read question carefully, you do not need these constraints."
                    },
                    {
                        "username": "nguyenminhhoabinhthachhoa",
                        "content": "Does this problem involve  multiplication and division operations?"
                    },
                    {
                        "username": "ushnish",
                        "content": "No but basic calculator iii does"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "fun hint: always treat subtraction as if it were a unary operation, and then ignore all other non numerical, non bracket symbols.  treat everything like it\\'s addition. "
                    },
                    {
                        "username": "sibedir",
                        "content": "\"()\"\tExpected = 0\n\"()()\"\tInvalid expression\n\"()+()\"\tExpected = 0\n\nStrange behavior for sure )))\n\nIt appears that\n\"()\" is equivalent to \"0\"\nIt means that\n\"()()\" is equivalent to \"0 0\"\n\"()+()\" is equivalent to \"0+0\"\n\nOk"
                    },
                    {
                        "username": "destinygamer243",
                        "content": "`class Solution {\\npublic:\\n    int calculate(string s, int& i){\\n        int num = 0,tmp  = 0;\\n    \\n        while(isdigit(s[i])){\\n            tmp *=10;\\n            tmp += (s[i]-\\'0\\');\\n            i++;\\n        }\\n        num += tmp;\\n        while(i<s.size() && s[i]!=\\')\\'){\\n            cout<<i<<\" {\"<<s[i]<<\"} \"<<num<<\" || \"<<tmp<<endl;\\n            if(s[i]==\\'-\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num -= tmp;\\n            }else if(s[i]==\\'+\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num += tmp;\\n            }else if(s[i]==\\'(\\'){\\n                if(i==0 || s[i-1]==\\'+\\')num += calculate(s,++i);\\n                else num-=calculate(s,++i);\\n                i++;\\n            }\\n\\n        }\\n        cout<<num<<endl;\\n        return num;\\n    }\\n\\n    int calculate(string s) {\\n        string tmp = \"\";\\n        for(auto c: s)if(c!=\\' \\')tmp+=c; \\n        int i =0;\\n        return calculate(tmp,i);\\n    }\\n};`\\n\\n\\nNot sure why this is giving TLE for the big testcase. I see that answers using an STL stack are able to pass this. Can anyone please provide clarity? I am doing recursive calling instead."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "halllllllis",
                        "content": "My code works well in C++, basically taking the same approach in the calculator II solution and connect it with Calculator I. \\n\\nHowever, when I transfer my C++ code into Python3(The exact same code), it does not work. \\n\\nAny help would be greatly appreciated!\\n\\nBelow is my implementation in both C++ and Python \\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        if(s.empty())return 0;\\n        int idx = 0;\\n        const int sz = s.size();\\n        function<int()>eval = [&](){\\n            \\n            char op = \\'+\\';\\n            int val = 0,last=  0,res = 0;\\n            //cout<<\"start: \"<<idx<<\\' \\';\\n            while(idx<sz){\\n                //cout<<\"idx: \"<<idx<<\" val: \"<<val<<\" last: \"<<last<<\" res: \"<<res<<endl;\\n                char ch = s[idx];\\n                if(isdigit(ch)){\\n                    val = val*10+(ch-\\'0\\');\\n                }else if(ch==\\'(\\'){\\n                    idx++;\\n                    val = eval();\\n                }\\n                \\n                if((!isdigit(ch)&&!iswspace(ch))||idx==sz-1){\\n                    if(op==\\'+\\'||op==\\'-\\'){\\n                        res +=last;\\n                        last = (op==\\'+\\'?val:-val);\\n                    }else if(op==\\'/\\'){\\n                        last/=val;\\n\\n                    }else if(op==\\'*\\'){\\n                        last*=val;\\n                    }\\n                    if(ch==\\')\\'){\\n                        //idx++;\\n                        break;\\n                    }\\n                    op  =ch;\\n                    val = 0;\\n                }\\n                idx++;\\n            }\\n            return res+last;\\n        };\\n        return eval();\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        idx = 0\\n        sz = len(s)\\n        def eval():\\n            nonlocal sz\\n            nonlocal idx\\n            sum,last,curr = 0,0,0\\n            op = \\'+\\'\\n            while(idx<sz):\\n                ch = s[idx]\\n                if ch.isdigit():\\n                    curr = curr*10+(ord(ch)-ord(\\'0\\'))\\n                elif ch==\\'(\\':\\n                    idx+=1\\n                    curr = eval()\\n                if(not ch.isdigit() and not ch.isspace()) or (idx==sz-1):\\n                    if op==\\'+\\' or op==\\'-\\':\\n                        sum += last \\n                        last = curr if op==\\'+\\' else -curr\\n                    elif op==\\'/\\':\\n                        last//=curr\\n                        \\n                    elif op==\\'*\\':\\n                        last*=curr\\n                    elif op== \\')\\':\\n                    \\n                        break\\n                    op = ch\\n                    curr = 0\\n                idx+=1\\n            return sum+last\\n        return eval()\\n\\n```"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "Idk why my stdout gives correct anseer but output is undefijed reeeeeeeeeeee"
                    },
                    {
                        "username": "wild_knight",
                        "content": " `TIP`\\n1.convert the expression to a postfix expression \\n2.Evaluate the postfix expression\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1690786,
                "content": [
                    {
                        "username": "nd4312",
                        "content": "With common sense, it makes sense that the input  `2(3 + 4)` is invalid particularly since multiplication and division operators are not valid operators, but shouldn\\'t this be explicit? e.g \"A number cannot follow an open parenthesis\"?"
                    },
                    {
                        "username": "mahesh105",
                        "content": "If you read question carefully, you do not need these constraints."
                    },
                    {
                        "username": "nguyenminhhoabinhthachhoa",
                        "content": "Does this problem involve  multiplication and division operations?"
                    },
                    {
                        "username": "ushnish",
                        "content": "No but basic calculator iii does"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "fun hint: always treat subtraction as if it were a unary operation, and then ignore all other non numerical, non bracket symbols.  treat everything like it\\'s addition. "
                    },
                    {
                        "username": "sibedir",
                        "content": "\"()\"\tExpected = 0\n\"()()\"\tInvalid expression\n\"()+()\"\tExpected = 0\n\nStrange behavior for sure )))\n\nIt appears that\n\"()\" is equivalent to \"0\"\nIt means that\n\"()()\" is equivalent to \"0 0\"\n\"()+()\" is equivalent to \"0+0\"\n\nOk"
                    },
                    {
                        "username": "destinygamer243",
                        "content": "`class Solution {\\npublic:\\n    int calculate(string s, int& i){\\n        int num = 0,tmp  = 0;\\n    \\n        while(isdigit(s[i])){\\n            tmp *=10;\\n            tmp += (s[i]-\\'0\\');\\n            i++;\\n        }\\n        num += tmp;\\n        while(i<s.size() && s[i]!=\\')\\'){\\n            cout<<i<<\" {\"<<s[i]<<\"} \"<<num<<\" || \"<<tmp<<endl;\\n            if(s[i]==\\'-\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num -= tmp;\\n            }else if(s[i]==\\'+\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num += tmp;\\n            }else if(s[i]==\\'(\\'){\\n                if(i==0 || s[i-1]==\\'+\\')num += calculate(s,++i);\\n                else num-=calculate(s,++i);\\n                i++;\\n            }\\n\\n        }\\n        cout<<num<<endl;\\n        return num;\\n    }\\n\\n    int calculate(string s) {\\n        string tmp = \"\";\\n        for(auto c: s)if(c!=\\' \\')tmp+=c; \\n        int i =0;\\n        return calculate(tmp,i);\\n    }\\n};`\\n\\n\\nNot sure why this is giving TLE for the big testcase. I see that answers using an STL stack are able to pass this. Can anyone please provide clarity? I am doing recursive calling instead."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "halllllllis",
                        "content": "My code works well in C++, basically taking the same approach in the calculator II solution and connect it with Calculator I. \\n\\nHowever, when I transfer my C++ code into Python3(The exact same code), it does not work. \\n\\nAny help would be greatly appreciated!\\n\\nBelow is my implementation in both C++ and Python \\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        if(s.empty())return 0;\\n        int idx = 0;\\n        const int sz = s.size();\\n        function<int()>eval = [&](){\\n            \\n            char op = \\'+\\';\\n            int val = 0,last=  0,res = 0;\\n            //cout<<\"start: \"<<idx<<\\' \\';\\n            while(idx<sz){\\n                //cout<<\"idx: \"<<idx<<\" val: \"<<val<<\" last: \"<<last<<\" res: \"<<res<<endl;\\n                char ch = s[idx];\\n                if(isdigit(ch)){\\n                    val = val*10+(ch-\\'0\\');\\n                }else if(ch==\\'(\\'){\\n                    idx++;\\n                    val = eval();\\n                }\\n                \\n                if((!isdigit(ch)&&!iswspace(ch))||idx==sz-1){\\n                    if(op==\\'+\\'||op==\\'-\\'){\\n                        res +=last;\\n                        last = (op==\\'+\\'?val:-val);\\n                    }else if(op==\\'/\\'){\\n                        last/=val;\\n\\n                    }else if(op==\\'*\\'){\\n                        last*=val;\\n                    }\\n                    if(ch==\\')\\'){\\n                        //idx++;\\n                        break;\\n                    }\\n                    op  =ch;\\n                    val = 0;\\n                }\\n                idx++;\\n            }\\n            return res+last;\\n        };\\n        return eval();\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        idx = 0\\n        sz = len(s)\\n        def eval():\\n            nonlocal sz\\n            nonlocal idx\\n            sum,last,curr = 0,0,0\\n            op = \\'+\\'\\n            while(idx<sz):\\n                ch = s[idx]\\n                if ch.isdigit():\\n                    curr = curr*10+(ord(ch)-ord(\\'0\\'))\\n                elif ch==\\'(\\':\\n                    idx+=1\\n                    curr = eval()\\n                if(not ch.isdigit() and not ch.isspace()) or (idx==sz-1):\\n                    if op==\\'+\\' or op==\\'-\\':\\n                        sum += last \\n                        last = curr if op==\\'+\\' else -curr\\n                    elif op==\\'/\\':\\n                        last//=curr\\n                        \\n                    elif op==\\'*\\':\\n                        last*=curr\\n                    elif op== \\')\\':\\n                    \\n                        break\\n                    op = ch\\n                    curr = 0\\n                idx+=1\\n            return sum+last\\n        return eval()\\n\\n```"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "Idk why my stdout gives correct anseer but output is undefijed reeeeeeeeeeee"
                    },
                    {
                        "username": "wild_knight",
                        "content": " `TIP`\\n1.convert the expression to a postfix expression \\n2.Evaluate the postfix expression\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1764218,
                "content": [
                    {
                        "username": "nd4312",
                        "content": "With common sense, it makes sense that the input  `2(3 + 4)` is invalid particularly since multiplication and division operators are not valid operators, but shouldn\\'t this be explicit? e.g \"A number cannot follow an open parenthesis\"?"
                    },
                    {
                        "username": "mahesh105",
                        "content": "If you read question carefully, you do not need these constraints."
                    },
                    {
                        "username": "nguyenminhhoabinhthachhoa",
                        "content": "Does this problem involve  multiplication and division operations?"
                    },
                    {
                        "username": "ushnish",
                        "content": "No but basic calculator iii does"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "fun hint: always treat subtraction as if it were a unary operation, and then ignore all other non numerical, non bracket symbols.  treat everything like it\\'s addition. "
                    },
                    {
                        "username": "sibedir",
                        "content": "\"()\"\tExpected = 0\n\"()()\"\tInvalid expression\n\"()+()\"\tExpected = 0\n\nStrange behavior for sure )))\n\nIt appears that\n\"()\" is equivalent to \"0\"\nIt means that\n\"()()\" is equivalent to \"0 0\"\n\"()+()\" is equivalent to \"0+0\"\n\nOk"
                    },
                    {
                        "username": "destinygamer243",
                        "content": "`class Solution {\\npublic:\\n    int calculate(string s, int& i){\\n        int num = 0,tmp  = 0;\\n    \\n        while(isdigit(s[i])){\\n            tmp *=10;\\n            tmp += (s[i]-\\'0\\');\\n            i++;\\n        }\\n        num += tmp;\\n        while(i<s.size() && s[i]!=\\')\\'){\\n            cout<<i<<\" {\"<<s[i]<<\"} \"<<num<<\" || \"<<tmp<<endl;\\n            if(s[i]==\\'-\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num -= tmp;\\n            }else if(s[i]==\\'+\\'){\\n                tmp = 0;\\n                i++;\\n                while(isdigit(s[i])){\\n                    tmp *=10;\\n                    tmp += (s[i]-\\'0\\');\\n                    i++;\\n                }\\n                num += tmp;\\n            }else if(s[i]==\\'(\\'){\\n                if(i==0 || s[i-1]==\\'+\\')num += calculate(s,++i);\\n                else num-=calculate(s,++i);\\n                i++;\\n            }\\n\\n        }\\n        cout<<num<<endl;\\n        return num;\\n    }\\n\\n    int calculate(string s) {\\n        string tmp = \"\";\\n        for(auto c: s)if(c!=\\' \\')tmp+=c; \\n        int i =0;\\n        return calculate(tmp,i);\\n    }\\n};`\\n\\n\\nNot sure why this is giving TLE for the big testcase. I see that answers using an STL stack are able to pass this. Can anyone please provide clarity? I am doing recursive calling instead."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "halllllllis",
                        "content": "My code works well in C++, basically taking the same approach in the calculator II solution and connect it with Calculator I. \\n\\nHowever, when I transfer my C++ code into Python3(The exact same code), it does not work. \\n\\nAny help would be greatly appreciated!\\n\\nBelow is my implementation in both C++ and Python \\n\\n```\\nclass Solution {\\npublic:\\n    int calculate(string s) {\\n        if(s.empty())return 0;\\n        int idx = 0;\\n        const int sz = s.size();\\n        function<int()>eval = [&](){\\n            \\n            char op = \\'+\\';\\n            int val = 0,last=  0,res = 0;\\n            //cout<<\"start: \"<<idx<<\\' \\';\\n            while(idx<sz){\\n                //cout<<\"idx: \"<<idx<<\" val: \"<<val<<\" last: \"<<last<<\" res: \"<<res<<endl;\\n                char ch = s[idx];\\n                if(isdigit(ch)){\\n                    val = val*10+(ch-\\'0\\');\\n                }else if(ch==\\'(\\'){\\n                    idx++;\\n                    val = eval();\\n                }\\n                \\n                if((!isdigit(ch)&&!iswspace(ch))||idx==sz-1){\\n                    if(op==\\'+\\'||op==\\'-\\'){\\n                        res +=last;\\n                        last = (op==\\'+\\'?val:-val);\\n                    }else if(op==\\'/\\'){\\n                        last/=val;\\n\\n                    }else if(op==\\'*\\'){\\n                        last*=val;\\n                    }\\n                    if(ch==\\')\\'){\\n                        //idx++;\\n                        break;\\n                    }\\n                    op  =ch;\\n                    val = 0;\\n                }\\n                idx++;\\n            }\\n            return res+last;\\n        };\\n        return eval();\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        idx = 0\\n        sz = len(s)\\n        def eval():\\n            nonlocal sz\\n            nonlocal idx\\n            sum,last,curr = 0,0,0\\n            op = \\'+\\'\\n            while(idx<sz):\\n                ch = s[idx]\\n                if ch.isdigit():\\n                    curr = curr*10+(ord(ch)-ord(\\'0\\'))\\n                elif ch==\\'(\\':\\n                    idx+=1\\n                    curr = eval()\\n                if(not ch.isdigit() and not ch.isspace()) or (idx==sz-1):\\n                    if op==\\'+\\' or op==\\'-\\':\\n                        sum += last \\n                        last = curr if op==\\'+\\' else -curr\\n                    elif op==\\'/\\':\\n                        last//=curr\\n                        \\n                    elif op==\\'*\\':\\n                        last*=curr\\n                    elif op== \\')\\':\\n                    \\n                        break\\n                    op = ch\\n                    curr = 0\\n                idx+=1\\n            return sum+last\\n        return eval()\\n\\n```"
                    },
                    {
                        "username": "SupaSibs",
                        "content": "Idk why my stdout gives correct anseer but output is undefijed reeeeeeeeeeee"
                    },
                    {
                        "username": "wild_knight",
                        "content": " `TIP`\\n1.convert the expression to a postfix expression \\n2.Evaluate the postfix expression\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n\\n    public int evaluateExpr(Stack<Object> stack) {\\n        \\n        if (stack.empty() || !(stack.peek() instanceof Integer)) {\\n            stack.push(0);\\n        }\\n\\n        int res = (int) stack.pop();\\n\\n        while (!stack.empty() && !((char) stack.peek() == \\')\\')) {\\n\\n            char sign = (char) stack.pop();\\n\\n            if (sign == \\'+\\') {\\n                res += (int) stack.pop();\\n            } else {\\n                res -= (int) stack.pop();\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int calculate(String s) {\\n\\n        int operand = 0;\\n        int n = 0;\\n        Stack<Object> stack = new Stack<Object>();\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n\\n            char ch = s.charAt(i);\\n\\n            if (Character.isDigit(ch)) {\\n\\n                \\n                operand = (int) Math.pow(10, n) * (int) (ch - \\'0\\') + operand;\\n                n += 1;\\n\\n            } else if (ch != \\' \\') {\\n                if (n != 0) {\\n\\n                    stack.push(operand);\\n                    n = 0;\\n                    operand = 0;\\n\\n                }\\n                if (ch == \\'(\\') {\\n\\n                    int res = evaluateExpr(stack);\\n                    stack.pop();\\n\\n                    stack.push(res);\\n\\n                } else {\\n\\n                    stack.push(ch);\\n                }\\n            }\\n        }\\n\\n        if (n != 0) {\\n            stack.push(operand);\\n        }\\n\\n        return evaluateExpr(stack);\\n    }\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            }
        ]
    }
]