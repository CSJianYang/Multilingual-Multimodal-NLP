[
    {
        "title": "Check Completeness of a Binary Tree",
        "question_content": "Given the root of a binary tree, determine if it is a complete binary tree.\nIn a complete binary tree, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.\n&nbsp;\nExample 1:\n\nInput: root = [1,2,3,4,5,6]\nOutput: true\nExplanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.\n\nExample 2:\n\nInput: root = [1,2,3,4,5,null,7]\nOutput: false\nExplanation: The node with value 7 isn't as far left as possible.\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [1, 100].\n\t1 <= Node.val <= 1000",
        "solutions": [
            {
                "id": 205682,
                "title": "java-c-python-bfs-solution-and-dfs-soluiton",
                "content": "# **Solution 1, BFS**\\nUse BFS to do a level order traversal,\\nadd childrens to the bfs queue,\\nuntil we met the first empty node.\\n\\nFor a complete binary tree,\\nthere should not be any node after we met an empty one.\\n\\nTime `O(N)`, Space `O(N)`\\n\\n**Java:**\\n```java\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> bfs = new LinkedList<TreeNode>();\\n        bfs.offer(root);\\n        while (bfs.peek() != null) {\\n            TreeNode node = bfs.poll();\\n            bfs.offer(node.left);\\n            bfs.offer(node.right);\\n        }\\n        while (!bfs.isEmpty() && bfs.peek() == null)\\n            bfs.poll();\\n        return bfs.isEmpty();\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    bool isCompleteTree(TreeNode* root) {\\n        vector<TreeNode*> bfs;\\n        bfs.push_back(root);\\n        int i = 0;\\n        while (i < bfs.size() && bfs[i]) {\\n            bfs.push_back(bfs[i]->left);\\n            bfs.push_back(bfs[i]->right);\\n            i++;\\n        }\\n        while (i < bfs.size() && !bfs[i])\\n            i++;\\n        return i == bfs.size();\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def isCompleteTree(self, root):\\n        bfs = [root]\\n        i = 0\\n        while bfs[i]:\\n            bfs.append(bfs[i].left)\\n            bfs.append(bfs[i].right)\\n            i += 1\\n        return not any(bfs[i:])\\n```\\n<br>\\n\\nAlso you may want to return earlier.\\nWe can stop the first while loop when met the first null child.\\nFrom then on there should not be any more child.\\nThis optimisation help reduce half of operations.\\n\\n**Java**\\n```java\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> bfs = new LinkedList<TreeNode>();\\n        bfs.offer(root);\\n        while (true) {\\n            TreeNode node = bfs.poll();\\n            if (node.left == null) {\\n                if (node.right != null)\\n                    return false;\\n                break;\\n            }\\n            bfs.offer(node.left);\\n            if (node.right == null) break;\\n            bfs.offer(node.right);\\n        }\\n        while (!bfs.isEmpty()) {\\n            TreeNode node = bfs.poll();\\n            if (node.left != null || node.right != null)\\n                return false;\\n        }\\n        return true;\\n    }\\n```\\n\\n<br><br>\\n\\n# **Solution 2, DFS**\\nLooking back to this problem, my first inituition is actually a dfs\\nif `root` is a complete tree , \\n`dfs(root)` return the count of nodes in a tree,\\notherwise it will return `-1`\\n\\nIf a tree is a complete FULL tree,\\nit must have 1,3,7,15,31..nodes,\\nwhich is pow of 2 minus 1.\\nAnd for x = 2^k -1, x has a property that `x & (x+1) == 0`.\\n\\nFor a complete tree, it must satify at least one of the following condition:\\nif left subtree is a full tree with `l` nodes,\\nright subtree must have `r` nodes that  `l / 2 <= r <= l`\\nif right subtree is a full tree with `r` nodes,\\nleft subtree must have `l` nodes that  `r <= l <= r * 2 + 1`.\\n\\nTime `O(N)`, Space `O(height)`\\n\\n**Java**\\n```java\\n    public boolean isCompleteTree(TreeNode root) {\\n        return dfs(root) >= 0;\\n    }\\n    \\n    public int dfs(TreeNode root) {\\n        if (root == null) return 0;\\n        int l = dfs(root.left), r = dfs(root.right);\\n        if ((l & (l + 1)) == 0 && l / 2 <= r && r <= l)\\n            return l + r + 1;\\n        if ((r & (r + 1)) == 0 && r <= l && l <= r * 2 + 1)\\n            return l + r + 1;\\n        return -1 ;\\n    }\\n```\\n**Python**\\n```py\\n    def isCompleteTree(self, root):\\n        def dfs(root):\\n            if not root: return 0\\n            l, r = dfs(root.left), dfs(root.right)\\n            if l & (l + 1) == 0 and l / 2 <= r <= l:\\n                return l + r + 1\\n            if r & (r + 1) == 0 and r <= l <= r * 2 + 1:\\n                return l + r + 1\\n            return -1\\n        return dfs(root) > 0\\n```\\n\\n",
                "solutionTags": [],
                "code": "```java\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> bfs = new LinkedList<TreeNode>();\\n        bfs.offer(root);\\n        while (bfs.peek() != null) {\\n            TreeNode node = bfs.poll();\\n            bfs.offer(node.left);\\n            bfs.offer(node.right);\\n        }\\n        while (!bfs.isEmpty() && bfs.peek() == null)\\n            bfs.poll();\\n        return bfs.isEmpty();\\n    }\\n```\n```cpp\\n    bool isCompleteTree(TreeNode* root) {\\n        vector<TreeNode*> bfs;\\n        bfs.push_back(root);\\n        int i = 0;\\n        while (i < bfs.size() && bfs[i]) {\\n            bfs.push_back(bfs[i]->left);\\n            bfs.push_back(bfs[i]->right);\\n            i++;\\n        }\\n        while (i < bfs.size() && !bfs[i])\\n            i++;\\n        return i == bfs.size();\\n    }\\n```\n```py\\n    def isCompleteTree(self, root):\\n        bfs = [root]\\n        i = 0\\n        while bfs[i]:\\n            bfs.append(bfs[i].left)\\n            bfs.append(bfs[i].right)\\n            i += 1\\n        return not any(bfs[i:])\\n```\n```java\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> bfs = new LinkedList<TreeNode>();\\n        bfs.offer(root);\\n        while (true) {\\n            TreeNode node = bfs.poll();\\n            if (node.left == null) {\\n                if (node.right != null)\\n                    return false;\\n                break;\\n            }\\n            bfs.offer(node.left);\\n            if (node.right == null) break;\\n            bfs.offer(node.right);\\n        }\\n        while (!bfs.isEmpty()) {\\n            TreeNode node = bfs.poll();\\n            if (node.left != null || node.right != null)\\n                return false;\\n        }\\n        return true;\\n    }\\n```\n```java\\n    public boolean isCompleteTree(TreeNode root) {\\n        return dfs(root) >= 0;\\n    }\\n    \\n    public int dfs(TreeNode root) {\\n        if (root == null) return 0;\\n        int l = dfs(root.left), r = dfs(root.right);\\n        if ((l & (l + 1)) == 0 && l / 2 <= r && r <= l)\\n            return l + r + 1;\\n        if ((r & (r + 1)) == 0 && r <= l && l <= r * 2 + 1)\\n            return l + r + 1;\\n        return -1 ;\\n    }\\n```\n```py\\n    def isCompleteTree(self, root):\\n        def dfs(root):\\n            if not root: return 0\\n            l, r = dfs(root.left), dfs(root.right)\\n            if l & (l + 1) == 0 and l / 2 <= r <= l:\\n                return l + r + 1\\n            if r & (r + 1) == 0 and r <= l <= r * 2 + 1:\\n                return l + r + 1\\n            return -1\\n        return dfs(root) > 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 205768,
                "title": "java-easy-level-order-traversal-one-while-loop",
                "content": "When level-order traversal in a complete tree, after the last node, all nodes in the queue should be null. \\nOtherwise, the tree is not complete.\\n```\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean end = false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(!queue.isEmpty()) {\\n            TreeNode cur = queue.poll();\\n            if(cur == null) end = true;\\n            else{\\n                if(end) return false;\\n                queue.add(cur.left);\\n                queue.add(cur.right);\\n            }\\n        }\\n        return true;\\n    }\\n```\\nTime Complexity: O(N), where N is the number of nodes.\\nSpace Complexity: O(N)",
                "solutionTags": [],
                "code": "```\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean end = false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(!queue.isEmpty()) {\\n            TreeNode cur = queue.poll();\\n            if(cur == null) end = true;\\n            else{\\n                if(end) return false;\\n                queue.add(cur.left);\\n                queue.add(cur.right);\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3298346,
                "title": "clean-codes-full-explanation-b-f-s-c-java-python3",
                "content": "# Intuition :\\n- Given the root of a binary tree, determine if it is a complete binary tree.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Breadth First Search\\n- Traverse the tree in `level-order` using a queue. At each level, we add the left and right child nodes of each node to the queue. \\n- If we encounter a `null` node, we still add it to the queue so that we can check if there are any more nodes left in the next step. \\n- Once we have traversed the entire tree, we check if there are any remaining nodes in the queue. \\n- If there are, it means the tree is not complete, and we return `false`. \\n- Otherwise, the tree is complete, and we return `true`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity :\\n- Time complexity : O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n# Codes [C++ |Java |Python3] : With Comments\\n```Java []\\n// Define the Solution class\\nclass Solution {\\n  \\n  // Define the isCompleteTree function that takes a TreeNode as input and returns a boolean\\n  public boolean isCompleteTree(TreeNode root) {\\n    // Check if the root node is null, if so, return true (an empty tree is complete)\\n    if (root == null)\\n      return true;\\n\\n    // Create a queue to store the nodes of the tree in level order\\n    Queue<TreeNode> q = new LinkedList<>(Arrays.asList(root));\\n\\n    // Traverse the tree in level order\\n    while (q.peek() != null) {\\n      // Remove the first node from the queue\\n      TreeNode node = q.poll();\\n      // Add the left and right child nodes of the current node to the queue\\n      q.offer(node.left);\\n      q.offer(node.right);\\n    }\\n\\n    // Remove any remaining null nodes from the end of the queue\\n    while (!q.isEmpty() && q.peek() == null)\\n      q.poll();\\n\\n    // Check if there are any remaining nodes in the queue\\n    // If so, the tree is not complete, so return false\\n    // Otherwise, the tree is complete, so return true\\n    return q.isEmpty();\\n  }\\n}\\n\\n```\\n```C++ []\\n// Define the Solution class\\nclass Solution {\\npublic:\\n    // Define the isCompleteTree function that takes a TreeNode pointer as input and returns a boolean\\n    bool isCompleteTree(TreeNode* root) {\\n        // Check if the root node is null, if so, return true (an empty tree is complete)\\n        if (root == nullptr)\\n            return true;\\n\\n        // Create a queue to store the nodes of the tree in level order\\n        queue<TreeNode*> q{{root}};\\n\\n        // Traverse the tree in level order\\n        while (q.front() != nullptr) {\\n            // Remove the first node from the queue\\n            TreeNode* node = q.front();\\n            q.pop();\\n            // Add the left and right child nodes of the current node to the queue\\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n\\n        // Remove any remaining null nodes from the front of the queue\\n        while (!q.empty() && q.front() == nullptr)\\n            q.pop();\\n\\n        // Check if there are any remaining nodes in the queue\\n        // If so, the tree is not complete, so return false\\n        // Otherwise, the tree is complete, so return true\\n        return q.empty();\\n    }\\n};\\n\\n```\\n```Python []\\nfrom collections import deque\\n\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        # Check if the root node is None, if so, return True (an empty tree is complete)\\n        if not root:\\n            return True\\n\\n        # Create a deque to store the nodes of the tree in level order\\n        q = deque([root])\\n\\n        # Traverse the tree in level order\\n        while q[0] is not None:\\n            # Remove the first node from the deque\\n            node = q.popleft()\\n            # Add the left and right child nodes of the current node to the deque\\n            q.append(node.left)\\n            q.append(node.right)\\n\\n        # Remove any remaining None nodes from the beginning of the deque\\n        while q and q[0] is None:\\n            q.popleft()\\n\\n        # Check if there are any remaining nodes in the deque\\n        # If so, the tree is not complete, so return False\\n        # Otherwise, the tree is complete, so return True\\n        return not bool(q)\\n\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/b1973ae0-07a2-4280-b4dc-3ffc7493f3c3_1678845601.0422919.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```Java []\\n// Define the Solution class\\nclass Solution {\\n  \\n  // Define the isCompleteTree function that takes a TreeNode as input and returns a boolean\\n  public boolean isCompleteTree(TreeNode root) {\\n    // Check if the root node is null, if so, return true (an empty tree is complete)\\n    if (root == null)\\n      return true;\\n\\n    // Create a queue to store the nodes of the tree in level order\\n    Queue<TreeNode> q = new LinkedList<>(Arrays.asList(root));\\n\\n    // Traverse the tree in level order\\n    while (q.peek() != null) {\\n      // Remove the first node from the queue\\n      TreeNode node = q.poll();\\n      // Add the left and right child nodes of the current node to the queue\\n      q.offer(node.left);\\n      q.offer(node.right);\\n    }\\n\\n    // Remove any remaining null nodes from the end of the queue\\n    while (!q.isEmpty() && q.peek() == null)\\n      q.poll();\\n\\n    // Check if there are any remaining nodes in the queue\\n    // If so, the tree is not complete, so return false\\n    // Otherwise, the tree is complete, so return true\\n    return q.isEmpty();\\n  }\\n}\\n\\n```\n```C++ []\\n// Define the Solution class\\nclass Solution {\\npublic:\\n    // Define the isCompleteTree function that takes a TreeNode pointer as input and returns a boolean\\n    bool isCompleteTree(TreeNode* root) {\\n        // Check if the root node is null, if so, return true (an empty tree is complete)\\n        if (root == nullptr)\\n            return true;\\n\\n        // Create a queue to store the nodes of the tree in level order\\n        queue<TreeNode*> q{{root}};\\n\\n        // Traverse the tree in level order\\n        while (q.front() != nullptr) {\\n            // Remove the first node from the queue\\n            TreeNode* node = q.front();\\n            q.pop();\\n            // Add the left and right child nodes of the current node to the queue\\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n\\n        // Remove any remaining null nodes from the front of the queue\\n        while (!q.empty() && q.front() == nullptr)\\n            q.pop();\\n\\n        // Check if there are any remaining nodes in the queue\\n        // If so, the tree is not complete, so return false\\n        // Otherwise, the tree is complete, so return true\\n        return q.empty();\\n    }\\n};\\n\\n```\n```Python []\\nfrom collections import deque\\n\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        # Check if the root node is None, if so, return True (an empty tree is complete)\\n        if not root:\\n            return True\\n\\n        # Create a deque to store the nodes of the tree in level order\\n        q = deque([root])\\n\\n        # Traverse the tree in level order\\n        while q[0] is not None:\\n            # Remove the first node from the deque\\n            node = q.popleft()\\n            # Add the left and right child nodes of the current node to the deque\\n            q.append(node.left)\\n            q.append(node.right)\\n\\n        # Remove any remaining None nodes from the beginning of the deque\\n        while q and q[0] is None:\\n            q.popleft()\\n\\n        # Check if there are any remaining nodes in the deque\\n        # If so, the tree is not complete, so return False\\n        # Otherwise, the tree is complete, so return True\\n        return not bool(q)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 206810,
                "title": "c-bfs",
                "content": "```\\nbool isCompleteTree(TreeNode* root) {\\n        bool pre = true;\\n        queue<TreeNode*> nq;\\n        nq.push(root);\\n        \\n        while(!nq.empty()){\\n            TreeNode* node = nq.front();\\n            nq.pop();\\n            \\n            if(node == NULL){\\n                pre = false;\\n            }\\n            else{\\n                if(pre == false)\\n                    return false;\\n                \\n                nq.push(node->left);\\n                nq.push(node->right);\\n            }\\n            \\n        }\\n        \\n        return true;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nbool isCompleteTree(TreeNode* root) {\\n        bool pre = true;\\n        queue<TreeNode*> nq;\\n        nq.push(root);\\n        \\n        while(!nq.empty()){\\n            TreeNode* node = nq.front();\\n            nq.pop();\\n            \\n            if(node == NULL){\\n                pre = false;\\n            }\\n            else{\\n                if(pre == false)\\n                    return false;\\n                \\n                nq.push(node->left);\\n                nq.push(node->right);\\n            }\\n            \\n        }\\n        \\n        return true;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 398169,
                "title": "python-11-lines-use-the-fact-that-level-order-traversal-array-is-val-val-null-null",
                "content": "The level-order traversal array of a complete binary tree will never have a null node in between non-null nodes. If we encounter a null node, all the following nodes should also be null, otherwise it\\'s not complete. \\n\\n```\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        have_null = False\\n        Q = [root]\\n        \\n        while Q:\\n            cur_node = Q.pop(0)\\n            if not cur_node: \\n                have_null = True\\n                continue\\n            if have_null: return False\\n            Q.append(cur_node.left)\\n            Q.append(cur_node.right)\\n            \\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        have_null = False\\n        Q = [root]\\n        \\n        while Q:\\n            cur_node = Q.pop(0)\\n            if not cur_node: \\n                have_null = True\\n                continue\\n            if have_null: return False\\n            Q.append(cur_node.left)\\n            Q.append(cur_node.right)\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533798,
                "title": "python-js-java-go-c-o-n-by-level-order-traversal-w-diagram",
                "content": "O(n) by level-order traversal.\\n\\n---\\n\\n**Hint**:\\n\\nComplete binary tree is a leftward compact tree.\\n\\nLaunch **level-order-traersal** (or **BFS** if we see binary tree as a *single source graph on root* )\\n\\nIf there is an **empty node** (i.e. **None**) somewhere **in the middle** before last node,\\nthen it is Not a *[complete binary tree](https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees)*, thus return False.\\n\\nOtherwise, it is complete and return True.\\n\\n---\\n\\n**Diagram** and **abstract model**:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1583721519.png)\\n\\n\\n---\\n**Implementation**:\\n\\nPython:\\n\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        \\n        \\n        traversal_queue = deque( [ root ] )\\n        prev_node = root\\n        \\n        \\n        # Launch Level-order traversal\\n        \\n        while traversal_queue:\\n            \\n            cur_node = traversal_queue.popleft()\\n            \\n            if cur_node:\\n                \\n                if not prev_node:\\n                    # Empty node in the middle means this is not a complete binary tree ( not left-compact)\\n                    return False\\n                \\n                traversal_queue.append( cur_node.left )\\n                traversal_queue.append( cur_node.right )\\n            \\n            # update previous node\\n            prev_node = cur_node\\n            \\n        return True\\n```\\n\\n---\\n\\nJava:\\n\\n```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        \\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.offer( root );\\n        \\n        TreeNode prevNode = root;\\n        \\n        // Launch level-order traversal\\n        while( queue.size() > 0 ){\\n            \\n            TreeNode curNode = queue.poll();\\n            \\n            if( curNode != null ){\\n                \\n                if( prevNode == null ){\\n                    // Empty node in the middle means this is not a complete binary tree ( not left-compact)\\n                    return false;\\n                }\\n                \\n                queue.offer( curNode.left );\\n                queue.offer( curNode.right );\\n            }\\n            // udpate previous node\\n            prevNode = curNode;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n---\\n\\n\\nJavascript:\\n\\n```\\nvar isCompleteTree = function(root) {\\n    \\n    // Initialization\\n    let traversal_queue = [root];\\n    let prevNode = root;\\n    \\n    // Launch level-order traversal\\n    while( traversal_queue.length ){\\n        \\n        let curNode = traversal_queue.shift();\\n        \\n        if( curNode != null )\\n        {\\n            if( prevNode == null ){\\n                // Empty in the middle means this is not a complete binary tree (not left-compact)\\n                return false;\\n            }    \\n            \\n            traversal_queue.push( curNode.left );\\n            traversal_queue.push( curNode.right );\\n        }\\n        \\n        // update previous node\\n        prevNode = curNode;\\n    }\\n    \\n    return true;\\n};\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nimport (\\n    \"container/list\"\\n)\\n\\nfunc isCompleteTree(root *TreeNode) bool {\\n    \\n    // Initialization\\n    traversalQ := list.New()\\n    traversalQ.PushBack( root )\\n    \\n    prevNode := root\\n    \\n    // Launch level-order traversal\\n    for traversalQ.Len() != 0 {\\n        \\n        queueHead := traversalQ.Front();\\n        traversalQ.Remove( queueHead )\\n        \\n        curNode := queueHead.Value.(*TreeNode)\\n        \\n        if( curNode != nil ){\\n            \\n            if( prevNode == nil){\\n                // Empty in the middle means this is not a complete binary tree (not left-compact)\\n                return false;\\n            }\\n            \\n            traversalQ.PushBack( curNode.Left )\\n            traversalQ.PushBack( curNode.Right )\\n        }\\n        \\n        // update previous node\\n        prevNode = curNode\\n    }\\n    \\n    return true;\\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        \\n        std::queue< TreeNode* > traversalQ;\\n        traversalQ.push( root );\\n        TreeNode* prevNode = root;\\n        \\n        // Launch level-order traversal\\n        while( traversalQ.size() ){\\n            \\n            TreeNode* curNode = traversalQ.front();\\n            traversalQ.pop();\\n            \\n            if( curNode != nullptr ){\\n                \\n                if( prevNode == nullptr ){\\n                    // Empty in the middle means this is not a complete binary tree (not left-compact)\\n                    return false;\\n                }\\n                \\n                traversalQ.push( curNode->left );\\n                traversalQ.push( curNode->right );\\n            }\\n            \\n            // update previous node\\n            prevNode = curNode;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #102 Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)\\n\\n[Leetcode #107 Binary Tree Level Order Traversal II](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/)\\n\\n[Leetcode #222 Count Complete Tree Nodes](https://leetcode.com/problems/count-complete-tree-nodes/)\\n\\n---\\n\\nReference:\\n\\n[1] [Wiki: Complete binary tree](https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees)\\n\\n[2] [GfG: Complete binary tree](https://bit.ly/3aFrrYQ)",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        \\n        \\n        traversal_queue = deque( [ root ] )\\n        prev_node = root\\n        \\n        \\n        # Launch Level-order traversal\\n        \\n        while traversal_queue:\\n            \\n            cur_node = traversal_queue.popleft()\\n            \\n            if cur_node:\\n                \\n                if not prev_node:\\n                    # Empty node in the middle means this is not a complete binary tree ( not left-compact)\\n                    return False\\n                \\n                traversal_queue.append( cur_node.left )\\n                traversal_queue.append( cur_node.right )\\n            \\n            # update previous node\\n            prev_node = cur_node\\n            \\n        return True\\n```\n```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        \\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.offer( root );\\n        \\n        TreeNode prevNode = root;\\n        \\n        // Launch level-order traversal\\n        while( queue.size() > 0 ){\\n            \\n            TreeNode curNode = queue.poll();\\n            \\n            if( curNode != null ){\\n                \\n                if( prevNode == null ){\\n                    // Empty node in the middle means this is not a complete binary tree ( not left-compact)\\n                    return false;\\n                }\\n                \\n                queue.offer( curNode.left );\\n                queue.offer( curNode.right );\\n            }\\n            // udpate previous node\\n            prevNode = curNode;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nvar isCompleteTree = function(root) {\\n    \\n    // Initialization\\n    let traversal_queue = [root];\\n    let prevNode = root;\\n    \\n    // Launch level-order traversal\\n    while( traversal_queue.length ){\\n        \\n        let curNode = traversal_queue.shift();\\n        \\n        if( curNode != null )\\n        {\\n            if( prevNode == null ){\\n                // Empty in the middle means this is not a complete binary tree (not left-compact)\\n                return false;\\n            }    \\n            \\n            traversal_queue.push( curNode.left );\\n            traversal_queue.push( curNode.right );\\n        }\\n        \\n        // update previous node\\n        prevNode = curNode;\\n    }\\n    \\n    return true;\\n};\\n```\n```\\nimport (\\n    \"container/list\"\\n)\\n\\nfunc isCompleteTree(root *TreeNode) bool {\\n    \\n    // Initialization\\n    traversalQ := list.New()\\n    traversalQ.PushBack( root )\\n    \\n    prevNode := root\\n    \\n    // Launch level-order traversal\\n    for traversalQ.Len() != 0 {\\n        \\n        queueHead := traversalQ.Front();\\n        traversalQ.Remove( queueHead )\\n        \\n        curNode := queueHead.Value.(*TreeNode)\\n        \\n        if( curNode != nil ){\\n            \\n            if( prevNode == nil){\\n                // Empty in the middle means this is not a complete binary tree (not left-compact)\\n                return false;\\n            }\\n            \\n            traversalQ.PushBack( curNode.Left )\\n            traversalQ.PushBack( curNode.Right )\\n        }\\n        \\n        // update previous node\\n        prevNode = curNode\\n    }\\n    \\n    return true;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        \\n        std::queue< TreeNode* > traversalQ;\\n        traversalQ.push( root );\\n        TreeNode* prevNode = root;\\n        \\n        // Launch level-order traversal\\n        while( traversalQ.size() ){\\n            \\n            TreeNode* curNode = traversalQ.front();\\n            traversalQ.pop();\\n            \\n            if( curNode != nullptr ){\\n                \\n                if( prevNode == nullptr ){\\n                    // Empty in the middle means this is not a complete binary tree (not left-compact)\\n                    return false;\\n                }\\n                \\n                traversalQ.push( curNode->left );\\n                traversalQ.push( curNode->right );\\n            }\\n            \\n            // update previous node\\n            prevNode = curNode;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 242287,
                "title": "python-solution",
                "content": "DFS. Time complexity: `O(n)`, space complexity: `O(h)`.\\n\\n```\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        # number of nodes, right_most_coords\\n        def dfs(root, coord):\\n            if not root:\\n                return 0, 0\\n            l = dfs(root.left, 2*coord)\\n            r = dfs(root.right, 2*coord+1)\\n            tot = l[0]+r[0]+1\\n            right_most = max(coord, l[1], r[1])\\n            return tot, right_most\\n        if not root:\\n            return True\\n        tot, right_most = dfs(root, 1)\\n        return tot == right_most\\n```\\n\\nBFS. Time complexity: `O(n)`, space complexity: `O(n)`.\\n\\n```\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return True\\n        q = collections.deque([(root, 1)])\\n        res = []\\n        while q:\\n            u, coord = q.popleft()\\n            res.append(coord)\\n            if u.left:\\n                q.append((u.left, 2*coord))\\n            if u.right:\\n                q.append((u.right, 2*coord+1))\\n        return len(res) == res[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        # number of nodes, right_most_coords\\n        def dfs(root, coord):\\n            if not root:\\n                return 0, 0\\n            l = dfs(root.left, 2*coord)\\n            r = dfs(root.right, 2*coord+1)\\n            tot = l[0]+r[0]+1\\n            right_most = max(coord, l[1], r[1])\\n            return tot, right_most\\n        if not root:\\n            return True\\n        tot, right_most = dfs(root, 1)\\n        return tot == right_most\\n```\n```\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return True\\n        q = collections.deque([(root, 1)])\\n        res = []\\n        while q:\\n            u, coord = q.popleft()\\n            res.append(coord)\\n            if u.left:\\n                q.append((u.left, 2*coord))\\n            if u.right:\\n                q.append((u.right, 2*coord+1))\\n        return len(res) == res[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 205699,
                "title": "c-java-track-leftmost-height",
                "content": "We traverse the tree and track the current height `h`. The very first leaf is the leftmost node, so its height sets `target_height`. \\n\\nFor remaining leaves, the height should be the same as `target_height`. Since the last level may not be filled, our height can become `target_height - 1`. In that case, we set `last_level_filled` to `1`, and check that the height of remaining leaves equals `target_height - last_level_filled`.\\n\\n**C++**\\n```\\nint target_height = 0, last_level_filled = false;\\nbool isCompleteTree(TreeNode* r, int h = 0) {\\n  if (r == nullptr) {\\n    if (target_height == 0) {\\n        target_height = h;\\n    } else if (h == target_height - 1) {\\n        last_level_filled = true;\\n    }\\n    return h == target_height - last_level_filled;\\n  }\\n  return isCompleteTree(r->left, h + 1) && isCompleteTree(r->right, h + 1);\\n}\\n```\\n**Java**\\n```\\nprivate int target_height = 0, last_level_filled = 0;\\nprivate boolean dfs(TreeNode r, int h) {\\n    if (r == null) {\\n        if (target_height == 0) {\\n            target_height = h;\\n        } else if (h == target_height - 1) {\\n            last_level_filled = 1;\\n        }\\n        return h == target_height - last_level_filled;\\n    }\\n    return dfs(r.left, h + 1) && dfs(r.right, h + 1);\\n}\\npublic boolean isCompleteTree(TreeNode root) {\\n    return dfs(root, 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint target_height = 0, last_level_filled = false;\\nbool isCompleteTree(TreeNode* r, int h = 0) {\\n  if (r == nullptr) {\\n    if (target_height == 0) {\\n        target_height = h;\\n    } else if (h == target_height - 1) {\\n        last_level_filled = true;\\n    }\\n    return h == target_height - last_level_filled;\\n  }\\n  return isCompleteTree(r->left, h + 1) && isCompleteTree(r->right, h + 1);\\n}\\n```\n```\\nprivate int target_height = 0, last_level_filled = 0;\\nprivate boolean dfs(TreeNode r, int h) {\\n    if (r == null) {\\n        if (target_height == 0) {\\n            target_height = h;\\n        } else if (h == target_height - 1) {\\n            last_level_filled = 1;\\n        }\\n        return h == target_height - last_level_filled;\\n    }\\n    return dfs(r.left, h + 1) && dfs(r.right, h + 1);\\n}\\npublic boolean isCompleteTree(TreeNode root) {\\n    return dfs(root, 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3298689,
                "title": "c-bfs-90-beat-intution-approach",
                "content": "# Intuition\\npoints by points\\n\\n-> We need to traverse and check either there is any case where our tree become uncomplete or we can say false to our answer.\\n\\n-> If our a level is completely fill then we not to thing over it , by observing we are getting intution to travel it by level order. for level order traversal we have to use **queue**.\\n\\n-> From above discussion , we conclude to use level order traversal and look for each level seperately.\\n\\n-> **As much as left possible** means if there is any node exist in  last level it should be in left not in right.\\n\\n-> Now , let\\'s go for Approach.\\n\\n# Approach\\n-> From above\\n\\n-> If we find any node NULL then should not be any node after that , if there exist any node after a NULL node then it will not be our compelete tree and we can return false.\\n\\n-> we need to Check do i previously find any NULL node if yes and also getting another node apart from null then return false other wise return true after complete ittiration.\\n\\n-> Next you may understand by code directly.\\n\\nif you read it let me know by commenting or doing VOTE UP !!\\n\\nif you read it just Vote it UP!!\\n\\n# Complexity\\n- Time complexity:\\no(n) , need to check for all nodes.\\n\\n- Space complexity:\\nO(W)\\n\\n# Code C++\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int i=0,f=0;\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            if(f && node != NULL) return false;\\n            if(node== NULL){\\n                f=1;\\n                continue;\\n            }\\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        return true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int i=0,f=0;\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            if(f && node != NULL) return false;\\n            if(node== NULL){\\n                f=1;\\n                continue;\\n            }\\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296050,
                "title": "python-simple-dfs-using-recursion",
                "content": "```\\nclass Solution(object):\\n    node_count = 0\\n    max_position = 0\\n\\n    def isCompleteTree(self, root):\\n        self.isCompleteTreeHelper(root, 1)\\n        return self.max_position == self.node_count\\n\\n    def isCompleteTreeHelper(self, root, position):\\n        if root is None:\\n            return\\n        self.node_count += 1\\n        self.max_position = max(self.max_position, position)\\n        self.isCompleteTreeHelper(root.left, 2 * position)\\n        self.isCompleteTreeHelper(root.right, 2 * position + 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    node_count = 0\\n    max_position = 0\\n\\n    def isCompleteTree(self, root):\\n        self.isCompleteTreeHelper(root, 1)\\n        return self.max_position == self.node_count\\n\\n    def isCompleteTreeHelper(self, root, position):\\n        if root is None:\\n            return\\n        self.node_count += 1\\n        self.max_position = max(self.max_position, position)\\n        self.isCompleteTreeHelper(root.left, 2 * position)\\n        self.isCompleteTreeHelper(root.right, 2 * position + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910868,
                "title": "bfs-level-order-traversal-c",
                "content": "BFS : Level Order Traversal. C++\\n```\\n//please upvote, if you like my approach.\\n//pre-request : basic knowledge of level order traversal.\\n//we traverse the tree level wise, whenever we encounter a null value we keep track of that. \\n//if our first null is last value in binary tree, then our tree is complete binary tree. else not complete binary tree.\\nbool isCompleteTree(TreeNode* root) {\\n        bool value = false;\\n        if(root==NULL)\\n            return true;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        while(q.size()>0)\\n        {\\n            TreeNode *p = q.front();\\n            q.pop();\\n            if(p==NULL)\\n            {\\n                value=true;\\n            }\\n            else\\n            {\\n                if(value)\\n                    return false;\\n                q.push(p->left);\\n                q.push(p->right);\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n//please upvote, if you like my approach.\\n//pre-request : basic knowledge of level order traversal.\\n//we traverse the tree level wise, whenever we encounter a null value we keep track of that. \\n//if our first null is last value in binary tree, then our tree is complete binary tree. else not complete binary tree.\\nbool isCompleteTree(TreeNode* root) {\\n        bool value = false;\\n        if(root==NULL)\\n            return true;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        while(q.size()>0)\\n        {\\n            TreeNode *p = q.front();\\n            q.pop();\\n            if(p==NULL)\\n            {\\n                value=true;\\n            }\\n            else\\n            {\\n                if(value)\\n                    return false;\\n                q.push(p->left);\\n                q.push(p->right);\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 205675,
                "title": "easy-recursive-solution-java",
                "content": "```\\n   public boolean isCompleteTree(TreeNode root) {\\n        return isCompleteTree(root,0,countNodes(root));\\n    }\\n    private boolean isCompleteTree(TreeNode root, int i, int n) { \\n        if (root == null)  return true; \\n        else if (i >= n) return false; \\n        return isCompleteTree(root.left, 2 * i + 1, n) && isCompleteTree(root.right, 2 * i + 2, n); \\n    } \\n     private  int countNodes(TreeNode root) { \\n        if (root == null) return 0; \\n        return 1 + countNodes(root.left) + countNodes(root.right); \\n    } \\n\\t",
                "solutionTags": [],
                "code": "```\\n   public boolean isCompleteTree(TreeNode root) {\\n        return isCompleteTree(root,0,countNodes(root));\\n    }\\n    private boolean isCompleteTree(TreeNode root, int i, int n) { \\n        if (root == null)  return true; \\n        else if (i >= n) return false; \\n        return isCompleteTree(root.left, 2 * i + 1, n) && isCompleteTree(root.right, 2 * i + 2, n); \\n    } \\n     private  int countNodes(TreeNode root) { \\n        if (root == null) return 0; \\n        return 1 + countNodes(root.left) + countNodes(root.right); \\n    } \\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 3298408,
                "title": "day-74-bfs-o-n-time-and-o-n-space-easiest-beginner-friendly-solution",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\n*The idea is to do a level order traversal of the binary tree using a queue. As we traverse each level, we keep track of whether we have encountered any null nodes in between non-null nodes. If we encounter a null node after encountering a non-null node, we set a flag isNullInBetweenNodes to true. If we encounter another non-null node after encountering a null node, then the tree is not complete, and we can return false. If we successfully complete the traversal of the entire tree without returning false, then the tree is complete, and we can return true.*\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Create a queue and add the root node to it.\\n2. Initialize a boolean flag isNullInBetweenNodes to false.\\n3. While the queue is not empty, do the following:\\n    - a. Get the size of the queue and initialize a loop to iterate over each node in the level.\\n    - b. Dequeue the node at the front of the queue.\\n    - c. If the dequeued node is null, set the isNullInBetweenNodes flag to true.\\n    - d. If the dequeued node is not null and isNullInBetweenNodes is true, then the tree is not complete. Return false.\\n    - e. If the dequeued node is not null, add its left and right children to the queue.\\n1. If the loop completes without returning false, then the tree is complete. Return true.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> storeNodes;\\n        storeNodes.push(root);\\n        bool isNullInBetweenNodes = false;\\n        while (!storeNodes.empty()) {\\n            int totalNodesInLevel = storeNodes.size();\\n            while (totalNodesInLevel--) {\\n                TreeNode *currNode = storeNodes.front();\\n                storeNodes.pop();\\n                if (currNode == nullptr) {\\n                    isNullInBetweenNodes = true;\\n                }\\n                else {\\n                    if (isNullInBetweenNodes == true) {\\n                        return false;\\n                    }\\n                    storeNodes.push(currNode -> left);\\n                    storeNodes.push(currNode -> right);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        boolean isNullInBetweenNodes = false;\\n        while (!queue.isEmpty()) {\\n            int totalNodesInLevel = queue.size();\\n            while (totalNodesInLevel-- > 0) {\\n                TreeNode currNode = queue.poll();\\n                if (currNode == null) {\\n                    isNullInBetweenNodes = true;\\n                }\\n                else {\\n                    if (isNullInBetweenNodes) {\\n                        return false;\\n                    }\\n                    queue.add(currNode.left);\\n                    queue.add(currNode.right);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        queue = collections.deque([root])\\n        is_null_in_between_nodes = False\\n        while queue:\\n            total_nodes_in_level = len(queue)\\n            for i in range(total_nodes_in_level):\\n                curr_node = queue.popleft()\\n                if curr_node is None:\\n                    is_null_in_between_nodes = True\\n                else:\\n                    if is_null_in_between_nodes:\\n                        return False\\n                    queue.append(curr_node.left)\\n                    queue.append(curr_node.right)\\n        return True\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity : **O(N)**, where N is the number of nodes in the binary tree. We visit each node exactly once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : **O(N)**, where N is the maximum number of nodes at any level of the binary tree. In the worst case, the last level of the binary tree may have N/2 nodes (in a complete binary tree), and thus the size of the queue can grow up to N/2.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> storeNodes;\\n        storeNodes.push(root);\\n        bool isNullInBetweenNodes = false;\\n        while (!storeNodes.empty()) {\\n            int totalNodesInLevel = storeNodes.size();\\n            while (totalNodesInLevel--) {\\n                TreeNode *currNode = storeNodes.front();\\n                storeNodes.pop();\\n                if (currNode == nullptr) {\\n                    isNullInBetweenNodes = true;\\n                }\\n                else {\\n                    if (isNullInBetweenNodes == true) {\\n                        return false;\\n                    }\\n                    storeNodes.push(currNode -> left);\\n                    storeNodes.push(currNode -> right);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        boolean isNullInBetweenNodes = false;\\n        while (!queue.isEmpty()) {\\n            int totalNodesInLevel = queue.size();\\n            while (totalNodesInLevel-- > 0) {\\n                TreeNode currNode = queue.poll();\\n                if (currNode == null) {\\n                    isNullInBetweenNodes = true;\\n                }\\n                else {\\n                    if (isNullInBetweenNodes) {\\n                        return false;\\n                    }\\n                    queue.add(currNode.left);\\n                    queue.add(currNode.right);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        queue = collections.deque([root])\\n        is_null_in_between_nodes = False\\n        while queue:\\n            total_nodes_in_level = len(queue)\\n            for i in range(total_nodes_in_level):\\n                curr_node = queue.popleft()\\n                if curr_node is None:\\n                    is_null_in_between_nodes = True\\n                else:\\n                    if is_null_in_between_nodes:\\n                        return False\\n                    queue.append(curr_node.left)\\n                    queue.append(curr_node.right)\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298705,
                "title": "faster-than-100-bfs-concise-full-explained-c",
                "content": "# Intuition\\nIn a complete Binary tree, all the levels except the last level should be fully filled and the last level should be filled from the left side.\\n\\nSo, if there\\'s a NULL node at any level, it should not be followed by any Non-NULL node, neither in the same level, nor in the next level.\\n\\n# Approach\\nThis can be implemented using simple BFS. Insert the elements in the queue until there\\'s a NULL node encountered. Use a bool variable for that(nullfound used in the code). If a node exists after NULL is found, simply return false as the tree can not be a complete Binary Tree.\\n\\nIf no such case is encountered, return True;\\n\\n# Complexity\\n- Time complexity:\\nAt most all the nodes will be processed if the tree is a complete binary tree.\\nThis is a simple Level-order Traversal, so the TC will be O(n) where n is the total number of nodes in the tree.\\n\\n- Space complexity:\\nA queue is used to store the items for a level, so the SC will be the maximum width of the tree , i.e., O(w).\\n\\n**PLEASE UPVOTE IF YOU FIND MY SOLUTION HELPFUL :)**\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        bool nullfound = false;\\n        while(!q.empty())\\n        {   \\n            TreeNode *curr = q.front();\\n            q.pop();\\n            if(curr == NULL)\\n            nullfound = true;\\n            else\\n            {\\n                if(nullfound)\\n                return false;\\n                else\\n                {\\n                    q.push(curr->left);\\n                    q.push(curr->right);\\n                }\\n            }            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        bool nullfound = false;\\n        while(!q.empty())\\n        {   \\n            TreeNode *curr = q.front();\\n            q.pop();\\n            if(curr == NULL)\\n            nullfound = true;\\n            else\\n            {\\n                if(nullfound)\\n                return false;\\n                else\\n                {\\n                    q.push(curr->left);\\n                    q.push(curr->right);\\n                }\\n            }            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1506222,
                "title": "java-simple-bfs-faster-than-100",
                "content": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList();\\n        queue.add(root);\\n        \\n        while (!queue.isEmpty()) {\\n            TreeNode node = queue.poll();\\n\\t\\t\\t\\n\\t\\t\\t// Trick here is that if you encounter  null between two non-null values, it ain\\'t complete binary tree.\\n            if (node == null && queue.peek() != null) return false; \\n            \\n            if (node != null)  {\\n                queue.add(node.left);\\n                queue.add(node.right);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList();\\n        queue.add(root);\\n        \\n        while (!queue.isEmpty()) {\\n            TreeNode node = queue.poll();\\n\\t\\t\\t\\n\\t\\t\\t// Trick here is that if you encounter  null between two non-null values, it ain\\'t complete binary tree.\\n            if (node == null && queue.peek() != null) return false; \\n            \\n            if (node != null)  {\\n                queue.add(node.left);\\n                queue.add(node.right);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 379607,
                "title": "java-easy-solution-using-queue-bfs-and-it-s-property-that-it-allows-null-values",
                "content": "1ms faster than 92.58% solutions and 36.4MB less than 100% solutions.\\n``` \\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root==null)\\n            return true;\\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\\n        q.add(root);\\n        while(q.isEmpty()!=true){\\n            TreeNode temp = q.remove();\\n            if(temp==null){                             // As soon as a null is encountered, now no other non null value could be on the Queue. So I check, if there is any I return False, else True.\\n                while(q.isEmpty()!=true){\\n                    TreeNode temp2 = q.remove();\\n                    if(temp2!=null)\\n                        return false;\\n                }\\n                return true;\\n            }\\n            q.add(temp.left);\\n            q.add(temp.right);\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "``` \\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root==null)\\n            return true;\\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\\n        q.add(root);\\n        while(q.isEmpty()!=true){\\n            TreeNode temp = q.remove();\\n            if(temp==null){                             // As soon as a null is encountered, now no other non null value could be on the Queue. So I check, if there is any I return False, else True.\\n                while(q.isEmpty()!=true){\\n                    TreeNode temp2 = q.remove();\\n                    if(temp2!=null)\\n                        return false;\\n                }\\n                return true;\\n            }\\n            q.add(temp.left);\\n            q.add(temp.right);\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3298252,
                "title": "level-order-traversal-video-java-c-python",
                "content": "# Intuition\\nIn a complete binary tree the nodes are added from top to bottom and from left to right. So we use the same traversal method i.e level order traversal and if there is any null prior to any non null node, the ans is false.\\n\\n# Approach\\n1. Initiate a queue.\\n2. Add root Node to queue.\\n3. while queue.peek() != null remove node and add left and right child.\\n4. Finally remove all continious null values.\\n5. If queue is not empty return false/ else true. \\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/fiCQAESE2Ts\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.add(root);\\n        while (queue.peek() != null) {\\n            TreeNode node = queue.remove();\\n            queue.add(node.left);\\n            queue.add(node.right);\\n        }\\n        while (!queue.isEmpty() && queue.peek() == null)\\n            queue.remove();\\n        return queue.isEmpty();\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while (q.front() != NULL) {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        while (!q.empty() && q.front() == NULL) {\\n            q.pop();\\n        }\\n        return q.empty();\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def isCompleteTree(self, root):\\n        queue = deque()\\n        queue.append(root)\\n        while queue[0] is not None:\\n            node = queue.popleft()\\n            queue.append(node.left)\\n            queue.append(node.right)\\n        while queue and queue[0] is None:\\n            queue.popleft()\\n        return not queue\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.add(root);\\n        while (queue.peek() != null) {\\n            TreeNode node = queue.remove();\\n            queue.add(node.left);\\n            queue.add(node.right);\\n        }\\n        while (!queue.isEmpty() && queue.peek() == null)\\n            queue.remove();\\n        return queue.isEmpty();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while (q.front() != NULL) {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        while (!q.empty() && q.front() == NULL) {\\n            q.pop();\\n        }\\n        return q.empty();\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def isCompleteTree(self, root):\\n        queue = deque()\\n        queue.append(root)\\n        while queue[0] is not None:\\n            node = queue.popleft()\\n            queue.append(node.left)\\n            queue.append(node.right)\\n        while queue and queue[0] is None:\\n            queue.popleft()\\n        return not queue\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150378,
                "title": "python-bfs-simple",
                "content": "```\\ndef isCompleteTree(self, root: TreeNode) -> bool:\\n        end = False\\n        queue = collections.deque([root])\\n        \\n        while queue:\\n            node = queue.popleft()\\n            \\n            if not node:\\n                end = True\\n            else:\\n                if end:\\n                    return False\\n                else:\\n                    queue.append(node.left)\\n                    queue.append(node.right)\\n        \\n        return True\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef isCompleteTree(self, root: TreeNode) -> bool:\\n        end = False\\n        queue = collections.deque([root])\\n        \\n        while queue:\\n            node = queue.popleft()\\n            \\n            if not node:\\n                end = True\\n            else:\\n                if end:\\n                    return False\\n                else:\\n                    queue.append(node.left)\\n                    queue.append(node.right)\\n        \\n        return True\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 492339,
                "title": "java-my-simple-solution-using-bfs",
                "content": "We do a BFS to check if we get a non-null node after a null node. If so, tree is not complete, else it is complete.\\n```\\npublic boolean isCompleteTree(TreeNode root) {\\n\\tif(root==null) return true;\\n\\tQueue<TreeNode> q = new LinkedList<>();\\n\\tq.offer(root);\\n\\tboolean flag = false;\\n\\twhile(!q.isEmpty()) {\\n\\t\\tTreeNode curr = q.poll();\\n\\t\\tif(curr != null && flag) return false;\\n\\t\\tif(curr == null) flag = true;\\n\\t\\telse {\\n\\t\\t\\tq.offer(curr.left);\\n\\t\\t\\tq.offer(curr.right);\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isCompleteTree(TreeNode root) {\\n\\tif(root==null) return true;\\n\\tQueue<TreeNode> q = new LinkedList<>();\\n\\tq.offer(root);\\n\\tboolean flag = false;\\n\\twhile(!q.isEmpty()) {\\n\\t\\tTreeNode curr = q.poll();\\n\\t\\tif(curr != null && flag) return false;\\n\\t\\tif(curr == null) flag = true;\\n\\t\\telse {\\n\\t\\t\\tq.offer(curr.left);\\n\\t\\t\\tq.offer(curr.right);\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 206520,
                "title": "easy-python-with-explanation-beats-100-so-far",
                "content": "Traverse the tree one level at a time, adding both children of each node to the queue as we go.  Keep a count of how many non-null nodes are left in the queue.  The first time we encounter a null node popped from the queue, if the counter shows nothing left, the tree is complete - otherwise not.\\n\\n```\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        count = 1 if root else 0\\n        nodes = [root]\\n        while nodes:\\n            x = nodes.pop(0)\\n            if not x:\\n                return count == 0\\n            count -= 1\\n            nodes += [x.left, x.right]\\n            count = count + 1 if x.left else count\\n            count = count + 1 if x.right else count\\n        \\n        return true\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        count = 1 if root else 0\\n        nodes = [root]\\n        while nodes:\\n            x = nodes.pop(0)\\n            if not x:\\n                return count == 0\\n            count -= 1\\n            nodes += [x.left, x.right]\\n            count = count + 1 if x.left else count\\n            count = count + 1 if x.right else count\\n        \\n        return true\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1687139,
                "title": "c-simplest-bfs-code",
                "content": "**PLEASE UPVOTE IF IT HELPS A BIT**\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root) return true;\\n        bool flag=true;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            auto curr= q.front();\\n            q.pop();\\n            if(curr==NULL)\\n            {\\n                flag=false;\\n            }\\n            else\\n            {\\n                if(flag==false)\\n                {\\n                    return false;\\n                }\\n                q.push(curr->left);\\n                q.push(curr->right);\\n            }\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root) return true;\\n        bool flag=true;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            auto curr= q.front();\\n            q.pop();\\n            if(curr==NULL)\\n            {\\n                flag=false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 212108,
                "title": "c-4ms-dfs-o-n-speed-o-lg-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(TreeNode* root, int d, vector<int>& v) {\\n        if (root == NULL) {\\n            if (v.size() == 0) {\\n                v.push_back(d);\\n                return true;\\n            }\\n            \\n            if (v.back() == d) {\\n                return true;\\n            }\\n            \\n            if (v.size() == 1 && v.back() == d + 1) {\\n                v.push_back(d);\\n                return true;\\n            }\\n            \\n            return false;\\n        }\\n        \\n        return dfs(root->left,  d + 1, v) && \\n               dfs(root->right, d + 1, v);\\n    }\\n    \\n    bool isCompleteTree(TreeNode* root) {\\n        vector<int> v;\\n        v.reserve(2);\\n        return dfs(root, 0, v);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(TreeNode* root, int d, vector<int>& v) {\\n        if (root == NULL) {\\n            if (v.size() == 0) {\\n                v.push_back(d);\\n                return true;\\n            }\\n            \\n            if (v.back() == d) {\\n                return true;\\n            }\\n            \\n            if (v.size() == 1 && v.back() == d + 1) {\\n                v.push_back(d);\\n                return true;\\n            }\\n            \\n            return false;\\n        }\\n        \\n        return dfs(root->left,  d + 1, v) && \\n               dfs(root->right, d + 1, v);\\n    }\\n    \\n    bool isCompleteTree(TreeNode* root) {\\n        vector<int> v;\\n        v.reserve(2);\\n        return dfs(root, 0, v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301628,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int i=0,f=0;\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            if(f && node != NULL) return false;\\n            if(node== NULL){\\n                f=1;\\n                continue;\\n            }\\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        return true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int i=0,f=0;\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            if(f && node != NULL) return false;\\n            if(node== NULL){\\n                f=1;\\n                continue;\\n            }\\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236163,
                "title": "level-order-traversal-bfs-o-n-time-o-n-space-for-queue",
                "content": "**Algorithm** : \\n1. find the total Node in Tree using a Utility function.\\n2. first create a queue and push root Node.\\n3. maintain a `int count = 0` for storing How many nodes are processed.\\n4. do level order traversal and push all Node(both `NULL` and `Non-NULL`) and increase a count with `q.pop()` [after processing the item].\\n5. When You find first `NULL` in `queue` break the while loop (Why?). \\n6. Now compaire the count with Total Node in Tree.\\n7. if count is less then Total Node then return false.\\n8. else return true.\\n\\nWhy? -> In complete binary tree the level order traversal is as follow.\\n```\\n            [val,val,val.......,...val, val ......., val,null,null,null.........,null]\\n\\t\\t\\t|------------------------------------------|^|--------------------------|\\n\\t\\t\\t\\t\\tNon null root.                                 Null root\\n```\\n**So the Count Must be equal to Total Number of root after finding first NULL root in a Complete Binary Tree.**\\n```\\nprivate:\\n    int TotalNode(TreeNode *root){\\n        if(root==NULL) return 0;\\n        return 1 + TotalNode(root->left) + TotalNode(root->right);\\n    }\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        \\n        int totalEle = TotalNode(root);\\n        int count = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(q.empty()==false){\\n           \\n            TreeNode* curr = q.front();\\n            if(curr==NULL){\\n                break;\\n            }\\n            q.pop();\\n            count++;\\n            q.push(curr->left);\\n            q.push(curr->right);\\n        }\\n        \\n        if(count<totalEle) return false;\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n            [val,val,val.......,...val, val ......., val,null,null,null.........,null]\\n\\t\\t\\t|------------------------------------------|^|--------------------------|\\n\\t\\t\\t\\t\\tNon null root.                                 Null root\\n```\n```\\nprivate:\\n    int TotalNode(TreeNode *root){\\n        if(root==NULL) return 0;\\n        return 1 + TotalNode(root->left) + TotalNode(root->right);\\n    }\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        \\n        int totalEle = TotalNode(root);\\n        int count = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(q.empty()==false){\\n           \\n            TreeNode* curr = q.front();\\n            if(curr==NULL){\\n                break;\\n            }\\n            q.pop();\\n            count++;\\n            q.push(curr->left);\\n            q.push(curr->right);\\n        }\\n        \\n        if(count<totalEle) return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3484894,
                "title": "simplest-bfs-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        int i,j,k,c=0;\\n        if(!root)\\n        return 1;\\n\\n        queue<TreeNode*>q;\\n        q.push(root);\\n\\n        while(!q.empty()){\\n            TreeNode* curr=q.front();\\n            q.pop();\\n\\n            if(curr->left){\\n                if(c!=0)\\n                return 0;\\n                q.push(curr->left);\\n            } else{\\n                c=1;\\n            }\\n\\n            if(curr->right){\\n                if(c!=0)\\n                return 0;\\n                q.push(curr->right);\\n            } else{\\n                c=1;\\n            }\\n        }\\n        return 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        int i,j,k,c=0;\\n        if(!root)\\n        return 1;\\n\\n        queue<TreeNode*>q;\\n        q.push(root);\\n\\n        while(!q.empty()){\\n            TreeNode* curr=q.front();\\n            q.pop();\\n\\n            if(curr->left){\\n                if(c!=0)\\n                return 0;\\n                q.push(curr->left);\\n            } else{\\n                c=1;\\n            }\\n\\n            if(curr->right){\\n                if(c!=0)\\n                return 0;\\n                q.push(curr->right);\\n            } else{\\n                c=1;\\n            }\\n        }\\n        return 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298821,
                "title": "c-easy-to-understand-explained-with-example",
                "content": "# Intuition\\nThe problem requires us to determine if the given binary tree is a complete binary tree or not. \\nA complete binary tree is one in which all levels are completely filled except possibly the last level and all nodes are as far left as possible. Therefore, we need to traverse the binary tree level by level and ensure that it satisfies these properties.\\n\\n![image.png](https://assets.leetcode.com/users/images/78c4e2bd-fae2-4ee9-8720-fa41a2c05908_1678860865.4098353.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/bae5991d-d8d2-4a89-afc5-a4041708157c_1678861616.1194062.png)\\n\\n\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can use a breadth-first search (BFS) algorithm to traverse the binary tree level by level. \\n1. We start with the root node and add it to a queue. \\n2. Then, while the queue is not empty:\\n    - we process each node at the front of the queue, add its left and right children to the queue if they exist, and remove the processed node from the queue. \\n    - We keep track of whether we have seen a null node previously using a flag variable. \\n    - If we encounter a non-null node after seeing a null node, then the binary tree is not a complete binary tree.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Example\\n```\\n       1\\n     /   \\\\\\n    2     3\\n   / \\\\   / \\n  4   5 6   \\n / \\\\\\n8   9\\n```\\nThe level-by-level traversal using BFS would be:\\n\\n```\\n1st level: [1]\\n2nd level: [2, 3]\\n3rd level: [4, 5, 6], nullSeen=true as null node is encountered after 6\\n4th level: [8,9] \\n```\\nIn the last level when we process 8, nullSeen was true hence we return false as we encounter a non-null node after seeing a null node.\\n\\n\\n# Complexity\\n- Time complexity: **O(n)**, where n is the number of nodes in the binary tree. This is because we need to visit each node once in the worst case.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**. The space complexity is actually O(w), where w is the maximum width of the binary tree. In the worst case, the width of the binary tree can be as large as n/2 (for a complete binary tree), so the space complexity of the function is O(n/2) =O(n).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root) return true; // if the root is null, then the tree is complete\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        bool nullSeen=false; // flag that keeps track of whether we encountered a null node previously or not\\n\\n        while(!q.empty()){ \\n            int levelSize=q.size(); // number of nodes at this level\\n            while(levelSize--){    \\n                TreeNode* tp=q.front();\\n                q.pop();\\n                if(!tp) nullSeen=true; // if the node is null, set the nullSeen flag to true \\n                else{\\n                    if(nullSeen) return false; // if we already had a null node, then this binary tree is not complete\\n                    q.push(tp->left);\\n                    q.push(tp->right);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n       1\\n     /   \\\\\\n    2     3\\n   / \\\\   / \\n  4   5 6   \\n / \\\\\\n8   9\\n```\n```\\n1st level: [1]\\n2nd level: [2, 3]\\n3rd level: [4, 5, 6], nullSeen=true as null node is encountered after 6\\n4th level: [8,9] \\n```\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root) return true; // if the root is null, then the tree is complete\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        bool nullSeen=false; // flag that keeps track of whether we encountered a null node previously or not\\n\\n        while(!q.empty()){ \\n            int levelSize=q.size(); // number of nodes at this level\\n            while(levelSize--){    \\n                TreeNode* tp=q.front();\\n                q.pop();\\n                if(!tp) nullSeen=true; // if the node is null, set the nullSeen flag to true \\n                else{\\n                    if(nullSeen) return false; // if we already had a null node, then this binary tree is not complete\\n                    q.push(tp->left);\\n                    q.push(tp->right);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298211,
                "title": "c-easiest-approach-beats-100-level-order-traversal",
                "content": "# Intuition\\nThe problem asks us to determine whether a binary tree is a complete binary tree or not. A complete binary tree is a binary tree where every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible.\\n\\n# Approach\\nTo solve this problem, we can do a level order traversal of the binary tree and keep track of the following:\\n\\n1. A flag that indicates if we have seen a non-full level (a level that is not completely filled).\\n2. A flag that indicates if we have seen a node that has only one child.\\n3. We start by pushing the root node into a queue. Then, we repeatedly dequeue a node from the queue and perform the following steps:\\n\\n4. If the dequeued node is null, we set the seen_non_full_level flag to true, indicating that we have seen a non-full level.\\n5. Otherwise, if we have already seen a non-full level and the node has only one child, then the binary tree is not a complete binary tree, and we return false.\\n6. Otherwise, we enqueue the left and right child of the node into the queue.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity is O(n), where n is the number of nodes in the binary tree. This is because we need to visit every node in the tree once during the level order traversal.\\n- Space complexity:\\nThe space complexity of the function is O(w), where w is the maximum width of the binary tree (i.e., the maximum number of nodes that can be in a single level). This is because we need to store at most w nodes in the queue at any given time during the level order traversal.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        bool seen_non_full_level = false;\\n        while (!q.empty()) {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if (node == nullptr) {\\n                seen_non_full_level = true;\\n            } else {\\n                if (seen_non_full_level) {\\n                    return false;\\n                }\\n                q.push(node->left);\\n                q.push(node->right);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\\\\\\\\\uD83D\\uDC47upvote Below if you liked the solution\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        bool seen_non_full_level = false;\\n        while (!q.empty()) {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if (node == nullptr) {\\n                seen_non_full_level = true;\\n            } else {\\n                if (seen_non_full_level) {\\n                    return false;\\n                }\\n                q.push(node->left);\\n                q.push(node->right);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\\\\\\\\\uD83D\\uDC47upvote Below if you liked the solution\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298198,
                "title": "swift-bfs-3-sloc",
                "content": "**BFS (accepted answer)**\\n```\\nclass Solution {\\n    func isCompleteTree(_ root: TreeNode?) -> Bool {\\n        var q = [root]    \\n        while let n = q.removeFirst() { q += [n.left, n.right] }\\n        return q.allSatisfy { $0 == nil }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isCompleteTree(_ root: TreeNode?) -> Bool {\\n        var q = [root]    \\n        while let n = q.removeFirst() { q += [n.left, n.right] }\\n        return q.allSatisfy { $0 == nil }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315536,
                "title": "using-recursion-in-c-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int countt(TreeNode *root)                             ////count the number of nodes \\n  {\\n      if(!root)\\n      return 0;\\n      \\n      return 1+countt(root->left)+countt(root->right);\\n  }\\n    bool iscomplete(TreeNode *root,int id,int count)                    ///recursively check the nodes are valid or not as we do in heap \\n  {\\n      if(!root)\\n      return 1;\\n      \\n      if(id>=count)\\n      return false;\\n      \\n      return iscomplete(root->left,2*id+1,count) && iscomplete(root->right,2*id+2,count);\\n  }\\n    bool isCompleteTree(TreeNode* root) {\\n         int count=countt(root);\\n        int id=0;\\n        return iscomplete(root,0,count);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countt(TreeNode *root)                             ////count the number of nodes \\n  {\\n      if(!root)\\n      return 0;\\n      \\n      return 1+countt(root->left)+countt(root->right);\\n  }\\n    bool iscomplete(TreeNode *root,int id,int count)                    ///recursively check the nodes are valid or not as we do in heap \\n  {\\n      if(!root)\\n      return 1;\\n      \\n      if(id>=count)\\n      return false;\\n      \\n      return iscomplete(root->left,2*id+1,count) && iscomplete(root->right,2*id+2,count);\\n  }\\n    bool isCompleteTree(TreeNode* root) {\\n         int count=countt(root);\\n        int id=0;\\n        return iscomplete(root,0,count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941333,
                "title": "python-easy-12-ms-bfs",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        q = deque()\\n        q.append(root)\\n        \\n        while q:\\n            node = q.popleft()\\n            \\n            if not node and q:\\n                return not any(q)\\n            elif node:\\n                q.append(node.left)\\n                q.append(node.right)\\n            \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        q = deque()\\n        q.append(root)\\n        \\n        while q:\\n            node = q.popleft()\\n            \\n            if not node and q:\\n                return not any(q)\\n            elif node:\\n                q.append(node.left)\\n                q.append(node.right)\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690494,
                "title": "well-commented-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(log n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode*root){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        return 1+countNodes(root->left)+countNodes(root->right);\\n    }\\n    bool isCBT(TreeNode*root,int i,int size){\\n        \\n        if(root==NULL){\\n            return true;\\n        }\\n\\n        if(i>=size){\\n            return false;\\n        }\\n        else{\\n            return isCBT(root->left,2*i+1,size) && isCBT(root->right,2*i+2,size);\\n        }\\n    }\\n    bool isCompleteTree(TreeNode* root) {\\n        // here will need to check just 1 condition \\n        // if index of a node don\\'t exceed the total number of elements\\n        \\n        // to find the total number of element find the height of the tree and 2*h is total number of nodes\\n\\n        int size=countNodes(root);\\n        return isCBT(root,0,size);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode*root){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        return 1+countNodes(root->left)+countNodes(root->right);\\n    }\\n    bool isCBT(TreeNode*root,int i,int size){\\n        \\n        if(root==NULL){\\n            return true;\\n        }\\n\\n        if(i>=size){\\n            return false;\\n        }\\n        else{\\n            return isCBT(root->left,2*i+1,size) && isCBT(root->right,2*i+2,size);\\n        }\\n    }\\n    bool isCompleteTree(TreeNode* root) {\\n        // here will need to check just 1 condition \\n        // if index of a node don\\'t exceed the total number of elements\\n        \\n        // to find the total number of element find the height of the tree and 2*h is total number of nodes\\n\\n        int size=countNodes(root);\\n        return isCBT(root,0,size);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485000,
                "title": "simplest-dfs-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- Auxillary Stack Space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int count_nodes(TreeNode* root){\\n        if(!root) return 0;\\n        int l=count_nodes(root->left);\\n        int r=count_nodes(root->right);\\n        return l+r+1;\\n    }\\n\\n    bool check(TreeNode* root,int ind,int n){\\n        if(!root)\\n        return 1;\\n\\n        if(ind>=n)\\n        return 0;\\n\\n        bool l=check(root->left,2*ind+1,n) ;\\n        bool r= check(root->right,2*ind+2,n);\\n        return l and r;\\n        \\n    }\\n\\n    bool isCompleteTree(TreeNode* root) {\\n        int i,j,k,c=0;\\n        if(!root) return 1;  \\n\\n        int n=count_nodes(root);   //For counting number of nodes\\n        return check(root,0,n);  \\n\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int count_nodes(TreeNode* root){\\n        if(!root) return 0;\\n        int l=count_nodes(root->left);\\n        int r=count_nodes(root->right);\\n        return l+r+1;\\n    }\\n\\n    bool check(TreeNode* root,int ind,int n){\\n        if(!root)\\n        return 1;\\n\\n        if(ind>=n)\\n        return 0;\\n\\n        bool l=check(root->left,2*ind+1,n) ;\\n        bool r= check(root->right,2*ind+2,n);\\n        return l and r;\\n        \\n    }\\n\\n    bool isCompleteTree(TreeNode* root) {\\n        int i,j,k,c=0;\\n        if(!root) return 1;  \\n\\n        int n=count_nodes(root);   //For counting number of nodes\\n        return check(root,0,n);  \\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298313,
                "title": "java-easy-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean end = false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while(!queue.isEmpty()) {\\n            TreeNode currentNode = queue.poll();\\n            if(currentNode == null) {\\n                end = true;\\n            } else {\\n                if(end) {\\n                    return false;\\n                }\\n                queue.offer(currentNode.left);\\n                queue.offer(currentNode.right);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean end = false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while(!queue.isEmpty()) {\\n            TreeNode currentNode = queue.poll();\\n            if(currentNode == null) {\\n                end = true;\\n            } else {\\n                if(end) {\\n                    return false;\\n                }\\n                queue.offer(currentNode.left);\\n                queue.offer(currentNode.right);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029782,
                "title": "javascript-clean-dfs-bfs-solutions",
                "content": "# Solution 1: DFS\\n```javascript\\nvar isCompleteTree = function(root) {\\n  \\n    function dfs(node) {\\n        if(!node) return [0];\\n        return [...dfs(node.left), ...dfs(node.right)].map(x => x + 1);\\n    }\\n    \\n    const heights = dfs(root);\\n    const maxH = heights[0];\\n    \\n    for(let i = 1; i < heights.length; i++) {\\n        if(heights[i] > heights[i-1]) return false;\\n        if(heights[i] < maxH-1) return false;\\n    }\\n    return true;\\n};\\n```\\n# Solution 2: BFS\\n```javascript\\nvar isCompleteTree = function(root) {\\n    let seenNull = false;\\n    let queue = [root];\\n    \\n    while(queue.length) {\\n        const next = [];\\n        \\n        for(let nextNode of queue) {\\n            if(!nextNode) seenNull = true;\\n            else {\\n                if(seenNull) return false;\\n                next.push(nextNode.left);\\n                next.push(nextNode.right);\\n            }\\n        }\\n        queue = next;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```javascript\\nvar isCompleteTree = function(root) {\\n  \\n    function dfs(node) {\\n        if(!node) return [0];\\n        return [...dfs(node.left), ...dfs(node.right)].map(x => x + 1);\\n    }\\n    \\n    const heights = dfs(root);\\n    const maxH = heights[0];\\n    \\n    for(let i = 1; i < heights.length; i++) {\\n        if(heights[i] > heights[i-1]) return false;\\n        if(heights[i] < maxH-1) return false;\\n    }\\n    return true;\\n};\\n```\n```javascript\\nvar isCompleteTree = function(root) {\\n    let seenNull = false;\\n    let queue = [root];\\n    \\n    while(queue.length) {\\n        const next = [];\\n        \\n        for(let nextNode of queue) {\\n            if(!nextNode) seenNull = true;\\n            else {\\n                if(seenNull) return false;\\n                next.push(nextNode.left);\\n                next.push(nextNode.right);\\n            }\\n        }\\n        queue = next;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 803885,
                "title": "python-easy-2-approaches",
                "content": "```\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        index,count = 0,0\\n        Q = collections.deque([(root,index)])\\n        while Q:\\n            u,index = Q.popleft()\\n            count += 1\\n            if u.left:\\n                Q.append((u.left,2*index+1))\\n            if u.right:\\n                Q.append((u.right,2*index+2))\\n        return index+1 == count\\n```\\n\\n```\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        Q = collections.deque([root])\\n        while Q[0]:\\n            u = Q.popleft()\\n            Q.append(u.left)\\n            Q.append(u.right)\\n        return not any(Q)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        index,count = 0,0\\n        Q = collections.deque([(root,index)])\\n        while Q:\\n            u,index = Q.popleft()\\n            count += 1\\n            if u.left:\\n                Q.append((u.left,2*index+1))\\n            if u.right:\\n                Q.append((u.right,2*index+2))\\n        return index+1 == count\\n```\n```\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        Q = collections.deque([root])\\n        while Q[0]:\\n            u = Q.popleft()\\n            Q.append(u.left)\\n            Q.append(u.right)\\n        return not any(Q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538773,
                "title": "java-bfs-classical",
                "content": "First idea for all Binary tree is DFS, this is very classcial example to use BFS\\n```\\npublic boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        boolean found = false;\\n        while (!q.isEmpty()) {\\n            TreeNode node = q.poll();\\n            if (node == null) {\\n                found = true;\\n            } else {\\n                if (found) return false;\\n                q.offer(node.left);\\n                q.offer(node.right);\\n            }\\n        }\\n        return true;\\n    }\\n```\\n\\nMORE easy understand version:\\n```\\npublic boolean isCompleteTree(TreeNode root) {\\n        if (root == null) return true;\\n        boolean foundPrev = false;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        while (!q.isEmpty()) {\\n            int l = q.size();\\n            boolean found = false;\\n            for (int i = 0; i < l; i++) {\\n                TreeNode node = q.poll();\\n                if (node != null) {\\n                    if (found || foundPrev) return false;\\n                    q.offer(node.left);\\n                    q.offer(node.right);\\n                } else{\\n                    found = true;\\n                }\\n            }\\n            foundPrev = found;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        boolean found = false;\\n        while (!q.isEmpty()) {\\n            TreeNode node = q.poll();\\n            if (node == null) {\\n                found = true;\\n            } else {\\n                if (found) return false;\\n                q.offer(node.left);\\n                q.offer(node.right);\\n            }\\n        }\\n        return true;\\n    }\\n```\n```\\npublic boolean isCompleteTree(TreeNode root) {\\n        if (root == null) return true;\\n        boolean foundPrev = false;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        while (!q.isEmpty()) {\\n            int l = q.size();\\n            boolean found = false;\\n            for (int i = 0; i < l; i++) {\\n                TreeNode node = q.poll();\\n                if (node != null) {\\n                    if (found || foundPrev) return false;\\n                    q.offer(node.left);\\n                    q.offer(node.right);\\n                } else{\\n                    found = true;\\n                }\\n            }\\n            foundPrev = found;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 329540,
                "title": "short-c-solution-with-comments-faster-than-93",
                "content": "* BFS traversal of a tree (level by level)\\n* If a tree is complete, no non-empty nodes after empty nodes.\\n\\n```\\nbool isCompleteTree(TreeNode* root) {\\n\\tqueue<TreeNode*> q;\\n\\tq.push(root);\\n\\tbool null_visited = false;\\n\\twhile(!q.empty()){\\n\\t\\tauto n = q.front();\\n\\t\\tq.pop();\\n\\t\\tif (!n)\\n\\t\\t\\tnull_visited = true;\\n\\t\\telse{\\n\\t\\t\\tif (null_visited)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tq.push(n->left);\\n\\t\\t\\tq.push(n->right);\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isCompleteTree(TreeNode* root) {\\n\\tqueue<TreeNode*> q;\\n\\tq.push(root);\\n\\tbool null_visited = false;\\n\\twhile(!q.empty()){\\n\\t\\tauto n = q.front();\\n\\t\\tq.pop();\\n\\t\\tif (!n)\\n\\t\\t\\tnull_visited = true;\\n\\t\\telse{\\n\\t\\t\\tif (null_visited)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\tq.push(n->left);\\n\\t\\t\\tq.push(n->right);\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 326507,
                "title": "javascript-beats-96-bfs",
                "content": "```\\n\\n```var isCompleteTree = function(root) {\\n    if(root == null) return true;\\n    var end=false;\\n    var q=[root];\\n    while(q.length>0){\\n         var cur=q.shift();\\n         if(cur == null){\\n             end=true;\\n         }else{\\n             if(end) return false;\\n             q.push(cur.left);\\n             q.push(cur.right);\\n         }\\n    }\\n    return true;\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3298728,
                "title": "javascript-rust-go-easy-to-understand-bfs-solution-with-explanation",
                "content": "# Approach\\n\\nIn this problem, we need to determine if a binary tree is complete. A binary tree is considered complete if all levels of the tree are completely filled, except possibly for the last level, which must be filled from left to right.\\n\\nWe can use a breadth-first search (BFS) approach to traverse the binary tree level by level to solve this problem. It starts by initializing a queue with the root node of the tree and then enters a loop that continues until there are no more nodes in the queue.\\n\\nIn each iteration of the loop, we remove the next node from the **front** of the queue and check whether it is null or not. If the node is null, we can set a flag to indicate that the previous node was null and continue to the next node in the queue. If the node is not null, we can check whether the previous node was null or not and if the previous node was null, we return false because a binary tree cannot have a non-null node following a null node.\\n\\nIf the node is not null and the previous node was not null, we add the left and right children of the current node to the back of the queue. By doing so, we ensure that the function traverses the tree level by level and that all nodes on the same level are visited before any nodes on the next level.\\n\\nIf the loop completes without returning false, then the binary tree is considered complete and the function returns true.\\n\\n## JavaScript Code\\n```\\nconst isCompleteTree = function (root) {\\n  let queue = [root]; // Initialize a queue with the root node\\n\\n  // Keep track of whether the previous node was null or not\\n  let isPreviousNodeNull = false;\\n\\n  // Loop until there are no more nodes in the queue\\n  while (queue.length > 0) {\\n    // Get the next node from the queue\\n    const node = queue.shift(); \\n\\n    if (!node) {\\n      // If the node is null\\n      // Set the flag to true, indicating that the previous node was null\\n      isPreviousNodeNull = true;\\n      continue; // Continue to the next node in the queue\\n    }\\n\\n    // If the previous node was null but the current node is not, \\n    // then the binary tree is not complete\\n    if (isPreviousNodeNull) return false; \\n\\n    // Add the left and right children of the current node to the queue\\n    queue.push(node.left, node.right);\\n  }\\n  // If the loop completes without finding any missing nodes, \\n  // then the binary tree is complete\\n  return true;\\n};\\n\\n```\\n\\n## Rust Solution\\n```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn is_complete_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let mut queue = std::collections::VecDeque::new();\\n        queue.push_back(root);\\n\\n        let mut is_previous_none = false;\\n\\n        while !queue.is_empty() {\\n            let node = queue.pop_front().unwrap();\\n\\n            if node.is_none() {\\n                is_previous_none = true;\\n                continue;\\n            }\\n\\n            if is_previous_none { return false; }\\n\\n            let node = node.unwrap();\\n            queue.push_back(node.borrow().left.clone());\\n            queue.push_back(node.borrow().right.clone());\\n        }\\n\\n        true\\n    }\\n}\\n```\\n\\n## Go Solution\\n```go\\nfunc isCompleteTree(root *TreeNode) bool {\\n\\tqueue := make([]*TreeNode, 0)\\n\\tqueue = append(queue, root)\\n\\n\\tisPreviousNull := false\\n\\tfor len(queue) > 0 {\\n\\t\\tnode := queue[0]\\n\\t\\tqueue = queue[1:]\\n\\n\\t\\tif node == nil {\\n\\t\\t\\tisPreviousNull = true\\n            continue\\n\\t\\t}\\n\\n\\t\\tif isPreviousNull { return false }\\n\\n\\t\\tqueue = append(queue, node.Left, node.Right)\\n\\t}\\n\\n\\treturn true\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Go",
                    "Rust",
                    "Breadth-First Search"
                ],
                "code": "```\\nconst isCompleteTree = function (root) {\\n  let queue = [root]; // Initialize a queue with the root node\\n\\n  // Keep track of whether the previous node was null or not\\n  let isPreviousNodeNull = false;\\n\\n  // Loop until there are no more nodes in the queue\\n  while (queue.length > 0) {\\n    // Get the next node from the queue\\n    const node = queue.shift(); \\n\\n    if (!node) {\\n      // If the node is null\\n      // Set the flag to true, indicating that the previous node was null\\n      isPreviousNodeNull = true;\\n      continue; // Continue to the next node in the queue\\n    }\\n\\n    // If the previous node was null but the current node is not, \\n    // then the binary tree is not complete\\n    if (isPreviousNodeNull) return false; \\n\\n    // Add the left and right children of the current node to the queue\\n    queue.push(node.left, node.right);\\n  }\\n  // If the loop completes without finding any missing nodes, \\n  // then the binary tree is complete\\n  return true;\\n};\\n\\n```\n```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn is_complete_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let mut queue = std::collections::VecDeque::new();\\n        queue.push_back(root);\\n\\n        let mut is_previous_none = false;\\n\\n        while !queue.is_empty() {\\n            let node = queue.pop_front().unwrap();\\n\\n            if node.is_none() {\\n                is_previous_none = true;\\n                continue;\\n            }\\n\\n            if is_previous_none { return false; }\\n\\n            let node = node.unwrap();\\n            queue.push_back(node.borrow().left.clone());\\n            queue.push_back(node.borrow().right.clone());\\n        }\\n\\n        true\\n    }\\n}\\n```\n```go\\nfunc isCompleteTree(root *TreeNode) bool {\\n\\tqueue := make([]*TreeNode, 0)\\n\\tqueue = append(queue, root)\\n\\n\\tisPreviousNull := false\\n\\tfor len(queue) > 0 {\\n\\t\\tnode := queue[0]\\n\\t\\tqueue = queue[1:]\\n\\n\\t\\tif node == nil {\\n\\t\\t\\tisPreviousNull = true\\n            continue\\n\\t\\t}\\n\\n\\t\\tif isPreviousNull { return false }\\n\\n\\t\\tqueue = append(queue, node.Left, node.Right)\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3298410,
                "title": "python-3-7-lines-w-explanation-t-m-100-97",
                "content": "Here\\'s the plan:\\n- BFS the tree, left to right, level by level.\\n- We mark the instance of the first null popped from the queue and then ensure the remaining queue is only null nodes.\\n- If so, both criteria are satisfied and True is returned. If not, False is returned.\\n```\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n                        \\n        queue = deque([root])                       #   <-- initialize the queue\\n\\n        while queue[0]:                             #   <-- if and while top queue node is not null, pop   \\n            node = queue.popleft()                  #       it and then push its left child and right  \\n            queue.extend([node.left, node.right])   #       child onto the queue.\\n\\n        while queue and not queue[0]:               #   <-- if and while top queue node is null, pop it. \\n            queue.popleft()                         #        \\n\\n        return not queue                            #   <-- If the queue is not empty, it must be non-null, so \\n                                                    #       return False; if the queue is empty, return True.\\n```\\n[https://leetcode.com/problems/check-completeness-of-a-binary-tree/submissions/915322764/]()",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n                        \\n        queue = deque([root])                       #   <-- initialize the queue\\n\\n        while queue[0]:                             #   <-- if and while top queue node is not null, pop   \\n            node = queue.popleft()                  #       it and then push its left child and right  \\n            queue.extend([node.left, node.right])   #       child onto the queue.\\n\\n        while queue and not queue[0]:               #   <-- if and while top queue node is null, pop it. \\n            queue.popleft()                         #        \\n\\n        return not queue                            #   <-- If the queue is not empty, it must be non-null, so \\n                                                    #       return False; if the queue is empty, return True.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435504,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q ;\\n        q.push(root) ;\\n        bool seenNull = false ;\\n        \\n        while(q.size()){\\n            int sz = q.size() ;\\n                auto node = q.front() ; q.pop() ;\\n                if(!node) seenNull = true ;\\n                else{\\n                    if(seenNull) return false ;\\n                    q.push(node->left) , q.push(node->right) ;\\n                }\\n        }\\n        return true ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q ;\\n        q.push(root) ;\\n        bool seenNull = false ;\\n        \\n        while(q.size()){\\n            int sz = q.size() ;\\n                auto node = q.front() ; q.pop() ;\\n                if(!node) seenNull = true ;\\n                else{\\n                    if(seenNull) return false ;\\n                    q.push(node->left) , q.push(node->right) ;\\n                }\\n        }\\n        return true ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967423,
                "title": "c-dfs-superfast",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n //just leave a comment if u have any doubt \\nclass Solution {\\npublic:\\n    int solve(TreeNode*root)\\n    {\\n        if(root==NULL)return 0;\\n        return 1+max(solve(root->left),solve(root->right));\\n    }\\n    int ch=-1,c=-1,r=-1;\\n    void dfs(TreeNode*root,int k)\\n    {\\n        if(k>1 && (!root->left || !root->right))r=0;\\n        if(c==0 || k<1 || r==0)return;\\n        if(k==1)\\n        {\\n            ch=1;\\n            if(c==1 && (root->right || root->left))c=0;\\n            else if(!root->right)c=1;\\n            else if(root->right && !root->left)c=0;\\n            return;\\n        }\\n        dfs(root->left,k-1);\\n        if(ch==-1 || c==0)return ;\\n        dfs(root->right,k-1);\\n    }\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root->left && !root->right)return true;\\n        int h=solve(root);\\n        dfs(root,h-1);\\n        if(c!=0 && r!=0)return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n //just leave a comment if u have any doubt \\nclass Solution {\\npublic:\\n    int solve(TreeNode*root)\\n    {\\n        if(root==NULL)return 0;\\n        return 1+max(solve(root->left),solve(root->right));\\n    }\\n    int ch=-1,c=-1,r=-1;\\n    void dfs(TreeNode*root,int k)\\n    {\\n        if(k>1 && (!root->left || !root->right))r=0;\\n        if(c==0 || k<1 || r==0)return;\\n        if(k==1)\\n        {\\n            ch=1;\\n            if(c==1 && (root->right || root->left))c=0;\\n            else if(!root->right)c=1;\\n            else if(root->right && !root->left)c=0;\\n            return;\\n        }\\n        dfs(root->left,k-1);\\n        if(ch==-1 || c==0)return ;\\n        dfs(root->right,k-1);\\n    }\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root->left && !root->right)return true;\\n        int h=solve(root);\\n        dfs(root,h-1);\\n        if(c!=0 && r!=0)return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834142,
                "title": "c-simple-easy-code-bfs-0ms",
                "content": "Just check in level order, weather the last element is NULL or not.\\nIf you face any element after the NULL element then its not a complete BT.\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        bool ch = true;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if(node == NULL){ch=false;}\\n            else{\\n                if(!ch){return false;}\\n                q.push(node->left);\\n                q.push(node->right);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\nDo upvote if it helped :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        bool ch = true;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if(node == NULL){ch=false;}\\n            else{\\n                if(!ch){return false;}\\n                q.push(node->left);\\n                q.push(node->right);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756452,
                "title": "python-easy-to-read-and-understand-bfs",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        q = [root]\\n        prev = root\\n        while q:\\n            node = q.pop(0)\\n            if node:\\n                if not prev:\\n                    return False\\n                q.append(node.left)\\n                q.append(node.right)\\n            prev = node\\n        return True",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        q = [root]\\n        prev = root\\n        while q:\\n            node = q.pop(0)\\n            if node:\\n                if not prev:\\n                    return False\\n                q.append(node.left)\\n                q.append(node.right)\\n            prev = node\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 1393027,
                "title": "c-level-order-traversal-short-solution-o-n",
                "content": "The idea is to use level order traversal and insert the null childen too.\\nWhen you find a null, look for a non null after it, if found, return false, else, return true.\\n```cpp\\nbool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while (!q.empty()) {\\n            TreeNode* t = q.front();\\n            q.pop();\\n            \\n            if (t == NULL) {\\n                while (!q.empty()) {\\n                    if (q.front() != NULL)\\n                        return false;\\n                    q.pop();\\n                }\\n                return true;\\n            } else {\\n                q.push(t->left);\\n                q.push(t->right);\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "The idea is to use level order traversal and insert the null childen too.\\nWhen you find a null, look for a non null after it, if found, return false, else, return true.\\n```cpp\\nbool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while (!q.empty()) {\\n            TreeNode* t = q.front();\\n            q.pop();\\n            \\n            if (t == NULL) {\\n                while (!q.empty()) {\\n                    if (q.front() != NULL)\\n                        return false;\\n                    q.pop();\\n                }\\n                return true;\\n            } else {\\n                q.push(t->left);\\n                q.push(t->right);\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1206358,
                "title": "c-simple-short-normal-bfs-code-null-pointer-logic",
                "content": "**Logic behind the curtains is simple :** if you take any complete tree and do BFS on it then BFS queue will contain null pointers only at the end.... if you get any null pointer in middle of your BFS , then its not a complete tree.\\nHope wording would explain what i meant!! HAPPY CODING!\\n\\nMust hit a like if u get the logic and think that its a simple cool logic :).\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool checkForAllNull(queue<TreeNode*> q){\\n        while(!q.empty()){\\n            if(q.front() !=NULL)\\n                return false;\\n            q.pop();\\n        }\\n        return true;\\n    }\\n    \\n    bool isCompleteTree(TreeNode* root) {\\n        int i,j,h=0;\\n        queue<TreeNode*> q;\\n        TreeNode *p;\\n        q.push(root);\\n        while(!q.empty()){\\n            p = q.front();\\n            if(p==NULL){ // Once null pointer starts... q should contain all null then to be a complete tree\\n                if(checkForAllNull(q))\\n                    return true;\\n                return false;\\n            }\\n            q.push(p->left);\\n            q.push(p->right);\\n            q.pop();\\n        }\\n        return true;\\n    }\\n   \\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool checkForAllNull(queue<TreeNode*> q){\\n        while(!q.empty()){\\n            if(q.front() !=NULL)\\n                return false;\\n            q.pop();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 331342,
                "title": "clean-and-easy-java-dfs-and-bfs-solution",
                "content": "There are basically two ways to solve this problem. The first one is DFS solution, which relys on the equal relationship two numbers: the number of nodes in tree and the largest node index in tree.    \\nFor example, index of root is 1, so it\\'s left child index is 2*1, right child is 2\\\\*1+1. And we record those two numbers. If they are the same, the tree is complete, else we will find maxindex > tree nodes.\\n```\\nclass Solution {\\n    int num; //the number node \\n    int index; //recored the largest index \\n    //for complete tree, max index == #node \\n    public boolean isCompleteTree(TreeNode root) {\\n        dfs(root, 1);\\n        return num == index; \\n    }\\n    public void dfs(TreeNode root, int cur){\\n        if(root == null) return; //leaf node \\n        //root != null\\n        num++;\\n        index = Math.max(index, cur);\\n        dfs(root.left, 2*cur);\\n        dfs(root.right, 2*cur+1);\\n    }\\n}\\n```\\nAnother way is level order traversal. If there are any solid nodes seperated by null node, tree is not complete. Therefore,use a boolean flag to represent if there has any null nodes before. If we met null but no solid node exist after that, it\\'s still a complete tree.\\n```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean flag = false; //if null appreared before \\n        Queue<TreeNode> queue = new LinkedList<>(); //arraydeque don\\'t allow null but linkedlist val can be null\\n        queue.offer(root);\\n        while(!queue.isEmpty()){\\n            TreeNode cur = queue.poll();\\n            if(cur == null){\\n                flag = true;\\n            }else if(flag == true){  \\n                return false;\\n            }else{ //cur != null but flag = true; null appreared before \\n                queue.offer(cur.left);\\n                queue.offer(cur.right);      \\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int num; //the number node \\n    int index; //recored the largest index \\n    //for complete tree, max index == #node \\n    public boolean isCompleteTree(TreeNode root) {\\n        dfs(root, 1);\\n        return num == index; \\n    }\\n    public void dfs(TreeNode root, int cur){\\n        if(root == null) return; //leaf node \\n        //root != null\\n        num++;\\n        index = Math.max(index, cur);\\n        dfs(root.left, 2*cur);\\n        dfs(root.right, 2*cur+1);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean flag = false; //if null appreared before \\n        Queue<TreeNode> queue = new LinkedList<>(); //arraydeque don\\'t allow null but linkedlist val can be null\\n        queue.offer(root);\\n        while(!queue.isEmpty()){\\n            TreeNode cur = queue.poll();\\n            if(cur == null){\\n                flag = true;\\n            }else if(flag == true){  \\n                return false;\\n            }else{ //cur != null but flag = true; null appreared before \\n                queue.offer(cur.left);\\n                queue.offer(cur.right);      \\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307377,
                "title": "python-bfs-with-explanation",
                "content": "O(n)\\nSpace: O(n)\\nAlgorithm: Do a BFS keeping track of the positions each node should occupy. If you have a completely filled tree the last element will be equal to exactly the length of the list, otherwise it means there was a gap earlier in the construction of the list.\\n\\n```\\ndef isCompleteTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return True\\n        res = []\\n        q = collections.deque([(root, 1)])\\n        while q:\\n            node, pos = q.popleft()\\n            res.append(pos)\\n            if node.left:\\n                q.append((node.left, 2 * pos))\\n            if node.right:\\n                q.append((node.right, 2 * pos + 1))\\n            \\n        return len(res) == res[-1]",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "O(n)\\nSpace: O(n)\\nAlgorithm: Do a BFS keeping track of the positions each node should occupy. If you have a completely filled tree the last element will be equal to exactly the length of the list, otherwise it means there was a gap earlier in the construction of the list.\\n\\n```\\ndef isCompleteTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return True\\n        res = []\\n        q = collections.deque([(root, 1)])\\n        while q:\\n            node, pos = q.popleft()\\n            res.append(pos)\\n            if node.left:\\n                q.append((node.left, 2 * pos))\\n            if node.right:\\n                q.append((node.right, 2 * pos + 1))\\n            \\n        return len(res) == res[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 205695,
                "title": "python-bfs-level-order-easy-to-understand",
                "content": "In order to determine whether a tree is complete visually, we essentially iterate level-order from left to right. This is accomplished in practice via a breadth first search, by enqueue-ing the left child before the right.\\n\\nThe key here is to find the first node that is missing a child - this determines that we have reached the lowest level. From here on, every visited node must have no children. Another key point to see is that we can never have a lone right child without a left child - if it were a complete tree, we could have swapped these children so the right is empty instead of the left.\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def isCompleteTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root: return True\\n    \\n        queue = deque()\\n        queue.append(root)\\n        end = False\\n        while queue:\\n            node = queue.popleft()\\n\\n            # should all be leaf nodes\\n            if end and (node.left or node.right): return False\\n\\n            # last level, all following nodes must be leaves\\n            if not node.right: end = True\\n\\n            # impossible to have empty left but present right\\n            elif not node.left: return False\\n\\n            if node.left:\\n                queue.append(node.left)\\n            if node.right:\\n                queue.append(node.right)\\n\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def isCompleteTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root: return True\\n    \\n        queue = deque()\\n        queue.append(root)\\n        end = False\\n        while queue:\\n            node = queue.popleft()\\n\\n            # should all be leaf nodes\\n            if end and (node.left or node.right): return False\\n\\n            # last level, all following nodes must be leaves\\n            if not node.right: end = True\\n\\n            # impossible to have empty left but present right\\n            elif not node.left: return False\\n\\n            if node.left:\\n                queue.append(node.left)\\n            if node.right:\\n                queue.append(node.right)\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667611,
                "title": "90-beats-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        int n;\\n        bool a = false;\\n        TreeNode* node;\\n        q.push(root);\\n        while(!q.empty()){\\n            n = q.size();\\n            while(n--){\\n                node = q.front();\\n                q.pop();\\n                if(a && (node->left || node->right))return false;\\n                if(node->left){\\n                    q.push(node->left);\\n                }else{\\n                    a = true;\\n                }\\n                if(a && node->right)return false;\\n                if(node->right){\\n                    q.push(node->right);\\n                }else{\\n                    a = true;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        int n;\\n        bool a = false;\\n        TreeNode* node;\\n        q.push(root);\\n        while(!q.empty()){\\n            n = q.size();\\n            while(n--){\\n                node = q.front();\\n                q.pop();\\n                if(a && (node->left || node->right))return false;\\n                if(node->left){\\n                    q.push(node->left);\\n                }else{\\n                    a = true;\\n                }\\n                if(a && node->right)return false;\\n                if(node->right){\\n                    q.push(node->right);\\n                }else{\\n                    a = true;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301367,
                "title": "java-bfs-explained",
                "content": "---\\n# Do let me know if you have any doubt! \\uD83D\\uDE07\\n*(Previous post got removed)*\\n\\n---\\n### Code:\\n```\\n// A BFS traverses in a \\'left to right\\' fashion at each level\\n// So if it sees a null, it should not see a unempty node after that null.\\n// All the unempty nodes should lie before the null, i.e. as left as possible\\n\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        // we haven\\'t seen a null\\n        boolean seenNull = false;\\n\\n        while (!q.isEmpty()) {\\n            TreeNode curr = q.poll();\\n            // if we see a null (node is null)\\n            if (curr == null) {\\n                seenNull = true;    // mark as seen\\n            } \\n            // node is not null\\n            else {\\n                // but if a null was encountered already\\n                if (seenNull) {\\n                    return false;   // not a complete tree\\n                }\\n                // otherwise, add the children to the queue\\n                q.offer(curr.left);\\n                q.offer(curr.right);\\n            }\\n        }\\n\\n        // If we never found a incompleteness within the tree,\\n        // then at the end return true\\n        return true;\\n    }\\n}\\n```\\n---\\n#### Clean solution:\\n```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        boolean seenNull = false;\\n\\n        while (!q.isEmpty()) {\\n            TreeNode curr = q.poll();\\n            if (curr == null) {\\n                seenNull = true; \\n            } else {\\n                if (seenNull) return false;  \\n                q.offer(curr.left);\\n                q.offer(curr.right);\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n---\\n##### Time complexity: $$O(n)$$\\n##### Space complexity: $$O(n)$$",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n// A BFS traverses in a \\'left to right\\' fashion at each level\\n// So if it sees a null, it should not see a unempty node after that null.\\n// All the unempty nodes should lie before the null, i.e. as left as possible\\n\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        // we haven\\'t seen a null\\n        boolean seenNull = false;\\n\\n        while (!q.isEmpty()) {\\n            TreeNode curr = q.poll();\\n            // if we see a null (node is null)\\n            if (curr == null) {\\n                seenNull = true;    // mark as seen\\n            } \\n            // node is not null\\n            else {\\n                // but if a null was encountered already\\n                if (seenNull) {\\n                    return false;   // not a complete tree\\n                }\\n                // otherwise, add the children to the queue\\n                q.offer(curr.left);\\n                q.offer(curr.right);\\n            }\\n        }\\n\\n        // If we never found a incompleteness within the tree,\\n        // then at the end return true\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        boolean seenNull = false;\\n\\n        while (!q.isEmpty()) {\\n            TreeNode curr = q.poll();\\n            if (curr == null) {\\n                seenNull = true; \\n            } else {\\n                if (seenNull) return false;  \\n                q.offer(curr.left);\\n                q.offer(curr.right);\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300691,
                "title": "tc-100-python-solution-using-bfs-traversal",
                "content": "![image.png](https://assets.leetcode.com/users/images/f7a9a2e7-c559-4c03-bbd2-8193a998c682_1678893049.0493286.png)\\n\\n\\n# Intuition\\nUsing BFS Traversal we can search level by level.\\n\\n# Approach\\nFollow the below steps :\\n1. Traverse through Level-by-Level\\n2. To check whether the last level is filled from left to right or not.\\n3. if we found a $$NULL$$ in the queue,\\n    i.  loop through the queue, to check whether we have any elements after the $$NULL$$ or not. if so, return $$False$$\\n    ii. else append the left and right node of the current node to the queue.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        q = deque([root])\\n\\n        while q:\\n            node = q.popleft()\\n            if node:\\n                q.append(node.left)\\n                q.append(node.right)\\n            else:\\n                while q:\\n                    if q.popleft():\\n                        return False\\n        \\n        return True        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        q = deque([root])\\n\\n        while q:\\n            node = q.popleft()\\n            if node:\\n                q.append(node.left)\\n                q.append(node.right)\\n            else:\\n                while q:\\n                    if q.popleft():\\n                        return False\\n        \\n        return True        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300310,
                "title": "simple-java-bfs-full-explanation-faster-100",
                "content": "COMPLETE BINARY TREE MEANS IT SHOULD HAVE NODE AT EACH LEVEL WHERE NO OF NODES EQUAL TO 2^LEVEL(WHERE LEVEL START FROM ZERO). BUT AT LAST LEVEL IT CAN HAVE ANY NUMBER BUT FROM LEFT TO RIGHT.\\n\\nSO WE CAN THINK THAT EXCEPT LAST LEVEL UPPER EVERY LEVEL WOULD BE FULL AND IT WILL NOT CONTAIN ANY NULL VALUE IF IT CONTAINS THEN IT NOT A COMPLETE BINARY TREE.\\n\\nNOW LET\\'S LOOK FOR LAST LEVEL. IT CONSIST OF TWO CASES  1) ALL ARE ON LEFT SIDE THEN RETURN TRUE\\nELSE \\nCASE 2) THERE MUS BE A NODE WHERE WHICH IS VIOLATING THE CONDITION i.e.(all nodes from left to right must be filled).SO IN THIS CASE DEFINITELY OUR QUEUE WILL NOT BE EMPTY AND WE WILL ENCOUNTER A NULL AND QUEUE PEEK WILL BE HAVING AN ELEMENT.SO RETURN FALSE.\\n\\n\\n\\n```\\n\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        \\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        int lev=0;\\n        int count=0;\\n        while(q.isEmpty()==false)\\n        {\\n            \\n           TreeNode node=q.remove();\\n            \\n            if(node==null&&q.peek()!=null)return false;\\n            \\n             if(node!=null)\\n             {\\n              q.add(node.left);\\n              q.add(node.right);\\n             }\\n            \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        \\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        int lev=0;\\n        int count=0;\\n        while(q.isEmpty()==false)\\n        {\\n            \\n           TreeNode node=q.remove();\\n            \\n            if(node==null&&q.peek()!=null)return false;\\n            \\n             if(node!=null)\\n             {\\n              q.add(node.left);\\n              q.add(node.right);\\n             }\\n            \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299863,
                "title": "c-solution-100-faster-beginner-friendly-solution-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n> __In a complete binary tree, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2^h nodes inclusive at the last level h.\\nThe idea is to store every level and check every node in the current level for a left and right child__\\n\\n\\n# Approach\\n1. Using BFS store each level in a queue\\n2. For every parent there must be two children except the last nodes parent, it can have only one child or no children\\n3. Some conditions to keep in mind:\\n- The left child has to be there if a node has children nodes\\n- only the last node in the second-last level can have 0 or 1 child nodes, other than that all must have 2 child nodes , except the leaf nodes(the nodes where the tree path ends).\\n- If some right child of a node from a level is absent, it has to be the last node of the second-last level for the tree .\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n\\n# Code\\n```\\nclass Solution // 100% faster\\n{\\npublic:\\n    bool isCompleteTree(TreeNode *root)\\n    {\\n        queue<TreeNode *> q; // Create a queue to store the nodes\\n        q.push(root);        // Push the root node\\n        int right_child = 1; // Initially Assume that both the left and right child nodes exist\\n        do\\n        {\\n            int x = q.size(); // Get the size of the queue\\n            for (int i = 0; i < x; i++)\\n            {\\n                TreeNode *parent = q.front(); // Store the parent node\\n                q.pop();                      // Pop it from the queue\\n                int left_child = 1;           // Assume that the left child exists\\n                if (parent->left)             // If the left child actually exists\\n                {\\n                    // If previously some right child was absent\\n                    // Return false,\\n                    // Only the last node (right most) of the last level can be a absent\\n                    // And if some right child from a level is absent,\\n                    // It has to be the last level for the tree to be complete\\n                    // Otherwise the tree is not complete!\\n                    if (!right_child)\\n                        return false;\\n                    q.push(parent->left); // Push the left child into the queue\\n                }\\n                else\\n                    // Set the left_child as 0\\n                    // For a tree to be complete, if a left child is absent\\n                    // No other nodes should have any children\\n                    left_child = 0;\\n                if (parent->right) // If the right child exists\\n                {\\n                    // Check if its sibling node was not absent\\n                    // If a sibling node of the right child is absent\\n                    // The tree is not complete,\\n                    // Hence false should be returned\\n                    if (!left_child)\\n                        return false;\\n                    // If the sibling exists, push the right child into the queue\\n                    q.push(parent->right);\\n                }\\n                else\\n                    // If the right child is absent\\n                    // Set the right_child as 0\\n                    right_child = 0;\\n            }\\n        } while (!q.empty());\\n        // If no anomalies exist, return true\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution // 100% faster\\n{\\npublic:\\n    bool isCompleteTree(TreeNode *root)\\n    {\\n        queue<TreeNode *> q; // Create a queue to store the nodes\\n        q.push(root);        // Push the root node\\n        int right_child = 1; // Initially Assume that both the left and right child nodes exist\\n        do\\n        {\\n            int x = q.size(); // Get the size of the queue\\n            for (int i = 0; i < x; i++)\\n            {\\n                TreeNode *parent = q.front(); // Store the parent node\\n                q.pop();                      // Pop it from the queue\\n                int left_child = 1;           // Assume that the left child exists\\n                if (parent->left)             // If the left child actually exists\\n                {\\n                    // If previously some right child was absent\\n                    // Return false,\\n                    // Only the last node (right most) of the last level can be a absent\\n                    // And if some right child from a level is absent,\\n                    // It has to be the last level for the tree to be complete\\n                    // Otherwise the tree is not complete!\\n                    if (!right_child)\\n                        return false;\\n                    q.push(parent->left); // Push the left child into the queue\\n                }\\n                else\\n                    // Set the left_child as 0\\n                    // For a tree to be complete, if a left child is absent\\n                    // No other nodes should have any children\\n                    left_child = 0;\\n                if (parent->right) // If the right child exists\\n                {\\n                    // Check if its sibling node was not absent\\n                    // If a sibling node of the right child is absent\\n                    // The tree is not complete,\\n                    // Hence false should be returned\\n                    if (!left_child)\\n                        return false;\\n                    // If the sibling exists, push the right child into the queue\\n                    q.push(parent->right);\\n                }\\n                else\\n                    // If the right child is absent\\n                    // Set the right_child as 0\\n                    right_child = 0;\\n            }\\n        } while (!q.empty());\\n        // If no anomalies exist, return true\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299586,
                "title": "level-order-traversal-using-bfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust do a level order traversal using BFS and if you find there is any NULL value between two elements in a level return false.\\n***SUPERR EASY!***\\n\\n\\n\\n# Complexity\\n- Time complexity: O(V+E)+O(N)=O(N+2)+O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)+O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        vector<TreeNode*> ans;\\n        ans.push_back(root);\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* temp=q.front();q.pop();\\n            if(temp==NULL)continue;\\n            q.push(temp->left);\\n            ans.push_back(temp->left);\\n            q.push(temp->right);\\n            ans.push_back(temp->right);\\n        }\\n        int i=0;int lock=0;\\n        while(i<ans.size()){\\n            if(ans[i]==NULL)lock=1;\\n            else if(lock==1)return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n---\\n\\n***UPVOTE PLEASE IF THIS WAS HELPFUL***",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        vector<TreeNode*> ans;\\n        ans.push_back(root);\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* temp=q.front();q.pop();\\n            if(temp==NULL)continue;\\n            q.push(temp->left);\\n            ans.push_back(temp->left);\\n            q.push(temp->right);\\n            ans.push_back(temp->right);\\n        }\\n        int i=0;int lock=0;\\n        while(i<ans.size()){\\n            if(ans[i]==NULL)lock=1;\\n            else if(lock==1)return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299390,
                "title": "99-faster-python-solution-dfs-easy-and-short-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNodes can be numbered levelwise and if it can be done correctly, a perfect binary tree would have all the node id\\'s in sequence\\n\\nLet\\'s say the tree should look like this:-\\n```\\n        1\\n     /     \\\\\\n    2        3\\n /    \\\\    /    \\\\\\n4      5  6       7\\n```\\nNotice that parent.left\\'s id is always 2\\\\*parent\\'s id and parent.right\\'s id is always 2\\\\*parent+1\\n\\nIn this way we can identify all the nodes sequentially. Even more, each level basically contains all the numbers of 2^LVL. i.e: 0th level has 2^0=1 node, 1st level has 2^1=2 nodes and 2nd level has 2^2=4 nodes.\\n\\nSo, if any of them goes out of sequence it only means there\\'s an intermediate left or right child that\\'s missing and making the tree incomplete. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe iterate in the mentioned approach and number the node id\\'s accordingly and finally check if all the numbers are sequential.\\n\\nif node.id = 1\\nnode.left.id = 1\\\\*2 = 2\\nnode.right.id = 1\\\\*2+1 = 3\\n\\nWe always endup having unique numbers in this way, so after numbering them all we can just check if max(id) == count(nodes)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        node_ids = []\\n        def iterate(root, id = 1):\\n            if not root: return\\n            node_ids.append(id)\\n            iterate(root.left, id<<1)\\n            iterate(root.right, id<<1|1)\\n        \\n        iterate(root)\\n        return max(node_ids) == len(node_ids)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n        1\\n     /     \\\\\\n    2        3\\n /    \\\\    /    \\\\\\n4      5  6       7\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        node_ids = []\\n        def iterate(root, id = 1):\\n            if not root: return\\n            node_ids.append(id)\\n            iterate(root.left, id<<1)\\n            iterate(root.right, id<<1|1)\\n        \\n        iterate(root)\\n        return max(node_ids) == len(node_ids)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299314,
                "title": "rust-bfs-solution",
                "content": "So Approach is very simple. We are making bfs left - right for every level. When we found first None, all others nodes must be also None\\n\\n# Code\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nuse std::collections::VecDeque;\\nimpl Solution {\\n    pub fn is_complete_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let mut deq = VecDeque::from([root]);\\n        let mut is_none = false;\\n        while let Some(node) = deq.pop_front() {\\n            match node {\\n                Some(node) =>  {\\n                    if is_none {\\n                        return false\\n                    }\\n                    let node = node.borrow();\\n                    deq.push_back(node.left.clone());\\n                    deq.push_back(node.right.clone());\\n                },\\n                None =>  {\\n                    is_none = true;\\n                },\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nuse std::collections::VecDeque;\\nimpl Solution {\\n    pub fn is_complete_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let mut deq = VecDeque::from([root]);\\n        let mut is_none = false;\\n        while let Some(node) = deq.pop_front() {\\n            match node {\\n                Some(node) =>  {\\n                    if is_none {\\n                        return false\\n                    }\\n                    let node = node.borrow();\\n                    deq.push_back(node.left.clone());\\n                    deq.push_back(node.right.clone());\\n                },\\n                None =>  {\\n                    is_none = true;\\n                },\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3299052,
                "title": "simple-bfs-queue-o-n-approach-with-explanation",
                "content": "# **Simple BFS Approach!!**\\nAuthor:- Yash Gaherwar\\n# Approach\\nStandard BFS (Breadth First Search Approach)\\n1. Approach is to maintain one flag variable and check whether we encountered any NULL value or not.\\n2. If we encounter any NULL value then we set flag as true.\\n3. Suppose if after that we encounter any value other than NULL. Then this means that the tree is not complete and hence we return false.\\n4. It means that the all the leaf nodes are not left alignd. Hence answer is false otherwise simply return true.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    bool isCompleteTree(TreeNode* root) {\\n        if(root==NULL){\\n            return true;\\n        }\\n\\n        int flag=0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        while(q.size()>0){\\n            TreeNode* nd=q.front();\\n            q.pop();\\n\\n            // If first NULL is encounter then set flag as 1\\n            if(nd==NULL){\\n                flag=1;\\n            }\\n            else{\\n            // If already in past we encounter NULL this means that tree is not Complete Binary Tree\\n                if(flag==1){\\n                    return false;\\n                }\\n\\n                q.push(nd->left);\\n                q.push(nd->right);\\n            }\\n        }\\n\\n        return true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    bool isCompleteTree(TreeNode* root) {\\n        if(root==NULL){\\n            return true;\\n        }\\n\\n        int flag=0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        while(q.size()>0){\\n            TreeNode* nd=q.front();\\n            q.pop();\\n\\n            // If first NULL is encounter then set flag as 1\\n            if(nd==NULL){\\n                flag=1;\\n            }\\n            else{\\n            // If already in past we encounter NULL this means that tree is not Complete Binary Tree\\n                if(flag==1){\\n                    return false;\\n                }\\n\\n                q.push(nd->left);\\n                q.push(nd->right);\\n            }\\n        }\\n\\n        return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298614,
                "title": "java-bfs-beats-80",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public boolean isCompleteTree(TreeNode root) {\\n    var flag = false;\\n    var queue = new ArrayDeque<TreeNode>();\\n    queue.offer(root);\\n\\n    while(!queue.isEmpty()) {\\n      for (var i = queue.size(); i > 0; i--) {\\n        var node = queue.poll();\\n\\n        if (node.left == null)\\n          flag = true;\\n        else if (flag)\\n          return false;\\n        else\\n          queue.offer(node.left);\\n        \\n        if (node.right == null)\\n          flag = true;\\n        else if (flag)\\n          return false;\\n        else\\n          queue.offer(node.right);\\n      }\\n    }\\n    return true;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n  public boolean isCompleteTree(TreeNode root) {\\n    var flag = false;\\n    var queue = new ArrayDeque<TreeNode>();\\n    queue.offer(root);\\n\\n    while(!queue.isEmpty()) {\\n      for (var i = queue.size(); i > 0; i--) {\\n        var node = queue.poll();\\n\\n        if (node.left == null)\\n          flag = true;\\n        else if (flag)\\n          return false;\\n        else\\n          queue.offer(node.left);\\n        \\n        if (node.right == null)\\n          flag = true;\\n        else if (flag)\\n          return false;\\n        else\\n          queue.offer(node.right);\\n      }\\n    }\\n    return true;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298601,
                "title": "easy-intuitive-approach-c-dfs",
                "content": "### Please upvote this post if it helps you\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA complete binary tree is one in which all levels are completely filled, with the exception of the bottom-most level, which is filled from left to right. This means that in a complete binary tree, all nodes are located as far to the left as possible, and the tree\\'s bottom level is filled from left to right.\\n\\nTo begin, the programme defines two helper functions: countNodes and isCBT.\\n\\n```countNodes``` returns the total number of nodes in the tree by recursively counting the number of nodes in each node\\'s left and right subtrees.\\n\\n```isCBT``` is the primary function that determines whether the binary tree is complete or not. It takes three arguments: \\n```(int i, TreeNode* root, int n) ```\\nIt recursively checks whether each node in the binary tree is within the bounds of a complete binary tree by traversing each node\\'s left and right subtrees. If a node is found that is outside the bounds, the function returns false, indicating that the binary tree is not complete. Otherwise, if all nodes are within the bounds, the function returns true.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(h)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root){\\n        if(root == NULL)    return 0;\\n        return countNodes(root->left)+countNodes(root->right)+1;\\n    }\\n\\n    bool isCBT(int i, TreeNode* root, int n){\\n        if(root == NULL)\\n            return true;\\n        if(i >= n)\\n            return false;\\n        else{\\n            bool left = isCBT(2*i+1, root->left, n);\\n            bool right = isCBT(2*i+2, root->right, n);\\n            return (left && right);\\n        }\\n    }\\n\\n    bool isCompleteTree(TreeNode* root) {\\n        int n = countNodes(root);\\n        return isCBT(0, root, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```countNodes```\n```isCBT```\n```(int i, TreeNode* root, int n) ```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int countNodes(TreeNode* root){\\n        if(root == NULL)    return 0;\\n        return countNodes(root->left)+countNodes(root->right)+1;\\n    }\\n\\n    bool isCBT(int i, TreeNode* root, int n){\\n        if(root == NULL)\\n            return true;\\n        if(i >= n)\\n            return false;\\n        else{\\n            bool left = isCBT(2*i+1, root->left, n);\\n            bool right = isCBT(2*i+2, root->right, n);\\n            return (left && right);\\n        }\\n    }\\n\\n    bool isCompleteTree(TreeNode* root) {\\n        int n = countNodes(root);\\n        return isCBT(0, root, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298543,
                "title": "python-c-c-simple-and-fast-bonus-true-non-clickbait-o-1-space-solution",
                "content": "# Intuition\\nIf we know the depth of the left most branch, we know that the depth can never be more than this.\\n\\nIt can be one less than this, but once it is less, it must stay 1 less.\\n\\n# Approach\\n- Get the depth of the left most branch\\n- Call a recursive function that will try each branch and ensure it matches the target depth from above\\n- If a leaf depth is less than `target_depth` and we haven\\'t done so already, decrease `target_depth` by 1.\\n- Check if each leaf depth equals `target_depth`\\n\\nA minor improvement could be made such that early termination could be done as soon as the depth is over `target_depth`, that is, before reaching a node. I don\\'t think this is worth doing as waiting to reach the leaf is not much extra time, but doing the early bail would require an extra compare for each node. \\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(h) (where _h_ is the height of the tree)\\n\\nEach node must be visited, so time is O(n)\\n\\nNeed to recurse upto the height of the tree, so need stack space based on the height. This will be O(logn) if the tree is roughly balanced, but could be O(n) if it\\'s completely unbalanced.\\n\\n**Since python doesn\\'t (really) support pass by reference, I solved it iteratively, using `todo` as a stack to allow for updating `used` and `target`.**\\n\\nThe problem could be done in O(1) space using a Morris Traversal. ~~I might look at adding that later.~~ Added a Morris Traversal solution.\\n\\n# Code\\n```python []\\ndef isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n  # Calculate the depth of the left most branch\\n  target = 0\\n  curr = root\\n  while curr:\\n    curr = curr.left\\n    target += 1\\n\\n  todo = [[root, 0]]\\n  used = False\\n  while todo:\\n    node, depth = todo[-1]\\n    todo.pop()\\n    if not node:\\n      # Reduce the target depth now if we\\'re under and have not done it yet\\n      if not used and depth < target:\\n        used = True\\n        target -= 1\\n      if depth != target:\\n        return False\\n    else :\\n      # Add to the stack right first so that left must get processed before right\\n      todo.append([node.right, depth + 1])\\n      todo.append([node.left, depth + 1])\\n  return True\\n```\\n```c []\\nint is_complete_tree_helper(struct TreeNode* root, int curr_depth, int* target_depth, bool* used) {\\n  if (!root) {\\n    /* Reduce the target depth now if we\\'re under and have not done it yet */\\n    if (!*used && curr_depth < *target_depth) {\\n      *used = true;\\n      --*target_depth;\\n    }\\n    return (curr_depth == *target_depth);\\n  }\\n  return (is_complete_tree_helper(root->left, curr_depth + 1, target_depth, used)) && (is_complete_tree_helper(root->right, curr_depth + 1, target_depth, used));\\n}\\n\\nbool isCompleteTree(struct TreeNode* root){\\n  bool used = false;\\n  /* Find the depth of the left most branch, everything must be this or 1 less */\\n  int depth = 0;\\n  for (struct TreeNode* node = root; node; node = node->left) {\\n    ++depth;\\n  }\\n  return is_complete_tree_helper(root, 0, &depth, &used);\\n}\\n```\\n```cpp []\\nint is_complete_tree_helper(struct TreeNode* root, int curr_depth, int& target_depth, bool& used) {\\n  if (!root) {\\n    // Reduce the target depth now if we\\'re under and have not done it yet\\n    if (!used && curr_depth < target_depth) {\\n      used = true;\\n      --target_depth;\\n    }\\n    return (curr_depth == target_depth);\\n  }\\n  return (is_complete_tree_helper(root->left, curr_depth + 1, target_depth, used)) && (is_complete_tree_helper(root->right, curr_depth + 1, target_depth, used));\\n}\\n\\nbool isCompleteTree(TreeNode* root) {\\n  bool used = false;\\n  // Find the depth of the left most branch, everything must be this or 1 less\\n  int depth = 0;\\n  for (auto* node = root; node; node = node->left) {\\n    ++depth;\\n  }\\n  return is_complete_tree_helper(root, 0, depth, used);\\n}\\n```\\n# Morris Traversal, O(n) Time, O(1) Space\\nJust for fun, and since others were clickbaiting with \"constant space\" solutions that weren\\'t, I decided to do an actual constant space solution.\\n\\nThe solutions is more complex, but uses an algorithm called a Morris Traversal. I won\\'t go into too much detail, but it relies on borrowing the NULL right branch to create a link back up the tree to the parent. Each time I have to move back up the tree, I need to remove the temporary link on the right branch and set it back to NULL. The fact that the right branch is modified means the entire tree must be processed before returning our result, otherwise the tree will not be restored.\\n\\nOther than using Morris Traversal, the solution is based on the same idea as the above.\\n\\n```python []\\ndef isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n  # Calculate the depth of the left most branch\\n  target = 0\\n  curr = root\\n  while curr:\\n    curr = curr.left\\n    target += 1\\n\\n  used = False\\n\\n  def helper(depth: int) -> bool:\\n    nonlocal target\\n    nonlocal used\\n    # Reduce the target depth now if we\\'re under and have not done it yet\\n    if not used and depth < target: \\n      used = True\\n      target -= 1\\n    return depth == target    \\n\\n  # Use a Moris Traversal to process check the depth of the leaf nodes\\n  ret = True;\\n  depth = 1;\\n  while root:\\n    if not root.left:\\n      # Reached an empty left branch, check it\\'s valid\\n      ret = ret and helper(depth)\\n      root = root.right\\n      depth += 1\\n    else:        \\n      pre = root.left\\n      steps = 1\\n      while pre.right != root and pre.right:\\n        steps += 1\\n        pre = pre.right;\\n\\n      if pre.right != root:\\n        # First time visiting root, set a temp link back to the root\\n        pre.right = root\\n        root = root.left\\n        depth += 1\\n      else:\\n        # Second time visiting root, check the right most of the left branch \\n        ret = ret and helper(depth - 1)\\n        # Taking our temp link will reduce our depth\\n        depth -= steps\\n        # Remove temp link\\n        pre.right = None\\n        root = root.right\\n\\n  # Need one final check to check the right most branch. The depth will be over incremented\\n  return ret and helper(depth - 1)\\n```\\n```c []\\nstatic\\nbool is_complete_tree_helper(int depth, int* target, bool* used) {\\n  /* Reduce the target depth now if we\\'re under and have not done it yet */\\n  if (!*used && depth < *target) {\\n    *used = true;\\n    --*target;\\n  }\\n  return (depth == *target);\\n}\\n\\nbool isCompleteTree(struct TreeNode* root) {\\n  /* Find the depth of the left most branch, everything must be this or 1 less */\\n  int target = 0;\\n  for (struct TreeNode* node = root; node; node = node->left) {\\n    ++target;\\n  }\\n\\n  /* Use a Moris Traversal to process check the depth of the leaf nodes */\\n  int ret = true;\\n  bool used = false;\\n  int depth = 1;\\n  while (root) {\\n    if (root->left) {\\n      struct TreeNode* pre = root->left;\\n      int steps = 1;\\n      while (pre->right != root && pre->right) {\\n        ++steps;\\n        pre = pre->right;\\n      }\\n\\n      if (pre->right != root) {\\n        /* First time visiting root, set a temp link back to the root */\\n        pre->right = root;\\n        root = root->left;\\n        ++depth;\\n      } else {\\n        /* Second time visiting root, check the right most of the left branch */\\n        ret &= is_complete_tree_helper(depth - 1, &target, &used);\\n        /* Taking our temp link will reduce our depth */\\n        depth -= steps;\\n        /* Remove temp link */\\n        pre->right = NULL;\\n        root = root->right;\\n      }\\n    } else {\\n      /* Reached an empty left branch, check it\\'s valid */\\n      ret &= is_complete_tree_helper(depth, &target, &used);\\n      root = root->right;\\n      ++depth;\\n    }\\n  }\\n  /* Need one final check to check the right most branch. The depth will be over incremented */\\n  return ret && is_complete_tree_helper(depth - 1, &target, &used);\\n}\\n```\\n```cpp []\\nbool isCompleteTree(TreeNode* root) {\\n  int target = 0;\\n  // Find the depth of the left most branch, everything must be this or 1 less\\n  for (auto* node = root; node; node = node->left) {\\n    ++target;\\n  }\\n\\n  bool used = false;\\n  auto helper = [&used, &target] (int depth) -> bool {\\n      // Reduce the target depth now if we\\'re under and have not done it yet\\n      if (!used && depth < target) {\\n        used = true;\\n        --target;\\n      }\\n      return (depth == target);    \\n    };\\n\\n  // Use a Moris Traversal to process check the depth of the leaf nodes\\n  int ret = true;\\n  int depth = 1;\\n  while (root) {\\n    if (root->left) {\\n      auto* pre = root->left;\\n      int steps = 1;\\n      while (pre->right != root && pre->right) {\\n        ++steps;\\n        pre = pre->right;\\n      }\\n\\n      if (pre->right != root) {\\n        // First time visiting root, set a temp link back to the root\\n        pre->right = root;\\n        root = root->left;\\n        ++depth;\\n      } else {\\n        // Second time visiting root, check the right most of the left branch \\n        ret &= helper(depth - 1);\\n        // Taking our temp link will reduce our depth\\n        depth -= steps;\\n        // Remove temp link\\n        pre->right = nullptr;\\n        root = root->right;\\n      }\\n    } else {\\n      // Reached an empty left branch, check it\\'s valid\\n      ret &= helper(depth);\\n      root = root->right;\\n      ++depth;\\n    }\\n  }\\n  // Need one final check to check the right most branch. The depth will be over incremented\\n  return ret && helper(depth - 1);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C"
                ],
                "code": "```python []\\ndef isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n  # Calculate the depth of the left most branch\\n  target = 0\\n  curr = root\\n  while curr:\\n    curr = curr.left\\n    target += 1\\n\\n  todo = [[root, 0]]\\n  used = False\\n  while todo:\\n    node, depth = todo[-1]\\n    todo.pop()\\n    if not node:\\n      # Reduce the target depth now if we\\'re under and have not done it yet\\n      if not used and depth < target:\\n        used = True\\n        target -= 1\\n      if depth != target:\\n        return False\\n    else :\\n      # Add to the stack right first so that left must get processed before right\\n      todo.append([node.right, depth + 1])\\n      todo.append([node.left, depth + 1])\\n  return True\\n```\n```c []\\nint is_complete_tree_helper(struct TreeNode* root, int curr_depth, int* target_depth, bool* used) {\\n  if (!root) {\\n    /* Reduce the target depth now if we\\'re under and have not done it yet */\\n    if (!*used && curr_depth < *target_depth) {\\n      *used = true;\\n      --*target_depth;\\n    }\\n    return (curr_depth == *target_depth);\\n  }\\n  return (is_complete_tree_helper(root->left, curr_depth + 1, target_depth, used)) && (is_complete_tree_helper(root->right, curr_depth + 1, target_depth, used));\\n}\\n\\nbool isCompleteTree(struct TreeNode* root){\\n  bool used = false;\\n  /* Find the depth of the left most branch, everything must be this or 1 less */\\n  int depth = 0;\\n  for (struct TreeNode* node = root; node; node = node->left) {\\n    ++depth;\\n  }\\n  return is_complete_tree_helper(root, 0, &depth, &used);\\n}\\n```\n```cpp []\\nint is_complete_tree_helper(struct TreeNode* root, int curr_depth, int& target_depth, bool& used) {\\n  if (!root) {\\n    // Reduce the target depth now if we\\'re under and have not done it yet\\n    if (!used && curr_depth < target_depth) {\\n      used = true;\\n      --target_depth;\\n    }\\n    return (curr_depth == target_depth);\\n  }\\n  return (is_complete_tree_helper(root->left, curr_depth + 1, target_depth, used)) && (is_complete_tree_helper(root->right, curr_depth + 1, target_depth, used));\\n}\\n\\nbool isCompleteTree(TreeNode* root) {\\n  bool used = false;\\n  // Find the depth of the left most branch, everything must be this or 1 less\\n  int depth = 0;\\n  for (auto* node = root; node; node = node->left) {\\n    ++depth;\\n  }\\n  return is_complete_tree_helper(root, 0, depth, used);\\n}\\n```\n```python []\\ndef isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n  # Calculate the depth of the left most branch\\n  target = 0\\n  curr = root\\n  while curr:\\n    curr = curr.left\\n    target += 1\\n\\n  used = False\\n\\n  def helper(depth: int) -> bool:\\n    nonlocal target\\n    nonlocal used\\n    # Reduce the target depth now if we\\'re under and have not done it yet\\n    if not used and depth < target: \\n      used = True\\n      target -= 1\\n    return depth == target    \\n\\n  # Use a Moris Traversal to process check the depth of the leaf nodes\\n  ret = True;\\n  depth = 1;\\n  while root:\\n    if not root.left:\\n      # Reached an empty left branch, check it\\'s valid\\n      ret = ret and helper(depth)\\n      root = root.right\\n      depth += 1\\n    else:        \\n      pre = root.left\\n      steps = 1\\n      while pre.right != root and pre.right:\\n        steps += 1\\n        pre = pre.right;\\n\\n      if pre.right != root:\\n        # First time visiting root, set a temp link back to the root\\n        pre.right = root\\n        root = root.left\\n        depth += 1\\n      else:\\n        # Second time visiting root, check the right most of the left branch \\n        ret = ret and helper(depth - 1)\\n        # Taking our temp link will reduce our depth\\n        depth -= steps\\n        # Remove temp link\\n        pre.right = None\\n        root = root.right\\n\\n  # Need one final check to check the right most branch. The depth will be over incremented\\n  return ret and helper(depth - 1)\\n```\n```c []\\nstatic\\nbool is_complete_tree_helper(int depth, int* target, bool* used) {\\n  /* Reduce the target depth now if we\\'re under and have not done it yet */\\n  if (!*used && depth < *target) {\\n    *used = true;\\n    --*target;\\n  }\\n  return (depth == *target);\\n}\\n\\nbool isCompleteTree(struct TreeNode* root) {\\n  /* Find the depth of the left most branch, everything must be this or 1 less */\\n  int target = 0;\\n  for (struct TreeNode* node = root; node; node = node->left) {\\n    ++target;\\n  }\\n\\n  /* Use a Moris Traversal to process check the depth of the leaf nodes */\\n  int ret = true;\\n  bool used = false;\\n  int depth = 1;\\n  while (root) {\\n    if (root->left) {\\n      struct TreeNode* pre = root->left;\\n      int steps = 1;\\n      while (pre->right != root && pre->right) {\\n        ++steps;\\n        pre = pre->right;\\n      }\\n\\n      if (pre->right != root) {\\n        /* First time visiting root, set a temp link back to the root */\\n        pre->right = root;\\n        root = root->left;\\n        ++depth;\\n      } else {\\n        /* Second time visiting root, check the right most of the left branch */\\n        ret &= is_complete_tree_helper(depth - 1, &target, &used);\\n        /* Taking our temp link will reduce our depth */\\n        depth -= steps;\\n        /* Remove temp link */\\n        pre->right = NULL;\\n        root = root->right;\\n      }\\n    } else {\\n      /* Reached an empty left branch, check it\\'s valid */\\n      ret &= is_complete_tree_helper(depth, &target, &used);\\n      root = root->right;\\n      ++depth;\\n    }\\n  }\\n  /* Need one final check to check the right most branch. The depth will be over incremented */\\n  return ret && is_complete_tree_helper(depth - 1, &target, &used);\\n}\\n```\n```cpp []\\nbool isCompleteTree(TreeNode* root) {\\n  int target = 0;\\n  // Find the depth of the left most branch, everything must be this or 1 less\\n  for (auto* node = root; node; node = node->left) {\\n    ++target;\\n  }\\n\\n  bool used = false;\\n  auto helper = [&used, &target] (int depth) -> bool {\\n      // Reduce the target depth now if we\\'re under and have not done it yet\\n      if (!used && depth < target) {\\n        used = true;\\n        --target;\\n      }\\n      return (depth == target);    \\n    };\\n\\n  // Use a Moris Traversal to process check the depth of the leaf nodes\\n  int ret = true;\\n  int depth = 1;\\n  while (root) {\\n    if (root->left) {\\n      auto* pre = root->left;\\n      int steps = 1;\\n      while (pre->right != root && pre->right) {\\n        ++steps;\\n        pre = pre->right;\\n      }\\n\\n      if (pre->right != root) {\\n        // First time visiting root, set a temp link back to the root\\n        pre->right = root;\\n        root = root->left;\\n        ++depth;\\n      } else {\\n        // Second time visiting root, check the right most of the left branch \\n        ret &= helper(depth - 1);\\n        // Taking our temp link will reduce our depth\\n        depth -= steps;\\n        // Remove temp link\\n        pre->right = nullptr;\\n        root = root->right;\\n      }\\n    } else {\\n      // Reached an empty left branch, check it\\'s valid\\n      ret &= helper(depth);\\n      root = root->right;\\n      ++depth;\\n    }\\n  }\\n  // Need one final check to check the right most branch. The depth will be over incremented\\n  return ret && helper(depth - 1);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3298514,
                "title": "c-bfs-easiest-solution-beats-96",
                "content": "# Intuition\\nIn breadth first search, a complete tree will have no non-null nodes after the first one.\\n\\n# Approach\\nAdd all nodes and their children to the bfs queue. When we dequeue the first null node, check if anything left in queue is non-null. If there are, we don\\'t have a complete tree.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsCompleteTree(TreeNode root) {\\n        \\n        Queue<TreeNode> bfs = new Queue<TreeNode>();\\n        bfs.Enqueue(root);\\n\\n        while (bfs.Any())\\n        {\\n            var node = bfs.Dequeue();\\n\\n            if (node == null)\\n                return !bfs.Any(x => x != null);\\n\\n            bfs.Enqueue(node.left);\\n            bfs.Enqueue(node.right);                    \\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsCompleteTree(TreeNode root) {\\n        \\n        Queue<TreeNode> bfs = new Queue<TreeNode>();\\n        bfs.Enqueue(root);\\n\\n        while (bfs.Any())\\n        {\\n            var node = bfs.Dequeue();\\n\\n            if (node == null)\\n                return !bfs.Any(x => x != null);\\n\\n            bfs.Enqueue(node.left);\\n            bfs.Enqueue(node.right);                    \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298199,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt refers to the instinctive understanding of something, based on our past experience, knowledge, and common sense. In algorithm design, intuition helps us come up with ideas and insights on how to solve a problem efficiently.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in this solution is to traverse the binary tree level by level using a queue. Starting with the root node, we add it to the queue and keep track of whether we have encountered any null nodes. We then continue dequeuing nodes from the queue and add their children to the queue. If we encounter a null node and we have not previously encountered one, we set a flag indicating that we have reached the end of the complete binary tree. If we encounter a non-null node after the flag has been set, we know that the binary tree is not complete.\\n\\nAt the end of the traversal, if we have not encountered any such scenario, we know that the binary tree is complete.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this approach is $$O(n)$$ where n is the number of nodes in the binary tree. \\n- Space complexity:\\nThe space complexity is $$O(n)$$ since we are using a queue to store the nodes.\\n\\n\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n``` Java []\\n\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if (root == null) {\\n            return true;\\n        }\\n\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        boolean end = false;\\n        while (!queue.isEmpty()) {\\n            TreeNode curr = queue.poll();\\n            if (curr == null) {\\n                end = true;\\n            } else {\\n                if (end) {\\n                    return false;\\n                }\\n                queue.offer(curr.left);\\n                queue.offer(curr.right);\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n\\n```\\n```Python []\\nclass Solution(object):\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return True\\n        \\n        q = deque([root])\\n        end = False\\n        \\n        while q:\\n            node = q.popleft()\\n            if not node:\\n                end = True\\n            else:\\n                if end:\\n                    return False\\n                q.append(node.left)\\n                q.append(node.right)\\n        \\n        return True\\n\\n\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        std::queue<TreeNode*> q;\\n        q.push(root);\\n        bool end = false;\\n\\n        while (!q.empty()) {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if (node == nullptr) {\\n                end = true;\\n            } else {\\n                if (end) {\\n                    return false;\\n                }\\n                q.push(node->left);\\n                q.push(node->right);\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\n\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if (root == null) {\\n            return true;\\n        }\\n\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        boolean end = false;\\n        while (!queue.isEmpty()) {\\n            TreeNode curr = queue.poll();\\n            if (curr == null) {\\n                end = true;\\n            } else {\\n                if (end) {\\n                    return false;\\n                }\\n                queue.offer(curr.left);\\n                queue.offer(curr.right);\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n\\n```\n```Python []\\nclass Solution(object):\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return True\\n        \\n        q = deque([root])\\n        end = False\\n        \\n        while q:\\n            node = q.popleft()\\n            if not node:\\n                end = True\\n            else:\\n                if end:\\n                    return False\\n                q.append(node.left)\\n                q.append(node.right)\\n        \\n        return True\\n\\n\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        std::queue<TreeNode*> q;\\n        q.push(root);\\n        bool end = false;\\n\\n        while (!q.empty()) {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if (node == nullptr) {\\n                end = true;\\n            } else {\\n                if (end) {\\n                    return false;\\n                }\\n                q.push(node->left);\\n                q.push(node->right);\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2517490,
                "title": "bfs-does-magic-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n       \\n    bool isCompleteTree(TreeNode* root) {\\n       \\n        queue<TreeNode*>q;\\n        q.push(root);\\n        bool flg=true;\\n        \\n        while(!q.empty()){\\n            int n=q.size();\\n                        \\n            for(int i=0;i<n;i++){\\n                auto ele=q.front();\\n                q.pop();\\n                \\n                if(!ele){\\n                    flg=false;\\n                }\\n                \\n                else{\\n                    if(!flg)return false;\\n                    \\n                    q.push(ele->left);\\n                    q.push(ele->right);\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n       \\n    bool isCompleteTree(TreeNode* root) {\\n       \\n        queue<TreeNode*>q;\\n        q.push(root);\\n        bool flg=true;\\n        \\n        while(!q.empty()){\\n            int n=q.size();\\n                        \\n            for(int i=0;i<n;i++){\\n                auto ele=q.front();\\n                q.pop();\\n                \\n                if(!ele){\\n                    flg=false;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2068637,
                "title": "java-bfs-solution-1ms-90-beat",
                "content": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean end = false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while(!queue.isEmpty()) {\\n            TreeNode currentNode = queue.poll();\\n            if(currentNode == null) {\\n                end = true;\\n            } else {\\n                if(end) {\\n                    return false;\\n                }\\n                queue.offer(currentNode.left);\\n                queue.offer(currentNode.right);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean end = false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while(!queue.isEmpty()) {\\n            TreeNode currentNode = queue.poll();\\n            if(currentNode == null) {\\n                end = true;\\n            } else {\\n                if(end) {\\n                    return false;\\n                }\\n                queue.offer(currentNode.left);\\n                queue.offer(currentNode.right);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861337,
                "title": "basic-level-order-traversal-c-for-beginners",
                "content": "Straight forward approach, return false, if a node has a right child but no left child, or the node doesnt have a right child but the next node has children/child.\\nOtherwise, after full traversal return true.\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()) {\\n            TreeNode* top = q.front();\\n            q.pop();\\n            if(top->left) q.push(top->left);\\n            if(top->right) q.push(top->right);\\n            if(!top->left and top->right or !top->right and !q.empty() and q.front()->left) \\n\\t\\t\\t\\treturn false;\\n        }\\n        return true;\\n    }\\n};\\n```\\nTrue, not the most brilliant solution, but intuitive, comes to mind easily and a good enough approach for a beginner to start somewhere.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()) {\\n            TreeNode* top = q.front();\\n            q.pop();\\n            if(top->left) q.push(top->left);\\n            if(top->right) q.push(top->right);\\n            if(!top->left and top->right or !top->right and !q.empty() and q.front()->left) \\n\\t\\t\\t\\treturn false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1799961,
                "title": "python-learned-from-nickwhite",
                "content": "Have to say, very clear when I listen to this guy explanation... I don\\'t know why  \\n```\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        queue = [root]\\n        end = False\\n        while queue:\\n            node = queue.pop(0)\\n            if not node:\\n                end = True\\n            else:\\n                if end:\\n                    return False\\n                queue.append(node.left)\\n                queue.append(node.right)\\n        return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "Have to say, very clear when I listen to this guy explanation... I don\\'t know why  \\n```\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        queue = [root]\\n        end = False\\n        while queue:\\n            node = queue.pop(0)\\n            if not node:\\n                end = True\\n            else:\\n                if end:\\n                    return False\\n                queue.append(node.left)\\n                queue.append(node.right)\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 1663015,
                "title": "swift-bfs",
                "content": "If the binary tree is complete, then the BFS queue will have either a suffix of null values or be empty. \\n\\n```\\nclass Solution {\\n    func isCompleteTree(_ root: TreeNode?) -> Bool {\\n        guard let root = root else {\\n            return true\\n        }\\n        \\n        var queue = [TreeNode?]()\\n        queue.append(root)\\n        \\n        while !queue.isEmpty {\\n            if let node = queue.removeFirst() {\\n                queue.append(node.left)\\n                queue.append(node.right)\\n            } else {\\n                for node in queue where node != nil {\\n                    return false\\n                }\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func isCompleteTree(_ root: TreeNode?) -> Bool {\\n        guard let root = root else {\\n            return true\\n        }\\n        \\n        var queue = [TreeNode?]()\\n        queue.append(root)\\n        \\n        while !queue.isEmpty {\\n            if let node = queue.removeFirst() {\\n                queue.append(node.left)\\n                queue.append(node.right)\\n            } else {\\n                for node in queue where node != nil {\\n                    return false\\n                }\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332230,
                "title": "c-labelling-5-line-dfs-code-concise-with-picture",
                "content": "\\n![image](https://assets.leetcode.com/users/images/b605af63-4931-4196-bca0-dd0994ec9e5d_1626061963.8985775.gif)\\n\\n\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n\\n    unsigned long long int sum , count = 0;\\n\\n    void dfs(TreeNode* root,unsigned long long int label){\\n        if(!root)\\n            return;\\n        ++count;\\n        sum += label;\\n        dfs(root->left,2*label);\\n        dfs(root->right,2*label+1);\\n    }\\n    \\n    bool isCompleteTree(TreeNode* root) {\\n        dfs(root,1);       \\n        return (count*(count+1)/2 == sum);\\n    }\\n};\\n```\\n\\n\\nLabel root node as 1 , left node as 2*i and right node as 2*i+1\\nLet count denote the total nodes in the binary tree \\nAfter labelling , just check if count*(count+1)/2 == sum of labels \\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    unsigned long long int sum , count = 0;\\n\\n    void dfs(TreeNode* root,unsigned long long int label){\\n        if(!root)\\n            return;\\n        ++count;\\n        sum += label;\\n        dfs(root->left,2*label);\\n        dfs(root->right,2*label+1);\\n    }\\n    \\n    bool isCompleteTree(TreeNode* root) {\\n        dfs(root,1);       \\n        return (count*(count+1)/2 == sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1267640,
                "title": "java-level-order-iterative-solution-one-loop-solution-bfs",
                "content": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root==null) return true;\\n        \\n        boolean last=false;\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        \\n        while(q.size()>0){\\n            TreeNode temp=q.poll();\\n            \\n            if(temp==null) last=true;\\n            else{\\n                if(last==true) return false;\\n                    q.add(temp.left);\\n                    q.add(temp.right);\\n            } \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root==null) return true;\\n        \\n        boolean last=false;\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        \\n        while(q.size()>0){\\n            TreeNode temp=q.poll();\\n            \\n            if(temp==null) last=true;\\n            else{\\n                if(last==true) return false;\\n                    q.add(temp.left);\\n                    q.add(temp.right);\\n            } \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948557,
                "title": "java-simple-dfs-approach-beats-100",
                "content": "```\\nclass Solution {\\n    boolean check = false;\\n    public boolean isCompleteTree(TreeNode root) {\\n        int h = height(root);\\n        return helper(root, h, 1);\\n    }\\n    \\n    public boolean helper(TreeNode root, int h, int depth){\\n        if(root == null){\\n            if(depth < h) return false;\\n            if(depth > h) return true;\\n            if(depth == h && !check) check = true;\\n            return true;\\n        }\\n        else if(depth == h && check) return false;\\n        return helper(root.left, h, depth + 1) && helper(root.right, h, depth + 1);\\n        \\n    }\\n    \\n    public int height(TreeNode root){\\n        if(root == null) return 0;\\n        else return 1 + Math.max(height(root.left), height(root.right));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    boolean check = false;\\n    public boolean isCompleteTree(TreeNode root) {\\n        int h = height(root);\\n        return helper(root, h, 1);\\n    }\\n    \\n    public boolean helper(TreeNode root, int h, int depth){\\n        if(root == null){\\n            if(depth < h) return false;\\n            if(depth > h) return true;\\n            if(depth == h && !check) check = true;\\n            return true;\\n        }\\n        else if(depth == h && check) return false;\\n        return helper(root.left, h, depth + 1) && helper(root.right, h, depth + 1);\\n        \\n    }\\n    \\n    public int height(TreeNode root){\\n        if(root == null) return 0;\\n        else return 1 + Math.max(height(root.left), height(root.right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 929980,
                "title": "c-short-level-order-traversal-solution",
                "content": "Idea is that by level order traversal, the nodes should form a contiguous sequence. So we just run a level-order traversal and check that once we hit a \"nullptr\" node, we will not hit any real nodes later. \\n\\nRun-time is `O(N)`, space is `O(N)`.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root) return true;\\n        std::queue<TreeNode*> q;\\n        TreeNode *last{root};\\n        q.emplace(root);\\n        while(!q.empty()) {\\n            TreeNode *cur{q.front()}; q.pop();\\n            if(!last && cur) return false;\\n            if(cur) q.emplace(cur->left), q.emplace(cur->right);\\n            last = cur;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root) return true;\\n        std::queue<TreeNode*> q;\\n        TreeNode *last{root};\\n        q.emplace(root);\\n        while(!q.empty()) {\\n            TreeNode *cur{q.front()}; q.pop();\\n            if(!last && cur) return false;\\n            if(cur) q.emplace(cur->left), q.emplace(cur->right);\\n            last = cur;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907914,
                "title": "c-solution",
                "content": "```\\n    public bool IsCompleteTree(TreeNode root) {\\n        var q=new Queue<TreeNode>();\\n        q.Enqueue(root);\\n        while(q.Any())\\n        {\\n            var cur=q.Dequeue();\\n            if(cur==null)\\n                break;\\n            q.Enqueue(cur.left);\\n            q.Enqueue(cur.right);\\n        }\\n        while(q.Any())\\n        {\\n            if(q.Dequeue()!=null)\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public bool IsCompleteTree(TreeNode root) {\\n        var q=new Queue<TreeNode>();\\n        q.Enqueue(root);\\n        while(q.Any())\\n        {\\n            var cur=q.Dequeue();\\n            if(cur==null)\\n                break;\\n            q.Enqueue(cur.left);\\n            q.Enqueue(cur.right);\\n        }\\n        while(q.Any())\\n        {\\n            if(q.Dequeue()!=null)\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 830686,
                "title": "c-bfs-fast-self-explanatory-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        bool flag = 0;\\n        deque<TreeNode*> q{root};\\n        while(!q.empty()) {\\n            TreeNode* cur = q.front();\\n            q.pop_front();\\n            if(!cur)\\n                flag = 1;\\n            else {\\n                if(flag)\\n                    return false;\\n                q.push_back(cur->left);\\n                q.push_back(cur->right);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        bool flag = 0;\\n        deque<TreeNode*> q{root};\\n        while(!q.empty()) {\\n            TreeNode* cur = q.front();\\n            q.pop_front();\\n            if(!cur)\\n                flag = 1;\\n            else {\\n                if(flag)\\n                    return false;\\n                q.push_back(cur->left);\\n                q.push_back(cur->right);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 754079,
                "title": "java-bfs-1ms",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public boolean isCompleteTree(TreeNode root) {\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        \\n        boolean hitEnd = false; // this will mark the first incomplete row to ensure we don\\'t go passed it\\n        \\n        while (!q.isEmpty()) {\\n            \\n            int len = q.size();\\n            \\n            while (len > 0) {\\n                TreeNode curr = q.poll();\\n                \\n                // another node in this line was incomplete\\n                if (hitEnd && (curr.left != null || curr.right != null))\\n                    return false;\\n                \\n                // can\\'t have a right without a left\\n                if (curr.right != null && curr.left == null)\\n                    return false;\\n                else if (curr.left != null && curr.right == null) {\\n                    q.offer(curr.left);\\n                    hitEnd = true;\\n                } else if (curr.left != null && curr.right != null) {\\n                    q.offer(curr.left);\\n                    q.offer(curr.right);\\n                } else { // both left and right null\\n                    hitEnd = true;\\n                }\\n                   \\n                len--;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    \\n    public boolean isCompleteTree(TreeNode root) {\\n        \\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        \\n        boolean hitEnd = false; // this will mark the first incomplete row to ensure we don\\'t go passed it\\n        \\n        while (!q.isEmpty()) {\\n            \\n            int len = q.size();\\n            \\n            while (len > 0) {\\n                TreeNode curr = q.poll();\\n                \\n                // another node in this line was incomplete\\n                if (hitEnd && (curr.left != null || curr.right != null))\\n                    return false;\\n                \\n                // can\\'t have a right without a left\\n                if (curr.right != null && curr.left == null)\\n                    return false;\\n                else if (curr.left != null && curr.right == null) {\\n                    q.offer(curr.left);\\n                    hitEnd = true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 440320,
                "title": "cookie-cutter-bfs-approach-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.add(root);\\n        while(queue.peek() != null) {\\n            TreeNode current = queue.poll();\\n            queue.add(current.left);\\n            queue.add(current.right);\\n        }       \\n        //all values in queue must be null for it to be complete bt\\n        while(queue.size() > 0 && queue.peek() == null)\\n            queue.poll();\\n        return queue.size() == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.add(root);\\n        while(queue.peek() != null) {\\n            TreeNode current = queue.poll();\\n            queue.add(current.left);\\n            queue.add(current.right);\\n        }       \\n        //all values in queue must be null for it to be complete bt\\n        while(queue.size() > 0 && queue.peek() == null)\\n            queue.poll();\\n        return queue.size() == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 366228,
                "title": "fast-and-easy-solution-beats-97-8-using-queue-python",
                "content": "\\timport collections\\n\\n\\tclass Solution(object):\\n\\t\\tdef isCompleteTree(self, root):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type root: TreeNode\\n\\t\\t\\t:rtype: bool\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tif not root: return True\\n\\n\\t\\t\\tqueue = collections.deque()\\n\\t\\t\\tqueue.append(root)\\n\\t\\t\\tflag = False\\n\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tcurr = queue.popleft()\\n\\t\\t\\t\\tif curr is None:\\n\\t\\t\\t\\t\\tflag = True\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif flag is True:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tqueue.append(curr.left)\\n\\t\\t\\t\\t\\tqueue.append(curr.right)\\n\\t\\t\\treturn True",
                "solutionTags": [],
                "code": "\\timport collections\\n\\n\\tclass Solution(object):\\n\\t\\tdef isCompleteTree(self, root):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type root: TreeNode\\n\\t\\t\\t:rtype: bool\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tif not root: return True\\n\\n\\t\\t\\tqueue = collections.deque()\\n\\t\\t\\tqueue.append(root)\\n\\t\\t\\tflag = False\\n\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tcurr = queue.popleft()\\n\\t\\t\\t\\tif curr is None:\\n\\t\\t\\t\\t\\tflag = True\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif flag is True:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tqueue.append(curr.left)\\n\\t\\t\\t\\t\\tqueue.append(curr.right)\\n\\t\\t\\treturn True",
                "codeTag": "Java"
            },
            {
                "id": 338689,
                "title": "my-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        std::queue<TreeNode*> myqueue;\\n        myqueue.push(root);\\n        \\n        while(!myqueue.empty()){\\n            if(myqueue.front()){\\n                myqueue.push(myqueue.front()->left);\\n                myqueue.push(myqueue.front()->right);\\n                myqueue.pop();\\n            }else{\\n                myqueue.pop();\\n                while(!myqueue.empty()){\\n                    if(myqueue.front())\\n                        return false;\\n                    myqueue.pop();\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        std::queue<TreeNode*> myqueue;\\n        myqueue.push(root);\\n        \\n        while(!myqueue.empty()){\\n            if(myqueue.front()){\\n                myqueue.push(myqueue.front()->left);\\n                myqueue.push(myqueue.front()->right);\\n                myqueue.pop();\\n            }else{\\n                myqueue.pop();\\n                while(!myqueue.empty()){\\n                    if(myqueue.front())\\n                        return false;\\n                    myqueue.pop();\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 272958,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        que = collections.deque([root])\\n        while que:\\n            for _ in range(len(que)):\\n                front = que.popleft()\\n                if front == None:\\n                    return all(node==None for node in que)\\n                else:\\n                    que.extend([front.left, front.right])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        que = collections.deque([root])\\n        while que:\\n            for _ in range(len(que)):\\n                front = que.popleft()\\n                if front == None:\\n                    return all(node==None for node in que)\\n                else:\\n                    que.extend([front.left, front.right])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 225307,
                "title": "c-0ms-recursive-solution-one-pass",
                "content": "The idea is to check if the tree is complete and also if it\\'s perfect (each node has 0 or 2 children and all the leaves are on the last level), and to track the depth. Then we can derive current node results based on completeness and perfectness of left and right subtrees (and their depths).\\n\\n```\\nclass Solution {\\npublic:   \\n    struct TreeStats {\\n        bool complete;\\n        bool perfect;\\n        int depth;        \\n    };\\n    \\n    TreeStats calcStats(TreeNode* node) {\\n        if(node == 0) {\\n            return {true, true, 0};\\n        }\\n        \\n        TreeStats left = calcStats(node->left);\\n        TreeStats right = calcStats(node->right);\\n        \\n        const int diff = left.depth - right.depth;\\n        \\n        bool isComplete = (0 <= diff && diff <= 1) && left.complete && right.complete\\n            && (left.perfect && right.perfect || left.perfect && diff == 0 || right.perfect && diff == 1);\\n        \\n        bool isPerfect = left.perfect && right.perfect && diff == 0;\\n        \\n        int depth = max(left.depth, right.depth) + 1;\\n        \\n        return {isComplete, isPerfect, depth};\\n    }\\n    \\n    bool isCompleteTree(TreeNode* root) {\\n        return calcStats(root).complete;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:   \\n    struct TreeStats {\\n        bool complete;\\n        bool perfect;\\n        int depth;        \\n    };\\n    \\n    TreeStats calcStats(TreeNode* node) {\\n        if(node == 0) {\\n            return {true, true, 0};\\n        }\\n        \\n        TreeStats left = calcStats(node->left);\\n        TreeStats right = calcStats(node->right);\\n        \\n        const int diff = left.depth - right.depth;\\n        \\n        bool isComplete = (0 <= diff && diff <= 1) && left.complete && right.complete\\n            && (left.perfect && right.perfect || left.perfect && diff == 0 || right.perfect && diff == 1);\\n        \\n        bool isPerfect = left.perfect && right.perfect && diff == 0;\\n        \\n        int depth = max(left.depth, right.depth) + 1;\\n        \\n        return {isComplete, isPerfect, depth};\\n    }\\n    \\n    bool isCompleteTree(TreeNode* root) {\\n        return calcStats(root).complete;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663206,
                "title": "c-simple-solution-bfs-dfs-without-count-nodes-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse BFS, DFS and level ordering properties to find the completeness.\\n# Approach 1 : DFS\\n<!-- Describe your approach to solving the problem. -->\\n- First, we do a simple DFS to determine the number of nodes n.\\n\\n- Next, we start another DFS with root as node and assigning an index of 0 to it. If node == null, we have an empty subtree of node. For this case, we return true. Otherwise, we examine whether index >= n.\\n\\n- If index >= n, it means we\\'ve a non-null node having index greater or equal to the number of nodes in the given tree which tells that the given tree is not a complete binary tree. We return false.\\n\\n- Otherwise, we call dfs recursively for the left and right subtrees to see if any node in either subtree violates the complete binary tree property. To perform this recursion, we use`isCBT(node->left, 2*index + 1, n) && isCBT(node->right, 2*index + 2, n)`.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nodes;\\n    void cntNodes(TreeNode* root){\\n        if(!root) return;\\n        cntNodes(root->left);\\n        nodes++;\\n        cntNodes(root->right);\\n    }\\n\\n    bool isCBT(TreeNode* root,int index,int nodes){\\n        if(!root)return true;\\n        if(index>=nodes)return false;\\n        return isCBT(root->left,2*index + 1,nodes) && isCBT(root->right,2*index + 2,nodes);\\n    }\\n\\n    bool isCompleteTree(TreeNode* root) {\\n        cntNodes(root);\\n        return isCBT(root,0,nodes);\\n    }\\n};\\n```\\n# Approach 2 : BFS\\n<!-- Describe your approach to solving the problem. -->\\n- We initialize nullNodeFound as false and start with the root node. \\n- If the tree is empty (root is null), we return true. \\n- During BFS, if a null node is encountered, nullNodeFound is set to true. \\n- If a non-null node is encountered after nullNodeFound is true, the tree is not complete, and we return false.\\n- If the traversal completes without violating this condition, the tree is considered complete, and we return true.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if (root == nullptr) {\\n            return true;\\n        }\\n\\n        bool nullNode = false;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        while (!q.empty()) {\\n            TreeNode* node = q.front();\\n            q.pop();\\n\\n            if (node == nullptr) {\\n                nullNode = true;\\n            } else {\\n                if (nullNode) {\\n                    return false;\\n                }\\n                q.push(node->left);\\n                q.push(node->right);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n# Approach 3 : Using Leftmost height\\n<!-- Describe your approach to solving the problem. -->\\n- We traverse the tree and track the current height h in recursive variable. Set leftmost node height into leftMostHeight varible.\\n\\n- For remaining leaves, the height should be the same as leftMostHeight. If we encounter a null node with height less that leftMostHeight, that means last level should not be filled further to maintain completeness, our height can become `leftMostHeight - 1` i.e; last before level. \\n- In that case, we set `lastLevelIsFull = 1`, and check that the height of remaining leaves equals `leftMostHeight - lastLevelIsFull` .\\n\\n- `h == leftMostHeight - lastLevelIsFull `, with this condition, whenever we encounter a node again in last level, it returns false.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) (recursive stack space)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int leftMostHeight = 0, lastLevelIsFull = false;\\n    bool isCompleteTree(TreeNode* r, int h = 0) {\\n    if (r == nullptr) {\\n        if (leftMostHeight == 0) {\\n            leftMostHeight = h;\\n        } else if (h == leftMostHeight - 1) {\\n            lastLevelIsFull  = true;\\n        }\\n        return h == leftMostHeight - lastLevelIsFull ;\\n    }\\n    return isCompleteTree(r->left, h + 1) && isCompleteTree(r->right, h + 1);\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.**\\n\\n![3u04h5.jpg](https://assets.leetcode.com/users/images/601f60ec-ad18-4e2d-9439-daae38029ce1_1687292004.5022247.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nodes;\\n    void cntNodes(TreeNode* root){\\n        if(!root) return;\\n        cntNodes(root->left);\\n        nodes++;\\n        cntNodes(root->right);\\n    }\\n\\n    bool isCBT(TreeNode* root,int index,int nodes){\\n        if(!root)return true;\\n        if(index>=nodes)return false;\\n        return isCBT(root->left,2*index + 1,nodes) && isCBT(root->right,2*index + 2,nodes);\\n    }\\n\\n    bool isCompleteTree(TreeNode* root) {\\n        cntNodes(root);\\n        return isCBT(root,0,nodes);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if (root == nullptr) {\\n            return true;\\n        }\\n\\n        bool nullNode = false;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        while (!q.empty()) {\\n            TreeNode* node = q.front();\\n            q.pop();\\n\\n            if (node == nullptr) {\\n                nullNode = true;\\n            } else {\\n                if (nullNode) {\\n                    return false;\\n                }\\n                q.push(node->left);\\n                q.push(node->right);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int leftMostHeight = 0, lastLevelIsFull = false;\\n    bool isCompleteTree(TreeNode* r, int h = 0) {\\n    if (r == nullptr) {\\n        if (leftMostHeight == 0) {\\n            leftMostHeight = h;\\n        } else if (h == leftMostHeight - 1) {\\n            lastLevelIsFull  = true;\\n        }\\n        return h == leftMostHeight - lastLevelIsFull ;\\n    }\\n    return isCompleteTree(r->left, h + 1) && isCompleteTree(r->right, h + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302080,
                "title": "java-solution-using-bfs",
                "content": "***We use bfs because in BFS, we visit nodes from left to right at a level so if we see node after \"null\" then it means our binary tree is not a complete binary tree***\\n```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        boolean nullNodeFound = false;\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            TreeNode node = q.poll();\\n            \\n            if(node==null){\\n                nullNodeFound = true;\\n            }else{\\n                if(nullNodeFound==true){\\n                    return false;\\n                }\\n                q.add(node.left);\\n                q.add(node.right);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        boolean nullNodeFound = false;\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            TreeNode node = q.poll();\\n            \\n            if(node==null){\\n                nullNodeFound = true;\\n            }else{\\n                if(nullNodeFound==true){\\n                    return false;\\n                }\\n                q.add(node.left);\\n                q.add(node.right);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301736,
                "title": "java-c-dfs-just-find-index-of-last-node-beats-100",
                "content": "# Upvote if you liked \\u2714\\u2705\\uD83E\\uDD29\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNo need to do BFS or DFS traversal. Just find the index of last node.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have taken binary tree as 1-indexed. So left child of root `ind` is   `2*ind` and right one is `2*ind+1`.\\n\\nSuppose `total` = total no of nodes in binary tree\\nand     `maxi`  = index of last node  of binary tree\\n\\nSo to become a Complete Binary Tree, it is needed `total == maxi`, otherwise it is not a Complete Binary Tree.\\n\\n[`Note` : To avoid overflow of indices i have taken `min(101, 2*ind)` instead of (`2*ind`) , as maximum no of node is only 100.  ]\\n\\n# Complexity\\n- Time complexity: $$O(N)$$, where `N` is no of node in binary tree. We are just traversing the entire binary tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(H)$$, where `H` is height of binary tree, required for call stack.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java Code\\n```\\nclass Solution {\\n    int maxi = 0;\\n\\n    private int isCompleteTreeHelp(TreeNode root, int ind) {\\n        if (root == null) return 0;\\n        maxi = Math.max(maxi, ind);\\n        return 1 + isCompleteTreeHelp(root.left, Math.min(101, 2 * ind)) + isCompleteTreeHelp(root.right, Math.min(101, 2 * ind + 1));\\n    }\\n\\n    public boolean isCompleteTree(TreeNode root) {\\n        return isCompleteTreeHelp(root, 1) == maxi ? true : false;\\n    }\\n}\\n```\\n\\n---\\n\\n# C++ Code :\\n```\\nclass Solution {\\n    int maxi = 0;\\n    int isCompleteTreeHelp(TreeNode* root, int ind) {\\n        if (root == NULL) return 0;\\n        maxi = max(maxi, ind);\\n        return 1 + isCompleteTreeHelp(root->left, min(101, 2 * ind)) + isCompleteTreeHelp(root->right, min(101, 2 * ind + 1));\\n    }\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        return isCompleteTreeHelp(root, 1) == maxi;\\n    }\\n};\\n```\\n# Upvote if you liked \\u2714\\u2705\\uD83E\\uDD29\\n\\n![upvote-img.jpg](https://assets.leetcode.com/users/images/97f61d34-0d0e-41a4-95b3-2729e1643bb5_1678909132.7747173.jpeg)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int maxi = 0;\\n\\n    private int isCompleteTreeHelp(TreeNode root, int ind) {\\n        if (root == null) return 0;\\n        maxi = Math.max(maxi, ind);\\n        return 1 + isCompleteTreeHelp(root.left, Math.min(101, 2 * ind)) + isCompleteTreeHelp(root.right, Math.min(101, 2 * ind + 1));\\n    }\\n\\n    public boolean isCompleteTree(TreeNode root) {\\n        return isCompleteTreeHelp(root, 1) == maxi ? true : false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int maxi = 0;\\n    int isCompleteTreeHelp(TreeNode* root, int ind) {\\n        if (root == NULL) return 0;\\n        maxi = max(maxi, ind);\\n        return 1 + isCompleteTreeHelp(root->left, min(101, 2 * ind)) + isCompleteTreeHelp(root->right, min(101, 2 * ind + 1));\\n    }\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        return isCompleteTreeHelp(root, 1) == maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300958,
                "title": "tc-o-n-sc-o-n-n-no-of-nodes-in-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root==null)\\n        return true;\\n        boolean nullfound=false;\\n        Queue<TreeNode> q=new LinkedList<>();\\n\\n        q.offer(root);\\n\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode temp=q.poll();\\n                if(temp==null)\\n                {\\n                    nullfound=true;\\n                }\\n                else {\\n                    if(nullfound)\\n                    {\\n                        return false;\\n                    }\\n                    else{\\n                        q.offer(temp.left);\\n                        q.offer(temp.right);\\n\\n                    }\\n                }\\n                \\n\\n            }\\n\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root==null)\\n        return true;\\n        boolean nullfound=false;\\n        Queue<TreeNode> q=new LinkedList<>();\\n\\n        q.offer(root);\\n\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode temp=q.poll();\\n                if(temp==null)\\n                {\\n                    nullfound=true;\\n                }\\n                else {\\n                    if(nullfound)\\n                    {\\n                        return false;\\n                    }\\n                    else{\\n                        q.offer(temp.left);\\n                        q.offer(temp.right);\\n\\n                    }\\n                }\\n                \\n\\n            }\\n\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300184,
                "title": "rust-bfs-simple",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nuse std::collections::LinkedList;\\n\\nimpl Solution {\\n    pub fn is_complete_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let mut queue = LinkedList::new();\\n        queue.push_back(root);\\n\\n        while let Some(v) = queue.pop_front() {\\n            if let Some(v) = v {\\n                queue.push_back(v.borrow().left.clone());\\n                queue.push_back(v.borrow().right.clone());\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        while let Some(v) = queue.pop_front() {\\n            if let Some(_) = v {\\n                return false\\n            }\\n        }\\n\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Breadth-First Search"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nuse std::collections::LinkedList;\\n\\nimpl Solution {\\n    pub fn is_complete_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let mut queue = LinkedList::new();\\n        queue.push_back(root);\\n\\n        while let Some(v) = queue.pop_front() {\\n            if let Some(v) = v {\\n                queue.push_back(v.borrow().left.clone());\\n                queue.push_back(v.borrow().right.clone());\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        while let Some(v) = queue.pop_front() {\\n            if let Some(_) = v {\\n                return false\\n            }\\n        }\\n\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3299921,
                "title": "easy-java-solution-full-explaination-level-order-comments-lbeginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**First get all the data for each level and store it into a Collections such as listData. And when you encounter null node just push -1 into your list to keep track of the space between nodes and then for each list inside listData you need to count number of element whose value is greater than 0. because when we are at last list we make sure that all the above level make complete binary tree to verify that we just check the count is equal to the formula i.e. Math.pow(2,i)-1 which gives the total no. of element upto that level including root.And then for the last list we just check the list is completely full or its partially full from the left and there is no -1 in between 2 nodes having value greater than 0**\\n\\nExample for last list should be like :\\n1. [4,5,6,-1,-1] this is valid\\n2. [4,5,6,-1,7,-1,-1,-1] is not valid\\n3. [1,-1,-1,-1,-1,-1,-1,-1] is valid \\n4. [-1,-1,-1,-1,-1,6,7,8] is not valid \\nso basically there should be no -1 in the left part of the list \\nif its not a valid list return false else return true\\n\\n**Note : Here in my listData will contain one extra list at the end so just ignore it**\\n# Code\\n```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            List<Integer> al = new ArrayList<>();\\n            for(int i = 0 ; i < size; i ++){\\n                TreeNode node = q.poll();\\n                if(node != null){\\n                    al.add(node.val);\\n                }else{\\n                    al.add(-1);\\n                    continue;\\n                }\\n                if(node.left != null){\\n                    q.add(node.left);\\n                }else{\\n                    q.add(null);\\n                }\\n                if(node.right != null){\\n                    q.add(node.right);\\n                }else{\\n                    q.add(null);\\n                }\\n            }\\n            list.add(al);\\n        }\\n        int count = 0;\\n        for(int i = 0 ; i < list.size()-1; i ++){\\n            if(i < list.size()-2){\\n                for(Integer num : list.get(i)){\\n                    if(num > 0){\\n                        count++;\\n                    }\\n                }\\n            }else{\\n                //check all the above level have total nodes as it should be in a complete binary tree\\n                if(count != (int)Math.pow(2,i)-1){\\n                    return false;\\n                }\\n                //check if the list is filled from the left \\n                int k = 0;\\n                while(k != list.get(i).size()){\\n                    if(list.get(i).get(k) == -1){\\n                        break;\\n                    }\\n                    k++;\\n                }\\n                while(k != list.get(i).size()){\\n                    if(list.get(i).get(k) > 0){\\n                        return false;\\n                    }\\n                    k++;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            List<Integer> al = new ArrayList<>();\\n            for(int i = 0 ; i < size; i ++){\\n                TreeNode node = q.poll();\\n                if(node != null){\\n                    al.add(node.val);\\n                }else{\\n                    al.add(-1);\\n                    continue;\\n                }\\n                if(node.left != null){\\n                    q.add(node.left);\\n                }else{\\n                    q.add(null);\\n                }\\n                if(node.right != null){\\n                    q.add(node.right);\\n                }else{\\n                    q.add(null);\\n                }\\n            }\\n            list.add(al);\\n        }\\n        int count = 0;\\n        for(int i = 0 ; i < list.size()-1; i ++){\\n            if(i < list.size()-2){\\n                for(Integer num : list.get(i)){\\n                    if(num > 0){\\n                        count++;\\n                    }\\n                }\\n            }else{\\n                //check all the above level have total nodes as it should be in a complete binary tree\\n                if(count != (int)Math.pow(2,i)-1){\\n                    return false;\\n                }\\n                //check if the list is filled from the left \\n                int k = 0;\\n                while(k != list.get(i).size()){\\n                    if(list.get(i).get(k) == -1){\\n                        break;\\n                    }\\n                    k++;\\n                }\\n                while(k != list.get(i).size()){\\n                    if(list.get(i).get(k) > 0){\\n                        return false;\\n                    }\\n                    k++;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299889,
                "title": "very-easy-efficient-c-soln-beginner-friendly-code-bfs-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will do BFS traversal since by this we can check all levels one by one.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is quite simple we first put our root in the queue and do BFS traveral which will visit every level one by one. In each iteration we will check if the children node is present or not, if any of the children node is not present then its clear that after that node, no new node of the tree should be there, So we will just mark our flag with 1, and if afterward any node is found then we will simply return false else will iterate it thorougly and at last return true.\\n**PLease upvote guys if it helps or make sense to you.**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(min(n,h))\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int flag=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            queue<TreeNode*> temp;\\n            while(size--)\\n            {\\n                TreeNode* top = q.front();\\n                q.pop();\\n                cout<<top->val<<\" \";\\n                if(top->left)\\n                {\\n                    if(flag==1)\\n                        return false;\\n                    temp.push(top->left);\\n                }\\n                else\\n                {\\n                    flag=1;\\n                    cout<<top->val;\\n                }\\n                if(top->right)\\n                {\\n                    if(flag==1)\\n                    return false;\\n                    temp.push(top->right);\\n                }\\n                else\\n                {\\n                    cout<<top->val;\\n                    flag=1;\\n                }\\n            }\\n            q=temp;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int flag=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            queue<TreeNode*> temp;\\n            while(size--)\\n            {\\n                TreeNode* top = q.front();\\n                q.pop();\\n                cout<<top->val<<\" \";\\n                if(top->left)\\n                {\\n                    if(flag==1)\\n                        return false;\\n                    temp.push(top->left);\\n                }\\n                else\\n                {\\n                    flag=1;\\n                    cout<<top->val;\\n                }\\n                if(top->right)\\n                {\\n                    if(flag==1)\\n                    return false;\\n                    temp.push(top->right);\\n                }\\n                else\\n                {\\n                    cout<<top->val;\\n                    flag=1;\\n                }\\n            }\\n            q=temp;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3299714,
                "title": "c-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(root == NULL) return true;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        bool seenNull = false;\\n        while(!q.empty()) {\\n            TreeNode* node = q.front();\\n            q.pop();   \\n            if(node == NULL) {\\n                seenNull = true;\\n                continue;\\n            }\\n            if(seenNull) {\\n                return false;\\n            }\\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(root == NULL) return true;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        bool seenNull = false;\\n        while(!q.empty()) {\\n            TreeNode* node = q.front();\\n            q.pop();   \\n            if(node == NULL) {\\n                seenNull = true;\\n                continue;\\n            }\\n            if(seenNull) {\\n                return false;\\n            }\\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299635,
                "title": "ruby-fast-concise-3-lines",
                "content": "```ruby\\ndef is_complete_tree(root)\\n    queue = [root]\\n    queue.push root.left, root.right while root = queue.shift\\n    queue.none?\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef is_complete_tree(root)\\n    queue = [root]\\n    queue.push root.left, root.right while root = queue.shift\\n    queue.none?\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3299492,
                "title": "simple-pyhton3-solution-upto-90-faster-o-n-simple-explaination-of-dfs",
                "content": "# Intuition\\n1. Start with a queue containing only the root node.\\n\\n2. While the first element in the queue is not None, remove the first element from the queue, and add its left and right children (if they exist) to the end of the queue.\\n\\n3. After the while loop, check if all remaining elements in the queue are None. If they are, the binary tree is complete; otherwise, it\\'s not complete.\\n\\nThis algorithm ensures that all nodes at each level are processed before moving on to the next level. If we encounter a **None element** in the queue before processing all nodes at a level, it means the binary tree is not complete.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(m)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        queue = [root]\\n        while queue[0] is not None:\\n            node = queue.pop(0)\\n            queue.append(node.left)\\n            queue.append(node.right)\\n        return all([n is None for n in queue]) \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        queue = [root]\\n        while queue[0] is not None:\\n            node = queue.pop(0)\\n            queue.append(node.left)\\n            queue.append(node.right)\\n        return all([n is None for n in queue]) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299425,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) \\n    {\\n        if(!root) return true;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        bool nullSeen=false; \\n        while(!q.empty())\\n        { \\n            int levelSize=q.size();\\n            while(levelSize--){    \\n                TreeNode* tp=q.front();\\n                q.pop();\\n                if(!tp) nullSeen=true; \\n                else\\n                {\\n                    if(nullSeen) return false; \\n                    q.push(tp->left);\\n                    q.push(tp->right);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) \\n    {\\n        if(!root) return true;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        bool nullSeen=false; \\n        while(!q.empty())\\n        { \\n            int levelSize=q.size();\\n            while(levelSize--){    \\n                TreeNode* tp=q.front();\\n                q.pop();\\n                if(!tp) nullSeen=true; \\n                else\\n                {\\n                    if(nullSeen) return false; \\n                    q.push(tp->left);\\n                    q.push(tp->right);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299357,
                "title": "short-sweet-c-iterative-code",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,bool &ans){\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int n;\\n        TreeNode* p;\\n        bool k = false;\\n        while(!q.empty()){\\n            n = q.size();\\n            while(n--){\\n                p = q.front();\\n                q.pop();\\n                if(p->left == NULL){\\n                    k = true;\\n                }\\n                if(k&&(p->left != NULL || p->right != NULL)){\\n                    ans = false;\\n                    return;\\n                }\\n                if(p->left){\\n                    q.push(p->left);\\n                }\\n                else{\\n                    k = true;\\n                }\\n                if(p->right){\\n                    q.push(p->right);\\n                }else{\\n                    k = true;\\n                }\\n            }\\n        }\\n    }\\n    bool isCompleteTree(TreeNode* root) {\\n        bool ans = true;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,bool &ans){\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int n;\\n        TreeNode* p;\\n        bool k = false;\\n        while(!q.empty()){\\n            n = q.size();\\n            while(n--){\\n                p = q.front();\\n                q.pop();\\n                if(p->left == NULL){\\n                    k = true;\\n                }\\n                if(k&&(p->left != NULL || p->right != NULL)){\\n                    ans = false;\\n                    return;\\n                }\\n                if(p->left){\\n                    q.push(p->left);\\n                }\\n                else{\\n                    k = true;\\n                }\\n                if(p->right){\\n                    q.push(p->right);\\n                }else{\\n                    k = true;\\n                }\\n            }\\n        }\\n    }\\n    bool isCompleteTree(TreeNode* root) {\\n        bool ans = true;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299209,
                "title": "try-once-more-with-my-hints-easy-bfs-solution-in-java",
                "content": "# Hints \\n- Use BFS.\\n- Queue helps us to traverse every level form left to right.\\n- While moving from left to right if got a null node and after that if there is any which is not null this means tree is incomplete.\\n- For every level traverse from left to right and check for 2 things\\n    - If current node is null record it\\n    - else check if any middle node is null return false if not then add left and right of current node in queue\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ where n is number of nodes in tree\\n\\n- Space complexity: $$O(n)$$ where n is maximum number of nodes at any level of tree\\n\\n```\\nPlease upvote\\n```\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root == null) return true;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        boolean nullBw = false;\\n        while(!q.isEmpty()){\\n            int s = q.size();\\n            for(int x = 0; x<s; x++){\\n                TreeNode curr = q.poll();\\n                if(curr == null) nullBw = true;\\n                else {\\n                    if(nullBw) return false;\\n                    q.offer(curr.left);\\n                    q.offer(curr.right);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPlease upvote\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root == null) return true;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        boolean nullBw = false;\\n        while(!q.isEmpty()){\\n            int s = q.size();\\n            for(int x = 0; x<s; x++){\\n                TreeNode curr = q.poll();\\n                if(curr == null) nullBw = true;\\n                else {\\n                    if(nullBw) return false;\\n                    q.offer(curr.left);\\n                    q.offer(curr.right);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299100,
                "title": "java-dfs-solution-o-n-time",
                "content": "# Intuition\\nFind the total number of nodes in tree n. \\nCheck index of node, if index is greater than to n, it means tree is in complete.\\n\\nIndex:- 2 * root index + 1 (left) and 2 * root index + 2 (right)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind count of nodes in tree.\\ncheck node index, if index is greated than number of nodes return false, otherwise return true.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(height)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n# Code\\n```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if (root == null) {\\n            return true;\\n        }\\n\\n        int totalNodes = countNodes(root);\\n        return isCompleteTree(root, 0, totalNodes);\\n    }\\n\\n    private boolean isCompleteTree(TreeNode root, int idx, int totalNodes) {\\n        if (root == null) {\\n            return true;\\n        }\\n\\n        if (idx >= totalNodes) {\\n            return false;\\n        }\\n\\n        return isCompleteTree(root.left, 2 * idx + 1, totalNodes) && isCompleteTree(root.right, 2 * idx + 2, totalNodes);\\n    }\\n\\n    private int countNodes(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        return 1 + countNodes(root.left) + countNodes(root.right);\\n    }\\n}\\n```\\n\\n# Hindi Problem Explanation and Solution Approach\\nhttps://youtu.be/ovmWdCyIeU0",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if (root == null) {\\n            return true;\\n        }\\n\\n        int totalNodes = countNodes(root);\\n        return isCompleteTree(root, 0, totalNodes);\\n    }\\n\\n    private boolean isCompleteTree(TreeNode root, int idx, int totalNodes) {\\n        if (root == null) {\\n            return true;\\n        }\\n\\n        if (idx >= totalNodes) {\\n            return false;\\n        }\\n\\n        return isCompleteTree(root.left, 2 * idx + 1, totalNodes) && isCompleteTree(root.right, 2 * idx + 2, totalNodes);\\n    }\\n\\n    private int countNodes(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        return 1 + countNodes(root.left) + countNodes(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299098,
                "title": "java-simple-approach",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        List<TreeNode> list=bfs(root);\\n        if(root==null) return false;\\n        boolean bool=true;\\n        for(int i=list.size()-1; i>=0; i--){\\n            if(bool && list.get(i)==null){\\n                list.remove(i);\\n                continue;\\n            }\\n            else bool=false;\\n            if(list.get(i)==null) return false;\\n        }\\n        return true;\\n         \\n    }\\n    public List<TreeNode> bfs(TreeNode root){\\n        Queue<TreeNode> queue=new LinkedList<TreeNode>();\\n        List<TreeNode> list=new ArrayList<TreeNode>();\\n        queue.offer(root);\\n        while(!queue.isEmpty()){\\n            TreeNode node=queue.poll();\\n            if(node==null) continue;\\n            list.add(node.left);\\n            list.add(node.right);\\n            queue.add(node.left);\\n            queue.add(node.right);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        List<TreeNode> list=bfs(root);\\n        if(root==null) return false;\\n        boolean bool=true;\\n        for(int i=list.size()-1; i>=0; i--){\\n            if(bool && list.get(i)==null){\\n                list.remove(i);\\n                continue;\\n            }\\n            else bool=false;\\n            if(list.get(i)==null) return false;\\n        }\\n        return true;\\n         \\n    }\\n    public List<TreeNode> bfs(TreeNode root){\\n        Queue<TreeNode> queue=new LinkedList<TreeNode>();\\n        List<TreeNode> list=new ArrayList<TreeNode>();\\n        queue.offer(root);\\n        while(!queue.isEmpty()){\\n            TreeNode node=queue.poll();\\n            if(node==null) continue;\\n            list.add(node.left);\\n            list.add(node.right);\\n            queue.add(node.left);\\n            queue.add(node.right);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299085,
                "title": "easy-c-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode * > q;\\n        q.push(root);\\n        bool prev =  true;\\n\\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            while(s--)\\n            {\\n                TreeNode *temp = q.front();\\n                q.pop();\\n                if(temp->left)\\n                {\\n                    if(prev ==false)\\n                    return false;\\n\\n                    q.push(temp->left);\\n                }\\n                else\\n                {\\n                    prev = false;\\n                }\\n                \\n                if(temp->right )\\n                {\\n                    if(prev == false)\\n                    return false;\\n\\n                    q.push(temp->right);\\n                }\\n                else\\n                {\\n                    prev = false;\\n                }\\n                \\n            }\\n        }\\n\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode * > q;\\n        q.push(root);\\n        bool prev =  true;\\n\\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            while(s--)\\n            {\\n                TreeNode *temp = q.front();\\n                q.pop();\\n                if(temp->left)\\n                {\\n                    if(prev ==false)\\n                    return false;\\n\\n                    q.push(temp->left);\\n                }\\n                else\\n                {\\n                    prev = false;\\n                }\\n                \\n                if(temp->right )\\n                {\\n                    if(prev == false)\\n                    return false;\\n\\n                    q.push(temp->right);\\n                }\\n                else\\n                {\\n                    prev = false;\\n                }\\n                \\n            }\\n        }\\n\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299081,
                "title": "beats-84-in-time-and-46-in-space-bfs-queue",
                "content": "# Intuition\\nGiven a tree is binary, a complete binary tree if non null nodes are present from top to bottom and left to right at each level except at last level where last some node as null are acceptable. If we have null before non null value in that level, then it will be a incomplete binary tree.  \\n\\n# Approach\\nOn first occurrence of null set the **nullFound** variable and then if queue has non null value then the tree is not complete binary tree.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        int nullFound=0;\\n        TreeNode n = root;\\n        while(!q.isEmpty()){\\n            n = q.poll();\\n            if(n == null){\\n                nullFound=1;\\n            }\\n            else{\\n                if(nullFound==1)\\n                    return false;\\n                q.add(n.left);\\n                q.add(n.right);    \\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        int nullFound=0;\\n        TreeNode n = root;\\n        while(!q.isEmpty()){\\n            n = q.poll();\\n            if(n == null){\\n                nullFound=1;\\n            }\\n            else{\\n                if(nullFound==1)\\n                    return false;\\n                q.add(n.left);\\n                q.add(n.right);    \\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299065,
                "title": "1ms-simple-and-easy-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean bool = false;\\n        Queue<TreeNode> que = new LinkedList<>();\\n        que.offer(root);\\n        while(!que.isEmpty()){\\n            TreeNode node = que.poll();\\n            if(node == null) bool = true;\\n            else{\\n                 if(bool) return false;\\n                 que.offer(node.left);\\n                 que.offer(node.right);\\n            } \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean bool = false;\\n        Queue<TreeNode> que = new LinkedList<>();\\n        que.offer(root);\\n        while(!que.isEmpty()){\\n            TreeNode node = que.poll();\\n            if(node == null) bool = true;\\n            else{\\n                 if(bool) return false;\\n                 que.offer(node.left);\\n                 que.offer(node.right);\\n            } \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298817,
                "title": "first-way-to-perceive-the-question-for-beginners",
                "content": "# Intuition\\nTo find wheather we have complete binary tree or not we have to use BFS for traversal. As there could not be a node present if we miss any node\\'s child node. Hmm was that confusing? Take it as if a parent does not have a child node indicate that no further child node can be present as if there will be then we will not satisfy the condition of complete binary tree.\\n\\n# Approach\\nMake a stack and store all the level order traversal in stack check if top element\\'s child is abscent if it does then mark the val to 1 indicating no more child should be present. if they are still present then return false else return true.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        stack<TreeNode*> list;\\n        list.push(root);\\n        int val = 0;\\n        while(list.size() != 0){\\n            stack<TreeNode*> dum;\\n            while(list.size() != 0){\\n                if(val == 1 && list.top()->left != NULL)\\n                    return false;\\n                if(list.top()->left == NULL)\\n                val = 1;\\n                else\\n                dum.push(list.top()->left);\\n                if(val == 1 && list.top()->right != NULL)\\n                    return false;\\n                if(list.top()->right == NULL)\\n                val = 1;\\n                else\\n                dum.push(list.top()->right);\\n                list.pop();\\n            }\\n            while(dum.size() != 0){\\n                list.push(dum.top());\\n                dum.pop();\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        stack<TreeNode*> list;\\n        list.push(root);\\n        int val = 0;\\n        while(list.size() != 0){\\n            stack<TreeNode*> dum;\\n            while(list.size() != 0){\\n                if(val == 1 && list.top()->left != NULL)\\n                    return false;\\n                if(list.top()->left == NULL)\\n                val = 1;\\n                else\\n                dum.push(list.top()->left);\\n                if(val == 1 && list.top()->right != NULL)\\n                    return false;\\n                if(list.top()->right == NULL)\\n                val = 1;\\n                else\\n                dum.push(list.top()->right);\\n                list.pop();\\n            }\\n            while(dum.size() != 0){\\n                list.push(dum.top());\\n                dum.pop();\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298773,
                "title": "levelwise-traversal-of-tree-bfs-0-ms-solution-day-15-succesfull",
                "content": "# INTIUTION\\n\\n1. To determine if a binary tree is a complete tree, we can perform a **level-wise traversal (BFS)** and check each node of each level. \\n2.  If we encounter a null node before we reach the last level, then the binary tree is not complete.\\n\\n# Approach\\n**1.** We use a queue to do a level-order traversal of the tree. During the traversal, if we encounter a NULL node, we set a flag to indicate that we have found a missing node. \\n\\n**2.** If we encounter a non-NULL node after finding a missing node, then the tree is not complete.\\n\\n**3.** If we finish the traversal without finding any missing nodes, then the tree is complete.\\n\\n# Complexity\\n**Time complexity**: **O(n)** where n is the number of nodes in the binary tree.\\n**Space complexity**: **O(n**) as we use a queue to store nodes. In the worst case, the queue can contain all the nodes in the tree.\\n\\nFeel free to connect on  **[LinkedIn](https://www.linkedin.com/in/pawas-goyal/)** and if any suggestions comment down\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode *>q;\\n        q.push(root);\\n        int foundNULL=false;\\n        while(!q.empty()){\\n            TreeNode *valnode=q.front();\\n            q.pop();\\n            if(valnode==NULL){\\n                foundNULL=true;\\n\\n            }\\n            else{\\n                if(foundNULL)return false;\\n                q.push(valnode->left);\\n                q.push(valnode->right);\\n            }\\n           \\n        }\\n        return true;\\n    }\\n};\\n```\\n![agXZX2w_700b.jpg](https://assets.leetcode.com/users/images/d17eeb25-29fa-42d5-8e93-99e395616ee8_1678856059.4601285.jpeg)\\n\\n**Please Upvote If u like the solution**\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode *>q;\\n        q.push(root);\\n        int foundNULL=false;\\n        while(!q.empty()){\\n            TreeNode *valnode=q.front();\\n            q.pop();\\n            if(valnode==NULL){\\n                foundNULL=true;\\n\\n            }\\n            else{\\n                if(foundNULL)return false;\\n                q.push(valnode->left);\\n                q.push(valnode->right);\\n            }\\n           \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298731,
                "title": "easy-solution-level-order-traversal",
                "content": "> # Approach\\nBy level order traversal we can traverse through levels and presence of previous left and right nodes are tracked with the help of boolean variables if current node has left or right children but previous node on level order traversal has one or no childern means it is not complete binary tree if it is filled with right child without left child then it is not complete binary tree else it will be complete binary tree. \\n<!-- Describe your approach to solving the problem. -->\\n\\n> # Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n> # Code\\n```\\n\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        boolean first=true;\\n        TreeNode curr = root;\\n        queue.add(root);\\n        int i=1;\\n        boolean prevLeft,prevRight=prevLeft=false;\\n        while(queue.size()>0){\\n            int size = queue.size();\\n            boolean hasLeft=false;\\n            boolean hasRight=false;\\n            while(size>0){\\n                curr = queue.poll();\\n                if(curr.left!=null){\\n                    queue.add(curr.left);\\n                    hasLeft=true;\\n                }\\n                else{\\n                    hasLeft=false;\\n                }\\n                if(curr.right!=null){\\n                    queue.add(curr.right);\\n                    hasRight=true;\\n                }\\n                else{\\n                    hasRight=false;\\n                }\\n                if(hasRight==true && hasLeft==false) return false;\\n            if(first){\\n                prevLeft=hasLeft;\\n                prevRight=hasRight;\\n            }\\n            else{\\n                if((hasLeft==true || hasRight==true) && (prevLeft==false || prevRight==false)) return false;\\n                else{\\n                    prevLeft=hasLeft;\\n                    prevRight=hasRight;\\n                }\\n            }\\n                size--;\\n            }\\n            first=false;\\n            i++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        boolean first=true;\\n        TreeNode curr = root;\\n        queue.add(root);\\n        int i=1;\\n        boolean prevLeft,prevRight=prevLeft=false;\\n        while(queue.size()>0){\\n            int size = queue.size();\\n            boolean hasLeft=false;\\n            boolean hasRight=false;\\n            while(size>0){\\n                curr = queue.poll();\\n                if(curr.left!=null){\\n                    queue.add(curr.left);\\n                    hasLeft=true;\\n                }\\n                else{\\n                    hasLeft=false;\\n                }\\n                if(curr.right!=null){\\n                    queue.add(curr.right);\\n                    hasRight=true;\\n                }\\n                else{\\n                    hasRight=false;\\n                }\\n                if(hasRight==true && hasLeft==false) return false;\\n            if(first){\\n                prevLeft=hasLeft;\\n                prevRight=hasRight;\\n            }\\n            else{\\n                if((hasLeft==true || hasRight==true) && (prevLeft==false || prevRight==false)) return false;\\n                else{\\n                    prevLeft=hasLeft;\\n                    prevRight=hasRight;\\n                }\\n            }\\n                size--;\\n            }\\n            first=false;\\n            i++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298672,
                "title": "c-binary-trees-easy-approach",
                "content": "Here is my c++ ode for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root){return true;}\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(q.front()){\\n            TreeNode* node=q.front();\\n            q.pop();\\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        while(!q.empty() && q.front()==NULL){q.pop();}\\n        return q.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root){return true;}\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(q.front()){\\n            TreeNode* node=q.front();\\n            q.pop();\\n            q.push(node->left);\\n            q.push(node->right);\\n        }\\n        while(!q.empty() && q.front()==NULL){q.pop();}\\n        return q.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298622,
                "title": "easy-python-solution-bfs-queue",
                "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n\\n        def bfs(node):\\n\\n            if not node:\\n                return False\\n\\n            queue = []\\n            queue.append(node)\\n\\n            next = []\\n            flag = 0\\n            level = 0\\n            isLast = 1\\n\\n            while queue:\\n                temp = queue.pop(0)\\n\\n                if (not temp.left) and (temp.right):\\n                    return False\\n\\n                if temp.left:\\n                    if flag == 1:\\n                        return False\\n                    next.append(temp.left)\\n\\n                    if temp.left.left or temp.left.right:\\n                        isLast = 0\\n\\n                if temp.right:\\n                    next.append(temp.right)\\n                    if temp.right.left or temp.right.right:\\n                        isLast = 0\\n                else:\\n                    flag = 1\\n\\n                if len(queue) == 0:\\n                    level += 1\\n\\n                    if isLast == 1:\\n                        return True\\n\\n                    if len(next) != 2**level:\\n                        return False\\n\\n                    queue = next\\n                    next = []\\n                    flag = 0\\n                    isLast = 1\\n\\n            return True\\n        \\n        return bfs(root)           \\n```\\nDo upvote if you like the Solution :)",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n\\n        def bfs(node):\\n\\n            if not node:\\n                return False\\n\\n            queue = []\\n            queue.append(node)\\n\\n            next = []\\n            flag = 0\\n            level = 0\\n            isLast = 1\\n\\n            while queue:\\n                temp = queue.pop(0)\\n\\n                if (not temp.left) and (temp.right):\\n                    return False\\n\\n                if temp.left:\\n                    if flag == 1:\\n                        return False\\n                    next.append(temp.left)\\n\\n                    if temp.left.left or temp.left.right:\\n                        isLast = 0\\n\\n                if temp.right:\\n                    next.append(temp.right)\\n                    if temp.right.left or temp.right.right:\\n                        isLast = 0\\n                else:\\n                    flag = 1\\n\\n                if len(queue) == 0:\\n                    level += 1\\n\\n                    if isLast == 1:\\n                        return True\\n\\n                    if len(next) != 2**level:\\n                        return False\\n\\n                    queue = next\\n                    next = []\\n                    flag = 0\\n                    isLast = 1\\n\\n            return True\\n        \\n        return bfs(root)           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298523,
                "title": "awesome-logic-with-bfs-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:95%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:99%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        q,gap=deque([root]),False\\n        while q:\\n            poping=q.popleft()\\n            if not poping: gap=True\\n            else:\\n                if gap: return False\\n                q.append(poping.left)\\n                q.append(poping.right)\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        q,gap=deque([root]),False\\n        while q:\\n            poping=q.popleft()\\n            if not poping: gap=True\\n            else:\\n                if gap: return False\\n                q.append(poping.left)\\n                q.append(poping.right)\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298484,
                "title": "beats-100-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool bfs(TreeNode* node){\\n        queue<TreeNode*>q;\\n        q.push(node);\\n        int lvl = 0;\\n        while(!q.empty()){\\n            int flag = 0;\\n            TreeNode* temp = q.front();\\n            int sz = q.size();\\n            cout<<sz;\\n            if( temp->left || temp->right){\\n                cout<<\" \"<<pow(2,lvl)<<endl;\\n                if(sz != pow(2,lvl)) return false;\\n            }\\n            for(int i=0; i<sz; i++){\\n                temp = q.front();\\n                q.pop();\\n                if(flag == 1 && (temp->left || temp->right)) return false;\\n                if(temp->left) q.push(temp->left);\\n                else flag = 1;\\n                if(!temp->left && temp->right) return false;\\n                if(temp->right) q.push(temp->right);\\n                else flag = 1; \\n            }\\n            lvl++;\\n        }\\n        return true;\\n    }\\n    bool isCompleteTree(TreeNode* root) {\\n        return bfs(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool bfs(TreeNode* node){\\n        queue<TreeNode*>q;\\n        q.push(node);\\n        int lvl = 0;\\n        while(!q.empty()){\\n            int flag = 0;\\n            TreeNode* temp = q.front();\\n            int sz = q.size();\\n            cout<<sz;\\n            if( temp->left || temp->right){\\n                cout<<\" \"<<pow(2,lvl)<<endl;\\n                if(sz != pow(2,lvl)) return false;\\n            }\\n            for(int i=0; i<sz; i++){\\n                temp = q.front();\\n                q.pop();\\n                if(flag == 1 && (temp->left || temp->right)) return false;\\n                if(temp->left) q.push(temp->left);\\n                else flag = 1;\\n                if(!temp->left && temp->right) return false;\\n                if(temp->right) q.push(temp->right);\\n                else flag = 1; \\n            }\\n            lvl++;\\n        }\\n        return true;\\n    }\\n    bool isCompleteTree(TreeNode* root) {\\n        return bfs(root);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3298257,
                "title": "level-order-traversal-c-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n       \\n        // If the root is NULL, the tree is complete.\\n        if(!root) return true;\\n        \\n        // Create a queue to store the nodes of the tree.\\n        queue<TreeNode*> q;\\n        \\n        // Add the root node to the queue.\\n        q.push(root);\\n        \\n        // Flag to check if there is any non-full node encountered in the tree.\\n        bool Non_full_Node = false;\\n        \\n        // Loop until the queue is empty.\\n        while(!q.empty()){\\n            \\n            // Get the front node of the queue.\\n            TreeNode* node = q.front();\\n            \\n            // Pop the front node from the queue.\\n            q.pop();\\n            \\n            // If the node is NULL, set the non-full node flag to true.\\n            if(node == NULL)\\n                Non_full_Node = true;\\n            \\n            // If the node is not NULL, check if the previous node was non-full.\\n            else{\\n                \\n                // If the previous node was non-full, the tree is not complete.\\n                if(Non_full_Node == true) {\\n                    return false;\\n                }\\n                \\n                // Add the left child of the current node to the queue.\\n                q.push(node->left);\\n                \\n                // Add the right child of the current node to the queue.\\n                q.push(node->right);\\n            }\\n        }\\n        \\n        // If all nodes have been processed and no non-full node has been encountered, the tree is complete.\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n       \\n        // If the root is NULL, the tree is complete.\\n        if(!root) return true;\\n        \\n        // Create a queue to store the nodes of the tree.\\n        queue<TreeNode*> q;\\n        \\n        // Add the root node to the queue.\\n        q.push(root);\\n        \\n        // Flag to check if there is any non-full node encountered in the tree.\\n        bool Non_full_Node = false;\\n        \\n        // Loop until the queue is empty.\\n        while(!q.empty()){\\n            \\n            // Get the front node of the queue.\\n            TreeNode* node = q.front();\\n            \\n            // Pop the front node from the queue.\\n            q.pop();\\n            \\n            // If the node is NULL, set the non-full node flag to true.\\n            if(node == NULL)\\n                Non_full_Node = true;\\n            \\n            // If the node is not NULL, check if the previous node was non-full.\\n            else{\\n                \\n                // If the previous node was non-full, the tree is not complete.\\n                if(Non_full_Node == true) {\\n                    return false;\\n                }\\n                \\n                // Add the left child of the current node to the queue.\\n                q.push(node->left);\\n                \\n                // Add the right child of the current node to the queue.\\n                q.push(node->right);\\n            }\\n        }\\n        \\n        // If all nodes have been processed and no non-full node has been encountered, the tree is complete.\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781521,
                "title": "java-c-bfs-level-order-traversal",
                "content": "# Intuition\\nWhen level-order traversal in a complete tree, after the last node, all nodes in the queue should be null.\\nOtherwise, the tree is not complete.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: We are doing just the Level Order Traversal so T.C - $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ for queue.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nif(you like)\\n\\tplease please UPVOTE\\uD83D\\uDE0A\\uD83D\\uDE0A;\\n```\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        bool end = false;\\n        while(!q.empty())\\n        {\\n            TreeNode* cur = q.front();\\n            q.pop();\\n            if(cur == NULL)     // We encounter a NULL and this should be our end node. Like ex-1.\\n                end = true;  \\n            else  // cur != NULL\\n            {\\n                if(end == true)  // means after encountering a NULL we again encountered a node like ex-2.\\n                    return false;\\n                q.push(cur->left);\\n                q.push(cur->right);\\n            }\\n        }\\n        return true;  // We never encounter a false so return true;\\n    }\\n};\\n```\\n\\n\\n# Java Code\\n```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        boolean end = false;\\n        while(!q.isEmpty())\\n        {\\n            TreeNode cur = q.poll();\\n            if(cur == null)     // We encounter a null and this should be our end node. Like ex-1.\\n                end = true;  \\n            else  // cur != null\\n            {\\n                if(end == true)  // means after encountering a null we again encountered a node like ex-2.\\n                    return false;\\n                q.offer(cur.left);\\n                q.offer(cur.right);\\n            }\\n        }\\n        return true;  // We never encounter a false so return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nif(you like)\\n\\tplease please UPVOTE\\uD83D\\uDE0A\\uD83D\\uDE0A;\\n```\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        bool end = false;\\n        while(!q.empty())\\n        {\\n            TreeNode* cur = q.front();\\n            q.pop();\\n            if(cur == NULL)     // We encounter a NULL and this should be our end node. Like ex-1.\\n                end = true;  \\n            else  // cur != NULL\\n            {\\n                if(end == true)  // means after encountering a NULL we again encountered a node like ex-2.\\n                    return false;\\n                q.push(cur->left);\\n                q.push(cur->right);\\n            }\\n        }\\n        return true;  // We never encounter a false so return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        boolean end = false;\\n        while(!q.isEmpty())\\n        {\\n            TreeNode cur = q.poll();\\n            if(cur == null)     // We encounter a null and this should be our end node. Like ex-1.\\n                end = true;  \\n            else  // cur != null\\n            {\\n                if(end == true)  // means after encountering a null we again encountered a node like ex-2.\\n                    return false;\\n                q.offer(cur.left);\\n                q.offer(cur.right);\\n            }\\n        }\\n        return true;  // We never encounter a false so return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500312,
                "title": "easy-simple-small-fast",
                "content": "```\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        t=[root]\\n        flg=0\\n        while(len(t)>0):\\n            if(len(t)==t.count(None)):\\n                print(\"yo\")\\n                break\\n            if(flg==1):\\n                return False\\n            \\n            n=len(t)\\n            tt=[]\\n            for i in range(n):\\n                if(t[i]!=None):\\n                    if(flg==1):\\n                        return False\\n                    tt.append(t[i].left)\\n                    tt.append(t[i].right)\\n                elif(t[i]==None):\\n                    flg=1\\n            t=tt\\n        return(True)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        t=[root]\\n        flg=0\\n        while(len(t)>0):\\n            if(len(t)==t.count(None)):\\n                print(\"yo\")\\n                break\\n            if(flg==1):\\n                return False\\n            \\n            n=len(t)\\n            tt=[]\\n            for i in range(n):\\n                if(t[i]!=None):\\n                    if(flg==1):\\n                        return False\\n                    tt.append(t[i].left)\\n                    tt.append(t[i].right)\\n                elif(t[i]==None):\\n                    flg=1\\n            t=tt\\n        return(True)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2344059,
                "title": "c-recursion-simple-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    //Step 1: calculate total nodes in a binary tree\\n    int totalNodes(TreeNode* root){\\n        if(root == NULL)return 0;\\n        int ans = 1 + totalNodes(root->left)+totalNodes(root->right);\\n        return ans;\\n    }\\n    //Step2 : check wheather it is CBT\\n    bool checkCBT(TreeNode* root, int i, int n){\\n        if(root == NULL){\\n            return true;\\n        }\\n        if(i >= n){\\n            // if it\\'s left or right child exceed the indes then it is not CBT\\n            return false;\\n        }\\n        else{\\n            bool left = checkCBT(root->left, 2*i+1, n); // calculate left\\n            bool right = checkCBT(root->right, 2*i+2, n); // caluclate right\\n            return (left&&right); // return left and right\\n        }\\n    }\\n    bool isCompleteTree(TreeNode* root) {\\n        int n = totalNodes(root);\\n        return checkCBT(root, 0 , n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    //Step 1: calculate total nodes in a binary tree\\n    int totalNodes(TreeNode* root){\\n        if(root == NULL)return 0;\\n        int ans = 1 + totalNodes(root->left)+totalNodes(root->right);\\n        return ans;\\n    }\\n    //Step2 : check wheather it is CBT\\n    bool checkCBT(TreeNode* root, int i, int n){\\n        if(root == NULL){\\n            return true;\\n        }\\n        if(i >= n){\\n            // if it\\'s left or right child exceed the indes then it is not CBT\\n            return false;\\n        }\\n        else{\\n            bool left = checkCBT(root->left, 2*i+1, n); // calculate left\\n            bool right = checkCBT(root->right, 2*i+2, n); // caluclate right\\n            return (left&&right); // return left and right\\n        }\\n    }\\n    bool isCompleteTree(TreeNode* root) {\\n        int n = totalNodes(root);\\n        return checkCBT(root, 0 , n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097437,
                "title": "python-simple-solution",
                "content": "I used simple approach, tired to manage one queue called as q. I will append node only when its not None. If I found node.left or node.right as None, simply add that data as well. \\n\\nNow check where you found None in queue, if you get None make pre = False, means if you found number after Pre= False, that means this is not Complete Binary tree\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        q = deque()\\n        q.append(root)\\n        pre= True\\n        while q :\\n            \\n            curr = q.popleft()\\n            \\n            if curr is None :\\n                pre = False\\n            else :\\n                if pre == False :\\n                    return False \\n                \\n                q.append(curr.left)\\n                q.append(curr.right)\\n                \\n                \\n        return True\\n```\\n\\nplease upvote if you like the idea !",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\\n        q = deque()\\n        q.append(root)\\n        pre= True\\n        while q :\\n            \\n            curr = q.popleft()\\n            \\n            if curr is None :\\n                pre = False\\n            else :\\n                if pre == False :\\n                    return False \\n                \\n                q.append(curr.left)\\n                q.append(curr.right)\\n                \\n                \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028866,
                "title": "c-easy-solution-runtime-0ms-fastest-then-100-user-dfs-solution",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n\\n**Runtime: 0 ms, faster than 100.00% of C++ online submissions for Check Completeness of a Binary Tree.\\nMemory Usage: 10.4 MB, less than 76.06% of C++ online submissions for Check Completeness of a Binary Tree.**\\n\\nTime complexity is O(n) and space complexty is O(n)\\n\\n```\\nclass Solution {\\n    // counting no of nodes in a tree\\n    int countnode(TreeNode* root)\\n    {\\n        if(root==NULL) return 0;\\n        int ans=1+countnode(root->left)+countnode(root->right);\\n        return ans;\\n    }\\n    // checking tree is a complete binary tree or not\\n    bool iscbt(TreeNode* root, int index , int count)\\n    {\\n        if(root==NULL) return true;\\n        if(index>=count) return false;\\n        else\\n        {\\n            bool left=iscbt(root->left,2*index+1,count);\\n            bool right=iscbt(root->right,2*index+2,count);\\n            return left && right;\\n        }\\n    }\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        \\n        int count=countnode(root);\\n      \\n        int index=0;\\n        \\n        if(iscbt(root,index,count))  return true; // cbt(complete binary tree) is helper function  \\n        else return false;                        \\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    // counting no of nodes in a tree\\n    int countnode(TreeNode* root)\\n    {\\n        if(root==NULL) return 0;\\n        int ans=1+countnode(root->left)+countnode(root->right);\\n        return ans;\\n    }\\n    // checking tree is a complete binary tree or not\\n    bool iscbt(TreeNode* root, int index , int count)\\n    {\\n        if(root==NULL) return true;\\n        if(index>=count) return false;\\n        else\\n        {\\n            bool left=iscbt(root->left,2*index+1,count);\\n            bool right=iscbt(root->right,2*index+2,count);\\n            return left && right;\\n        }\\n    }\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        \\n        int count=countnode(root);\\n      \\n        int index=0;\\n        \\n        if(iscbt(root,index,count))  return true; // cbt(complete binary tree) is helper function  \\n        else return false;                        \\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026604,
                "title": "level-order",
                "content": "class Solution {\\npublic:\\n\\n    bool isCompleteTree(TreeNode* root)  {\\n       queue<TreeNode*>q;\\n        q.push(root);\\n        TreeNode* temp;\\n        TreeNode* temp1;\\n        while(!q.empty())\\n        {\\n            temp = q.front();\\n            q.pop();\\n            \\n            if(temp == nullptr){\\n                while(!q.empty())\\n                {\\n                    if(q.front()!= nullptr){\\n                        return false;\\n                    } \\n                    q.pop();\\n                }\\n                return true;\\n            }\\n           \\n                q.push(temp->left);\\n                q.push (temp->right);\\n           \\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool isCompleteTree(TreeNode* root)  {\\n       queue<TreeNode*>q;\\n        q.push(root);\\n        TreeNode* temp;\\n        TreeNode* temp1;\\n        while(!q.empty())\\n        {\\n            temp = q.front();\\n            q.pop();\\n            \\n            if(temp == nullptr){\\n                while(!q.empty())\\n                {\\n                    if(q.front()!= nullptr){\\n                        return false;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1974124,
                "title": "c-solution",
                "content": "```\\n    bool isCompleteTree(TreeNode* root) {\\n        // we do BFS\\n        // if we meet the first node which has no left nor right child\\n        // we can assume that if the tree is complete, we would never meet any children any longer\\n        // if we meet any child after that then it means that the tree is not complete\\n        bool noMoreChild = false;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while (q.size() > 0) {\\n            TreeNode* node = q.front();\\n            if (node->left == NULL) {\\n                noMoreChild = true;\\n            } else {\\n                if (noMoreChild) {\\n                    return false;\\n                }\\n                q.push(node->left);\\n            }\\n            if (node->right == NULL) {\\n                noMoreChild = true;\\n            } else {\\n                if (noMoreChild) {\\n                    return false;\\n                }\\n                q.push(node->right);\\n            }\\n            q.pop();\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool isCompleteTree(TreeNode* root) {\\n        // we do BFS\\n        // if we meet the first node which has no left nor right child\\n        // we can assume that if the tree is complete, we would never meet any children any longer\\n        // if we meet any child after that then it means that the tree is not complete\\n        bool noMoreChild = false;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while (q.size() > 0) {\\n            TreeNode* node = q.front();\\n            if (node->left == NULL) {\\n                noMoreChild = true;\\n            } else {\\n                if (noMoreChild) {\\n                    return false;\\n                }\\n                q.push(node->left);\\n            }\\n            if (node->right == NULL) {\\n                noMoreChild = true;\\n            } else {\\n                if (noMoreChild) {\\n                    return false;\\n                }\\n                q.push(node->right);\\n            }\\n            q.pop();\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1906459,
                "title": "c-level-order-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root) return true;\\n        // Intution : \\n        // In a complete binary tree you will never encounter null node between the not-null nodes.\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\t\\t// foundNull : used to check if a null node is found in between the not-null nodes.\\n        bool foundNull = false;\\n        while(!q.empty())\\n        {\\n            TreeNode *curr = q.front();\\n            q.pop();\\n            if(curr->left)\\n            {\\n                if(foundNull) // if foundNull is marked true then tree is not a complete tree\\n                    return false;\\n                q.push(curr->left);\\n            }\\n            else\\n                foundNull = true;  // is current node becomes NULL, mark foundNull as true\\n            if(curr->right)\\n            {\\n                if(foundNull)\\n                    return false;\\n                q.push(curr->right);\\n            }\\n            else\\n                foundNull = true;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root) return true;\\n        // Intution : \\n        // In a complete binary tree you will never encounter null node between the not-null nodes.\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\t\\t// foundNull : used to check if a null node is found in between the not-null nodes.\\n        bool foundNull = false;\\n        while(!q.empty())\\n        {\\n            TreeNode *curr = q.front();\\n            q.pop();\\n            if(curr->left)\\n            {\\n                if(foundNull) // if foundNull is marked true then tree is not a complete tree\\n                    return false;\\n                q.push(curr->left);\\n            }\\n            else\\n                foundNull = true;  // is current node becomes NULL, mark foundNull as true\\n            if(curr->right)\\n            {\\n                if(foundNull)\\n                    return false;\\n                q.push(curr->right);\\n            }\\n            else\\n                foundNull = true;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1798827,
                "title": "ruby-concise-and-fast",
                "content": "```\\ndef is_complete_tree(root)\\n    q=[root]\\n    while node=q.shift\\n        q<<node.left\\n        q<<node.right\\n    end\\n    q.uniq == [nil] ? true : false\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef is_complete_tree(root)\\n    q=[root]\\n    while node=q.shift\\n        q<<node.left\\n        q<<node.right\\n    end\\n    q.uniq == [nil] ? true : false\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1755977,
                "title": "java-solution-bfs-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\\n        q.add(root);\\n        \\n        boolean gotNullNode = false;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for (;size>0;size--){\\n                var node = q.poll();\\n                \\n                if (node != null && gotNullNode){\\n                    return false;\\n                }\\n                \\n                if (node == null){\\n                    gotNullNode = true;\\n                } else {\\n                    q.add(node.left);\\n                    q.add(node.right);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\\n        q.add(root);\\n        \\n        boolean gotNullNode = false;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for (;size>0;size--){\\n                var node = q.poll();\\n                \\n                if (node != null && gotNullNode){\\n                    return false;\\n                }\\n                \\n                if (node == null){\\n                    gotNullNode = true;\\n                } else {\\n                    q.add(node.left);\\n                    q.add(node.right);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482243,
                "title": "easy-javascript-solution-using-breadth-first-search",
                "content": "```\\nvar isCompleteTree = function(root) {\\n    let hasSeenNull = false\\n    let complete = true\\n    let queue = []\\n\\n\\n    const traverse = () => {\\n        if (!complete) return complete\\n\\n        const node = queue.shift()\\n\\n        if (!node) return false\\n\\n        const right = node.right\\n        const left = node.left\\n\\n        if (left ){\\n            if (hasSeenNull) {\\n                complete = false\\n                return true\\n            }\\n            queue.push(left)\\n        }else {\\n            hasSeenNull = true\\n        }\\n\\n        if (right ){\\n            if (hasSeenNull) {\\n                complete = false\\n                return true\\n            }\\n            queue.push(right)\\n        }else {\\n            hasSeenNull = true\\n        }\\n\\n        traverse ()\\n    }\\n\\n\\n    queue.push(root)\\n    \\n    traverse()\\n    \\n    return complete\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar isCompleteTree = function(root) {\\n    let hasSeenNull = false\\n    let complete = true\\n    let queue = []\\n\\n\\n    const traverse = () => {\\n        if (!complete) return complete\\n\\n        const node = queue.shift()\\n\\n        if (!node) return false\\n\\n        const right = node.right\\n        const left = node.left\\n\\n        if (left ){\\n            if (hasSeenNull) {\\n                complete = false\\n                return true\\n            }\\n            queue.push(left)\\n        }else {\\n            hasSeenNull = true\\n        }\\n\\n        if (right ){\\n            if (hasSeenNull) {\\n                complete = false\\n                return true\\n            }\\n            queue.push(right)\\n        }else {\\n            hasSeenNull = true\\n        }\\n\\n        traverse ()\\n    }\\n\\n\\n    queue.push(root)\\n    \\n    traverse()\\n    \\n    return complete\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1437393,
                "title": "c-bfs",
                "content": "```\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        bool isEnd = false;\\n        while(!q.empty()){\\n            auto p = q.front(); q.pop();\\n            if(!p){\\n                isEnd = true;\\n                continue;\\n            } \\n            else if(isEnd) return false;\\n            q.push(p->left);\\n            q.push(p->right);\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "```\\n    bool isCompleteTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        bool isEnd = false;\\n        while(!q.empty()){\\n            auto p = q.front(); q.pop();\\n            if(!p){\\n                isEnd = true;\\n                continue;\\n            } \\n            else if(isEnd) return false;\\n            q.push(p->left);\\n            q.push(p->right);\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1374645,
                "title": "just-bfs-and-no-extra-code-100-fast-explained",
                "content": "just think it this way:\\n**If at least 1 null pointer is obtained in level traversal then no furthur nodes should be available for complete binary tree!!**\\n\\n```\\n bool isCompleteTree(TreeNode* root) {\\n         queue<TreeNode*> q;\\n        TreeNode* t;\\n        q.push(root);\\n        while(q.size()){\\n            int n=q.size();\\n            t=q.front(); q.pop();\\n\\t\\t\\tif(t){                                                                       // push even if children are null\\n                q.push(t->left);  \\n                q.push(t->right);\\n            }\\n            else{                                                                                    // if at least 1 null pointer is obtained \\n                while(q.size()&&q.front()==nullptr)q.pop();                                     // pop all null pointers \\n                if(q.size()) return 0;                                                          // still if queue is not empty then return false \\n            }\\n            \\n        }\\n        return 1;                 // if queue is empty return true\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n bool isCompleteTree(TreeNode* root) {\\n         queue<TreeNode*> q;\\n        TreeNode* t;\\n        q.push(root);\\n        while(q.size()){\\n            int n=q.size();\\n            t=q.front(); q.pop();\\n\\t\\t\\tif(t){                                                                       // push even if children are null\\n                q.push(t->left);  \\n                q.push(t->right);\\n            }\\n            else{                                                                                    // if at least 1 null pointer is obtained \\n                while(q.size()&&q.front()==nullptr)q.pop();                                     // pop all null pointers \\n                if(q.size()) return 0;                                                          // still if queue is not empty then return false \\n            }\\n            \\n        }\\n        return 1;                 // if queue is empty return true\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1242350,
                "title": "java-bfs-level-order-traversal-100-performance",
                "content": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root==null)\\n            return true;\\n        boolean last = false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(!queue.isEmpty())\\n        {\\n            int s = queue.size();\\n            if(last)//this level is last one.\\n            {\\n                for(int i=0;i<s;i++)\\n                {\\n                   TreeNode node = queue.remove();\\n                    //as its last level we should not see any childs if so then return false.\\n                    if(node.left!=null || node.right!=null)\\n                        return false;\\n                }\\n            }\\n            else\\n            {\\n                for(int i=0;i<s;i++)\\n                {\\n                    TreeNode node = queue.remove();\\n                    //in this level we already got null child node, so we should not get any more child nodes for current level nodes.\\n                    if(last)\\n                    {\\n                        if(node.left!=null || node.right!=null)\\n                            return false;\\n                    }\\n                    //if we see a null child mark end of tree;\\n                    if(node.left==null){\\n                        last=true;\\n                    }\\n                    else \\n                    {\\n                        //If we already saw end of tree, but still we have childs for current level nodes then its not complete binary tree;\\n                        if(last){\\n                            return false;\\n                        }\\n                        queue.add(node.left);\\n                    }\\n                    //if we see a null child mark end of tree;\\n                    if(node.right==null){\\n                        last=true;\\n                    }\\n                    else\\n                    {\\n                        //If we already saw end of tree, but still we have childs for current level nodes then its not complete binary tree;\\n                        if(last){\\n                            return false;\\n                        }\\n                        queue.add(node.right);\\n                    }  \\n                }\\n            }\\n            \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root==null)\\n            return true;\\n        boolean last = false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(!queue.isEmpty())\\n        {\\n            int s = queue.size();\\n            if(last)//this level is last one.\\n            {\\n                for(int i=0;i<s;i++)\\n                {\\n                   TreeNode node = queue.remove();\\n                    //as its last level we should not see any childs if so then return false.\\n                    if(node.left!=null || node.right!=null)\\n                        return false;\\n                }\\n            }\\n            else\\n            {\\n                for(int i=0;i<s;i++)\\n                {\\n                    TreeNode node = queue.remove();\\n                    //in this level we already got null child node, so we should not get any more child nodes for current level nodes.\\n                    if(last)\\n                    {\\n                        if(node.left!=null || node.right!=null)\\n                            return false;\\n                    }\\n                    //if we see a null child mark end of tree;\\n                    if(node.left==null){\\n                        last=true;\\n                    }\\n                    else \\n                    {\\n                        //If we already saw end of tree, but still we have childs for current level nodes then its not complete binary tree;\\n                        if(last){\\n                            return false;\\n                        }\\n                        queue.add(node.left);\\n                    }\\n                    //if we see a null child mark end of tree;\\n                    if(node.right==null){\\n                        last=true;\\n                    }\\n                    else\\n                    {\\n                        //If we already saw end of tree, but still we have childs for current level nodes then its not complete binary tree;\\n                        if(last){\\n                            return false;\\n                        }\\n                        queue.add(node.right);\\n                    }  \\n                }\\n            }\\n            \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1216558,
                "title": "intuitive-bfs",
                "content": "**Every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible** in English is: no non-empty nodes after the first empty node hit in the BFS traversal order.\\n\\nDuring BFS, a node is polled from the queue and its non-empty children are added to the queue; for empty children, we mark `emptyHit` and move on. Nodes polled can never have non-empty children after `emptyHit`.\\n\\n```\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        boolean emptyHit = false;\\n        while(!q.isEmpty()) {\\n            TreeNode cur = q.poll();\\n            if (cur.left != null) {\\n                if (emptyHit) {\\n                    return false;\\n                }\\n                q.offer(cur.left);\\n            } else {\\n                emptyHit = true;\\n            }\\n            if (cur.right != null) {\\n                if (emptyHit) {\\n                    return false;\\n                }\\n                q.offer(cur.right);\\n            } else {\\n                emptyHit = true;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        boolean emptyHit = false;\\n        while(!q.isEmpty()) {\\n            TreeNode cur = q.poll();\\n            if (cur.left != null) {\\n                if (emptyHit) {\\n                    return false;\\n                }\\n                q.offer(cur.left);\\n            } else {\\n                emptyHit = true;\\n            }\\n            if (cur.right != null) {\\n                if (emptyHit) {\\n                    return false;\\n                }\\n                q.offer(cur.right);\\n            } else {\\n                emptyHit = true;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1165388,
                "title": "c-0ms-100-iterative",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Check Completeness of a Binary Tree.\\nMemory Usage: 10.5 MB, less than 47.28% of C++ online submissions for Check Completeness of a Binary Tree.\\n```\\nclass Solution {\\npublic:\\n  bool isCompleteTree(TreeNode* root) {\\n    queue<TreeNode*> q;\\n    q.push(root);\\n    while(!q.empty()){\\n      int n = q.size();\\n      while(n--){\\n        TreeNode *tmp = q.front(); q.pop();\\n        \\n        if(tmp->left) q.push(tmp->left);\\n        else{\\n          if(tmp->right) return false;\\n          while(!q.empty()){\\n            tmp = q.front(); q.pop();\\n            if(tmp->left || tmp->right) return false;\\n          }\\n          return true;\\n        }\\n        if(tmp->right) q.push(tmp->right);\\n        else{\\n          while(!q.empty()){\\n            tmp = q.front(); q.pop();\\n            if(tmp->left || tmp->right) return false;\\n          }\\n          return true;\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool isCompleteTree(TreeNode* root) {\\n    queue<TreeNode*> q;\\n    q.push(root);\\n    while(!q.empty()){\\n      int n = q.size();\\n      while(n--){\\n        TreeNode *tmp = q.front(); q.pop();\\n        \\n        if(tmp->left) q.push(tmp->left);\\n        else{\\n          if(tmp->right) return false;\\n          while(!q.empty()){\\n            tmp = q.front(); q.pop();\\n            if(tmp->left || tmp->right) return false;\\n          }\\n          return true;\\n        }\\n        if(tmp->right) q.push(tmp->right);\\n        else{\\n          while(!q.empty()){\\n            tmp = q.front(); q.pop();\\n            if(tmp->left || tmp->right) return false;\\n          }\\n          return true;\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164970,
                "title": "java-100-faster-simple-solution-preorder-traversal",
                "content": "```\\nclass Solution {\\n    \\n    int size=0, max=0;\\n\\n    public boolean isCompleteTree(TreeNode root) {\\n        if (root==null) {\\n            return true;\\n        }\\n        \\n        helper (root,0);\\n        return size-1 == max;\\n    }\\n    \\n    void helper (TreeNode root, int position) {\\n        if (root != null) {\\n            max = Math.max(position, max);\\n            size++;\\n            helper (root.left, position*2+1);\\n            helper (root.right, position*2+2);\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int size=0, max=0;\\n\\n    public boolean isCompleteTree(TreeNode root) {\\n        if (root==null) {\\n            return true;\\n        }\\n        \\n        helper (root,0);\\n        return size-1 == max;\\n    }\\n    \\n    void helper (TreeNode root, int position) {\\n        if (root != null) {\\n            max = Math.max(position, max);\\n            size++;\\n            helper (root.left, position*2+1);\\n            helper (root.right, position*2+2);\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1106847,
                "title": "java-1ms-faster-than-68",
                "content": "```\\n/**\\n * Definition for a binary tree node. public class TreeNode { int val; TreeNode\\n * left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; }\\n * TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left\\n * = left; this.right = right; } }\\n */\\nclass Solution {\\n\\tpublic boolean isCompleteTree(TreeNode root) {\\n\\n\\t\\tQueue<TreeNode> que = new LinkedList<>();\\n\\n\\t\\tque.offer(root);\\n\\t\\tboolean isNullSeen = false;\\n\\t\\twhile (!que.isEmpty()) {\\n\\n\\t\\t\\tint size = que.size();\\n\\n\\t\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\t\\tTreeNode poll = que.poll();\\n\\t\\t\\t\\tif (poll == null) {\\n\\t\\t\\t\\t\\tisNullSeen = true;\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif (isNullSeen) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tque.offer(poll.left);\\n\\t\\t\\t\\t\\tque.offer(poll.right);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node. public class TreeNode { int val; TreeNode\\n * left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; }\\n * TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left\\n * = left; this.right = right; } }\\n */\\nclass Solution {\\n\\tpublic boolean isCompleteTree(TreeNode root) {\\n\\n\\t\\tQueue<TreeNode> que = new LinkedList<>();\\n\\n\\t\\tque.offer(root);\\n\\t\\tboolean isNullSeen = false;\\n\\t\\twhile (!que.isEmpty()) {\\n\\n\\t\\t\\tint size = que.size();\\n\\n\\t\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\t\\tTreeNode poll = que.poll();\\n\\t\\t\\t\\tif (poll == null) {\\n\\t\\t\\t\\t\\tisNullSeen = true;\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif (isNullSeen) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tque.offer(poll.left);\\n\\t\\t\\t\\t\\tque.offer(poll.right);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1071429,
                "title": "go-bfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n \\nfunc isCompleteTree(root *TreeNode) bool {\\n    queue := []*TreeNode {root}\\n    stopped := false\\n\\n    for len(queue) > 0 {\\n        cur := queue[0]\\n        queue = queue[1:]\\n        \\n\\t\\t// if the current node is nil, then, from now on, all the nodes on the same depth and all the leaf nodes should also be nil\\n        if cur == nil {\\n            stopped = true\\n            continue\\n        }\\n        \\n        if cur != nil && stopped {\\n            return false\\n        }\\n        \\n        queue = append(queue, cur.Left, cur.Right)\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n \\nfunc isCompleteTree(root *TreeNode) bool {\\n    queue := []*TreeNode {root}\\n    stopped := false\\n\\n    for len(queue) > 0 {\\n        cur := queue[0]\\n        queue = queue[1:]\\n        \\n\\t\\t// if the current node is nil, then, from now on, all the nodes on the same depth and all the leaf nodes should also be nil\\n        if cur == nil {\\n            stopped = true\\n            continue\\n        }\\n        \\n        if cur != nil && stopped {\\n            return false\\n        }\\n        \\n        queue = append(queue, cur.Left, cur.Right)\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1036947,
                "title": "c-bfs-faster-than-100-runtime-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root)\\n            return true;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        TreeNode* curr;\\n        while(!q.empty()){\\n            curr=q.front();\\n            q.pop();\\n            if(curr==NULL)\\n                break;\\n            q.push(curr->left);\\n            q.push(curr->right);\\n        }\\n        if(q.empty())\\n            return true;\\n        while(!q.empty()){\\n            curr=q.front();\\n            q.pop();\\n            if(curr)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root)\\n            return true;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        TreeNode* curr;\\n        while(!q.empty()){\\n            curr=q.front();\\n            q.pop();\\n            if(curr==NULL)\\n                break;\\n            q.push(curr->left);\\n            q.push(curr->right);\\n        }\\n        if(q.empty())\\n            return true;\\n        while(!q.empty()){\\n            curr=q.front();\\n            q.pop();\\n            if(curr)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023883,
                "title": "easy-bfs-dfs-python",
                "content": "**BFS: O(n) time and space**\\n\\n```\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        if not root:\\n            return       \\n        ret = []\\n        q = collections.deque([(root, 1)])\\n        while q:\\n            node, idx = q.popleft()\\n            ret.append(idx)\\n            if node.left:\\n                q+=[(node.left, 2*idx)]\\n            if node.right:\\n                q+=[(node.right, 2*idx+1)] \\n        return len(ret)==ret[-1]\\n```\\n\\n**DFS: O(n) time and space**\\n```\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        def dfs(node, idx):\\n            ret.append(idx)\\n            if node.left:\\n                dfs(node.left, 2*idx)\\n            if node.right:\\n                dfs(node.right, 2*idx+1)           \\n        ret = []\\n        if not root:\\n            return \\n        dfs(root, 1)\\n        return len(ret)==max(ret)\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        if not root:\\n            return       \\n        ret = []\\n        q = collections.deque([(root, 1)])\\n        while q:\\n            node, idx = q.popleft()\\n            ret.append(idx)\\n            if node.left:\\n                q+=[(node.left, 2*idx)]\\n            if node.right:\\n                q+=[(node.right, 2*idx+1)] \\n        return len(ret)==ret[-1]\\n```\n```\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        def dfs(node, idx):\\n            ret.append(idx)\\n            if node.left:\\n                dfs(node.left, 2*idx)\\n            if node.right:\\n                dfs(node.right, 2*idx+1)           \\n        ret = []\\n        if not root:\\n            return \\n        dfs(root, 1)\\n        return len(ret)==max(ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1013096,
                "title": "c-bfs-simple-straight-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(NULL == root)\\n            return true;\\n        queue<TreeNode* > q;\\n        q.push(root);\\n        bool flag=false;\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                root=q.front();\\n                q.pop();\\n                if(root==NULL){\\n                    flag=true;\\n                    continue;\\n                }\\n                if(flag)\\n                    return false;\\n                q.push(root->left);\\n                q.push(root->right);\\n            }\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(NULL == root)\\n            return true;\\n        queue<TreeNode* > q;\\n        q.push(root);\\n        bool flag=false;\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                root=q.front();\\n                q.pop();\\n                if(root==NULL){\\n                    flag=true;\\n                    continue;\\n                }\\n                if(flag)\\n                    return false;\\n                q.push(root->left);\\n                q.push(root->right);\\n            }\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915474,
                "title": "beats-100-c-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        \\n        if(!root)\\n            return true;\\n        \\n        int i = 0;\\n        vector<TreeNode*> bfs;\\n        bfs.push_back(root);\\n        \\n        // traversing level wise until a NUll occurs\\n        while(i<bfs.size() && bfs[i]){\\n            bfs.push_back(bfs[i]->left);\\n            bfs.push_back(bfs[i]->right);\\n            i++;\\n        }\\n        \\n        // clearing the cluster of NULLs if left\\n        while(i<bfs.size() && !bfs[i]){\\n            i++;\\n        }\\n    \\n        return i == bfs.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        \\n        if(!root)\\n            return true;\\n        \\n        int i = 0;\\n        vector<TreeNode*> bfs;\\n        bfs.push_back(root);\\n        \\n        // traversing level wise until a NUll occurs\\n        while(i<bfs.size() && bfs[i]){\\n            bfs.push_back(bfs[i]->left);\\n            bfs.push_back(bfs[i]->right);\\n            i++;\\n        }\\n        \\n        // clearing the cluster of NULLs if left\\n        while(i<bfs.size() && !bfs[i]){\\n            i++;\\n        }\\n    \\n        return i == bfs.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846490,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root) return false;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        bool end = false;\\n        while(!q.empty()){\\n           TreeNode* curr = q.front();\\n            q.pop();\\n            for(TreeNode* p:{curr->left,curr->right}){\\n                if(p and end) return false;\\n                if(p) q.push(p);\\n                else end = true;\\n            }  \\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {\\n        if(!root) return false;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        bool end = false;\\n        while(!q.empty()){\\n           TreeNode* curr = q.front();\\n            q.pop();\\n            for(TreeNode* p:{curr->left,curr->right}){\\n                if(p and end) return false;\\n                if(p) q.push(p);\\n                else end = true;\\n            }  \\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 756546,
                "title": "java-o-n-beats-100-level-order-traversal",
                "content": "```\\nclass Solution {\\n    int k=-1;\\n    boolean printLevelOrder(TreeNode root)  \\n    { \\n        Queue<TreeNode> queue = new LinkedList<TreeNode>(); \\n        queue.add(root); \\n        while (!queue.isEmpty())  \\n        { \\n            TreeNode tempNode = queue.poll(); \\n          //  System.out.print(tempNode.data + \" \"); \\n            if (tempNode.left != null) { \\n                if(k==-1)\\n                queue.add(tempNode.left);\\n                else{\\n                    return false;\\n                }\\n            } \\n            else{\\n                k=0;\\n            }\\n            if (tempNode.right != null) { \\n                if(k==-1)\\n                queue.add(tempNode.right);\\n                else\\n                    return false;\\n            } \\n            else\\n                k=0;\\n        }\\n        return true;\\n    } \\n    public boolean isCompleteTree(TreeNode root) {\\n        return printLevelOrder(root);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int k=-1;\\n    boolean printLevelOrder(TreeNode root)  \\n    { \\n        Queue<TreeNode> queue = new LinkedList<TreeNode>(); \\n        queue.add(root); \\n        while (!queue.isEmpty())  \\n        { \\n            TreeNode tempNode = queue.poll(); \\n          //  System.out.print(tempNode.data + \" \"); \\n            if (tempNode.left != null) { \\n                if(k==-1)\\n                queue.add(tempNode.left);\\n                else{\\n                    return false;\\n                }\\n            } \\n            else{\\n                k=0;\\n            }\\n            if (tempNode.right != null) { \\n                if(k==-1)\\n                queue.add(tempNode.right);\\n                else\\n                    return false;\\n            } \\n            else\\n                k=0;\\n        }\\n        return true;\\n    } \\n    public boolean isCompleteTree(TreeNode root) {\\n        return printLevelOrder(root);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740650,
                "title": "java-code-easy-understanable",
                "content": "We will do the BFS traversal of the tree.\\nAnd whenever we encounter a null node it has to be the last node in the tree.\\n```\\n\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root == null) return true;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        boolean gotNull = false;\\n        while(!q.isEmpty()){\\n            TreeNode temp = q.poll();\\n            if(temp == null && !gotNull){\\n                gotNull = true;\\n                continue;\\n            }\\n            if(gotNull && temp != null){\\n                return false;\\n            }\\n            if(temp == null) continue;\\n            q.add(temp.left);\\n            q.add(temp.right);\\n            \\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root == null) return true;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        boolean gotNull = false;\\n        while(!q.isEmpty()){\\n            TreeNode temp = q.poll();\\n            if(temp == null && !gotNull){\\n                gotNull = true;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 714056,
                "title": "javascript-o-n-faster-than-97",
                "content": "```\\nvar isCompleteTree = function(root) {\\n    if(!!root){\\n        const queue = [root];\\n        while(queue.length){\\n            let curr = queue.shift();\\n            if(curr===null){\\n                for(node of queue){\\n                    if(node!==null) return false;\\n                }\\n                break;\\n            }\\n            queue.push(curr.left);\\n            queue.push(curr.right);\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar isCompleteTree = function(root) {\\n    if(!!root){\\n        const queue = [root];\\n        while(queue.length){\\n            let curr = queue.shift();\\n            if(curr===null){\\n                for(node of queue){\\n                    if(node!==null) return false;\\n                }\\n                break;\\n            }\\n            queue.push(curr.left);\\n            queue.push(curr.right);\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 654045,
                "title": "simple-solution-in-python-with-explanation",
                "content": "First, let us consider the scenarios for any tree to be a complete tree.\\n* All levels must be filled up completely except for the last level.\\n* All the nodes in the last level should be as left as possible.\\n\\nBoth the scenarios can be put this way. If we do a BFS traversal, no valid node should appear after first NULL.\\n\\nLet\\'s prove this from the two examples given in the problem description.\\n\\n![image](https://assets.leetcode.com/users/satish_muddana/image_1590527114.png)\\n\\nIn the above tree, the first time NULL appears in a BFS traversal is after node 6. We don\\'t have any other valid nodes after 6. Hence this is a complete tree.\\n\\n![image](https://assets.leetcode.com/users/satish_muddana/image_1590527201.png)\\n\\nIn the above tree, the first time NULL apperas in a BFS traversal is after node 5. We have a valid node(node 7) after NULL. Hence this is not a complete tree.\\n\\nHere is the code for the same.\\n```\\nimport collections\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        queue_nodes = collections.deque()\\n        queue_nodes.append(root)\\n        while queue_nodes:\\n            curr_node = queue_nodes.popleft()\\n\\t\\t\\t#  break the traversal after the first null\\n            if not curr_node:\\n                break\\n            queue_nodes.append(curr_node.left)\\n            queue_nodes.append(curr_node.right)\\n            \\n        while queue_nodes:\\n            curr_node = queue_nodes.popleft()\\n\\t\\t\\t# check if there is a valid node.  Return False if node is valid\\n            if curr_node:\\n                return False\\n\\t\\t\\n        return True\\n```\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        queue_nodes = collections.deque()\\n        queue_nodes.append(root)\\n        while queue_nodes:\\n            curr_node = queue_nodes.popleft()\\n\\t\\t\\t#  break the traversal after the first null\\n            if not curr_node:\\n                break\\n            queue_nodes.append(curr_node.left)\\n            queue_nodes.append(curr_node.right)\\n            \\n        while queue_nodes:\\n            curr_node = queue_nodes.popleft()\\n\\t\\t\\t# check if there is a valid node.  Return False if node is valid\\n            if curr_node:\\n                return False\\n\\t\\t\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 576080,
                "title": "java-simple-dfs-solution-with-explanations",
                "content": "```\\npublic boolean isCompleteTree(TreeNode root) {\\n        Set<Integer> seenIndexes = new HashSet<>();\\n        dfs(root, 0, seenIndexes); // scan the tree and add all indexes (root index is )\\n        for (int i = 0; i < seenIndexes.size(); i++) { // scan indexes of all nodes\\n            if (!seenIndexes.contains(i)) return false; // if any index is missing\\n        }\\n        return true; // no index is missing\\n    }\\n    \\n    public void dfs(TreeNode root, int ind, Set<Integer> seenIndexes) {\\n        if (root == null) return;\\n        seenIndexes.add(ind); // store current index\\n        dfs(root.left, ind * 2 + 1, seenIndexes); // the index of the left node will be: ind * 2 + 1\\n        dfs(root.right, ind * 2 + 2, seenIndexes); // the index of the left node will be: ind * 2 + 2\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isCompleteTree(TreeNode root) {\\n        Set<Integer> seenIndexes = new HashSet<>();\\n        dfs(root, 0, seenIndexes); // scan the tree and add all indexes (root index is )\\n        for (int i = 0; i < seenIndexes.size(); i++) { // scan indexes of all nodes\\n            if (!seenIndexes.contains(i)) return false; // if any index is missing\\n        }\\n        return true; // no index is missing\\n    }\\n    \\n    public void dfs(TreeNode root, int ind, Set<Integer> seenIndexes) {\\n        if (root == null) return;\\n        seenIndexes.add(ind); // store current index\\n        dfs(root.left, ind * 2 + 1, seenIndexes); // the index of the left node will be: ind * 2 + 1\\n        dfs(root.right, ind * 2 + 2, seenIndexes); // the index of the left node will be: ind * 2 + 2\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 551901,
                "title": "python-collection-of-bfs-solutions",
                "content": "**BFS** with an observation: `No null node on the left and above`\\n\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n            \"\"\"\\n            1\\n          2   3\\n        4       5\\n    \\n            1\\n          2   3\\n        4  5    \\n      6\\n            \"\"\"\\n            Q = [root]\\n            isNoneAbove = False\\n            while Q:\\n                lvlNodes = []\\n                isNoneLeft = False\\n                \\n                for node in Q:\\n                    if not node:\\n                        isNoneLeft = True\\n                    elif isNoneAbove or isNoneLeft:\\n                        return False\\n                    else:\\n    \\t\\t\\t\\t\\t# we don\\'t check children are null\\n                        lvlNodes += [node.left, node.right]\\n                \\n                isNoneAbove = isNoneLeft\\n                Q = lvlNodes\\n            return True\\n\\nUse **BFS** to do a level order traversal, add children to the bfs queue, until we met the first empty node. For a complete binary tree, there should not be any node after we met an empty one.\\n\\n    from collections import deque\\n    \\n    class Solution:\\n        def isCompleteTree(self, root: TreeNode) -> bool:\\n            deq = deque([root])\\n            while deq:\\n                node = deq.popleft()\\n                if not node:\\n                    break\\n                deq.append(node.left)\\n                deq.append(node.right)\\n            # there should not be any node after we met an empty one\\n            return not any(deq)\\n\\n**BFS** with an observation: `if each node is marked with a number, starting from 1 as the root node, then len(queue) == largest number at the end`\\n\\nMore details [here](https://leetcode.com/problems/check-completeness-of-a-binary-tree/solution/)\\n\\n    \"\"\"\\n    \\t   \\t   1\\n    \\t    2     3\\n    \\tnull  5\\n            10 11\\n    \"\"\"\\n        def isCompleteTree(self, root):\\n            nodes = [(root, 1)]\\n            i = 0\\n            while i < len(nodes):\\n                node, v = nodes[i]\\n                i += 1\\n                if node:\\n                    nodes.append((node.left, 2*v))\\n                    nodes.append((node.right, 2*v+1))\\n    \\n            return  nodes[-1][1] == len(nodes)",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "**BFS** with an observation: `No null node on the left and above`\\n\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n            \"\"\"\\n            1\\n          2   3\\n        4       5\\n    \\n            1\\n          2   3\\n        4  5    \\n      6\\n            \"\"\"\\n            Q = [root]\\n            isNoneAbove = False\\n            while Q:\\n                lvlNodes = []\\n                isNoneLeft = False\\n                \\n                for node in Q:\\n                    if not node:\\n                        isNoneLeft = True\\n                    elif isNoneAbove or isNoneLeft:\\n                        return False\\n                    else:\\n    \\t\\t\\t\\t\\t# we don\\'t check children are null\\n                        lvlNodes += [node.left, node.right]\\n                \\n                isNoneAbove = isNoneLeft\\n                Q = lvlNodes\\n            return True\\n\\nUse **BFS** to do a level order traversal, add children to the bfs queue, until we met the first empty node. For a complete binary tree, there should not be any node after we met an empty one.\\n\\n    from collections import deque\\n    \\n    class Solution:\\n        def isCompleteTree(self, root: TreeNode) -> bool:\\n            deq = deque([root])\\n            while deq:\\n                node = deq.popleft()\\n                if not node:\\n                    break\\n                deq.append(node.left)\\n                deq.append(node.right)\\n            # there should not be any node after we met an empty one\\n            return not any(deq)\\n\\n**BFS** with an observation: `if each node is marked with a number, starting from 1 as the root node, then len(queue) == largest number at the end`\\n\\nMore details [here](https://leetcode.com/problems/check-completeness-of-a-binary-tree/solution/)\\n\\n    \"\"\"\\n    \\t   \\t   1\\n    \\t    2     3\\n    \\tnull  5\\n            10 11\\n    \"\"\"\\n        def isCompleteTree(self, root):\\n            nodes = [(root, 1)]\\n            i = 0\\n            while i < len(nodes):\\n                node, v = nodes[i]\\n                i += 1\\n                if node:\\n                    nodes.append((node.left, 2*v))\\n                    nodes.append((node.right, 2*v+1))\\n    \\n            return  nodes[-1][1] == len(nodes)",
                "codeTag": "Java"
            },
            {
                "id": 536677,
                "title": "go-golang-bfs-0ms-solution",
                "content": "```\\nfunc isCompleteTree(root *TreeNode) bool {\\n    if root == nil {\\n        return true\\n    }\\n    curr := []*TreeNode{root}\\n    next := []*TreeNode{}\\n    empty := false\\n    for len(curr) != 0 {\\n        for _, c := range curr {\\n            if c.Left == nil && c.Right != nil {\\n                return false\\n            }\\n            if c.Left != nil {\\n                if empty {\\n                    return false\\n                }\\n                next = append(next, c.Left)\\n            }\\n            if c.Right != nil {\\n                next = append(next, c.Right)\\n            } else {\\n                empty = true\\n            }\\n        } \\n        curr = next\\n        next = []*TreeNode{}\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isCompleteTree(root *TreeNode) bool {\\n    if root == nil {\\n        return true\\n    }\\n    curr := []*TreeNode{root}\\n    next := []*TreeNode{}\\n    empty := false\\n    for len(curr) != 0 {\\n        for _, c := range curr {\\n            if c.Left == nil && c.Right != nil {\\n                return false\\n            }\\n            if c.Left != nil {\\n                if empty {\\n                    return false\\n                }\\n                next = append(next, c.Left)\\n            }\\n            if c.Right != nil {\\n                next = append(next, c.Right)\\n            } else {\\n                empty = true\\n            }\\n        } \\n        curr = next\\n        next = []*TreeNode{}\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 519073,
                "title": "c-simple-solution",
                "content": "Pretty self-explanatory C++ solution:\\n\\n```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {        \\n        std::queue<TreeNode *> Q;\\n        if (root != nullptr) Q.push(root);\\n        \\n        bool lastLevel = false;\\n        while (!Q.empty()) {\\n            int s = Q.size();\\n            for (int i = 0; i < s; ++i) {\\n                TreeNode *u = Q.front(); Q.pop();\\n                \\n                if (u->left != nullptr) {\\n                    if (lastLevel) return false;\\n                    Q.push(u->left);\\n                }\\n                else lastLevel = true;\\n                \\n                if (u->right != nullptr) {\\n                    if (lastLevel) return false;\\n                    Q.push(u->right);\\n                }\\n                else lastLevel = true;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCompleteTree(TreeNode* root) {        \\n        std::queue<TreeNode *> Q;\\n        if (root != nullptr) Q.push(root);\\n        \\n        bool lastLevel = false;\\n        while (!Q.empty()) {\\n            int s = Q.size();\\n            for (int i = 0; i < s; ++i) {\\n                TreeNode *u = Q.front(); Q.pop();\\n                \\n                if (u->left != nullptr) {\\n                    if (lastLevel) return false;\\n                    Q.push(u->left);\\n                }\\n                else lastLevel = true;\\n                \\n                if (u->right != nullptr) {\\n                    if (lastLevel) return false;\\n                    Q.push(u->right);\\n                }\\n                else lastLevel = true;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 438157,
                "title": "python-divide-and-conquer-solution",
                "content": "The helper function returns two number: MIN and MAX height of the subtree starting from current node.\\nIn each recursion, we got Min and Max from both left and right:\\nThere are only four valid situations:(five are listed, but one and five are actually the same)\\n![image](https://assets.leetcode.com/users/lechen999/image_1574787802.png)\\nIf the MINs and MAXs are within one of the valid situation, path the new MIN and new MAX.\\nOtherwise, pass the -inf and inf\\nIn other words, the return of height is conditional, only return the actual MIN and MAX height when this subtree starting from current node is complete.\\nEither one of the child\\'s MIN MAX is -inf and inf, this node\\'s MIN MAX will also be -inf and inf.\\n\\nHere is the code:\\n```\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        height_min, height_max = self.helper(root)\\n        return height_max - height_min <= 1 # Only when height different less than one, this tree is complete\\n    \\n    def helper(self, root):\\n        if not root:\\n            return 0, 0 # when reach the bottom, MIN MAX height are both zero\\n        left_min, left_max = self.helper(root.left)\\n        right_min, right_max = self.helper(root.right)\\n        if left_max >= left_min >= right_max >= right_min and left_max <= right_min + 1:  # to be clear, the logic here is redundent\\n\\t\\t# if left_min >= right_max and left_max <= right_min + 1: # this is the concise version\\n            return right_min + 1, left_max + 1  \\n        return float(\"-inf\"), float(\"inf\")\\n```",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        height_min, height_max = self.helper(root)\\n        return height_max - height_min <= 1 # Only when height different less than one, this tree is complete\\n    \\n    def helper(self, root):\\n        if not root:\\n            return 0, 0 # when reach the bottom, MIN MAX height are both zero\\n        left_min, left_max = self.helper(root.left)\\n        right_min, right_max = self.helper(root.right)\\n        if left_max >= left_min >= right_max >= right_min and left_max <= right_min + 1:  # to be clear, the logic here is redundent\\n\\t\\t# if left_min >= right_max and left_max <= right_min + 1: # this is the concise version\\n            return right_min + 1, left_max + 1  \\n        return float(\"-inf\"), float(\"inf\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427990,
                "title": "java-easy-recursion-with-two-100-solution",
                "content": "\\n    private int count = 0;\\n    private int max = 0;\\n    public boolean isCompleteTree(TreeNode root) {\\n        if (root == null){\\n            return true;\\n        }\\n        dfs(root, 1);\\n        return max == count;\\n    }\\n    \\n    private void dfs(TreeNode root, int next){\\n        if (root == null) return;\\n        count++;\\n        max = Math.max(max, next);\\n        dfs(root.left, 2 * next);\\n        dfs(root.right, 2 * next + 1);\\n    }\\n\\xB7\\xB7\\xB7",
                "solutionTags": [],
                "code": "\\n    private int count = 0;\\n    private int max = 0;\\n    public boolean isCompleteTree(TreeNode root) {\\n        if (root == null){\\n            return true;\\n        }\\n        dfs(root, 1);\\n        return max == count;\\n    }\\n    \\n    private void dfs(TreeNode root, int next){\\n        if (root == null) return;\\n        count++;\\n        max = Math.max(max, next);\\n        dfs(root.left, 2 * next);\\n        dfs(root.right, 2 * next + 1);\\n    }\\n\\xB7\\xB7\\xB7",
                "codeTag": "Unknown"
            },
            {
                "id": 409836,
                "title": "simple-java-solution-bfs",
                "content": "```\\npublic boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.add(root);\\n        boolean inComplete = false; \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode curr = queue.poll();\\n                if(curr.left == null && curr.right != null) return false;\\n                if(inComplete && (curr.left !=null || curr.right != null)) return false;\\n                if(curr.left != null) queue.add(curr.left);\\n                if(curr.right != null) queue.add(curr.right);\\n                if (curr.right == null) inComplete = true;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.add(root);\\n        boolean inComplete = false; \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode curr = queue.poll();\\n                if(curr.left == null && curr.right != null) return false;\\n                if(inComplete && (curr.left !=null || curr.right != null)) return false;\\n                if(curr.left != null) queue.add(curr.left);\\n                if(curr.right != null) queue.add(curr.right);\\n                if (curr.right == null) inComplete = true;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 364908,
                "title": "go-concise-solution",
                "content": "```\\n\\nfunc isCompleteTree(root *TreeNode) bool {\\n\\tq := []*TreeNode{root}\\n\\tfor len(q) != 0 && q[0] != nil {\\n\\t\\tnode := q[0]\\n\\t\\tq = append(q, node.Left, node.Right)\\n\\t\\tq = q[1:]\\n\\t}\\n\\n\\tfor i := 0; i < len(q); i++ {\\n\\t\\tif q[i] != nil {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nfunc isCompleteTree(root *TreeNode) bool {\\n\\tq := []*TreeNode{root}\\n\\tfor len(q) != 0 && q[0] != nil {\\n\\t\\tnode := q[0]\\n\\t\\tq = append(q, node.Left, node.Right)\\n\\t\\tq = q[1:]\\n\\t}\\n\\n\\tfor i := 0; i < len(q); i++ {\\n\\t\\tif q[i] != nil {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 363230,
                "title": "c-solution-using-bfs-faster-than-90",
                "content": "ALGO-->> As soon as we receive first null in tree, we will check for all the values that are remaining in stack, If any of these values are not NULL, it will retrun false. Traversal is done by Breadth first search(BFS).\\n\\n```\\nbool isCompleteTree(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return true;\\n        TreeNode *p,*r;\\n        std::queue<TreeNode *> q{};                   // Queue is created\\n        q.push(root);\\n        int count=0;\\n        while(!q.empty())                             // while q is empty it will run\\n        { \\n            int z=q.size();\\n            for(int i=0;i<z;i++)\\n            {\\n            p=q.front();\\n            q.pop();\\n                if(p==NULL)                           // as soon as first null is recived all the next \\n                {                                     // elements must be null in order to be a complete\\n                                                      // binary tree\\n                    count++;\\n                    while(!q.empty())\\n                    {\\n                        r=q.front();\\n                        q.pop();\\n                        if(r!=NULL)\\n                            return false;\\n                    }\\n                  break;  \\n                }\\n                  \\n                  \\n              q.push(p->left);\\n              q.push(p->right);\\n            }\\n        }\\n   \\n        return true;                                  // If all nodes after first null are null, it returns true;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nbool isCompleteTree(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return true;\\n        TreeNode *p,*r;\\n        std::queue<TreeNode *> q{};                   // Queue is created\\n        q.push(root);\\n        int count=0;\\n        while(!q.empty())                             // while q is empty it will run\\n        { \\n            int z=q.size();\\n            for(int i=0;i<z;i++)\\n            {\\n            p=q.front();\\n            q.pop();\\n                if(p==NULL)                           // as soon as first null is recived all the next \\n                {                                     // elements must be null in order to be a complete\\n                                                      // binary tree\\n                    count++;\\n                    while(!q.empty())\\n                    {\\n                        r=q.front();\\n                        q.pop();\\n                        if(r!=NULL)\\n                            return false;\\n                    }\\n                  break;  \\n                }\\n                  \\n                  \\n              q.push(p->left);\\n              q.push(p->right);\\n            }\\n        }\\n   \\n        return true;                                  // If all nodes after first null are null, it returns true;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 330731,
                "title": "python-bfs-level-order-traversal",
                "content": "```\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n        curr_level = [root]\\n        not_filled = 0\\n        while curr_level:\\n            next_level, l = [], 0\\n            for i, node in enumerate(curr_level):\\n                if node.left:\\n                    if l != 2 * i:\\n                        return False\\n                    l += 1\\n                    next_level.append(node.left)\\n                if node.right:\\n                    if l != 2 * i + 1:\\n                        return False\\n                    l += 1\\n                    next_level.append(node.right)\\n            if l > 0 and l < 2 * len(curr_level):\\n                not_filled += 1\\n                if not_filled >= 2:\\n                    return False\\n            curr_level = next_level\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\n    def isCompleteTree(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n        curr_level = [root]\\n        not_filled = 0\\n        while curr_level:\\n            next_level, l = [], 0\\n            for i, node in enumerate(curr_level):\\n                if node.left:\\n                    if l != 2 * i:\\n                        return False\\n                    l += 1\\n                    next_level.append(node.left)\\n                if node.right:\\n                    if l != 2 * i + 1:\\n                        return False\\n                    l += 1\\n                    next_level.append(node.right)\\n            if l > 0 and l < 2 * len(curr_level):\\n                not_filled += 1\\n                if not_filled >= 2:\\n                    return False\\n            curr_level = next_level\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 328435,
                "title": "java-0ms-o-logn-time-solution-beat-100-with-detailed-explaination",
                "content": "```java\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if (root == null) return false;\\n        return isComplete(root)[0] > 0 ? true : false;\\n    }\\n    \\n\\t// return a array of length 2\\n\\t// first number : height of the tree, -1 means not complete\\n\\t// second number : 1 for perfect(defined below) tree, 0 for not perfect\\n    private int[] isComplete(TreeNode root) {\\n        int[] left = new int[]{0, 1};\\n        int[] right = new int[]{0, 1};\\n        if (root.left != null) {\\n            left = isComplete(root.left);\\n        }\\n        if (root.right != null) {\\n            right = isComplete(root.right);\\n        }\\n        if (left[0] == -1 || right[0] == -1) return new int[]{-1, 0};\\n        if (left[0] == right[0]) {\\n            if (left[1] == 1 && right[1] == 1) return new int[]{left[0] + 1, 1};\\n            return new int[]{left[1] == 0 ? -1 : (left[0] + 1), 0};\\n        } else if (left[0] == right[0] + 1) {\\n            return new int[]{right[1] == 1 ? (left[0] + 1) : -1, 0};\\n        } else {\\n            return new int[]{-1, 0};\\n        }\\n    }\\n}\\n```\\nExplaination:\\n**perfect : (self defined)a binary tree is perfect when it\\'s Complete and Symmetrical:**\\nwhen a tree is complete, there are some conditons:\\n- left subtree and right subtree of the root are complete (must)\\n- left subtree height == right subtree height OR left subtree height == right subtree height + 1\\n\\t1. when left subtree height == right subtree height:\\n\\t\\ta. left and right are both **perfect** -> target tree perfect\\n\\t\\tb. left perfect\\n\\t2. when left subtree height == right subtree height + 1:\\n\\t   a. right perfect",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        if (root == null) return false;\\n        return isComplete(root)[0] > 0 ? true : false;\\n    }\\n    \\n\\t// return a array of length 2\\n\\t// first number : height of the tree, -1 means not complete\\n\\t// second number : 1 for perfect(defined below) tree, 0 for not perfect\\n    private int[] isComplete(TreeNode root) {\\n        int[] left = new int[]{0, 1};\\n        int[] right = new int[]{0, 1};\\n        if (root.left != null) {\\n            left = isComplete(root.left);\\n        }\\n        if (root.right != null) {\\n            right = isComplete(root.right);\\n        }\\n        if (left[0] == -1 || right[0] == -1) return new int[]{-1, 0};\\n        if (left[0] == right[0]) {\\n            if (left[1] == 1 && right[1] == 1) return new int[]{left[0] + 1, 1};\\n            return new int[]{left[1] == 0 ? -1 : (left[0] + 1), 0};\\n        } else if (left[0] == right[0] + 1) {\\n            return new int[]{right[1] == 1 ? (left[0] + 1) : -1, 0};\\n        } else {\\n            return new int[]{-1, 0};\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312181,
                "title": "easy-understand-python-bfs",
                "content": "```\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        bfs = [root]\\n\\n        while bfs:\\n            node = bfs.pop(0)\\n\\n            if node is None:\\n                return all([node is None for node in bfs])\\n\\n            else:\\n                bfs.append(node.left)\\n                bfs.append(node.right)\\n\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isCompleteTree(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        bfs = [root]\\n\\n        while bfs:\\n            node = bfs.pop(0)\\n\\n            if node is None:\\n                return all([node is None for node in bfs])\\n\\n            else:\\n                bfs.append(node.left)\\n                bfs.append(node.right)\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309914,
                "title": "java-bfs-queue-solution",
                "content": "We traverse the tree using BFS, keeping track of whether we have encountered a null value. If we have, then we expect all the following values to be null as well.\\n```\\npublic boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        boolean hasEncounteredNullValue = false;\\n        while (!queue.isEmpty()){\\n            TreeNode current = queue.remove();\\n            if (current == null){\\n                hasEncounteredNullValue = true;\\n            }\\n            else if (hasEncounteredNullValue){\\n                return false;\\n            }\\n            else{\\n                queue.add(current.left);\\n                queue.add(current.right);\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isCompleteTree(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        boolean hasEncounteredNullValue = false;\\n        while (!queue.isEmpty()){\\n            TreeNode current = queue.remove();\\n            if (current == null){\\n                hasEncounteredNullValue = true;\\n            }\\n            else if (hasEncounteredNullValue){\\n                return false;\\n            }\\n            else{\\n                queue.add(current.left);\\n                queue.add(current.right);\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 221096,
                "title": "python-with-bfs",
                "content": "I used O(n) space complexity way.\\nFirst, represent the tree as a number list.\\nIf node\\'s value is null, mark as very big number.\\nLastly, just check whether index list increase or not.\\n\\n```\\nclass Solution:\\n    def isCompleteTree(self, root):\\n        from collections import deque\\n        q = deque([root])\\n        nums = []\\n        while q:\\n            node = q.popleft()\\n            if not node:\\n                nums.append(float(\\'inf\\'))\\n                continue\\n            nums.append(node.val)\\n            q.append(node.left)\\n            q.append(node.right)\\n\\n        for i in range(len(nums)-1):\\n            if nums[i] > nums[i+1]:\\n                return False\\n        return True",
                "solutionTags": [],
                "code": "I used O(n) space complexity way.\\nFirst, represent the tree as a number list.\\nIf node\\'s value is null, mark as very big number.\\nLastly, just check whether index list increase or not.\\n\\n```\\nclass Solution:\\n    def isCompleteTree(self, root):\\n        from collections import deque\\n        q = deque([root])\\n        nums = []\\n        while q:\\n            node = q.popleft()\\n            if not node:\\n                nums.append(float(\\'inf\\'))\\n                continue\\n            nums.append(node.val)\\n            q.append(node.left)\\n            q.append(node.right)\\n\\n        for i in range(len(nums)-1):\\n            if nums[i] > nums[i+1]:\\n                return False\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 207371,
                "title": "beat-99-92-java-solution-recursive-way",
                "content": "```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    class Pair{\\n        boolean full;\\n        int height;\\n        Pair(int a, boolean b) {\\n            full = b; height = a;\\n        }\\n    }\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root == null) return true;\\n        Pair x = helper(root);\\n        if(x.height == -1) return false;\\n        return true;\\n    }\\n    public Pair helper(TreeNode root) {\\n        if(root == null) return new Pair(0, true);\\n        Pair a = helper(root.right);\\n        Pair b = helper(root.left);\\n        if(a.height < 0 || b.height < 0) return new Pair(-1, false);\\n        if(a.height > b.height || (a.height==b.height && !b.full) || b.height > a.height+1) return new Pair(-1, false);\\n        if(!a.full && b.height > a.height) return new Pair(-1, false);\\n        return new Pair(Math.max(a.height, b.height)+1, b.height > a.height ? false:a.full&&b.full);\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    class Pair{\\n        boolean full;\\n        int height;\\n        Pair(int a, boolean b) {\\n            full = b; height = a;\\n        }\\n    }\\n    public boolean isCompleteTree(TreeNode root) {\\n        if(root == null) return true;\\n        Pair x = helper(root);\\n        if(x.height == -1) return false;\\n        return true;\\n    }\\n    public Pair helper(TreeNode root) {\\n        if(root == null) return new Pair(0, true);\\n        Pair a = helper(root.right);\\n        Pair b = helper(root.left);\\n        if(a.height < 0 || b.height < 0) return new Pair(-1, false);\\n        if(a.height > b.height || (a.height==b.height && !b.full) || b.height > a.height+1) return new Pair(-1, false);\\n        if(!a.full && b.height > a.height) return new Pair(-1, false);\\n        return new Pair(Math.max(a.height, b.height)+1, b.height > a.height ? false:a.full&&b.full);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058788,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean flag = false;\\n\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()) {\\n            TreeNode a = q.remove();\\n            if(a==null) {\\n                flag = true;\\n            }else{\\n                if(flag) return false;\\n                q.add(a.left);\\n                q.add(a.right);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean flag = false;\\n\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()) {\\n            TreeNode a = q.remove();\\n            if(a==null) {\\n                flag = true;\\n            }else{\\n                if(flag) return false;\\n                q.add(a.left);\\n                q.add(a.right);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1832760,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832633,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832886,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832767,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832625,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832911,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832903,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832843,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832669,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1808090,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832760,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832633,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832886,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832767,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832625,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832911,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832903,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832843,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1832669,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 1808090,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "If you ever encounter a NULL node, you must not encounter a non NULL node after that in a Level Order Traversal, this is the definition of a complete Binary Tree."
                    },
                    {
                        "username": "srapol",
                        "content": "what?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you. Solved it with your hint "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@Michael_Teng6](/Michael_Teng6) :)"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Very helpful! Thanks"
                    },
                    {
                        "username": "meow_power",
                        "content": "Hi guys, I again could not solve a question\\n"
                    },
                    {
                        "username": "bhavyashu",
                        "content": "No worries, more than solving understanding is important If you know the construction of a complete binary tree and then try to solve it you\\'ll find it easier to solve just figuring out, how would I check the conditions to evaluate a tree is a complete BT or not and how would i put the conditions for a program to do the same. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "me almost every day :\\')"
                    },
                    {
                        "username": "TajPotato",
                        "content": "same here..."
                    },
                    {
                        "username": "TajPotato",
                        "content": "I would think a good approach to solve this problem is to use Breadth First Search.\n1. Remember that a complete binary tree is filled from left to right\n2. No nodes should come after a null node is visited\n\nAll the best!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "bfs all the way"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- To solve this problem, we can use a level-order traversal approach using a queue. We start with the root node and add it to the queue. Then, while the queue is not empty, we iteratively dequeue each node and perform the following steps:\\n\\n1. If the current node has a right child but no left child, the tree is not complete, and we can immediately return false.\\n2. If the current node has a left child, we add it to the queue. If there was any node in the previous level that didn\\'t have a left child, we can mark the current level as incomplete by setting a flag.\\n3. If the current node has a right child, we add it to the queue. If there was any node in the previous level that didn\\'t have a right child, we can mark the current level as incomplete by setting a flag.\\n4. After processing all nodes at the current level, we check the flag. If the flag is false, it means that there was a node in the previous level that didn\\'t have a left or right child, so the tree is not complete, and we can return false.\\n5. If we have processed all nodes in the queue and haven\\'t returned false, it means that the tree is complete, so we can return true.\\n\\n- We should also handle the case where the root node is null or the tree has only one node separately.\\n\\n- The time complexity of this approach is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(n), since in the worst case, the queue can contain all nodes in the last level of the tree."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the solution link for reference:-\\nhttps://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3298544/easiest-solution/"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**Seems like power has returned !!**\\n**Thank You Leetcode**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-2.png)\\n![](https://leetcode.com/problems/check-completeness-of-a-binary-tree/Figures/958/958-3.png)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Those who have used DFS would be getting WA for this testcase.\\n[1,2,3,null,null,7,8]"
                    },
                    {
                        "username": "me-oniichan",
                        "content": "Not really, I have used DFS. You have to keep track of previous leaf, and *number of unique leaves*. If *number of unique leaves* exceeds *3* or difference with previous leaf is not 1 or 0 then it is false."
                    },
                    {
                        "username": "prakashtarun313",
                        "content": "finally trees got its day\\n"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1 "
                    },
                    {
                        "username": "vikash1509",
                        "content": "using level order traversal \\nintially take boolean value false\\nif left is null change boolean into true \\nand if any not null exits in queue return false"
                    },
                    {
                        "username": "srapol",
                        "content": "will fail on this case [1,2,3,5,null,7,8]"
                    }
                ]
            },
            {
                "id": 2025969,
                "content": [
                    {
                        "username": "ShashidharAngadi",
                        "content": "It was my 100th medium question and that too solved it on one goo\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Why defining the found bool at every level giving wrong and while defining it at the top for only one time is giving right ans??\\n\\nbool isCompleteTree(TreeNode* root) {\\n        \\n        if (root == NULL)\\n            return true;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n\\n        bool found = false;\\n        while (!(q.empty()))\\n        {\\n            int n = q.size();\\n            // IF WE ARE DEFINING IT HERE THEN IT IS GIVING WRONG ANS, WHY?\\n            //bool found = false;\\n            while (n--)\\n            {\\n                TreeNode *node = q.front();\\n                q.pop();\\n                if (node == NULL)\\n                {\\n                    found = true;\\n                }\\n                else{\\n                    if(found)return false;\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n\\n    }"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "Spoiler alert!\\n\\nAnybody knows what to add to this code to work? I reached case 106 and I can\\'t get past it ([1, 2, 3, 4, 5, 6]);\\n\\nvar isCompleteTree = function(root) {\\n\\n    const scanTree = (root) => {\\n        if (!root.left && !root.right) return true;\\n        if (!root.left || !root.right) return false;\\n\\n        return (scanTree(root.left) && scanTree(root.right));\\n    }\\n\\n    return scanTree(root);\\n};"
                    },
                    {
                        "username": "cube_89",
                        "content": "This is a Tree Week \\uD83C\\uDF34\\uD83C\\uDF32"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "in level order traversal if you are getting a non NULL node after a NULL node then \nit is not a complete binary tree\n"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Learned one valuable lesson today, never insert a null value as a placeholder in a queue. Punished me for this :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "neerajbhattof98",
                        "content": "GFG is better than Leetcode"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how ??"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "  ```  \\nclass Solution {\\n    public int height(TreeNode root){  // maxax height of a binary\\n        if(root==null){\\n            return 0;\\n        }\\n        return Math.max(height(root.left),height(root.right))+1;\\n    }\\n    public boolean isCompleteTree(TreeNode root) {\\n        //total no of nodes = 2^h-1; \\n        //bfs\\n         if(root==null){\\n            return true;\\n        }\\n        int Height = height(root);\\n        int depth = 1;\\n        Queue<TreeNode> q  =new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int n= q.size();\\n            for(int i =0;i<n;i++){\\n                TreeNode node = q.poll();\\n                if(depth<Height-1 && (node.left==null || node.right==null)) return false;\\n                else if(depth==Height-1){\\n                    if(node.left==null && node.right!=null) return false;\\n                }\\n                if(node.left!=null) q.offer(node.left);\\n                if(node.right!=null) q.offer(node.right);\\n            }\\n            depth++;\\n\\n        }\\n        return true;\\n    }\\n}\\n```\\nMy code fails on this tastecase\\n[1,2,3,5,null,7,8]\\nI know why its failing but can someone tell how to handle this taste case??\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "easy HINT: just remember how heap sort works, how a Complete Binary tree can be represented as a continuous array without any break. That\\'s All!!"
                    }
                ]
            },
            {
                "id": 1899884,
                "content": [
                    {
                        "username": "ShashidharAngadi",
                        "content": "It was my 100th medium question and that too solved it on one goo\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Why defining the found bool at every level giving wrong and while defining it at the top for only one time is giving right ans??\\n\\nbool isCompleteTree(TreeNode* root) {\\n        \\n        if (root == NULL)\\n            return true;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n\\n        bool found = false;\\n        while (!(q.empty()))\\n        {\\n            int n = q.size();\\n            // IF WE ARE DEFINING IT HERE THEN IT IS GIVING WRONG ANS, WHY?\\n            //bool found = false;\\n            while (n--)\\n            {\\n                TreeNode *node = q.front();\\n                q.pop();\\n                if (node == NULL)\\n                {\\n                    found = true;\\n                }\\n                else{\\n                    if(found)return false;\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n\\n    }"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "Spoiler alert!\\n\\nAnybody knows what to add to this code to work? I reached case 106 and I can\\'t get past it ([1, 2, 3, 4, 5, 6]);\\n\\nvar isCompleteTree = function(root) {\\n\\n    const scanTree = (root) => {\\n        if (!root.left && !root.right) return true;\\n        if (!root.left || !root.right) return false;\\n\\n        return (scanTree(root.left) && scanTree(root.right));\\n    }\\n\\n    return scanTree(root);\\n};"
                    },
                    {
                        "username": "cube_89",
                        "content": "This is a Tree Week \\uD83C\\uDF34\\uD83C\\uDF32"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "in level order traversal if you are getting a non NULL node after a NULL node then \nit is not a complete binary tree\n"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Learned one valuable lesson today, never insert a null value as a placeholder in a queue. Punished me for this :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "neerajbhattof98",
                        "content": "GFG is better than Leetcode"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how ??"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "  ```  \\nclass Solution {\\n    public int height(TreeNode root){  // maxax height of a binary\\n        if(root==null){\\n            return 0;\\n        }\\n        return Math.max(height(root.left),height(root.right))+1;\\n    }\\n    public boolean isCompleteTree(TreeNode root) {\\n        //total no of nodes = 2^h-1; \\n        //bfs\\n         if(root==null){\\n            return true;\\n        }\\n        int Height = height(root);\\n        int depth = 1;\\n        Queue<TreeNode> q  =new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int n= q.size();\\n            for(int i =0;i<n;i++){\\n                TreeNode node = q.poll();\\n                if(depth<Height-1 && (node.left==null || node.right==null)) return false;\\n                else if(depth==Height-1){\\n                    if(node.left==null && node.right!=null) return false;\\n                }\\n                if(node.left!=null) q.offer(node.left);\\n                if(node.right!=null) q.offer(node.right);\\n            }\\n            depth++;\\n\\n        }\\n        return true;\\n    }\\n}\\n```\\nMy code fails on this tastecase\\n[1,2,3,5,null,7,8]\\nI know why its failing but can someone tell how to handle this taste case??\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "easy HINT: just remember how heap sort works, how a Complete Binary tree can be represented as a continuous array without any break. That\\'s All!!"
                    }
                ]
            },
            {
                "id": 1833625,
                "content": [
                    {
                        "username": "ShashidharAngadi",
                        "content": "It was my 100th medium question and that too solved it on one goo\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Why defining the found bool at every level giving wrong and while defining it at the top for only one time is giving right ans??\\n\\nbool isCompleteTree(TreeNode* root) {\\n        \\n        if (root == NULL)\\n            return true;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n\\n        bool found = false;\\n        while (!(q.empty()))\\n        {\\n            int n = q.size();\\n            // IF WE ARE DEFINING IT HERE THEN IT IS GIVING WRONG ANS, WHY?\\n            //bool found = false;\\n            while (n--)\\n            {\\n                TreeNode *node = q.front();\\n                q.pop();\\n                if (node == NULL)\\n                {\\n                    found = true;\\n                }\\n                else{\\n                    if(found)return false;\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n\\n    }"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "Spoiler alert!\\n\\nAnybody knows what to add to this code to work? I reached case 106 and I can\\'t get past it ([1, 2, 3, 4, 5, 6]);\\n\\nvar isCompleteTree = function(root) {\\n\\n    const scanTree = (root) => {\\n        if (!root.left && !root.right) return true;\\n        if (!root.left || !root.right) return false;\\n\\n        return (scanTree(root.left) && scanTree(root.right));\\n    }\\n\\n    return scanTree(root);\\n};"
                    },
                    {
                        "username": "cube_89",
                        "content": "This is a Tree Week \\uD83C\\uDF34\\uD83C\\uDF32"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "in level order traversal if you are getting a non NULL node after a NULL node then \nit is not a complete binary tree\n"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Learned one valuable lesson today, never insert a null value as a placeholder in a queue. Punished me for this :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "neerajbhattof98",
                        "content": "GFG is better than Leetcode"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how ??"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "  ```  \\nclass Solution {\\n    public int height(TreeNode root){  // maxax height of a binary\\n        if(root==null){\\n            return 0;\\n        }\\n        return Math.max(height(root.left),height(root.right))+1;\\n    }\\n    public boolean isCompleteTree(TreeNode root) {\\n        //total no of nodes = 2^h-1; \\n        //bfs\\n         if(root==null){\\n            return true;\\n        }\\n        int Height = height(root);\\n        int depth = 1;\\n        Queue<TreeNode> q  =new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int n= q.size();\\n            for(int i =0;i<n;i++){\\n                TreeNode node = q.poll();\\n                if(depth<Height-1 && (node.left==null || node.right==null)) return false;\\n                else if(depth==Height-1){\\n                    if(node.left==null && node.right!=null) return false;\\n                }\\n                if(node.left!=null) q.offer(node.left);\\n                if(node.right!=null) q.offer(node.right);\\n            }\\n            depth++;\\n\\n        }\\n        return true;\\n    }\\n}\\n```\\nMy code fails on this tastecase\\n[1,2,3,5,null,7,8]\\nI know why its failing but can someone tell how to handle this taste case??\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "easy HINT: just remember how heap sort works, how a Complete Binary tree can be represented as a continuous array without any break. That\\'s All!!"
                    }
                ]
            },
            {
                "id": 1833463,
                "content": [
                    {
                        "username": "ShashidharAngadi",
                        "content": "It was my 100th medium question and that too solved it on one goo\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Why defining the found bool at every level giving wrong and while defining it at the top for only one time is giving right ans??\\n\\nbool isCompleteTree(TreeNode* root) {\\n        \\n        if (root == NULL)\\n            return true;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n\\n        bool found = false;\\n        while (!(q.empty()))\\n        {\\n            int n = q.size();\\n            // IF WE ARE DEFINING IT HERE THEN IT IS GIVING WRONG ANS, WHY?\\n            //bool found = false;\\n            while (n--)\\n            {\\n                TreeNode *node = q.front();\\n                q.pop();\\n                if (node == NULL)\\n                {\\n                    found = true;\\n                }\\n                else{\\n                    if(found)return false;\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n\\n    }"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "Spoiler alert!\\n\\nAnybody knows what to add to this code to work? I reached case 106 and I can\\'t get past it ([1, 2, 3, 4, 5, 6]);\\n\\nvar isCompleteTree = function(root) {\\n\\n    const scanTree = (root) => {\\n        if (!root.left && !root.right) return true;\\n        if (!root.left || !root.right) return false;\\n\\n        return (scanTree(root.left) && scanTree(root.right));\\n    }\\n\\n    return scanTree(root);\\n};"
                    },
                    {
                        "username": "cube_89",
                        "content": "This is a Tree Week \\uD83C\\uDF34\\uD83C\\uDF32"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "in level order traversal if you are getting a non NULL node after a NULL node then \nit is not a complete binary tree\n"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Learned one valuable lesson today, never insert a null value as a placeholder in a queue. Punished me for this :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "neerajbhattof98",
                        "content": "GFG is better than Leetcode"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how ??"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "  ```  \\nclass Solution {\\n    public int height(TreeNode root){  // maxax height of a binary\\n        if(root==null){\\n            return 0;\\n        }\\n        return Math.max(height(root.left),height(root.right))+1;\\n    }\\n    public boolean isCompleteTree(TreeNode root) {\\n        //total no of nodes = 2^h-1; \\n        //bfs\\n         if(root==null){\\n            return true;\\n        }\\n        int Height = height(root);\\n        int depth = 1;\\n        Queue<TreeNode> q  =new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int n= q.size();\\n            for(int i =0;i<n;i++){\\n                TreeNode node = q.poll();\\n                if(depth<Height-1 && (node.left==null || node.right==null)) return false;\\n                else if(depth==Height-1){\\n                    if(node.left==null && node.right!=null) return false;\\n                }\\n                if(node.left!=null) q.offer(node.left);\\n                if(node.right!=null) q.offer(node.right);\\n            }\\n            depth++;\\n\\n        }\\n        return true;\\n    }\\n}\\n```\\nMy code fails on this tastecase\\n[1,2,3,5,null,7,8]\\nI know why its failing but can someone tell how to handle this taste case??\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "easy HINT: just remember how heap sort works, how a Complete Binary tree can be represented as a continuous array without any break. That\\'s All!!"
                    }
                ]
            },
            {
                "id": 1833444,
                "content": [
                    {
                        "username": "ShashidharAngadi",
                        "content": "It was my 100th medium question and that too solved it on one goo\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Why defining the found bool at every level giving wrong and while defining it at the top for only one time is giving right ans??\\n\\nbool isCompleteTree(TreeNode* root) {\\n        \\n        if (root == NULL)\\n            return true;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n\\n        bool found = false;\\n        while (!(q.empty()))\\n        {\\n            int n = q.size();\\n            // IF WE ARE DEFINING IT HERE THEN IT IS GIVING WRONG ANS, WHY?\\n            //bool found = false;\\n            while (n--)\\n            {\\n                TreeNode *node = q.front();\\n                q.pop();\\n                if (node == NULL)\\n                {\\n                    found = true;\\n                }\\n                else{\\n                    if(found)return false;\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n\\n    }"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "Spoiler alert!\\n\\nAnybody knows what to add to this code to work? I reached case 106 and I can\\'t get past it ([1, 2, 3, 4, 5, 6]);\\n\\nvar isCompleteTree = function(root) {\\n\\n    const scanTree = (root) => {\\n        if (!root.left && !root.right) return true;\\n        if (!root.left || !root.right) return false;\\n\\n        return (scanTree(root.left) && scanTree(root.right));\\n    }\\n\\n    return scanTree(root);\\n};"
                    },
                    {
                        "username": "cube_89",
                        "content": "This is a Tree Week \\uD83C\\uDF34\\uD83C\\uDF32"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "in level order traversal if you are getting a non NULL node after a NULL node then \nit is not a complete binary tree\n"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Learned one valuable lesson today, never insert a null value as a placeholder in a queue. Punished me for this :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "neerajbhattof98",
                        "content": "GFG is better than Leetcode"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how ??"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "  ```  \\nclass Solution {\\n    public int height(TreeNode root){  // maxax height of a binary\\n        if(root==null){\\n            return 0;\\n        }\\n        return Math.max(height(root.left),height(root.right))+1;\\n    }\\n    public boolean isCompleteTree(TreeNode root) {\\n        //total no of nodes = 2^h-1; \\n        //bfs\\n         if(root==null){\\n            return true;\\n        }\\n        int Height = height(root);\\n        int depth = 1;\\n        Queue<TreeNode> q  =new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int n= q.size();\\n            for(int i =0;i<n;i++){\\n                TreeNode node = q.poll();\\n                if(depth<Height-1 && (node.left==null || node.right==null)) return false;\\n                else if(depth==Height-1){\\n                    if(node.left==null && node.right!=null) return false;\\n                }\\n                if(node.left!=null) q.offer(node.left);\\n                if(node.right!=null) q.offer(node.right);\\n            }\\n            depth++;\\n\\n        }\\n        return true;\\n    }\\n}\\n```\\nMy code fails on this tastecase\\n[1,2,3,5,null,7,8]\\nI know why its failing but can someone tell how to handle this taste case??\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "easy HINT: just remember how heap sort works, how a Complete Binary tree can be represented as a continuous array without any break. That\\'s All!!"
                    }
                ]
            },
            {
                "id": 1833439,
                "content": [
                    {
                        "username": "ShashidharAngadi",
                        "content": "It was my 100th medium question and that too solved it on one goo\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Why defining the found bool at every level giving wrong and while defining it at the top for only one time is giving right ans??\\n\\nbool isCompleteTree(TreeNode* root) {\\n        \\n        if (root == NULL)\\n            return true;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n\\n        bool found = false;\\n        while (!(q.empty()))\\n        {\\n            int n = q.size();\\n            // IF WE ARE DEFINING IT HERE THEN IT IS GIVING WRONG ANS, WHY?\\n            //bool found = false;\\n            while (n--)\\n            {\\n                TreeNode *node = q.front();\\n                q.pop();\\n                if (node == NULL)\\n                {\\n                    found = true;\\n                }\\n                else{\\n                    if(found)return false;\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n\\n    }"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "Spoiler alert!\\n\\nAnybody knows what to add to this code to work? I reached case 106 and I can\\'t get past it ([1, 2, 3, 4, 5, 6]);\\n\\nvar isCompleteTree = function(root) {\\n\\n    const scanTree = (root) => {\\n        if (!root.left && !root.right) return true;\\n        if (!root.left || !root.right) return false;\\n\\n        return (scanTree(root.left) && scanTree(root.right));\\n    }\\n\\n    return scanTree(root);\\n};"
                    },
                    {
                        "username": "cube_89",
                        "content": "This is a Tree Week \\uD83C\\uDF34\\uD83C\\uDF32"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "in level order traversal if you are getting a non NULL node after a NULL node then \nit is not a complete binary tree\n"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Learned one valuable lesson today, never insert a null value as a placeholder in a queue. Punished me for this :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "neerajbhattof98",
                        "content": "GFG is better than Leetcode"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how ??"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "  ```  \\nclass Solution {\\n    public int height(TreeNode root){  // maxax height of a binary\\n        if(root==null){\\n            return 0;\\n        }\\n        return Math.max(height(root.left),height(root.right))+1;\\n    }\\n    public boolean isCompleteTree(TreeNode root) {\\n        //total no of nodes = 2^h-1; \\n        //bfs\\n         if(root==null){\\n            return true;\\n        }\\n        int Height = height(root);\\n        int depth = 1;\\n        Queue<TreeNode> q  =new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int n= q.size();\\n            for(int i =0;i<n;i++){\\n                TreeNode node = q.poll();\\n                if(depth<Height-1 && (node.left==null || node.right==null)) return false;\\n                else if(depth==Height-1){\\n                    if(node.left==null && node.right!=null) return false;\\n                }\\n                if(node.left!=null) q.offer(node.left);\\n                if(node.right!=null) q.offer(node.right);\\n            }\\n            depth++;\\n\\n        }\\n        return true;\\n    }\\n}\\n```\\nMy code fails on this tastecase\\n[1,2,3,5,null,7,8]\\nI know why its failing but can someone tell how to handle this taste case??\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "easy HINT: just remember how heap sort works, how a Complete Binary tree can be represented as a continuous array without any break. That\\'s All!!"
                    }
                ]
            },
            {
                "id": 1833420,
                "content": [
                    {
                        "username": "ShashidharAngadi",
                        "content": "It was my 100th medium question and that too solved it on one goo\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Why defining the found bool at every level giving wrong and while defining it at the top for only one time is giving right ans??\\n\\nbool isCompleteTree(TreeNode* root) {\\n        \\n        if (root == NULL)\\n            return true;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n\\n        bool found = false;\\n        while (!(q.empty()))\\n        {\\n            int n = q.size();\\n            // IF WE ARE DEFINING IT HERE THEN IT IS GIVING WRONG ANS, WHY?\\n            //bool found = false;\\n            while (n--)\\n            {\\n                TreeNode *node = q.front();\\n                q.pop();\\n                if (node == NULL)\\n                {\\n                    found = true;\\n                }\\n                else{\\n                    if(found)return false;\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n\\n    }"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "Spoiler alert!\\n\\nAnybody knows what to add to this code to work? I reached case 106 and I can\\'t get past it ([1, 2, 3, 4, 5, 6]);\\n\\nvar isCompleteTree = function(root) {\\n\\n    const scanTree = (root) => {\\n        if (!root.left && !root.right) return true;\\n        if (!root.left || !root.right) return false;\\n\\n        return (scanTree(root.left) && scanTree(root.right));\\n    }\\n\\n    return scanTree(root);\\n};"
                    },
                    {
                        "username": "cube_89",
                        "content": "This is a Tree Week \\uD83C\\uDF34\\uD83C\\uDF32"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "in level order traversal if you are getting a non NULL node after a NULL node then \nit is not a complete binary tree\n"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Learned one valuable lesson today, never insert a null value as a placeholder in a queue. Punished me for this :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "neerajbhattof98",
                        "content": "GFG is better than Leetcode"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how ??"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "  ```  \\nclass Solution {\\n    public int height(TreeNode root){  // maxax height of a binary\\n        if(root==null){\\n            return 0;\\n        }\\n        return Math.max(height(root.left),height(root.right))+1;\\n    }\\n    public boolean isCompleteTree(TreeNode root) {\\n        //total no of nodes = 2^h-1; \\n        //bfs\\n         if(root==null){\\n            return true;\\n        }\\n        int Height = height(root);\\n        int depth = 1;\\n        Queue<TreeNode> q  =new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int n= q.size();\\n            for(int i =0;i<n;i++){\\n                TreeNode node = q.poll();\\n                if(depth<Height-1 && (node.left==null || node.right==null)) return false;\\n                else if(depth==Height-1){\\n                    if(node.left==null && node.right!=null) return false;\\n                }\\n                if(node.left!=null) q.offer(node.left);\\n                if(node.right!=null) q.offer(node.right);\\n            }\\n            depth++;\\n\\n        }\\n        return true;\\n    }\\n}\\n```\\nMy code fails on this tastecase\\n[1,2,3,5,null,7,8]\\nI know why its failing but can someone tell how to handle this taste case??\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "easy HINT: just remember how heap sort works, how a Complete Binary tree can be represented as a continuous array without any break. That\\'s All!!"
                    }
                ]
            },
            {
                "id": 1833190,
                "content": [
                    {
                        "username": "ShashidharAngadi",
                        "content": "It was my 100th medium question and that too solved it on one goo\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Why defining the found bool at every level giving wrong and while defining it at the top for only one time is giving right ans??\\n\\nbool isCompleteTree(TreeNode* root) {\\n        \\n        if (root == NULL)\\n            return true;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n\\n        bool found = false;\\n        while (!(q.empty()))\\n        {\\n            int n = q.size();\\n            // IF WE ARE DEFINING IT HERE THEN IT IS GIVING WRONG ANS, WHY?\\n            //bool found = false;\\n            while (n--)\\n            {\\n                TreeNode *node = q.front();\\n                q.pop();\\n                if (node == NULL)\\n                {\\n                    found = true;\\n                }\\n                else{\\n                    if(found)return false;\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n\\n    }"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "Spoiler alert!\\n\\nAnybody knows what to add to this code to work? I reached case 106 and I can\\'t get past it ([1, 2, 3, 4, 5, 6]);\\n\\nvar isCompleteTree = function(root) {\\n\\n    const scanTree = (root) => {\\n        if (!root.left && !root.right) return true;\\n        if (!root.left || !root.right) return false;\\n\\n        return (scanTree(root.left) && scanTree(root.right));\\n    }\\n\\n    return scanTree(root);\\n};"
                    },
                    {
                        "username": "cube_89",
                        "content": "This is a Tree Week \\uD83C\\uDF34\\uD83C\\uDF32"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "in level order traversal if you are getting a non NULL node after a NULL node then \nit is not a complete binary tree\n"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Learned one valuable lesson today, never insert a null value as a placeholder in a queue. Punished me for this :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "neerajbhattof98",
                        "content": "GFG is better than Leetcode"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how ??"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "  ```  \\nclass Solution {\\n    public int height(TreeNode root){  // maxax height of a binary\\n        if(root==null){\\n            return 0;\\n        }\\n        return Math.max(height(root.left),height(root.right))+1;\\n    }\\n    public boolean isCompleteTree(TreeNode root) {\\n        //total no of nodes = 2^h-1; \\n        //bfs\\n         if(root==null){\\n            return true;\\n        }\\n        int Height = height(root);\\n        int depth = 1;\\n        Queue<TreeNode> q  =new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int n= q.size();\\n            for(int i =0;i<n;i++){\\n                TreeNode node = q.poll();\\n                if(depth<Height-1 && (node.left==null || node.right==null)) return false;\\n                else if(depth==Height-1){\\n                    if(node.left==null && node.right!=null) return false;\\n                }\\n                if(node.left!=null) q.offer(node.left);\\n                if(node.right!=null) q.offer(node.right);\\n            }\\n            depth++;\\n\\n        }\\n        return true;\\n    }\\n}\\n```\\nMy code fails on this tastecase\\n[1,2,3,5,null,7,8]\\nI know why its failing but can someone tell how to handle this taste case??\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "easy HINT: just remember how heap sort works, how a Complete Binary tree can be represented as a continuous array without any break. That\\'s All!!"
                    }
                ]
            },
            {
                "id": 1833100,
                "content": [
                    {
                        "username": "ShashidharAngadi",
                        "content": "It was my 100th medium question and that too solved it on one goo\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Why defining the found bool at every level giving wrong and while defining it at the top for only one time is giving right ans??\\n\\nbool isCompleteTree(TreeNode* root) {\\n        \\n        if (root == NULL)\\n            return true;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n\\n        bool found = false;\\n        while (!(q.empty()))\\n        {\\n            int n = q.size();\\n            // IF WE ARE DEFINING IT HERE THEN IT IS GIVING WRONG ANS, WHY?\\n            //bool found = false;\\n            while (n--)\\n            {\\n                TreeNode *node = q.front();\\n                q.pop();\\n                if (node == NULL)\\n                {\\n                    found = true;\\n                }\\n                else{\\n                    if(found)return false;\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n\\n    }"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "Spoiler alert!\\n\\nAnybody knows what to add to this code to work? I reached case 106 and I can\\'t get past it ([1, 2, 3, 4, 5, 6]);\\n\\nvar isCompleteTree = function(root) {\\n\\n    const scanTree = (root) => {\\n        if (!root.left && !root.right) return true;\\n        if (!root.left || !root.right) return false;\\n\\n        return (scanTree(root.left) && scanTree(root.right));\\n    }\\n\\n    return scanTree(root);\\n};"
                    },
                    {
                        "username": "cube_89",
                        "content": "This is a Tree Week \\uD83C\\uDF34\\uD83C\\uDF32"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "in level order traversal if you are getting a non NULL node after a NULL node then \nit is not a complete binary tree\n"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Learned one valuable lesson today, never insert a null value as a placeholder in a queue. Punished me for this :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "neerajbhattof98",
                        "content": "GFG is better than Leetcode"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how ??"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "  ```  \\nclass Solution {\\n    public int height(TreeNode root){  // maxax height of a binary\\n        if(root==null){\\n            return 0;\\n        }\\n        return Math.max(height(root.left),height(root.right))+1;\\n    }\\n    public boolean isCompleteTree(TreeNode root) {\\n        //total no of nodes = 2^h-1; \\n        //bfs\\n         if(root==null){\\n            return true;\\n        }\\n        int Height = height(root);\\n        int depth = 1;\\n        Queue<TreeNode> q  =new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int n= q.size();\\n            for(int i =0;i<n;i++){\\n                TreeNode node = q.poll();\\n                if(depth<Height-1 && (node.left==null || node.right==null)) return false;\\n                else if(depth==Height-1){\\n                    if(node.left==null && node.right!=null) return false;\\n                }\\n                if(node.left!=null) q.offer(node.left);\\n                if(node.right!=null) q.offer(node.right);\\n            }\\n            depth++;\\n\\n        }\\n        return true;\\n    }\\n}\\n```\\nMy code fails on this tastecase\\n[1,2,3,5,null,7,8]\\nI know why its failing but can someone tell how to handle this taste case??\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "easy HINT: just remember how heap sort works, how a Complete Binary tree can be represented as a continuous array without any break. That\\'s All!!"
                    }
                ]
            },
            {
                "id": 1833084,
                "content": [
                    {
                        "username": "ShashidharAngadi",
                        "content": "It was my 100th medium question and that too solved it on one goo\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Why defining the found bool at every level giving wrong and while defining it at the top for only one time is giving right ans??\\n\\nbool isCompleteTree(TreeNode* root) {\\n        \\n        if (root == NULL)\\n            return true;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n\\n        bool found = false;\\n        while (!(q.empty()))\\n        {\\n            int n = q.size();\\n            // IF WE ARE DEFINING IT HERE THEN IT IS GIVING WRONG ANS, WHY?\\n            //bool found = false;\\n            while (n--)\\n            {\\n                TreeNode *node = q.front();\\n                q.pop();\\n                if (node == NULL)\\n                {\\n                    found = true;\\n                }\\n                else{\\n                    if(found)return false;\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n\\n    }"
                    },
                    {
                        "username": "Ludacris2G",
                        "content": "Spoiler alert!\\n\\nAnybody knows what to add to this code to work? I reached case 106 and I can\\'t get past it ([1, 2, 3, 4, 5, 6]);\\n\\nvar isCompleteTree = function(root) {\\n\\n    const scanTree = (root) => {\\n        if (!root.left && !root.right) return true;\\n        if (!root.left || !root.right) return false;\\n\\n        return (scanTree(root.left) && scanTree(root.right));\\n    }\\n\\n    return scanTree(root);\\n};"
                    },
                    {
                        "username": "cube_89",
                        "content": "This is a Tree Week \\uD83C\\uDF34\\uD83C\\uDF32"
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "in level order traversal if you are getting a non NULL node after a NULL node then \nit is not a complete binary tree\n"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Learned one valuable lesson today, never insert a null value as a placeholder in a queue. Punished me for this :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "neerajbhattof98",
                        "content": "GFG is better than Leetcode"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how ??"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "  ```  \\nclass Solution {\\n    public int height(TreeNode root){  // maxax height of a binary\\n        if(root==null){\\n            return 0;\\n        }\\n        return Math.max(height(root.left),height(root.right))+1;\\n    }\\n    public boolean isCompleteTree(TreeNode root) {\\n        //total no of nodes = 2^h-1; \\n        //bfs\\n         if(root==null){\\n            return true;\\n        }\\n        int Height = height(root);\\n        int depth = 1;\\n        Queue<TreeNode> q  =new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            int n= q.size();\\n            for(int i =0;i<n;i++){\\n                TreeNode node = q.poll();\\n                if(depth<Height-1 && (node.left==null || node.right==null)) return false;\\n                else if(depth==Height-1){\\n                    if(node.left==null && node.right!=null) return false;\\n                }\\n                if(node.left!=null) q.offer(node.left);\\n                if(node.right!=null) q.offer(node.right);\\n            }\\n            depth++;\\n\\n        }\\n        return true;\\n    }\\n}\\n```\\nMy code fails on this tastecase\\n[1,2,3,5,null,7,8]\\nI know why its failing but can someone tell how to handle this taste case??\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "easy HINT: just remember how heap sort works, how a Complete Binary tree can be represented as a continuous array without any break. That\\'s All!!"
                    }
                ]
            },
            {
                "id": 1833028,
                "content": [
                    {
                        "username": "alexNotusDev",
                        "content": "Root without left and right, how it can be true ? \\n\\'A complete binary tree is a binary tree in which every level is completely filled\\'\\nI think 65 is wrong case.\\n\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Use BFS "
                    },
                    {
                        "username": "Msey",
                        "content": "Seems like i\\'m a dendroid this week among all the trees."
                    },
                    {
                        "username": "dumb_me",
                        "content": "```\\nthere are mainly three conditions which can tell if a tree is complete\\n!left && right  ===> false\\n!left && !right ===> every node after this node should be leaf otherwise false\\nLast one you try to think. (hint: similar to 1st condition)\\n\\n\\n// 2nd condition\\nif(isLeaf && (node->left || node->right)) \\n    return false;\\n\\n// 1 condition\\n if(!node->left && node->right) return false;\\n\\n//2 nd condition\\nif(!node->left && !node->right) {\\n       isLeaf = 1;\\n}\\n```"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "the testcase already gave out a big hint, we can make the TreeNode val in order, 1, 2, 3, 4, 5 etc. \\nFor root val equals to x, its left son is 2x, right son is 2x + 1"
                    },
                    {
                        "username": "sachinab",
                        "content": "Can someone tell me where this is going wrong?\n\nIntuition:\n\nWith the post order traversal, if you come across a leaf node with level less than that of already came across leaf node then the tree is not complete. \n\n\nclass Solution {\n    int maxLevel = 0;\n    public boolean isCompleteTree(TreeNode root) {\n        return isCompleteTree(root,0);\n    }\n\n    private boolean isCompleteTree(TreeNode root, int level){\n        if(root == null){\n            return level>=maxLevel;\n        }\n        level++;\n        maxLevel = Math.max(level,maxLevel);\n        return isCompleteTree(root.right,level) && isCompleteTree(root.left,level);\n    }\n\n}\n\nWrong Answer\n\n106 / 120 testcases passed\nInput\nroot =\n[1,2,3,4,5,6,7,8,9,10,11,12,13,null,null,15]\n\nOutput\ntrue\nExpected\nfalse"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this  week should be dedicated to tree especially."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are at least 2 kinds of solutions. One is BFS; other is DFS. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "how many trees have you planted this week?"
                    },
                    {
                        "username": "avinash2678",
                        "content": " 1. for complete binary tree.\\n 2. left node can\\'t be null before right node.\\n 3. In a complete binary tree, every level, except \\n possibly the last, is completely filled\\n 4. if it is not complete binary tree there should \\n    be null node before the not null node.\\n 5. so we need to maintain flag if any null node \\n     occurs before your not null node. if occurs \\n     return false else at end return true.\\n 6. we can take Boolean flag to check null node \\n     and use BFS"
                    }
                ]
            },
            {
                "id": 1832917,
                "content": [
                    {
                        "username": "alexNotusDev",
                        "content": "Root without left and right, how it can be true ? \\n\\'A complete binary tree is a binary tree in which every level is completely filled\\'\\nI think 65 is wrong case.\\n\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Use BFS "
                    },
                    {
                        "username": "Msey",
                        "content": "Seems like i\\'m a dendroid this week among all the trees."
                    },
                    {
                        "username": "dumb_me",
                        "content": "```\\nthere are mainly three conditions which can tell if a tree is complete\\n!left && right  ===> false\\n!left && !right ===> every node after this node should be leaf otherwise false\\nLast one you try to think. (hint: similar to 1st condition)\\n\\n\\n// 2nd condition\\nif(isLeaf && (node->left || node->right)) \\n    return false;\\n\\n// 1 condition\\n if(!node->left && node->right) return false;\\n\\n//2 nd condition\\nif(!node->left && !node->right) {\\n       isLeaf = 1;\\n}\\n```"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "the testcase already gave out a big hint, we can make the TreeNode val in order, 1, 2, 3, 4, 5 etc. \\nFor root val equals to x, its left son is 2x, right son is 2x + 1"
                    },
                    {
                        "username": "sachinab",
                        "content": "Can someone tell me where this is going wrong?\n\nIntuition:\n\nWith the post order traversal, if you come across a leaf node with level less than that of already came across leaf node then the tree is not complete. \n\n\nclass Solution {\n    int maxLevel = 0;\n    public boolean isCompleteTree(TreeNode root) {\n        return isCompleteTree(root,0);\n    }\n\n    private boolean isCompleteTree(TreeNode root, int level){\n        if(root == null){\n            return level>=maxLevel;\n        }\n        level++;\n        maxLevel = Math.max(level,maxLevel);\n        return isCompleteTree(root.right,level) && isCompleteTree(root.left,level);\n    }\n\n}\n\nWrong Answer\n\n106 / 120 testcases passed\nInput\nroot =\n[1,2,3,4,5,6,7,8,9,10,11,12,13,null,null,15]\n\nOutput\ntrue\nExpected\nfalse"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this  week should be dedicated to tree especially."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are at least 2 kinds of solutions. One is BFS; other is DFS. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "how many trees have you planted this week?"
                    },
                    {
                        "username": "avinash2678",
                        "content": " 1. for complete binary tree.\\n 2. left node can\\'t be null before right node.\\n 3. In a complete binary tree, every level, except \\n possibly the last, is completely filled\\n 4. if it is not complete binary tree there should \\n    be null node before the not null node.\\n 5. so we need to maintain flag if any null node \\n     occurs before your not null node. if occurs \\n     return false else at end return true.\\n 6. we can take Boolean flag to check null node \\n     and use BFS"
                    }
                ]
            },
            {
                "id": 1832875,
                "content": [
                    {
                        "username": "alexNotusDev",
                        "content": "Root without left and right, how it can be true ? \\n\\'A complete binary tree is a binary tree in which every level is completely filled\\'\\nI think 65 is wrong case.\\n\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Use BFS "
                    },
                    {
                        "username": "Msey",
                        "content": "Seems like i\\'m a dendroid this week among all the trees."
                    },
                    {
                        "username": "dumb_me",
                        "content": "```\\nthere are mainly three conditions which can tell if a tree is complete\\n!left && right  ===> false\\n!left && !right ===> every node after this node should be leaf otherwise false\\nLast one you try to think. (hint: similar to 1st condition)\\n\\n\\n// 2nd condition\\nif(isLeaf && (node->left || node->right)) \\n    return false;\\n\\n// 1 condition\\n if(!node->left && node->right) return false;\\n\\n//2 nd condition\\nif(!node->left && !node->right) {\\n       isLeaf = 1;\\n}\\n```"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "the testcase already gave out a big hint, we can make the TreeNode val in order, 1, 2, 3, 4, 5 etc. \\nFor root val equals to x, its left son is 2x, right son is 2x + 1"
                    },
                    {
                        "username": "sachinab",
                        "content": "Can someone tell me where this is going wrong?\n\nIntuition:\n\nWith the post order traversal, if you come across a leaf node with level less than that of already came across leaf node then the tree is not complete. \n\n\nclass Solution {\n    int maxLevel = 0;\n    public boolean isCompleteTree(TreeNode root) {\n        return isCompleteTree(root,0);\n    }\n\n    private boolean isCompleteTree(TreeNode root, int level){\n        if(root == null){\n            return level>=maxLevel;\n        }\n        level++;\n        maxLevel = Math.max(level,maxLevel);\n        return isCompleteTree(root.right,level) && isCompleteTree(root.left,level);\n    }\n\n}\n\nWrong Answer\n\n106 / 120 testcases passed\nInput\nroot =\n[1,2,3,4,5,6,7,8,9,10,11,12,13,null,null,15]\n\nOutput\ntrue\nExpected\nfalse"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this  week should be dedicated to tree especially."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are at least 2 kinds of solutions. One is BFS; other is DFS. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "how many trees have you planted this week?"
                    },
                    {
                        "username": "avinash2678",
                        "content": " 1. for complete binary tree.\\n 2. left node can\\'t be null before right node.\\n 3. In a complete binary tree, every level, except \\n possibly the last, is completely filled\\n 4. if it is not complete binary tree there should \\n    be null node before the not null node.\\n 5. so we need to maintain flag if any null node \\n     occurs before your not null node. if occurs \\n     return false else at end return true.\\n 6. we can take Boolean flag to check null node \\n     and use BFS"
                    }
                ]
            },
            {
                "id": 1832803,
                "content": [
                    {
                        "username": "alexNotusDev",
                        "content": "Root without left and right, how it can be true ? \\n\\'A complete binary tree is a binary tree in which every level is completely filled\\'\\nI think 65 is wrong case.\\n\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Use BFS "
                    },
                    {
                        "username": "Msey",
                        "content": "Seems like i\\'m a dendroid this week among all the trees."
                    },
                    {
                        "username": "dumb_me",
                        "content": "```\\nthere are mainly three conditions which can tell if a tree is complete\\n!left && right  ===> false\\n!left && !right ===> every node after this node should be leaf otherwise false\\nLast one you try to think. (hint: similar to 1st condition)\\n\\n\\n// 2nd condition\\nif(isLeaf && (node->left || node->right)) \\n    return false;\\n\\n// 1 condition\\n if(!node->left && node->right) return false;\\n\\n//2 nd condition\\nif(!node->left && !node->right) {\\n       isLeaf = 1;\\n}\\n```"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "the testcase already gave out a big hint, we can make the TreeNode val in order, 1, 2, 3, 4, 5 etc. \\nFor root val equals to x, its left son is 2x, right son is 2x + 1"
                    },
                    {
                        "username": "sachinab",
                        "content": "Can someone tell me where this is going wrong?\n\nIntuition:\n\nWith the post order traversal, if you come across a leaf node with level less than that of already came across leaf node then the tree is not complete. \n\n\nclass Solution {\n    int maxLevel = 0;\n    public boolean isCompleteTree(TreeNode root) {\n        return isCompleteTree(root,0);\n    }\n\n    private boolean isCompleteTree(TreeNode root, int level){\n        if(root == null){\n            return level>=maxLevel;\n        }\n        level++;\n        maxLevel = Math.max(level,maxLevel);\n        return isCompleteTree(root.right,level) && isCompleteTree(root.left,level);\n    }\n\n}\n\nWrong Answer\n\n106 / 120 testcases passed\nInput\nroot =\n[1,2,3,4,5,6,7,8,9,10,11,12,13,null,null,15]\n\nOutput\ntrue\nExpected\nfalse"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this  week should be dedicated to tree especially."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are at least 2 kinds of solutions. One is BFS; other is DFS. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "how many trees have you planted this week?"
                    },
                    {
                        "username": "avinash2678",
                        "content": " 1. for complete binary tree.\\n 2. left node can\\'t be null before right node.\\n 3. In a complete binary tree, every level, except \\n possibly the last, is completely filled\\n 4. if it is not complete binary tree there should \\n    be null node before the not null node.\\n 5. so we need to maintain flag if any null node \\n     occurs before your not null node. if occurs \\n     return false else at end return true.\\n 6. we can take Boolean flag to check null node \\n     and use BFS"
                    }
                ]
            },
            {
                "id": 1832764,
                "content": [
                    {
                        "username": "alexNotusDev",
                        "content": "Root without left and right, how it can be true ? \\n\\'A complete binary tree is a binary tree in which every level is completely filled\\'\\nI think 65 is wrong case.\\n\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Use BFS "
                    },
                    {
                        "username": "Msey",
                        "content": "Seems like i\\'m a dendroid this week among all the trees."
                    },
                    {
                        "username": "dumb_me",
                        "content": "```\\nthere are mainly three conditions which can tell if a tree is complete\\n!left && right  ===> false\\n!left && !right ===> every node after this node should be leaf otherwise false\\nLast one you try to think. (hint: similar to 1st condition)\\n\\n\\n// 2nd condition\\nif(isLeaf && (node->left || node->right)) \\n    return false;\\n\\n// 1 condition\\n if(!node->left && node->right) return false;\\n\\n//2 nd condition\\nif(!node->left && !node->right) {\\n       isLeaf = 1;\\n}\\n```"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "the testcase already gave out a big hint, we can make the TreeNode val in order, 1, 2, 3, 4, 5 etc. \\nFor root val equals to x, its left son is 2x, right son is 2x + 1"
                    },
                    {
                        "username": "sachinab",
                        "content": "Can someone tell me where this is going wrong?\n\nIntuition:\n\nWith the post order traversal, if you come across a leaf node with level less than that of already came across leaf node then the tree is not complete. \n\n\nclass Solution {\n    int maxLevel = 0;\n    public boolean isCompleteTree(TreeNode root) {\n        return isCompleteTree(root,0);\n    }\n\n    private boolean isCompleteTree(TreeNode root, int level){\n        if(root == null){\n            return level>=maxLevel;\n        }\n        level++;\n        maxLevel = Math.max(level,maxLevel);\n        return isCompleteTree(root.right,level) && isCompleteTree(root.left,level);\n    }\n\n}\n\nWrong Answer\n\n106 / 120 testcases passed\nInput\nroot =\n[1,2,3,4,5,6,7,8,9,10,11,12,13,null,null,15]\n\nOutput\ntrue\nExpected\nfalse"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this  week should be dedicated to tree especially."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are at least 2 kinds of solutions. One is BFS; other is DFS. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "how many trees have you planted this week?"
                    },
                    {
                        "username": "avinash2678",
                        "content": " 1. for complete binary tree.\\n 2. left node can\\'t be null before right node.\\n 3. In a complete binary tree, every level, except \\n possibly the last, is completely filled\\n 4. if it is not complete binary tree there should \\n    be null node before the not null node.\\n 5. so we need to maintain flag if any null node \\n     occurs before your not null node. if occurs \\n     return false else at end return true.\\n 6. we can take Boolean flag to check null node \\n     and use BFS"
                    }
                ]
            },
            {
                "id": 1832756,
                "content": [
                    {
                        "username": "alexNotusDev",
                        "content": "Root without left and right, how it can be true ? \\n\\'A complete binary tree is a binary tree in which every level is completely filled\\'\\nI think 65 is wrong case.\\n\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Use BFS "
                    },
                    {
                        "username": "Msey",
                        "content": "Seems like i\\'m a dendroid this week among all the trees."
                    },
                    {
                        "username": "dumb_me",
                        "content": "```\\nthere are mainly three conditions which can tell if a tree is complete\\n!left && right  ===> false\\n!left && !right ===> every node after this node should be leaf otherwise false\\nLast one you try to think. (hint: similar to 1st condition)\\n\\n\\n// 2nd condition\\nif(isLeaf && (node->left || node->right)) \\n    return false;\\n\\n// 1 condition\\n if(!node->left && node->right) return false;\\n\\n//2 nd condition\\nif(!node->left && !node->right) {\\n       isLeaf = 1;\\n}\\n```"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "the testcase already gave out a big hint, we can make the TreeNode val in order, 1, 2, 3, 4, 5 etc. \\nFor root val equals to x, its left son is 2x, right son is 2x + 1"
                    },
                    {
                        "username": "sachinab",
                        "content": "Can someone tell me where this is going wrong?\n\nIntuition:\n\nWith the post order traversal, if you come across a leaf node with level less than that of already came across leaf node then the tree is not complete. \n\n\nclass Solution {\n    int maxLevel = 0;\n    public boolean isCompleteTree(TreeNode root) {\n        return isCompleteTree(root,0);\n    }\n\n    private boolean isCompleteTree(TreeNode root, int level){\n        if(root == null){\n            return level>=maxLevel;\n        }\n        level++;\n        maxLevel = Math.max(level,maxLevel);\n        return isCompleteTree(root.right,level) && isCompleteTree(root.left,level);\n    }\n\n}\n\nWrong Answer\n\n106 / 120 testcases passed\nInput\nroot =\n[1,2,3,4,5,6,7,8,9,10,11,12,13,null,null,15]\n\nOutput\ntrue\nExpected\nfalse"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this  week should be dedicated to tree especially."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are at least 2 kinds of solutions. One is BFS; other is DFS. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "how many trees have you planted this week?"
                    },
                    {
                        "username": "avinash2678",
                        "content": " 1. for complete binary tree.\\n 2. left node can\\'t be null before right node.\\n 3. In a complete binary tree, every level, except \\n possibly the last, is completely filled\\n 4. if it is not complete binary tree there should \\n    be null node before the not null node.\\n 5. so we need to maintain flag if any null node \\n     occurs before your not null node. if occurs \\n     return false else at end return true.\\n 6. we can take Boolean flag to check null node \\n     and use BFS"
                    }
                ]
            },
            {
                "id": 1832734,
                "content": [
                    {
                        "username": "alexNotusDev",
                        "content": "Root without left and right, how it can be true ? \\n\\'A complete binary tree is a binary tree in which every level is completely filled\\'\\nI think 65 is wrong case.\\n\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Use BFS "
                    },
                    {
                        "username": "Msey",
                        "content": "Seems like i\\'m a dendroid this week among all the trees."
                    },
                    {
                        "username": "dumb_me",
                        "content": "```\\nthere are mainly three conditions which can tell if a tree is complete\\n!left && right  ===> false\\n!left && !right ===> every node after this node should be leaf otherwise false\\nLast one you try to think. (hint: similar to 1st condition)\\n\\n\\n// 2nd condition\\nif(isLeaf && (node->left || node->right)) \\n    return false;\\n\\n// 1 condition\\n if(!node->left && node->right) return false;\\n\\n//2 nd condition\\nif(!node->left && !node->right) {\\n       isLeaf = 1;\\n}\\n```"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "the testcase already gave out a big hint, we can make the TreeNode val in order, 1, 2, 3, 4, 5 etc. \\nFor root val equals to x, its left son is 2x, right son is 2x + 1"
                    },
                    {
                        "username": "sachinab",
                        "content": "Can someone tell me where this is going wrong?\n\nIntuition:\n\nWith the post order traversal, if you come across a leaf node with level less than that of already came across leaf node then the tree is not complete. \n\n\nclass Solution {\n    int maxLevel = 0;\n    public boolean isCompleteTree(TreeNode root) {\n        return isCompleteTree(root,0);\n    }\n\n    private boolean isCompleteTree(TreeNode root, int level){\n        if(root == null){\n            return level>=maxLevel;\n        }\n        level++;\n        maxLevel = Math.max(level,maxLevel);\n        return isCompleteTree(root.right,level) && isCompleteTree(root.left,level);\n    }\n\n}\n\nWrong Answer\n\n106 / 120 testcases passed\nInput\nroot =\n[1,2,3,4,5,6,7,8,9,10,11,12,13,null,null,15]\n\nOutput\ntrue\nExpected\nfalse"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this  week should be dedicated to tree especially."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are at least 2 kinds of solutions. One is BFS; other is DFS. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "how many trees have you planted this week?"
                    },
                    {
                        "username": "avinash2678",
                        "content": " 1. for complete binary tree.\\n 2. left node can\\'t be null before right node.\\n 3. In a complete binary tree, every level, except \\n possibly the last, is completely filled\\n 4. if it is not complete binary tree there should \\n    be null node before the not null node.\\n 5. so we need to maintain flag if any null node \\n     occurs before your not null node. if occurs \\n     return false else at end return true.\\n 6. we can take Boolean flag to check null node \\n     and use BFS"
                    }
                ]
            },
            {
                "id": 1832723,
                "content": [
                    {
                        "username": "alexNotusDev",
                        "content": "Root without left and right, how it can be true ? \\n\\'A complete binary tree is a binary tree in which every level is completely filled\\'\\nI think 65 is wrong case.\\n\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Use BFS "
                    },
                    {
                        "username": "Msey",
                        "content": "Seems like i\\'m a dendroid this week among all the trees."
                    },
                    {
                        "username": "dumb_me",
                        "content": "```\\nthere are mainly three conditions which can tell if a tree is complete\\n!left && right  ===> false\\n!left && !right ===> every node after this node should be leaf otherwise false\\nLast one you try to think. (hint: similar to 1st condition)\\n\\n\\n// 2nd condition\\nif(isLeaf && (node->left || node->right)) \\n    return false;\\n\\n// 1 condition\\n if(!node->left && node->right) return false;\\n\\n//2 nd condition\\nif(!node->left && !node->right) {\\n       isLeaf = 1;\\n}\\n```"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "the testcase already gave out a big hint, we can make the TreeNode val in order, 1, 2, 3, 4, 5 etc. \\nFor root val equals to x, its left son is 2x, right son is 2x + 1"
                    },
                    {
                        "username": "sachinab",
                        "content": "Can someone tell me where this is going wrong?\n\nIntuition:\n\nWith the post order traversal, if you come across a leaf node with level less than that of already came across leaf node then the tree is not complete. \n\n\nclass Solution {\n    int maxLevel = 0;\n    public boolean isCompleteTree(TreeNode root) {\n        return isCompleteTree(root,0);\n    }\n\n    private boolean isCompleteTree(TreeNode root, int level){\n        if(root == null){\n            return level>=maxLevel;\n        }\n        level++;\n        maxLevel = Math.max(level,maxLevel);\n        return isCompleteTree(root.right,level) && isCompleteTree(root.left,level);\n    }\n\n}\n\nWrong Answer\n\n106 / 120 testcases passed\nInput\nroot =\n[1,2,3,4,5,6,7,8,9,10,11,12,13,null,null,15]\n\nOutput\ntrue\nExpected\nfalse"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this  week should be dedicated to tree especially."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are at least 2 kinds of solutions. One is BFS; other is DFS. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "how many trees have you planted this week?"
                    },
                    {
                        "username": "avinash2678",
                        "content": " 1. for complete binary tree.\\n 2. left node can\\'t be null before right node.\\n 3. In a complete binary tree, every level, except \\n possibly the last, is completely filled\\n 4. if it is not complete binary tree there should \\n    be null node before the not null node.\\n 5. so we need to maintain flag if any null node \\n     occurs before your not null node. if occurs \\n     return false else at end return true.\\n 6. we can take Boolean flag to check null node \\n     and use BFS"
                    }
                ]
            },
            {
                "id": 1832720,
                "content": [
                    {
                        "username": "alexNotusDev",
                        "content": "Root without left and right, how it can be true ? \\n\\'A complete binary tree is a binary tree in which every level is completely filled\\'\\nI think 65 is wrong case.\\n\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Use BFS "
                    },
                    {
                        "username": "Msey",
                        "content": "Seems like i\\'m a dendroid this week among all the trees."
                    },
                    {
                        "username": "dumb_me",
                        "content": "```\\nthere are mainly three conditions which can tell if a tree is complete\\n!left && right  ===> false\\n!left && !right ===> every node after this node should be leaf otherwise false\\nLast one you try to think. (hint: similar to 1st condition)\\n\\n\\n// 2nd condition\\nif(isLeaf && (node->left || node->right)) \\n    return false;\\n\\n// 1 condition\\n if(!node->left && node->right) return false;\\n\\n//2 nd condition\\nif(!node->left && !node->right) {\\n       isLeaf = 1;\\n}\\n```"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "the testcase already gave out a big hint, we can make the TreeNode val in order, 1, 2, 3, 4, 5 etc. \\nFor root val equals to x, its left son is 2x, right son is 2x + 1"
                    },
                    {
                        "username": "sachinab",
                        "content": "Can someone tell me where this is going wrong?\n\nIntuition:\n\nWith the post order traversal, if you come across a leaf node with level less than that of already came across leaf node then the tree is not complete. \n\n\nclass Solution {\n    int maxLevel = 0;\n    public boolean isCompleteTree(TreeNode root) {\n        return isCompleteTree(root,0);\n    }\n\n    private boolean isCompleteTree(TreeNode root, int level){\n        if(root == null){\n            return level>=maxLevel;\n        }\n        level++;\n        maxLevel = Math.max(level,maxLevel);\n        return isCompleteTree(root.right,level) && isCompleteTree(root.left,level);\n    }\n\n}\n\nWrong Answer\n\n106 / 120 testcases passed\nInput\nroot =\n[1,2,3,4,5,6,7,8,9,10,11,12,13,null,null,15]\n\nOutput\ntrue\nExpected\nfalse"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this  week should be dedicated to tree especially."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are at least 2 kinds of solutions. One is BFS; other is DFS. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "how many trees have you planted this week?"
                    },
                    {
                        "username": "avinash2678",
                        "content": " 1. for complete binary tree.\\n 2. left node can\\'t be null before right node.\\n 3. In a complete binary tree, every level, except \\n possibly the last, is completely filled\\n 4. if it is not complete binary tree there should \\n    be null node before the not null node.\\n 5. so we need to maintain flag if any null node \\n     occurs before your not null node. if occurs \\n     return false else at end return true.\\n 6. we can take Boolean flag to check null node \\n     and use BFS"
                    }
                ]
            },
            {
                "id": 1832690,
                "content": [
                    {
                        "username": "alexNotusDev",
                        "content": "Root without left and right, how it can be true ? \\n\\'A complete binary tree is a binary tree in which every level is completely filled\\'\\nI think 65 is wrong case.\\n\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Use BFS "
                    },
                    {
                        "username": "Msey",
                        "content": "Seems like i\\'m a dendroid this week among all the trees."
                    },
                    {
                        "username": "dumb_me",
                        "content": "```\\nthere are mainly three conditions which can tell if a tree is complete\\n!left && right  ===> false\\n!left && !right ===> every node after this node should be leaf otherwise false\\nLast one you try to think. (hint: similar to 1st condition)\\n\\n\\n// 2nd condition\\nif(isLeaf && (node->left || node->right)) \\n    return false;\\n\\n// 1 condition\\n if(!node->left && node->right) return false;\\n\\n//2 nd condition\\nif(!node->left && !node->right) {\\n       isLeaf = 1;\\n}\\n```"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "the testcase already gave out a big hint, we can make the TreeNode val in order, 1, 2, 3, 4, 5 etc. \\nFor root val equals to x, its left son is 2x, right son is 2x + 1"
                    },
                    {
                        "username": "sachinab",
                        "content": "Can someone tell me where this is going wrong?\n\nIntuition:\n\nWith the post order traversal, if you come across a leaf node with level less than that of already came across leaf node then the tree is not complete. \n\n\nclass Solution {\n    int maxLevel = 0;\n    public boolean isCompleteTree(TreeNode root) {\n        return isCompleteTree(root,0);\n    }\n\n    private boolean isCompleteTree(TreeNode root, int level){\n        if(root == null){\n            return level>=maxLevel;\n        }\n        level++;\n        maxLevel = Math.max(level,maxLevel);\n        return isCompleteTree(root.right,level) && isCompleteTree(root.left,level);\n    }\n\n}\n\nWrong Answer\n\n106 / 120 testcases passed\nInput\nroot =\n[1,2,3,4,5,6,7,8,9,10,11,12,13,null,null,15]\n\nOutput\ntrue\nExpected\nfalse"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this  week should be dedicated to tree especially."
                    },
                    {
                        "username": "anwendeng",
                        "content": "There are at least 2 kinds of solutions. One is BFS; other is DFS. "
                    },
                    {
                        "username": "JiayingGao",
                        "content": "how many trees have you planted this week?"
                    },
                    {
                        "username": "avinash2678",
                        "content": " 1. for complete binary tree.\\n 2. left node can\\'t be null before right node.\\n 3. In a complete binary tree, every level, except \\n possibly the last, is completely filled\\n 4. if it is not complete binary tree there should \\n    be null node before the not null node.\\n 5. so we need to maintain flag if any null node \\n     occurs before your not null node. if occurs \\n     return false else at end return true.\\n 6. we can take Boolean flag to check null node \\n     and use BFS"
                    }
                ]
            }
        ]
    }
]