[
    {
        "title": "Largest Component Size by Common Factor",
        "question_content": "You are given an integer array of unique positive integers nums. Consider the following graph:\n\n\tThere are nums.length nodes, labeled nums[0] to nums[nums.length - 1],\n\tThere is an undirected edge between nums[i] and nums[j] if nums[i] and nums[j] share a common factor greater than 1.\n\nReturn the size of the largest connected component in the graph.\n&nbsp;\nExample 1:\n\nInput: nums = [4,6,15,35]\nOutput: 4\n\nExample 2:\n\nInput: nums = [20,50,9,63]\nOutput: 2\n\nExample 3:\n\nInput: nums = [2,3,6,7,4,12,21,39]\nOutput: 8\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 2 * 104\n\t1 <= nums[i] <= 105\n\tAll the values of nums are unique.",
        "solutions": [
            {
                "id": 819919,
                "title": "python-union-find-solution-explained",
                "content": "If you try to run usual dfs/bfs on this problem, you will get TLE, so we need to think something smarter. Note, that if two numbers has common factor more than `1`, it means that they have **prime** common factor. So, let us for example consider all even numbers: they all have prime common factor `2`, so we can immediatly say, that they should be in the same group. Consider all numbers which are divisible by `3`, they also can be put in the same group. There is special data stucture: Disjoint set (https://en.wikipedia.org/wiki/Disjoint-set_data_structure), which is very suitable for these type of problems.\\n\\nLet us consider example `[2,3,6,7,4,12,21,39]` an go through my code:\\n\\n1. `primes_set(self,n)` return set of unique prive divisors of number `n`, for example for `n = 12` it returns set `[2,3]` and for `n=39` it returns set `[3,13]`.\\n2. Now, what is `primes` defaultdict? For each found prime, we put indexes of numbers from `A`, which are divisible by this prime. For our example we have: `2: [0,2,4,5], 3:[1,2,5,6,7], 7:[3,6], 13:[7]`. So, what we need to do now? We need to union `0-2-4-5`, `1-2-5-6-7` and `3-6`.\\n3. That exaclty what we do on the next step: iterate over our `primes` and create connections with `UF.union(indexes[i], indexes[i+1])`\\n4. Finally, when we made all connections, we need to find the biggest group: so we find parent for each number and find the bigges frequency.\\n\\n**Complexity**: this is interesting part. Let `n` be length of `A` and let `m` be the biggest possible number. Function `primes_set` is quite heavy: for each number we need to check all numbers before its square root (if number is prime we can not do better with this approach), so complexity of `primes_set` is `O(sqrt(m))`. We apply this function `n` times, so overall complexity of this function will be `O(n*sqrt(m))`. We also have other parts of algorithm, where we put prime numbers to dictionary, complexity will be `O(n*log(m))` at most, because each number has no more, than `log(m)` different prime divisors. We also have the same number of `union()` calls, which will work as `O(1)` if we use it with ranks, and slower if we use it without ranks as I did, but still fast enough to be better than our bottleneck: `O(n*sqrt(m))` complexity for prime factors generation. That is why I use Union Find without ranks: if you want to improve algorighm, you need to deal with `primes_set()` function.\\nSpace complexity is `O(n*log(m))` to keep all prime factors and to keep our `DSU` data structure.\\n\\n```\\nclass DSU:\\n    def __init__(self, N):\\n        self.p = list(range(N))\\n\\n    def find(self, x):\\n        if self.p[x] != x:\\n            self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n\\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        self.p[xr] = yr\\n\\nclass Solution:\\n    def primes_set(self,n):\\n        for i in range(2, int(math.sqrt(n))+1):\\n            if n % i == 0:\\n                return self.primes_set(n//i) | set([i])\\n        return set([n])\\n\\n    def largestComponentSize(self, A):\\n        n = len(A)\\n        UF = DSU(n)\\n        primes = defaultdict(list)\\n        for i, num in enumerate(A):\\n            pr_set = self.primes_set(num)\\n            for q in pr_set: primes[q].append(i)\\n\\n        for _, indexes in primes.items():\\n            for i in range(len(indexes)-1):\\n                UF.union(indexes[i], indexes[i+1])\\n\\n        return max(Counter([UF.find(i) for i in range(n)]).values())\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass DSU:\\n    def __init__(self, N):\\n        self.p = list(range(N))\\n\\n    def find(self, x):\\n        if self.p[x] != x:\\n            self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n\\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        self.p[xr] = yr\\n\\nclass Solution:\\n    def primes_set(self,n):\\n        for i in range(2, int(math.sqrt(n))+1):\\n            if n % i == 0:\\n                return self.primes_set(n//i) | set([i])\\n        return set([n])\\n\\n    def largestComponentSize(self, A):\\n        n = len(A)\\n        UF = DSU(n)\\n        primes = defaultdict(list)\\n        for i, num in enumerate(A):\\n            pr_set = self.primes_set(num)\\n            for q in pr_set: primes[q].append(i)\\n\\n        for _, indexes in primes.items():\\n            for i in range(len(indexes)-1):\\n                UF.union(indexes[i], indexes[i+1])\\n\\n        return max(Counter([UF.find(i) for i in range(n)]).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592263,
                "title": "c-3-simple-solution-w-explanation-disjoint-set-union-sieve-of-eratosthenes",
                "content": "We are given an array `nums` each element of which denotes a node in the graph. There is an edge between two elements if they share a common factor. We need to return the largest connected component in this graph.\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Union-Find)***\\n\\nThe problem statement can be stated in simpler terms as - two element belong to same group if they share a common factor. We need to find largest of such groups. \\n\\nFor eg. If we have numbers `[2,3,5,6,25]`, then we can see `2` & `6` share a common factor. So lets say they belong to group `A`. `3` & `6` also share a common factor, so 3 belongs to group `A` as well. `5` and `25` is another pair sharing a common factor so they belong to one group, lets say `B`. So, out of all these groups, `A` is the largest and it will be our answer.\\n\\nThere\\'s a common Data Structure that can be used in such problems - **[Disjoint Set Union](https://en.wikipedia.org/wiki/Disjoint-set_data_structure)**. \\n\\n<blockquote>\\n<details>\\n<summary><b>Brief Description of DSU</b></summary>\\n\\nDisjoin Set Union or DSU involes two basic operations -\\n* **`find(x)`**: finds the id which represents the component that a node belongs to\\n* **`union(x, y)`**: joins the two components into a single component. This involves finding the representative of x-component (by `find(x)`) and y-component (by `find(y)`) and assigning them a common  representative (same parent).\\n\\nIn simple implementation, we can only maintain a `par` array denoting parent of each node and define a `find` function that finds representative/parent of component that a given node belongs to. In more optimized versions, we use path compression in `find` function along with either use a rank or size to group elements based on their component rank/size to ensure that even in the worst case, DSU doesnt form a skewed tree. You can read on more about it **[here](https://cp-algorithms.com/data_structures/disjoint_set_union.html)**\\n\\n</details>\\n</blockquote>\\n\\nHere, we use DSU to group elements of `nums` and its factors into a single component. Once this is done, all elements of `nums` that share a common factor will belong to the same component and will have the same parent in DSU. Then we can just iterate over `nums`, and find the parent of component that it belongs to. We keep count of number of times that each parent is seen. The largest group will be the one whose parent is seen maximum number of times.\\n\\nWe can find the factors of a number in `O(sqrt(N))` time and union each factor with that number itself.\\n\\n```cpp\\n// a standard Disjoint Set Union class template\\nclass DSU {\\n    public:\\n    vector<int> par, sz;\\n    DSU(int n) : par(n), sz(n,1) {\\n        iota(begin(par), end(par), 0);                         // initializes each node\\'s parent to be itself - fills as [0,1,2,3,...,n]\\n    }\\n    int find(int x) {\\n        if(par[x] == x) return x;                              // x is itself the parent of the component that it belongs to\\n        return par[x] = find(par[x]);                          // update parent of x before returning for each call -path compression\\n    }\\n    bool Union(int x, int y) {\\n        int xp = find(x), yp = find(y);                        // find parents of x and y, i.e, representatives of components that x and y belong to\\n        if(xp == yp) return false;                             // x and y already belong to same component - not possible to union\\n        if(sz[xp] > sz[yp]) par[yp] = par[xp], sz[xp] += sz[yp];   // union by size - join smaller sized to bigger one\\n        else par[xp] = par[yp], sz[yp] += sz[xp];\\n        return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = size(nums), ans = 1;\\n        DSU ds(*max_element(begin(nums), end(nums)) + 1);      // max(nums) is largest element that will be stored in DSU\\n        unordered_map<int, int> mp;                            // maintains {parent of component: frequency}\\n        for(auto c : nums) \\n            for(int f = 2; f <= sqrt(c); f++)                  // finding factors of each element\\n                if(c % f == 0)                                 // if f divides c, then f & c/f are its factor. So union them\\n                    ds.Union(c, f), \\n                    ds.Union(c, c/f);\\n        \\n        for(int i = 0; i < n; i++)                             // iterate and find parent that is seen most. It\\'ll give the largest group\\n            ans = max(ans, ++mp[ds.find(nums[i])]);\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n***Time Complexity :*** `O(N * sqrt(M))`, where `N` is the number of elements in `nums` and `M` is the maximum element in `nums`. The time complexity of each `find` call after union-by-size and path compression comes out to be `O(\\u03B1(n))`, where `\\u03B1(n)` is the inverse Ackermann function. It doesn\\'t exceed 4 for any <code>n < 10<sup>600</sup></code> and hence is practically constant. We take each `N` elements from `nums` and iterate upto `sqrt(num[i])`. Thus the overall time comes out to `O(N * sqrt(M))`.\\n***Space Complexity :*** `O(M)`, for DSU\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Union-Find w/ Prime Factorization)***\\n\\nWe can see that if two numbers belong to the same group due to some common factor, they should also have some common prime factor. This allows us to use slightly different approach where we find all prime factors of a number and union the elements based on the common prime factors amongst them. This can reduce the space used by DSU to `O(N)` down from `O(M)` by allowing us to perform union on indices of elements instead of elements & its factors, although we do incur a cost of storing primes and elements in `nums` that it divides.\\n\\n```cpp\\nclass UnionFind {\\n    public:\\n    vector<int> par, sz;\\n    UnionFind(int n) : par(n), sz(n,1) {\\n        iota(begin(par), end(par), 0);\\n    }\\n    int find(int x) {\\n        if(par[x] == x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n    bool Union(int x, int y) {\\n        int xp = find(x), yp = find(y);\\n        if(xp == yp) return false;\\n        if(sz[xp] > sz[yp]) par[yp] = par[xp], sz[xp] += sz[yp];\\n        else par[xp] = par[yp], sz[yp] += sz[xp];\\n        return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = size(nums), ans = 1;\\n        UnionFind uf(n + 1);\\n        unordered_map<int, vector<int>> mp;             // stores {p : [indices of nums for which p is prime factor]}\\n        for(int i = 0; i < n; i++) {                    // prime factorize nums[i]\\n            int cur = nums[i];\\n            if(cur % 2 == 0) {                          // 2 is prime factor of nums[i]\\n                mp[2].push_back(i);\\n                while(cur % 2 == 0) cur >>= 1;\\n            }\\n            for(int p = 3; p <= sqrt(cur); p += 2)      // now check for all odd numbers if it is factor of nums[i]\\n                if(cur % p == 0) {                      // p is prime factor of nums[i]\\n                    mp[p].push_back(i);\\n                    while(cur % p == 0) cur /= p;\\n                }\\n            \\n            if(cur > 1) mp[cur].push_back(i);           // nums[i] itself is prime\\n        }\\n        \\n        for(auto& [prime, ids] : mp)                    // union all element index that have same prime\\n            for(int i = 0; i < size(ids)-1; i++) \\n                uf.Union(ids[i], ids[i+1]);\\n        \\n        return *max_element(begin(uf.sz), end(uf.sz));  // return largest component\\n    }\\n};\\n```\\n\\nHowever, we can add another small optimization for space. Instead of storing all the primes as a vector in the hashmap and then performing union on the indices of element that each prime divides, we can just put the 1st index of element we find that a prime `p` divides and then for every subsequent indices, we just union them there itself. This saves space and also eliminate the last step of iterating over each prime and then unioning the indices. \\n\\nThe following code will make this optimization clear -\\n\\n```cpp\\nclass UnionFind {\\n    public:\\n    vector<int> par, sz;\\n    UnionFind(int n) : par(n), sz(n,1) {\\n        iota(begin(par), end(par), 0);\\n    }\\n    int find(int x) {\\n        if(par[x] == x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n    bool Union(int x, int y) {\\n        int xp = find(x), yp = find(y);\\n        if(xp == yp) return false;\\n        if(sz[xp] > sz[yp]) par[yp] = par[xp], sz[xp] += sz[yp];\\n        else par[xp] = par[yp], sz[yp] += sz[xp];\\n        return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = size(nums), ans = 1;\\n        UnionFind uf(n + 1);\\n        unordered_map<int, int> mp;                    // stores {p : 1st found index i such that nums[i] % p == 0}\\n        auto putOrUnion = [&](int p, int i){           // puts 1st found index of element that p divides into hashmap\\n            if(mp.count(p)) uf.Union(mp[p], i);        // and if already exists, directly union them\\n            else mp[p] = i;\\n        };\\n        for(int i = 0; i < n; i++) {                   // prime factorize nums[i]\\n            int cur = nums[i];\\n            if(cur % 2 == 0) {                        \\n                putOrUnion(2, i);\\n                while(cur % 2 == 0) cur >>= 1;\\n            }\\n            for(int p = 3; p <= sqrt(cur); p += 2)   \\n                if(cur % p == 0) {                 \\n                    putOrUnion(p, i);\\n                    while(cur % p == 0) cur /= p;\\n                }\\n            if(cur > 1) putOrUnion(cur, i);            // nums[i] itself is prime   \\n        }\\n        return *max_element(begin(uf.sz), end(uf.sz)); // return largest component\\n    }\\n};\\n```\\n\\n***Time Complexity :*** `O(N * sqrt(M))` same as above\\n***Space Complexity :*** \\n* 1st Implementation: <code>O(N + \\u2211\\u03C9(nums<sub>i</sub>))</code> \\n* 2nd Implementation: `O(N + \\u03C0(M))`\\n \\nwhere `\\u03C9(n)` is the **[prime omega function](https://en.wikipedia.org/wiki/Prime_omega_function)** and `\\u03C0(n)` is the **[prime counting function](https://en.wikipedia.org/wiki/Prime-counting_function)** which is approximately equal to `O(n/logn)`. Let me know if there\\'s a better way to describe the space complexity or if there\\'s a mistake in this analysis.\\n\\n\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Union-Find w/ Prime Factorization using Sieve of Eratosthenes)***\\n\\nWe can use sieve of Eratosthenes to compute prime factorization queries in better time complexity than O(sqrt(M)). The logic is similar to above but we have just changed the way we compute prime factors for each element in `nums`. \\n\\n<blockquote>\\n<details>\\n\\n<summary>Similar to 1st implementation in <code>Solution - II</code></summary>\\n\\n```cpp\\nclass UnionFind {\\n    public:\\n    vector<int> par, sz;\\n    UnionFind(int n) : par(n), sz(n,1) {\\n        iota(begin(par), end(par), 0);\\n    }\\n    int find(int x) {\\n        if(par[x] == x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n    bool Union(int x, int y) {\\n        int xp = find(x), yp = find(y);\\n        if(xp == yp) return false;\\n        if(sz[xp] > sz[yp]) par[yp] = par[xp], sz[xp] += sz[yp];\\n        else par[xp] = par[yp], sz[yp] += sz[xp];\\n        return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = size(nums), M = *max_element(begin(nums), end(nums)), ans = 1;\\n        auto spf = sieve(M+1);\\n        UnionFind uf(n + 1);\\n        unordered_map<int, vector<int>> mp;           // stores {p : [indices of nums for which p is prime factor]}\\n        for(int i = 0; i < n; i++)                    // prime factorize nums[i]\\n            for(auto p : getPrimes(nums[i], spf))\\n                mp[p].push_back(i);\\n        \\n        for(auto& [prime, ids] : mp)                  // union all element index that have same prime\\n            for(int i = 0; i < size(ids)-1; i++) \\n                uf.Union(ids[i], ids[i+1]);\\n        \\n        return *max_element(begin(uf.sz), end(uf.sz));\\n    }\\n    \\n    vector<int> sieve(int M) {\\n        vector<int> spf(M+1);\\n        iota(begin(spf), end(spf), 0);\\n        for(int i = 2; i*i < M; i++) \\n            if(spf[i] == i) \\n                for(int j = i*i; j < M; j += i)\\n                    if(spf[j] == j)\\n                        spf[j] = i;            \\n        return spf;\\n    }\\n\\n    vector<int> getPrimes(int x, vector<int>& spf) {\\n        vector<int> primes;\\n        while (x != 1) {\\n            int p = spf[x];\\n            primes.push_back(p);\\n            while(x % p == 0) x /= p;\\n        }\\n        return primes;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** `O((N+M)logM)`\\n***Space Complexity :*** <code>O(M + \\u2211\\u03C9(nums<sub>i</sub>))</code>\\n\\n</details>\\n</blockquote>\\n\\n```cpp\\nclass UnionFind {\\n    public:\\n    vector<int> par, sz;\\n    UnionFind(int n) : par(n), sz(n,1) {\\n        iota(begin(par), end(par), 0);\\n    }\\n    int find(int x) {\\n        if(par[x] == x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n    bool Union(int x, int y) {\\n        int xp = find(x), yp = find(y);\\n        if(xp == yp) return false;\\n        if(sz[xp] > sz[yp]) par[yp] = par[xp], sz[xp] += sz[yp];\\n        else par[xp] = par[yp], sz[yp] += sz[xp];\\n        return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = size(nums), ans = 1;\\n        auto spf = sieve(*max_element(begin(nums), end(nums))+1);\\n        UnionFind uf(n + 1);\\n        unordered_map<int, int> mp;                      // stores {p : 1st found index i such that nums[i] % p == 0}\\n        for(int i = 0; i < n; i++)                       // prime factorize nums[i]\\n            for(auto p : getPrimes(nums[i], spf))\\n                if(mp.count(p)) uf.Union(i, mp[p]);\\n                else mp[p] = i;\\n        \\n        return *max_element(begin(uf.sz), end(uf.sz));\\n    }\\n    \\n    vector<int> sieve(int M) {\\n        vector<int> spf(M+1);\\n        iota(begin(spf), end(spf), 0);\\n        for(int i = 2; i*i < M; i++) \\n            if(spf[i] == i) \\n                for(int j = i*i; j < M; j += i)\\n                    if(spf[j] == j)\\n                        spf[j] = i;            \\n        return spf;\\n    }\\n\\n    vector<int> getPrimes(int x, vector<int>& spf) {\\n        vector<int> primes;\\n        while (x != 1) {\\n            int p = spf[x];\\n            primes.push_back(p);\\n            while(x % p == 0) x /= p;\\n        }\\n        return primes;\\n    }\\n};\\n```\\n\\n\\n\\n***Time Complexity :*** `O(M*log(logM) + N*logM)`, we require `O(M*log(logM))` time to initially compute the sieve.Then, every query to `getPrimes` will require `O(logM)` and this is queried for `N` times. So overall time complexity becomes `O(M*loglogM + NlogM)`.\\n\\n***Space Complexity :*** `O(M)`, for sieve\\n\\nYou can search **`sieve of eratosthenes GFG`** to read more about it on GFG from where this implementation is referred (unfortunately LC doesn\\'t allow external links or even names of sites in post \\u2639\\uFE0F).\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\n// a standard Disjoint Set Union class template\\nclass DSU {\\n    public:\\n    vector<int> par, sz;\\n    DSU(int n) : par(n), sz(n,1) {\\n        iota(begin(par), end(par), 0);                         // initializes each node\\'s parent to be itself - fills as [0,1,2,3,...,n]\\n    }\\n    int find(int x) {\\n        if(par[x] == x) return x;                              // x is itself the parent of the component that it belongs to\\n        return par[x] = find(par[x]);                          // update parent of x before returning for each call -path compression\\n    }\\n    bool Union(int x, int y) {\\n        int xp = find(x), yp = find(y);                        // find parents of x and y, i.e, representatives of components that x and y belong to\\n        if(xp == yp) return false;                             // x and y already belong to same component - not possible to union\\n        if(sz[xp] > sz[yp]) par[yp] = par[xp], sz[xp] += sz[yp];   // union by size - join smaller sized to bigger one\\n        else par[xp] = par[yp], sz[yp] += sz[xp];\\n        return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = size(nums), ans = 1;\\n        DSU ds(*max_element(begin(nums), end(nums)) + 1);      // max(nums) is largest element that will be stored in DSU\\n        unordered_map<int, int> mp;                            // maintains {parent of component: frequency}\\n        for(auto c : nums) \\n            for(int f = 2; f <= sqrt(c); f++)                  // finding factors of each element\\n                if(c % f == 0)                                 // if f divides c, then f & c/f are its factor. So union them\\n                    ds.Union(c, f), \\n                    ds.Union(c, c/f);\\n        \\n        for(int i = 0; i < n; i++)                             // iterate and find parent that is seen most. It\\'ll give the largest group\\n            ans = max(ans, ++mp[ds.find(nums[i])]);\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass UnionFind {\\n    public:\\n    vector<int> par, sz;\\n    UnionFind(int n) : par(n), sz(n,1) {\\n        iota(begin(par), end(par), 0);\\n    }\\n    int find(int x) {\\n        if(par[x] == x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n    bool Union(int x, int y) {\\n        int xp = find(x), yp = find(y);\\n        if(xp == yp) return false;\\n        if(sz[xp] > sz[yp]) par[yp] = par[xp], sz[xp] += sz[yp];\\n        else par[xp] = par[yp], sz[yp] += sz[xp];\\n        return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = size(nums), ans = 1;\\n        UnionFind uf(n + 1);\\n        unordered_map<int, vector<int>> mp;             // stores {p : [indices of nums for which p is prime factor]}\\n        for(int i = 0; i < n; i++) {                    // prime factorize nums[i]\\n            int cur = nums[i];\\n            if(cur % 2 == 0) {                          // 2 is prime factor of nums[i]\\n                mp[2].push_back(i);\\n                while(cur % 2 == 0) cur >>= 1;\\n            }\\n            for(int p = 3; p <= sqrt(cur); p += 2)      // now check for all odd numbers if it is factor of nums[i]\\n                if(cur % p == 0) {                      // p is prime factor of nums[i]\\n                    mp[p].push_back(i);\\n                    while(cur % p == 0) cur /= p;\\n                }\\n            \\n            if(cur > 1) mp[cur].push_back(i);           // nums[i] itself is prime\\n        }\\n        \\n        for(auto& [prime, ids] : mp)                    // union all element index that have same prime\\n            for(int i = 0; i < size(ids)-1; i++) \\n                uf.Union(ids[i], ids[i+1]);\\n        \\n        return *max_element(begin(uf.sz), end(uf.sz));  // return largest component\\n    }\\n};\\n```\n```cpp\\nclass UnionFind {\\n    public:\\n    vector<int> par, sz;\\n    UnionFind(int n) : par(n), sz(n,1) {\\n        iota(begin(par), end(par), 0);\\n    }\\n    int find(int x) {\\n        if(par[x] == x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n    bool Union(int x, int y) {\\n        int xp = find(x), yp = find(y);\\n        if(xp == yp) return false;\\n        if(sz[xp] > sz[yp]) par[yp] = par[xp], sz[xp] += sz[yp];\\n        else par[xp] = par[yp], sz[yp] += sz[xp];\\n        return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = size(nums), ans = 1;\\n        UnionFind uf(n + 1);\\n        unordered_map<int, int> mp;                    // stores {p : 1st found index i such that nums[i] % p == 0}\\n        auto putOrUnion = [&](int p, int i){           // puts 1st found index of element that p divides into hashmap\\n            if(mp.count(p)) uf.Union(mp[p], i);        // and if already exists, directly union them\\n            else mp[p] = i;\\n        };\\n        for(int i = 0; i < n; i++) {                   // prime factorize nums[i]\\n            int cur = nums[i];\\n            if(cur % 2 == 0) {                        \\n                putOrUnion(2, i);\\n                while(cur % 2 == 0) cur >>= 1;\\n            }\\n            for(int p = 3; p <= sqrt(cur); p += 2)   \\n                if(cur % p == 0) {                 \\n                    putOrUnion(p, i);\\n                    while(cur % p == 0) cur /= p;\\n                }\\n            if(cur > 1) putOrUnion(cur, i);            // nums[i] itself is prime   \\n        }\\n        return *max_element(begin(uf.sz), end(uf.sz)); // return largest component\\n    }\\n};\\n```\n```cpp\\nclass UnionFind {\\n    public:\\n    vector<int> par, sz;\\n    UnionFind(int n) : par(n), sz(n,1) {\\n        iota(begin(par), end(par), 0);\\n    }\\n    int find(int x) {\\n        if(par[x] == x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n    bool Union(int x, int y) {\\n        int xp = find(x), yp = find(y);\\n        if(xp == yp) return false;\\n        if(sz[xp] > sz[yp]) par[yp] = par[xp], sz[xp] += sz[yp];\\n        else par[xp] = par[yp], sz[yp] += sz[xp];\\n        return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = size(nums), M = *max_element(begin(nums), end(nums)), ans = 1;\\n        auto spf = sieve(M+1);\\n        UnionFind uf(n + 1);\\n        unordered_map<int, vector<int>> mp;           // stores {p : [indices of nums for which p is prime factor]}\\n        for(int i = 0; i < n; i++)                    // prime factorize nums[i]\\n            for(auto p : getPrimes(nums[i], spf))\\n                mp[p].push_back(i);\\n        \\n        for(auto& [prime, ids] : mp)                  // union all element index that have same prime\\n            for(int i = 0; i < size(ids)-1; i++) \\n                uf.Union(ids[i], ids[i+1]);\\n        \\n        return *max_element(begin(uf.sz), end(uf.sz));\\n    }\\n    \\n    vector<int> sieve(int M) {\\n        vector<int> spf(M+1);\\n        iota(begin(spf), end(spf), 0);\\n        for(int i = 2; i*i < M; i++) \\n            if(spf[i] == i) \\n                for(int j = i*i; j < M; j += i)\\n                    if(spf[j] == j)\\n                        spf[j] = i;            \\n        return spf;\\n    }\\n\\n    vector<int> getPrimes(int x, vector<int>& spf) {\\n        vector<int> primes;\\n        while (x != 1) {\\n            int p = spf[x];\\n            primes.push_back(p);\\n            while(x % p == 0) x /= p;\\n        }\\n        return primes;\\n    }\\n};\\n```\n```cpp\\nclass UnionFind {\\n    public:\\n    vector<int> par, sz;\\n    UnionFind(int n) : par(n), sz(n,1) {\\n        iota(begin(par), end(par), 0);\\n    }\\n    int find(int x) {\\n        if(par[x] == x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n    bool Union(int x, int y) {\\n        int xp = find(x), yp = find(y);\\n        if(xp == yp) return false;\\n        if(sz[xp] > sz[yp]) par[yp] = par[xp], sz[xp] += sz[yp];\\n        else par[xp] = par[yp], sz[yp] += sz[xp];\\n        return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = size(nums), ans = 1;\\n        auto spf = sieve(*max_element(begin(nums), end(nums))+1);\\n        UnionFind uf(n + 1);\\n        unordered_map<int, int> mp;                      // stores {p : 1st found index i such that nums[i] % p == 0}\\n        for(int i = 0; i < n; i++)                       // prime factorize nums[i]\\n            for(auto p : getPrimes(nums[i], spf))\\n                if(mp.count(p)) uf.Union(i, mp[p]);\\n                else mp[p] = i;\\n        \\n        return *max_element(begin(uf.sz), end(uf.sz));\\n    }\\n    \\n    vector<int> sieve(int M) {\\n        vector<int> spf(M+1);\\n        iota(begin(spf), end(spf), 0);\\n        for(int i = 2; i*i < M; i++) \\n            if(spf[i] == i) \\n                for(int j = i*i; j < M; j += i)\\n                    if(spf[j] == j)\\n                        spf[j] = i;            \\n        return spf;\\n    }\\n\\n    vector<int> getPrimes(int x, vector<int>& spf) {\\n        vector<int> primes;\\n        while (x != 1) {\\n            int p = spf[x];\\n            primes.push_back(p);\\n            while(x % p == 0) x /= p;\\n        }\\n        return primes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200959,
                "title": "simplest-solution-union-find-only-no-prime-calculation",
                "content": "Union Find template. The only additional stuff is one hashmap which is used to convert factor to the node index in A for union. \\nHashMap: key is the factor, val is the index in A\\nTime complexity: O(N*sqrt(Max val of A[i]))\\n```\\nclass Solution {\\n    class UF {\\n        int[] parent;\\n        int[] size;\\n        int max;\\n        public UF (int N){\\n            parent = new int[N];\\n            size = new int[N];\\n            max = 1;\\n            for (int i = 0; i < N; i++){\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        public int find(int x){\\n            if (x == parent[x]){\\n                return x;\\n            }\\n            return parent[x] = find(parent[x]);\\n        }\\n        public void union(int x, int y){\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX != rootY){\\n                parent[rootX] = rootY;\\n                size[rootY] += size[rootX];\\n                max = Math.max(max, size[rootY]);\\n            }\\n        }\\n    }\\n    public int largestComponentSize(int[] A) {\\n        int N = A.length;\\n        Map<Integer, Integer> map = new HashMap<>();// key is the factor, val is the node index\\n        UF uf = new UF(N);\\n        for (int i = 0; i < N; i++){\\n            int a = A[i];\\n            for (int j = 2; j * j <= a; j++){\\n                if (a % j == 0){\\n                    if (!map.containsKey(j)){//this means that no index has claimed the factor yet\\n                        map.put(j, i);\\n                    }else{//this means that one index already claimed, so union that one with current\\n                        uf.union(i, map.get(j));\\n                    }\\n                    if (!map.containsKey(a/j)){\\n                        map.put(a/j, i);\\n                    }else{\\n                        uf.union(i, map.get(a/j));\\n                    }\\n                }\\n            }\\n            if (!map.containsKey(a)){//a could be factor too. Don\\'t miss this\\n                map.put(a, i);\\n            }else{\\n                uf.union(i, map.get(a));\\n            }\\n        }\\n        return uf.max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class UF {\\n        int[] parent;\\n        int[] size;\\n        int max;\\n        public UF (int N){\\n            parent = new int[N];\\n            size = new int[N];\\n            max = 1;\\n            for (int i = 0; i < N; i++){\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        public int find(int x){\\n            if (x == parent[x]){\\n                return x;\\n            }\\n            return parent[x] = find(parent[x]);\\n        }\\n        public void union(int x, int y){\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX != rootY){\\n                parent[rootX] = rootY;\\n                size[rootY] += size[rootX];\\n                max = Math.max(max, size[rootY]);\\n            }\\n        }\\n    }\\n    public int largestComponentSize(int[] A) {\\n        int N = A.length;\\n        Map<Integer, Integer> map = new HashMap<>();// key is the factor, val is the node index\\n        UF uf = new UF(N);\\n        for (int i = 0; i < N; i++){\\n            int a = A[i];\\n            for (int j = 2; j * j <= a; j++){\\n                if (a % j == 0){\\n                    if (!map.containsKey(j)){//this means that no index has claimed the factor yet\\n                        map.put(j, i);\\n                    }else{//this means that one index already claimed, so union that one with current\\n                        uf.union(i, map.get(j));\\n                    }\\n                    if (!map.containsKey(a/j)){\\n                        map.put(a/j, i);\\n                    }else{\\n                        uf.union(i, map.get(a/j));\\n                    }\\n                }\\n            }\\n            if (!map.containsKey(a)){//a could be factor too. Don\\'t miss this\\n                map.put(a, i);\\n            }else{\\n                uf.union(i, map.get(a));\\n            }\\n        }\\n        return uf.max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201046,
                "title": "c-232ms-union-find-solution",
                "content": "[reference](https://www.youtube.com/watch?v=GTX0kw63Tn0)\\n### Intuition\\n\\n(1) Union each number with all its factor;\\n(2) Count the most frequent parent.\\n\\n```\\n// W: the largest number\\n// Time Complexity: O(n*sqrt(W))\\n// Space Complexity: O(W)\\n\\nclass UnionFindSet {\\npublic:\\n    UnionFindSet(int n) : _parent(n) {\\n        for (int i=0; i<n; i++) {\\n            _parent[i] = i;\\n        }\\n    }\\n    \\n    void Union(int x, int y) {\\n        _parent[Find(x)] = _parent[Find(y)];\\n    }\\n    \\n    int Find(int x) {\\n        if (_parent[x] != x) {\\n            _parent[x] = Find(_parent[x]);\\n        }\\n        return _parent[x];\\n    }\\n    \\nprivate:\\n    vector<int> _parent;\\n};\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& A) {\\n        int n = *max_element(A.begin(), A.end());\\n        UnionFindSet ufs(n+1);\\n        for (int &a : A) {\\n            for (int k = 2; k <= sqrt(a); k++) {\\n                if (a % k == 0) {\\n                    ufs.Union(a, k);\\n                    ufs.Union(a, a / k);\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int, int> mp;\\n        int ans = 1;\\n        for (int &a : A) {\\n            ans = max(ans, ++mp[ufs.Find(a)]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// W: the largest number\\n// Time Complexity: O(n*sqrt(W))\\n// Space Complexity: O(W)\\n\\nclass UnionFindSet {\\npublic:\\n    UnionFindSet(int n) : _parent(n) {\\n        for (int i=0; i<n; i++) {\\n            _parent[i] = i;\\n        }\\n    }\\n    \\n    void Union(int x, int y) {\\n        _parent[Find(x)] = _parent[Find(y)];\\n    }\\n    \\n    int Find(int x) {\\n        if (_parent[x] != x) {\\n            _parent[x] = Find(_parent[x]);\\n        }\\n        return _parent[x];\\n    }\\n    \\nprivate:\\n    vector<int> _parent;\\n};\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& A) {\\n        int n = *max_element(A.begin(), A.end());\\n        UnionFindSet ufs(n+1);\\n        for (int &a : A) {\\n            for (int k = 2; k <= sqrt(a); k++) {\\n                if (a % k == 0) {\\n                    ufs.Union(a, k);\\n                    ufs.Union(a, a / k);\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int, int> mp;\\n        int ans = 1;\\n        for (int &a : A) {\\n            ans = max(ans, ++mp[ufs.Find(a)]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200546,
                "title": "prime-factorization-and-union-find",
                "content": "1. Calculate all prime numbers less than `100000`.\\n2. For each number in `A`, we say `A[i]`\\n\\ta. Do Prime Factorization(Brute force using the primes set in step 1), we say the prime factor is `p`.\\n\\tb. If `p` has presented in the `primeToIndex`, union `i` and `primeToIndex[p]`.\\n\\tc. Update `primeToIndex[p]` to `i`.\\n3. Return the maximum count.\\n\\nTime complexity: `O(NP)`, where `P` is the count of prime numbers < `100000`. I think this is an upperbound time complexity.\\n```\\nclass Solution {\\n    int max = 0;\\n    public int largestComponentSize(int[] A) {\\n        boolean[] isPrime = new boolean[100001];\\n        Arrays.fill(isPrime, true);\\n        Set<Integer> primes = new HashSet<>();\\n        // all primes less than 100000\\n        for (int i = 2; i <= 100000; i++) {\\n            if (isPrime[i]) {\\n                primes.add(i);\\n                for (int j = 2; j * i <= 100000; j++) {\\n                    isPrime[j * i] = false;\\n                }\\n            }\\n        }\\n        int n = A.length;\\n        int[] counts = new int[n];\\n        int[] parents = new int[n];\\n        int[] primeToIndex = new int[100001];\\n        Arrays.fill(primeToIndex, -1);\\n        for (int i = 0; i < n; i++) {\\n            parents[i] = i;\\n            counts[i] = 1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int a = A[i];\\n            for (int p : primes) {\\n                if (primes.contains(a)) { // Optimization\\n                    p = a;\\n                }\\n                if (a % p == 0) {\\n                    if (primeToIndex[p] > -1) {\\n                        union(parents, counts, primeToIndex[p], i);\\n                    }\\n                    primeToIndex[p] = i;\\n                    while (a % p == 0) {\\n                        a /= p;\\n                    }\\n                }\\n                if (a == 1) {\\n                    break;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    private int find(int[] parents, int a) {\\n        if (parents[a] != a) {\\n            parents[a] = find(parents, parents[a]);\\n        }\\n        return parents[a];\\n    }\\n    private void union(int[] parents, int[] counts, int a, int b) {\\n        int root1 = find(parents, a), root2 = find(parents, b);\\n        if (root1 == root2) {\\n            return;\\n        }\\n        int count = counts[root2] + counts[root1];\\n        max = Math.max(count, max);\\n        parents[root1] = root2;\\n        counts[root2] = count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max = 0;\\n    public int largestComponentSize(int[] A) {\\n        boolean[] isPrime = new boolean[100001];\\n        Arrays.fill(isPrime, true);\\n        Set<Integer> primes = new HashSet<>();\\n        // all primes less than 100000\\n        for (int i = 2; i <= 100000; i++) {\\n            if (isPrime[i]) {\\n                primes.add(i);\\n                for (int j = 2; j * i <= 100000; j++) {\\n                    isPrime[j * i] = false;\\n                }\\n            }\\n        }\\n        int n = A.length;\\n        int[] counts = new int[n];\\n        int[] parents = new int[n];\\n        int[] primeToIndex = new int[100001];\\n        Arrays.fill(primeToIndex, -1);\\n        for (int i = 0; i < n; i++) {\\n            parents[i] = i;\\n            counts[i] = 1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int a = A[i];\\n            for (int p : primes) {\\n                if (primes.contains(a)) { // Optimization\\n                    p = a;\\n                }\\n                if (a % p == 0) {\\n                    if (primeToIndex[p] > -1) {\\n                        union(parents, counts, primeToIndex[p], i);\\n                    }\\n                    primeToIndex[p] = i;\\n                    while (a % p == 0) {\\n                        a /= p;\\n                    }\\n                }\\n                if (a == 1) {\\n                    break;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    private int find(int[] parents, int a) {\\n        if (parents[a] != a) {\\n            parents[a] = find(parents, parents[a]);\\n        }\\n        return parents[a];\\n    }\\n    private void union(int[] parents, int[] counts, int a, int b) {\\n        int root1 = find(parents, a), root2 = find(parents, b);\\n        if (root1 == root2) {\\n            return;\\n        }\\n        int count = counts[root2] + counts[root1];\\n        max = Math.max(count, max);\\n        parents[root1] = root2;\\n        counts[root2] = count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200643,
                "title": "python-1112-ms-beats-100-union-find-and-prime-factor-decomposition-with-optimization",
                "content": "Using the input of first example,We can firstly do Prime factor decomposition for each number in A, then we can get the map:```{2: [4, 6], 3: [6, 15], 5: [15, 35], 7: [35]})```, in which values are all multiples of the key(```must be prime```). Then we can regard the first multiple as the root of all the multiples, connect each multiple with the root. In this example, we connect 6 with 4(```root```), connect 15 with 6(```root```), connect 35 with 15(```root```), because there is only one multiple in ```7: [35]```, so no connection. At the end, we can get the largest size 4, which is the result. The root of all the numbers in A is the number ```4```.\\n```\\nclass UnionFind(object):\\n    def uf(self, n):  \\n        self.uf = [i for i in range(n)]\\n        self.size = [1] * n\\n        \\n    def find(self, x):  \\n        while x != self.uf[x]:\\n            self.uf[x] = self.uf[self.uf[x]]\\n            x = self.uf[x]\\n        return self.uf[x]\\n\\n    def union(self, x, y):  \\n        x_root = self.find(x)\\n        y_root = self.find(y)\\n        if x_root == y_root:\\n            return\\n        self.uf[x_root] = y_root\\n        self.size[y_root] += self.size[x_root]\\n        self.size[x_root] = 0\\n\\n\\nclass Solution(object):\\n    def largestComponentSize(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def primeFactors(n):  # Prime factor decomposition\\n            out = set()\\n            while n % 2 == 0: \\n                out.add(2)\\n                n //= 2\\n            for i in range(3, int(math.sqrt(n))+1, 2): \\n                while n % i== 0: \\n                    out.add(i) \\n                    n //= i \\n            if n > 2: \\n                out.add(n)\\n            return out\\n        \\n        idx_lookup = {A[i]: i for i in range(len(A))} # in order to find idx in uf\\n        uf = UnionFind()\\n        uf.uf(len(A))\\n        primeAndItsMultiples = collections.defaultdict(list) # {2: [4, 6], 3: [6, 15], 5: [15, 35], 7: [35]})\\n        \\n        for i in A:\\n            factors = primeFactors(i)\\n            for f in factors:\\n                primeAndItsMultiples[f].append(i)\\n\\n        # we don\\'t need to connect all the multiples of a prime, \\n        # just use the first multiple as their root\\n        for idx, multiples in primeAndItsMultiples.items():\\n            if multiples:\\n                root = multiples[0] # use the first multiple as their root\\n                for node in multiples[1:]:\\n                    uf.union(idx_lookup[node], idx_lookup[root]) # connect node with root\\n                    \\n        return max(uf.size)\\n```\\n\\nInspired by `yanx1` in the comment below,  `idx_lookup` and `primeAndItsMultiples` are kind of unnecessary... all we need is a dict primeToIndex that record the index of the element in A who has p as a prime factor.\\n\\nThis allows the runtime to be reduced to `1112 ms`\\n\\n\\n\\n```python\\nclass UnionFind(object):\\n    def uf(self, n):  \\n        self.uf = [i for i in range(n)]\\n        self.size = [1] * n\\n        \\n    def find(self, x):  \\n        while x != self.uf[x]:\\n            self.uf[x] = self.uf[self.uf[x]]\\n            x = self.uf[x]\\n        return self.uf[x]\\n\\n    def union(self, x, y):  \\n        x_root = self.find(x)\\n        y_root = self.find(y)\\n        if x_root == y_root:\\n            return\\n        self.uf[x_root] = y_root\\n        self.size[y_root] += self.size[x_root]\\n        self.size[x_root] = 0\\n\\n\\nclass Solution(object):\\n    def largestComponentSize(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def primeFactors(n):  # Prime factor decomposition\\n            out = set()\\n            while n % 2 == 0: \\n                out.add(2)\\n                n //= 2\\n            for i in range(3, int(math.sqrt(n))+1, 2): \\n                while n % i== 0: \\n                    out.add(i) \\n                    n //= i \\n            if n > 2: \\n                out.add(n)\\n            return out\\n        \\n        uf = UnionFind()\\n        uf.uf(len(A))\\n        \\n        primeToIndex = {} \\n        for i,a in enumerate(A):\\n            primes = primeFactors(a)\\n            for p in primes:\\n                if p in primeToIndex:\\n                    uf.union(i, primeToIndex[p])\\n                primeToIndex[p] = i\\n        return max(uf.size)\\n```\\nYou can also check the solution [here](https://github.com/apachecn/awesome-algorithm/blob/master/docs/Leetcode_Solutions/Python/952._Largest_Component_Size_by_Common_Factor.md).",
                "solutionTags": [],
                "code": "```{2: [4, 6], 3: [6, 15], 5: [15, 35], 7: [35]})```\n```must be prime```\n```root```\n```root```\n```root```\n```7: [35]```\n```4```\n```\\nclass UnionFind(object):\\n    def uf(self, n):  \\n        self.uf = [i for i in range(n)]\\n        self.size = [1] * n\\n        \\n    def find(self, x):  \\n        while x != self.uf[x]:\\n            self.uf[x] = self.uf[self.uf[x]]\\n            x = self.uf[x]\\n        return self.uf[x]\\n\\n    def union(self, x, y):  \\n        x_root = self.find(x)\\n        y_root = self.find(y)\\n        if x_root == y_root:\\n            return\\n        self.uf[x_root] = y_root\\n        self.size[y_root] += self.size[x_root]\\n        self.size[x_root] = 0\\n\\n\\nclass Solution(object):\\n    def largestComponentSize(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def primeFactors(n):  # Prime factor decomposition\\n            out = set()\\n            while n % 2 == 0: \\n                out.add(2)\\n                n //= 2\\n            for i in range(3, int(math.sqrt(n))+1, 2): \\n                while n % i== 0: \\n                    out.add(i) \\n                    n //= i \\n            if n > 2: \\n                out.add(n)\\n            return out\\n        \\n        idx_lookup = {A[i]: i for i in range(len(A))} # in order to find idx in uf\\n        uf = UnionFind()\\n        uf.uf(len(A))\\n        primeAndItsMultiples = collections.defaultdict(list) # {2: [4, 6], 3: [6, 15], 5: [15, 35], 7: [35]})\\n        \\n        for i in A:\\n            factors = primeFactors(i)\\n            for f in factors:\\n                primeAndItsMultiples[f].append(i)\\n\\n        # we don\\'t need to connect all the multiples of a prime, \\n        # just use the first multiple as their root\\n        for idx, multiples in primeAndItsMultiples.items():\\n            if multiples:\\n                root = multiples[0] # use the first multiple as their root\\n                for node in multiples[1:]:\\n                    uf.union(idx_lookup[node], idx_lookup[root]) # connect node with root\\n                    \\n        return max(uf.size)\\n```\n```python\\nclass UnionFind(object):\\n    def uf(self, n):  \\n        self.uf = [i for i in range(n)]\\n        self.size = [1] * n\\n        \\n    def find(self, x):  \\n        while x != self.uf[x]:\\n            self.uf[x] = self.uf[self.uf[x]]\\n            x = self.uf[x]\\n        return self.uf[x]\\n\\n    def union(self, x, y):  \\n        x_root = self.find(x)\\n        y_root = self.find(y)\\n        if x_root == y_root:\\n            return\\n        self.uf[x_root] = y_root\\n        self.size[y_root] += self.size[x_root]\\n        self.size[x_root] = 0\\n\\n\\nclass Solution(object):\\n    def largestComponentSize(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def primeFactors(n):  # Prime factor decomposition\\n            out = set()\\n            while n % 2 == 0: \\n                out.add(2)\\n                n //= 2\\n            for i in range(3, int(math.sqrt(n))+1, 2): \\n                while n % i== 0: \\n                    out.add(i) \\n                    n //= i \\n            if n > 2: \\n                out.add(n)\\n            return out\\n        \\n        uf = UnionFind()\\n        uf.uf(len(A))\\n        \\n        primeToIndex = {} \\n        for i,a in enumerate(A):\\n            primes = primeFactors(a)\\n            for p in primes:\\n                if p in primeToIndex:\\n                    uf.union(i, primeToIndex[p])\\n                primeToIndex[p] = i\\n        return max(uf.size)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592584,
                "title": "c-brute-to-optimal-solution",
                "content": "## Method 1\\n\\nFrom question it can be clearly observed that two numbers have an edge if their gcd is >1. Using this we can try to construct the graph and then perform dfs/bfs to find largest connected component.\\n\\n### Code\\n```\\nclass Solution {\\n    \\n    void recur(int node,unordered_map<int,vector<int>> &mp,unordered_map<int,bool> &vis)\\n    {\\n        vis[node] = 1;\\n        // int cnt = 0;\\n        for(auto &val : mp[node])\\n        {\\n            if(vis.find(val) == vis.end())\\n            {\\n                recur(val,mp,vis);\\n            }\\n        }\\n    }\\n    \\n    int dfs(unordered_map<int,vector<int>> &mp)\\n    {\\n        int res = 0,prev = 0;\\n        unordered_map<int,bool> vis;\\n        for(auto &[key,value] : mp)\\n        {\\n            if(vis.find(key) == vis.end())\\n            {\\n                recur(key,mp,vis);\\n            }\\n            \\n            int len = vis.size() - prev;\\n            res = max(len,res);\\n            prev = vis.size();\\n        }\\n        \\n        return res;\\n    }\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(__gcd(nums[i] , nums[j]) > 1)\\n                {\\n                    mp[nums[i]].push_back(nums[j]);\\n                    mp[nums[j]].push_back(nums[i]);\\n                }\\n            }\\n        }\\n        \\n        return dfs(mp);\\n    }\\n};\\n```\\n\\n**Time Complexity :**  O(n^2 * logn)\\n**Space Complexity :** O(n) [for map]\\n\\n## Method 2\\n\\nSince we only need connected components so instead of creating the whole graph , we can use something called Disjoint Set Union.\\n\\n### Code\\n\\n```\\nclass Solution {\\n    map<int,int> rank;\\n    map<int,int> par;\\n    \\n    void init(vector<int> &nums)\\n    {\\n        for(auto &val : nums) rank[val] = 1 , par[val] = val;\\n    }\\n    \\n    int findPar(int u)\\n    {\\n        if(par[u] == u) return u;\\n        \\n        return par[u] = findPar(par[u]);\\n    }\\n    \\n    void unn(int u,int v)\\n    {\\n        int x = findPar(u) , y = findPar(v);\\n        if(rank[x] > rank[y]) par[y] = x;\\n        else if(rank[x] < rank[y]) par[x] = y;\\n        else par[x] = y , rank[y]++;\\n    }\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        init(nums);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(__gcd(nums[i],nums[j]) > 1)\\n                {\\n                    unn(nums[i],nums[j]);\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int,int> mp;\\n        for(auto &val : nums) mp[findPar(val)]++;\\n        \\n        int res = 0, len = 0;\\n        \\n        for(auto &[key,value] : mp)\\n        {\\n            if(value > len) len = value;\\n        }\\n        \\n        return len;\\n        \\n    }\\n};\\n```\\n\\n**Time Complexity :** O(n^2)\\n**Space Complexity :** O(n) [for rank and par map]\\n\\n## Method 3 (Optimal)\\n\\nWe know that elements having same factors can be put in one set. So we\\'ll calculate factors of every element in nums and then put elements with same factor in same set.\\n\\n```\\nclass Solution {\\n    void init(vector<int> &par)\\n    {\\n        for(int i=0;i<=100001;i++)\\n            par.push_back(i);\\n    }\\n    \\n    int findPar(int u,vector<int> &par)\\n    {\\n        if(par[u] == u) return u;\\n        \\n        return par[u] = findPar(par[u],par);\\n    }\\n    \\n    void unn(int u,int v,vector<int> &par)\\n    {\\n        int x = findPar(u,par) , y = findPar(v,par);\\n        if(x != y) par[x] = y;\\n    }\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        vector<int> par;\\n        init(par);\\n        \\n        for(auto &val : nums)\\n        {\\n            for(int k=2;k<=sqrt(val);k++)\\n            {\\n                if(val%k == 0)\\n                {\\n                    unn(val,k,par);\\n                    unn(val,val/k,par);\\n                }\\n            }\\n        }\\n        \\n        int cnt = 0;\\n        unordered_map<int,int> mp;\\n        \\n        for(auto &val : nums)\\n        {\\n            int x = findPar(val,par);\\n            mp[x]++;\\n            cnt = max(cnt,mp[x]);\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```\\n\\n**Time Complexity :** O(n * sqrt(max element in nums))\\n**Space Complexity :** O(n) [for parent array]\\n",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    \\n    void recur(int node,unordered_map<int,vector<int>> &mp,unordered_map<int,bool> &vis)\\n    {\\n        vis[node] = 1;\\n        // int cnt = 0;\\n        for(auto &val : mp[node])\\n        {\\n            if(vis.find(val) == vis.end())\\n            {\\n                recur(val,mp,vis);\\n            }\\n        }\\n    }\\n    \\n    int dfs(unordered_map<int,vector<int>> &mp)\\n    {\\n        int res = 0,prev = 0;\\n        unordered_map<int,bool> vis;\\n        for(auto &[key,value] : mp)\\n        {\\n            if(vis.find(key) == vis.end())\\n            {\\n                recur(key,mp,vis);\\n            }\\n            \\n            int len = vis.size() - prev;\\n            res = max(len,res);\\n            prev = vis.size();\\n        }\\n        \\n        return res;\\n    }\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(__gcd(nums[i] , nums[j]) > 1)\\n                {\\n                    mp[nums[i]].push_back(nums[j]);\\n                    mp[nums[j]].push_back(nums[i]);\\n                }\\n            }\\n        }\\n        \\n        return dfs(mp);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    map<int,int> rank;\\n    map<int,int> par;\\n    \\n    void init(vector<int> &nums)\\n    {\\n        for(auto &val : nums) rank[val] = 1 , par[val] = val;\\n    }\\n    \\n    int findPar(int u)\\n    {\\n        if(par[u] == u) return u;\\n        \\n        return par[u] = findPar(par[u]);\\n    }\\n    \\n    void unn(int u,int v)\\n    {\\n        int x = findPar(u) , y = findPar(v);\\n        if(rank[x] > rank[y]) par[y] = x;\\n        else if(rank[x] < rank[y]) par[x] = y;\\n        else par[x] = y , rank[y]++;\\n    }\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        init(nums);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(__gcd(nums[i],nums[j]) > 1)\\n                {\\n                    unn(nums[i],nums[j]);\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int,int> mp;\\n        for(auto &val : nums) mp[findPar(val)]++;\\n        \\n        int res = 0, len = 0;\\n        \\n        for(auto &[key,value] : mp)\\n        {\\n            if(value > len) len = value;\\n        }\\n        \\n        return len;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n    void init(vector<int> &par)\\n    {\\n        for(int i=0;i<=100001;i++)\\n            par.push_back(i);\\n    }\\n    \\n    int findPar(int u,vector<int> &par)\\n    {\\n        if(par[u] == u) return u;\\n        \\n        return par[u] = findPar(par[u],par);\\n    }\\n    \\n    void unn(int u,int v,vector<int> &par)\\n    {\\n        int x = findPar(u,par) , y = findPar(v,par);\\n        if(x != y) par[x] = y;\\n    }\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        vector<int> par;\\n        init(par);\\n        \\n        for(auto &val : nums)\\n        {\\n            for(int k=2;k<=sqrt(val);k++)\\n            {\\n                if(val%k == 0)\\n                {\\n                    unn(val,k,par);\\n                    unn(val,val/k,par);\\n                }\\n            }\\n        }\\n        \\n        int cnt = 0;\\n        unordered_map<int,int> mp;\\n        \\n        for(auto &val : nums)\\n        {\\n            int x = findPar(val,par);\\n            mp[x]++;\\n            cnt = max(cnt,mp[x]);\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200712,
                "title": "fast-than-100-concise-java-solution",
                "content": "step 1. foreach element make it as distinct min prime factor save it to a map\\n(key is prime factor, value is element index set).\\neg. {10, 30, 18}->{2: {0,1,2}, 3 {1,2}, 5: {0,1}}\\n\\nstep 2. foreach set do union and find max cnt\\n\\n```\\n    int[] par;\\n    int[] cnt;\\n    private int find(int i) {\\n        if (i == par[i]) return i;\\n        return par[i] = find(par[i]);\\n    }\\n    private void union(int i, int j) {\\n        int pi = find(i);\\n        int pj = find(j);\\n        if (pi == pj) return ;\\n        par[pi] = pj;\\n        cnt[pj] += cnt[pi];\\n    }\\n    public int largestComponentSize(int[] A) {\\n        int N = A.length;\\n        par = new int[N];\\n        cnt = new int[N];\\n        Map<Integer, Set<Integer>> prime2Idx = new HashMap<>();\\n        for (int i = 0; i < N; i++) {\\n            int d = 2, x = A[i];\\n            while (d * d <= x) {\\n                if (x % d == 0) {\\n                    while (x % d == 0) x /= d;\\n                    prime2Idx.putIfAbsent(d, new HashSet<>());\\n                    prime2Idx.get(d).add(i);\\n                }\\n                d++;\\n            }\\n            if (x > 1) {\\n                prime2Idx.putIfAbsent(x, new HashSet<>());\\n                prime2Idx.get(x).add(i);\\n            }\\n        }\\n        for (int i = 0; i < N; i++) par[i] = i;\\n        Arrays.fill(cnt, 1);\\n        int max = 1;\\n        for (Set<Integer> s : prime2Idx.values()) {\\n            int fir = s.iterator().next();\\n            for (int idx : s) {\\n                union(idx, fir);\\n                max = Math.max(cnt[find(idx)],max);\\n            }\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int[] par;\\n    int[] cnt;\\n    private int find(int i) {\\n        if (i == par[i]) return i;\\n        return par[i] = find(par[i]);\\n    }\\n    private void union(int i, int j) {\\n        int pi = find(i);\\n        int pj = find(j);\\n        if (pi == pj) return ;\\n        par[pi] = pj;\\n        cnt[pj] += cnt[pi];\\n    }\\n    public int largestComponentSize(int[] A) {\\n        int N = A.length;\\n        par = new int[N];\\n        cnt = new int[N];\\n        Map<Integer, Set<Integer>> prime2Idx = new HashMap<>();\\n        for (int i = 0; i < N; i++) {\\n            int d = 2, x = A[i];\\n            while (d * d <= x) {\\n                if (x % d == 0) {\\n                    while (x % d == 0) x /= d;\\n                    prime2Idx.putIfAbsent(d, new HashSet<>());\\n                    prime2Idx.get(d).add(i);\\n                }\\n                d++;\\n            }\\n            if (x > 1) {\\n                prime2Idx.putIfAbsent(x, new HashSet<>());\\n                prime2Idx.get(x).add(i);\\n            }\\n        }\\n        for (int i = 0; i < N; i++) par[i] = i;\\n        Arrays.fill(cnt, 1);\\n        int max = 1;\\n        for (Set<Integer> s : prime2Idx.values()) {\\n            int fir = s.iterator().next();\\n            for (int idx : s) {\\n                union(idx, fir);\\n                max = Math.max(cnt[find(idx)],max);\\n            }\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 788988,
                "title": "c-simple-compact-union-find-97-space-and-time",
                "content": "Time Complexity is **O(N * sqrt(max(arr[i]))**.\\nThe idea is that for every number we find and link all of its  factors to a unique parent number. Then simply count the numbers which has the given parent and output the maximum such frequency.\\n```\\nint parent[100001];\\nint find (int x)\\n{\\n    if(parent[x]==-1)\\n        return x;\\n    else return parent[x]=find(parent[x]);\\n}\\nbool uni(int x,int y)\\n{\\n    int xp=find(x);\\n    int yp=find(y);\\n    if(xp!=yp)\\n        parent[yp]=xp;\\n    else return false;\\n    return true;\\n}\\nint largestComponentSize(vector<int>& arr) \\n{\\n    unordered_map<int,int> memo;\\n    memset(parent,-1,sizeof(parent));\\n    int ret=0;\\n    for(int x:arr)\\n    {\\n       int flag=0;\\n        for(int i=2;i*i<=x;++i)\\n            if(x%i==0)\\n            {\\n                uni(i,x);\\n                uni(x,x/i);\\n                flag=1;\\n            }\\n    }\\n    for(int x:arr)\\n        ret=max(ret,++memo[find(x)]);\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nint parent[100001];\\nint find (int x)\\n{\\n    if(parent[x]==-1)\\n        return x;\\n    else return parent[x]=find(parent[x]);\\n}\\nbool uni(int x,int y)\\n{\\n    int xp=find(x);\\n    int yp=find(y);\\n    if(xp!=yp)\\n        parent[yp]=xp;\\n    else return false;\\n    return true;\\n}\\nint largestComponentSize(vector<int>& arr) \\n{\\n    unordered_map<int,int> memo;\\n    memset(parent,-1,sizeof(parent));\\n    int ret=0;\\n    for(int x:arr)\\n    {\\n       int flag=0;\\n        for(int i=2;i*i<=x;++i)\\n            if(x%i==0)\\n            {\\n                uni(i,x);\\n                uni(x,x/i);\\n                flag=1;\\n            }\\n    }\\n    for(int x:arr)\\n        ret=max(ret,++memo[find(x)]);\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 349437,
                "title": "java-simple-o-n-sqrt-w-union-find-solution",
                "content": "We maintain a union set where several elements are connected if and only if they have any common factor greater than 1.\\nWe only have to connect each element in *A* with all its factors greater than 1, according to the nature of union set. We can do this by simply checking all the integers ranging from 2 to sqrt(A[i]).\\n```\\nclass Solution {\\n    \\n    int[] p;\\n    \\n    int get(int x){\\n        return p[x]==x ? x : (p[x]=get(p[x])) ;\\n    }\\n    \\n    void add(int x, int y){\\n        p[get(x)]=p[get(y)];\\n    }\\n    \\n    public int largestComponentSize(int[] A) {\\n        int mx=0;\\n        for(int i:A) mx=Math.max(i, mx);\\n        p=new int[mx+1];\\n        for(int i=1;i<=mx;++i) p[i]=i;\\n        for(int i:A)\\n            for(int j=(int)Math.sqrt(i);j>=2;--j)\\n                if(i%j==0){\\n                    add(i, j);\\n                    add(i, i/j);\\n                }\\n        Map<Integer, Integer> map=new HashMap<Integer, Integer>();\\n        int res=0;\\n        for(int i:A){\\n            int j=get(i);\\n            if(!map.containsKey(j)) map.put(j, 1);\\n            else map.put(j, map.get(j)+1);\\n            res=Math.max(res, map.get(j));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int[] p;\\n    \\n    int get(int x){\\n        return p[x]==x ? x : (p[x]=get(p[x])) ;\\n    }\\n    \\n    void add(int x, int y){\\n        p[get(x)]=p[get(y)];\\n    }\\n    \\n    public int largestComponentSize(int[] A) {\\n        int mx=0;\\n        for(int i:A) mx=Math.max(i, mx);\\n        p=new int[mx+1];\\n        for(int i=1;i<=mx;++i) p[i]=i;\\n        for(int i:A)\\n            for(int j=(int)Math.sqrt(i);j>=2;--j)\\n                if(i%j==0){\\n                    add(i, j);\\n                    add(i, i/j);\\n                }\\n        Map<Integer, Integer> map=new HashMap<Integer, Integer>();\\n        int res=0;\\n        for(int i:A){\\n            int j=get(i);\\n            if(!map.containsKey(j)) map.put(j, 1);\\n            else map.put(j, map.get(j)+1);\\n            res=Math.max(res, map.get(j));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 581394,
                "title": "python-1032ms-beat-100-time-space",
                "content": "**Step 1: get primes less than sqrt(max(A))\\nStep 2: compute factors for each number in A\\nStep 3: use union-find to link two primes if they are factors of the same number in A\\nStep 4: for each number in A, add to its union (the union represented by its smallest prime)**\\n```\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        primes = []\\n        for x in range(2, int(max(A)**0.5)+1):\\n            for y in primes:\\n                if x % y == 0:\\n                    break\\n            else:\\n                primes.append(x)\\n    \\n        factors = collections.defaultdict(list)         # compute factors of each \\'a\\'\\n        for a in A:\\n            x = a\\n            for p in primes:\\n                if p*p > x:\\n                    break\\n                if x % p == 0:\\n                    factors[a].append(p)\\n                    while x % p == 0:\\n                        x //= p\\n            if x > 1:                                   # a new prime found\\n                factors[a].append(x)\\n                primes.append(x)\\n                \\n        primes = list(set(primes))\\n        n = len(primes)\\n        p2i = {p: i for i,p in enumerate(primes)}       # prime to index\\n        \\n        parent = [i for i in range(n)]                  # union-find on primes\\n        \\n        def find(i):\\n            if i != parent[i]:\\n                parent[i] = find(parent[i])\\n            return parent[i]\\n        \\n        def union(i,j):\\n            pi, pj = find(i), find(j)\\n            if pi != pj:\\n                parent[pi] = pj\\n\\n        for a in A:\\n            if factors[a]:\\n                p0 = factors[a][0]\\n                for p in factors[a][1:]:                # link two primes if they are factors of \\'a\\'\\n                    union(p2i[p0], p2i[p])\\n        \\n        count = collections.Counter(find(p2i[factors[a][0]]) for a in A if factors[a])      # each \\'a\\' corresponds to a prime index\\n        return max(count.values())\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        primes = []\\n        for x in range(2, int(max(A)**0.5)+1):\\n            for y in primes:\\n                if x % y == 0:\\n                    break\\n            else:\\n                primes.append(x)\\n    \\n        factors = collections.defaultdict(list)         # compute factors of each \\'a\\'\\n        for a in A:\\n            x = a\\n            for p in primes:\\n                if p*p > x:\\n                    break\\n                if x % p == 0:\\n                    factors[a].append(p)\\n                    while x % p == 0:\\n                        x //= p\\n            if x > 1:                                   # a new prime found\\n                factors[a].append(x)\\n                primes.append(x)\\n                \\n        primes = list(set(primes))\\n        n = len(primes)\\n        p2i = {p: i for i,p in enumerate(primes)}       # prime to index\\n        \\n        parent = [i for i in range(n)]                  # union-find on primes\\n        \\n        def find(i):\\n            if i != parent[i]:\\n                parent[i] = find(parent[i])\\n            return parent[i]\\n        \\n        def union(i,j):\\n            pi, pj = find(i), find(j)\\n            if pi != pj:\\n                parent[pi] = pj\\n\\n        for a in A:\\n            if factors[a]:\\n                p0 = factors[a][0]\\n                for p in factors[a][1:]:                # link two primes if they are factors of \\'a\\'\\n                    union(p2i[p0], p2i[p])\\n        \\n        count = collections.Counter(find(p2i[factors[a][0]]) for a in A if factors[a])      # each \\'a\\' corresponds to a prime index\\n        return max(count.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592323,
                "title": "c-disjoint-set-union-find-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    vector<int> rank;\\n    \\n    int find(int x){\\n        if(parent[x]==x) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    void unionDsu(int x, int y){\\n        int _x = find(x), _y = find(y);\\n        if(_x == _y) return;\\n        if (rank[_x] < rank[_y]){\\n            parent[_x] = _y;\\n        }else if(rank[_x] > rank[_y]){\\n            parent[_y] = _x;\\n        }else{\\n            parent[_y] = _x;\\n            rank[_x]+=1;\\n        }\\n    }\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int size = *max_element(nums.begin(), nums.end());\\n        parent.resize(size+1);\\n        for(int i=0; i<size+1; ++i) parent[i]=i;\\n        rank.resize(size+1,1);\\n        \\n        for(int i=0; i<nums.size(); ++i){\\n            for(int j=2; j<=sqrt(nums[i]); ++j){\\n                if(nums[i]%j==0){\\n                    unionDsu(nums[i], j);\\n                    unionDsu(nums[i]/j, j);\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int,int> map;\\n        for(int i=0; i<nums.size(); ++i){\\n            int _x = find(nums[i]);\\n            map[_x]++;\\n        }\\n        \\n        int maxCount = 0;\\n        for(auto &m : map) maxCount = max(maxCount, m.second);\\n        \\n        return maxCount;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    vector<int> rank;\\n    \\n    int find(int x){\\n        if(parent[x]==x) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    void unionDsu(int x, int y){\\n        int _x = find(x), _y = find(y);\\n        if(_x == _y) return;\\n        if (rank[_x] < rank[_y]){\\n            parent[_x] = _y;\\n        }else if(rank[_x] > rank[_y]){\\n            parent[_y] = _x;\\n        }else{\\n            parent[_y] = _x;\\n            rank[_x]+=1;\\n        }\\n    }\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int size = *max_element(nums.begin(), nums.end());\\n        parent.resize(size+1);\\n        for(int i=0; i<size+1; ++i) parent[i]=i;\\n        rank.resize(size+1,1);\\n        \\n        for(int i=0; i<nums.size(); ++i){\\n            for(int j=2; j<=sqrt(nums[i]); ++j){\\n                if(nums[i]%j==0){\\n                    unionDsu(nums[i], j);\\n                    unionDsu(nums[i]/j, j);\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int,int> map;\\n        for(int i=0; i<nums.size(); ++i){\\n            int _x = find(nums[i]);\\n            map[_x]++;\\n        }\\n        \\n        int maxCount = 0;\\n        for(auto &m : map) maxCount = max(maxCount, m.second);\\n        \\n        return maxCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592773,
                "title": "java-solution-using-disjoint-set-union-hashmap",
                "content": "```\\nclass DSU {\\n    ArrayList<Integer> parent = new ArrayList();\\n    public DSU (int n) {\\n        for (int i = 0; i < n; i++)\\n            parent.add(i);\\n    }\\n    int findParent(int n) {\\n        if(parent.get(n) == n)\\n            return n;\\n        parent.set(n, findParent(parent.get(n)));\\n        return parent.get(n);\\n    }\\n    void union(int u, int v) {\\n        int uParent = findParent(u);\\n        int vParent = findParent(v);\\n        \\n        if(uParent != vParent)\\n            parent.set(uParent, parent.get(vParent));\\n    }\\n}\\nclass Solution {\\n    public int largestComponentSize(int[] nums) {\\n        int n = nums.length;\\n        int x = nums[0];\\n        for (int num : nums)\\n            x = Math.max(x, num);\\n        DSU dsu = new DSU(x + 1);\\n        \\n        for (int num : nums) {\\n            for (int i = 2; i * i <= num; i++) {\\n                if (num % i == 0) {\\n                    dsu.union(num, i);\\n                    dsu.union(num, num/i);\\n                }\\n            }\\n        }\\n        Map<Integer, Integer> map = new HashMap();\\n        int ans = 1;\\n        for (int num : nums) {\\n            int par = dsu.findParent(num);\\n            map.put(par, map.getOrDefault(par, 0) + 1);\\n            ans = Math.max(ans, map.get(par));\\n        }\\n        return ans;\\n    }\\n}\\n```\\nPlease **upvote** :-)",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass DSU {\\n    ArrayList<Integer> parent = new ArrayList();\\n    public DSU (int n) {\\n        for (int i = 0; i < n; i++)\\n            parent.add(i);\\n    }\\n    int findParent(int n) {\\n        if(parent.get(n) == n)\\n            return n;\\n        parent.set(n, findParent(parent.get(n)));\\n        return parent.get(n);\\n    }\\n    void union(int u, int v) {\\n        int uParent = findParent(u);\\n        int vParent = findParent(v);\\n        \\n        if(uParent != vParent)\\n            parent.set(uParent, parent.get(vParent));\\n    }\\n}\\nclass Solution {\\n    public int largestComponentSize(int[] nums) {\\n        int n = nums.length;\\n        int x = nums[0];\\n        for (int num : nums)\\n            x = Math.max(x, num);\\n        DSU dsu = new DSU(x + 1);\\n        \\n        for (int num : nums) {\\n            for (int i = 2; i * i <= num; i++) {\\n                if (num % i == 0) {\\n                    dsu.union(num, i);\\n                    dsu.union(num, num/i);\\n                }\\n            }\\n        }\\n        Map<Integer, Integer> map = new HashMap();\\n        int ans = 1;\\n        for (int num : nums) {\\n            int par = dsu.findParent(num);\\n            map.put(par, map.getOrDefault(par, 0) + 1);\\n            ans = Math.max(ans, map.get(par));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820994,
                "title": "cpp-union-find-using-map-with-explanation",
                "content": "tldr: By using map we can save the space from max(array) to sqrt(max(array)).\\n\\nThis question is basically asking the largest connected component in a forest. In order to do so, we need to find a way to \"group\" all the nodes whose common divisor (one by one, not among any two) is greater than 1 together to a single tree, and we need a \"root\" as an id to quantify how many kids does this tree hold. This leads to Union-Find.\\n\\n---\\nstep 1 build the graph:\\n* start with all the nodes themselves, they are \"self-connected\"\\n---\\nstep 2 find all the divisor of current node\\n* after we put node value to the tree, we also need to group all the divisor >= 2 with current root node.\\n* this can be done with sqrt(n) times, since any two divisor a * b < n, a has to be less than sqrt(n).\\n---\\nstep 3 check the root and do the counting\\n* now we have built our tree, and we can easily find the root node (or id) for each node, we can just count the number of id and find the max.\\n```cpp\\nclass Solution {\\npublic:\\n    unordered_map<int, int> p;\\n    \\n    int find(int a) {\\n        if (!p.count(a)) return p[a] = a;\\n        if (p[a] == a) return a;\\n        return p[a] = find(p[a]);\\n    }\\n    \\n    int largestComponentSize(vector<int>& A) {\\n        int n = A.size();\\n        for (int a : A)\\n            p[a] = a;\\n        for (int a : A) \\n            for (int i = 2; i <= sqrt(a); ++i)\\n                if (a % i == 0) {\\n                    p[find(a)] = p[find(i)];\\n                    p[find(a)] = p[find(a / i)];\\n                }\\n        unordered_map<int, int> cnt;\\n        int res = 1;\\n        for (int a : A)\\n            res = max(res, ++cnt[find(a)]);\\n        return res;\\n    }\\n};\\n```\\n\\nQ&A:\\nwhy \\n```cpp\\nfor (int a : A) \\n\\tfor (int i = 2; i <= sqrt(a); ++i)\\n\\t\\tif (a % i == 0) {\\n\\t\\t\\tp[find(a)] = p[find(i)];\\n\\t\\t\\tp[find(a)] = p[find(a / i)];\\n\\t\\t}\\n```\\ninstead of\\n```cpp\\nfor (int a : A) \\n\\tfor (int i = 2; i <= sqrt(a); ++i) {\\n\\t\\tint root = find(a);\\n\\t\\tif (a % i == 0) {\\n\\t\\t\\tp[root] = p[find(i)];\\n\\t\\t\\tp[root] = p[find(a / i)];\\n\\t\\t}\\n\\t}\\n```\\nBecause our root is going to change every time when the p map is updated.\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    unordered_map<int, int> p;\\n    \\n    int find(int a) {\\n        if (!p.count(a)) return p[a] = a;\\n        if (p[a] == a) return a;\\n        return p[a] = find(p[a]);\\n    }\\n    \\n    int largestComponentSize(vector<int>& A) {\\n        int n = A.size();\\n        for (int a : A)\\n            p[a] = a;\\n        for (int a : A) \\n            for (int i = 2; i <= sqrt(a); ++i)\\n                if (a % i == 0) {\\n                    p[find(a)] = p[find(i)];\\n                    p[find(a)] = p[find(a / i)];\\n                }\\n        unordered_map<int, int> cnt;\\n        int res = 1;\\n        for (int a : A)\\n            res = max(res, ++cnt[find(a)]);\\n        return res;\\n    }\\n};\\n```\n```cpp\\nfor (int a : A) \\n\\tfor (int i = 2; i <= sqrt(a); ++i)\\n\\t\\tif (a % i == 0) {\\n\\t\\t\\tp[find(a)] = p[find(i)];\\n\\t\\t\\tp[find(a)] = p[find(a / i)];\\n\\t\\t}\\n```\n```cpp\\nfor (int a : A) \\n\\tfor (int i = 2; i <= sqrt(a); ++i) {\\n\\t\\tint root = find(a);\\n\\t\\tif (a % i == 0) {\\n\\t\\t\\tp[root] = p[find(i)];\\n\\t\\t\\tp[root] = p[find(a / i)];\\n\\t\\t}\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593150,
                "title": "c-simple-solution-using-depth-first-search-and-prime-factorization",
                "content": "```\\nclass Solution {\\n    final int MAX = (int)1e5;\\n    boolean[] vis;\\n    int[] occ;\\n    int[] LPF; // Least prime factor\\n    \\n    int dfs(int x) {\\n        if (x > MAX || vis[x] == true) return 0;\\n        vis[x] = true;\\n        \\n        int cnt = occ[x];\\n        \\n        if (x == LPF[x]) { // if prime\\n            for (int i = x+x; i <= MAX; i += x) {\\n                cnt += dfs(i);\\n            }\\n        }\\n        else if (occ[x] > 0) { // if cotains in nums array\\n            for (x = x; x > 1; x /= LPF[x]) { // Log(x) prime factorization \\n                cnt += dfs(LPF[x]);\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n    \\n    public int largestComponentSize(int[] nums) {\\n        occ = new int[MAX+10];\\n        for (int num : nums) occ[num]++;\\n        \\n        LPF = new int[MAX+10];\\n        for (int i = 2; i <= MAX; i++) {\\n            if (LPF[i] == 0) {\\n                for (int j = i; j <= MAX; j += i) {\\n                    if (LPF[j] == 0) LPF[j] = i;\\n                }\\n            }\\n        }\\n        \\n        vis = new boolean[MAX+10];\\n        int ans = 0;\\n        for (int i = 2; i <= MAX; i++) {\\n            ans = Math.max(ans, dfs(i));\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    final int MAX = (int)1e5;\\n    boolean[] vis;\\n    int[] occ;\\n    int[] LPF; // Least prime factor\\n    \\n    int dfs(int x) {\\n        if (x > MAX || vis[x] == true) return 0;\\n        vis[x] = true;\\n        \\n        int cnt = occ[x];\\n        \\n        if (x == LPF[x]) { // if prime\\n            for (int i = x+x; i <= MAX; i += x) {\\n                cnt += dfs(i);\\n            }\\n        }\\n        else if (occ[x] > 0) { // if cotains in nums array\\n            for (x = x; x > 1; x /= LPF[x]) { // Log(x) prime factorization \\n                cnt += dfs(LPF[x]);\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n    \\n    public int largestComponentSize(int[] nums) {\\n        occ = new int[MAX+10];\\n        for (int num : nums) occ[num]++;\\n        \\n        LPF = new int[MAX+10];\\n        for (int i = 2; i <= MAX; i++) {\\n            if (LPF[i] == 0) {\\n                for (int j = i; j <= MAX; j += i) {\\n                    if (LPF[j] == 0) LPF[j] = i;\\n                }\\n            }\\n        }\\n        \\n        vis = new boolean[MAX+10];\\n        int ans = 0;\\n        for (int i = 2; i <= MAX; i++) {\\n            ans = Math.max(ans, dfs(i));\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821162,
                "title": "java-2-simple-solutions-one-using-dfs-and-another-using-union-find",
                "content": "Here I have given 2 solutions one using dfs and another using union-find. Bothe approach share the same initial preprocessing steps! The only thing that is different is thet in union find we check size of every root node where as in dfs implementation we use dfs to find size of every connected component.\\n\\n**1. Using DFS**\\n```\\nclass Solution {\\n    \\n    ArrayList<Integer>[] graph;\\n    boolean[] visited;\\n    int count=0;\\n    \\n\\tpublic int largestComponentSize(int[] A) {\\n\\t\\t\\n\\t\\t//Getting prime factors of every element in the array A\\n        HashSet<Integer> primes[] = new HashSet[A.length];\\n        for(int i=0; i<A.length; i++){\\n            primes[i] = primeFact(A[i]);\\n        }\\n\\t\\t\\n\\t\\t//Generating HashMap with every prime factor as key and list of elements\\' index that has that particular number as prime factor as value\\n        HashMap<Integer, ArrayList<Integer>> mapping = new HashMap<>();\\n        for(int i=0; i<primes.length; i++){\\n            for(int fact: primes[i]){\\n                if(!mapping.containsKey(fact))\\n                    mapping.put(fact, new ArrayList<Integer>());\\n                mapping.get(fact).add(i);\\n            }\\n        }\\n\\t\\t\\n        //Initializing graph\\n        graph = new ArrayList[A.length];\\n        visited = new boolean[A.length];\\n        for(int i=0; i<A.length; i++)\\n            graph[i]=new ArrayList<>();\\n        \\n\\t\\t//Adding edges between nodes that share common prime factors\\n\\t\\t//There will be duplicate node in this adjacency list. We can use HashSet but overhead is big! \\n\\t\\t//As during dfs we do use visited array so every node is visited once so duplicate entries don\\'t bother that much\\n        for(ArrayList<Integer> arr:mapping.values()){\\n            for(int i=1; i<arr.size(); i++){\\n                graph[arr.get(i-1)].add(arr.get(i));\\n                graph[arr.get(i)].add(arr.get(i-1));\\n            }\\n        }\\n        \\n\\t\\t//finding the size of largest connected component\\n        int max = 0;\\n        for(int i=0; i<A.length; i++){\\n            if(!visited[i]){\\n                count=0;\\n                dfs(i);\\n                max = Math.max(max, count);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private void dfs(int node){\\n        visited[node]=true;\\n        count++;\\n        for(int nbr:graph[node]){\\n            if(!visited[nbr]){\\n                dfs(nbr);\\n            }\\n        }\\n    }\\n    \\n    private HashSet<Integer> primeFact(int n){\\n        HashSet<Integer> ans = new HashSet<>();\\n        if(n==1)\\n            return ans;\\n        \\n        while(n%2==0){\\n            ans.add(2);\\n            n/=2;\\n        }\\n        for(int i=3; i<=Math.sqrt(n); i+=2){\\n            // System.out.println(n%i);\\n            while(n%i==0){\\n                n/=i;\\n                ans.add(i);\\n            }\\n        }\\n        if(n>2)\\n            ans.add(n);\\n        return ans;\\n    }\\n}\\n```\\n\\n**2. Using Union Find(More effiecient)**\\n\\n```\\nclass Solution {\\n    \\n    int[] sz, id;\\n    \\n    public int largestComponentSize(int[] A) {\\n\\t\\n\\t\\t//Getting prime factors of every element in the array A\\n        HashSet<Integer> primes[] = new HashSet[A.length];\\n        for(int i=0; i<A.length; i++){\\n            primes[i] = primeFact(A[i]);\\n        }\\n\\t\\t\\n\\t\\t//Generating HashMap with every prime factor as key and list of elements\\' index that has that particular number as prime factor as value\\n        HashMap<Integer, ArrayList<Integer>> mapping = new HashMap<>();\\n        for(int i=0; i<primes.length; i++){\\n            for(int fact: primes[i]){\\n                if(!mapping.containsKey(fact))\\n                    mapping.put(fact, new ArrayList<Integer>());\\n                mapping.get(fact).add(i);\\n            }\\n        }\\n        \\n\\t\\t//Initializing arrays for union-find \\n        this.sz = new int[A.length];\\n        this.id = new int[A.length];\\n        \\n        for(int i=0; i<id.length; i++){\\n            sz[i]=1; //Initial size of each componenet is 1\\n            id[i]=i; //Initially every node is root node \\n        }\\n        \\n\\t\\t//Calling union with elements that share same prime factore\\n        for(ArrayList<Integer> arr:mapping.values())\\n            for(int i=1; i<arr.size(); i++)\\n                union(arr.get(i-1), arr.get(i));\\n        \\n\\t\\t//finding the size of largest component size in disjoint set\\n        int max = 0;\\n        for(int i=0; i<A.length; i++){\\n            max = Math.max(max, this.sz[find(i)]);\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int find(int node){\\n\\t\\t\\n\\t\\t//Finding root node\\n        int root = node;\\n        while(root!=this.id[root]){\\n            root = this.id[root];\\n        }\\n        \\n\\t\\t//Path Compression\\n\\t\\twhile(node!=root){\\n            int tmp = this.id[node];\\n            this.id[node] = root;\\n            node = tmp;\\n        }\\n        return root;\\n    }\\n    \\n    private void union(int i, int j){\\n        int root1 = find(i);\\n        int root2 = find(j);\\n        \\n        if(root1==root2)\\n            return;\\n        \\n\\t\\t//Merging smaller component into larger one\\n        if(this.sz[root1]<=this.sz[root2]){\\n            this.sz[root2]+=this.sz[root1];\\n            this.id[root1]=root2;\\n        }else{\\n            this.sz[root1]+=this.sz[root2];\\n            this.id[root2]=root1;\\n        }\\n    }\\n    \\n    private HashSet<Integer> primeFact(int n){\\n        HashSet<Integer> ans = new HashSet<>();\\n        if(n==1){\\n            return ans;\\n        }\\n\\t\\t\\n        while(n%2==0){\\n            ans.add(2);\\n            n/=2;\\n        }\\n        for(int i=3; i<=Math.sqrt(n); i+=2){\\n            while(n%i==0){\\n                n/=i;\\n                ans.add(i);\\n            }\\n        }\\n        if(n>2)\\n            ans.add(n);\\n        return ans;\\n    }\\n}\\n```\\n\\nHere time complexity of both approach is more or less same. In both approach first thing that is different that in dfs one we create graph by adding edges and in the later one we call union function and create components with that. We know that union method\\'s amortized time complexity effectively becomes small constant with path compression. \\n\\nNow main difference is in the last part where we find the size of the largest component! In the dfs approach we call the dfs in loop and keep track of size of each component. This approach is little ineffecient as there are duplicate nodes in the adjacency list but it doesn\\'t affect that much due to the use of visited array but we do run a loop for every nbr in the adj list. Where as in the union find we find size of the root for every node so find has amortized complexity of contant and we do that also n times so this may be little bit more efficient in some cases but it doen\\'t make that much difference.",
                "solutionTags": [
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    \\n    ArrayList<Integer>[] graph;\\n    boolean[] visited;\\n    int count=0;\\n    \\n\\tpublic int largestComponentSize(int[] A) {\\n\\t\\t\\n\\t\\t//Getting prime factors of every element in the array A\\n        HashSet<Integer> primes[] = new HashSet[A.length];\\n        for(int i=0; i<A.length; i++){\\n            primes[i] = primeFact(A[i]);\\n        }\\n\\t\\t\\n\\t\\t//Generating HashMap with every prime factor as key and list of elements\\' index that has that particular number as prime factor as value\\n        HashMap<Integer, ArrayList<Integer>> mapping = new HashMap<>();\\n        for(int i=0; i<primes.length; i++){\\n            for(int fact: primes[i]){\\n                if(!mapping.containsKey(fact))\\n                    mapping.put(fact, new ArrayList<Integer>());\\n                mapping.get(fact).add(i);\\n            }\\n        }\\n\\t\\t\\n        //Initializing graph\\n        graph = new ArrayList[A.length];\\n        visited = new boolean[A.length];\\n        for(int i=0; i<A.length; i++)\\n            graph[i]=new ArrayList<>();\\n        \\n\\t\\t//Adding edges between nodes that share common prime factors\\n\\t\\t//There will be duplicate node in this adjacency list. We can use HashSet but overhead is big! \\n\\t\\t//As during dfs we do use visited array so every node is visited once so duplicate entries don\\'t bother that much\\n        for(ArrayList<Integer> arr:mapping.values()){\\n            for(int i=1; i<arr.size(); i++){\\n                graph[arr.get(i-1)].add(arr.get(i));\\n                graph[arr.get(i)].add(arr.get(i-1));\\n            }\\n        }\\n        \\n\\t\\t//finding the size of largest connected component\\n        int max = 0;\\n        for(int i=0; i<A.length; i++){\\n            if(!visited[i]){\\n                count=0;\\n                dfs(i);\\n                max = Math.max(max, count);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private void dfs(int node){\\n        visited[node]=true;\\n        count++;\\n        for(int nbr:graph[node]){\\n            if(!visited[nbr]){\\n                dfs(nbr);\\n            }\\n        }\\n    }\\n    \\n    private HashSet<Integer> primeFact(int n){\\n        HashSet<Integer> ans = new HashSet<>();\\n        if(n==1)\\n            return ans;\\n        \\n        while(n%2==0){\\n            ans.add(2);\\n            n/=2;\\n        }\\n        for(int i=3; i<=Math.sqrt(n); i+=2){\\n            // System.out.println(n%i);\\n            while(n%i==0){\\n                n/=i;\\n                ans.add(i);\\n            }\\n        }\\n        if(n>2)\\n            ans.add(n);\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    int[] sz, id;\\n    \\n    public int largestComponentSize(int[] A) {\\n\\t\\n\\t\\t//Getting prime factors of every element in the array A\\n        HashSet<Integer> primes[] = new HashSet[A.length];\\n        for(int i=0; i<A.length; i++){\\n            primes[i] = primeFact(A[i]);\\n        }\\n\\t\\t\\n\\t\\t//Generating HashMap with every prime factor as key and list of elements\\' index that has that particular number as prime factor as value\\n        HashMap<Integer, ArrayList<Integer>> mapping = new HashMap<>();\\n        for(int i=0; i<primes.length; i++){\\n            for(int fact: primes[i]){\\n                if(!mapping.containsKey(fact))\\n                    mapping.put(fact, new ArrayList<Integer>());\\n                mapping.get(fact).add(i);\\n            }\\n        }\\n        \\n\\t\\t//Initializing arrays for union-find \\n        this.sz = new int[A.length];\\n        this.id = new int[A.length];\\n        \\n        for(int i=0; i<id.length; i++){\\n            sz[i]=1; //Initial size of each componenet is 1\\n            id[i]=i; //Initially every node is root node \\n        }\\n        \\n\\t\\t//Calling union with elements that share same prime factore\\n        for(ArrayList<Integer> arr:mapping.values())\\n            for(int i=1; i<arr.size(); i++)\\n                union(arr.get(i-1), arr.get(i));\\n        \\n\\t\\t//finding the size of largest component size in disjoint set\\n        int max = 0;\\n        for(int i=0; i<A.length; i++){\\n            max = Math.max(max, this.sz[find(i)]);\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int find(int node){\\n\\t\\t\\n\\t\\t//Finding root node\\n        int root = node;\\n        while(root!=this.id[root]){\\n            root = this.id[root];\\n        }\\n        \\n\\t\\t//Path Compression\\n\\t\\twhile(node!=root){\\n            int tmp = this.id[node];\\n            this.id[node] = root;\\n            node = tmp;\\n        }\\n        return root;\\n    }\\n    \\n    private void union(int i, int j){\\n        int root1 = find(i);\\n        int root2 = find(j);\\n        \\n        if(root1==root2)\\n            return;\\n        \\n\\t\\t//Merging smaller component into larger one\\n        if(this.sz[root1]<=this.sz[root2]){\\n            this.sz[root2]+=this.sz[root1];\\n            this.id[root1]=root2;\\n        }else{\\n            this.sz[root1]+=this.sz[root2];\\n            this.id[root2]=root1;\\n        }\\n    }\\n    \\n    private HashSet<Integer> primeFact(int n){\\n        HashSet<Integer> ans = new HashSet<>();\\n        if(n==1){\\n            return ans;\\n        }\\n\\t\\t\\n        while(n%2==0){\\n            ans.add(2);\\n            n/=2;\\n        }\\n        for(int i=3; i<=Math.sqrt(n); i+=2){\\n            while(n%i==0){\\n                n/=i;\\n                ans.add(i);\\n            }\\n        }\\n        if(n>2)\\n            ans.add(n);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592465,
                "title": "simplest-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // M = MAX ELEMENT\\n    // TIME COMPLEXITY:- O(MLOG(M))\\n    // SPQACE COMPLEXITY:- O(M)\\n    \\n     // finds the parent of a connected component\\n    int find_set(int x,vector<pair<int,int>>& parent){\\n        return parent[x].first==x?x:parent[x].first = find_set(parent[x].first,parent);\\n    }\\n    \\n    // unites two connected component if they have different parent\\'s\\n    void union_set(int x,int y,vector<pair<int,int>>& parent,vector<int>& comp){\\n        int xroot = find_set(x,parent),yroot = find_set(y,parent);\\n        if(xroot==yroot)\\n            return; // have same parent\\n        \\n        // rank compression \\n        if(parent[xroot].second==parent[yroot].second)\\n            parent[xroot].second++;\\n        if(parent[xroot].second>parent[yroot].second){\\n            parent[yroot].first = xroot;\\n            comp[xroot] += comp[yroot]; // increase the component size on merging\\n        }\\n        else{\\n            parent[xroot].first = yroot;\\n            comp[yroot] += comp[xroot]; // increase the component size on merging\\n        }\\n    }\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int N = *max_element(nums.begin(),nums.end());\\n        vector<bool> isPresent(N+1,false);\\n        \\n        for(auto& c:nums)\\n            isPresent[c] = true;\\n        \\n        // use NlogN time to mark all numbers which have same factor i\\n        vector<int> adj[N+1];\\n        for(int i=2;i<=N;i++){\\n            for(int j=i;j<=N;j+=i){\\n                if(isPresent[j])\\n                    adj[i].push_back(j);\\n            }\\n        }\\n        \\n        // parent[i].first = store parent of the connected component\\n        // parent[i].second = store rank of the connected component\\n        // comp[i] will store size of connected component\\n        \\n        vector<int> comp(N+1);\\n        vector<pair<int,int>> parent;\\n        for(int i=0;i<=N;i++){\\n            if(isPresent[i])\\n                comp[i] = 1;\\n            parent.push_back({i,0});\\n        }\\n        \\n        // unite two numbers which has same factor i\\n        for(int i=1;i<=N;i++){\\n            for(int j=1;j<adj[i].size();j++)\\n                union_set(adj[i][j-1],adj[i][j],parent,comp);\\n        }\\n        \\n        // find the maximum size of connected component\\n        int ans = 0;\\n        for(auto& c:comp)\\n            ans = max(ans,c);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // M = MAX ELEMENT\\n    // TIME COMPLEXITY:- O(MLOG(M))\\n    // SPQACE COMPLEXITY:- O(M)\\n    \\n     // finds the parent of a connected component\\n    int find_set(int x,vector<pair<int,int>>& parent){\\n        return parent[x].first==x?x:parent[x].first = find_set(parent[x].first,parent);\\n    }\\n    \\n    // unites two connected component if they have different parent\\'s\\n    void union_set(int x,int y,vector<pair<int,int>>& parent,vector<int>& comp){\\n        int xroot = find_set(x,parent),yroot = find_set(y,parent);\\n        if(xroot==yroot)\\n            return; // have same parent\\n        \\n        // rank compression \\n        if(parent[xroot].second==parent[yroot].second)\\n            parent[xroot].second++;\\n        if(parent[xroot].second>parent[yroot].second){\\n            parent[yroot].first = xroot;\\n            comp[xroot] += comp[yroot]; // increase the component size on merging\\n        }\\n        else{\\n            parent[xroot].first = yroot;\\n            comp[yroot] += comp[xroot]; // increase the component size on merging\\n        }\\n    }\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int N = *max_element(nums.begin(),nums.end());\\n        vector<bool> isPresent(N+1,false);\\n        \\n        for(auto& c:nums)\\n            isPresent[c] = true;\\n        \\n        // use NlogN time to mark all numbers which have same factor i\\n        vector<int> adj[N+1];\\n        for(int i=2;i<=N;i++){\\n            for(int j=i;j<=N;j+=i){\\n                if(isPresent[j])\\n                    adj[i].push_back(j);\\n            }\\n        }\\n        \\n        // parent[i].first = store parent of the connected component\\n        // parent[i].second = store rank of the connected component\\n        // comp[i] will store size of connected component\\n        \\n        vector<int> comp(N+1);\\n        vector<pair<int,int>> parent;\\n        for(int i=0;i<=N;i++){\\n            if(isPresent[i])\\n                comp[i] = 1;\\n            parent.push_back({i,0});\\n        }\\n        \\n        // unite two numbers which has same factor i\\n        for(int i=1;i<=N;i++){\\n            for(int j=1;j<adj[i].size();j++)\\n                union_set(adj[i][j-1],adj[i][j],parent,comp);\\n        }\\n        \\n        // find the maximum size of connected component\\n        int ans = 0;\\n        for(auto& c:comp)\\n            ans = max(ans,c);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570148,
                "title": "c-232-ms-union-find-factorisation",
                "content": "## Approach\\n<hr>\\nWe know from the problem statement, that if any two number have a common factor, they need to be put in the same set. For this, we can iterate over the list, factorize the number, for each of its factor (not 1 and number itself), we should unite the sets using [Disjoin set Union](https://cp-algorithms.com/data_structures/disjoint_set_union.html) (use path compession for efficiency).\\n\\nFor instance, if we have [4, 6]\\n`factorize 4`: `2`\\n`unite(4, 2)`\\n`factorize 6`: `2, 3`\\n`unite(6, 2)`\\n`unite(6, 3)`\\n\\nat the end we see that 4 and 6 belong to the same set.\\nwe use `unordered_map` to store parents and their frequency at the end and get parent with maximum size.\\n\\n## Code\\n<hr>\\n\\n```cpp\\nstruct DSU {\\n\\tvector<int> e;\\n\\tDSU(int N) { e = vector<int>(N, -1); }\\n\\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }\\n\\tbool same_set(int a, int b) { return get(a) == get(b); }\\n\\tint size(int x) { return -e[get(x)]; }\\n\\tbool unite(int x, int y) { \\n\\t\\tx = get(x), y = get(y);\\n\\t\\tif (x == y) return false;\\n\\t\\tif (e[x] > e[y]) swap(x, y);\\n\\t\\te[x] += e[y]; e[y] = x;\\n\\t\\treturn true;\\n\\t}\\n};\\n\\nint largestComponentSize(vector<int>& nums) {\\n\\tDSU dsu(*max_element(nums.begin(), nums.end()) + 1); //create DSU struct with nodes 0, 1, 2, ... max element of the vector\\n\\tfor(auto i: nums){\\n\\t\\tfor(int j = 2;j*j<=i;j++){ //factorize each number\\n\\t\\t\\tif(i%j == 0){\\n\\t\\t\\t\\tdsu.unite(j, i);\\n\\t\\t\\t\\tdsu.unite(i/j, i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tint ans = 1;\\n\\tunordered_map<int, int> freq;\\n\\tfor(auto i: nums){\\n\\t\\tint p = dsu.get(i); //get parent\\n\\t\\tfreq[p]++;\\n\\t\\tans = max(ans, freq[p]);\\n\\t}\\n\\treturn ans;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\nstruct DSU {\\n\\tvector<int> e;\\n\\tDSU(int N) { e = vector<int>(N, -1); }\\n\\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }\\n\\tbool same_set(int a, int b) { return get(a) == get(b); }\\n\\tint size(int x) { return -e[get(x)]; }\\n\\tbool unite(int x, int y) { \\n\\t\\tx = get(x), y = get(y);\\n\\t\\tif (x == y) return false;\\n\\t\\tif (e[x] > e[y]) swap(x, y);\\n\\t\\te[x] += e[y]; e[y] = x;\\n\\t\\treturn true;\\n\\t}\\n};\\n\\nint largestComponentSize(vector<int>& nums) {\\n\\tDSU dsu(*max_element(nums.begin(), nums.end()) + 1); //create DSU struct with nodes 0, 1, 2, ... max element of the vector\\n\\tfor(auto i: nums){\\n\\t\\tfor(int j = 2;j*j<=i;j++){ //factorize each number\\n\\t\\t\\tif(i%j == 0){\\n\\t\\t\\t\\tdsu.unite(j, i);\\n\\t\\t\\t\\tdsu.unite(i/j, i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tint ans = 1;\\n\\tunordered_map<int, int> freq;\\n\\tfor(auto i: nums){\\n\\t\\tint p = dsu.get(i); //get parent\\n\\t\\tfreq[p]++;\\n\\t\\tans = max(ans, freq[p]);\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 820371,
                "title": "swift-solution-beats-100",
                "content": "This problem was nearly impossible in Swift. I was using Union Find with Path Compression and Weights and it was giving TLE. I finally realized that the Path Compression was causing too many array assignments and strangely enough, the solution was faster without path compression. The `group(_ r: Int)` method does not use path compression while the`root(_ r: Int)` method does. I replaced all calls to `root(_ r: Int)` with `group(_ r: Int)` and it provided a 10x improvement.\\n\\n**Solution**\\n```swift\\nclass Solution {\\n    func largestComponentSize(_ A: [Int]) -> Int {\\n        var uf = UnionFind((A.max() ?? 0) + 1)\\n        var map = [Int: Int]()\\n        \\n        for num in A {\\n            let primes = factors(num)\\n            map[num] = primes[0]\\n            \\n            for i in 0 ..< primes.count - 1 where primes[i] != primes[i+1] {\\n                uf.union(primes[i], primes[i+1])\\n            }\\n        }\\n         \\n        var count = [Int: Int]()\\n        for num in A {\\n            var group = uf.group(map[num]!)\\n            count[group, default: 0] += 1\\n        }\\n        \\n        return count.values.max() ?? 0\\n    }\\n    \\n    func factors(_ num: Int) -> [Int] {\\n        var result = [Int]() \\n        var factor = 2 \\n        var num = num\\n        \\n        var prev = 1\\n        while num >= factor * factor {\\n            if num % factor == 0 {\\n                if factor != prev {\\n                    result.append(factor)\\n                }\\n                prev = factor\\n                num = num / factor\\n            } else {\\n                factor += 1\\n            }\\n        }\\n        \\n        result.append(num) \\n        return result\\n    }\\n}\\n\\n\\n\\n// MARK: Union Find \\n\\npublic class UnionFind {\\n\\t\\n\\t// MARK: Properties \\n\\n\\tpublic private(set) var arr: [Int]\\n\\tpublic private(set) var size: [Int]\\n\\n\\n\\t// MARK: Initialization \\n\\t\\n\\t/// Initializes Union Find with n objects \\n\\tpublic init(_ n: Int) {\\n\\t\\tself.arr = Array(0 ..< n) \\n\\t\\tself.size = Array(repeating: 1, count: n) \\n\\t}\\n\\n\\n\\t// MARK: Methods \\n\\n\\t/// Connects the set containing p with the set containing q\\n\\tpublic func union(_ p: Int, _ q: Int) {\\n\\t\\tlet pid = group(p) \\n\\t\\tlet qid = group(q) \\n        guard pid != qid else { return }\\n\\t\\tlet (small, big) = size[pid] < size[qid] ? \\n\\t\\t\\t(pid, qid) : (qid, pid) \\n\\t\\tsize[big] += size[small]\\n\\t\\tarr[small] = big \\n\\t}\\n\\n\\t/// Returns true if and only if p and q are connected \\n\\tpublic func find(_ p: Int, _ q: Int) -> Bool {\\n\\t\\tlet pid = group(p)\\n\\t\\tlet qid = group(q)\\n\\t\\treturn pid == qid \\n\\t}\\n\\n\\t/// Returns the root of r and performs path compression \\n\\tpublic func root(_ r: Int) -> Int {\\n\\t\\tvar r = r \\n\\t\\twhile arr[r] != r {\\n\\t\\t\\tarr[r] = arr[arr[r]]\\n\\t\\t\\tr = arr[r]\\n\\t\\t}\\n\\t\\treturn r \\n\\t}\\n    \\n    public func group(_ r: Int) -> Int {\\n        var r = r \\n        while arr[r] != r {\\n            r = arr[r]\\n        }\\n        return r \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    func largestComponentSize(_ A: [Int]) -> Int {\\n        var uf = UnionFind((A.max() ?? 0) + 1)\\n        var map = [Int: Int]()\\n        \\n        for num in A {\\n            let primes = factors(num)\\n            map[num] = primes[0]\\n            \\n            for i in 0 ..< primes.count - 1 where primes[i] != primes[i+1] {\\n                uf.union(primes[i], primes[i+1])\\n            }\\n        }\\n         \\n        var count = [Int: Int]()\\n        for num in A {\\n            var group = uf.group(map[num]!)\\n            count[group, default: 0] += 1\\n        }\\n        \\n        return count.values.max() ?? 0\\n    }\\n    \\n    func factors(_ num: Int) -> [Int] {\\n        var result = [Int]() \\n        var factor = 2 \\n        var num = num\\n        \\n        var prev = 1\\n        while num >= factor * factor {\\n            if num % factor == 0 {\\n                if factor != prev {\\n                    result.append(factor)\\n                }\\n                prev = factor\\n                num = num / factor\\n            } else {\\n                factor += 1\\n            }\\n        }\\n        \\n        result.append(num) \\n        return result\\n    }\\n}\\n\\n\\n\\n// MARK: Union Find \\n\\npublic class UnionFind {\\n\\t\\n\\t// MARK: Properties \\n\\n\\tpublic private(set) var arr: [Int]\\n\\tpublic private(set) var size: [Int]\\n\\n\\n\\t// MARK: Initialization \\n\\t\\n\\t/// Initializes Union Find with n objects \\n\\tpublic init(_ n: Int) {\\n\\t\\tself.arr = Array(0 ..< n) \\n\\t\\tself.size = Array(repeating: 1, count: n) \\n\\t}\\n\\n\\n\\t// MARK: Methods \\n\\n\\t/// Connects the set containing p with the set containing q\\n\\tpublic func union(_ p: Int, _ q: Int) {\\n\\t\\tlet pid = group(p) \\n\\t\\tlet qid = group(q) \\n        guard pid != qid else { return }\\n\\t\\tlet (small, big) = size[pid] < size[qid] ? \\n\\t\\t\\t(pid, qid) : (qid, pid) \\n\\t\\tsize[big] += size[small]\\n\\t\\tarr[small] = big \\n\\t}\\n\\n\\t/// Returns true if and only if p and q are connected \\n\\tpublic func find(_ p: Int, _ q: Int) -> Bool {\\n\\t\\tlet pid = group(p)\\n\\t\\tlet qid = group(q)\\n\\t\\treturn pid == qid \\n\\t}\\n\\n\\t/// Returns the root of r and performs path compression \\n\\tpublic func root(_ r: Int) -> Int {\\n\\t\\tvar r = r \\n\\t\\twhile arr[r] != r {\\n\\t\\t\\tarr[r] = arr[arr[r]]\\n\\t\\t\\tr = arr[r]\\n\\t\\t}\\n\\t\\treturn r \\n\\t}\\n    \\n    public func group(_ r: Int) -> Int {\\n        var r = r \\n        while arr[r] != r {\\n            r = arr[r]\\n        }\\n        return r \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819957,
                "title": "java-short-and-concise",
                "content": "```java\\nclass Solution {\\n    public int largestComponentSize(int[] A) {\\n        Map<Integer,Integer> parent = new HashMap<>();\\n\\n        for (int num : A)\\n            for (int fact = 2; fact*fact<=num; fact++)\\n                if (num % fact == 0){\\n                    union(num,fact,parent);\\n                    union(num,num/fact,parent);\\n                }\\n\\n        int max = 1;\\n        Map<Integer,Integer> freq = new HashMap<>();\\n        for (Integer v : A) {\\n            int f = find(v,parent);\\n            if (freq.containsKey(f)) {\\n                freq.put(f, freq.get(f)+1);\\n                max=Math.max(max,freq.get(f));\\n            }\\n            else freq.put(f,1);\\n        }\\n        return max;\\n    }\\n    \\n    public void union(int n, int m, Map<Integer,Integer> p) {\\n        int findN = find(n,p);\\n        int findM = find(m,p);\\n        if (findN < findM) p.put(findM,findN);\\n        else p.put(findN,findM);\\n    }\\n\\n    public int find(Integer i, Map<Integer,Integer> parent) {\\n        if (parent.get(i) == null) parent.put(i,i);\\n        while (i != parent.get(i)) i = parent.get(i);\\n        return i;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int largestComponentSize(int[] A) {\\n        Map<Integer,Integer> parent = new HashMap<>();\\n\\n        for (int num : A)\\n            for (int fact = 2; fact*fact<=num; fact++)\\n                if (num % fact == 0){\\n                    union(num,fact,parent);\\n                    union(num,num/fact,parent);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 200583,
                "title": "simple-c-uf-without-primes",
                "content": "Fairly minimal C++ solution without unnecessary cruft like finding all primes, etc\\n\\nI\\'m using UF indices 1..100000  to represent factors (initially all having size=0) and 100001+i to represent the element A[i] (with initial size=1). I brute force all factors of each A[i] on the fly as I iterate through A and merge() them with the element\\'s index:\\n\\n```\\nclass Solution {\\n    int parent[121000], size[121000];\\n\\npublic:\\n    int largestComponentSize(vector<int>& A) {\\n        for (int i = 0; i < 121000; i++) parent[i] = i;\\n        memset(size, 0, sizeof(size));\\n\\n        for (int i = 0; i < A.size(); i++) {\\n            size[100001 + i] = 1;\\n            for (int p = 2; p*p <= A[i]; p++) {\\n                if (A[i] % p == 0) {\\n                    merge(p, 100001+i);\\n                    merge(A[i]/p, 100001+i);\\n                }\\n            }\\n            merge(A[i], 100001+i);\\n        }\\n\\n        int max_cc = 1;\\n        for (int i = 0; i < A.size(); i++)\\n            max_cc = max(max_cc, size[find(100001+i)]);\\n        return max_cc;\\n    }\\n\\n    int find(int i) {\\n        if (parent[i] != i) parent[i] = find(parent[i]);\\n        return parent[i];\\n    }\\n\\n    void merge(int i, int j) {\\n        i = find(i);\\n        j = find(j);\\n        if (i == j) return;\\n        size[i] += size[j];\\n        parent[j] = i;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int parent[121000], size[121000];\\n\\npublic:\\n    int largestComponentSize(vector<int>& A) {\\n        for (int i = 0; i < 121000; i++) parent[i] = i;\\n        memset(size, 0, sizeof(size));\\n\\n        for (int i = 0; i < A.size(); i++) {\\n            size[100001 + i] = 1;\\n            for (int p = 2; p*p <= A[i]; p++) {\\n                if (A[i] % p == 0) {\\n                    merge(p, 100001+i);\\n                    merge(A[i]/p, 100001+i);\\n                }\\n            }\\n            merge(A[i], 100001+i);\\n        }\\n\\n        int max_cc = 1;\\n        for (int i = 0; i < A.size(); i++)\\n            max_cc = max(max_cc, size[find(100001+i)]);\\n        return max_cc;\\n    }\\n\\n    int find(int i) {\\n        if (parent[i] != i) parent[i] = find(parent[i]);\\n        return parent[i];\\n    }\\n\\n    void merge(int i, int j) {\\n        i = find(i);\\n        j = find(j);\\n        if (i == j) return;\\n        size[i] += size[j];\\n        parent[j] = i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593045,
                "title": "python-union-find-clean-and-easy-to-understand-with-explanation",
                "content": "```\\nclass UnionFindSet(object):\\n    def __init__(self):\\n        self.data = collections.defaultdict(int)\\n\\n    def find(self, x):\\n        while x <> self.data[x]:\\n            x = self.data[x]\\n        return x\\n\\n    def union(self, x, y):\\n        if x not in self.data:\\n            self.data[x] = x\\n        if y not in self.data:\\n            self.data[y] = y\\n        self.data[self.find(x)] = self.find(y)\\n\\n    def speedup(self):\\n        for x in self.data.keys():\\n            self.data[x] = self.find(x)\\n\\n\\nclass Solution(object):\\n    def largestComponentSize(self, nums):\\n        # First of all, generate all prime numbers less than or equal to the max(nums) sequentially. \\n        # It is true that this part of the code is intuitive and easy to understand, but its execution efficiency is not\\n        # high. I added a more efficient version in the comment area below, but it might not be that easy to understand.\\n        primes = []\\n        for num in range(2, max(nums) + 1):\\n            flag = True\\n            for prime in primes:\\n                if num % prime == 0:\\n                    flag = False\\n                    break\\n                if prime * prime > num:\\n                    break\\n            if flag:\\n                primes.append(num)\\n\\n        # Secondly, find the smallest prime factor of each number.\\n        primes = set(primes)\\n        smallest_prime_factor = range(max(nums) + 1)\\n        for num in range(1, max(nums) + 1):\\n            if num in primes:\\n                continue\\n            for prime in primes:\\n                if num % prime == 0:\\n                    smallest_prime_factor[num] = prime\\n                    break\\n\\n        # Thirdly, find all prime factors of each number, and generate a dictionary with prime factors as the key and\\n        # the list of numbers as the value.\\n        prime_factors = collections.defaultdict(list)\\n        for num in nums:\\n            n = num\\n            while smallest_prime_factor[n] < n:\\n                prime_factors[smallest_prime_factor[n]].append(num)\\n                n //= smallest_prime_factor[n]\\n            prime_factors[smallest_prime_factor[n]].append(num)\\n\\n        # Fourthly, use UnionFindSet to connect numbers with common prime factors.\\n        uf = UnionFindSet()\\n        for nums in prime_factors.values():\\n            for i in range(1, len(nums)):\\n                uf.union(nums[i], nums[0])\\n        uf.speedup()\\n\\n        # Finally, returns the number of elements in the largest subset.\\n        # Notice that if no edge could union, the UnionFindSet is empty.\\n        if len(uf.data) == 0:\\n            return 1\\n        return collections.Counter(uf.data.values()).most_common(1)[0][1]\\n```\\n\\n**Please UPVOTE!**",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFindSet(object):\\n    def __init__(self):\\n        self.data = collections.defaultdict(int)\\n\\n    def find(self, x):\\n        while x <> self.data[x]:\\n            x = self.data[x]\\n        return x\\n\\n    def union(self, x, y):\\n        if x not in self.data:\\n            self.data[x] = x\\n        if y not in self.data:\\n            self.data[y] = y\\n        self.data[self.find(x)] = self.find(y)\\n\\n    def speedup(self):\\n        for x in self.data.keys():\\n            self.data[x] = self.find(x)\\n\\n\\nclass Solution(object):\\n    def largestComponentSize(self, nums):\\n        # First of all, generate all prime numbers less than or equal to the max(nums) sequentially. \\n        # It is true that this part of the code is intuitive and easy to understand, but its execution efficiency is not\\n        # high. I added a more efficient version in the comment area below, but it might not be that easy to understand.\\n        primes = []\\n        for num in range(2, max(nums) + 1):\\n            flag = True\\n            for prime in primes:\\n                if num % prime == 0:\\n                    flag = False\\n                    break\\n                if prime * prime > num:\\n                    break\\n            if flag:\\n                primes.append(num)\\n\\n        # Secondly, find the smallest prime factor of each number.\\n        primes = set(primes)\\n        smallest_prime_factor = range(max(nums) + 1)\\n        for num in range(1, max(nums) + 1):\\n            if num in primes:\\n                continue\\n            for prime in primes:\\n                if num % prime == 0:\\n                    smallest_prime_factor[num] = prime\\n                    break\\n\\n        # Thirdly, find all prime factors of each number, and generate a dictionary with prime factors as the key and\\n        # the list of numbers as the value.\\n        prime_factors = collections.defaultdict(list)\\n        for num in nums:\\n            n = num\\n            while smallest_prime_factor[n] < n:\\n                prime_factors[smallest_prime_factor[n]].append(num)\\n                n //= smallest_prime_factor[n]\\n            prime_factors[smallest_prime_factor[n]].append(num)\\n\\n        # Fourthly, use UnionFindSet to connect numbers with common prime factors.\\n        uf = UnionFindSet()\\n        for nums in prime_factors.values():\\n            for i in range(1, len(nums)):\\n                uf.union(nums[i], nums[0])\\n        uf.speedup()\\n\\n        # Finally, returns the number of elements in the largest subset.\\n        # Notice that if no edge could union, the UnionFindSet is empty.\\n        if len(uf.data) == 0:\\n            return 1\\n        return collections.Counter(uf.data.values()).most_common(1)[0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546345,
                "title": "python3-union-find",
                "content": "\\n`O(MlogM)` using sieve\\n```\\nclass UnionFind: \\n    \\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [1]*n\\n        \\n    def find(self, p): \\n        if p != self.parent[p]: \\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union(self, p, q): \\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False \\n        if self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt\\n        self.parent[prt] = qrt\\n        self.rank[qrt] += self.rank[prt]\\n        return True \\n\\n\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        m = max(A)\\n        uf = UnionFind(m+1)\\n        seen = set(A)\\n        \\n        # modified sieve of eratosthenes \\n        sieve = [1]*(m+1)\\n        sieve[0] = sieve[1] = 0 \\n        for k in range(m//2+1): \\n            if sieve[k]: \\n                prev = k if k in seen else 0\\n                for x in range(2*k, m+1, k): \\n                    sieve[x] = 0\\n                    if x in seen: \\n                        if prev: uf.union(prev, x)\\n                        else: prev = x\\n        return max(uf.rank)\\n```\\n\\n**Related problems**\\n[952. Largest Component Size by Common Factor](https://leetcode.com/problems/largest-component-size-by-common-factor/discuss/1546345/Python3-union-find)\\n[1998. GCD Sort of an Array](https://leetcode.com/problems/gcd-sort-of-an-array/discuss/1445278/Python3-union-find)\\n\\nAlternative implemetation `O(Nsqrt(M))` assuming `O(1)` union & find.\\n```\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        m = max(nums)\\n        uf = UnionFind(m+1)\\n        for x in nums: \\n            for p in range(2, int(sqrt(x))+1): \\n                if x%p == 0: \\n                    uf.union(x, p)\\n                    uf.union(x, x//p)\\n        freq = Counter(uf.find(x) for x in nums)\\n        return max(freq.values())\\n```\\n\\nAlternative implementation using `spf` `O((M+N)logM)`\\n```\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        m = max(nums)\\n        spf = list(range(m+1))\\n        for x in range(4, m+1, 2): spf[x] = 2\\n        for x in range(3, int(sqrt(m+1))+1): \\n            if spf[x] == x: \\n                for xx in range(x*x, m+1, x): \\n                    spf[xx] = x \\n        \\n        uf = UnionFind(len(nums))\\n        mp = {}\\n        for i, x in enumerate(nums): \\n            while x > 1: \\n                if spf[x] in mp: uf.union(i, mp[spf[x]])\\n                else: mp[spf[x]] = i\\n                x //= spf[x]\\n        return max(uf.rank)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass UnionFind: \\n    \\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [1]*n\\n        \\n    def find(self, p): \\n        if p != self.parent[p]: \\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union(self, p, q): \\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False \\n        if self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt\\n        self.parent[prt] = qrt\\n        self.rank[qrt] += self.rank[prt]\\n        return True \\n\\n\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        m = max(A)\\n        uf = UnionFind(m+1)\\n        seen = set(A)\\n        \\n        # modified sieve of eratosthenes \\n        sieve = [1]*(m+1)\\n        sieve[0] = sieve[1] = 0 \\n        for k in range(m//2+1): \\n            if sieve[k]: \\n                prev = k if k in seen else 0\\n                for x in range(2*k, m+1, k): \\n                    sieve[x] = 0\\n                    if x in seen: \\n                        if prev: uf.union(prev, x)\\n                        else: prev = x\\n        return max(uf.rank)\\n```\n```\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        m = max(nums)\\n        uf = UnionFind(m+1)\\n        for x in nums: \\n            for p in range(2, int(sqrt(x))+1): \\n                if x%p == 0: \\n                    uf.union(x, p)\\n                    uf.union(x, x//p)\\n        freq = Counter(uf.find(x) for x in nums)\\n        return max(freq.values())\\n```\n```\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        m = max(nums)\\n        spf = list(range(m+1))\\n        for x in range(4, m+1, 2): spf[x] = 2\\n        for x in range(3, int(sqrt(m+1))+1): \\n            if spf[x] == x: \\n                for xx in range(x*x, m+1, x): \\n                    spf[xx] = x \\n        \\n        uf = UnionFind(len(nums))\\n        mp = {}\\n        for i, x in enumerate(nums): \\n            while x > 1: \\n                if spf[x] in mp: uf.union(i, mp[spf[x]])\\n                else: mp[spf[x]] = i\\n                x //= spf[x]\\n        return max(uf.rank)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819974,
                "title": "largest-component-javascript-356ms-beats-90",
                "content": "### Ideas to the solution\\n\\n* It doesn\\'t need to have the entire graph, and we only need to have connected components with minimal connections.\\n* Using [union-find algorithm](https://en.wikipedia.org/wiki/Disjoint-set_data_structure), we can efficiently group two numbers divided by a divisor. However, running this algorithm will take O(N^2), and it causes TLE. \\n* A key idea is that two numbers divided by a prime number belong to the same component together. Furthermore, K numbers are divided by a prime number will be in the same component. Running the union operation for (X1, X2), (X1, X3), ..., (X1, XK) will group the number together. Here, X1 ... XK is a set of numbers that are divided by a prime number.\\n* So, using Eratosthenes\\' sieve, we can collect prime numbers less than or equal to the maximum number (M) of the input and run the union operations.\\n* My initial solution runs Eratosthenes\\' sieve from 2 to M. It was accepted, but it took 4600 ms. After I got AC, I tried to find where I could optimize. \\n* After review my code, I realized that it only needs to run the sieve up to sqrt(M) with prime factorizations for every time it performs a union operation for a prime number. Later the sieve, it needs to find numbers that still need to be factorized, and those numbers are prime numbers that are not counted by the sieve. Running additional union operations the same yet-to-factorized numbers (prime numbers) and measuring the maximum component will complete the algorithm. \\n\\n```\\nvar largestComponentSize = function(A) {\\n  const n = A.length;\\n  let parent = new Array(n).fill().map((_,i)=>i);\\n  let cnt = new Array(n).fill(1);\\n  let find  = (i) => parent[i] == i? i : find(parent[i]);\\n  let union = (i, j) => {\\n    let p = find(i);\\n    let q = find(j);\\n    \\n    if(p === q) return;\\n    \\n    if(cnt[p]<cnt[q]) {\\n      [p,q] = [q,p];\\n    }\\n    cnt[p] += cnt[q];\\n    parent[q] = p;\\n  }\\n  \\n  const m = Math.max(...A);\\n  let p = new Array(m+1).fill(true);\\n  const root = Math.floor(Math.sqrt(m));\\n  for(let i=2;i<=root;i++) if(p[i]) {\\n    let k = -1;\\n    for(let j=0;j<n;++j) {\\n      if(A[j]%i===0) {\\n        while(A[j] % i === 0)\\n          A[j] = Math.floor(A[j]/i);\\n        if(k===-1) k = j;\\n        else union(k, j);\\n      }\\n    } \\n    for(let j=i*i;j<=m;j+=i) p[j] = false;\\n  }\\n  \\n  A = A.map((x,i)=>[x,i]).filter(x=>x[0]>1).sort((a,b)=>a[0]-b[0]);\\n  for(let i=1;i<A.length;++i) {\\n    if(A[i-1][0]===A[i][0]) {\\n      union(A[i-1][1], A[i][1]);\\n    }\\n  }\\n  \\n  return Math.max(...cnt);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\nvar largestComponentSize = function(A) {\\n  const n = A.length;\\n  let parent = new Array(n).fill().map((_,i)=>i);\\n  let cnt = new Array(n).fill(1);\\n  let find  = (i) => parent[i] == i? i : find(parent[i]);\\n  let union = (i, j) => {\\n    let p = find(i);\\n    let q = find(j);\\n    \\n    if(p === q) return;\\n    \\n    if(cnt[p]<cnt[q]) {\\n      [p,q] = [q,p];\\n    }\\n    cnt[p] += cnt[q];\\n    parent[q] = p;\\n  }\\n  \\n  const m = Math.max(...A);\\n  let p = new Array(m+1).fill(true);\\n  const root = Math.floor(Math.sqrt(m));\\n  for(let i=2;i<=root;i++) if(p[i]) {\\n    let k = -1;\\n    for(let j=0;j<n;++j) {\\n      if(A[j]%i===0) {\\n        while(A[j] % i === 0)\\n          A[j] = Math.floor(A[j]/i);\\n        if(k===-1) k = j;\\n        else union(k, j);\\n      }\\n    } \\n    for(let j=i*i;j<=m;j+=i) p[j] = false;\\n  }\\n  \\n  A = A.map((x,i)=>[x,i]).filter(x=>x[0]>1).sort((a,b)=>a[0]-b[0]);\\n  for(let i=1;i<A.length;++i) {\\n    if(A[i-1][0]===A[i][0]) {\\n      union(A[i-1][1], A[i][1]);\\n    }\\n  }\\n  \\n  return Math.max(...cnt);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 204260,
                "title": "a-few-solutions",
                "content": "For each number `x` in the input array `A`, use an associative array `m` to map factors of `x` to `x`.  There are 3 use cases to consider for each factor of `x`:\\n\\n* **Case 1:** `x` as a factor of itself\\n* **Case 2:** the i<sup>th</sup> factor of `x`\\n* **Case 3:** the j<sup>th</sup> factor of `x`, where `j` = `x / i`\\n\\nSince we are using union-find to track the parent representatives `P` of each disjoint set, we only need to track a single member `x` of each set for each factor `x`, `i`, `j` for case 1, 2, 3 correspondingly.  As sets are joined, their length `L` is accumulated and tracked by each parent reprentative.  Return the maxmium length of any parent reprensentative\\'s set.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun largestComponentSize(A: IntArray, N: Int = (1e5 + 1).toInt()): Int {\\n        var P = IntArray(N) { it }              // \\uD83D\\uDE42 parent representative of disjoint sets\\n        var L = IntArray(N) { 1 }               // \\uD83E\\uDD25 length of parent representative\\'s set\\n        fun find(x: Int): Int {\\n            if (P[x] == x)\\n                return x\\n            P[x] = find(P[x])\\n            return P[x]\\n        }\\n        fun union(a_: Int, b_: Int) {\\n            var (a, b) = listOf(a_, b_)\\n            a = find(a)\\n            b = find(b)\\n            if (a == b)\\n                return\\n            P[a] = b; L[b] += L[a]  // arbitrary choice\\n        }\\n        var m = mutableMapOf<Int, Int>()  // x,i,j factors of x -> x\\n        for (x in A) {\\n            if (m.contains(x)) union(m[x]!!, x) else m[x] = x      // case 1: x as a factor of itself\\n            for (i in 2..Math.floor(Math.sqrt(x.toDouble())).toInt()) {\\n                if (x % i != 0)\\n                    continue\\n                var j = x / i\\n                if (m.contains(i)) union(m[i]!!, x) else m[i] = x  // case 2: i-th factor of x\\n                if (m.contains(j)) union(m[j]!!, x) else m[j] = x  // case 3: j-th factor of x\\n            }\\n        }\\n        return L.max()!!  // \\uD83C\\uDFAF maximum length of any parent representative\\'s set\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet largestComponentSize = (A, N = 100001, m = {}) => {\\n    let P = [...Array(N).keys()],              // \\uD83D\\uDE42 parent representative of disjoint sets\\n        L = Array(N).fill(1);                  // \\uD83E\\uDD25 length of parent representative\\'s set\\n    let find = x => P[x] = x == P[x] ? P[x] : find(P[x]);\\n    let union = (a, b) => {\\n        a = find(a);\\n        b = find(b);\\n        if (a == b)\\n            return;\\n        P[b] = a;  // arbitrary choice\\n        L[a] += L[b];\\n    }\\n    for (let x of A) {\\n        m[x] ? union(m[x], x) : m[x] = x;      // case 1: x as a factor of itself\\n        for (let i = 2; i * i <= x; ++i) {\\n            if (x % i)\\n                continue;\\n            let j = Math.floor(x / i);\\n            m[i] ? union(m[i], x) : m[i] = x;  // case 2: i-th factor of x\\n            m[j] ? union(m[j], x) : m[j] = x;  // case 3: j-th factor of x\\n        }\\n    }\\n    return Math.max(...L);                     // \\uD83C\\uDFAF maximum length of any parent representative\\'s set\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def largestComponentSize(self, A: List[int], N = 100001) -> int:\\n        m = {}\\n        P = [i for i in range(N)]   # \\uD83D\\uDE42 parent representative of disjoint sets\\n        L = [1] * N                 # \\uD83E\\uDD25 length of parent representative\\'s set\\n        def find(x):\\n            P[x] = P[x] if x == P[x] else find(P[x])\\n            return P[x]\\n        def union(a, b):\\n            a = find(a)\\n            b = find(b)\\n            if a == b:\\n                return\\n            P[b] = a  # arbitrary choice\\n            L[a] += L[b]\\n        for x in A:\\n            m[x] = x if x not in m else m[x]; union(m[x], x)      # case 1: x as a factor of itself\\n            for i in range(2, floor(sqrt(x)) + 1):\\n                if x % i:\\n                    continue\\n                j = x // i\\n                m[i] = x if i not in m else m[i]; union(m[i], x)  # case 2: i-th factor of x\\n                m[j] = x if j not in m else m[j]; union(m[j], x)  # case 3: j-th factor of x\\n        return max(L)  # \\uD83C\\uDFAF maximum length of any parent representative\\'s set\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    using fun = function<int(int)>;\\n    int largestComponentSize(VI& A, int N = 100001, Map m = {}) {\\n        VI P(N); iota(P.begin(), P.end(), 0);               // \\uD83D\\uDE42 parent representative of disjoint sets\\n        VI L(N, 1);                                         // \\uD83E\\uDD25 length of parent representative\\'s set\\n        fun find = [&](auto x) { return P[x] = x == P[x] ? P[x] : find(P[x]); };\\n        auto _union = [&](auto a, auto b) {\\n            a = find(a);\\n            b = find(b);\\n            if (a == b)\\n                return;\\n            P[b] = a;  // arbitrary choice\\n            L[a] += L[b];\\n        };\\n        for (auto x: A) {\\n            if (m[x]) _union(m[x], x); else m[x] = x;      // case 1: x as a factor of itself\\n            for (auto i{ 2 }; i * i <= x; ++i) {\\n                if (x % i)\\n                    continue;\\n                auto j = x / i;\\n                if (m[i]) _union(m[i], x); else m[i] = x;  // case 2: i-th factor of x\\n                if (m[j]) _union(m[j], x); else m[j] = x;  // case 3: j-th factor of x\\n            }\\n        }\\n        return *max_element(L.begin(), L.end());           // \\uD83C\\uDFAF maximum length of any parent representative\\'s set\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun largestComponentSize(A: IntArray, N: Int = (1e5 + 1).toInt()): Int {\\n        var P = IntArray(N) { it }              // \\uD83D\\uDE42 parent representative of disjoint sets\\n        var L = IntArray(N) { 1 }               // \\uD83E\\uDD25 length of parent representative\\'s set\\n        fun find(x: Int): Int {\\n            if (P[x] == x)\\n                return x\\n            P[x] = find(P[x])\\n            return P[x]\\n        }\\n        fun union(a_: Int, b_: Int) {\\n            var (a, b) = listOf(a_, b_)\\n            a = find(a)\\n            b = find(b)\\n            if (a == b)\\n                return\\n            P[a] = b; L[b] += L[a]  // arbitrary choice\\n        }\\n        var m = mutableMapOf<Int, Int>()  // x,i,j factors of x -> x\\n        for (x in A) {\\n            if (m.contains(x)) union(m[x]!!, x) else m[x] = x      // case 1: x as a factor of itself\\n            for (i in 2..Math.floor(Math.sqrt(x.toDouble())).toInt()) {\\n                if (x % i != 0)\\n                    continue\\n                var j = x / i\\n                if (m.contains(i)) union(m[i]!!, x) else m[i] = x  // case 2: i-th factor of x\\n                if (m.contains(j)) union(m[j]!!, x) else m[j] = x  // case 3: j-th factor of x\\n            }\\n        }\\n        return L.max()!!  // \\uD83C\\uDFAF maximum length of any parent representative\\'s set\\n    }\\n}\\n```\n```\\nlet largestComponentSize = (A, N = 100001, m = {}) => {\\n    let P = [...Array(N).keys()],              // \\uD83D\\uDE42 parent representative of disjoint sets\\n        L = Array(N).fill(1);                  // \\uD83E\\uDD25 length of parent representative\\'s set\\n    let find = x => P[x] = x == P[x] ? P[x] : find(P[x]);\\n    let union = (a, b) => {\\n        a = find(a);\\n        b = find(b);\\n        if (a == b)\\n            return;\\n        P[b] = a;  // arbitrary choice\\n        L[a] += L[b];\\n    }\\n    for (let x of A) {\\n        m[x] ? union(m[x], x) : m[x] = x;      // case 1: x as a factor of itself\\n        for (let i = 2; i * i <= x; ++i) {\\n            if (x % i)\\n                continue;\\n            let j = Math.floor(x / i);\\n            m[i] ? union(m[i], x) : m[i] = x;  // case 2: i-th factor of x\\n            m[j] ? union(m[j], x) : m[j] = x;  // case 3: j-th factor of x\\n        }\\n    }\\n    return Math.max(...L);                     // \\uD83C\\uDFAF maximum length of any parent representative\\'s set\\n};\\n```\n```\\nclass Solution:\\n    def largestComponentSize(self, A: List[int], N = 100001) -> int:\\n        m = {}\\n        P = [i for i in range(N)]   # \\uD83D\\uDE42 parent representative of disjoint sets\\n        L = [1] * N                 # \\uD83E\\uDD25 length of parent representative\\'s set\\n        def find(x):\\n            P[x] = P[x] if x == P[x] else find(P[x])\\n            return P[x]\\n        def union(a, b):\\n            a = find(a)\\n            b = find(b)\\n            if a == b:\\n                return\\n            P[b] = a  # arbitrary choice\\n            L[a] += L[b]\\n        for x in A:\\n            m[x] = x if x not in m else m[x]; union(m[x], x)      # case 1: x as a factor of itself\\n            for i in range(2, floor(sqrt(x)) + 1):\\n                if x % i:\\n                    continue\\n                j = x // i\\n                m[i] = x if i not in m else m[i]; union(m[i], x)  # case 2: i-th factor of x\\n                m[j] = x if j not in m else m[j]; union(m[j], x)  # case 3: j-th factor of x\\n        return max(L)  # \\uD83C\\uDFAF maximum length of any parent representative\\'s set\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    using fun = function<int(int)>;\\n    int largestComponentSize(VI& A, int N = 100001, Map m = {}) {\\n        VI P(N); iota(P.begin(), P.end(), 0);               // \\uD83D\\uDE42 parent representative of disjoint sets\\n        VI L(N, 1);                                         // \\uD83E\\uDD25 length of parent representative\\'s set\\n        fun find = [&](auto x) { return P[x] = x == P[x] ? P[x] : find(P[x]); };\\n        auto _union = [&](auto a, auto b) {\\n            a = find(a);\\n            b = find(b);\\n            if (a == b)\\n                return;\\n            P[b] = a;  // arbitrary choice\\n            L[a] += L[b];\\n        };\\n        for (auto x: A) {\\n            if (m[x]) _union(m[x], x); else m[x] = x;      // case 1: x as a factor of itself\\n            for (auto i{ 2 }; i * i <= x; ++i) {\\n                if (x % i)\\n                    continue;\\n                auto j = x / i;\\n                if (m[i]) _union(m[i], x); else m[i] = x;  // case 2: i-th factor of x\\n                if (m[j]) _union(m[j], x); else m[j] = x;  // case 3: j-th factor of x\\n            }\\n        }\\n        return *max_element(L.begin(), L.end());           // \\uD83C\\uDFAF maximum length of any parent representative\\'s set\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 202298,
                "title": "c-84-ms-o-n-65",
                "content": "For each number, we find all prime factors, group these factors using union-find, and count how many numbers are in each group.\\n\\nSince the maximum value is 100,000,  we only need primes till 313 (317 * 317 = 100,489). The intuition here is that we do not need to care about large primes as they won\\'t connect to any other number. So, our union-find structure only needs to have 65 elements.\\n\\nNow, numbers like 2, 3, 401, 802, 1203 are tricky (all in the same group). 802 (2 * 401) adds a previous prime to group \"2\", and 1203 (3 * 401) joins groups \"2\" and \"3\". So, we do need to track large primes, *but only when they appear in the input sequence*.\\n\\nIf after trying all 65 factors the remainder is greater than 1, it\\'s a large prime. We use a hash map to track our large primes and the factor it\\'s \\'connected\\' to.\\n```\\nvector<int> factors = {\\n    2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101,\\n    103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197,\\n    199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313\\n};\\nvoid uf_union(vector<int>& uf, int p1, int p2) {\\n  auto pp1 = uf_find(uf, p1), pp2 = uf_find(uf, p2);\\n  if (pp1 != pp2) uf[pp1] += uf[pp2], uf[pp2] = pp1;\\n}\\nint uf_find(vector<int>& uf, int p) {\\n  if (uf[p] <= 0) return p;\\n  return uf[p] = uf_find(uf, uf[p]);\\n}\\nint largestComponentSize(vector<int>& A) {\\n  unordered_map<int, int> primes;\\n  vector<int> uf(factors.size(), 0);\\n  for (auto a : A) {\\n    auto last_f = -1;\\n    for (auto i = 0; i < factors.size() && factors[i] <= a; ++i) {\\n      if (a % factors[i] == 0) {\\n        while (a % factors[i] == 0) a /= factors[i];\\n        if (last_f >= 0) uf_union(uf, i, last_f);\\n        last_f = i;\\n      }\\n    }\\n    if (a > 1) {\\n      auto it = primes.find(a);\\n      if (it != primes.end()) {\\n        if (last_f != -1 && it->second != -1) uf_union(uf, last_f, it->second);\\n        else if (last_f != -1 || it->second != -1) uf[uf_find(uf, max(last_f, it->second))] -= 1;\\n      }\\n      if (it == primes.end() || last_f >= 0) primes[a] = last_f;\\n    }\\n    if (last_f >= 0) uf[uf_find(uf, last_f)] -= 1;\\n  }\\n  return -*min_element(begin(uf), end(uf));\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> factors = {\\n    2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101,\\n    103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197,\\n    199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313\\n};\\nvoid uf_union(vector<int>& uf, int p1, int p2) {\\n  auto pp1 = uf_find(uf, p1), pp2 = uf_find(uf, p2);\\n  if (pp1 != pp2) uf[pp1] += uf[pp2], uf[pp2] = pp1;\\n}\\nint uf_find(vector<int>& uf, int p) {\\n  if (uf[p] <= 0) return p;\\n  return uf[p] = uf_find(uf, uf[p]);\\n}\\nint largestComponentSize(vector<int>& A) {\\n  unordered_map<int, int> primes;\\n  vector<int> uf(factors.size(), 0);\\n  for (auto a : A) {\\n    auto last_f = -1;\\n    for (auto i = 0; i < factors.size() && factors[i] <= a; ++i) {\\n      if (a % factors[i] == 0) {\\n        while (a % factors[i] == 0) a /= factors[i];\\n        if (last_f >= 0) uf_union(uf, i, last_f);\\n        last_f = i;\\n      }\\n    }\\n    if (a > 1) {\\n      auto it = primes.find(a);\\n      if (it != primes.end()) {\\n        if (last_f != -1 && it->second != -1) uf_union(uf, last_f, it->second);\\n        else if (last_f != -1 || it->second != -1) uf[uf_find(uf, max(last_f, it->second))] -= 1;\\n      }\\n      if (it == primes.end() || last_f >= 0) primes[a] = last_f;\\n    }\\n    if (last_f >= 0) uf[uf_find(uf, last_f)] -= 1;\\n  }\\n  return -*min_element(begin(uf), end(uf));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3785309,
                "title": "c-dfs-uses-linear-sieve-eratosthenes-sieve-prime-number-theory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n2 kinds of sieve methods are implemented,. One is Linear Sieve which has elapsed time only O(M) of the time complexity. The other is the famous Eratosthenes\\' Sieve Method with TC O(M log log M).\\n\\nBased on the Sieve\\'s result, DFS is the algorithm to solve this question. It is doable. Use the similar tricks like the sieve method to build up the adjacent list.\\n\\nPrime Number Theory can be used to reserve the memory allocation and speed up the code.\\n\\nPrime Number Theory says\\nthe number of {primes <=M }~M/log(M)\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n# Visualize Eratosthenes\\' Sieve\\n[https://youtu.be/7GGhURLPnIs](https://youtu.be/7GGhURLPnIs)\\n\\n# Math explains Eratosthenes\\' Sieve\\n[Please Turn on English subtitles if neccessary]\\n[https://youtu.be/GxoMWxXLKMc](https://youtu.be/GxoMWxXLKMc)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(M)$$ where M=max(nums[:])\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(M)$$\\n# Code using Linear Sieve & DFS\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<bool> sieve;\\n    vector<int> prime;\\n    vector<vector<int>> commonFactor;\\n    vector<int> num_state;\\n\\n    void linearSieve(int n) {\\n        sieve.assign(n + 1, false);\\n        prime.reserve((int)(n/log(n)));// Use Prime Number Theory\\n        for (int i = 2; i <= n; i++) {\\n            if (!sieve[i]) prime.push_back(i); // When not sieved, i is a prime\\n            for (int j = 0; i * prime[j] <= n; j++) {\\n                sieve[i * prime[j]] = true;\\n                if (i % prime[j] == 0) break;\\n            }\\n        }\\n    }\\n\\n    void build_commonFactor_path(vector<int>& nums, int M) {\\n        num_state.assign(M + 1, 0);\\n        commonFactor.resize(M + 1, vector<int>());\\n\\n        for (int x : nums)\\n            num_state[x] = 1;\\n\\n        for (int p : prime) {//Probably M/log(M) primes\\n            if (num_state[p] != 1)\\n                num_state[p] = -1;\\n\\n            for (int i = p * 2; i <= M; i += p) {\\n                if (num_state[i] == 1) {\\n                    commonFactor[i].push_back(p);\\n                    commonFactor[p].push_back(i);\\n                }\\n            }\\n        }\\n    }\\n\\n    void dfs(int i, int& sz) {\\n        if (num_state[i] == 1)\\n            sz++;\\n        num_state[i] = 2;\\n\\n        for (int x : commonFactor[i]) {\\n            if (num_state[x] == 1 || num_state[x] == -1) {\\n                dfs(x, sz);\\n            }\\n        }\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n        n = nums.size();\\n        int M = *max_element(nums.begin(), nums.end());\\n        linearSieve(M);\\n        build_commonFactor_path(nums, M);\\n        int ans = 0;\\n        for (int i : nums) {\\n            if (num_state[i] == 1) {\\n                int sz = 0;\\n                dfs(i, sz);\\n                ans = max(ans, sz);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n# Code using Eratosthenes\\' Sieve  with TC O(M log log(M)). In real test, it is faster than the linear Sieve, since M is not large enough\\n```\\n    int n;\\n    vector<int> prime;\\n    vector<vector<int>> commonFactor;\\n    vector<bool> isPrime;\\n    \\n    void Sieve(int n){//TC: O(n log log n)\\n        isPrime.assign(n+1, 1);\\n        isPrime[0]=isPrime[1]=0;\\n        int&& n_sqrt=int(sqrt(n));\\n        for(int i=2; i<=n_sqrt; i++){\\n            if (isPrime[i]){\\n                for(int j=i*i ; j<=n; j+=i)\\n                    isPrime[j]=0;\\n            }\\n        }\\n        prime.reserve((int)(n/log(n)));//Use Prime Number Theory\\n        for(int i=2; i<=n; i++)\\n            if (isPrime[i]) prime.push_back(i);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<bool> sieve;\\n    vector<int> prime;\\n    vector<vector<int>> commonFactor;\\n    vector<int> num_state;\\n\\n    void linearSieve(int n) {\\n        sieve.assign(n + 1, false);\\n        prime.reserve((int)(n/log(n)));// Use Prime Number Theory\\n        for (int i = 2; i <= n; i++) {\\n            if (!sieve[i]) prime.push_back(i); // When not sieved, i is a prime\\n            for (int j = 0; i * prime[j] <= n; j++) {\\n                sieve[i * prime[j]] = true;\\n                if (i % prime[j] == 0) break;\\n            }\\n        }\\n    }\\n\\n    void build_commonFactor_path(vector<int>& nums, int M) {\\n        num_state.assign(M + 1, 0);\\n        commonFactor.resize(M + 1, vector<int>());\\n\\n        for (int x : nums)\\n            num_state[x] = 1;\\n\\n        for (int p : prime) {//Probably M/log(M) primes\\n            if (num_state[p] != 1)\\n                num_state[p] = -1;\\n\\n            for (int i = p * 2; i <= M; i += p) {\\n                if (num_state[i] == 1) {\\n                    commonFactor[i].push_back(p);\\n                    commonFactor[p].push_back(i);\\n                }\\n            }\\n        }\\n    }\\n\\n    void dfs(int i, int& sz) {\\n        if (num_state[i] == 1)\\n            sz++;\\n        num_state[i] = 2;\\n\\n        for (int x : commonFactor[i]) {\\n            if (num_state[x] == 1 || num_state[x] == -1) {\\n                dfs(x, sz);\\n            }\\n        }\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n        n = nums.size();\\n        int M = *max_element(nums.begin(), nums.end());\\n        linearSieve(M);\\n        build_commonFactor_path(nums, M);\\n        int ans = 0;\\n        for (int i : nums) {\\n            if (num_state[i] == 1) {\\n                int sz = 0;\\n                dfs(i, sz);\\n                ans = max(ans, sz);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```\n```\\n    int n;\\n    vector<int> prime;\\n    vector<vector<int>> commonFactor;\\n    vector<bool> isPrime;\\n    \\n    void Sieve(int n){//TC: O(n log log n)\\n        isPrime.assign(n+1, 1);\\n        isPrime[0]=isPrime[1]=0;\\n        int&& n_sqrt=int(sqrt(n));\\n        for(int i=2; i<=n_sqrt; i++){\\n            if (isPrime[i]){\\n                for(int j=i*i ; j<=n; j+=i)\\n                    isPrime[j]=0;\\n            }\\n        }\\n        prime.reserve((int)(n/log(n)));//Use Prime Number Theory\\n        for(int i=2; i<=n; i++)\\n            if (isPrime[i]) prime.push_back(i);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617573,
                "title": "c-union-find",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nint find(int a,vector<int> &p){\\n    if(a == p[a])return a;\\n    return p[a] = find(p[a],p);\\n}\\nvoid unon(int a,int b,vector<int> &s,vector<int> &p){\\n    int x = find(a,p),y = find(b,p);\\n    if(x != y){\\n        if(s[y]<s[x])swap(x,y);\\n        p[x] = y;\\n        s[y] += s[x];\\n    }\\n}\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = 1e5+1,i;\\n        vector<int> s(n),p(n);\\n        for(i = 0; i < n; i++){\\n            s[i] = 1, p[i] = i;\\n        }\\n        for(auto &j: nums){\\n            for(i = 2; i <= sqrt(j); i++){\\n                if(j%i==0){\\n                    unon(i,j,s,p);\\n                    unon(j/i,j,s,p);\\n                }\\n            }\\n        }\\n        n = 0;\\n        unordered_map<int,int> mp;\\n        for(auto &i: nums){\\n            mp[find(i,p)]++;\\n            n = max(n,mp[find(i,p)]);\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Union Find",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint find(int a,vector<int> &p){\\n    if(a == p[a])return a;\\n    return p[a] = find(p[a],p);\\n}\\nvoid unon(int a,int b,vector<int> &s,vector<int> &p){\\n    int x = find(a,p),y = find(b,p);\\n    if(x != y){\\n        if(s[y]<s[x])swap(x,y);\\n        p[x] = y;\\n        s[y] += s[x];\\n    }\\n}\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = 1e5+1,i;\\n        vector<int> s(n),p(n);\\n        for(i = 0; i < n; i++){\\n            s[i] = 1, p[i] = i;\\n        }\\n        for(auto &j: nums){\\n            for(i = 2; i <= sqrt(j); i++){\\n                if(j%i==0){\\n                    unon(i,j,s,p);\\n                    unon(j/i,j,s,p);\\n                }\\n            }\\n        }\\n        n = 0;\\n        unordered_map<int,int> mp;\\n        for(auto &i: nums){\\n            mp[find(i,p)]++;\\n            n = max(n,mp[find(i,p)]);\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724652,
                "title": "c-sieve-of-eratosthenes-normal-dfs-without-dsu",
                "content": "class Solution {\\npublic:\\n\\n\\n    vector<vector<int>> g; // graph\\n    vector<int> isPrime, inArr,vis; // inArr[i] = 1, if i is present in nums\\n    int cnt;\\n    \\n    void dfs(int node){\\n        vis[node] = 1;\\n        if(inArr[node]) cnt++; // count only if element (here node) is present in nums\\n        for(auto &v: g[node]){\\n            if(!vis[v]){\\n                dfs(v);\\n            }\\n        }\\n    }\\n    \\n    void sieve(int n){ // normal sieve\\n        isPrime.assign(n+1,1);\\n        isPrime[0] = isPrime[1] = 0;\\n        for(int i = 2; i*i <= n; i++){\\n            if(isPrime[i]){\\n                for(long long j = i*i; j <= sqrt(n); j += i){\\n                    isPrime[j] = 0;\\n                }\\n            }\\n        }\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n\\t\\n        int maxVal = -1;\\n        for(auto &x: nums) maxVal = max(maxVal,x); // maxvalue in nums\\n        sieve(maxVal+1);\\n\\t\\tg.resize(maxVal+1); \\n        inArr.assign(maxVal+1,0); vis.assign(maxVal+1,0);\\n        \\n        for(auto &x: nums) inArr[x] = 1;\\n        // creating graph\\n        for(int i = 1; i <= maxVal; i++){\\n            if(isPrime[i]){    // connecting nums[i] with its primes\\n                for(long long j = i*2; j <= maxVal; j += i){\\n                    if(inArr[j]){\\n                        g[i].push_back(j);\\n                        g[j].push_back(i);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int ans = -1; \\n        for(auto &x: nums){\\n            if(!vis[x]){\\n                cnt = 0;\\n                dfs(x);\\n                ans = max(ans,cnt); // counting size of maximum sized component\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\nThis method extends the idea of sieve, here the elements of nums are connected with their prime factors and size of connected component is calculated for only those which are present in nums.\\n\\nExample: [4, 6, 15, 35]\\n\\n2: its prime: connect 2 and its multiples (which are present in nums) with it (here 4 and 6)\\n3: its prime: connect 3 and its multiples (which are present in nums) with it (here 6 and 15)\\n5: its prime: connect 5 and its multiples (which are present in nums) with it (here 15 and 35)\\n7: its prime: connect 7 and its multiples (which are present in nums) with it (here 35 only)\\n\\nFinal graph will look like\\n\\n2 -- 4 -- 6 -- 3 -- 15 -- 5 -- 35 -- 7 (or print g for adjacency list view)\\n\\nCount elements which are present in nums to find the maximum size of connected component.",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n\\n    vector<vector<int>> g; // graph\\n    vector<int> isPrime, inArr,vis; // inArr[i] = 1, if i is present in nums\\n    int cnt;\\n    \\n    void dfs(int node){\\n        vis[node] = 1;\\n        if(inArr[node]) cnt++; // count only if element (here node) is present in nums\\n        for(auto &v: g[node]){\\n            if(!vis[v]){\\n                dfs(v);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1592576,
                "title": "python-solution-using-disjoint-set-union-and-prime-factorization",
                "content": "**Time Complexity:** O(N log(M))\\n**Space Complexity:** O(M)\\nwhere N is the number of element and M is the maximum value among all elements\\n\\nTo have a factor greater than 1, two numbers must have common primes in their prime factorization. Using this information, we can merge elements having common primes with Disjoint Set Union\\n\\n```\\nclass DSU:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        self.ranks = [1 for i in range(n)]\\n    \\n    def find(self, u):\\n        if self.parent[u] == u:\\n            return u\\n        self.parent[u] = self.find(self.parent[u])\\n        return self.parent[u]\\n    \\n    def merge(self, u, v):\\n        u, v = self.find(u), self.find(v)\\n        if u == v:\\n            return\\n        \\n        if self.ranks[u] < self.ranks[v]:\\n            u, v = v, u\\n        self.ranks[u] += self.ranks[v]\\n        self.parent[v] = u\\n\\n\\nclass PrimeFactorizer:\\n    def __init__(self, mx):\\n        self.spf = [i for i in range(mx)]\\n        self.mx = mx\\n        self.sieve()\\n    \\n    def sieve(self):\\n        limit = int(sqrt(self.mx)) + 1\\n        \\n        for i in range(2, limit):\\n            if self.spf[i] != i:\\n                continue\\n            for j in range(i*i, self.mx, i):\\n                if self.spf[j] == j:\\n                    self.spf[j] = i\\n    \\n    def getPrimes(self, n):\\n        primes = []\\n        \\n        while n > 1:\\n            prime = self.spf[n]\\n            primes.append(prime)\\n            while n % prime == 0:\\n                n //= prime\\n        \\n        return primes\\n\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        max_num = max(nums)\\n        mp = defaultdict(list)\\n        \\n        dsu = DSU(len(nums))\\n        prime_factorizer = PrimeFactorizer(max_num + 1)\\n        \\n        for idx, num in enumerate(nums):\\n            for prime in prime_factorizer.getPrimes(num):\\n                mp[prime].append(idx)\\n        \\n        for prime in mp:\\n            for i in range(1, len(mp[prime])):\\n                dsu.merge(mp[prime][i], mp[prime][i-1])\\n        \\n        return max(dsu.ranks)\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass DSU:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        self.ranks = [1 for i in range(n)]\\n    \\n    def find(self, u):\\n        if self.parent[u] == u:\\n            return u\\n        self.parent[u] = self.find(self.parent[u])\\n        return self.parent[u]\\n    \\n    def merge(self, u, v):\\n        u, v = self.find(u), self.find(v)\\n        if u == v:\\n            return\\n        \\n        if self.ranks[u] < self.ranks[v]:\\n            u, v = v, u\\n        self.ranks[u] += self.ranks[v]\\n        self.parent[v] = u\\n\\n\\nclass PrimeFactorizer:\\n    def __init__(self, mx):\\n        self.spf = [i for i in range(mx)]\\n        self.mx = mx\\n        self.sieve()\\n    \\n    def sieve(self):\\n        limit = int(sqrt(self.mx)) + 1\\n        \\n        for i in range(2, limit):\\n            if self.spf[i] != i:\\n                continue\\n            for j in range(i*i, self.mx, i):\\n                if self.spf[j] == j:\\n                    self.spf[j] = i\\n    \\n    def getPrimes(self, n):\\n        primes = []\\n        \\n        while n > 1:\\n            prime = self.spf[n]\\n            primes.append(prime)\\n            while n % prime == 0:\\n                n //= prime\\n        \\n        return primes\\n\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        max_num = max(nums)\\n        mp = defaultdict(list)\\n        \\n        dsu = DSU(len(nums))\\n        prime_factorizer = PrimeFactorizer(max_num + 1)\\n        \\n        for idx, num in enumerate(nums):\\n            for prime in prime_factorizer.getPrimes(num):\\n                mp[prime].append(idx)\\n        \\n        for prime in mp:\\n            for i in range(1, len(mp[prime])):\\n                dsu.merge(mp[prime][i], mp[prime][i-1])\\n        \\n        return max(dsu.ranks)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592297,
                "title": "brute-force-to-optimal-c-simple-to-understand",
                "content": "1) **Brute Force colution** :\\n\\t\\n* \\tFind the greatest common divisors between two values.\\n* \\tIf GCD is greater than 1, then merge it \\n* \\tDo DFS for all unvisited value, print the maximum count of component.\\n```\\nclass Solution {\\n    private :\\n    int findGCD(int a, int b)\\n    {\\n        if(a == 0)\\n            return b;\\n        \\n        return findGCD(b%a, a);\\n    }\\n        \\n    \\n    bool isCommon(int u, int v)\\n    {\\n        // find gcd \\n        int gcd = findGCD(u, v);\\n        \\n        // gcd should be > 1\\n        return gcd > 1;\\n    }\\n    \\n    void dfs(int u, vector<int> adj[], int &curCount, vector<bool> &vis)\\n    {\\n        curCount++;\\n        \\n        vis[u] = true;\\n        \\n        for(auto v : adj[u])\\n        {\\n            if(!vis[v])\\n            {\\n                dfs(v, adj, curCount, vis);\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        vector<int> adj[n];\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i + 1; j < n; j++)\\n            {\\n                // if both values have common value, then add it to adjacent\\n                if(isCommon(nums[i], nums[j]))\\n                {\\n                    adj[i].push_back(j);\\n                    adj[j].push_back(i);\\n                }\\n            }\\n        }\\n        \\n        vector<bool> vis(n, false);\\n        int maxi = 0;\\n        \\n        // do dfs to find size of each component and print the maxi\\n        for(int i = 0; i < n; i++)\\n        {\\n           if(!vis[i])\\n           {\\n               int curCount = 0;\\n               \\n               dfs(i, adj, curCount, vis);\\n               \\n               maxi = max(maxi, curCount);\\n           }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```\\n\\n2) Optimal solution (using union-find algorithm)\\n\\n```\\nclass DSU\\n{\\n    private:\\n    vector<int> parent;\\n    \\n    public:\\n    DSU(int n)\\n    {\\n        for(int i = 0; i < n; i++)\\n        {\\n            parent.push_back(i);\\n        }\\n    }\\n    \\n    int findParent(int node)\\n    {\\n        if(parent[node] == node)\\n            return node;\\n        \\n        return parent[node] = findParent(parent[node]);\\n    }\\n    \\n    void _union(int u, int v)\\n    {\\n        int uParent = findParent(u);\\n        int vParent = findParent(v);\\n        \\n        if(uParent != vParent)\\n            parent[uParent] = parent[vParent];\\n    }\\n};\\n\\nclass Solution {\\n  \\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        \\n        int n = *max_element(nums.begin(), nums.end());\\n         \\n        DSU dsu(n+1);\\n        \\n        // do union for each element with all of the element\\'s factors\\n        for(auto &val : nums)\\n        {\\n            for(int i = 2; i * i <= val; i++)\\n            {\\n                if(val % i == 0)\\n                {\\n                    dsu._union(val, i);\\n                    dsu._union(val, val/i);\\n                    \\n                }\\n            }\\n        }\\n        \\n        \\n        unordered_map<int,int> mp;\\n        int res = 1;\\n        \\n        // count the number of parent for each value\\n        for(auto val : nums)\\n        {\\n            res = max(res, ++mp[dsu.findParent(val)]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    private :\\n    int findGCD(int a, int b)\\n    {\\n        if(a == 0)\\n            return b;\\n        \\n        return findGCD(b%a, a);\\n    }\\n        \\n    \\n    bool isCommon(int u, int v)\\n    {\\n        // find gcd \\n        int gcd = findGCD(u, v);\\n        \\n        // gcd should be > 1\\n        return gcd > 1;\\n    }\\n    \\n    void dfs(int u, vector<int> adj[], int &curCount, vector<bool> &vis)\\n    {\\n        curCount++;\\n        \\n        vis[u] = true;\\n        \\n        for(auto v : adj[u])\\n        {\\n            if(!vis[v])\\n            {\\n                dfs(v, adj, curCount, vis);\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        vector<int> adj[n];\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i + 1; j < n; j++)\\n            {\\n                // if both values have common value, then add it to adjacent\\n                if(isCommon(nums[i], nums[j]))\\n                {\\n                    adj[i].push_back(j);\\n                    adj[j].push_back(i);\\n                }\\n            }\\n        }\\n        \\n        vector<bool> vis(n, false);\\n        int maxi = 0;\\n        \\n        // do dfs to find size of each component and print the maxi\\n        for(int i = 0; i < n; i++)\\n        {\\n           if(!vis[i])\\n           {\\n               int curCount = 0;\\n               \\n               dfs(i, adj, curCount, vis);\\n               \\n               maxi = max(maxi, curCount);\\n           }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```\n```\\nclass DSU\\n{\\n    private:\\n    vector<int> parent;\\n    \\n    public:\\n    DSU(int n)\\n    {\\n        for(int i = 0; i < n; i++)\\n        {\\n            parent.push_back(i);\\n        }\\n    }\\n    \\n    int findParent(int node)\\n    {\\n        if(parent[node] == node)\\n            return node;\\n        \\n        return parent[node] = findParent(parent[node]);\\n    }\\n    \\n    void _union(int u, int v)\\n    {\\n        int uParent = findParent(u);\\n        int vParent = findParent(v);\\n        \\n        if(uParent != vParent)\\n            parent[uParent] = parent[vParent];\\n    }\\n};\\n\\nclass Solution {\\n  \\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        \\n        int n = *max_element(nums.begin(), nums.end());\\n         \\n        DSU dsu(n+1);\\n        \\n        // do union for each element with all of the element\\'s factors\\n        for(auto &val : nums)\\n        {\\n            for(int i = 2; i * i <= val; i++)\\n            {\\n                if(val % i == 0)\\n                {\\n                    dsu._union(val, i);\\n                    dsu._union(val, val/i);\\n                    \\n                }\\n            }\\n        }\\n        \\n        \\n        unordered_map<int,int> mp;\\n        int res = 1;\\n        \\n        // count the number of parent for each value\\n        for(auto val : nums)\\n        {\\n            res = max(res, ++mp[dsu.findParent(val)]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1449216,
                "title": "c-union-find-sieve",
                "content": "Interesting Union Find Problems: \\n\\n- [959. Regions Cut By Slashes](https://leetcode.com/problems/regions-cut-by-slashes/) [Medium] \\n- [947. Most Stones Removed with Same Row or Column](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/) [Medium]\\n- [990. Satisfiability of Equality Equations](https://leetcode.com/problems/satisfiability-of-equality-equations/) [Medium]\\n- [952. Largest Component Size by Common Factor](https://leetcode.com/problems/largest-component-size-by-common-factor/) [Hard] - current question\\n- [1627. Graph Connectivity With Threshold](https://leetcode.com/problems/graph-connectivity-with-threshold/) [Hard]\\n- [1998. GCD Sort of an Array](https://leetcode.com/problems/gcd-sort-of-an-array/) [Hard]\\n\\n```\\nclass UnionFind {\\n    vector<int> parent, size;\\npublic:\\n    UnionFind(int n) {\\n        parent.resize(n); size.resize(n);\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i, size[i] = 1;\\n        }\\n    }\\n    \\n    int Find(int x) {\\n        if (x == parent[x]) return x;\\n        return parent[x] = Find(parent[x]); // Path compression\\n    }\\n    \\n    bool Union(int u, int v) {\\n        int pu = Find(u), pv = Find(v);\\n        if (pu == pv) return false; // Return False if u and v are already part of the same component\\n        if (size[pu] > size[pv]) { // Union by larger size\\n            size[pu] += size[pv];\\n            parent[pv] = pu;\\n        } else {\\n            size[pv] += size[pu];\\n            parent[pu] = pv;\\n        }\\n        return true;\\n    }\\n    \\n    int getComponentSize(int x) {\\n        return size[Find(x)];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> spf; // spf[x] is the smallest prime factor of number x, where x >= 2\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int maxNum = *max_element(nums.begin(), nums.end());\\n        UnionFind uf(maxNum + 1);\\n        sieve(maxNum);\\n        \\n        for (int x : nums) {\\n            for (int pf : getPrimeFactors(x)) {\\n                uf.Union(pf, x);\\n            }\\n        }\\n        \\n        int res = 1; // max_component_size\\n        map<int, int> component_size;\\n        for (int x : nums) {\\n            int parent = uf.Find(x);\\n            component_size[parent]++;\\n            res = max(res, component_size[parent]);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    void sieve(int n) {\\n        spf.resize(n+1);\\n        for (int i = 2; i <= n; ++i)\\n            spf[i] = i;\\n\\n        for (int i = 2; i * i <= n; i++) {\\n            if (spf[i] != i) continue; // skip if `i` is not a prime number\\n            for (int j = 2*i; j <= n; j += i) {\\n                if (spf[j] > i) { \\n                    spf[j] = i;\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<int> getPrimeFactors(int n) { // O(logN)\\n        vector<int> factors;\\n        while (n > 1) {\\n            factors.push_back(spf[n]);\\n            int s = spf[n]; // smallest prime factor\\n            while (n % s == 0) { n /= s;}\\n        }\\n        return factors;\\n    }\\n    \\n};\\n```\\n\\nReferences: \\n- https://leetcode.com/problems/gcd-sort-of-an-array/discuss/1445180/C%2B%2BPython-Union-Find-and-Sieve-and-Sorting-Clean-and-Concise\\n",
                "solutionTags": [],
                "code": "```\\nclass UnionFind {\\n    vector<int> parent, size;\\npublic:\\n    UnionFind(int n) {\\n        parent.resize(n); size.resize(n);\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i, size[i] = 1;\\n        }\\n    }\\n    \\n    int Find(int x) {\\n        if (x == parent[x]) return x;\\n        return parent[x] = Find(parent[x]); // Path compression\\n    }\\n    \\n    bool Union(int u, int v) {\\n        int pu = Find(u), pv = Find(v);\\n        if (pu == pv) return false; // Return False if u and v are already part of the same component\\n        if (size[pu] > size[pv]) { // Union by larger size\\n            size[pu] += size[pv];\\n            parent[pv] = pu;\\n        } else {\\n            size[pv] += size[pu];\\n            parent[pu] = pv;\\n        }\\n        return true;\\n    }\\n    \\n    int getComponentSize(int x) {\\n        return size[Find(x)];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> spf; // spf[x] is the smallest prime factor of number x, where x >= 2\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int maxNum = *max_element(nums.begin(), nums.end());\\n        UnionFind uf(maxNum + 1);\\n        sieve(maxNum);\\n        \\n        for (int x : nums) {\\n            for (int pf : getPrimeFactors(x)) {\\n                uf.Union(pf, x);\\n            }\\n        }\\n        \\n        int res = 1; // max_component_size\\n        map<int, int> component_size;\\n        for (int x : nums) {\\n            int parent = uf.Find(x);\\n            component_size[parent]++;\\n            res = max(res, component_size[parent]);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    void sieve(int n) {\\n        spf.resize(n+1);\\n        for (int i = 2; i <= n; ++i)\\n            spf[i] = i;\\n\\n        for (int i = 2; i * i <= n; i++) {\\n            if (spf[i] != i) continue; // skip if `i` is not a prime number\\n            for (int j = 2*i; j <= n; j += i) {\\n                if (spf[j] > i) { \\n                    spf[j] = i;\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<int> getPrimeFactors(int n) { // O(logN)\\n        vector<int> factors;\\n        while (n > 1) {\\n            factors.push_back(spf[n]);\\n            int s = spf[n]; // smallest prime factor\\n            while (n % s == 0) { n /= s;}\\n        }\\n        return factors;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467052,
                "title": "c-easy-understanding-union-find-solution",
                "content": "\\tclass dsu{\\n\\t\\tpublic:\\n\\t\\tvector<int> arr;\\n\\t\\tdsu(int n):arr(n){\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tarr[i]=i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t\\tvoid merge(int a, int b){\\n\\t\\t\\tarr[find(arr[a])]=arr[find(arr[b])];\\n\\t\\t}\\n\\n\\n\\t\\tint find(int x){\\n\\t\\t\\tif(arr[x]!=x){\\n\\t\\t\\t\\tarr[x]=find(arr[x]);\\n\\t\\t\\t}\\n\\t\\t\\treturn arr[x];\\n\\t\\t}\\n\\n\\n\\t};\\n\\tclass Solution {\\n\\n\\tpublic:\\n\\t\\tint largestComponentSize(vector<int>& A) {\\n\\t\\t\\tint n=*max_element(A.begin(),A.end());\\n\\t\\t\\tdsu DSU(n+1);\\n\\t\\t\\tfor(auto x:A){\\n\\t\\t\\t\\tint temp=sqrt(x);\\n\\t\\t\\t\\tfor(int k=2;k<=temp;k++){\\n\\t\\t\\t\\t\\tif(x%k==0){\\n\\t\\t\\t\\t\\t\\tDSU.merge(x,k);\\n\\t\\t\\t\\t\\t\\tDSU.merge(x,x/k);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tunordered_map<int,int> m;\\n\\t\\t\\tint res=1;\\n\\t\\t\\tfor(auto v:A){\\n\\t\\t\\t\\tm[DSU.find(v)]+=1;\\n\\t\\t\\t\\tres=max(res,m[DSU.find(v)]);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "class Solution {\\n\\n\\tpublic:\\n\\t\\tint largestComponentSize(vector<int>& A) {\\n\\t\\t\\tint n=*max_element(A.begin(),A.end());\\n\\t\\t\\tdsu DSU(n+1);\\n\\t\\t\\tfor(auto x:A){\\n\\t\\t\\t\\tint temp=sqrt(x);\\n\\t\\t\\t\\tfor(int k=2;k<=temp;k++){\\n\\t\\t\\t\\t\\tif(x%k==0){\\n\\t\\t\\t\\t\\t\\tDSU.merge(x,k);\\n\\t\\t\\t\\t\\t\\tDSU.merge(x,x/k);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3529307,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int arr[(int)(1e5+5)];\\n    int visit[(int)(1e5+5)]={0};\\n    int member[(int)(1e5+5)];\\n    constexpr void build(vector<int>& primes, pair<int,int>* sp, int N){\\n        if(primes.empty()){\\n            visit[0] = visit[1] = 1;\\n            sp[1].first = sp[1].second = 1;\\n            for(int i=2;i<=1e5;i++){\\n                if(!visit[i]){\\n                    primes.push_back(i);\\n                    sp[i].first=i;\\n                    sp[i].second = i;\\n                }for (int j=0; i*primes[j]<=1e5; j++){\\n                     visit[i*primes[j]] = 1;\\n                     sp[i*primes[j]].first = primes[j];\\n                     sp[i*primes[j]].second = sp[i].first == primes[j] ? sp[i].second : i;\\n                     if(i%primes[j]==0)break;\\n                 }\\n            }\\n        }\\n        for(int i=0;i<=N;i++){\\n            arr[i] = i;\\n        }\\n    }\\n    int find(int x){\\n        while(arr[x]!=x)\\n            x=arr[x];\\n        return x;\\n    }\\n    void uni(int x, int y){\\n        x = find(x), y = find(y);\\n        if(x==y)return;\\n        member[y]+=member[x];\\n        member[x]=0;\\n        arr[x] = y;\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n        static vector<int> primes;\\n        static pair<int,int> sp[(int)(1e5+5)];\\n        build(primes, sp, *max_element(nums.begin(),nums.end()));\\n        int ans=1;\\n        for(auto& it:nums){\\n            int pre=sp[it].first;\\n            it = sp[it].second;\\n            while(it!=sp[it].first){\\n                uni(sp[it].first, pre);\\n                pre = sp[it].first;\\n                it = sp[it].second;\\n            }\\n            uni(sp[it].first, pre);\\n            member[find(pre)]++;\\n            ans = max(member[find(pre)], ans);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nMAXN = 10**5 + 5\\nspf = list(range(MAXN))\\n\\ndef sieve():\\n\\tspf[1] = 1\\n\\n\\tfor i in range(4, MAXN, 2):\\n\\t\\tspf[i] = 2\\n\\n\\tfor i in range(3, ceil(sqrt(MAXN))):\\n\\t\\tif (spf[i] == i):\\n\\t\\t\\tfor j in range(i * i, MAXN, i):\\n\\t\\t\\t\\tif (spf[j] == j):\\n\\t\\t\\t\\t\\tspf[j] = i\\n\\ndef factors(x: int):\\n\\tfactors_set = set()\\n\\n\\twhile x != 1:\\n\\t\\tfactors_set.add(spf[x])\\n\\t\\tx //= spf[x]\\n\\n\\treturn factors_set\\n\\nsieve()\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        df = {}\\n        uf = UnionFind(len(nums))\\n        for pos, num in enumerate(nums):\\n            for factor in factors(num):\\n                if factor in df:\\n                    uf.union(pos, df[factor])\\n                else:\\n                    df[factor] = pos\\n                    \\n        return uf.mx\\n            \\nclass UnionFind:\\n    def __init__(self, n: int):\\n        self.root_lookup = list(range(n))\\n        self.rank_lookup = [1] * n\\n        self.mx = 1\\n\\n    def find(self, num: int):\\n        root = self.root_lookup[num]\\n        while root != self.root_lookup[root]:\\n              root = self.root_lookup[root]\\n        self.root_lookup[num] = root\\n        return root\\n    \\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        if xr == yr:\\n            return False\\n        if self.rank_lookup[xr] < self.rank_lookup[yr]:\\n            xr, yr = yr, xr\\n        self.root_lookup[yr] = xr\\n        self.rank_lookup[xr] += self.rank_lookup[yr]\\n        self.mx = max(self.mx,self.rank_lookup[xr])\\n        return True\\n```\\n\\n```Java []\\nclass Solution {\\n    public int gcd(int a, int b) {\\n        if(a < b) {\\n            int h = a;\\n            a = b;\\n            b = h;\\n        }\\n        while(b > 0) {\\n            int h = b;\\n            b = a % b;\\n            a = h;\\n        }\\n        return a;\\n    }\\n    public int largestComponentSize(int[] nums) {\\n        int n = nums.length;\\n        int max = 1;\\n        for(int num : nums) {\\n            max = Math.max(max, num);\\n        }\\n        int[] m = new int[max + 1];\\n        Arrays.fill(m, -1);\\n        boolean[] check = new boolean[max + 1];\\n        for(int i = 0; i < n; i++) {\\n            m[nums[i]] = i;\\n        }\\n        UnionFind uf = new UnionFind(n);\\n        for(int p = 2; p <= max; p++) {\\n            if(check[p])\\n                continue;\\n\\n            int first = -1;\\n            for(int div = p; div <= max; div += p) {\\n                if(m[div] >= 0) {\\n                    if(first == -1) {\\n                        first = m[div];\\n                    } else {\\n                        uf.join(first, m[div]);\\n                    }\\n                }\\n                check[div] = true;\\n            }\\n        }\\n        return uf.getMaxComponent();\\n    }\\n}\\npublic class UnionFind {\\n    private int[] parent;\\n    private int[] size;\\n    private int maxSize;\\n\\n    public UnionFind(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        maxSize = 1;\\n\\n        for(int i = 0; i < n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    public int find(int x) {\\n        return x != parent[x] ? parent[x] = find(parent[x]) : x;\\n    }\\n    public void join(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n\\n        if(x != y) {\\n            if(size[x] < size[y]) {\\n                int h = x;\\n                x = y;\\n                y = h;\\n            }\\n            size[x] += size[y];\\n            maxSize = Math.max(maxSize, size[x]);\\n            parent[y] = x;\\n        }\\n    }\\n    public int getMaxComponent() {\\n        return maxSize;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int arr[(int)(1e5+5)];\\n    int visit[(int)(1e5+5)]={0};\\n    int member[(int)(1e5+5)];\\n    constexpr void build(vector<int>& primes, pair<int,int>* sp, int N){\\n        if(primes.empty()){\\n            visit[0] = visit[1] = 1;\\n            sp[1].first = sp[1].second = 1;\\n            for(int i=2;i<=1e5;i++){\\n                if(!visit[i]){\\n                    primes.push_back(i);\\n                    sp[i].first=i;\\n                    sp[i].second = i;\\n                }for (int j=0; i*primes[j]<=1e5; j++){\\n                     visit[i*primes[j]] = 1;\\n                     sp[i*primes[j]].first = primes[j];\\n                     sp[i*primes[j]].second = sp[i].first == primes[j] ? sp[i].second : i;\\n                     if(i%primes[j]==0)break;\\n                 }\\n            }\\n        }\\n        for(int i=0;i<=N;i++){\\n            arr[i] = i;\\n        }\\n    }\\n    int find(int x){\\n        while(arr[x]!=x)\\n            x=arr[x];\\n        return x;\\n    }\\n    void uni(int x, int y){\\n        x = find(x), y = find(y);\\n        if(x==y)return;\\n        member[y]+=member[x];\\n        member[x]=0;\\n        arr[x] = y;\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n        static vector<int> primes;\\n        static pair<int,int> sp[(int)(1e5+5)];\\n        build(primes, sp, *max_element(nums.begin(),nums.end()));\\n        int ans=1;\\n        for(auto& it:nums){\\n            int pre=sp[it].first;\\n            it = sp[it].second;\\n            while(it!=sp[it].first){\\n                uni(sp[it].first, pre);\\n                pre = sp[it].first;\\n                it = sp[it].second;\\n            }\\n            uni(sp[it].first, pre);\\n            member[find(pre)]++;\\n            ans = max(member[find(pre)], ans);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nMAXN = 10**5 + 5\\nspf = list(range(MAXN))\\n\\ndef sieve():\\n\\tspf[1] = 1\\n\\n\\tfor i in range(4, MAXN, 2):\\n\\t\\tspf[i] = 2\\n\\n\\tfor i in range(3, ceil(sqrt(MAXN))):\\n\\t\\tif (spf[i] == i):\\n\\t\\t\\tfor j in range(i * i, MAXN, i):\\n\\t\\t\\t\\tif (spf[j] == j):\\n\\t\\t\\t\\t\\tspf[j] = i\\n\\ndef factors(x: int):\\n\\tfactors_set = set()\\n\\n\\twhile x != 1:\\n\\t\\tfactors_set.add(spf[x])\\n\\t\\tx //= spf[x]\\n\\n\\treturn factors_set\\n\\nsieve()\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        df = {}\\n        uf = UnionFind(len(nums))\\n        for pos, num in enumerate(nums):\\n            for factor in factors(num):\\n                if factor in df:\\n                    uf.union(pos, df[factor])\\n                else:\\n                    df[factor] = pos\\n                    \\n        return uf.mx\\n            \\nclass UnionFind:\\n    def __init__(self, n: int):\\n        self.root_lookup = list(range(n))\\n        self.rank_lookup = [1] * n\\n        self.mx = 1\\n\\n    def find(self, num: int):\\n        root = self.root_lookup[num]\\n        while root != self.root_lookup[root]:\\n              root = self.root_lookup[root]\\n        self.root_lookup[num] = root\\n        return root\\n    \\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        if xr == yr:\\n            return False\\n        if self.rank_lookup[xr] < self.rank_lookup[yr]:\\n            xr, yr = yr, xr\\n        self.root_lookup[yr] = xr\\n        self.rank_lookup[xr] += self.rank_lookup[yr]\\n        self.mx = max(self.mx,self.rank_lookup[xr])\\n        return True\\n```\n```Java []\\nclass Solution {\\n    public int gcd(int a, int b) {\\n        if(a < b) {\\n            int h = a;\\n            a = b;\\n            b = h;\\n        }\\n        while(b > 0) {\\n            int h = b;\\n            b = a % b;\\n            a = h;\\n        }\\n        return a;\\n    }\\n    public int largestComponentSize(int[] nums) {\\n        int n = nums.length;\\n        int max = 1;\\n        for(int num : nums) {\\n            max = Math.max(max, num);\\n        }\\n        int[] m = new int[max + 1];\\n        Arrays.fill(m, -1);\\n        boolean[] check = new boolean[max + 1];\\n        for(int i = 0; i < n; i++) {\\n            m[nums[i]] = i;\\n        }\\n        UnionFind uf = new UnionFind(n);\\n        for(int p = 2; p <= max; p++) {\\n            if(check[p])\\n                continue;\\n\\n            int first = -1;\\n            for(int div = p; div <= max; div += p) {\\n                if(m[div] >= 0) {\\n                    if(first == -1) {\\n                        first = m[div];\\n                    } else {\\n                        uf.join(first, m[div]);\\n                    }\\n                }\\n                check[div] = true;\\n            }\\n        }\\n        return uf.getMaxComponent();\\n    }\\n}\\npublic class UnionFind {\\n    private int[] parent;\\n    private int[] size;\\n    private int maxSize;\\n\\n    public UnionFind(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        maxSize = 1;\\n\\n        for(int i = 0; i < n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    public int find(int x) {\\n        return x != parent[x] ? parent[x] = find(parent[x]) : x;\\n    }\\n    public void join(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n\\n        if(x != y) {\\n            if(size[x] < size[y]) {\\n                int h = x;\\n                x = y;\\n                y = h;\\n            }\\n            size[x] += size[y];\\n            maxSize = Math.max(maxSize, size[x]);\\n            parent[y] = x;\\n        }\\n    }\\n    public int getMaxComponent() {\\n        return maxSize;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645270,
                "title": "union-by-size-prime-factorization",
                "content": "# Intuition  \\nLargest component by size => Union by size\\nShares common factor => we need to check all prime factors\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMake a hash table of integer , set.\\nIn the hash table the key will be the array element (unique)\\nand value will be a set of all prime factors of it.\\nThen union each array elements with it\\'s prime factors.\\n\\nused sieve of eratosthenes to generate all prime factors in logn.\\nAt first for each array elements size[element] = 1 and\\nsize of all other numbers will be 0.  So after union size of prime factors will not be counted.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n * max number of prime factors among all nums[i]) + O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:   O( max( nums[ i ] ) )\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int parent [];\\n    int size [];\\n    public int largestComponentSize(int[] nums) {\\n     int max = nums[0] ;\\n     HashMap<Integer,HashSet<Integer>> primeFactors = new HashMap<>();\\n     for(int val : nums)   max = Math.max(max,val);\\n     int seive [] = new int[max + 1];\\n     parent = new int[max + 1];\\n     size  = new int[max + 1];\\n\\n     for(int i = 0; i < seive.length ; i++)   parent[i] = seive[i] = i;\\n\\n     for(int i = 2; i*i < seive.length ; i++){\\n         if(seive[i] == i){\\n             for(int j = i; j < seive.length ; j+=i){\\n                 if(seive[j] == j) seive[j] = i;\\n             }\\n         }\\n     }\\n\\n     for(int i = 0; i < nums.length ; i++){\\n         int val = nums[i];\\n         size[val] = 1;\\n         HashSet<Integer> set = new HashSet<>();\\n        addFactors(val,seive,set);\\n         primeFactors.put(val,set);\\n     }\\n\\n\\n\\n\\n         for(int val : nums){\\n             for(int fac : primeFactors.get(val)){\\n             if(val % fac == 0){\\n                 if(findparent(fac) != findparent(val)) {\\n                  union(fac , val);\\n                 }\\n             }\\n         }\\n         }\\n     \\n\\n    \\n            int ans = 1;\\n            for(int val : size) {\\n                ans = Math.max(ans,val);\\n            }\\n            return ans;\\n     \\n\\n    }\\n\\n    public int findparent(int node){\\n         if(parent[node] == node) return node;\\n         return parent[node] = findparent(parent[node]);\\n    }\\n\\n    public void union(int u , int v){\\n      u = findparent(u);\\n      v = findparent(v);\\n      if(size[u] > size[v]){\\n          parent[v] = u;\\n          size[u]+=size[v];\\n      }else {\\n        parent[u] = v;\\n          size[v]+=size[u];\\n      }\\n    }\\n\\n    public void addFactors(int val, int seive [] , HashSet<Integer> set){\\n          while(val > 1){\\n              set.add(seive[val]);\\n              val = val/seive[val];\\n          }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int parent [];\\n    int size [];\\n    public int largestComponentSize(int[] nums) {\\n     int max = nums[0] ;\\n     HashMap<Integer,HashSet<Integer>> primeFactors = new HashMap<>();\\n     for(int val : nums)   max = Math.max(max,val);\\n     int seive [] = new int[max + 1];\\n     parent = new int[max + 1];\\n     size  = new int[max + 1];\\n\\n     for(int i = 0; i < seive.length ; i++)   parent[i] = seive[i] = i;\\n\\n     for(int i = 2; i*i < seive.length ; i++){\\n         if(seive[i] == i){\\n             for(int j = i; j < seive.length ; j+=i){\\n                 if(seive[j] == j) seive[j] = i;\\n             }\\n         }\\n     }\\n\\n     for(int i = 0; i < nums.length ; i++){\\n         int val = nums[i];\\n         size[val] = 1;\\n         HashSet<Integer> set = new HashSet<>();\\n        addFactors(val,seive,set);\\n         primeFactors.put(val,set);\\n     }\\n\\n\\n\\n\\n         for(int val : nums){\\n             for(int fac : primeFactors.get(val)){\\n             if(val % fac == 0){\\n                 if(findparent(fac) != findparent(val)) {\\n                  union(fac , val);\\n                 }\\n             }\\n         }\\n         }\\n     \\n\\n    \\n            int ans = 1;\\n            for(int val : size) {\\n                ans = Math.max(ans,val);\\n            }\\n            return ans;\\n     \\n\\n    }\\n\\n    public int findparent(int node){\\n         if(parent[node] == node) return node;\\n         return parent[node] = findparent(parent[node]);\\n    }\\n\\n    public void union(int u , int v){\\n      u = findparent(u);\\n      v = findparent(v);\\n      if(size[u] > size[v]){\\n          parent[v] = u;\\n          size[u]+=size[v];\\n      }else {\\n        parent[u] = v;\\n          size[v]+=size[u];\\n      }\\n    }\\n\\n    public void addFactors(int val, int seive [] , HashSet<Integer> set){\\n          while(val > 1){\\n              set.add(seive[val]);\\n              val = val/seive[val];\\n          }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593686,
                "title": "c-union-find-every-line-explained",
                "content": "* Idea is to have multiple sets for each factor i.e. one set which has all numbers divisible by 2, one set with all numbers divisible by 3 etc.\\n* Once we encounter any number which is divisible by say 2 and 3, we join the two sets (i.e. set for factor 2 and set for factor 3)\\n* At the end we return the set with max numbers in it.\\n```\\npublic class Solution {\\n    Dictionary<int, int> dict = new Dictionary<int, int>(); // key is the factor, value is index of first num with that factor\\n    UnionFind uf;                                           // unionfind will maintain multiple sets for each factor\\n    public int LargestComponentSize(int[] nums) {\\n        var n = nums.Length;\\n        uf = new UnionFind(n);\\n        \\n        for (int i = 0; i < n; i++){                    // for each number in input array\\n            var num = nums[i];                          // the current number we are processing\\n            StartNewSetOrJoin(num, i, num);             // the number is a factor of itself\\n            for (int j = 2; j*j <= num; j++){           // j*j <= num because we want to only check factors till square root of num\\n                if (num % j == 0){                      // if j is a factor of num\\n                    StartNewSetOrJoin(num, i, j);       // add current num to set of factor j\\n                    StartNewSetOrJoin(num, i, num/j);   // obviously num/j is also a factor of num \\n                }\\n            }\\n        }\\n        \\n        return uf.max;\\n    }\\n    \\n    private void StartNewSetOrJoin(int num, int numIdx, int factor){\\n        if (!dict.ContainsKey(factor)){         // no number has had this factor yet\\n            dict[factor] = numIdx;              // so a new set starts with current number\\n        }else{                                  // if there is already a set with current factor as parent\\n            uf.Union(numIdx, dict[factor]);     // join current number with that set\\n        }\\n    }\\n}\\n\\n\\npublic class UnionFind{\\n    int[] parent;                           // it stores index of first node in a set\\n    int[] size;                             // keeps track of size of a set\\n    public int max;                         // this we maintain so that we don\\'t have to do a loop later to get biggest set\\n    \\n    public UnionFind(int n){\\n        parent = new int[n];\\n        size = new int[n];\\n        max = 1;                            // all disjoint sets have one node\\n        for(int i=0; i<n; i++){\\n            parent[i] = i;                  // all are self parent initially\\n            size[i] = 1;                    // size of all disjoint sets is 1 initially\\n        }\\n    }\\n    \\n    public int Find(int n){\\n        if(parent[n] != n)                  // if there are multiple nodes in current set\\n            parent[n] = Find(parent[n]);    // find parent node of the set\\n        return parent[n];                   // and then return the parent\\n    }\\n    \\n    public void Union(int n1, int n2){\\n        var n1_p = Find(n1);                // find parent of number 1\\n        var n2_p = Find(n2);                // find parent of number 2\\n        if(n1_p != n2_p){                   // if parent of number 1 and number 2 are not same, then we need to join two sets\\n            parent[n1_p] = n2_p;            // make n2\\'s parent as common parent for both sets. ideally smaller set should update its parent\\n            size[n2_p] += size[n1_p];       // update size of the merged set\\n            max = Math.Max(max, size[n2_p]);// update the max size of any set\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\npublic class Solution {\\n    Dictionary<int, int> dict = new Dictionary<int, int>(); // key is the factor, value is index of first num with that factor\\n    UnionFind uf;                                           // unionfind will maintain multiple sets for each factor\\n    public int LargestComponentSize(int[] nums) {\\n        var n = nums.Length;\\n        uf = new UnionFind(n);\\n        \\n        for (int i = 0; i < n; i++){                    // for each number in input array\\n            var num = nums[i];                          // the current number we are processing\\n            StartNewSetOrJoin(num, i, num);             // the number is a factor of itself\\n            for (int j = 2; j*j <= num; j++){           // j*j <= num because we want to only check factors till square root of num\\n                if (num % j == 0){                      // if j is a factor of num\\n                    StartNewSetOrJoin(num, i, j);       // add current num to set of factor j\\n                    StartNewSetOrJoin(num, i, num/j);   // obviously num/j is also a factor of num \\n                }\\n            }\\n        }\\n        \\n        return uf.max;\\n    }\\n    \\n    private void StartNewSetOrJoin(int num, int numIdx, int factor){\\n        if (!dict.ContainsKey(factor)){         // no number has had this factor yet\\n            dict[factor] = numIdx;              // so a new set starts with current number\\n        }else{                                  // if there is already a set with current factor as parent\\n            uf.Union(numIdx, dict[factor]);     // join current number with that set\\n        }\\n    }\\n}\\n\\n\\npublic class UnionFind{\\n    int[] parent;                           // it stores index of first node in a set\\n    int[] size;                             // keeps track of size of a set\\n    public int max;                         // this we maintain so that we don\\'t have to do a loop later to get biggest set\\n    \\n    public UnionFind(int n){\\n        parent = new int[n];\\n        size = new int[n];\\n        max = 1;                            // all disjoint sets have one node\\n        for(int i=0; i<n; i++){\\n            parent[i] = i;                  // all are self parent initially\\n            size[i] = 1;                    // size of all disjoint sets is 1 initially\\n        }\\n    }\\n    \\n    public int Find(int n){\\n        if(parent[n] != n)                  // if there are multiple nodes in current set\\n            parent[n] = Find(parent[n]);    // find parent node of the set\\n        return parent[n];                   // and then return the parent\\n    }\\n    \\n    public void Union(int n1, int n2){\\n        var n1_p = Find(n1);                // find parent of number 1\\n        var n2_p = Find(n2);                // find parent of number 2\\n        if(n1_p != n2_p){                   // if parent of number 1 and number 2 are not same, then we need to join two sets\\n            parent[n1_p] = n2_p;            // make n2\\'s parent as common parent for both sets. ideally smaller set should update its parent\\n            size[n2_p] += size[n1_p];       // update size of the merged set\\n            max = Math.Max(max, size[n2_p]);// update the max size of any set\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592949,
                "title": "c-union-find",
                "content": "Approach 1: Union-find\\n```\\nclass DSU {\\npublic:\\n  DSU(int n): p_(n) {\\n    for (int i = 0; i < n; ++i)\\n      p_[i] = i;\\n  }\\n  \\n  void Union(int x, int y) {\\n    p_[Find(x)] = p_[Find(y)];\\n  }\\n  \\n  int Find(int x) {\\n    if (p_[x] != x) p_[x] = Find(p_[x]);\\n    return p_[x];\\n  }\\nprivate:\\n  vector<int> p_;\\n};\\n \\nclass Solution {\\npublic:\\n  int largestComponentSize(vector<int>& A) {    \\n    int n = *max_element(begin(A), end(A));\\n    DSU dsu(n + 1);\\n    for (int a : A) {\\n      int t = sqrt(a);\\n      for (int k = 2; k <= t; ++k)\\n        if (a % k == 0) {\\n          dsu.Union(a, k);\\n          dsu.Union(a, a / k);\\n        }\\n    }\\n    unordered_map<int, int> c;\\n    int ans = 1;\\n    for (int a : A)\\n      ans = max(ans, ++c[dsu.Find(a)]);    \\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass DSU {\\npublic:\\n  DSU(int n): p_(n) {\\n    for (int i = 0; i < n; ++i)\\n      p_[i] = i;\\n  }\\n  \\n  void Union(int x, int y) {\\n    p_[Find(x)] = p_[Find(y)];\\n  }\\n  \\n  int Find(int x) {\\n    if (p_[x] != x) p_[x] = Find(p_[x]);\\n    return p_[x];\\n  }\\nprivate:\\n  vector<int> p_;\\n};\\n \\nclass Solution {\\npublic:\\n  int largestComponentSize(vector<int>& A) {    \\n    int n = *max_element(begin(A), end(A));\\n    DSU dsu(n + 1);\\n    for (int a : A) {\\n      int t = sqrt(a);\\n      for (int k = 2; k <= t; ++k)\\n        if (a % k == 0) {\\n          dsu.Union(a, k);\\n          dsu.Union(a, a / k);\\n        }\\n    }\\n    unordered_map<int, int> c;\\n    int ans = 1;\\n    for (int a : A)\\n      ans = max(ans, ++c[dsu.Find(a)]);    \\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592788,
                "title": "java-code",
                "content": "```\\nclass Solution {\\n\\tprivate class UnionFind {\\n\\t\\tprivate int[] parent;\\n\\n\\t\\tprivate UnionFind(int n){\\n\\t\\t\\tparent = new int[n];\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tparent[i] = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprivate int getAbsoluteParent(int i){\\n\\t\\t\\tif(parent[i]==i){\\n\\t\\t\\t\\t// absolute parent\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t\\tparent[i]=getAbsoluteParent(parent[i]);\\n\\t\\t\\treturn parent[i];\\n\\t\\t}\\n\\n\\t\\tprivate void unify(int i, int j){\\n\\t\\t\\tint absoluteParentI = getAbsoluteParent(i);\\n\\t\\t\\tint absoluteParentJ = getAbsoluteParent(j);\\n\\t\\t\\tif(absoluteParentI!=absoluteParentJ){\\n\\t\\t\\t\\t// 7->2, 21->2 (7,21)\\n\\t\\t\\t\\tparent[absoluteParentJ] = absoluteParentI;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\n\\tpublic int largestComponentSize(int[] nums) {\\n\\t\\tint max=0;\\n\\t\\tfor(int el:nums) {\\n\\t\\t\\tmax = Math.max(el, max);\\n\\t\\t}\\n\\t\\tUnionFind uf = new UnionFind(max+1);\\n\\n\\t\\tfor(int i:nums) {\\n\\t\\t\\tfor(int j=2;j*j<=i;j++) {\\n\\t\\t\\t\\tif(i%j==0){ // j is a factor of i\\n\\t\\t\\t\\t\\tuf.unify( j,i); // i=21, j=3\\n\\t\\t\\t\\t\\tuf.unify(i/j,i); // (21,3), (21,21/3(7))\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//<Parent, Freq>\\n\\t\\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n\\t\\tint maxComponet = 0;\\n\\t\\tfor(int el:nums){\\n\\t\\t\\tint parent = uf.getAbsoluteParent(el);\\n\\t\\t\\tmap.put(parent, map.getOrDefault(parent, 0) + 1);\\n\\t\\t\\tmaxComponet= Math.max(maxComponet, map.get(parent));\\n\\t\\t}\\n\\n\\n\\n\\t\\treturn maxComponet;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tprivate class UnionFind {\\n\\t\\tprivate int[] parent;\\n\\n\\t\\tprivate UnionFind(int n){\\n\\t\\t\\tparent = new int[n];\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tparent[i] = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tprivate int getAbsoluteParent(int i){\\n\\t\\t\\tif(parent[i]==i){\\n\\t\\t\\t\\t// absolute parent\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t\\tparent[i]=getAbsoluteParent(parent[i]);\\n\\t\\t\\treturn parent[i];\\n\\t\\t}\\n\\n\\t\\tprivate void unify(int i, int j){\\n\\t\\t\\tint absoluteParentI = getAbsoluteParent(i);\\n\\t\\t\\tint absoluteParentJ = getAbsoluteParent(j);\\n\\t\\t\\tif(absoluteParentI!=absoluteParentJ){\\n\\t\\t\\t\\t// 7->2, 21->2 (7,21)\\n\\t\\t\\t\\tparent[absoluteParentJ] = absoluteParentI;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\n\\tpublic int largestComponentSize(int[] nums) {\\n\\t\\tint max=0;\\n\\t\\tfor(int el:nums) {\\n\\t\\t\\tmax = Math.max(el, max);\\n\\t\\t}\\n\\t\\tUnionFind uf = new UnionFind(max+1);\\n\\n\\t\\tfor(int i:nums) {\\n\\t\\t\\tfor(int j=2;j*j<=i;j++) {\\n\\t\\t\\t\\tif(i%j==0){ // j is a factor of i\\n\\t\\t\\t\\t\\tuf.unify( j,i); // i=21, j=3\\n\\t\\t\\t\\t\\tuf.unify(i/j,i); // (21,3), (21,21/3(7))\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//<Parent, Freq>\\n\\t\\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n\\t\\tint maxComponet = 0;\\n\\t\\tfor(int el:nums){\\n\\t\\t\\tint parent = uf.getAbsoluteParent(el);\\n\\t\\t\\tmap.put(parent, map.getOrDefault(parent, 0) + 1);\\n\\t\\t\\tmaxComponet= Math.max(maxComponet, map.get(parent));\\n\\t\\t}\\n\\n\\n\\n\\t\\treturn maxComponet;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546376,
                "title": "c-952-largest-component-size-by-common-factor",
                "content": "\\n```\\nclass UnionFind {\\npublic: \\n    vector<int> parent, rank; \\n    UnionFind(int n) {\\n        parent.resize(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        rank.resize(n); \\n        fill(rank.begin(), rank.end(), 1); \\n    }\\n    \\n    int find(int p) {\\n        if (p != parent[p]) \\n            parent[p] = find(parent[p]); \\n        return parent[p]; \\n    }\\n    \\n    bool connect(int p, int q) {\\n        int prt = find(p), qrt = find(q); \\n        if (prt == qrt) return false; \\n        if (rank[prt] > rank[qrt]) swap(prt, qrt); \\n        parent[prt] = qrt; \\n        rank[qrt] += rank[prt]; \\n        return true; \\n    }\\n}; \\n\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int m = *max_element(nums.begin(), nums.end()); \\n        vector<bool> seen(m+1); \\n        for (auto& x : nums) seen[x] = true; \\n        UnionFind* uf = new UnionFind(m+1); \\n        vector<bool> sieve(m+1, true); \\n        sieve[0] = sieve[1] = false; \\n        for (int x = 2; x <= m/2; ++x) \\n            if (sieve[x]) {\\n                int prev = seen[x] ? x : 0; \\n                for (int xx = 2*x; xx <= m; xx += x) {\\n                    sieve[xx] = false; \\n                    if (seen[xx]) \\n                        if (prev) uf->connect(prev, xx); \\n                        else prev = xx; \\n                }\\n            }\\n        int ans = *max_element(uf->rank.begin(), uf->rank.end()); \\n        delete uf; \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass UnionFind {\\npublic: \\n    vector<int> parent, rank; \\n    UnionFind(int n) {\\n        parent.resize(n); \\n        iota(parent.begin(), parent.end(), 0); \\n        rank.resize(n); \\n        fill(rank.begin(), rank.end(), 1); \\n    }\\n    \\n    int find(int p) {\\n        if (p != parent[p]) \\n            parent[p] = find(parent[p]); \\n        return parent[p]; \\n    }\\n    \\n    bool connect(int p, int q) {\\n        int prt = find(p), qrt = find(q); \\n        if (prt == qrt) return false; \\n        if (rank[prt] > rank[qrt]) swap(prt, qrt); \\n        parent[prt] = qrt; \\n        rank[qrt] += rank[prt]; \\n        return true; \\n    }\\n}; \\n\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int m = *max_element(nums.begin(), nums.end()); \\n        vector<bool> seen(m+1); \\n        for (auto& x : nums) seen[x] = true; \\n        UnionFind* uf = new UnionFind(m+1); \\n        vector<bool> sieve(m+1, true); \\n        sieve[0] = sieve[1] = false; \\n        for (int x = 2; x <= m/2; ++x) \\n            if (sieve[x]) {\\n                int prev = seen[x] ? x : 0; \\n                for (int xx = 2*x; xx <= m; xx += x) {\\n                    sieve[xx] = false; \\n                    if (seen[xx]) \\n                        if (prev) uf->connect(prev, xx); \\n                        else prev = xx; \\n                }\\n            }\\n        int ans = *max_element(uf->rank.begin(), uf->rank.end()); \\n        delete uf; \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1453397,
                "title": "easy-c-union-find-based-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(int x, vector<int> &parent)\\n    {\\n        if(x==parent[x])\\n        {\\n            return x;\\n        }\\n        return parent[x] = find(parent[x],parent);\\n    }\\n    void merge(int a,int b,vector<int> &parent,vector<int> &rank)\\n    {\\n        int pa = find(a,parent);\\n        int pb = find(b,parent);\\n        if(pa!=pb)\\n        {\\n            if(rank[pa]<rank[pb])\\n            {\\n                swap(pa,pb);\\n            }\\n            parent[pb] = pa;\\n            if(rank[pa]==rank[pb])\\n            {\\n                rank[pa]++;\\n            }\\n        }\\n    }\\n    \\n    unordered_set<int> get_factors(int n, vector<int> &sieve)\\n    {\\n        unordered_set<int> f;\\n        while(n>1)\\n        {\\n            f.insert(sieve[n]);\\n            n = n/sieve[n];\\n        }\\n        return f;\\n    }\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxx = *max_element(nums.begin(),nums.end());\\n        vector<int> parent(maxx+1);\\n        for(int i =0;i<=maxx;i++)\\n        {\\n            parent[i] = i;\\n        }\\n        vector<int> rank(maxx+1,0);\\n        \\n        //create the factor sieve\\n        vector<int> sieve(maxx+1);\\n        for(int i=0;i<=maxx;i++)\\n        {\\n            sieve[i] = i;\\n        }\\n        for(int i=2;(i*i)<=maxx;i++)\\n        {\\n            if(sieve[i]==i)\\n            {\\n                for(int j = i*i;j<=maxx;j+=i)\\n                {\\n                    if(sieve[j]==j)\\n                    {\\n                        sieve[j] = i;\\n                    }\\n                }\\n            }\\n        }\\n        //\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int curr = nums[i];\\n            unordered_set<int> fac = get_factors(curr,sieve);\\n            for(int f:fac)\\n            {\\n                merge(f,curr,parent,rank);\\n            }\\n        }\\n        map<int,int> mp;\\n        int ans= 1;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pc = find(nums[i],parent);\\n            mp[pc]++;\\n            ans = max(ans,mp[pc]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int x, vector<int> &parent)\\n    {\\n        if(x==parent[x])\\n        {\\n            return x;\\n        }\\n        return parent[x] = find(parent[x],parent);\\n    }\\n    void merge(int a,int b,vector<int> &parent,vector<int> &rank)\\n    {\\n        int pa = find(a,parent);\\n        int pb = find(b,parent);\\n        if(pa!=pb)\\n        {\\n            if(rank[pa]<rank[pb])\\n            {\\n                swap(pa,pb);\\n            }\\n            parent[pb] = pa;\\n            if(rank[pa]==rank[pb])\\n            {\\n                rank[pa]++;\\n            }\\n        }\\n    }\\n    \\n    unordered_set<int> get_factors(int n, vector<int> &sieve)\\n    {\\n        unordered_set<int> f;\\n        while(n>1)\\n        {\\n            f.insert(sieve[n]);\\n            n = n/sieve[n];\\n        }\\n        return f;\\n    }\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxx = *max_element(nums.begin(),nums.end());\\n        vector<int> parent(maxx+1);\\n        for(int i =0;i<=maxx;i++)\\n        {\\n            parent[i] = i;\\n        }\\n        vector<int> rank(maxx+1,0);\\n        \\n        //create the factor sieve\\n        vector<int> sieve(maxx+1);\\n        for(int i=0;i<=maxx;i++)\\n        {\\n            sieve[i] = i;\\n        }\\n        for(int i=2;(i*i)<=maxx;i++)\\n        {\\n            if(sieve[i]==i)\\n            {\\n                for(int j = i*i;j<=maxx;j+=i)\\n                {\\n                    if(sieve[j]==j)\\n                    {\\n                        sieve[j] = i;\\n                    }\\n                }\\n            }\\n        }\\n        //\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int curr = nums[i];\\n            unordered_set<int> fac = get_factors(curr,sieve);\\n            for(int f:fac)\\n            {\\n                merge(f,curr,parent,rank);\\n            }\\n        }\\n        map<int,int> mp;\\n        int ans= 1;\\n        for(int i=0;i<n;i++)\\n        {\\n            int pc = find(nums[i],parent);\\n            mp[pc]++;\\n            ans = max(ans,mp[pc]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841771,
                "title": "union-find-using-path-compression-with-commented-code",
                "content": "```\\nclass Solution {\\n    static class UF {\\n        int[] size;\\n        int[] parent;\\n        int max;\\n        \\n        public UF(int n) {\\n            size = new int[n];\\n            parent= new int[n];\\n            for(int i=0; i<n; i++) {\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        \\n        int find(int x) {\\n            int temp = x;\\n            while(parent[x] != x) {\\n                x = parent[x];\\n            }\\n            \\n            while(temp != x) {\\n                int ptemp = parent[temp];\\n                parent[temp] = x;\\n                temp = ptemp;\\n            }\\n            return x;\\n        }\\n        \\n        public void union(int x, int y) {\\n            int px = find(x);\\n            int py = find(y);\\n            if(px == py) return;\\n            \\n            if(size[px] > size[py]) {\\n                size[px] += size[py];\\n                parent[py] = px;\\n                max= Math.max(max, size[px]);\\n            } else {\\n                size[py] += size[px];\\n                parent[px] = py;\\n                max= Math.max(max, size[py]);\\n            }\\n        }\\n    }\\n    public int largestComponentSize(int[] A) {\\n        int n = A.length;\\n        UF uf = new UF(n);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i=0; i<n; i++) {\\n            int num = A[i];\\n            // to compute the factorization we need to go upto sqrt(num) times\\n            for(int j=2; j*j <=num; ++j) {\\n                // if j is one of the factor of num\\n                if(num%j == 0) {\\n                    if(map.containsKey(j)){\\n                        uf.union(i, map.get(j));\\n                    } else {\\n                        map.put(j, i);\\n                    }\\n                \\n                    if(map.containsKey(num/j)){\\n                        uf.union(i, map.get(num/j));\\n                    } else {\\n                        map.put(num/j, i);\\n                    }\\n                }\\n                \\n            }\\n            \\n            // if factor is not possible\\n            // then number itself is an factor\\n            if(map.containsKey(num)) {\\n                uf.union(i, map.get(num));\\n            } else {\\n                map.put(num, i);\\n            }\\n        }\\n        \\n        return uf.max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static class UF {\\n        int[] size;\\n        int[] parent;\\n        int max;\\n        \\n        public UF(int n) {\\n            size = new int[n];\\n            parent= new int[n];\\n            for(int i=0; i<n; i++) {\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        \\n        int find(int x) {\\n            int temp = x;\\n            while(parent[x] != x) {\\n                x = parent[x];\\n            }\\n            \\n            while(temp != x) {\\n                int ptemp = parent[temp];\\n                parent[temp] = x;\\n                temp = ptemp;\\n            }\\n            return x;\\n        }\\n        \\n        public void union(int x, int y) {\\n            int px = find(x);\\n            int py = find(y);\\n            if(px == py) return;\\n            \\n            if(size[px] > size[py]) {\\n                size[px] += size[py];\\n                parent[py] = px;\\n                max= Math.max(max, size[px]);\\n            } else {\\n                size[py] += size[px];\\n                parent[px] = py;\\n                max= Math.max(max, size[py]);\\n            }\\n        }\\n    }\\n    public int largestComponentSize(int[] A) {\\n        int n = A.length;\\n        UF uf = new UF(n);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i=0; i<n; i++) {\\n            int num = A[i];\\n            // to compute the factorization we need to go upto sqrt(num) times\\n            for(int j=2; j*j <=num; ++j) {\\n                // if j is one of the factor of num\\n                if(num%j == 0) {\\n                    if(map.containsKey(j)){\\n                        uf.union(i, map.get(j));\\n                    } else {\\n                        map.put(j, i);\\n                    }\\n                \\n                    if(map.containsKey(num/j)){\\n                        uf.union(i, map.get(num/j));\\n                    } else {\\n                        map.put(num/j, i);\\n                    }\\n                }\\n                \\n            }\\n            \\n            // if factor is not possible\\n            // then number itself is an factor\\n            if(map.containsKey(num)) {\\n                uf.union(i, map.get(num));\\n            } else {\\n                map.put(num, i);\\n            }\\n        }\\n        \\n        return uf.max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822954,
                "title": "c-and-python-explained-2-solutions-based-on-sieve-o-n-log-m-o-m",
                "content": "I suggest reading this post only after you understood the `O(n*sqrt(m)) `solution.\\n\\nIn this problem we need to find the largest component where the numbers share a common factor.\\nFor this let us create these components, and then simply find the one which has more numbers.\\n\\n1. How can we create the components?\\n The main idea is to use prime factor decomposition (i.e. 42 = 2 * 3 * 7). Let us build a dictionary (unordered_map) with keys - prime numbers, and values - the numbers which have this prime in their decomposition.\\n 2. Why do we build this dictionary?\\n Because we need to connect the numbers fast. If we know that 3 numbers (let them be 2, 6, 8) have 2 as their common factor, then we know that 2, 6 and 8 are in the same component.\\n 3. How can we decompose our numbers?\\n There are 2 approaches with time complexities `O(sqrt(k))` and `O(log(k))` for each number k. The latter one is faster but it requires more space, we will use this one. There we should build a specific Sieve. In the `O(sqrt(k))` approach we go through each number `i = 1...sqrt(k)`, and check if `k mod i = 0` (i.e. we find the smallest prime factor which divides our number k). Now, what if we know already for every number k which is its smallest prime factor? Then, we can find its decomposition by dividing the given number recursively with its smallest prime factor till it becomes 1. Take 12, you divide it by 2 (you get 6), then one more time by 2 (you get 3), and then divide by 3 (you get 1, you stop the process, and you know that 12 = 2 * 2 * 3). In the original Sieve we have `Sieve[i] = true` if `i - prime`, else false. In our Sieve, which we will call \\'spf\\' (smallest prime factor), `spf[i] = i` if `i - prime`, and each time we get a prime number, we make `spf[2i], spf[3i], spf[4i] ... = i`. Also we should check if \\'i\\' isn\\'t already a smallest prime factor of another number. \\n 4. What\\'s next?\\n Now, we know how to create components for every unique prime, however there is a problem, we still need to connect the components which share at least one number. For example if we have 3 numbers (let them be 3, 5, 15), we will have 2 components (the former for the prime 3 (3, 15), and the latter for the prime 5 (5, 15)) but for this problem 3, 5 and 15 should be in the same component.\\n 5. How can we fix that?\\n I will show 2 solutions, one in C++ with DSU (Disjoint Set Union) - `O(n*logn)`, and another in Python with BFS - `O(n)`\\n \\n**C++ with DSU**\\n1. We build the Sieve and the primes dictionary.\\n2. We create the DSU, and then we join the numbers which share the same factor.\\n3. We count how many elements we have in each component and return the largest one.\\n```\\nclass Solution { // Sieve + DSU\\npublic:\\n    vector<int> parent, spf;\\n    void sieve(int N, vector<int> &spf) {\\n        spf = vector<int> (N);           // N = max(A) + 1\\n        for(int i = 1; i < N; ++i)       // Initially, we mark smallest prime factor for every number to be itself. \\n            spf[i] = i;\\n        for(int i = 2; i < N; i += 2)    // Like in the Sieve, it\\'s easier to mark even numbers separately \\n            spf[i] = 2;\\n        for(int i = 3; i < N; i += 2)\\n            if (spf[i] == i)             // If spf[i] == i, our number is prime\\n                for(int j = i; j < N; j += i)\\n                    if (spf[j] == j)     // Before we mark each 2i, 3i, 4i ..., we should check if it wasn\\'t already marked. Take 6, it is marked by 2 but it can also be marked by 3.\\n                        spf[j] = i;\\n    }\\n    int find(int node) {\\n        return node == parent[node] ? parent[node] : parent[node] = find(parent[node]);   \\n    }\\n    int largestComponentSize(vector<int>& A) {\\n        sieve(*max_element(A.begin(), A.end()) + 1, spf); // 1\\n        unordered_map <int, unordered_set<int>> primes;\\n        for(int i = 0; i < A.size(); ++i) {\\n            int num = A[i];\\n            while(num != 1) {\\n                primes[spf[num]].insert(i);\\n                num /= spf[num]; \\n            }\\n        }\\n        \\n        parent = vector<int> (A.size()); // 2\\n        for(int i = 0; i < A.size(); ++i)\\n            parent[i] = i;\\n        for(auto [_, x]: primes) {\\n            int i = *x.begin();\\n            x.erase(x.begin());\\n            for(int j: x)\\n                parent[find(i)] = find(j);\\n        }\\n        \\n        vector<int> components(A.size()); // 3\\n        for(int x: parent)\\n            components[find(x)]++;\\n        return *max_element(components.begin(), components.end());\\n    }\\n};\\n```\\n\\n**Python with BFS**\\n1. We build the Sieve and the primes dictionary.\\n2. For each number that we haven\\'t visited yet, we run a BFS over the primes in its decomposition.\\n3. For each prime, we find other numbers which have this prime in their decomposition, and we increment the number of components in our current (\\'cur\\') component. Also, we add to our queue other factors which we haven\\'t visited.\\n```\\nclass Solution:  # Sieve + BFS \\n    \\n    def largestComponentSize(self, A: List[int]) -> int:\\n        \\n        def sieve():\\n            i = 2\\n            while i < len(spf):\\n                spf[i] = 2\\n                i += 2\\n            i = 3\\n            while i * i < len(spf):\\n                if spf[i] == i:\\n                    j = i\\n                    while j < len(spf):\\n                        if spf[j] == j:\\n                            spf[j] = i\\n                        j += i\\n                i += 2\\n        \\n        spf, di, factors, visited_nums, visited_factors, ans = [i for i in range(max(A) + 1)], defaultdict(set), defaultdict(set), set(), set(), 1\\n        \\n        sieve()  # 1\\n        \\n        for num in A:\\n            x = num\\n            while x != 1:\\n                di[spf[x]].add(num)\\n                factors[num].add(spf[x])\\n                x //= spf[x]\\n        \\n        for num in A:  # 2\\n            if num in visited_nums:\\n                continue\\n                \\n            visited_nums.add(num)\\n            cur, queue = 1, deque([])\\n            for factor in factors[num]:\\n                queue.append(factor)\\n                \\n            while queue: \\n                factor = queue.popleft()\\n                visited_factors.add(factor)\\n                for next_num in di[factor]:  # 3\\n                    if next_num in visited_nums:\\n                        continue\\n                        \\n                    visited_nums.add(next_num)\\n                    cur += 1\\n                    for next_factor in factors[next_num]:\\n                        if next_factor in visited_factors:\\n                            continue\\n                        \\n                        visited_factors.add(next_factor)\\n                        queue.append(next_factor)\\n                \\n            ans = max(ans, cur)\\n        \\n        return ans\\n        \\n        \\n            \\n```\\n\\nEven if the DSU is slower than the BFS, the time complexities of both solutions are the same due to the Sieve.\\n\\n`TC - O(n*log(m))`, where m is the biggest number in our array\\n`SC - O(m)`",
                "solutionTags": [],
                "code": "```\\nclass Solution { // Sieve + DSU\\npublic:\\n    vector<int> parent, spf;\\n    void sieve(int N, vector<int> &spf) {\\n        spf = vector<int> (N);           // N = max(A) + 1\\n        for(int i = 1; i < N; ++i)       // Initially, we mark smallest prime factor for every number to be itself. \\n            spf[i] = i;\\n        for(int i = 2; i < N; i += 2)    // Like in the Sieve, it\\'s easier to mark even numbers separately \\n            spf[i] = 2;\\n        for(int i = 3; i < N; i += 2)\\n            if (spf[i] == i)             // If spf[i] == i, our number is prime\\n                for(int j = i; j < N; j += i)\\n                    if (spf[j] == j)     // Before we mark each 2i, 3i, 4i ..., we should check if it wasn\\'t already marked. Take 6, it is marked by 2 but it can also be marked by 3.\\n                        spf[j] = i;\\n    }\\n    int find(int node) {\\n        return node == parent[node] ? parent[node] : parent[node] = find(parent[node]);   \\n    }\\n    int largestComponentSize(vector<int>& A) {\\n        sieve(*max_element(A.begin(), A.end()) + 1, spf); // 1\\n        unordered_map <int, unordered_set<int>> primes;\\n        for(int i = 0; i < A.size(); ++i) {\\n            int num = A[i];\\n            while(num != 1) {\\n                primes[spf[num]].insert(i);\\n                num /= spf[num]; \\n            }\\n        }\\n        \\n        parent = vector<int> (A.size()); // 2\\n        for(int i = 0; i < A.size(); ++i)\\n            parent[i] = i;\\n        for(auto [_, x]: primes) {\\n            int i = *x.begin();\\n            x.erase(x.begin());\\n            for(int j: x)\\n                parent[find(i)] = find(j);\\n        }\\n        \\n        vector<int> components(A.size()); // 3\\n        for(int x: parent)\\n            components[find(x)]++;\\n        return *max_element(components.begin(), components.end());\\n    }\\n};\\n```\n```\\nclass Solution:  # Sieve + BFS \\n    \\n    def largestComponentSize(self, A: List[int]) -> int:\\n        \\n        def sieve():\\n            i = 2\\n            while i < len(spf):\\n                spf[i] = 2\\n                i += 2\\n            i = 3\\n            while i * i < len(spf):\\n                if spf[i] == i:\\n                    j = i\\n                    while j < len(spf):\\n                        if spf[j] == j:\\n                            spf[j] = i\\n                        j += i\\n                i += 2\\n        \\n        spf, di, factors, visited_nums, visited_factors, ans = [i for i in range(max(A) + 1)], defaultdict(set), defaultdict(set), set(), set(), 1\\n        \\n        sieve()  # 1\\n        \\n        for num in A:\\n            x = num\\n            while x != 1:\\n                di[spf[x]].add(num)\\n                factors[num].add(spf[x])\\n                x //= spf[x]\\n        \\n        for num in A:  # 2\\n            if num in visited_nums:\\n                continue\\n                \\n            visited_nums.add(num)\\n            cur, queue = 1, deque([])\\n            for factor in factors[num]:\\n                queue.append(factor)\\n                \\n            while queue: \\n                factor = queue.popleft()\\n                visited_factors.add(factor)\\n                for next_num in di[factor]:  # 3\\n                    if next_num in visited_nums:\\n                        continue\\n                        \\n                    visited_nums.add(next_num)\\n                    cur += 1\\n                    for next_factor in factors[next_num]:\\n                        if next_factor in visited_factors:\\n                            continue\\n                        \\n                        visited_factors.add(next_factor)\\n                        queue.append(next_factor)\\n                \\n            ans = max(ans, cur)\\n        \\n        return ans\\n        \\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 822315,
                "title": "python3-official-solution-with-improvement-largest-component-size-by-common-factor",
                "content": "```\\nclass UF:        \\n    def __init__(self) -> None:\\n        self.parent = {}\\n        self.sz = {}\\n        self.count = 0\\n        \\n    def add(self, p):    \\n        if p not in self.parent:\\n            self.parent[p] = p\\n            self.sz[p] = 1\\n            self.count += 1\\n                          \\n    def find(self, p: int) -> int:\\n        while p != self.parent[p]:\\n            self.parent[p] = self.parent[self.parent[p]]\\n            p = self.parent[p]\\n        return p  \\n              \\n    def union(self, p: int, q: int) -> None:\\n        i = self.find(p)\\n        j = self.find(q)             \\n        if i == j:    \\n            return \\n        if self.sz[i] > self.sz[j]:                 \\n            self.parent[j] = i\\n            self.sz[i] += self.sz[j]\\n        else:             \\n            self.parent[i] = j\\n            self.sz[j] += self.sz[i]                                           \\n        self.count -= 1 \\n        \\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        def fac(n): \\n            for i in range(2, int(n**0.5)+1):\\n                if n % i == 0:\\n                    n //= i\\n                    return set((i,)) | fac(n)\\n            return set((n,))\\n        \\n        @lru_cache(None) \\n        def group_id(p):\\n            return uf.find(p)\\n        \\n        uf = UF()\\n        c = Counter() \\n        for n in A:\\n            factors = fac(n)\\n            if (key := tuple(sorted(factors))) not in c:\\n                p = factors.pop()\\n                uf.add(p)\\n                for q in factors:\\n                    uf.add(q)\\n                    uf.union(p, q)\\n            c[key] += 1\\n        if uf.count == 1:\\n            return len(A)            \\n        groups = Counter()\\n        for factors, value in c.items():\\n            groups[group_id(factors[0])] += value\\n        return groups.most_common()[0][1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass UF:        \\n    def __init__(self) -> None:\\n        self.parent = {}\\n        self.sz = {}\\n        self.count = 0\\n        \\n    def add(self, p):    \\n        if p not in self.parent:\\n            self.parent[p] = p\\n            self.sz[p] = 1\\n            self.count += 1\\n                          \\n    def find(self, p: int) -> int:\\n        while p != self.parent[p]:\\n            self.parent[p] = self.parent[self.parent[p]]\\n            p = self.parent[p]\\n        return p  \\n              \\n    def union(self, p: int, q: int) -> None:\\n        i = self.find(p)\\n        j = self.find(q)             \\n        if i == j:    \\n            return \\n        if self.sz[i] > self.sz[j]:                 \\n            self.parent[j] = i\\n            self.sz[i] += self.sz[j]\\n        else:             \\n            self.parent[i] = j\\n            self.sz[j] += self.sz[i]                                           \\n        self.count -= 1 \\n        \\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        def fac(n): \\n            for i in range(2, int(n**0.5)+1):\\n                if n % i == 0:\\n                    n //= i\\n                    return set((i,)) | fac(n)\\n            return set((n,))\\n        \\n        @lru_cache(None) \\n        def group_id(p):\\n            return uf.find(p)\\n        \\n        uf = UF()\\n        c = Counter() \\n        for n in A:\\n            factors = fac(n)\\n            if (key := tuple(sorted(factors))) not in c:\\n                p = factors.pop()\\n                uf.add(p)\\n                for q in factors:\\n                    uf.add(q)\\n                    uf.union(p, q)\\n            c[key] += 1\\n        if uf.count == 1:\\n            return len(A)            \\n        groups = Counter()\\n        for factors, value in c.items():\\n            groups[group_id(factors[0])] += value\\n        return groups.most_common()[0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821306,
                "title": "easy-java-implementation",
                "content": "```\\nclass Solution {\\n    public int find(int x,int[] parent)\\n    {\\n        if(parent[x]==-1)\\n            return x;\\n        else\\n            parent[x]=find(parent[x],parent);\\n        return parent[x];\\n    }\\n    public void union(int x,int y,int[] parent)\\n    {\\n        int xp=find(x,parent);\\n        int yp=find(y,parent);\\n        if(xp!=yp)\\n        {\\n            parent[yp]=xp;\\n        }\\n        return;\\n    }\\n    public int largestComponentSize(int[] nums) {\\n        int[] parent=new int[100001];\\n        Arrays.fill(parent,-1);\\n        int i;\\n        for(i=0;i<nums.length;i++)\\n        {\\n            for(int k=2;k<=Math.sqrt(nums[i]);k++)\\n            {\\n                if(nums[i]%k==0)\\n                {\\n                    union(nums[i],k,parent);\\n                    union(nums[i],nums[i]/k,parent);\\n                }\\n            }\\n        }\\n        int count=0;\\n        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\\n        for(i=0;i<nums.length;i++)\\n        {\\n            int p=find(nums[i],parent);\\n            count=Math.max(count,map.getOrDefault(p,0)+1);\\n            map.put(p,map.getOrDefault(p,0)+1);\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int find(int x,int[] parent)\\n    {\\n        if(parent[x]==-1)\\n            return x;\\n        else\\n            parent[x]=find(parent[x],parent);\\n        return parent[x];\\n    }\\n    public void union(int x,int y,int[] parent)\\n    {\\n        int xp=find(x,parent);\\n        int yp=find(y,parent);\\n        if(xp!=yp)\\n        {\\n            parent[yp]=xp;\\n        }\\n        return;\\n    }\\n    public int largestComponentSize(int[] nums) {\\n        int[] parent=new int[100001];\\n        Arrays.fill(parent,-1);\\n        int i;\\n        for(i=0;i<nums.length;i++)\\n        {\\n            for(int k=2;k<=Math.sqrt(nums[i]);k++)\\n            {\\n                if(nums[i]%k==0)\\n                {\\n                    union(nums[i],k,parent);\\n                    union(nums[i],nums[i]/k,parent);\\n                }\\n            }\\n        }\\n        int count=0;\\n        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\\n        for(i=0;i<nums.length;i++)\\n        {\\n            int p=find(nums[i],parent);\\n            count=Math.max(count,map.getOrDefault(p,0)+1);\\n            map.put(p,map.getOrDefault(p,0)+1);\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821179,
                "title": "go-golang-clean-solution",
                "content": ">Runtime: 300 ms, faster than 50.00% of Go online submissions for Largest Component Size by Common Factor.\\nMemory Usage: 8.6 MB, less than 50.00% of Go online submissions for Largest Component Size by Common Factor.\\n\\n```go\\ntype DSU struct {\\n    parent []int\\n}\\n\\nfunc (d *DSU) find(x int) int {\\n    if d.parent[x] != x { d.parent[x] = d.find(d.parent[x]) }\\n    return d.parent[x]\\n}\\n\\nfunc (d *DSU) union(x, y int) {\\n    d.parent[d.find(x)] = d.parent[d.find(y)]\\n}\\n\\nfunc Constructor(n int) *DSU {\\n    s := make([]int, n)\\n    for i := 0; i < n; i++ { s[i] = i }\\n    return &DSU{ s }\\n}\\n\\nfunc largestComponentSize(A []int) int {\\n    ans, max, cache := 1, 0, make(map[int]int)\\n    for _, a := range A { if a > max { max = a } }\\n    DSU := Constructor(max + 1)\\n    for _, a := range A {\\n        for k := 2; k <= int(math.Sqrt(float64(a))); k++ {\\n            if a % k == 0 {\\n                DSU.union(a, k)\\n                DSU.union(a, a / k)\\n            }\\n        }\\n    }\\n    for _, a := range A {\\n        r := DSU.find(a)\\n        cache[r]++\\n        if cache[r] > ans { ans = cache[r] }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\ntype DSU struct {\\n    parent []int\\n}\\n\\nfunc (d *DSU) find(x int) int {\\n    if d.parent[x] != x { d.parent[x] = d.find(d.parent[x]) }\\n    return d.parent[x]\\n}\\n\\nfunc (d *DSU) union(x, y int) {\\n    d.parent[d.find(x)] = d.parent[d.find(y)]\\n}\\n\\nfunc Constructor(n int) *DSU {\\n    s := make([]int, n)\\n    for i := 0; i < n; i++ { s[i] = i }\\n    return &DSU{ s }\\n}\\n\\nfunc largestComponentSize(A []int) int {\\n    ans, max, cache := 1, 0, make(map[int]int)\\n    for _, a := range A { if a > max { max = a } }\\n    DSU := Constructor(max + 1)\\n    for _, a := range A {\\n        for k := 2; k <= int(math.Sqrt(float64(a))); k++ {\\n            if a % k == 0 {\\n                DSU.union(a, k)\\n                DSU.union(a, a / k)\\n            }\\n        }\\n    }\\n    for _, a := range A {\\n        r := DSU.find(a)\\n        cache[r]++\\n        if cache[r] > ans { ans = cache[r] }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 820634,
                "title": "c-union-find-solution",
                "content": "I first tried using graph implemented as adjacency matrix and performed depth first search using stack. This worked for 74/100 test cases but exceeded time limit for the 75th case. \\n\\nI referred to [Algorithms made easy - @khushbugupta \\'s video](https://www.youtube.com/watch?v=2mva2YRgrW8) on union-find and implemented the same in C.\\n\\n```\\nint find_max(int* arr, int ASize)\\n{\\n    int max = arr[0];\\n    for(int i = 1; i < ASize; ++i)\\n    {\\n        max = arr[i] > max ? arr[i] : max;\\n    }\\n    return max;\\n}\\n\\nint find(int* arr, int x)\\n{\\n    if(arr[x] != x)\\n    {\\n        arr[x] = find(arr, arr[x]);\\n    }\\n    return arr[x];\\n}\\n\\nvoid unionn(int* arr, int x, int y)\\n{\\n    arr[find(arr, x)] = arr[find(arr, y)];\\n}\\n\\nint maximum(int x, int y)\\n{\\n    return x > y ? x : y;\\n}\\n\\nint largestComponentSize(int* A, int ASize)\\n{\\n    int max = find_max(A, ASize);\\n    int* relationships = (int*)malloc((max+1) * sizeof(int));\\n    for(int i = 0; i < max+1; ++i)\\n    {\\n        relationships[i] = i;\\n    }\\n    int num;\\n    for(int i = 0; i < ASize; ++i)\\n    {\\n        num = A[i];\\n        for(int j = 2; j <= sqrt(num); ++j)\\n        {\\n            if(num % j == 0)\\n            {\\n                unionn(relationships, num, j);\\n                unionn(relationships, num, num/j);\\n            }\\n        }\\n    }\\n    //the value at res_dict[i] denotes the number of nodes which have relationship with i\\n    int* res_dict = (int*)calloc(max+1, sizeof(int));\\n    int prime_num;\\n    int res = 0;\\n    for(int i = 0; i < ASize; ++i)\\n    {\\n        prime_num = find(relationships, A[i]);\\n        ++res_dict[prime_num];\\n        res = maximum(res, res_dict[prime_num]);\\n    }\\n    return res;\\n}\\n\\n\\n\\n//OWN ATTEMPT : EXCEEDED TIME LIMIT AFTER BEING SUCCESSFUL FOR 74/100 TEST CASES\\n/*int gcd(int a, int b) \\n{ \\n    if (a == 0) \\n        return b; \\n    return gcd(b%a, a); \\n}\\n\\n\\nint** construct_graph(int* A, int ASize) //construct a graph (adjacency matrix) with the given constraints\\n{\\n    int** graph = (int**)malloc(ASize * sizeof(int*));\\n    for(int i = 0; i < ASize; ++i)\\n    {\\n        graph[i] = (int*)malloc(ASize * sizeof(int));\\n    }\\n    for(int i = 0; i < ASize; ++i)\\n    {\\n        for(int j = i+1; j < ASize; ++j)\\n        {\\n            if(gcd(A[i], A[j]) != 1)\\n            {\\n                graph[i][j] = graph[j][i] = 1;\\n            }\\n            else\\n            {\\n                graph[i][j] = graph[j][i] = 0;\\n            }\\n        }\\n    }\\n    return graph;\\n}\\n\\n\\nstruct stack{\\n    int* arr;\\n    int top;\\n    int capacity;\\n};\\n\\ntypedef struct stack stack;\\n\\nstack* init_stack(int capacity)\\n{\\n    stack* st = (stack*)malloc(sizeof(stack));\\n    st -> top = -1;\\n    st -> capacity = capacity;\\n    st -> arr = (int*)malloc(capacity * sizeof(int));\\n    return st;\\n}\\n\\nint is_Full(stack* st)\\n{\\n    return st -> top == st -> capacity -1;\\n}\\n\\nint is_Empty(stack* st)\\n{\\n    return st -> top == -1;\\n}\\n\\nvoid push(stack* st, int key)\\n{\\n    if(!is_Full(st))\\n        st -> arr[++st -> top] = key;\\n}\\n\\nint pop(stack* st)\\n{\\n    if(!is_Empty(st))\\n        return st -> arr[st->top--];\\n    return -1;\\n}\\n\\nint find_length(int* A, int ASize, int** graph, int key_index, int* visited)\\n{\\n    int count = 0;\\n    stack* st = init_stack(ASize);\\n    int* inStack = (int*)calloc(ASize, sizeof(int));\\n    int node_index = key_index;\\n    push(st, node_index);\\n    inStack[node_index] = 1;\\n    while(!is_Empty(st))\\n    {\\n        node_index = pop(st);\\n        ++count;\\n        visited[node_index] = 1;\\n        for(int i = 0; i < ASize; ++i)\\n        {\\n            if(graph[node_index][i] && visited[i] == 0 && !inStack[i])\\n            {\\n                push(st, i);\\n                inStack[i] = 1;\\n            }\\n        }\\n    }\\n    return count;\\n}\\n\\nint largestComponentSize(int* A, int ASize){\\n    int** graph = construct_graph(A, ASize);\\n    int* visited = (int*)calloc(ASize, sizeof(int));\\n    int res = 0;\\n    int sub_graph_length;\\n    for(int i = 0; i < ASize; ++i)\\n    {\\n        if(visited[i] == 0)\\n        {\\n            sub_graph_length = find_length(A, ASize, graph, i, visited);\\n            if(sub_graph_length > res)\\n                res = sub_graph_length;\\n        }\\n    }\\n    return res;\\n}*/\\n```",
                "solutionTags": [],
                "code": "```\\nint find_max(int* arr, int ASize)\\n{\\n    int max = arr[0];\\n    for(int i = 1; i < ASize; ++i)\\n    {\\n        max = arr[i] > max ? arr[i] : max;\\n    }\\n    return max;\\n}\\n\\nint find(int* arr, int x)\\n{\\n    if(arr[x] != x)\\n    {\\n        arr[x] = find(arr, arr[x]);\\n    }\\n    return arr[x];\\n}\\n\\nvoid unionn(int* arr, int x, int y)\\n{\\n    arr[find(arr, x)] = arr[find(arr, y)];\\n}\\n\\nint maximum(int x, int y)\\n{\\n    return x > y ? x : y;\\n}\\n\\nint largestComponentSize(int* A, int ASize)\\n{\\n    int max = find_max(A, ASize);\\n    int* relationships = (int*)malloc((max+1) * sizeof(int));\\n    for(int i = 0; i < max+1; ++i)\\n    {\\n        relationships[i] = i;\\n    }\\n    int num;\\n    for(int i = 0; i < ASize; ++i)\\n    {\\n        num = A[i];\\n        for(int j = 2; j <= sqrt(num); ++j)\\n        {\\n            if(num % j == 0)\\n            {\\n                unionn(relationships, num, j);\\n                unionn(relationships, num, num/j);\\n            }\\n        }\\n    }\\n    //the value at res_dict[i] denotes the number of nodes which have relationship with i\\n    int* res_dict = (int*)calloc(max+1, sizeof(int));\\n    int prime_num;\\n    int res = 0;\\n    for(int i = 0; i < ASize; ++i)\\n    {\\n        prime_num = find(relationships, A[i]);\\n        ++res_dict[prime_num];\\n        res = maximum(res, res_dict[prime_num]);\\n    }\\n    return res;\\n}\\n\\n\\n\\n//OWN ATTEMPT : EXCEEDED TIME LIMIT AFTER BEING SUCCESSFUL FOR 74/100 TEST CASES\\n/*int gcd(int a, int b) \\n{ \\n    if (a == 0) \\n        return b; \\n    return gcd(b%a, a); \\n}\\n\\n\\nint** construct_graph(int* A, int ASize) //construct a graph (adjacency matrix) with the given constraints\\n{\\n    int** graph = (int**)malloc(ASize * sizeof(int*));\\n    for(int i = 0; i < ASize; ++i)\\n    {\\n        graph[i] = (int*)malloc(ASize * sizeof(int));\\n    }\\n    for(int i = 0; i < ASize; ++i)\\n    {\\n        for(int j = i+1; j < ASize; ++j)\\n        {\\n            if(gcd(A[i], A[j]) != 1)\\n            {\\n                graph[i][j] = graph[j][i] = 1;\\n            }\\n            else\\n            {\\n                graph[i][j] = graph[j][i] = 0;\\n            }\\n        }\\n    }\\n    return graph;\\n}\\n\\n\\nstruct stack{\\n    int* arr;\\n    int top;\\n    int capacity;\\n};\\n\\ntypedef struct stack stack;\\n\\nstack* init_stack(int capacity)\\n{\\n    stack* st = (stack*)malloc(sizeof(stack));\\n    st -> top = -1;\\n    st -> capacity = capacity;\\n    st -> arr = (int*)malloc(capacity * sizeof(int));\\n    return st;\\n}\\n\\nint is_Full(stack* st)\\n{\\n    return st -> top == st -> capacity -1;\\n}\\n\\nint is_Empty(stack* st)\\n{\\n    return st -> top == -1;\\n}\\n\\nvoid push(stack* st, int key)\\n{\\n    if(!is_Full(st))\\n        st -> arr[++st -> top] = key;\\n}\\n\\nint pop(stack* st)\\n{\\n    if(!is_Empty(st))\\n        return st -> arr[st->top--];\\n    return -1;\\n}\\n\\nint find_length(int* A, int ASize, int** graph, int key_index, int* visited)\\n{\\n    int count = 0;\\n    stack* st = init_stack(ASize);\\n    int* inStack = (int*)calloc(ASize, sizeof(int));\\n    int node_index = key_index;\\n    push(st, node_index);\\n    inStack[node_index] = 1;\\n    while(!is_Empty(st))\\n    {\\n        node_index = pop(st);\\n        ++count;\\n        visited[node_index] = 1;\\n        for(int i = 0; i < ASize; ++i)\\n        {\\n            if(graph[node_index][i] && visited[i] == 0 && !inStack[i])\\n            {\\n                push(st, i);\\n                inStack[i] = 1;\\n            }\\n        }\\n    }\\n    return count;\\n}\\n\\nint largestComponentSize(int* A, int ASize){\\n    int** graph = construct_graph(A, ASize);\\n    int* visited = (int*)calloc(ASize, sizeof(int));\\n    int res = 0;\\n    int sub_graph_length;\\n    for(int i = 0; i < ASize; ++i)\\n    {\\n        if(visited[i] == 0)\\n        {\\n            sub_graph_length = find_length(A, ASize, graph, i, visited);\\n            if(sub_graph_length > res)\\n                res = sub_graph_length;\\n        }\\n    }\\n    return res;\\n}*/\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 820496,
                "title": "union-find-java",
                "content": "n^2 brute force union find exceeds the time limit, uses a map here.\\n```\\nclass Solution {\\n    public int largestComponentSize(int[] A) {\\n        UF uf = new UF(A.length);\\n        \\n        Map<Integer, Integer> map = new HashMap<>();        \\n        for (int i = 0; i < A.length; i++)\\n        {            \\n            for (int j = 2; j * j <= A[i]; j++)\\n            {\\n                if (A[i] % j == 0)\\n                {\\n                    if (map.containsKey(j) && uf.find(i) != map.get(j))\\n                    {\\n                        uf.union(i, map.get(j));\\n                    }\\n                    else if (!map.containsKey(j))\\n                    {\\n                        map.put(j, i);\\n                    }\\n                    \\n                    if (map.containsKey(A[i] / j) && uf.find(i) != map.get(A[i] / j))\\n                    {\\n                        uf.union(i, map.get(A[i] / j));\\n                    }\\n                    else if (!map.containsKey(A[i] / j))\\n                    {\\n                        map.put(A[i] / j, i);\\n                    }\\n                }\\n            }\\n            \\n            if (map.containsKey(A[i]) && uf.find(i) != map.get(A[i]))\\n            {\\n                uf.union(i, map.get(A[i]));\\n            }\\n            else if (!map.containsKey(A[i]))\\n            {\\n                map.put(A[i], i);\\n            }\\n        }\\n        \\n        int[] counts = new int[A.length];\\n        int max = 0;\\n        \\n        for (int i = 0; i < A.length; i++)\\n        {\\n            counts[uf.find(i)]++;\\n            max = Math.max(max, counts[uf.find(i)]);\\n        }\\n        \\n        return max;\\n    }\\n    \\n    class UF\\n    {\\n        int[] roots;\\n        \\n        public UF(int length)\\n        {\\n            roots = new int[length];\\n            \\n            for (int i = 0; i < roots.length; i++)\\n            {\\n                roots[i] = i;\\n            }       \\n        }\\n        \\n        public void union(int i, int j)\\n        {   \\n            roots[find(i)] = roots[find(j)];\\n        }\\n        \\n        public int find(int i)\\n        {\\n            if (roots[i] != i)\\n            {\\n                roots[i] = find(roots[i]);\\n            }\\n            \\n            return roots[i];\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int largestComponentSize(int[] A) {\\n        UF uf = new UF(A.length);\\n        \\n        Map<Integer, Integer> map = new HashMap<>();        \\n        for (int i = 0; i < A.length; i++)\\n        {            \\n            for (int j = 2; j * j <= A[i]; j++)\\n            {\\n                if (A[i] % j == 0)\\n                {\\n                    if (map.containsKey(j) && uf.find(i) != map.get(j))\\n                    {\\n                        uf.union(i, map.get(j));\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 662628,
                "title": "union-find-prime-factorization-c-solution",
                "content": "```\\nclass Solution {\\n    vector<int> parent;\\npublic:\\n    int find(int x){\\n        if(parent[x]==-1) return x;\\n        return parent[x]=find(parent[x]);\\n    }\\n    void unio(int x,int y){\\n        int xd=find(x);\\n        int yd=find(y);\\n        if(xd!=yd){\\n            parent[xd]=yd;\\n        }\\n    }\\n    int largestComponentSize(vector<int>& A) {\\n        parent.resize(1000000+1,-1);\\n        for(auto a:A){\\n            int n=a;\\n            int count=0;\\n            while(n%2==0){\\n                n>>=1;\\n                count++;\\n            }\\n            if(count){\\n                unio(a,2);\\n            }\\n            for(int i=3;i<=sqrt(n);i++){\\n                int c=0;\\n                while(n%i==0){\\n                    n=n/i;\\n                    c++;\\n                }\\n                if(c){\\n                    unio(a,i);\\n                }\\n            }\\n            if(n>2){\\n                unio(a,n);\\n            }\\n        }\\n        unordered_map<int,int> mp;\\n        for(auto a:A){\\n            mp[find(a)]++;\\n        }\\n        int ans=1;\\n        for(auto m:mp){\\n            ans=max(ans,m.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> parent;\\npublic:\\n    int find(int x){\\n        if(parent[x]==-1) return x;\\n        return parent[x]=find(parent[x]);\\n    }\\n    void unio(int x,int y){\\n        int xd=find(x);\\n        int yd=find(y);\\n        if(xd!=yd){\\n            parent[xd]=yd;\\n        }\\n    }\\n    int largestComponentSize(vector<int>& A) {\\n        parent.resize(1000000+1,-1);\\n        for(auto a:A){\\n            int n=a;\\n            int count=0;\\n            while(n%2==0){\\n                n>>=1;\\n                count++;\\n            }\\n            if(count){\\n                unio(a,2);\\n            }\\n            for(int i=3;i<=sqrt(n);i++){\\n                int c=0;\\n                while(n%i==0){\\n                    n=n/i;\\n                    c++;\\n                }\\n                if(c){\\n                    unio(a,i);\\n                }\\n            }\\n            if(n>2){\\n                unio(a,n);\\n            }\\n        }\\n        unordered_map<int,int> mp;\\n        for(auto a:A){\\n            mp[find(a)]++;\\n        }\\n        int ans=1;\\n        for(auto m:mp){\\n            ans=max(ans,m.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640347,
                "title": "union-find-javascript-648ms",
                "content": "```\\n/**\\n * @param {number[]} A\\n * @return {number}\\n */\\n//UnionFind - 648ms - beats 100%\\n\\nvar largestComponentSize = function(A) {\\n    const p = []\\n    for(let num of A) {\\n        const set = getFactors(num)  // get the set of all the factors\\n        for(let factor of set.values()) {  \\n            p[find(factor)] = find(num) // union the number with all the factors\\n        }\\n    }\\n    \\n    const cntMap = new Map()\\n    for(let num of A) {   // for all the input numbers, count the related numbers via their parents \\n        const parent = find(num)\\n        cntMap.set(parent, (cntMap.get(parent) || 0) + 1) \\n    }\\n    return Math.max(...cntMap.values())\\n    \\n    function find(a) {\\n        if(!p[a]) p[a] = a\\n        while(p[a] !== a) {\\n            p[a] = p[p[a]]\\n            a = p[a]\\n        }\\n        return a\\n    }\\n    \\n    function getFactors(number) {\\n        const res = new Set()  // use set to guarantee no duplicates, no need to add number itself here. \\n        for (let i = 2; i * i <= number; i++) { \\n            if (number % i === 0) {\\n                res.add(i)\\n                res.add(number / i)\\n            }\\n        }\\n        return res\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @return {number}\\n */\\n//UnionFind - 648ms - beats 100%\\n\\nvar largestComponentSize = function(A) {\\n    const p = []\\n    for(let num of A) {\\n        const set = getFactors(num)  // get the set of all the factors\\n        for(let factor of set.values()) {  \\n            p[find(factor)] = find(num) // union the number with all the factors\\n        }\\n    }\\n    \\n    const cntMap = new Map()\\n    for(let num of A) {   // for all the input numbers, count the related numbers via their parents \\n        const parent = find(num)\\n        cntMap.set(parent, (cntMap.get(parent) || 0) + 1) \\n    }\\n    return Math.max(...cntMap.values())\\n    \\n    function find(a) {\\n        if(!p[a]) p[a] = a\\n        while(p[a] !== a) {\\n            p[a] = p[p[a]]\\n            a = p[a]\\n        }\\n        return a\\n    }\\n    \\n    function getFactors(number) {\\n        const res = new Set()  // use set to guarantee no duplicates, no need to add number itself here. \\n        for (let i = 2; i * i <= number; i++) { \\n            if (number % i === 0) {\\n                res.add(i)\\n                res.add(number / i)\\n            }\\n        }\\n        return res\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 476793,
                "title": "accepted-c-dsu-solution",
                "content": "```\\n    public class Solution\\n    {\\n        private class Unions\\n        {\\n            private readonly int[] _parents;\\n            private readonly int[] _ranks;\\n\\n            public Unions(int n)\\n            {\\n                _parents = new int[n];\\n                _ranks = new int[n];\\n                for (int i = 0; i < n; i++)\\n                {\\n                    _parents[i] = i;\\n                }\\n            }\\n\\n            public int Find(int x)\\n            {\\n                if (x != _parents[x])\\n                {\\n                    x = Find(_parents[x]);\\n                }\\n                return _parents[x];\\n            }\\n\\n            public bool Union(int x, int y)\\n            {\\n                int px = Find(x);\\n                int py = Find(y);\\n                if (px == py)\\n                {\\n                    return false;\\n                }\\n                if (_ranks[px] > _ranks[py])\\n                {\\n                    _parents[py] = px;\\n                    _ranks[px]++;\\n                }\\n                else\\n                {\\n                    _parents[px] = py;\\n                    _ranks[py]++;\\n                }\\n                return true;\\n            }\\n        }\\n\\n        public int LargestComponentSize(int[] nums)\\n        {\\n            IDictionary<int, int> factor2Root = new Dictionary<int, int>();\\n            Unions dsu = new Unions(nums.Length);\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                int currentNum = nums[i];\\n\\n                int factor = 2;\\n                while (factor * factor <= currentNum)\\n                {\\n                    if (currentNum % factor != 0)\\n                    {\\n                        factor++;\\n                        continue;\\n                    }\\n\\n                    if (factor2Root.ContainsKey(factor))\\n                    {\\n                        dsu.Union(i, factor2Root[factor]);\\n                    }\\n\\n                    factor2Root[factor] = dsu.Find(i);\\n\\n                    while (currentNum % factor == 0)\\n                    {\\n                        currentNum /= factor;\\n                    }\\n\\n                    factor++;\\n                }\\n\\n\\n                if (factor2Root.ContainsKey(nums[i]))\\n                {\\n                    dsu.Union(i, factor2Root[nums[i]]);\\n                }\\n                factor2Root[nums[i]] = dsu.Find(i);\\n\\n\\n\\n                if (currentNum != 1)\\n                {\\n                    if (factor2Root.ContainsKey(currentNum))\\n                    {\\n                        dsu.Union(i, factor2Root[currentNum]);\\n                    }\\n                    factor2Root[currentNum] = dsu.Find(i);\\n                }\\n            }\\n\\n            IDictionary<int, int> roots2Count = new Dictionary<int, int>();\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                var r = dsu.Find(i);\\n                if (!roots2Count.ContainsKey(r))\\n                {\\n                    roots2Count[r] = 0;\\n                }\\n\\n                roots2Count[r]++;\\n            }\\n\\n\\n            return roots2Count.Values.Max();\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        private class Unions\\n        {\\n            private readonly int[] _parents;\\n            private readonly int[] _ranks;\\n\\n            public Unions(int n)\\n            {\\n                _parents = new int[n];\\n                _ranks = new int[n];\\n                for (int i = 0; i < n; i++)\\n                {\\n                    _parents[i] = i;\\n                }\\n            }\\n\\n            public int Find(int x)\\n            {\\n                if (x != _parents[x])\\n                {\\n                    x = Find(_parents[x]);\\n                }\\n                return _parents[x];\\n            }\\n\\n            public bool Union(int x, int y)\\n            {\\n                int px = Find(x);\\n                int py = Find(y);\\n                if (px == py)\\n                {\\n                    return false;\\n                }\\n                if (_ranks[px] > _ranks[py])\\n                {\\n                    _parents[py] = px;\\n                    _ranks[px]++;\\n                }\\n                else\\n                {\\n                    _parents[px] = py;\\n                    _ranks[py]++;\\n                }\\n                return true;\\n            }\\n        }\\n\\n        public int LargestComponentSize(int[] nums)\\n        {\\n            IDictionary<int, int> factor2Root = new Dictionary<int, int>();\\n            Unions dsu = new Unions(nums.Length);\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                int currentNum = nums[i];\\n\\n                int factor = 2;\\n                while (factor * factor <= currentNum)\\n                {\\n                    if (currentNum % factor != 0)\\n                    {\\n                        factor++;\\n                        continue;\\n                    }\\n\\n                    if (factor2Root.ContainsKey(factor))\\n                    {\\n                        dsu.Union(i, factor2Root[factor]);\\n                    }\\n\\n                    factor2Root[factor] = dsu.Find(i);\\n\\n                    while (currentNum % factor == 0)\\n                    {\\n                        currentNum /= factor;\\n                    }\\n\\n                    factor++;\\n                }\\n\\n\\n                if (factor2Root.ContainsKey(nums[i]))\\n                {\\n                    dsu.Union(i, factor2Root[nums[i]]);\\n                }\\n                factor2Root[nums[i]] = dsu.Find(i);\\n\\n\\n\\n                if (currentNum != 1)\\n                {\\n                    if (factor2Root.ContainsKey(currentNum))\\n                    {\\n                        dsu.Union(i, factor2Root[currentNum]);\\n                    }\\n                    factor2Root[currentNum] = dsu.Find(i);\\n                }\\n            }\\n\\n            IDictionary<int, int> roots2Count = new Dictionary<int, int>();\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                var r = dsu.Find(i);\\n                if (!roots2Count.ContainsKey(r))\\n                {\\n                    roots2Count[r] = 0;\\n                }\\n\\n                roots2Count[r]++;\\n            }\\n\\n\\n            return roots2Count.Values.Max();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204482,
                "title": "elegant-solution-using-kotlin-with-sieve-of-eratosthenes-bfs-o-1-000-000",
                "content": "The idea is to construct a Bipartite Graph with left vertices contain prime numbers, right vertices contain A[i]\\n```\\n2    A[0]\\n3    A[1]\\n5    A[2]\\n7    A[3]\\n...\\n```\\nand edges connect `left[l]` with `right[r]` satisfying `right[r] mod left[l] = 0`\\nThe number of edges will < the complexity of Sieve of Eratosthenes, which is ~ `1000000`\\nSo the problem become simple: find the largest connected component using `BFS` or `DFS`\\nFor the sake of this problem, it\\'s possible that A[i] = A[j], so instead of A in the right vertices, we instead use count map to count the number of occurance of each unique A member.\\nComplexity: O (100000 * 10) for both `Sieve of Eratosthenes` and `BFS`\\n```\\nclass Solution {\\n    fun largestComponentSize(A: IntArray): Int {\\n        val count = A.toList().groupingBy { it }.eachCount().toMutableMap()\\n        val left = mutableMapOf<Int, MutableSet<Int>>()\\n        val right = mutableMapOf<Int, MutableSet<Int>>()\\n        val prime = BooleanArray(100001, { _ -> true })\\n        for (p in 2 until 100001) {\\n            if (prime[p]) {\\n                for (d in IntProgression.fromClosedRange(p, 100000, p)) {\\n                    if (d > p) prime[d] = false\\n                    if (count.containsKey(d)) {\\n                        left.computeIfAbsent(p, { _ -> hashSetOf() }).add(d)\\n                        right.computeIfAbsent(d, { _ -> hashSetOf() }).add(p)\\n                    }\\n                }\\n            }\\n        }\\n\\n        var max = 0\\n        while (left.isNotEmpty()) {\\n            val queue = mutableSetOf<Int>()\\n            var sum = 0\\n            queue.add(left.keys.first())\\n            while (queue.isNotEmpty()) {\\n                val l = queue.first().also { queue.remove(it) }\\n                val rs = left.remove(l) ?: emptyList<Int>()\\n                for (r in rs) {\\n                    sum += count.remove(r) ?: 0\\n                    queue.addAll((right.remove(r) ?: mutableSetOf()).toList())\\n                }\\n            }\\n            max = kotlin.math.max(max, sum)\\n        }\\n\\n        return max\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n2    A[0]\\n3    A[1]\\n5    A[2]\\n7    A[3]\\n...\\n```\n```\\nclass Solution {\\n    fun largestComponentSize(A: IntArray): Int {\\n        val count = A.toList().groupingBy { it }.eachCount().toMutableMap()\\n        val left = mutableMapOf<Int, MutableSet<Int>>()\\n        val right = mutableMapOf<Int, MutableSet<Int>>()\\n        val prime = BooleanArray(100001, { _ -> true })\\n        for (p in 2 until 100001) {\\n            if (prime[p]) {\\n                for (d in IntProgression.fromClosedRange(p, 100000, p)) {\\n                    if (d > p) prime[d] = false\\n                    if (count.containsKey(d)) {\\n                        left.computeIfAbsent(p, { _ -> hashSetOf() }).add(d)\\n                        right.computeIfAbsent(d, { _ -> hashSetOf() }).add(p)\\n                    }\\n                }\\n            }\\n        }\\n\\n        var max = 0\\n        while (left.isNotEmpty()) {\\n            val queue = mutableSetOf<Int>()\\n            var sum = 0\\n            queue.add(left.keys.first())\\n            while (queue.isNotEmpty()) {\\n                val l = queue.first().also { queue.remove(it) }\\n                val rs = left.remove(l) ?: emptyList<Int>()\\n                for (r in rs) {\\n                    sum += count.remove(r) ?: 0\\n                    queue.addAll((right.remove(r) ?: mutableSetOf()).toList())\\n                }\\n            }\\n            max = kotlin.math.max(max, sum)\\n        }\\n\\n        return max\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203266,
                "title": "java-solution-without-prime-factor",
                "content": "```\\n    int[] parent;\\n    int[] size;\\n    int res=0;\\n    public int largestComponentSize(int[] A) {\\n        parent=new int[A.length];\\n        size=new int[A.length];\\n        Map<Integer, List<Integer>> map=new HashMap<>();\\n        Map<Integer, Integer> pos=new HashMap<>();\\n        for(int i=0;i<A.length;i++) {\\n            parent[i]=-1;\\n            size[i]=1;\\n            pos.put(A[i], i);\\n            for(int j=1;j<=Math.sqrt(A[i]);j++) {\\n                if(A[i]%j==0) {\\n                    if(!map.containsKey(j)) map.put(j, new ArrayList<Integer>());\\n                    map.get(j).add(A[i]);\\n                    if(!map.containsKey(A[i]/j)) map.put(A[i]/j, new ArrayList<Integer>());\\n                    map.get(A[i]/j).add(A[i]);\\n                }\\n            }\\n        }\\n        map.remove(1);\\n        for(int i : map.keySet()) {\\n            List<Integer> cur=map.get(i);\\n            for(int j=0;j<cur.size()-1;j++) union(pos.get(cur.get(j)), pos.get(cur.get(j+1)));\\n        }\\n        return res;\\n    }\\n    \\n    public int find(int x) {\\n        while(parent[x]!=-1) x=parent[x];\\n        return x;\\n    }\\n    \\n    public void union(int x, int y) {\\n        int px=find(x), py=find(y);\\n        if(px!=py) {\\n            if(size[px]<size[py]) {\\n                parent[px]=py;\\n                size[py]+=size[px];\\n                res=Math.max(res, size[py]);\\n            }\\n            else {\\n                parent[py]=px;\\n                size[px]+=size[py];\\n                res=Math.max(res, size[px]);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "```\\n    int[] parent;\\n    int[] size;\\n    int res=0;\\n    public int largestComponentSize(int[] A) {\\n        parent=new int[A.length];\\n        size=new int[A.length];\\n        Map<Integer, List<Integer>> map=new HashMap<>();\\n        Map<Integer, Integer> pos=new HashMap<>();\\n        for(int i=0;i<A.length;i++) {\\n            parent[i]=-1;\\n            size[i]=1;\\n            pos.put(A[i], i);\\n            for(int j=1;j<=Math.sqrt(A[i]);j++) {\\n                if(A[i]%j==0) {\\n                    if(!map.containsKey(j)) map.put(j, new ArrayList<Integer>());\\n                    map.get(j).add(A[i]);\\n                    if(!map.containsKey(A[i]/j)) map.put(A[i]/j, new ArrayList<Integer>());\\n                    map.get(A[i]/j).add(A[i]);\\n                }\\n            }\\n        }\\n        map.remove(1);\\n        for(int i : map.keySet()) {\\n            List<Integer> cur=map.get(i);\\n            for(int j=0;j<cur.size()-1;j++) union(pos.get(cur.get(j)), pos.get(cur.get(j+1)));\\n        }\\n        return res;\\n    }\\n    \\n    public int find(int x) {\\n        while(parent[x]!=-1) x=parent[x];\\n        return x;\\n    }\\n    \\n    public void union(int x, int y) {\\n        int px=find(x), py=find(y);\\n        if(px!=py) {\\n            if(size[px]<size[py]) {\\n                parent[px]=py;\\n                size[py]+=size[px];\\n                res=Math.max(res, size[py]);\\n            }\\n            else {\\n                parent[py]=px;\\n                size[px]+=size[py];\\n                res=Math.max(res, size[px]);\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 202425,
                "title": "o-nlg-n-full-solution-with-explanation",
                "content": "since the maximum value of n<=100000, which means our solution must have atmost \\nT(n)<=O(nlg(n).\\nThe main crux of problem is to connect the two number having a divisor greater than 1.\\nAgain we know every number  can we written as multiple of prime numbers (prime factorisation).\\nWe will use sieve ***REFER*** [https://www.geeksforgeeks.org/prime-factorization-using-sieve-olog-n-multiple-queries/](http://)\\nI will tell anyway the psudo code of prime factorisation\\nprime_fact(n):\\nwhile(n%2==0):\\nn=n/2;        // 2 is prime factor\\nfor(i=3;i<=sqrt(n);i++):\\n\\twhile(n%i):\\n\\t\\tn=n/i;  // 3 is prime factor\\nif(n>2): \\nn                // n is primefacor\\n\\nWe will use MAP to store mapping from prime number to respective index.\\nThen will use Disjoint Union Find Data Structure with path compression  ***REFER***\\n[https://drive.google.com/file/d/1Zky8tK6GKRcoLUZMFdxqsEF0hTFSm1Pn/view?usp=sharing]\\n\\n\\n```\\nint find_root(vector<int>&id,int i){\\n    while(i!=id[i]){\\n        id[i]=id[id[i]]; //pathcompression;\\n        i=id[i];\\n    }\\n    return i;\\n}\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& A) {\\n        map<int,vector<int>>mymap;\\n        vector<int>id(A.size());\\n        vector<int>size(A.size(),1);\\n        for(int i=0;i<A.size();i++){\\n            id[i]=i;\\n        }\\n           \\n        int n;\\n        \\n        for(int i=0;i<A.size();i++){\\n            n=A[i];\\n            bool temp=false;\\n            while(n%2==0){\\n                n=n/2;\\n                temp=true;\\n             }\\n            if(temp==true) mymap[2].push_back(i);\\n            for(int k=3;k<=sqrt(n);k++){\\n                \\n                temp=false;\\n                while(n%k==0){\\n                    n=n/k;\\n                    temp=true;\\n                }\\n                \\n                if(temp==true) mymap[k].push_back(i);\\n            }\\n            \\n            if(n>2){\\n                mymap[n].push_back(i);\\n            }\\n            \\n        }\\n        \\n        int maxi=1;\\n        \\n        for(auto it=mymap.begin();it!=mymap.end();it++){\\n            \\n            for(int k=0;k<it->second.size()-1;k++){\\n                int pa=find_root(id,it->second[k]);\\n                int pb=find_root(id,it->second[k+1]);\\n                if(pa!=pb){\\n                    \\n                    if(size[pa]>size[pb]){\\n                        id[pb]=pa;\\n                        size[pa]+=size[pb];\\n                        maxi=max(maxi,size[pa]);\\n                    }\\n                    else{\\n                        id[pa]=pb;\\n                        size[pb]+=size[pa];\\n                        maxi=max(maxi,size[pb]);\\n                    }\\n                    \\n                }\\n                  \\n            }\\n            \\n        }\\n        return maxi;   \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint find_root(vector<int>&id,int i){\\n    while(i!=id[i]){\\n        id[i]=id[id[i]]; //pathcompression;\\n        i=id[i];\\n    }\\n    return i;\\n}\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& A) {\\n        map<int,vector<int>>mymap;\\n        vector<int>id(A.size());\\n        vector<int>size(A.size(),1);\\n        for(int i=0;i<A.size();i++){\\n            id[i]=i;\\n        }\\n           \\n        int n;\\n        \\n        for(int i=0;i<A.size();i++){\\n            n=A[i];\\n            bool temp=false;\\n            while(n%2==0){\\n                n=n/2;\\n                temp=true;\\n             }\\n            if(temp==true) mymap[2].push_back(i);\\n            for(int k=3;k<=sqrt(n);k++){\\n                \\n                temp=false;\\n                while(n%k==0){\\n                    n=n/k;\\n                    temp=true;\\n                }\\n                \\n                if(temp==true) mymap[k].push_back(i);\\n            }\\n            \\n            if(n>2){\\n                mymap[n].push_back(i);\\n            }\\n            \\n        }\\n        \\n        int maxi=1;\\n        \\n        for(auto it=mymap.begin();it!=mymap.end();it++){\\n            \\n            for(int k=0;k<it->second.size()-1;k++){\\n                int pa=find_root(id,it->second[k]);\\n                int pb=find_root(id,it->second[k+1]);\\n                if(pa!=pb){\\n                    \\n                    if(size[pa]>size[pb]){\\n                        id[pb]=pa;\\n                        size[pa]+=size[pb];\\n                        maxi=max(maxi,size[pa]);\\n                    }\\n                    else{\\n                        id[pa]=pb;\\n                        size[pb]+=size[pa];\\n                        maxi=max(maxi,size[pb]);\\n                    }\\n                    \\n                }\\n                  \\n            }\\n            \\n        }\\n        return maxi;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200618,
                "title": "python-1396ms-faster-than-official-2224ms-method",
                "content": "maybe you are curious about step 3. step 3 is to deal with the prime number which is larger than m ** 0.5. step 1,2,4 are very intuitive tbh. For the running time, they are not consistent for each run. I have submitted several times and below are the report.\\na few seconds ago\\tAccepted\\t1396 ms\\tpython\\na few seconds ago\\tAccepted\\t1572 ms\\tpython\\na few seconds ago\\tAccepted\\t1836 ms\\tpython\\na few seconds ago\\tAccepted\\t1696 ms\\tpython\\na few seconds ago\\tAccepted\\t1396 ms\\tpython\\n3 minutes ago\\tAccepted\\t1408 ms\\tpython\\n3 minutes ago\\tAccepted\\t1448 ms\\tpython\\n3 minutes ago\\tAccepted\\t1944 ms\\tpython\\n4 minutes ago\\tAccepted\\t1536 ms\\tpython\\n4 minutes ago\\tAccepted\\t1648 ms\\tpython\\n4 minutes ago\\tAccepted\\t1384 ms\\tpython\\n\\n\\n```\\nclass Solution(object):\\n    def largestComponentSize(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        parent = range(len(A))\\n        # Union Find\\n        def Findparent(i):\\n            if parent[i] != i:\\n                parent[i] = Findparent(parent[i])\\n            return parent[i]\\n\\n        # step 1: Sieve of Eratosthenes, only consider the prime number <= m ** 0.5 \\n        m = int(max(A) ** 0.5) + 1\\n        R = [1] * m\\n        prime = []\\n        for i in xrange(2, m):\\n            if R[i] == 1:\\n                prime.append(i)\\n            for j in xrange(i*i, m, i):\\n                R[j] = 0\\n        \\n        # step 2: check every prime number and do some prunes to narrow the search space\\n        B = range(len(A))\\n        for p in prime:\\n            tempB = []\\n            L = -1\\n            # print A, B, parent\\n            for idx in B:\\n                if A[idx] % p == 0:\\n                    if L == -1:\\n                        L = idx\\n                        a = Findparent(L)\\n                    else:\\n                        b = Findparent(idx)\\n                        parent[b] = a\\n                    while A[idx] % p == 0:\\n                        A[idx] /= p      \\n                if A[idx] > p:\\n                    tempB.append(idx)     \\n            B = tempB\\n        \\n        # step 3: deal with the number with primes > m ** 0.5 as its factors\\n        D = {}\\n        for idx in B:\\n            if A[idx] not in D:\\n                D[A[idx]] = []\\n            D[A[idx]].append(idx)\\n        # print D\\n        for i in D:\\n            if len(D[i]) > 1:\\n                a = Findparent(D[i][0])\\n                for j in xrange(1,len(D[i])):\\n                    b = Findparent(D[i][j])\\n                    parent[b] = a\\n               \\n        # step 4: do the counting\\n        D = {}\\n        for i in xrange(len(parent)):\\n            a = Findparent(i)\\n            if a not in D:\\n                D[a] = 0\\n            D[a] += 1\\n        return max(D.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def largestComponentSize(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        parent = range(len(A))\\n        # Union Find\\n        def Findparent(i):\\n            if parent[i] != i:\\n                parent[i] = Findparent(parent[i])\\n            return parent[i]\\n\\n        # step 1: Sieve of Eratosthenes, only consider the prime number <= m ** 0.5 \\n        m = int(max(A) ** 0.5) + 1\\n        R = [1] * m\\n        prime = []\\n        for i in xrange(2, m):\\n            if R[i] == 1:\\n                prime.append(i)\\n            for j in xrange(i*i, m, i):\\n                R[j] = 0\\n        \\n        # step 2: check every prime number and do some prunes to narrow the search space\\n        B = range(len(A))\\n        for p in prime:\\n            tempB = []\\n            L = -1\\n            # print A, B, parent\\n            for idx in B:\\n                if A[idx] % p == 0:\\n                    if L == -1:\\n                        L = idx\\n                        a = Findparent(L)\\n                    else:\\n                        b = Findparent(idx)\\n                        parent[b] = a\\n                    while A[idx] % p == 0:\\n                        A[idx] /= p      \\n                if A[idx] > p:\\n                    tempB.append(idx)     \\n            B = tempB\\n        \\n        # step 3: deal with the number with primes > m ** 0.5 as its factors\\n        D = {}\\n        for idx in B:\\n            if A[idx] not in D:\\n                D[A[idx]] = []\\n            D[A[idx]].append(idx)\\n        # print D\\n        for i in D:\\n            if len(D[i]) > 1:\\n                a = Findparent(D[i][0])\\n                for j in xrange(1,len(D[i])):\\n                    b = Findparent(D[i][j])\\n                    parent[b] = a\\n               \\n        # step 4: do the counting\\n        D = {}\\n        for i in xrange(len(parent)):\\n            a = Findparent(i)\\n            if a not in D:\\n                D[a] = 0\\n            D[a] += 1\\n        return max(D.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200614,
                "title": "accepted-python-prime-factorization-union-find-optimization",
                "content": "The idea is that we only establish sets tagged by prime numbers.\\nAnd we combine these sets according to the factorization of numbers in list A.\\nSo we can largely reduce the number of elements in Union Find.\\n\\nFor example:\\n```\\nA = [3, 4, 5, 6, 12]\\n3 = 3\\n4 = 2*2\\n5 = 5\\n6 = 2*3\\n12 = 2*2*3\\n```\\n\\nAt the beginning, we have some empty sets tagged by prime numbers 2, 3, 5, etc:\\nSET(tag = 2) has 0 elements.\\nSET(tag = 3) has 0 elements.\\nSET(tag = 5) has 0 elements.\\n\\nThen we check every number in the list A.\\n3 has prime factors: 3, so SET(tag = 3) now has 1 element.\\n\\n4 has prime factors: 2, so SET(tag = 2) now has 1 element.\\n\\n5 has prime factors: 5, so SET(tag = 5) now has 1 element.\\n\\n6 has prime factors: 2 and 3, so SET(tag = 2) now has 2 element. And we combine SET(tag = 3) with SET(tag = 2). Now SET(tag =2) has 3 elements. SET(tag = 3) also has 3 elements. It is obvious because SET(tag =2) and SET(tag =3) are the same set now.\\n\\n12 has prime factors: 2 andd 3, so SET(tag = 2) now has 4 element. And we combine SET(tag = 3) with SET(tag = 2) if they are not combined before. In this case, they have been already combined. Also SET(tag = 3) has 4 elements since it represents the same set as SET(tag = 2) does.\\n\\nSET(tag = 2) has 4 elements.\\nSET(tag = 3) has 4 elements.\\nSET(tag = 5) has 1 elements.\\n\\nThe answer is 4.\\n\\nThe 9,592nd prime is 99,991. The 9,593rd prime is 100,003.\\nSo by my method, we will have at most 9592 elements in the Union Find.\\n\\n2^17 = 131072 > 100000 and 2^16 = 65536. So a number under 10^5 has at most 16 factors. Actually numbers under 10^5 has 2.66 different prime factors on average. For Union Find, if m operations, either Union or Find, are applied to n elements, the total run time is O(m log n), where log is the iterated logarithm. (https://en.wikipedia.org/wiki/Proof_of_O(log*n)_time_complexity_of_union%E2%80%93find)\\n\\nSo considering this problem, the worst time complexcity is O(N m log n) = O (20000*2.66 * log2 9592) = O(703709).\\n\\n\\n```\\nclass Solution(object):\\n    def largestComponentSize(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def prime(n):\\n            if n <= 1:\\n                return 0\\n            for i in range(2,int(math.sqrt(n)+1)):\\n                if n%i == 0:\\n                    return 0\\n            return 1\\n\\n        def find(x):\\n            if x != UF[x]:\\n                UF[x] = find(UF[x])\\n            return UF[x]\\n        \\n        def union(x, y):\\n            xx, yy = find(x), find(y)\\n            if xx != yy:\\n                sum_UF[xx] += sum_UF[yy]\\n                UF[yy] = xx\\n        \\n        m = max(int((max(A))**0.5)+2, 3)\\n        primes = []\\n        for i in range(2,m+1):\\n            if prime(i):\\n                primes.append(i)\\n                \\n        sum_UF = {}\\n        UF = {}\\n        \\n        for x in A:\\n            if x == 1:\\n                continue\\n            tmp = x\\n            prime_factors = []\\n            i = 0\\n            while (i < len(primes)) and (primes[i] <= tmp**0.5):\\n                if tmp % primes[i] == 0:\\n                    prime_factors.append(primes[i])\\n                    while tmp % primes[i] == 0:\\n                        tmp = tmp // primes[i]\\n                i += 1\\n            if tmp != 1:\\n                prime_factors.append(tmp)\\n            \\n            for p in prime_factors:\\n                if p not in UF:\\n                    UF[p] = p\\n                    sum_UF[p] = 0\\n            \\n            sum_UF[find(prime_factors[0])] += 1\\n            if len(prime_factors) > 1:\\n                for i in range(1,len(prime_factors),1):\\n                    union(prime_factors[0], prime_factors[i])\\n            \\n        ans = 1\\n        for x in sum_UF:\\n            ans = max(ans,sum_UF[x])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nA = [3, 4, 5, 6, 12]\\n3 = 3\\n4 = 2*2\\n5 = 5\\n6 = 2*3\\n12 = 2*2*3\\n```\n```\\nclass Solution(object):\\n    def largestComponentSize(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def prime(n):\\n            if n <= 1:\\n                return 0\\n            for i in range(2,int(math.sqrt(n)+1)):\\n                if n%i == 0:\\n                    return 0\\n            return 1\\n\\n        def find(x):\\n            if x != UF[x]:\\n                UF[x] = find(UF[x])\\n            return UF[x]\\n        \\n        def union(x, y):\\n            xx, yy = find(x), find(y)\\n            if xx != yy:\\n                sum_UF[xx] += sum_UF[yy]\\n                UF[yy] = xx\\n        \\n        m = max(int((max(A))**0.5)+2, 3)\\n        primes = []\\n        for i in range(2,m+1):\\n            if prime(i):\\n                primes.append(i)\\n                \\n        sum_UF = {}\\n        UF = {}\\n        \\n        for x in A:\\n            if x == 1:\\n                continue\\n            tmp = x\\n            prime_factors = []\\n            i = 0\\n            while (i < len(primes)) and (primes[i] <= tmp**0.5):\\n                if tmp % primes[i] == 0:\\n                    prime_factors.append(primes[i])\\n                    while tmp % primes[i] == 0:\\n                        tmp = tmp // primes[i]\\n                i += 1\\n            if tmp != 1:\\n                prime_factors.append(tmp)\\n            \\n            for p in prime_factors:\\n                if p not in UF:\\n                    UF[p] = p\\n                    sum_UF[p] = 0\\n            \\n            sum_UF[find(prime_factors[0])] += 1\\n            if len(prime_factors) > 1:\\n                for i in range(1,len(prime_factors),1):\\n                    union(prime_factors[0], prime_factors[i])\\n            \\n        ans = 1\\n        for x in sum_UF:\\n            ans = max(ans,sum_UF[x])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200613,
                "title": "c-sieve-of-erastosthenes-219ms-roughly-o-n-log-2-n",
                "content": "Solution runs on 219ms (maybe there is a little bit more room for improvement, like using rank on DSU).\\nTime complexity: O((n * log(log(n))) * ackermann function(|A|)). Where n is the max number in the array.\\nA rough analysis would be around O(n * log^2(n)), assuming the ackermann would result in around O(log n).\\nAlgorithm:\\nUse Sieve of Erastosthenes to generate all primes.\\nWhile doing this, for each number we are going to mark as non-prime number,\\nwe can also check if the number is in our initial array.\\nIf yes, merge them together.\\n```\\nclass Solution {\\npublic:\\n    int p[100100], sz[100100];\\n    \\n    int find(int x) {\\n        return x == p[x] ? x : p[x] = find(p[x]);\\n    }\\n    \\n    void merge(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        if(x == y) return;\\n        sz[x] += sz[y];\\n        p[y] = x;\\n    }\\n    \\n    int largestComponentSize(vector<int>& A) {\\n        bool mark[100100] = {0}, used[100100] = {0};\\n        for(int x : A) {\\n            mark[x] = 1;\\n            p[x] = x;\\n            sz[x] = 1;\\n        }\\n        // Sieve of erastosthenes\\n        for(long long i = 2; i <= 100000; i++) {\\n            if(!used[i]) {\\n                int last = -1;\\n                // i is a prime, union all numbers which has i as its factor.\\n                for(long long j = i; j <= 100000; j += i) {\\n                    used[j] = 1;\\n                    if(mark[j]) {\\n                        if(last != -1) merge(last, j);\\n                        last = j;\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int x : A) ans = max(ans, sz[x]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int p[100100], sz[100100];\\n    \\n    int find(int x) {\\n        return x == p[x] ? x : p[x] = find(p[x]);\\n    }\\n    \\n    void merge(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        if(x == y) return;\\n        sz[x] += sz[y];\\n        p[y] = x;\\n    }\\n    \\n    int largestComponentSize(vector<int>& A) {\\n        bool mark[100100] = {0}, used[100100] = {0};\\n        for(int x : A) {\\n            mark[x] = 1;\\n            p[x] = x;\\n            sz[x] = 1;\\n        }\\n        // Sieve of erastosthenes\\n        for(long long i = 2; i <= 100000; i++) {\\n            if(!used[i]) {\\n                int last = -1;\\n                // i is a prime, union all numbers which has i as its factor.\\n                for(long long j = i; j <= 100000; j += i) {\\n                    used[j] = 1;\\n                    if(mark[j]) {\\n                        if(last != -1) merge(last, j);\\n                        last = j;\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int x : A) ans = max(ans, sz[x]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200581,
                "title": "for-those-who-are-stuck-with-tle-even-though-unionfind-is-used",
                "content": "It\\'s easy to come up with unionfind (UF) as the solution. And there is good algorithm to generate all the prime numbers no bigger than n (denote as P(n)).\\n\\nHowever, a O(nP(n)) solution is still too slow. The tricky part is here: don\\'t waste time on trying prime number p on every A[i]. Consider how you calculate the prime numbers under n: choose a number 2, mark all its multiples as false (non-prime). Then you go to 3, and 5, ... (4 is skipped because it has been marked in the round of 2). Together the time complexity is A[i]max(1/2+1/3+1/5+...). This is smaller than the famous Harmonic series (https://en.wikipedia.org/wiki/Harmonic_series_(mathematics) which grows very slowly.\\n\\nSimilar idea can be used after we have our candidate prime numbers. We choose a prime number (say, 2) and find are the multiple of 2\\'s in the given array A. If so, union them together (Actually union all the index with the first i where A[i]%2==0). Then do the case of 3, 5, 7, .... By HashMap (with A[i] as key and i as value). every prime number (denote as p) needs A[i]max/p steps. And the total time complexity for the second half is O(A[i]max*(1/2+1/3+1/5+...). This should pass the test cases.\\n\\n```\\nint[] id,size;\\n    public int largestComponentSize(int[] A) {\\n        Arrays.sort(A);\\n        int n = A.length;\\n        id = new int[n];\\n        size = new int[n];\\n        for(int i=0;i<n;i++){\\n            id[i] = i;\\n            size[i] = 1;\\n        }\\n        int max = Math.max(10,A[A.length-1]);\\n\\t\\t\\n\\t\\t// find out all the prime numbers that are no bigger than A[i]_max\\n        boolean[] pri = new boolean[max+1];\\n        Arrays.fill(pri,true);\\n        ArrayList<Integer> prime = new ArrayList<>();\\n        for(int i=2;i<=max;i++){\\n            if(!pri[i]) continue;\\n            prime.add(i);\\n            for(int j=i;j<=max;j+=i) pri[j]=false;\\n        }\\n\\t\\t\\n        HashMap<Integer,Integer> node = new HashMap<>();\\n        for(int i=0;i<A.length;i++) node.put(A[i],i);\\n        for(int w:prime){\\n            int last = -1;\\n\\t\\t\\t// last >= 0 means that there is at least one A[i] that is a multiple of w. Union all other index with it\\n            for(int i=w;i<=A[n-1];i+=w){\\n                if(!node.containsKey(i)) continue;\\n                if(last<0) last = node.get(i);\\n                else{\\n                    union(last,node.get(i));\\n                }\\n            }\\n        }\\n        int ans = 1;\\n        for(int i=0;i<n;i++){\\n            ans = Math.max(ans,size[find(i)]);\\n        }\\n        return ans;\\n    }\\n    public int find(int p){\\n        while(p!=id[p]){\\n            id[p] = id[id[p]];\\n            p = id[p];\\n        }\\n        return id[p];\\n    }\\n    public void union(int p, int q){\\n        int i = find(p);\\n        int j = find(q);\\n        if(i==j) return;\\n        if(size[i]<size[j]){\\n            id[i]=j;\\n            size[j]+=size[i];\\n        }else{\\n            id[j]=i;\\n            size[i]+=size[j];\\n        }\\n    }\\n\\t```\\nSorry for the weird English I might have used. Please feel free to ask any question.\\n",
                "solutionTags": [],
                "code": "```\\nint[] id,size;\\n    public int largestComponentSize(int[] A) {\\n        Arrays.sort(A);\\n        int n = A.length;\\n        id = new int[n];\\n        size = new int[n];\\n        for(int i=0;i<n;i++){\\n            id[i] = i;\\n            size[i] = 1;\\n        }\\n        int max = Math.max(10,A[A.length-1]);\\n\\t\\t\\n\\t\\t// find out all the prime numbers that are no bigger than A[i]_max\\n        boolean[] pri = new boolean[max+1];\\n        Arrays.fill(pri,true);\\n        ArrayList<Integer> prime = new ArrayList<>();\\n        for(int i=2;i<=max;i++){\\n            if(!pri[i]) continue;\\n            prime.add(i);\\n            for(int j=i;j<=max;j+=i) pri[j]=false;\\n        }\\n\\t\\t\\n        HashMap<Integer,Integer> node = new HashMap<>();\\n        for(int i=0;i<A.length;i++) node.put(A[i],i);\\n        for(int w:prime){\\n            int last = -1;\\n\\t\\t\\t// last >= 0 means that there is at least one A[i] that is a multiple of w. Union all other index with it\\n            for(int i=w;i<=A[n-1];i+=w){\\n                if(!node.containsKey(i)) continue;\\n                if(last<0) last = node.get(i);\\n                else{\\n                    union(last,node.get(i));\\n                }\\n            }\\n        }\\n        int ans = 1;\\n        for(int i=0;i<n;i++){\\n            ans = Math.max(ans,size[find(i)]);\\n        }\\n        return ans;\\n    }\\n    public int find(int p){\\n        while(p!=id[p]){\\n            id[p] = id[id[p]];\\n            p = id[p];\\n        }\\n        return id[p];\\n    }\\n    public void union(int p, int q){\\n        int i = find(p);\\n        int j = find(q);\\n        if(i==j) return;\\n        if(size[i]<size[j]){\\n            id[i]=j;\\n            size[j]+=size[i];\\n        }else{\\n            id[j]=i;\\n            size[i]+=size[j];\\n        }\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 3442124,
                "title": "union-find-c-soltuion-sieve-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> dsu,si;\\n    int find(int i)\\n    {\\n        if(i==dsu[i])return i;\\n        return dsu[i] = find(dsu[i]);\\n    }\\n    void f(int u ,int v)\\n    {\\n        int uu = find(u);\\n        int vv = find(v);\\n        if(uu==vv)return ;\\n        if(si[uu]<si[vv])\\n        {\\n            dsu[uu] = vv;\\n            si[vv]+=si[uu];\\n        }\\n        else \\n        {\\n            dsu[vv] = uu;\\n            si[uu]+=si[vv];\\n        }\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n      int n = nums.size(),x=0;\\n        dsu.resize(1e6);\\n        si.resize(1e6,1);\\n        for(int i=0;i<1e6;i++)\\n        {\\n            dsu[i] = i;\\n        }\\n        unordered_set<int>s;\\n        for(auto it:nums)\\n        {\\n          s.insert(it);\\n            x = max(x,it);\\n        }\\n        for(int i=2;i<=x;i++)\\n        {\\n            int last =-1;\\n            for(int j=i;j<=x;j+=i)\\n            {\\n                if(s.find(j)!=s.end())\\n                {\\n                    if(last==-1)last = j;\\n                else\\n                {\\n                    f(last,j);\\n                    last  = j;\\n                }\\n                }\\n               \\n            }\\n        }\\n        int res=0;\\n        for(auto it:si)\\n        {\\n          res = max(res,it);\\n        }\\n        return res;\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dsu,si;\\n    int find(int i)\\n    {\\n        if(i==dsu[i])return i;\\n        return dsu[i] = find(dsu[i]);\\n    }\\n    void f(int u ,int v)\\n    {\\n        int uu = find(u);\\n        int vv = find(v);\\n        if(uu==vv)return ;\\n        if(si[uu]<si[vv])\\n        {\\n            dsu[uu] = vv;\\n            si[vv]+=si[uu];\\n        }\\n        else \\n        {\\n            dsu[vv] = uu;\\n            si[uu]+=si[vv];\\n        }\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n      int n = nums.size(),x=0;\\n        dsu.resize(1e6);\\n        si.resize(1e6,1);\\n        for(int i=0;i<1e6;i++)\\n        {\\n            dsu[i] = i;\\n        }\\n        unordered_set<int>s;\\n        for(auto it:nums)\\n        {\\n          s.insert(it);\\n            x = max(x,it);\\n        }\\n        for(int i=2;i<=x;i++)\\n        {\\n            int last =-1;\\n            for(int j=i;j<=x;j+=i)\\n            {\\n                if(s.find(j)!=s.end())\\n                {\\n                    if(last==-1)last = j;\\n                else\\n                {\\n                    f(last,j);\\n                    last  = j;\\n                }\\n                }\\n               \\n            }\\n        }\\n        int res=0;\\n        for(auto it:si)\\n        {\\n          res = max(res,it);\\n        }\\n        return res;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2729366,
                "title": "connect-only-when-the-factor-is-1",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> p;\\n    vector<int> r;\\n    int gcd(int a , int b)\\n    {\\n          return b == 0 ? a : gcd(b, a % b);\\n    }\\n    \\n    int find(int k)\\n    {\\n        if(p[k] == k)\\n            return k;\\n        return p[k] = find(p[k]);\\n    }\\n    \\n    void unon(int a, int b)\\n    {\\n        int pa = find(a);\\n        int pb = find(b);\\n        if(pa == pb)\\n            return;\\n        if(r[pa]>r[pb]){\\n            p[pb] = pa;\\n            r[pa]+=r[pb];\\n        }\\n        else{\\n            p[pa] = pb;\\n            r[pb]+=r[pa];\\n        }\\n    }\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int ii = 0;\\n        p.resize(100002);\\n        r.resize(100002);\\n        for(int i=0;i<100002;i++)\\n        {\\n            p[i] = i;\\n            r[i] = 1;\\n        }\\n        \\n        \\n        \\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n            for(int j=2;j<=sqrt(nums[i]);j++)\\n            {\\n                if(nums[i]%j==0)\\n                {\\n                    unon(nums[i],j);\\n                    unon(nums[i],nums[i]/j);\\n                }\\n            }\\n        \\n        \\n        unordered_map<int, int> mp;\\n        for(auto i: nums)\\n        {\\n            int y = find(i);\\n            mp[y]++;\\n        }\\n        int res = 0;\\n        for(auto i: mp)\\n        {\\n            res = max(res,i.second);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> p;\\n    vector<int> r;\\n    int gcd(int a , int b)\\n    {\\n          return b == 0 ? a : gcd(b, a % b);\\n    }\\n    \\n    int find(int k)\\n    {\\n        if(p[k] == k)\\n            return k;\\n        return p[k] = find(p[k]);\\n    }\\n    \\n    void unon(int a, int b)\\n    {\\n        int pa = find(a);\\n        int pb = find(b);\\n        if(pa == pb)\\n            return;\\n        if(r[pa]>r[pb]){\\n            p[pb] = pa;\\n            r[pa]+=r[pb];\\n        }\\n        else{\\n            p[pa] = pb;\\n            r[pb]+=r[pa];\\n        }\\n    }\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int ii = 0;\\n        p.resize(100002);\\n        r.resize(100002);\\n        for(int i=0;i<100002;i++)\\n        {\\n            p[i] = i;\\n            r[i] = 1;\\n        }\\n        \\n        \\n        \\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n            for(int j=2;j<=sqrt(nums[i]);j++)\\n            {\\n                if(nums[i]%j==0)\\n                {\\n                    unon(nums[i],j);\\n                    unon(nums[i],nums[i]/j);\\n                }\\n            }\\n        \\n        \\n        unordered_map<int, int> mp;\\n        for(auto i: nums)\\n        {\\n            int y = find(i);\\n            mp[y]++;\\n        }\\n        int res = 0;\\n        for(auto i: mp)\\n        {\\n            res = max(res,i.second);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099232,
                "title": "java-solution-with-unionfind",
                "content": "```\\nclass Solution {\\n    public int largestComponentSize(int[] A) {\\n\\n        int maxValue = Arrays.stream(A).reduce(A[0], (x, y) -> x > y ? x : y);\\n        \\n        UnionFind uf = new UnionFind(maxValue + 1);\\n        \\n        // Attribute each element to all the groups that lead by its factors.\\n        for (int num : A) {\\n            for (int factor = 2; factor < (int)(Math.sqrt(num)) + 1; ++factor)\\n                if (num % factor == 0) {\\n                    uf.union(num, factor);\\n                    uf.union(num, num / factor);\\n                }\\n        }\\n\\n        int maxGroupSize = 0;\\n        HashMap<Integer, Integer> groupCount = new HashMap<>();\\n        for (int num : A) {\\n            Integer groupId = uf.find(num);\\n            Integer count = groupCount.getOrDefault(groupId, 0);\\n            groupCount.put(groupId, count+1);\\n            maxGroupSize = Math.max(maxGroupSize, count+1);\\n        }\\n\\n        return maxGroupSize;\\n    }\\n}\\n\\nclass UnionFind {\\n    int[] parents;\\n    int[] ranks;\\n\\n    public UnionFind(int n) {\\n        this.parents = new int[n];\\n        this.ranks = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            this.parents[i] = i;\\n            this.ranks[i] = 1;\\n        }\\n    }\\n\\n    public int find(int x) {\\n        if (parents[x] != x) parents[x] = find(parents[x]);\\n\\n        return parents[x];\\n    }\\n\\n    public void union(int x, int y) {\\n        int xRoot = find(x);\\n        int yRoot = find(y);\\n\\n        if (xRoot == yRoot) return;\\n\\n        if (ranks[xRoot] < ranks[yRoot]) {\\n            parents[xRoot] = yRoot;\\n        } else {\\n            parents[yRoot] = xRoot;\\n        }\\n\\n        if (ranks[xRoot] == ranks[yRoot]) {\\n            ranks[xRoot]++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestComponentSize(int[] A) {\\n\\n        int maxValue = Arrays.stream(A).reduce(A[0], (x, y) -> x > y ? x : y);\\n        \\n        UnionFind uf = new UnionFind(maxValue + 1);\\n        \\n        // Attribute each element to all the groups that lead by its factors.\\n        for (int num : A) {\\n            for (int factor = 2; factor < (int)(Math.sqrt(num)) + 1; ++factor)\\n                if (num % factor == 0) {\\n                    uf.union(num, factor);\\n                    uf.union(num, num / factor);\\n                }\\n        }\\n\\n        int maxGroupSize = 0;\\n        HashMap<Integer, Integer> groupCount = new HashMap<>();\\n        for (int num : A) {\\n            Integer groupId = uf.find(num);\\n            Integer count = groupCount.getOrDefault(groupId, 0);\\n            groupCount.put(groupId, count+1);\\n            maxGroupSize = Math.max(maxGroupSize, count+1);\\n        }\\n\\n        return maxGroupSize;\\n    }\\n}\\n\\nclass UnionFind {\\n    int[] parents;\\n    int[] ranks;\\n\\n    public UnionFind(int n) {\\n        this.parents = new int[n];\\n        this.ranks = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            this.parents[i] = i;\\n            this.ranks[i] = 1;\\n        }\\n    }\\n\\n    public int find(int x) {\\n        if (parents[x] != x) parents[x] = find(parents[x]);\\n\\n        return parents[x];\\n    }\\n\\n    public void union(int x, int y) {\\n        int xRoot = find(x);\\n        int yRoot = find(y);\\n\\n        if (xRoot == yRoot) return;\\n\\n        if (ranks[xRoot] < ranks[yRoot]) {\\n            parents[xRoot] = yRoot;\\n        } else {\\n            parents[yRoot] = xRoot;\\n        }\\n\\n        if (ranks[xRoot] == ranks[yRoot]) {\\n            ranks[xRoot]++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097394,
                "title": "c-o-nlogn-solution-using-dfs-and-sieve-of-eratosthenes-easy-to-understand",
                "content": "In this approach, I\\'m using Sieve of Eratosthenes to compute all the prime numbers till 10^5 and then store them in an array `primelist`. Then, I can compute unique prime factors for each number in LogN using the `factors()` function. \\n\\nFor every unique prime factor of nums[i], if a previous number in the array had the same prime factor (hashmap `m` is used to store this information), then this number is connected to that node (Just that node is sufficient. No need to connect to all previous nodes that had this prime factor because we only to need to calculate the component size and hence all the connections need not to be made. If we try to connect all the edges, then the number of edges can be n^2 which is not at all feasible because n <= 10^4). if none of the previous numbers had the same prime factor, then this index is stored for that particular prime factor in the hashmap `m`.\\n\\nThe maximum number of unique prime factors that a number <= 10^5 is 6. So, the maximum number of edges in the graph is n * 6 which is feasible. \\n\\nNow, we can just run a simple DFS to calculate the maximum component size in the graph.\\n\\n```\\nclass Solution {\\nprivate:\\n    vector<bool> sieve(int n) {\\n        vector<bool> prime(n + 1);\\n        for (int i = 0; i <= n; i++)\\n            prime[i] = 1;\\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p] == 1) {\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = 0;\\n            }\\n        }\\n        prime[1] = prime[0] = 0;\\n        return prime;\\n    }\\n    vector<int> factors(int n, vector<int> &primelist) {\\n        vector<int> facs;\\n        for (int i = 0; primelist[i] * primelist[i] <= n && i < primelist.size(); i++) {\\n            if (n % primelist[i] == 0) {\\n                facs.push_back(primelist[i]);\\n                while (n % primelist[i] == 0) {\\n                    n /= primelist[i];\\n                }\\n            }\\n        }\\n        if (n > 1) facs.push_back(n);\\n        return facs;\\n    }\\n    void dfs(vector<vector<int>> &gr, int node, vector<int> &vis, int &compSize) {\\n        if(vis[node]) return;\\n        vis[node] = 1;\\n        compSize++;\\n        for(auto x : gr[node]) {\\n            dfs(gr, x, vis, compSize);\\n        }\\n    }\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> gr(n);\\n        vector<bool> prime = sieve(1e5 + 6);\\n        vector<int> primelist;\\n\\t\\t// Getting all the primes till 10^5 as maximum value of nums[i] is 10^5\\n        for (int i = 2; i <= 1e5 + 5; i++) if (prime[i]) primelist.push_back(i);\\n        unordered_map<int, int> m; // to store the index of the node with prime factor x\\n        for(int i = 0; i < n; i++) {\\n            vector<int> facs = factors(nums[i], primelist);\\n            for(auto j : facs) {\\n                if(m.find(j) == m.end()) { // prime factor had not occured before\\n                    m[j] = i; // j is the prime factor and its index is i\\n                } else {\\n\\t\\t\\t\\t    // prime factor has already been seen before in a previous number and nums[i] is connected to that number\\n                    gr[i].push_back(m[j]);\\n                    gr[m[j]].push_back(i);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        vector<int> vis(n);\\n        for(int i = 0; i < n; i++) { // running a simple dfs to calculate the maximum component size\\n            if(!vis[i]) {\\n                int compSize = 0;\\n                dfs(gr, i, vis, compSize);\\n                ans = max(ans, compSize);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<bool> sieve(int n) {\\n        vector<bool> prime(n + 1);\\n        for (int i = 0; i <= n; i++)\\n            prime[i] = 1;\\n        for (int p = 2; p * p <= n; p++) {\\n            if (prime[p] == 1) {\\n                for (int i = p * p; i <= n; i += p)\\n                    prime[i] = 0;\\n            }\\n        }\\n        prime[1] = prime[0] = 0;\\n        return prime;\\n    }\\n    vector<int> factors(int n, vector<int> &primelist) {\\n        vector<int> facs;\\n        for (int i = 0; primelist[i] * primelist[i] <= n && i < primelist.size(); i++) {\\n            if (n % primelist[i] == 0) {\\n                facs.push_back(primelist[i]);\\n                while (n % primelist[i] == 0) {\\n                    n /= primelist[i];\\n                }\\n            }\\n        }\\n        if (n > 1) facs.push_back(n);\\n        return facs;\\n    }\\n    void dfs(vector<vector<int>> &gr, int node, vector<int> &vis, int &compSize) {\\n        if(vis[node]) return;\\n        vis[node] = 1;\\n        compSize++;\\n        for(auto x : gr[node]) {\\n            dfs(gr, x, vis, compSize);\\n        }\\n    }\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> gr(n);\\n        vector<bool> prime = sieve(1e5 + 6);\\n        vector<int> primelist;\\n\\t\\t// Getting all the primes till 10^5 as maximum value of nums[i] is 10^5\\n        for (int i = 2; i <= 1e5 + 5; i++) if (prime[i]) primelist.push_back(i);\\n        unordered_map<int, int> m; // to store the index of the node with prime factor x\\n        for(int i = 0; i < n; i++) {\\n            vector<int> facs = factors(nums[i], primelist);\\n            for(auto j : facs) {\\n                if(m.find(j) == m.end()) { // prime factor had not occured before\\n                    m[j] = i; // j is the prime factor and its index is i\\n                } else {\\n\\t\\t\\t\\t    // prime factor has already been seen before in a previous number and nums[i] is connected to that number\\n                    gr[i].push_back(m[j]);\\n                    gr[m[j]].push_back(i);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        vector<int> vis(n);\\n        for(int i = 0; i < n; i++) { // running a simple dfs to calculate the maximum component size\\n            if(!vis[i]) {\\n                int compSize = 0;\\n                dfs(gr, i, vis, compSize);\\n                ans = max(ans, compSize);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078280,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Union Find***\\n\\n* ***Time Complexity : O(N * sqrt(N))***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> parent;\\n    \\n    vector<int> rank;\\n    \\n    int find(int x)\\n    {\\n        if(parent[x] == x)\\n        {\\n            return x;\\n        }\\n        \\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    void _union(int x, int y)\\n    {\\n        int x_par = find(x);\\n        \\n        int y_par = find(y);\\n        \\n        if(x_par == y_par)\\n        {\\n            return;\\n        }\\n        if(rank[x_par] > rank[y_par])\\n        {\\n            parent[y_par] = x_par;\\n        }\\n        else if(rank[x_par] < rank[y_par])\\n        {\\n            parent[x_par] = y_par;\\n        }\\n        else\\n        {\\n            parent[y_par] = x_par;\\n            \\n            rank[x_par]++;\\n        }\\n    }\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int size = *max_element(nums.begin(), nums.end());\\n        \\n        parent.resize(size + 1);\\n        \\n        rank.resize(size + 1);\\n        \\n        for(int i = 0; i <= size; i++)\\n        {\\n            parent[i] = i;\\n            \\n            rank[i] = 1;\\n        }\\n        \\n        int maxi = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 2; j <= sqrt(nums[i]); j++)\\n            {\\n                if(nums[i] % j == 0)\\n                {\\n                    _union(nums[i], j);\\n                    \\n                    _union(nums[i], nums[i] / j);\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int, int> mp;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int x_par = find(nums[i]);\\n            \\n            mp[x_par]++;\\n            \\n            maxi = max(maxi, mp[x_par]);\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> parent;\\n    \\n    vector<int> rank;\\n    \\n    int find(int x)\\n    {\\n        if(parent[x] == x)\\n        {\\n            return x;\\n        }\\n        \\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    void _union(int x, int y)\\n    {\\n        int x_par = find(x);\\n        \\n        int y_par = find(y);\\n        \\n        if(x_par == y_par)\\n        {\\n            return;\\n        }\\n        if(rank[x_par] > rank[y_par])\\n        {\\n            parent[y_par] = x_par;\\n        }\\n        else if(rank[x_par] < rank[y_par])\\n        {\\n            parent[x_par] = y_par;\\n        }\\n        else\\n        {\\n            parent[y_par] = x_par;\\n            \\n            rank[x_par]++;\\n        }\\n    }\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int size = *max_element(nums.begin(), nums.end());\\n        \\n        parent.resize(size + 1);\\n        \\n        rank.resize(size + 1);\\n        \\n        for(int i = 0; i <= size; i++)\\n        {\\n            parent[i] = i;\\n            \\n            rank[i] = 1;\\n        }\\n        \\n        int maxi = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 2; j <= sqrt(nums[i]); j++)\\n            {\\n                if(nums[i] % j == 0)\\n                {\\n                    _union(nums[i], j);\\n                    \\n                    _union(nums[i], nums[i] / j);\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int, int> mp;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int x_par = find(nums[i]);\\n            \\n            mp[x_par]++;\\n            \\n            maxi = max(maxi, mp[x_par]);\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905677,
                "title": "python-sol-union-find-explained",
                "content": "# EXPLANATION\\n```\\nUnion and Find is must !!\\nOne way is to find GCD of every pair and if GCD > 1 means they have an edge so do union \\nBut this method will give TLE \\n\\nNow a better solution is by using factors\\nFactors of 21 are : 3 , 7 \\nFactors of 63 are : 3 , 7 , 9 , 21\\n\\nSo for 21 we have a child 3 and 7\\nFor 63 we have child 3 \\nBut 3\\'s parent is 21 so 21 and 63 will be joined\\n```\\n\\n# CODE\\n```\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        \\n        def find(node):\\n            if parent[node] == -1: return node\\n            else:\\n                parent[node] = find(parent[node])\\n                return parent[node]\\n        \\n        def union(idx1,idx2):\\n            par1,par2 = find(idx1),find(idx2)\\n            if par1!=par2:\\n                if rank[par1] > rank[par2]:\\n                    parent[par2] = par1\\n                elif rank[par2] > rank[par1]:\\n                    parent[par1] = par2\\n                else:\\n                    parent[par2] = par1\\n                    rank[par1] += 1\\n        \\n        n = len(nums)\\n        parent = defaultdict(lambda:-1)\\n        rank = defaultdict(lambda:0)\\n        for i in range(n):\\n            limit = int(nums[i]**0.5)\\n            for j in range(2,limit+1):\\n                if nums[i] % j == 0:\\n                    union(nums[i],j)\\n                    union(nums[i],nums[i]//j)\\n        count = defaultdict(lambda:0)\\n        best = -1\\n        for num in nums:\\n            par = find(num)\\n            tmp = count[par] + 1\\n            if tmp > best: best = tmp\\n            count[par] = tmp\\n        return best\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nUnion and Find is must !!\\nOne way is to find GCD of every pair and if GCD > 1 means they have an edge so do union \\nBut this method will give TLE \\n\\nNow a better solution is by using factors\\nFactors of 21 are : 3 , 7 \\nFactors of 63 are : 3 , 7 , 9 , 21\\n\\nSo for 21 we have a child 3 and 7\\nFor 63 we have child 3 \\nBut 3\\'s parent is 21 so 21 and 63 will be joined\\n```\n```\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        \\n        def find(node):\\n            if parent[node] == -1: return node\\n            else:\\n                parent[node] = find(parent[node])\\n                return parent[node]\\n        \\n        def union(idx1,idx2):\\n            par1,par2 = find(idx1),find(idx2)\\n            if par1!=par2:\\n                if rank[par1] > rank[par2]:\\n                    parent[par2] = par1\\n                elif rank[par2] > rank[par1]:\\n                    parent[par1] = par2\\n                else:\\n                    parent[par2] = par1\\n                    rank[par1] += 1\\n        \\n        n = len(nums)\\n        parent = defaultdict(lambda:-1)\\n        rank = defaultdict(lambda:0)\\n        for i in range(n):\\n            limit = int(nums[i]**0.5)\\n            for j in range(2,limit+1):\\n                if nums[i] % j == 0:\\n                    union(nums[i],j)\\n                    union(nums[i],nums[i]//j)\\n        count = defaultdict(lambda:0)\\n        best = -1\\n        for num in nums:\\n            par = find(num)\\n            tmp = count[par] + 1\\n            if tmp > best: best = tmp\\n            count[par] = tmp\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1796746,
                "title": "union-find-algorithm-o-nlogn-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int parent[100001];\\n    int rank[100001];\\n    \\n    int findparent(int node){\\n        if(parent[node]==node){\\n            return node;\\n        }\\n        \\n        return parent[node]=findparent(parent[node]);\\n    }\\n    \\n    void unionp(int x,int y){\\n        x=findparent(x);\\n        y=findparent(y);\\n        if(x==y){\\n            return;\\n        }\\n        if(rank[x]>rank[y]){\\n               parent[y]=x;\\n        }else if(rank[x]<rank[y]){\\n               parent[x]=y;\\n           \\n        }else{\\n               parent[x]=y;\\n               rank[y]++;\\n           \\n        }\\n    }\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        for(int i=0;i<100001;i++){\\n            rank[i]=0;\\n            parent[i]=i;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=2;j<=sqrt(nums[i]);j++){\\n                if(nums[i]%j==0){\\n                    unionp(nums[i],j);\\n                    unionp(nums[i],nums[i]/j);\\n                }\\n            }\\n        }\\n        int maxsize=0;\\n        map<int,int> m;\\n        for(int i=0;i<nums.size();i++){\\n           int x=findparent(nums[i]);\\n            m[x]++;\\n            if(maxsize<m[x]){\\n                maxsize=m[x];\\n            }\\n           \\n        }\\n        return maxsize;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int parent[100001];\\n    int rank[100001];\\n    \\n    int findparent(int node){\\n        if(parent[node]==node){\\n            return node;\\n        }\\n        \\n        return parent[node]=findparent(parent[node]);\\n    }\\n    \\n    void unionp(int x,int y){\\n        x=findparent(x);\\n        y=findparent(y);\\n        if(x==y){\\n            return;\\n        }\\n        if(rank[x]>rank[y]){\\n               parent[y]=x;\\n        }else if(rank[x]<rank[y]){\\n               parent[x]=y;\\n           \\n        }else{\\n               parent[x]=y;\\n               rank[y]++;\\n           \\n        }\\n    }\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        for(int i=0;i<100001;i++){\\n            rank[i]=0;\\n            parent[i]=i;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=2;j<=sqrt(nums[i]);j++){\\n                if(nums[i]%j==0){\\n                    unionp(nums[i],j);\\n                    unionp(nums[i],nums[i]/j);\\n                }\\n            }\\n        }\\n        int maxsize=0;\\n        map<int,int> m;\\n        for(int i=0;i<nums.size();i++){\\n           int x=findparent(nums[i]);\\n            m[x]++;\\n            if(maxsize<m[x]){\\n                maxsize=m[x];\\n            }\\n           \\n        }\\n        return maxsize;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598090,
                "title": "java-using-union-find-o-n-sqrt-m",
                "content": "```\\nclass Solution {\\n    public int largestComponentSize(int[] A) {\\n        int max = 0;\\n        for(int a : A) {\\n            max = Math.max(max, a);\\n        }\\n        \\n        int[] roots = new int[max + 1],sizes = new int[max + 1];\\n        for(int idx = 1; idx <= max; idx++){\\n            roots[idx] = idx;\\n        }\\n        \\n        for(int a : A){\\n            if(a == 1){\\n                sizes[a] = 1;\\n                continue;\\n            }\\n            \\n            int sqrt = (int) Math.sqrt(a);\\n            int thisRoot = getRoot(roots, a);\\n            sizes[thisRoot]++;\\n            \\n            for(int factor = 1; factor <= sqrt; factor++){\\n                if(a % factor == 0){\\n                    int otherFactor = a / factor;\\n                    int factorRoot = getRoot(roots, factor);\\n                    int otherFactorRoot = getRoot(roots, otherFactor);\\n                    \\n                    if(factor != 1){\\n                        union(roots, thisRoot, factor, sizes);\\n                    }\\n                    union(roots, thisRoot, otherFactorRoot, sizes);\\n                }\\n            }\\n        }\\n        \\n        int maxConnection = 0;\\n        for(int size : sizes){\\n            maxConnection = Math.max(maxConnection, size);\\n        }\\n        \\n        return maxConnection;\\n    }\\n    \\n    public void union(int[] roots, int a, int b, int[] sizes){\\n        int rootA = getRoot(roots, a);\\n        int rootB = getRoot(roots, b);\\n        if(rootA != rootB){    \\n            sizes[rootA] += sizes[rootB];\\n            roots[rootB] = rootA;\\n        }\\n    }\\n    \\n    public int getRoot(int[] roots, int a){\\n        if(roots[a] == a){\\n            return a;\\n        }\\n        return roots[a] = getRoot(roots, roots[a]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int largestComponentSize(int[] A) {\\n        int max = 0;\\n        for(int a : A) {\\n            max = Math.max(max, a);\\n        }\\n        \\n        int[] roots = new int[max + 1],sizes = new int[max + 1];\\n        for(int idx = 1; idx <= max; idx++){\\n            roots[idx] = idx;\\n        }\\n        \\n        for(int a : A){\\n            if(a == 1){\\n                sizes[a] = 1;\\n                continue;\\n            }\\n            \\n            int sqrt = (int) Math.sqrt(a);\\n            int thisRoot = getRoot(roots, a);\\n            sizes[thisRoot]++;\\n            \\n            for(int factor = 1; factor <= sqrt; factor++){\\n                if(a % factor == 0){\\n                    int otherFactor = a / factor;\\n                    int factorRoot = getRoot(roots, factor);\\n                    int otherFactorRoot = getRoot(roots, otherFactor);\\n                    \\n                    if(factor != 1){\\n                        union(roots, thisRoot, factor, sizes);\\n                    }\\n                    union(roots, thisRoot, otherFactorRoot, sizes);\\n                }\\n            }\\n        }\\n        \\n        int maxConnection = 0;\\n        for(int size : sizes){\\n            maxConnection = Math.max(maxConnection, size);\\n        }\\n        \\n        return maxConnection;\\n    }\\n    \\n    public void union(int[] roots, int a, int b, int[] sizes){\\n        int rootA = getRoot(roots, a);\\n        int rootB = getRoot(roots, b);\\n        if(rootA != rootB){    \\n            sizes[rootA] += sizes[rootB];\\n            roots[rootB] = rootA;\\n        }\\n    }\\n    \\n    public int getRoot(int[] roots, int a){\\n        if(roots[a] == a){\\n            return a;\\n        }\\n        return roots[a] = getRoot(roots, roots[a]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596937,
                "title": "python-solution-o-n-sqrt-max-nums-time-o-max-nums-space-union-find-faster-than-31",
                "content": "\\t# Union Find Set  \\n\\tclass UnionFindSet: \\n\\t\\tdef __init__(self, n): \\n\\t\\t\\tself.parents = [i for i in range(n+1)]\\n\\t\\t\\tself.ranks = [1 for _ in range(n+1)]\\n\\n\\t\\tdef find(self, u): \\n\\t\\t\\twhile u != self.parents[u]: \\n\\t\\t\\t\\tself.parents[u] = self.parents[self.parents[u]]\\n\\t\\t\\t\\tu = self.parents[u]\\n\\t\\t\\treturn u\\n\\n\\t\\tdef union(self, u, v): \\n\\t\\t\\tu_parent = self.find(u)\\n\\t\\t\\tv_parent = self.find(v)\\n\\t\\t\\tif u_parent == v_parent: \\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tif self.ranks[u_parent] > self.ranks[v_parent]:   \\n\\t\\t\\t\\tself.parents[v_parent] = u_parent\\n\\t\\t\\telif self.ranks[u_parent] < self.ranks[v_parent]: \\n\\t\\t\\t\\tself.parents[u_parent] = v_parent\\n\\t\\t\\telif self.ranks[u_parent] == self.ranks[v_parent]: \\n\\t\\t\\t\\tself.parents[v_parent] = u_parent\\n\\t\\t\\t\\tself.ranks[u_parent] += 1\\n\\t\\t\\treturn True    \\n\\n\\n\\tclass Solution(object):\\n\\t\\tdef largestComponentSize(self, nums):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type nums: List[int]\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tmax_num = max(nums)\\n\\t\\t\\tunion_find_set = UnionFindSet(max_num+1)\\n\\n\\t\\t\\tfor num in nums: \\n\\t\\t\\t\\tsqrt_num = int(num**(1/2.0))+1\\n\\t\\t\\t\\tfor i in range(2, sqrt_num): \\n\\t\\t\\t\\t\\tif num%i==0: \\n\\t\\t\\t\\t\\t\\tunion_find_set.union(num, i) \\n\\t\\t\\t\\t\\t\\tunion_find_set.union(num, num/i)\\n\\n\\t\\t\\tfrom collections import defaultdict\\n\\t\\t\\tres = defaultdict(int)            \\n\\t\\t\\tfor num in nums: \\n\\t\\t\\t\\tres[union_find_set.find(num)] += 1\\n\\t\\t\\t# print(res.values())    \\n\\t\\t\\treturn max(res.values())\\n\\n",
                "solutionTags": [],
                "code": "\\t# Union Find Set  \\n\\tclass UnionFindSet: \\n\\t\\tdef __init__(self, n): \\n\\t\\t\\tself.parents = [i for i in range(n+1)]\\n\\t\\t\\tself.ranks = [1 for _ in range(n+1)]\\n\\n\\t\\tdef find(self, u): \\n\\t\\t\\twhile u != self.parents[u]: \\n\\t\\t\\t\\tself.parents[u] = self.parents[self.parents[u]]\\n\\t\\t\\t\\tu = self.parents[u]\\n\\t\\t\\treturn u\\n\\n\\t\\tdef union(self, u, v): \\n\\t\\t\\tu_parent = self.find(u)\\n\\t\\t\\tv_parent = self.find(v)\\n\\t\\t\\tif u_parent == v_parent: \\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tif self.ranks[u_parent] > self.ranks[v_parent]:   \\n\\t\\t\\t\\tself.parents[v_parent] = u_parent\\n\\t\\t\\telif self.ranks[u_parent] < self.ranks[v_parent]: \\n\\t\\t\\t\\tself.parents[u_parent] = v_parent\\n\\t\\t\\telif self.ranks[u_parent] == self.ranks[v_parent]: \\n\\t\\t\\t\\tself.parents[v_parent] = u_parent\\n\\t\\t\\t\\tself.ranks[u_parent] += 1\\n\\t\\t\\treturn True    \\n\\n\\n\\tclass Solution(object):\\n\\t\\tdef largestComponentSize(self, nums):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type nums: List[int]\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tmax_num = max(nums)\\n\\t\\t\\tunion_find_set = UnionFindSet(max_num+1)\\n\\n\\t\\t\\tfor num in nums: \\n\\t\\t\\t\\tsqrt_num = int(num**(1/2.0))+1\\n\\t\\t\\t\\tfor i in range(2, sqrt_num): \\n\\t\\t\\t\\t\\tif num%i==0: \\n\\t\\t\\t\\t\\t\\tunion_find_set.union(num, i) \\n\\t\\t\\t\\t\\t\\tunion_find_set.union(num, num/i)\\n\\n\\t\\t\\tfrom collections import defaultdict\\n\\t\\t\\tres = defaultdict(int)            \\n\\t\\t\\tfor num in nums: \\n\\t\\t\\t\\tres[union_find_set.find(num)] += 1\\n\\t\\t\\t# print(res.values())    \\n\\t\\t\\treturn max(res.values())\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1593363,
                "title": "python-union-find-simple-solution",
                "content": "```\\nimport math\\n\\n\\nclass DisjointSet:\\n    def __init__(self, vertices):\\n        self.parent = {}\\n        self.rank = {}\\n        for vertex in range(len(vertices)):\\n            self.parent[vertex] = vertex\\n            self.rank[vertex] = 0\\n\\n    def find(self, u):\\n        if self.parent[u] != u:\\n            self.parent[u] = self.find(self.parent[u])\\n        return self.parent[u]\\n\\n    def union(self, u, v):\\n        x = self.find(u)\\n        y = self.find(v)\\n        if x != y:\\n            if self.rank[x] > self.rank[y]:\\n                self.parent[y] = x\\n            elif self.rank[y] > self.rank[x]:\\n                self.parent[x] = y\\n            else:\\n                self.parent[y] = x\\n                self.rank[x] += 1\\n        \\n        \\nclass Solution:\\n    def getPrimesFactors(self, num):\\n        for i in range(2, int(math.sqrt(num))+1):\\n            if num % i == 0:\\n                return self.getPrimesFactors(num//i) | {i}\\n        return {num}\\n\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        primeFactors = {}\\n        for index, num in enumerate(nums):\\n            for prime in self.getPrimesFactors(num):\\n                if prime in primeFactors:\\n                    primeFactors[prime].append(index)\\n                else:\\n                    primeFactors[prime] = [index]\\n\\n        djs = DisjointSet(nums)\\n        for indexes in primeFactors.values():\\n            for index in range(len(indexes) - 1):\\n                djs.union(indexes[index], indexes[index + 1])\\n\\n        longestConnectedComponentLength = 1\\n        components = {}\\n        for index in range(len(nums)):\\n            x = djs.find(index)\\n            if x in components:\\n                components[x] += 1\\n                longestConnectedComponentLength = max(longestConnectedComponentLength, components[x])\\n            else:\\n                components[x] = 1\\n\\n        return longestConnectedComponentLength\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nimport math\\n\\n\\nclass DisjointSet:\\n    def __init__(self, vertices):\\n        self.parent = {}\\n        self.rank = {}\\n        for vertex in range(len(vertices)):\\n            self.parent[vertex] = vertex\\n            self.rank[vertex] = 0\\n\\n    def find(self, u):\\n        if self.parent[u] != u:\\n            self.parent[u] = self.find(self.parent[u])\\n        return self.parent[u]\\n\\n    def union(self, u, v):\\n        x = self.find(u)\\n        y = self.find(v)\\n        if x != y:\\n            if self.rank[x] > self.rank[y]:\\n                self.parent[y] = x\\n            elif self.rank[y] > self.rank[x]:\\n                self.parent[x] = y\\n            else:\\n                self.parent[y] = x\\n                self.rank[x] += 1\\n        \\n        \\nclass Solution:\\n    def getPrimesFactors(self, num):\\n        for i in range(2, int(math.sqrt(num))+1):\\n            if num % i == 0:\\n                return self.getPrimesFactors(num//i) | {i}\\n        return {num}\\n\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        primeFactors = {}\\n        for index, num in enumerate(nums):\\n            for prime in self.getPrimesFactors(num):\\n                if prime in primeFactors:\\n                    primeFactors[prime].append(index)\\n                else:\\n                    primeFactors[prime] = [index]\\n\\n        djs = DisjointSet(nums)\\n        for indexes in primeFactors.values():\\n            for index in range(len(indexes) - 1):\\n                djs.union(indexes[index], indexes[index + 1])\\n\\n        longestConnectedComponentLength = 1\\n        components = {}\\n        for index in range(len(nums)):\\n            x = djs.find(index)\\n            if x in components:\\n                components[x] += 1\\n                longestConnectedComponentLength = max(longestConnectedComponentLength, components[x])\\n            else:\\n                components[x] = 1\\n\\n        return longestConnectedComponentLength\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593214,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    \\n    \\n    public int  find(int x,int ds[]){\\n        if(ds[x]==0)\\n            return x;\\n        return find(ds[x],ds);\\n    }\\n    \\n    \\n    \\n    public int largestComponentSize(int[] nums) {\\n        int max=Integer.MIN_VALUE;\\n        for(int i:nums)\\n            max=Math.max(max,i);\\n          int ds[]=new int[max+1];\\n          int size[]=new int[max+1];\\n        Arrays.fill(size,1);\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int curr=nums[i];\\n            for(int j=2;j<=Math.sqrt(curr);j++){\\n                if(curr%j==0){\\n                    int x=find(curr,ds);\\n                    int y=find(j,ds);\\n                    if(x!=y){\\n                        if(size[x]>size[y])\\n                        {\\n                            ds[y]=x;\\n                            size[x]+=size[y];\\n                        }\\n                        else{\\n                            ds[x]=y;\\n                            size[y]+=size[x];\\n                            x=y;\\n                        }\\n                        \\n                        \\n                        \\n                    }\\n                    y=find(curr/j,ds);\\n                    if(x!=y){\\n                        if(size[x]>size[y]){\\n                        ds[y]=x;\\n                        size[x]+=size[y];\\n                        }\\n                        else{\\n                            ds[x]=y;\\n                            size[y]+=size[x];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int count[]=new int[max+1];\\n        int res=1;\\n        for(int i=0;i<nums.length;i++){\\n           res=Math.max(++count[find(nums[i],ds)],res);\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    \\n    public int  find(int x,int ds[]){\\n        if(ds[x]==0)\\n            return x;\\n        return find(ds[x],ds);\\n    }\\n    \\n    \\n    \\n    public int largestComponentSize(int[] nums) {\\n        int max=Integer.MIN_VALUE;\\n        for(int i:nums)\\n            max=Math.max(max,i);\\n          int ds[]=new int[max+1];\\n          int size[]=new int[max+1];\\n        Arrays.fill(size,1);\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int curr=nums[i];\\n            for(int j=2;j<=Math.sqrt(curr);j++){\\n                if(curr%j==0){\\n                    int x=find(curr,ds);\\n                    int y=find(j,ds);\\n                    if(x!=y){\\n                        if(size[x]>size[y])\\n                        {\\n                            ds[y]=x;\\n                            size[x]+=size[y];\\n                        }\\n                        else{\\n                            ds[x]=y;\\n                            size[y]+=size[x];\\n                            x=y;\\n                        }\\n                        \\n                        \\n                        \\n                    }\\n                    y=find(curr/j,ds);\\n                    if(x!=y){\\n                        if(size[x]>size[y]){\\n                        ds[y]=x;\\n                        size[x]+=size[y];\\n                        }\\n                        else{\\n                            ds[x]=y;\\n                            size[y]+=size[x];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int count[]=new int[max+1];\\n        int res=1;\\n        for(int i=0;i<nums.length;i++){\\n           res=Math.max(++count[find(nums[i],ds)],res);\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593197,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(int x,vector<int>&p){\\n        if(p[x]==-1) return x;\\n        p[x]=find(p[x],p);\\n        return p[x];\\n    }\\n    void Union(int x,int y,vector<int>&p){\\n        x=find(x,p);\\n        y=find(y,p);\\n        if(x!=y) p[y]=x;\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n        vector<int>p(100001,-1);\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=2;j*j<=nums[i];j++){\\n                if(nums[i]%j==0) {\\n                    Union(nums[i],j,p);\\n                    Union(nums[i],nums[i]/j,p);\\n                }\\n            }\\n        }\\n        unordered_map<int,int> mp;\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int p1 = find(nums[i],p);\\n            count = max(count,1+mp[p1]);\\n            mp[p1]+=1;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int find(int x,vector<int>&p){\\n        if(p[x]==-1) return x;\\n        p[x]=find(p[x],p);\\n        return p[x];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1593177,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int find(int x,int []parent){\\n        if(parent[x] == -1)return x;\\n        parent[x] = find(parent[x],parent);\\n        return parent[x];\\n    }\\n    \\n    public void union(int x,int y,int[] parent){\\n        int xp = find(x,parent);\\n        int yp = find(y,parent);\\n        if(xp != yp){\\n            parent[yp] = xp;\\n        }\\n    }\\n    \\n    public int largestComponentSize(int[] nums) {\\n        int n = nums.length;\\n        int[] parent = new int[100001];\\n        Arrays.fill(parent,-1);\\n            \\n        for(int i = 0;i<n;i++){\\n            for(int k = 2;k<= Math.sqrt(nums[i]);k++){\\n                if(nums[i] % k == 0){\\n                    union(nums[i],k,parent);\\n                    union(nums[i],nums[i]/k,parent);\\n                }\\n            }\\n        }\\n        \\n        int count = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i= 0;i<n;i++){\\n            int p = find(nums[i],parent);\\n            count = Math.max(count,1 + map.getOrDefault(p,0));\\n            map.put(p,1+map.getOrDefault(p,0));\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int find(int x,int []parent){\\n        if(parent[x] == -1)return x;\\n        parent[x] = find(parent[x],parent);\\n        return parent[x];\\n    }\\n    \\n    public void union(int x,int y,int[] parent){\\n        int xp = find(x,parent);\\n        int yp = find(y,parent);\\n        if(xp != yp){\\n            parent[yp] = xp;\\n        }\\n    }\\n    \\n    public int largestComponentSize(int[] nums) {\\n        int n = nums.length;\\n        int[] parent = new int[100001];\\n        Arrays.fill(parent,-1);\\n            \\n        for(int i = 0;i<n;i++){\\n            for(int k = 2;k<= Math.sqrt(nums[i]);k++){\\n                if(nums[i] % k == 0){\\n                    union(nums[i],k,parent);\\n                    union(nums[i],nums[i]/k,parent);\\n                }\\n            }\\n        }\\n        \\n        int count = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i= 0;i<n;i++){\\n            int p = find(nums[i],parent);\\n            count = Math.max(count,1 + map.getOrDefault(p,0));\\n            map.put(p,1+map.getOrDefault(p,0));\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593029,
                "title": "largest-component-size-by-common-factor-c-using-sieve-and-union",
                "content": "```\\nclass Solution {\\npublic:\\n\\t/*function to get root or parent*/\\n    int getRoot(vector<int>& root, int x)\\n    {\\n        if(x == root[x])\\n            return x;\\n        else\\n            return root[x] = getRoot(root, root[x]); \\n    }\\n\\t/*get all prime factors of x in a vector*/\\n     vector<int> getPrimes(int x, vector<int>& s) {\\n        vector<int> primes;\\n        while (x > 1) {\\n            int p = s[x];\\n            if(p == 0)\\n                p = x;\\n            primes.push_back(p);\\n\\t\\t\\t// Edit: uncomment next 2 lines and comment last x/=p to remove duplicate same primes, taken from other solution.\\n\\t\\t\\t// while(x % p == 0)\\n            //    x /= p;\\n            x /= p;\\n        }\\n        return primes;\\n    }\\n\\t/*union a and b by making roots same*/\\n    void unions(int a, int b, vector<int>& root)\\n    {\\n        int aR = getRoot(root, a);\\n        int bR = getRoot(root, b);\\n        if(aR > bR)  // if a is greater, make root of b as a\\n            root[bR] = root[aR];\\n        else\\n            root[aR] = root[bR];\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n        int n=nums.size();\\n        int i,j,M=0;\\n\\t\\tint ans=1; //minimum answer can be 1.\\n        for(i=0;i<n;i++)\\n        {\\n            M = max(M,nums[i]); // get the maximum number.\\n        }\\n        vector<int>sieve(M+1); // used for sieve of eratosthenes\\n        vector<int>count(M+1);  // count_i stores the count of all numbers having root = i\\n        vector<int>root(M+1);  // stores the root\\n        for(i=0;i<=M;i++)\\n        {\\n            root[i] = i; // make each number its on root\\n        }\\n        for(i=2;i*i<=M;i++)\\n        {\\n            if(sieve[i]) // prime number will have 0 value\\n                continue;\\n            for(j=i*i;j<=M;j+=i)\\n            {\\n                sieve[j] = i; // the smallest prime value will be stored here\\n            }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(nums[i]==1) //ignore 1\\n                continue;\\n            vector<int>v = getPrimes(nums[i], sieve); //get the prime factors\\n            for(j=0; j<v.size()-1; j++)\\n            {\\n                unions(v[j], v[j+1], root); // union them i.e make their root same.\\n            }\\n            unions(v[j], nums[i], root); // union the number with one of their factors\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            int r = getRoot(root, nums[i]); // find the root i.e. the bucket in which this number will fall\\n            count[r]++; //increase the count of that bucket\\n            ans = max(ans, count[r]); // check max\\n        }\\n        return ans; // return the ans\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t/*function to get root or parent*/\\n    int getRoot(vector<int>& root, int x)\\n    {\\n        if(x == root[x])\\n            return x;\\n        else\\n            return root[x] = getRoot(root, root[x]); \\n    }\\n\\t/*get all prime factors of x in a vector*/\\n     vector<int> getPrimes(int x, vector<int>& s) {\\n        vector<int> primes;\\n        while (x > 1) {\\n            int p = s[x];\\n            if(p == 0)\\n                p = x;\\n            primes.push_back(p);\\n\\t\\t\\t// Edit: uncomment next 2 lines and comment last x/=p to remove duplicate same primes, taken from other solution.\\n\\t\\t\\t// while(x % p == 0)\\n            //    x /= p;\\n            x /= p;\\n        }\\n        return primes;\\n    }\\n\\t/*union a and b by making roots same*/\\n    void unions(int a, int b, vector<int>& root)\\n    {\\n        int aR = getRoot(root, a);\\n        int bR = getRoot(root, b);\\n        if(aR > bR)  // if a is greater, make root of b as a\\n            root[bR] = root[aR];\\n        else\\n            root[aR] = root[bR];\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n        int n=nums.size();\\n        int i,j,M=0;\\n\\t\\tint ans=1; //minimum answer can be 1.\\n        for(i=0;i<n;i++)\\n        {\\n            M = max(M,nums[i]); // get the maximum number.\\n        }\\n        vector<int>sieve(M+1); // used for sieve of eratosthenes\\n        vector<int>count(M+1);  // count_i stores the count of all numbers having root = i\\n        vector<int>root(M+1);  // stores the root\\n        for(i=0;i<=M;i++)\\n        {\\n            root[i] = i; // make each number its on root\\n        }\\n        for(i=2;i*i<=M;i++)\\n        {\\n            if(sieve[i]) // prime number will have 0 value\\n                continue;\\n            for(j=i*i;j<=M;j+=i)\\n            {\\n                sieve[j] = i; // the smallest prime value will be stored here\\n            }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(nums[i]==1) //ignore 1\\n                continue;\\n            vector<int>v = getPrimes(nums[i], sieve); //get the prime factors\\n            for(j=0; j<v.size()-1; j++)\\n            {\\n                unions(v[j], v[j+1], root); // union them i.e make their root same.\\n            }\\n            unions(v[j], nums[i], root); // union the number with one of their factors\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            int r = getRoot(root, nums[i]); // find the root i.e. the bucket in which this number will fall\\n            count[r]++; //increase the count of that bucket\\n            ans = max(ans, count[r]); // check max\\n        }\\n        return ans; // return the ans\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592831,
                "title": "golang-union-find-standard-template",
                "content": "typical union find template can be used, we use a factor map to keep track of the most recent group belonging to that factor, it does not have to be most updated since we always union using the parent of the group regardless. here I say \"most updated\" meaning that group does not necessarily have to be the parent group, it could be a child belonging to another parent group.\\n\\nto consider 2 indices eligible to be union, means that the value at their index must share a common factor.\\nexample, consider array: [2,3,4,5] and index 0 and 2.\\nindex 0: value -> 2\\nindex 2: value -> 4\\nthis is considered a good pair to union because they share a common factor of 2.\\n\\nIf you like to visualise things as a graph, then a common factor of 2 is like an edge connecting 2 vertex/nodes representing index 0 and index 2 for the above case.\\n\\n\\n```\\nfunc largestComponentSize(nums []int) int {\\n    factorMap := make(map[int]int) // factor -> number (note: store first one is good enough, we map it back to the parent group in the uf always)\\n    \\n    uf := NewUnionFind(len(nums))\\n    for i, num := range nums {\\n        for _, factor := range genFactor(num) {\\n            if otherIdx, exist := factorMap[factor]; exist {\\n                uf.union(i, otherIdx)\\n            }\\n            factorMap[factor] = i\\n        }\\n    }\\n    \\n    return uf.findLargestComponentSize()\\n}\\n\\n// generates all factors of num, not inclusive of 1\\nfunc genFactor(num int) []int {\\n    res := make([]int, 0)\\n    for i := 2; i<=int(math.Sqrt(float64(num))); i++ {\\n        if num % i == 0 {\\n            res = append(res, i)\\n            if i != num/i {\\n                res = append(res, num/i)\\n            }\\n        }\\n    }\\n    res = append(res, num)  // put in num itself, we do not consider 1 in the loop\\n    \\n    return res\\n}\\n\\n// mapping groups by index\\ntype UnionFind struct {\\n    parents []int\\n    size []int\\n}\\n\\nfunc NewUnionFind(n int) *UnionFind {\\n    parents := make([]int, n)\\n    size := make([]int, n)\\n    for i := range parents {\\n        parents[i] = i\\n        size[i] = 1\\n    }\\n    \\n    return &UnionFind{parents: parents, size: size}\\n}\\n\\nfunc (u *UnionFind) find(x int) int {\\n    if u.parents[x] == x {\\n        return x\\n    }\\n    root := u.find(u.parents[x])\\n    u.parents[x] = root\\n    \\n    return root\\n}\\n\\nfunc (u *UnionFind) union(x, y int) {\\n    rootX := u.find(x)\\n    rootY := u.find(y)\\n    if rootX != rootY {\\n        u.parents[rootY] = rootX\\n        u.size[rootX] += u.size[rootY]\\n    }\\n}\\n\\nfunc (u *UnionFind) findLargestComponentSize() int {\\n    res := 0\\n    for _, s := range u.size {\\n        if s > res {\\n            res = s\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc largestComponentSize(nums []int) int {\\n    factorMap := make(map[int]int) // factor -> number (note: store first one is good enough, we map it back to the parent group in the uf always)\\n    \\n    uf := NewUnionFind(len(nums))\\n    for i, num := range nums {\\n        for _, factor := range genFactor(num) {\\n            if otherIdx, exist := factorMap[factor]; exist {\\n                uf.union(i, otherIdx)\\n            }\\n            factorMap[factor] = i\\n        }\\n    }\\n    \\n    return uf.findLargestComponentSize()\\n}\\n\\n// generates all factors of num, not inclusive of 1\\nfunc genFactor(num int) []int {\\n    res := make([]int, 0)\\n    for i := 2; i<=int(math.Sqrt(float64(num))); i++ {\\n        if num % i == 0 {\\n            res = append(res, i)\\n            if i != num/i {\\n                res = append(res, num/i)\\n            }\\n        }\\n    }\\n    res = append(res, num)  // put in num itself, we do not consider 1 in the loop\\n    \\n    return res\\n}\\n\\n// mapping groups by index\\ntype UnionFind struct {\\n    parents []int\\n    size []int\\n}\\n\\nfunc NewUnionFind(n int) *UnionFind {\\n    parents := make([]int, n)\\n    size := make([]int, n)\\n    for i := range parents {\\n        parents[i] = i\\n        size[i] = 1\\n    }\\n    \\n    return &UnionFind{parents: parents, size: size}\\n}\\n\\nfunc (u *UnionFind) find(x int) int {\\n    if u.parents[x] == x {\\n        return x\\n    }\\n    root := u.find(u.parents[x])\\n    u.parents[x] = root\\n    \\n    return root\\n}\\n\\nfunc (u *UnionFind) union(x, y int) {\\n    rootX := u.find(x)\\n    rootY := u.find(y)\\n    if rootX != rootY {\\n        u.parents[rootY] = rootX\\n        u.size[rootX] += u.size[rootY]\\n    }\\n}\\n\\nfunc (u *UnionFind) findLargestComponentSize() int {\\n    res := 0\\n    for _, s := range u.size {\\n        if s > res {\\n            res = s\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592790,
                "title": "js-union-find-in-33-lines-beats-100-space-time",
                "content": "This executes in 444 ms, with no prime-factor optimizations:\\n\\n```js\\nvar largestComponentSize = function(nums) {\\n  const rootByFactor = new Map();\\n  const parents = new Array(nums.length);\\n  \\n  function addFactor(i, factor) {\\n    if (rootByFactor.has(factor)) {\\n      let r = rootByFactor.get(factor);\\n      while (parents[i] != i) i = parents[i];\\n      while (parents[r] != r) r = parents[r];\\n      parents[i] = r;\\n    }\\n    rootByFactor.set(factor, parents[i]);\\n  }\\n  \\n  for (const [i, num] of nums.entries()) {\\n    parents[i] = i;\\n    addFactor(i, num);\\n    for (let factor = 2; factor * factor <= num; ++factor) {\\n      if (num % factor == 0) {\\n        addFactor(i, factor);\\n        addFactor(i, num / factor);\\n      }\\n    }\\n  }\\n  \\n  let largest = 0;\\n  const sums = new Array(nums.length).fill(0);\\n  for (let r of parents) {\\n    while (parents[r] != r) r = parents[r];\\n    largest = Math.max(largest, ++sums[r]);\\n  }\\n  return largest;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```js\\nvar largestComponentSize = function(nums) {\\n  const rootByFactor = new Map();\\n  const parents = new Array(nums.length);\\n  \\n  function addFactor(i, factor) {\\n    if (rootByFactor.has(factor)) {\\n      let r = rootByFactor.get(factor);\\n      while (parents[i] != i) i = parents[i];\\n      while (parents[r] != r) r = parents[r];\\n      parents[i] = r;\\n    }\\n    rootByFactor.set(factor, parents[i]);\\n  }\\n  \\n  for (const [i, num] of nums.entries()) {\\n    parents[i] = i;\\n    addFactor(i, num);\\n    for (let factor = 2; factor * factor <= num; ++factor) {\\n      if (num % factor == 0) {\\n        addFactor(i, factor);\\n        addFactor(i, num / factor);\\n      }\\n    }\\n  }\\n  \\n  let largest = 0;\\n  const sums = new Array(nums.length).fill(0);\\n  for (let r of parents) {\\n    while (parents[r] != r) r = parents[r];\\n    largest = Math.max(largest, ++sums[r]);\\n  }\\n  return largest;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592460,
                "title": "approach-using-union-find",
                "content": "```\\npublic class Solution {\\n    public int LargestComponentSize(int[] nums) {\\n        var set = new UnionFindSet(nums.Max() + 1);\\n        \\n        // Calculate primes set for all elements\\n        foreach (var num in nums) {\\n            for (var k = 2; k * k <= num; ++k) {\\n                if (num % k == 0) {\\n                    set.Union(num, k);\\n                    set.Union(num, num / k);\\n                }\\n            }\\n        }\\n        \\n        // Count the apperance of parents, return the maxium one.\\n        // All connected nodes will point to same parent\\n        var map = new Dictionary<int, int>();\\n        var result = 1;\\n        foreach (var num in nums) {\\n            var count = set.Find(num);\\n            map[count] = (map.ContainsKey(count) ? map[count] : 0) + 1;\\n            result = Math.Max(result, map[count]);\\n        }        \\n        return result;\\n    }\\n    \\n    public class UnionFindSet {\\n        private int[] parent;\\n        \\n        public UnionFindSet(int size) {\\n            parent = new int[size];\\n            for (int i = 0; i < parent.Length; ++i) {\\n                parent[i] = i;\\n            }\\n        }\\n        public void Union(int x, int y) {\\n            parent[Find(x)] = parent[Find(y)];\\n        }\\n        public int Find(int x) {\\n            if (parent[x] != x) {\\n                parent[x] = Find(parent[x]);\\n            }\\n            return parent[x];\\n        }        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\npublic class Solution {\\n    public int LargestComponentSize(int[] nums) {\\n        var set = new UnionFindSet(nums.Max() + 1);\\n        \\n        // Calculate primes set for all elements\\n        foreach (var num in nums) {\\n            for (var k = 2; k * k <= num; ++k) {\\n                if (num % k == 0) {\\n                    set.Union(num, k);\\n                    set.Union(num, num / k);\\n                }\\n            }\\n        }\\n        \\n        // Count the apperance of parents, return the maxium one.\\n        // All connected nodes will point to same parent\\n        var map = new Dictionary<int, int>();\\n        var result = 1;\\n        foreach (var num in nums) {\\n            var count = set.Find(num);\\n            map[count] = (map.ContainsKey(count) ? map[count] : 0) + 1;\\n            result = Math.Max(result, map[count]);\\n        }        \\n        return result;\\n    }\\n    \\n    public class UnionFindSet {\\n        private int[] parent;\\n        \\n        public UnionFindSet(int size) {\\n            parent = new int[size];\\n            for (int i = 0; i < parent.Length; ++i) {\\n                parent[i] = i;\\n            }\\n        }\\n        public void Union(int x, int y) {\\n            parent[Find(x)] = parent[Find(y)];\\n        }\\n        public int Find(int x) {\\n            if (parent[x] != x) {\\n                parent[x] = Find(parent[x]);\\n            }\\n            return parent[x];\\n        }        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592428,
                "title": "rust-unionfind-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\nstruct UnionFind {\\n    parent: Vec<usize>,\\n}\\n\\nimpl UnionFind {\\n    fn new(n: usize) -> Self {\\n        Self {\\n            parent: (0..n).collect(),\\n        }\\n    }\\n    fn union(&mut self, x: usize, y: usize) {\\n        let x = self.find(x);\\n        let y = self.find(y);\\n        self.parent[y] = x\\n    }\\n    fn find(&mut self, x: usize) -> usize {\\n        if x != self.parent[x] {\\n            self.parent[x] = self.find(self.parent[x]);\\n        }\\n        self.parent[x]\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn largest_component_size(nums: Vec<i32>) -> i32 {\\n        let mut sieve = (0..100_001).collect::<Vec<_>>();\\n        for i in (2..).take_while(|&i| i * i < 100_001) {\\n            if sieve[i] == i as i32 {\\n                for j in (i..100_001).step_by(i) {\\n                    sieve[j] = sieve[j].min(i as i32);\\n                }\\n            }\\n        }\\n        let mut hm = HashMap::new();\\n        for (i, &num) in nums.iter().enumerate() {\\n            let mut n = num;\\n            while n > 1 {\\n                let p = sieve[n as usize];\\n                hm.entry(p).or_insert_with(Vec::new).push(i);\\n                n /= p as i32;\\n            }\\n        }\\n        let mut uf = UnionFind::new(nums.len());\\n        for v in hm.values_mut() {\\n            v.dedup();\\n            v.windows(2).for_each(|w| uf.union(w[0], w[1]));\\n        }\\n        let mut counts = vec![0; nums.len()];\\n        for i in 0..nums.len() {\\n            counts[uf.find(i)] += 1;\\n        }\\n        *counts.iter().max().unwrap() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Union Find"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nstruct UnionFind {\\n    parent: Vec<usize>,\\n}\\n\\nimpl UnionFind {\\n    fn new(n: usize) -> Self {\\n        Self {\\n            parent: (0..n).collect(),\\n        }\\n    }\\n    fn union(&mut self, x: usize, y: usize) {\\n        let x = self.find(x);\\n        let y = self.find(y);\\n        self.parent[y] = x\\n    }\\n    fn find(&mut self, x: usize) -> usize {\\n        if x != self.parent[x] {\\n            self.parent[x] = self.find(self.parent[x]);\\n        }\\n        self.parent[x]\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn largest_component_size(nums: Vec<i32>) -> i32 {\\n        let mut sieve = (0..100_001).collect::<Vec<_>>();\\n        for i in (2..).take_while(|&i| i * i < 100_001) {\\n            if sieve[i] == i as i32 {\\n                for j in (i..100_001).step_by(i) {\\n                    sieve[j] = sieve[j].min(i as i32);\\n                }\\n            }\\n        }\\n        let mut hm = HashMap::new();\\n        for (i, &num) in nums.iter().enumerate() {\\n            let mut n = num;\\n            while n > 1 {\\n                let p = sieve[n as usize];\\n                hm.entry(p).or_insert_with(Vec::new).push(i);\\n                n /= p as i32;\\n            }\\n        }\\n        let mut uf = UnionFind::new(nums.len());\\n        for v in hm.values_mut() {\\n            v.dedup();\\n            v.windows(2).for_each(|w| uf.union(w[0], w[1]));\\n        }\\n        let mut counts = vec![0; nums.len()];\\n        for i in 0..nums.len() {\\n            counts[uf.find(i)] += 1;\\n        }\\n        *counts.iter().max().unwrap() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592244,
                "title": "my-c-solution",
                "content": "```\\nint parent[100001];\\n\\nint find(int x)\\n{\\n    if(parent[x] == -1)\\n        return x;\\n    else \\n        return parent[x] = find(parent[x]);\\n}\\nbool uni(int a, int b)\\n{\\n    int x = find(a);\\n    int y = find(b);\\n    if(x != y)\\n        parent[y] = x;\\n    else \\n        return false;\\n    return true;\\n}\\n\\nint largestComponentSize(int* nums, int numsSize){\\n    int temp[100001] = {0};\\n    int ret = 0;\\n    for(int i = 0; i < 100001; i++)\\n        parent[i] = -1;\\n    for(int i = 0; i < numsSize; i++)\\n        for(int j = 2; j*j <= nums[i]; j++)\\n            if(nums[i] % j == 0)\\n            {\\n                uni(j, nums[i]);\\n                uni(nums[i], nums[i]/j);\\n            }\\n    for(int i = 0; i < numsSize; i++)\\n        ret = ret > ++temp[find(nums[i])] ? ret : temp[find(nums[i])];\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nint parent[100001];\\n\\nint find(int x)\\n{\\n    if(parent[x] == -1)\\n        return x;\\n    else \\n        return parent[x] = find(parent[x]);\\n}\\nbool uni(int a, int b)\\n{\\n    int x = find(a);\\n    int y = find(b);\\n    if(x != y)\\n        parent[y] = x;\\n    else \\n        return false;\\n    return true;\\n}\\n\\nint largestComponentSize(int* nums, int numsSize){\\n    int temp[100001] = {0};\\n    int ret = 0;\\n    for(int i = 0; i < 100001; i++)\\n        parent[i] = -1;\\n    for(int i = 0; i < numsSize; i++)\\n        for(int j = 2; j*j <= nums[i]; j++)\\n            if(nums[i] % j == 0)\\n            {\\n                uni(j, nums[i]);\\n                uni(nums[i], nums[i]/j);\\n            }\\n    for(int i = 0; i < numsSize; i++)\\n        ret = ret > ++temp[find(nums[i])] ? ret : temp[find(nums[i])];\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592177,
                "title": "rust-solution",
                "content": "```\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn largest_component_size(nums: Vec<i32>) -> i32 {\\n        let mut par: Vec<i32> = vec![0; 100001];\\n        let mut rank: Vec<i32> = vec![0; 100001];\\n        let mut ans: i32 = 1;\\n        \\n        for i in 1..=100000{\\n            par[i] = i as i32;\\n        }\\n        \\n        for i in 0..nums.len() {\\n            rank[nums[i] as usize] = 1;\\n        }\\n        \\n        for i in 0..nums.len() {\\n            let mut j: usize = 2;\\n            while j*j <= nums[i] as usize  {\\n                if(nums[i] as usize % j == 0)\\n                {\\n                    Solution::union(j, nums[i] as usize, &mut par, &mut rank, &mut ans);\\n                    Solution::union(j, (nums[i] as usize/j), &mut par, &mut rank, &mut ans);\\n                }\\n                j+=1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    fn find(x: usize, par: &mut Vec<i32>) -> usize {\\n        return if par[x] == x as i32 {x} else {par[x] = Solution::find(par[x] as usize, par) as i32; return par[x] as usize};\\n    }\\n    \\n    fn union(a: usize, b: usize, par: &mut Vec<i32>, rank: &mut Vec<i32>, ans: &mut i32) {\\n        \\n        let a = Solution::find(a, par); \\n        let b = Solution::find(b, par);\\n        \\n        if(a==b) {return;}\\n        \\n        if(rank[a]>=rank[b]){\\n            par[b]=a as i32; rank[a] += rank[b];\\n        }\\n        \\n        else {\\n            rank[b] += rank[a]; par[a]=b as i32;\\n        }\\n        *ans = max(*ans, max(rank[a],rank[b]));\\n    }\\n}",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn largest_component_size(nums: Vec<i32>) -> i32 {\\n        let mut par: Vec<i32> = vec![0; 100001];\\n        let mut rank: Vec<i32> = vec![0; 100001];\\n        let mut ans: i32 = 1;\\n        \\n        for i in 1..=100000{\\n            par[i] = i as i32;\\n        }\\n        \\n        for i in 0..nums.len() {\\n            rank[nums[i] as usize] = 1;\\n        }\\n        \\n        for i in 0..nums.len() {\\n            let mut j: usize = 2;\\n            while j*j <= nums[i] as usize  {\\n                if(nums[i] as usize % j == 0)\\n                {\\n                    Solution::union(j, nums[i] as usize, &mut par, &mut rank, &mut ans);\\n                    Solution::union(j, (nums[i] as usize/j), &mut par, &mut rank, &mut ans);\\n                }\\n                j+=1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    fn find(x: usize, par: &mut Vec<i32>) -> usize {\\n        return if par[x] == x as i32 {x} else {par[x] = Solution::find(par[x] as usize, par) as i32; return par[x] as usize};\\n    }\\n    \\n    fn union(a: usize, b: usize, par: &mut Vec<i32>, rank: &mut Vec<i32>, ans: &mut i32) {\\n        \\n        let a = Solution::find(a, par); \\n        let b = Solution::find(b, par);\\n        \\n        if(a==b) {return;}\\n        \\n        if(rank[a]>=rank[b]){\\n            par[b]=a as i32; rank[a] += rank[b];\\n        }\\n        \\n        else {\\n            rank[b] += rank[a]; par[a]=b as i32;\\n        }\\n        *ans = max(*ans, max(rank[a],rank[b]));\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1533268,
                "title": "java-find-and-union-graph-question",
                "content": "```\\nclass Solution {\\n    int find(int x, int[] parent){\\n            if(parent[x] == -1) return x;\\n        \\n        parent[x] = find(parent[x], parent);\\n        return parent[x];\\n        }\\n    \\n    void union(int x, int y, int[] parent){\\n        int xp = find(x,parent);\\n        int yp = find(y,parent);\\n        if(xp!= yp) parent[yp] = xp;\\n    }\\n    public int largestComponentSize(int[] A) {\\n        int n = A.length;\\n        int[] parent = new int[100001];\\n        for(int i=0;i<100001;i++) parent[i] = -1;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int k=2;k<=Math.sqrt(A[i]);k++){\\n                if(A[i]%k == 0){\\n                    union(A[i],k,parent);\\n                    union(A[i],A[i]/k,parent);\\n                }\\n            }\\n        }\\n        int count=0;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            int p = find(A[i],parent);\\n            count = Math.max(count, 1+hm.getOrDefault(p,0));\\n            hm.put(p,1+hm.getOrDefault(p,0));\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int find(int x, int[] parent){\\n            if(parent[x] == -1) return x;\\n        \\n        parent[x] = find(parent[x], parent);\\n        return parent[x];\\n        }\\n    \\n    void union(int x, int y, int[] parent){\\n        int xp = find(x,parent);\\n        int yp = find(y,parent);\\n        if(xp!= yp) parent[yp] = xp;\\n    }\\n    public int largestComponentSize(int[] A) {\\n        int n = A.length;\\n        int[] parent = new int[100001];\\n        for(int i=0;i<100001;i++) parent[i] = -1;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int k=2;k<=Math.sqrt(A[i]);k++){\\n                if(A[i]%k == 0){\\n                    union(A[i],k,parent);\\n                    union(A[i],A[i]/k,parent);\\n                }\\n            }\\n        }\\n        int count=0;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            int p = find(A[i],parent);\\n            count = Math.max(count, 1+hm.getOrDefault(p,0));\\n            hm.put(p,1+hm.getOrDefault(p,0));\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1459058,
                "title": "c-optimized-union-find-linq",
                "content": "```\\npublic class Solution {\\n    public class UnionFind {\\n        private int[] root;\\n        private int[] rank;\\n\\n        // O(n)\\n        public UnionFind(int vertices){\\n            root = new int[vertices];\\n            rank = new int[vertices];\\n            for(int i = 0; i < vertices; i++){\\n                root[i] = i;\\n                rank[i] = 1;\\n            }\\n        }\\n\\n        // O(1), average\\n        public int Find(int x){\\n            if(x == root[x]){\\n                return x;\\n            }\\n            return root[x] = Find(root[x]);\\n        }\\n\\n        // O(1), average\\n        public void Union(int x, int y){\\n            int xRoot = Find(x);\\n            int yRoot = Find(y);\\n            if(xRoot != yRoot){\\n                if(rank[xRoot] > rank[yRoot]){\\n                    root[yRoot] = xRoot;\\n                } else if(rank[xRoot] < rank[yRoot]){\\n                    root[xRoot] = yRoot;\\n                } else {\\n                    root[yRoot] = xRoot;\\n                    rank[xRoot]++;\\n                }\\n            }\\n        }\\n    }\\n\\n    public int LargestComponentSize(int[] nums) {\\n        int maxValue = nums.Aggregate((x, y) => x > y ? x : y); // Uses LINQ\\'s reduce method to find largest value\\n        UnionFind ds = new UnionFind(maxValue + 1); // +1 to hold just enough items, without +1 out of bounds\\n\\n        foreach(int num in nums){\\n            for(int factor = 2; factor < (int)(Math.Sqrt(num)) + 1; ++factor){\\n                if(num % factor == 0){\\n                    ds.Union(num, factor);\\n                    ds.Union(num, num / factor);\\n                }\\n            }\\n        }\\n\\n        int maxGroupSize = 0;\\n        Dictionary<int, int> groupCount = new Dictionary<int, int>();\\n        foreach(int num in nums){\\n            int groupID = ds.Find(num);\\n            if(!groupCount.ContainsKey(groupID)){\\n                groupCount.Add(groupID, 0);\\n            }\\n            groupCount[groupID]++;\\n            maxGroupSize = Math.Max(maxGroupSize, groupCount[groupID]);\\n        }\\n\\n        return maxGroupSize;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\npublic class Solution {\\n    public class UnionFind {\\n        private int[] root;\\n        private int[] rank;\\n\\n        // O(n)\\n        public UnionFind(int vertices){\\n            root = new int[vertices];\\n            rank = new int[vertices];\\n            for(int i = 0; i < vertices; i++){\\n                root[i] = i;\\n                rank[i] = 1;\\n            }\\n        }\\n\\n        // O(1), average\\n        public int Find(int x){\\n            if(x == root[x]){\\n                return x;\\n            }\\n            return root[x] = Find(root[x]);\\n        }\\n\\n        // O(1), average\\n        public void Union(int x, int y){\\n            int xRoot = Find(x);\\n            int yRoot = Find(y);\\n            if(xRoot != yRoot){\\n                if(rank[xRoot] > rank[yRoot]){\\n                    root[yRoot] = xRoot;\\n                } else if(rank[xRoot] < rank[yRoot]){\\n                    root[xRoot] = yRoot;\\n                } else {\\n                    root[yRoot] = xRoot;\\n                    rank[xRoot]++;\\n                }\\n            }\\n        }\\n    }\\n\\n    public int LargestComponentSize(int[] nums) {\\n        int maxValue = nums.Aggregate((x, y) => x > y ? x : y); // Uses LINQ\\'s reduce method to find largest value\\n        UnionFind ds = new UnionFind(maxValue + 1); // +1 to hold just enough items, without +1 out of bounds\\n\\n        foreach(int num in nums){\\n            for(int factor = 2; factor < (int)(Math.Sqrt(num)) + 1; ++factor){\\n                if(num % factor == 0){\\n                    ds.Union(num, factor);\\n                    ds.Union(num, num / factor);\\n                }\\n            }\\n        }\\n\\n        int maxGroupSize = 0;\\n        Dictionary<int, int> groupCount = new Dictionary<int, int>();\\n        foreach(int num in nums){\\n            int groupID = ds.Find(num);\\n            if(!groupCount.ContainsKey(groupID)){\\n                groupCount.Add(groupID, 0);\\n            }\\n            groupCount[groupID]++;\\n            maxGroupSize = Math.Max(maxGroupSize, groupCount[groupID]);\\n        }\\n\\n        return maxGroupSize;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445730,
                "title": "python-union-find-sieve-of-eratosthenes",
                "content": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parents = [i for i in range(n+1)]\\n        self.ranks = [0] * (n+1)\\n    \\n    def find(self, x):\\n        if x != self.parents[x]:\\n            self.parents[x] = self.find(self.parents[x])\\n        return self.parents[x]\\n    \\n    def union(self, x, y):\\n        root_x, root_y = self.find(x), self.find(y)\\n        if self.ranks[root_x] < self.ranks[root_y]:\\n            self.parents[root_x] = root_y\\n        elif self.ranks[root_x] > self.ranks[root_y]:\\n            self.parents[root_y] = root_x\\n        else:\\n            self.parents[root_x] = root_y\\n            self.ranks[root_y] += 1\\n        \\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        nums_set = set(nums)\\n        max_num = max(nums)\\n        uf = UnionFind(max_num)\\n        is_prime = [True for _ in range(max_num+1)]\\n        for num in range(2, max_num+1):\\n            if is_prime[num]:\\n                for composite in range(num, max_num+1, num):\\n                    if composite != num:\\n                        is_prime[composite] = False\\n                    if composite in nums_set:\\n                        uf.union(num, composite)\\n        \\n        cluster_to_cnt = defaultdict(int)\\n        for num in nums:\\n            cluster_to_cnt[uf.find(num)] += 1\\n        return max([cnt for _, cnt in cluster_to_cnt.items()])\\n```",
                "solutionTags": [],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parents = [i for i in range(n+1)]\\n        self.ranks = [0] * (n+1)\\n    \\n    def find(self, x):\\n        if x != self.parents[x]:\\n            self.parents[x] = self.find(self.parents[x])\\n        return self.parents[x]\\n    \\n    def union(self, x, y):\\n        root_x, root_y = self.find(x), self.find(y)\\n        if self.ranks[root_x] < self.ranks[root_y]:\\n            self.parents[root_x] = root_y\\n        elif self.ranks[root_x] > self.ranks[root_y]:\\n            self.parents[root_y] = root_x\\n        else:\\n            self.parents[root_x] = root_y\\n            self.ranks[root_y] += 1\\n        \\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        nums_set = set(nums)\\n        max_num = max(nums)\\n        uf = UnionFind(max_num)\\n        is_prime = [True for _ in range(max_num+1)]\\n        for num in range(2, max_num+1):\\n            if is_prime[num]:\\n                for composite in range(num, max_num+1, num):\\n                    if composite != num:\\n                        is_prime[composite] = False\\n                    if composite in nums_set:\\n                        uf.union(num, composite)\\n        \\n        cluster_to_cnt = defaultdict(int)\\n        for num in nums:\\n            cluster_to_cnt[uf.find(num)] += 1\\n        return max([cnt for _, cnt in cluster_to_cnt.items()])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439740,
                "title": "python-soluton-sieve-of-eratosthenes-and-union-find",
                "content": "We use Sieve of Eratosthenes to find all element with common prime factor, the connet them with Union set.\\n```\\nclass Uni:\\n\\n    def __init__(self, arr):\\n        self.arr = {i:i for i in arr}\\n        self.sz = {i:1 for i in arr}\\n    \\n    def find(self, x):\\n        if x != self.arr[x]: self.arr[x] = self.find(self.arr[x])\\n        return self.arr[x]\\n    \\n    def same(self, x, y):\\n        return self.find(x) == self.find(y)\\n    \\n    def merge(self, x, y):\\n        x, y = self.find(x), self.find(y)\\n        if x == y: return\\n        if x > y: x, y = y, x\\n        self.sz[x] += self.sz[y]\\n        self.arr[y] = self.arr[x]\\n\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        uni = Uni(nums)\\n        bound = max(nums) + 1\\n        isprime = [True] * bound\\n        nums = set(nums)\\n        for i in range(2, bound):\\n            if not isprime[i]: continue\\n            last = None\\n            for j in range(i, bound, i):\\n                isprime[j] = False\\n                if j in nums:\\n                    if last is None: last = j\\n                    else: uni.merge(last, j)\\n        return max(uni.sz.values())",
                "solutionTags": [],
                "code": "We use Sieve of Eratosthenes to find all element with common prime factor, the connet them with Union set.\\n```\\nclass Uni:\\n\\n    def __init__(self, arr):\\n        self.arr = {i:i for i in arr}\\n        self.sz = {i:1 for i in arr}\\n    \\n    def find(self, x):\\n        if x != self.arr[x]: self.arr[x] = self.find(self.arr[x])\\n        return self.arr[x]\\n    \\n    def same(self, x, y):\\n        return self.find(x) == self.find(y)\\n    \\n    def merge(self, x, y):\\n        x, y = self.find(x), self.find(y)\\n        if x == y: return\\n        if x > y: x, y = y, x\\n        self.sz[x] += self.sz[y]\\n        self.arr[y] = self.arr[x]\\n\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        uni = Uni(nums)\\n        bound = max(nums) + 1\\n        isprime = [True] * bound\\n        nums = set(nums)\\n        for i in range(2, bound):\\n            if not isprime[i]: continue\\n            last = None\\n            for j in range(i, bound, i):\\n                isprime[j] = False\\n                if j in nums:\\n                    if last is None: last = j\\n                    else: uni.merge(last, j)\\n        return max(uni.sz.values())",
                "codeTag": "Java"
            },
            {
                "id": 1329265,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int par[100001],rank_[100001],ans;\\n    int find(int x)\\n    {\\n        return (par[x]==x?x:par[x]=find(par[x]));\\n    }\\n    void union_(int a,int b)\\n    {\\n        a=find(a); b=find(b);\\n        if(a==b)return;\\n        if(rank_[a]>=rank_[b])\\n        {\\n            par[b]=a; rank_[a] += rank_[b];\\n        }\\n        else\\n        {\\n            rank_[b] += rank_[a]; par[a]=b;\\n        }\\n        ans = max(ans,max(rank_[a],rank_[b]));\\n    }\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        ans = 1;\\n        for(int i=1;i<=100000;i++)\\n        {\\n            par[i]=i; rank_[i]=0;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n            rank_[nums[i]]=1;\\n        \\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=2;j*j<=nums[i];j++)\\n            {\\n                if(nums[i]%j == 0)\\n                {\\n                    union_(j,nums[i]);\\n                    union_(j,nums[i]/j);\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    int par[100001],rank_[100001],ans;\\n    int find(int x)\\n    {\\n        return (par[x]==x?x:par[x]=find(par[x]));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1319995,
                "title": "simplest-union-find-solution-with-inline-comments-for-explaination-95-time",
                "content": "**Main Intuition:**\\n1. Do union operation of all numbers with their prime factors\\n2. Answer will be the most frequent parent (or root)\\n```\\n    /* --------------------------------- GENERAL UNION FIND TEMPLATE ----------------------------------- */\\n    \\n    struct vt{\\n        int parent;\\n        int rank;\\n    };\\n    \\n    int ds_find(vector<vt> & ds, int v){\\n        if(ds[v].parent==-1)\\n            return v;\\n        \\n        return ds[v].parent = ds_find(ds, ds[v].parent);\\n    }\\n    \\n    void ds_union(vector<vt> & ds, int v1, int v2){\\n        if(ds[v1].rank < ds[v2].rank)\\n            ds[v1].parent = v2;\\n        \\n        else if(ds[v1].rank > ds[v2].rank)\\n            ds[v2].parent = v1;\\n        \\n        else{\\n            ds[v1].parent = v2;\\n            ds[v2].rank++;\\n        }\\n    }\\n    \\n    /* ------------------------------------------------------------------------------------------------- */\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int mx = *max_element(nums.begin(), nums.end());\\n        \\n        vector<vt> ds (mx+1, {-1, 0});\\n        \\n        /* Iterate array nums */\\n        \\n        for(int num : nums){\\n            int sqr_root = sqrt(num);\\n            \\n            /* For each element, find prime factors (by iterating from 2 to sqrt(num)) */\\n            \\n            for(int i=2; i<=sqr_root; i++){\\n                \\n                /* Do union operation of num with its every prime factor */\\n                \\n                if(num%i==0){\\n                    \\n                    /* We need to do find operation everytime because root may change anytime */\\n                    \\n                    int root1 = ds_find(ds, num);\\n                    int root2 = ds_find(ds, i);\\n                    \\n                    if(root1!=root2)\\n                        ds_union(ds, root1, root2);\\n                    \\n                    root1 = ds_find(ds, num); \\n                    root2 = ds_find(ds, num/i);\\n                    \\n                    if(root1!=root2)\\n                        ds_union(ds, root1, root2);\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int, int> mp;     // ----> will contains frequency of roots of each element\\n        int ans = 1;\\n        \\n        for(int num : nums){\\n            int root = ds_find(ds, num);\\n            mp[root]++;\\n            \\n            ans = max(ans, mp[root]);  // ----> Ans will be the max frequency of all roots\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    /* --------------------------------- GENERAL UNION FIND TEMPLATE ----------------------------------- */\\n    \\n    struct vt{\\n        int parent;\\n        int rank;\\n    };\\n    \\n    int ds_find(vector<vt> & ds, int v){\\n        if(ds[v].parent==-1)\\n            return v;\\n        \\n        return ds[v].parent = ds_find(ds, ds[v].parent);\\n    }\\n    \\n    void ds_union(vector<vt> & ds, int v1, int v2){\\n        if(ds[v1].rank < ds[v2].rank)\\n            ds[v1].parent = v2;\\n        \\n        else if(ds[v1].rank > ds[v2].rank)\\n            ds[v2].parent = v1;\\n        \\n        else{\\n            ds[v1].parent = v2;\\n            ds[v2].rank++;\\n        }\\n    }\\n    \\n    /* ------------------------------------------------------------------------------------------------- */\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int mx = *max_element(nums.begin(), nums.end());\\n        \\n        vector<vt> ds (mx+1, {-1, 0});\\n        \\n        /* Iterate array nums */\\n        \\n        for(int num : nums){\\n            int sqr_root = sqrt(num);\\n            \\n            /* For each element, find prime factors (by iterating from 2 to sqrt(num)) */\\n            \\n            for(int i=2; i<=sqr_root; i++){\\n                \\n                /* Do union operation of num with its every prime factor */\\n                \\n                if(num%i==0){\\n                    \\n                    /* We need to do find operation everytime because root may change anytime */\\n                    \\n                    int root1 = ds_find(ds, num);\\n                    int root2 = ds_find(ds, i);\\n                    \\n                    if(root1!=root2)\\n                        ds_union(ds, root1, root2);\\n                    \\n                    root1 = ds_find(ds, num); \\n                    root2 = ds_find(ds, num/i);\\n                    \\n                    if(root1!=root2)\\n                        ds_union(ds, root1, root2);\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int, int> mp;     // ----> will contains frequency of roots of each element\\n        int ans = 1;\\n        \\n        for(int num : nums){\\n            int root = ds_find(ds, num);\\n            mp[root]++;\\n            \\n            ans = max(ans, mp[root]);  // ----> Ans will be the max frequency of all roots\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1235995,
                "title": "3-separate-class-easy-to-understand-unionfind-class-sieve-class-c",
                "content": "```\\nclass UnionFind {\\n    public:\\n        vector < int > par, SIZ;\\n        UnionFind( int sz = 100005 ) {\\n            for ( int i = 0; i < sz; ++i ) {\\n                par.push_back( i );\\n                SIZ.push_back( 0 );\\n            }\\n        }\\n\\n        int find_root( int u ) {\\n            if ( par[ u ] != u )\\n                par[ u ] = find_root( par[ u ] );\\n\\n                return par[ u ];\\n        }\\n\\n        void merge( int u, int v ) {\\n            if ( find_root( u ) != find_root( v ) ) {\\n                if ( SIZ[ par[ u ] ] <= SIZ[ par[ v ] ] )   swap( u, v );\\n\\n                SIZ[ par[ u ] ] += SIZ[ par[ v ] ];\\n                par[ par[ v ] ] = par[ u ];\\n            }\\n        }\\n};\\n\\nclass Sieve {\\n    public:     \\n        vector < int > sie;\\n        vector < int > spf;  \\n    \\n        Sieve( int MSS ) {    \\n            spf.resize( MSS + 7, 0 );\\n            for ( int i = 2; i < MSS; ++i ) {  \\n                if ( spf[ i ] == 0 ) {\\n                    spf[ i ] = i;   \\n                    sie.push_back( i );  \\n                }    \\n                for ( int j = 0; j < sie.size() && i * sie[ j ] <= MSS && sie[ j ] <= spf[ i ]; ++j ) \\n                    spf[ i * sie[ j ] ] = sie[ j ]; \\n            }\\n        }\\n};\\n\\nclass Solution {\\n    public:\\n        Sieve Sv = Sieve( 100005 );\\n    \\n        int largestComponentSize( vector < int > &Arr ) {\\n            UnionFind UF = UnionFind();\\n            \\n            for ( int A : Arr ) {\\n                if ( A == 1 ) {\\n                    UF.SIZ[ A ] = 1;\\n                    continue;\\n                }\\n                vector < int > E;\\n                while ( A != 1 ) {\\n                    E.push_back( Sv.spf[ A ] );\\n                    A /= Sv.spf[ A ]; \\n                }\\n                \\n                UF.SIZ[ UF.find_root( E[ 0 ] ) ]++;\\n                \\n                for ( int i = 1; i < E.size(); ++i ) \\n                    UF.merge( E[ 0 ], E[ i ] );\\n            }\\n            \\n            return *max_element( UF.SIZ.begin(), UF.SIZ.end() );\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind {\\n    public:\\n        vector < int > par, SIZ;\\n        UnionFind( int sz = 100005 ) {\\n            for ( int i = 0; i < sz; ++i ) {\\n                par.push_back( i );\\n                SIZ.push_back( 0 );\\n            }\\n        }\\n\\n        int find_root( int u ) {\\n            if ( par[ u ] != u )\\n                par[ u ] = find_root( par[ u ] );\\n\\n                return par[ u ];\\n        }\\n\\n        void merge( int u, int v ) {\\n            if ( find_root( u ) != find_root( v ) ) {\\n                if ( SIZ[ par[ u ] ] <= SIZ[ par[ v ] ] )   swap( u, v );\\n\\n                SIZ[ par[ u ] ] += SIZ[ par[ v ] ];\\n                par[ par[ v ] ] = par[ u ];\\n            }\\n        }\\n};\\n\\nclass Sieve {\\n    public:     \\n        vector < int > sie;\\n        vector < int > spf;  \\n    \\n        Sieve( int MSS ) {    \\n            spf.resize( MSS + 7, 0 );\\n            for ( int i = 2; i < MSS; ++i ) {  \\n                if ( spf[ i ] == 0 ) {\\n                    spf[ i ] = i;   \\n                    sie.push_back( i );  \\n                }    \\n                for ( int j = 0; j < sie.size() && i * sie[ j ] <= MSS && sie[ j ] <= spf[ i ]; ++j ) \\n                    spf[ i * sie[ j ] ] = sie[ j ]; \\n            }\\n        }\\n};\\n\\nclass Solution {\\n    public:\\n        Sieve Sv = Sieve( 100005 );\\n    \\n        int largestComponentSize( vector < int > &Arr ) {\\n            UnionFind UF = UnionFind();\\n            \\n            for ( int A : Arr ) {\\n                if ( A == 1 ) {\\n                    UF.SIZ[ A ] = 1;\\n                    continue;\\n                }\\n                vector < int > E;\\n                while ( A != 1 ) {\\n                    E.push_back( Sv.spf[ A ] );\\n                    A /= Sv.spf[ A ]; \\n                }\\n                \\n                UF.SIZ[ UF.find_root( E[ 0 ] ) ]++;\\n                \\n                for ( int i = 1; i < E.size(); ++i ) \\n                    UF.merge( E[ 0 ], E[ i ] );\\n            }\\n            \\n            return *max_element( UF.SIZ.begin(), UF.SIZ.end() );\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1217549,
                "title": "c-union-find-prime-fact",
                "content": "```\\nclass Solution {\\npublic:\\n    int parent[100001];\\n    int find(int x)\\n    {\\n        if(parent[x]!=x)\\n            parent[x]=find(parent[x]);\\n        return parent[x];\\n    }\\n    void Union(int x,int y)\\n    {\\n        int px=find(x),py=find(y);\\n        parent[py]=px;\\n    }\\n    int largestComponentSize(vector<int>& nums) \\n    {\\n        for(int i=0;i<=100000;i++)\\n            parent[i]=i;\\n        for(auto x:nums)\\n        {\\n            int i=2;\\n            int n=x;\\n            while(i*i<=n)\\n            {\\n                bool flag=false;\\n                while(n%i==0)\\n                {\\n                    flag=true;\\n                    n/=i;\\n                }\\n                if(flag)\\n                    Union(x,i);\\n                i++;\\n            }\\n            if(n>2)\\n                Union(x,n);\\n        }\\n        int res=0;\\n        unordered_map<int,int>m;\\n        for(auto x:nums)\\n        {\\n            int pa=find(x);\\n            m[pa]++;\\n            res=max(res,m[pa]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int parent[100001];\\n    int find(int x)\\n    {\\n        if(parent[x]!=x)\\n            parent[x]=find(parent[x]);\\n        return parent[x];\\n    }\\n    void Union(int x,int y)\\n    {\\n        int px=find(x),py=find(y);\\n        parent[py]=px;\\n    }\\n    int largestComponentSize(vector<int>& nums) \\n    {\\n        for(int i=0;i<=100000;i++)\\n            parent[i]=i;\\n        for(auto x:nums)\\n        {\\n            int i=2;\\n            int n=x;\\n            while(i*i<=n)\\n            {\\n                bool flag=false;\\n                while(n%i==0)\\n                {\\n                    flag=true;\\n                    n/=i;\\n                }\\n                if(flag)\\n                    Union(x,i);\\n                i++;\\n            }\\n            if(n>2)\\n                Union(x,n);\\n        }\\n        int res=0;\\n        unordered_map<int,int>m;\\n        for(auto x:nums)\\n        {\\n            int pa=find(x);\\n            m[pa]++;\\n            res=max(res,m[pa]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831987,
                "title": "python-484ms-beats100-unionfind-primedecomposition-explained",
                "content": "\\tfrom collections import defaultdict\\n\\n   \\n\\tclass Solution:\\n\\t\\tMAXA = 100001\\n\\t\\tisPrime=[0 for _ in range(MAXA+1)]\\n\\t\\tisPrime[0]=-1;isPrime[1]=-1 #0 and 1 are not prime numbers\\n\\t\\tfor i in range(2, MAXA):\\n\\t\\t\\tif isPrime[i]==0: #i is prime\\n\\t\\t\\t\\tfor multiple in range(i*i,MAXA+1,i):\\n\\t\\t\\t\\t\\tif isPrime[multiple]==0:\\n\\t\\t\\t\\t\\t\\tisPrime[multiple]=i\\n\\t\\t\\t\\tisPrime[i] = i # let i store itself for consistency\\n\\n\\t\\tdef largestComponentSize(self, A: List[int]) -> int:\\n\\t\\t\\tlabel = defaultdict(int)\\n\\n\\t\\t\\tdef findRoot(key):\\n\\t\\t\\t\\tif label[key] > 0:\\n\\t\\t\\t\\t\\tlabel[key] = findRoot(label[key])\\n\\t\\t\\t\\t\\treturn label[key]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn key\\n\\n\\t\\t\\tdef mergeRoot(k1, k2):\\n\\t\\t\\t\\tr1, r2 = findRoot(k1), findRoot(k2)  \\n\\t\\t\\t\\tif r1 != r2:\\n\\t\\t\\t\\t\\tr1, r2 = min(r1, r2), max(r1, r2)\\n\\t\\t\\t\\t\\tlabel[r1] += label[r2]\\n\\t\\t\\t\\t\\tlabel[r2] = r1\\n\\t\\t\\t\\treturn r1\\n\\n\\t\\t\\tfor x in A:\\n\\t\\t\\t\\troot_id = 0\\n\\t\\t\\t\\twhile Solution.isPrime[x]!=-1:\\n\\t\\t\\t\\t\\tp = Solution.isPrime[x]\\n\\t\\t\\t\\t\\troot_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\\n\\t\\t\\t\\t\\tx //= p\\n\\t\\t\\t\\tlabel[root_id] -= 1\\n\\n\\t\\t\\treturn -min(label.values())\\n# Explaination\\nDenote *MAXA = UpperBound(A)*\\nIn solution.isPrime, the *smallest prime factor* of that number is stored, for prime numbers, the number itself is stored to keep consistency.\\nThe Generation itself takes an upperbound of *NumberOfPrimesLessThan(MAXA)\\\\*MAXA* which is about *MAXA\\\\*log(MAXA)* for non-trivial *MAXA*.\\nBy using that, we could decompose all the numbers simply by looking up the isPrime array recursivly, which would take about *O(log(MAXA)))* time for each prime factor decomposition.\\nFor UnionFind, the merge and ~O(1) time since we maintain the UnionFind to be at most 2 layers, and the merge itself takes O(1) time, the overall time complexity for this solution is *O(N+MAXA\\\\*log(MAXA))*. \\n\\n# Why this is so fast\\nDue to the nature of the leetcode judge machine, the precomputaion part is not counted for the total time spent if you put them in the class part, so the complexity is reduced to O(N) which makes it faster than most solutions. Which means if someone tried to manually calculate all the prime factors for every numebr from 2 to MAXA, he/she can be even faster than this answer, If you put the calculation os isPrime inside the function, it would take ~2000ms to finish,\\n\\n# Alternative solution [980ms beats 99.6%]\\nIf you don\\'t want to play dirty, here\\'s another solution for you:\\n```\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        small_primes = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317)\\n        label = defaultdict(int)\\n       \\n        def findRoot(key):\\n            if label[key] > 0:\\n                label[key] = findRoot(label[key])\\n                return label[key]\\n            else:\\n                return key\\n        \\n        def mergeRoot(k1, k2):\\n            r1, r2 = findRoot(k1), findRoot(k2)  \\n            if r1 != r2:\\n                r1, r2 = min(r1, r2), max(r1, r2)\\n                label[r1] += label[r2]\\n                label[r2] = r1\\n            return r1\\n\\n        for x in A:\\n            root_id = 0\\n            t = sqrt(x) + 1\\n            for p in small_primes:\\n                if p > t:\\n                    break\\n                elif x % p == 0:\\n                    root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\\n                    while x % p == 0:\\n                        x //= p\\n            if x != 1:\\n                root_id = findRoot(x) if root_id == 0 else mergeRoot(root_id, x)\\n            label[root_id] -= 1\\n        \\n        return -min(label.values())\\n```\\nIn this, we pre-calculated all primes that\\'s smaller that *sqrt(MAXA)*, any number can\\'t be divided by that must be a prime number, which means a new group, and can also be merged using UnionFind. \\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        small_primes = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317)\\n        label = defaultdict(int)\\n       \\n        def findRoot(key):\\n            if label[key] > 0:\\n                label[key] = findRoot(label[key])\\n                return label[key]\\n            else:\\n                return key\\n        \\n        def mergeRoot(k1, k2):\\n            r1, r2 = findRoot(k1), findRoot(k2)  \\n            if r1 != r2:\\n                r1, r2 = min(r1, r2), max(r1, r2)\\n                label[r1] += label[r2]\\n                label[r2] = r1\\n            return r1\\n\\n        for x in A:\\n            root_id = 0\\n            t = sqrt(x) + 1\\n            for p in small_primes:\\n                if p > t:\\n                    break\\n                elif x % p == 0:\\n                    root_id = findRoot(p) if root_id == 0 else mergeRoot(root_id, p)\\n                    while x % p == 0:\\n                        x //= p\\n            if x != 1:\\n                root_id = findRoot(x) if root_id == 0 else mergeRoot(root_id, x)\\n            label[root_id] -= 1\\n        \\n        return -min(label.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831250,
                "title": "python-faster-than-100-union-find-with-sieve-pre-calculation",
                "content": "```\\nclass UF:\\n    def __init__(self,n):\\n        self.p=[i for i in range(n)]  # parent array\\n        self.s=[1]*n  # size array\\n        \\n    def find(self,x): # find the representative/root of x\\n        if self.p[x]!=x:\\n            self.p[x]=self.find(self.p[x])\\n        return self.p[x]\\n\\nclass Solution:\\n    M=100000\\n    sieve=[0]*(M+1) # stores the largest prime divisor of integers up to M\\n    for i in range(2,M+1):\\n        if sieve[i]!=0:\\n            continue\\n        for j in range(1,M//i+1):\\n            sieve[j*i]=i\\n        \\n    def largestComponentSize(self, A: List[int]) -> int:   \\n        g=UF(len(A))\\n        primes=defaultdict(list) # {q:[nums]} list of integers that\\'s divisible by prime q\\n        for i,num in enumerate(A):\\n            while num>1:\\n                q=self.sieve[num]\\n                primes[q].append(i) # add the ith element to be divisible by q\\n                while num%q==0:\\n                    num//=q\\n                    \\n        for l in primes.values():\\n            root=g.find(l[0]) # representative/root of the 1st integer divisible by q\\n            for i in l[1:]: # joins all components with root\\n                node=g.find(i)\\n                if node!=root:\\n                    if g.s[root]<g.s[node]: # connect the smaller set to the larger one (for efficiency)\\n                        root,node=node,root\\n                    g.p[node]=root\\n                    g.s[root]+=g.s[node]\\n        \\n        return max(g.s)\\n```",
                "solutionTags": [],
                "code": "```\\nclass UF:\\n    def __init__(self,n):\\n        self.p=[i for i in range(n)]  # parent array\\n        self.s=[1]*n  # size array\\n        \\n    def find(self,x): # find the representative/root of x\\n        if self.p[x]!=x:\\n            self.p[x]=self.find(self.p[x])\\n        return self.p[x]\\n\\nclass Solution:\\n    M=100000\\n    sieve=[0]*(M+1) # stores the largest prime divisor of integers up to M\\n    for i in range(2,M+1):\\n        if sieve[i]!=0:\\n            continue\\n        for j in range(1,M//i+1):\\n            sieve[j*i]=i\\n        \\n    def largestComponentSize(self, A: List[int]) -> int:   \\n        g=UF(len(A))\\n        primes=defaultdict(list) # {q:[nums]} list of integers that\\'s divisible by prime q\\n        for i,num in enumerate(A):\\n            while num>1:\\n                q=self.sieve[num]\\n                primes[q].append(i) # add the ith element to be divisible by q\\n                while num%q==0:\\n                    num//=q\\n                    \\n        for l in primes.values():\\n            root=g.find(l[0]) # representative/root of the 1st integer divisible by q\\n            for i in l[1:]: # joins all components with root\\n                node=g.find(i)\\n                if node!=root:\\n                    if g.s[root]<g.s[node]: # connect the smaller set to the larger one (for efficiency)\\n                        root,node=node,root\\n                    g.p[node]=root\\n                    g.s[root]+=g.s[node]\\n        \\n        return max(g.s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826136,
                "title": "c-prime-factorization-union-find-similar-to-official-solution",
                "content": "Pairwise iteration leads to TLE, hence we have to use prime factorization.\\n(1) `factored[i]` stores the list of unique prime factors of `A[i]`\\n(2) `primes` stores the unique prime factors of all numbers in `A`, and each prime is assigned an index as value of the map (starting from 0) which corresponds to the index of `pre`\\n(3) Initialize `pre` and apply union find to it, which actually groups all primes. (the number of groups in `pre` is the number of groups in `A`)\\n(4) Since we need to calculate the number of nodes in the largest group, we iterate through `A` again, find the root of `A[i]`, and add it to a counter to count the number.\\n\\n```\\nClass Solution {\\n    int find(int root, vector<int> &pre) {\\n        if (root == pre[root]) return root;\\n        int son = root;\\n        int tmp;\\n        while (root != pre[root]) {\\n            root = pre[root];\\n        }\\n        while (son != root) {\\n            tmp = pre[son];\\n            pre[son] = root;\\n            son = tmp;\\n        }\\n        return root;\\n    }\\n    \\npublic:\\n    int largestComponentSize(vector<int>& A) {\\n        vector<vector<int>> factored(A.size());\\n        for (int i = 0; i < A.size(); i++) {\\n            int d = 2, x = A[i];\\n            while (d*d <= x) {\\n                if (x%d == 0) {\\n                    while (x%d == 0) {\\n                        x /= d;\\n                    }\\n                    factored[i].push_back(d);\\n                }\\n                d++;\\n            }\\n            if (x > 1 || factored[i].size()==0) factored[i].push_back(x);\\n        }\\n        unordered_map<int, int> primes;\\n        int t = 0;\\n        for (auto vec : factored) {\\n            for (int v : vec) {\\n                if (!primes.count(v)) {\\n                    primes[v] = t;\\n                    t++;\\n                }\\n            }\\n        }\\n        vector<int> pre(primes.size());\\n        for (int i = 0; i < pre.size(); i++) {\\n            pre[i] = i;\\n        }\\n        for (int i = 0; i < A.size(); i++) {\\n            if (factored[i].size() < 2) continue;\\n            for (int j = 1; j < factored[i].size(); j++) {\\n                pre[find(primes[factored[i][j]], pre)] = find(primes[factored[i][0]], pre);\\n            }\\n        }\\n        unordered_map<int, int> count;\\n        for (int i = 0; i < A.size(); i++) {\\n            int root = find(primes[factored[i][0]], pre);\\n            if (count.count(root)) count[root] += 1;\\n            else count[root] = 1;\\n        }\\n        int lcs = 0;\\n        for (auto it=count.begin(); it!=count.end(); it++) {\\n            lcs = max(lcs, it->second);\\n        }\\n        return lcs;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nClass Solution {\\n    int find(int root, vector<int> &pre) {\\n        if (root == pre[root]) return root;\\n        int son = root;\\n        int tmp;\\n        while (root != pre[root]) {\\n            root = pre[root];\\n        }\\n        while (son != root) {\\n            tmp = pre[son];\\n            pre[son] = root;\\n            son = tmp;\\n        }\\n        return root;\\n    }\\n    \\npublic:\\n    int largestComponentSize(vector<int>& A) {\\n        vector<vector<int>> factored(A.size());\\n        for (int i = 0; i < A.size(); i++) {\\n            int d = 2, x = A[i];\\n            while (d*d <= x) {\\n                if (x%d == 0) {\\n                    while (x%d == 0) {\\n                        x /= d;\\n                    }\\n                    factored[i].push_back(d);\\n                }\\n                d++;\\n            }\\n            if (x > 1 || factored[i].size()==0) factored[i].push_back(x);\\n        }\\n        unordered_map<int, int> primes;\\n        int t = 0;\\n        for (auto vec : factored) {\\n            for (int v : vec) {\\n                if (!primes.count(v)) {\\n                    primes[v] = t;\\n                    t++;\\n                }\\n            }\\n        }\\n        vector<int> pre(primes.size());\\n        for (int i = 0; i < pre.size(); i++) {\\n            pre[i] = i;\\n        }\\n        for (int i = 0; i < A.size(); i++) {\\n            if (factored[i].size() < 2) continue;\\n            for (int j = 1; j < factored[i].size(); j++) {\\n                pre[find(primes[factored[i][j]], pre)] = find(primes[factored[i][0]], pre);\\n            }\\n        }\\n        unordered_map<int, int> count;\\n        for (int i = 0; i < A.size(); i++) {\\n            int root = find(primes[factored[i][0]], pre);\\n            if (count.count(root)) count[root] += 1;\\n            else count[root] = 1;\\n        }\\n        int lcs = 0;\\n        for (auto it=count.begin(); it!=count.end(); it++) {\\n            lcs = max(lcs, it->second);\\n        }\\n        return lcs;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 822451,
                "title": "fastest-solution-based-on-elements-factorization-disjoint-set-union-union-find",
                "content": "1. Find unique prime factors of each element (brute force, no magic).\\n2. Build directed graph (from indexes of elements in original array A) using https://cp-algorithms.com/data_structures/disjoint_set_union.html\\n3. Count nodes in each connected group\\n4. Return max group size\\n```\\npublic class Solution\\n{\\n    public int LargestComponentSize(int[] A)\\n    {\\n        var parents = new int[A.Length];\\n        var parentByDivisor = new Dictionary<int,int>();\\n        \\n        for(int i=0; i < A.Length; i++)\\n        {\\n            parents[i] = i;\\n            var divs = GetUniqueDivisors(A[i]);\\n\\n            foreach(var divisor in divs)\\n            {\\n                if(parentByDivisor.TryGetValue(divisor, out var p))\\n                {\\n                    var root = FindParent(parents, p);\\n                    parents[root] = i;\\n                }\\n                parentByDivisor[divisor] = i;\\n            }\\n        }\\n\\n        var count = new int[A.Length];\\n        for (int i = 0; i < A.Length; i++)\\n        {\\n            var root = FindParent(parents, i);\\n            count[root]++;\\n        }\\n\\n        return count.Max();\\n    }\\n\\n    private int FindParent(int[] parents, int i)\\n    {\\n        if (parents[i] != i)\\n        {\\n            parents[i] = FindParent(parents, parents[i]);\\n        }\\n\\n        return parents[i];\\n    }\\n\\n    private HashSet<int> GetUniqueDivisors(int x)\\n    {\\n        var result = new HashSet<int>();\\n        \\n        while(x % 2 == 0)\\n        {\\n            result.Add(2);\\n            x >>= 1;\\n        }\\n        \\n        for (int i = 3; i*i <= x; i += 2)\\n        {\\n            while(x % i == 0)\\n            {\\n                result.Add(i);\\n                x /= i;\\n            }\\n        }\\n\\n        if(x > 1) result.Add(x);\\n\\n        return result;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int LargestComponentSize(int[] A)\\n    {\\n        var parents = new int[A.Length];\\n        var parentByDivisor = new Dictionary<int,int>();\\n        \\n        for(int i=0; i < A.Length; i++)\\n        {\\n            parents[i] = i;\\n            var divs = GetUniqueDivisors(A[i]);\\n\\n            foreach(var divisor in divs)\\n            {\\n                if(parentByDivisor.TryGetValue(divisor, out var p))\\n                {\\n                    var root = FindParent(parents, p);\\n                    parents[root] = i;\\n                }\\n                parentByDivisor[divisor] = i;\\n            }\\n        }\\n\\n        var count = new int[A.Length];\\n        for (int i = 0; i < A.Length; i++)\\n        {\\n            var root = FindParent(parents, i);\\n            count[root]++;\\n        }\\n\\n        return count.Max();\\n    }\\n\\n    private int FindParent(int[] parents, int i)\\n    {\\n        if (parents[i] != i)\\n        {\\n            parents[i] = FindParent(parents, parents[i]);\\n        }\\n\\n        return parents[i];\\n    }\\n\\n    private HashSet<int> GetUniqueDivisors(int x)\\n    {\\n        var result = new HashSet<int>();\\n        \\n        while(x % 2 == 0)\\n        {\\n            result.Add(2);\\n            x >>= 1;\\n        }\\n        \\n        for (int i = 3; i*i <= x; i += 2)\\n        {\\n            while(x % i == 0)\\n            {\\n                result.Add(i);\\n                x /= i;\\n            }\\n        }\\n\\n        if(x > 1) result.Add(x);\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822192,
                "title": "simple-c-approach",
                "content": "```\\nclass Solution {\\npublic:\\n   int parent[100001];\\n    int findParent(int child) {\\n        if(parent[child]==-1) return child;\\n        return parent[child] = findParent(parent[child]);\\n    }\\n    void union_value(int child1, int child2) {\\n        int p_value1 = findParent(child1);\\n        int p_value2 = findParent(child2);\\n        if(p_value1 != p_value2) \\n            parent[p_value2] = p_value1;\\n        \\n    }\\n    \\n    int largestComponentSize(vector<int>& A) {\\n        int ans = 0;\\n        memset(parent, -1, sizeof parent);\\n        \\n        for(int x:A) \\n            for(int j=2; j<= sqrt(x); ++j) \\n                if(x%j == 0) \\n                    {union_value(j, x); union_value(x,x/j);}\\n             \\n        unordered_map<int, int> reference;\\n        for(auto child : A) \\n            ans = max(ans, 1 + reference[findParent(child)]++);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   int parent[100001];\\n    int findParent(int child) {\\n        if(parent[child]==-1) return child;\\n        return parent[child] = findParent(parent[child]);\\n    }\\n    void union_value(int child1, int child2) {\\n        int p_value1 = findParent(child1);\\n        int p_value2 = findParent(child2);\\n        if(p_value1 != p_value2) \\n            parent[p_value2] = p_value1;\\n        \\n    }\\n    \\n    int largestComponentSize(vector<int>& A) {\\n        int ans = 0;\\n        memset(parent, -1, sizeof parent);\\n        \\n        for(int x:A) \\n            for(int j=2; j<= sqrt(x); ++j) \\n                if(x%j == 0) \\n                    {union_value(j, x); union_value(x,x/j);}\\n             \\n        unordered_map<int, int> reference;\\n        for(auto child : A) \\n            ans = max(ans, 1 + reference[findParent(child)]++);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820805,
                "title": "python-simple-solution-works-perfectly-on-all-testcases-but-gets-tle-when-submitted",
                "content": "**Can anyone please tell me why I get a TLE when I submit, but if I run each testcase separately it works perfectly ?????**\\n```\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        n = max(A)\\n        prime_list = [0] * n\\n        \\n        def primes():\\n            for num in range(2, n//2+1):\\n                for i in range(2, num // 2 + 1):\\n                    if (num % i) == 0:\\n                        break\\n                else:\\n                    prime_list[num-1] = 1\\n        primes()\\n        \\n        def get_prime_divisors(n):\\n            s = set()\\n            for i in range(2, n//2+1):\\n                if n % i == 0 and prime_list[i-1] == 1:\\n                    s.add(i)\\n            if prime_list[n-1] == 1:\\n                s.add(n)\\n            return s\\n                    \\n        save = defaultdict(set)\\n        for num in A:\\n            s = get_prime_divisors(num)\\n            #print(s)\\n            for prime in s:\\n                save[prime].add(num)\\n                    \\n        for key, val in save.items():\\n            for val2 in save.values():\\n                if len(val & val2) > 0:\\n                    save[key] |= val2\\n\\n        return max([len(x) for x in save.values()])\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        n = max(A)\\n        prime_list = [0] * n\\n        \\n        def primes():\\n            for num in range(2, n//2+1):\\n                for i in range(2, num // 2 + 1):\\n                    if (num % i) == 0:\\n                        break\\n                else:\\n                    prime_list[num-1] = 1\\n        primes()\\n        \\n        def get_prime_divisors(n):\\n            s = set()\\n            for i in range(2, n//2+1):\\n                if n % i == 0 and prime_list[i-1] == 1:\\n                    s.add(i)\\n            if prime_list[n-1] == 1:\\n                s.add(n)\\n            return s\\n                    \\n        save = defaultdict(set)\\n        for num in A:\\n            s = get_prime_divisors(num)\\n            #print(s)\\n            for prime in s:\\n                save[prime].add(num)\\n                    \\n        for key, val in save.items():\\n            for val2 in save.values():\\n                if len(val & val2) > 0:\\n                    save[key] |= val2\\n\\n        return max([len(x) for x in save.values()])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820610,
                "title": "java-union-and-find-technique-maintain-parentmap",
                "content": "```\\nclass Solution {\\n\\t\\n\\tprivate int findParent (int parentKey, HashMap<Integer, Integer> parent) {\\n\\t\\t\\n\\t\\tif (!parent.containsKey (parentKey)) {\\n\\t\\t\\tparent.put (parentKey, parentKey);\\n\\t\\t}\\n\\t\\t\\n\\t\\twhile (parentKey != parent.get (parentKey)) {\\n\\t\\t\\tparentKey = parent.get (parentKey);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn parentKey;\\n\\t}\\n\\t\\n\\tprivate void union (int num, int factor, HashMap<Integer, Integer> parent) {\\n\\t\\t\\n\\t\\tint numParent = findParent (num, parent);\\n\\t\\tint factorParent = findParent (factor, parent);\\n\\t\\t\\n\\t\\tif (numParent < factorParent) {\\n\\t\\t\\tparent.put (factorParent, numParent);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent.put (numParent, factorParent);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic int largestComponentSize (int[] A) {\\n\\t\\t\\n\\t\\tHashMap<Integer, Integer> parent = new HashMap <>();\\n\\t\\t\\n\\t\\tfor (int num : A) {\\n\\t\\t\\tfor (int factor = 2; factor * factor <= num; factor++) {\\t\\n\\t\\t\\t\\tif (num % factor == 0) {\\n\\t\\t\\t\\t\\tunion (num, factor, parent);\\n\\t\\t\\t\\t\\tif (num / factor != factor) {\\n\\t\\t\\t\\t\\t\\tunion (num, num / factor, parent);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tHashMap<Integer, Integer> connectedComponent = new HashMap <>();\\n\\t\\tint maxComponent = 0;\\n\\t\\t\\n\\t\\tfor (int num : A) {\\n\\t\\t\\tint parentKey = findParent (num, parent);\\n\\t\\t\\tconnectedComponent.put (parentKey, connectedComponent.getOrDefault (parentKey, 0) + 1);\\n\\t\\t\\tmaxComponent = Math.max (maxComponent, connectedComponent.get (parentKey));\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn maxComponent;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\n\\tprivate int findParent (int parentKey, HashMap<Integer, Integer> parent) {\\n\\t\\t\\n\\t\\tif (!parent.containsKey (parentKey)) {\\n\\t\\t\\tparent.put (parentKey, parentKey);\\n\\t\\t}\\n\\t\\t\\n\\t\\twhile (parentKey != parent.get (parentKey)) {\\n\\t\\t\\tparentKey = parent.get (parentKey);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn parentKey;\\n\\t}\\n\\t\\n\\tprivate void union (int num, int factor, HashMap<Integer, Integer> parent) {\\n\\t\\t\\n\\t\\tint numParent = findParent (num, parent);\\n\\t\\tint factorParent = findParent (factor, parent);\\n\\t\\t\\n\\t\\tif (numParent < factorParent) {\\n\\t\\t\\tparent.put (factorParent, numParent);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent.put (numParent, factorParent);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic int largestComponentSize (int[] A) {\\n\\t\\t\\n\\t\\tHashMap<Integer, Integer> parent = new HashMap <>();\\n\\t\\t\\n\\t\\tfor (int num : A) {\\n\\t\\t\\tfor (int factor = 2; factor * factor <= num; factor++) {\\t\\n\\t\\t\\t\\tif (num % factor == 0) {\\n\\t\\t\\t\\t\\tunion (num, factor, parent);\\n\\t\\t\\t\\t\\tif (num / factor != factor) {\\n\\t\\t\\t\\t\\t\\tunion (num, num / factor, parent);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tHashMap<Integer, Integer> connectedComponent = new HashMap <>();\\n\\t\\tint maxComponent = 0;\\n\\t\\t\\n\\t\\tfor (int num : A) {\\n\\t\\t\\tint parentKey = findParent (num, parent);\\n\\t\\t\\tconnectedComponent.put (parentKey, connectedComponent.getOrDefault (parentKey, 0) + 1);\\n\\t\\t\\tmaxComponent = Math.max (maxComponent, connectedComponent.get (parentKey));\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn maxComponent;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820524,
                "title": "c-dfs-explanation",
                "content": "Create graph using prime factors of every node value.\\nhow can we know that  x & y are same component or not?\\nLet x=12, y=15;\\n\\nprime factor of 12= 2 * 2 * 3 . [[[ so create a bi-coonected graph by each distinct prime factor value. 12->2, 12->3 ]]]\\nprime factor of 15=3 * 5   [[[  15->3, 15->5 ]]]\\n\\nwhen we traverse the graph then 12 and 15 should be in same graph.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int>v[100005];\\n    bool seen[100005];\\n    bool have[100005];\\n    int cnt=0;\\n    void dfs(int x)\\n    {\\n        if(seen[x])return;seen[x]=1;\\n        if(have[x]){\\n            cnt++;\\n   \\n        }\\n        for(int i=0;i<v[x].size();i++)dfs(v[x][i]);\\n    }\\n    int largestComponentSize(vector<int>& A) {\\n        for(int i=0;i<A.size();i++)\\n        {\\n            int take=A[i];\\n            have[take]=1;\\n            if(take<2)continue;\\n            for(long j=2;j*j<=(long)take;j++)\\n            {\\n                \\n                if(take%j==0) {\\n                    while(take%j==0){\\n                        take=take/j;\\n                    }\\n                    v[A[i]].push_back(j);\\n                    v[j].push_back(A[i]);\\n                }\\n            }\\n            if(take>1){\\n                v[take].push_back(A[i]);\\n                v[A[i]].push_back(take);\\n            }\\n        }\\n        int mx=0;\\n        for(int i=0;i<A.size();i++) \\n        {\\n            if(seen[A[i]]==0){\\n                cnt=0;\\n                dfs(A[i]);\\n    \\n                mx=max(mx,cnt);\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>v[100005];\\n    bool seen[100005];\\n    bool have[100005];\\n    int cnt=0;\\n    void dfs(int x)\\n    {\\n        if(seen[x])return;seen[x]=1;\\n        if(have[x]){\\n            cnt++;\\n   \\n        }\\n        for(int i=0;i<v[x].size();i++)dfs(v[x][i]);\\n    }\\n    int largestComponentSize(vector<int>& A) {\\n        for(int i=0;i<A.size();i++)\\n        {\\n            int take=A[i];\\n            have[take]=1;\\n            if(take<2)continue;\\n            for(long j=2;j*j<=(long)take;j++)\\n            {\\n                \\n                if(take%j==0) {\\n                    while(take%j==0){\\n                        take=take/j;\\n                    }\\n                    v[A[i]].push_back(j);\\n                    v[j].push_back(A[i]);\\n                }\\n            }\\n            if(take>1){\\n                v[take].push_back(A[i]);\\n                v[A[i]].push_back(take);\\n            }\\n        }\\n        int mx=0;\\n        for(int i=0;i<A.size();i++) \\n        {\\n            if(seen[A[i]]==0){\\n                cnt=0;\\n                dfs(A[i]);\\n    \\n                mx=max(mx,cnt);\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820436,
                "title": "simple-explanation-with-video-on-disjoint-set-merge-find-union-find",
                "content": "https://www.youtube.com/watch?v=2mva2YRgrW8&list=PLJtzaiEpVo2xu4h0gYQzvOMboclK_pZMe&index=2&t=0\\n\\t\\n\\tclass Solution {\\n\\t\\tpublic int largestComponentSize(int[] A) {\\n\\n\\t\\t\\tint maxVal = Integer.MIN_VALUE;\\n\\t\\t\\tfor (int a : A) {\\n\\t\\t\\t\\tmaxVal = Math.max(maxVal, a);\\n\\t\\t\\t}\\n\\n\\t\\t\\tUnionFind uf=new UnionFind(maxVal+1);\\n\\t\\t\\tfor(int a:A){\\n\\t\\t\\t\\tfor(int i=2;i<=Math.sqrt(a);i++){\\n\\t\\t\\t\\t\\tif(a%i==0){\\n\\t\\t\\t\\t\\t\\tuf.union(a,i);\\n\\t\\t\\t\\t\\t\\tuf.union(a,a/i);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint max=1;\\n\\t\\t\\tMap<Integer, Integer> map = new HashMap<>();\\n\\n\\t\\t\\tfor(int a:A){\\n\\t\\t\\t\\tint parent=uf.find(a);\\n\\t\\t\\t\\tmap.put(parent,map.getOrDefault(parent,0)+1);\\n\\t\\t\\t\\tmax=Math.max(max,map.get(parent));\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn max;\\n\\t\\t}\\n\\n\\t\\tclass UnionFind{\\n\\n\\t\\t\\tint[] ar;\\n\\n\\t\\t\\tUnionFind(int len){\\n\\t\\t\\t\\tar=new int[len];\\n\\t\\t\\t\\tfor(int i=0;i<len;i++){\\n\\t\\t\\t\\t\\tar[i]=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint find(int x){\\n\\t\\t\\t\\tif(x!=ar[x]){\\n\\t\\t\\t\\t\\tar[x]=find(ar[x]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ar[x];\\n\\t\\t\\t}\\n\\n\\t\\t\\tvoid union(int x,int y){\\n\\t\\t\\t\\tar[find(x)]=ar[find(y)];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int largestComponentSize(int[] A) {\\n\\n\\t\\t\\tint maxVal = Integer.MIN_VALUE;\\n\\t\\t\\tfor (int a : A) {\\n\\t\\t\\t\\tmaxVal = Math.max(maxVal, a);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 820431,
                "title": "java-union-find-with-prime-factors-giving-tle",
                "content": "The following code gives TLE. Im unable to figure what i am missing to improve the speed or eleminate any redundant calculations.\\n\\nHelp is much appreciated.\\n\\n\\n```\\nclass Solution {\\n    public int largestComponentSize(int[] A) {\\n        // Arrays.sort(A);\\n        int[] graph = new int[A.length];\\n        int maxNum = 0;\\n        for (int i=0; i<graph.length; i++) {\\n            graph[i] = i;\\n            maxNum = Math.max(A[i], maxNum == 0 ? A[i] : maxNum);\\n        }\\n        \\n        // System.out.printf(\"max num is %d\\\\n\", maxNum);\\n        boolean[] isNotPrime = new boolean[maxNum + 1];\\n        \\n        for (int i=2; i*2<=maxNum; i++) {\\n            int prev = -1;\\n            if (!isNotPrime[i]) {\\n                for (int j=0; j<A.length; j++) {\\n                    if (A[j]%i == 0) {\\n                        if (prev != -1) {\\n                            this.union(graph, prev, j);\\n                        }\\n                        prev = j;\\n                    }\\n                }\\n                this.markFactors(isNotPrime, i);\\n            }\\n        }\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        int maxParentCount = 0;\\n        for (int i=0; i< A.length; i++) {\\n            int parent = this.find(graph, i);\\n            // System.out.printf(\"parent of %d is %d\\\\n\", A[i], A[parent]);\\n            int parentCount = map.getOrDefault(parent, 1);\\n            map.put(parent, parentCount+1);\\n            \\n            maxParentCount = Math.max(parentCount, maxParentCount);\\n        }\\n        \\n        return maxParentCount;\\n    }\\n    \\n    private void markFactors(boolean[] isNotPrime, int n) {\\n        for (int i=n; i<isNotPrime.length; i++) {\\n            if (i%n == 0) {\\n                isNotPrime[i] = true;\\n            }\\n        }\\n    }\\n    \\n    private int find(int[] graph, int k) {\\n        int num = k;\\n        if (graph[k] == k) {\\n            return k;\\n        }\\n        \\n        graph[k] = this.find(graph, graph[k]);\\n        \\n        return graph[k];\\n    }\\n    \\n    private void union(int[] graph, int x, int y) {\\n        int p = this.find(graph, x);\\n        int q = this.find(graph, y);\\n        \\n        if (p == q) {\\n            return;\\n        }\\n        \\n        graph[q] = p;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestComponentSize(int[] A) {\\n        // Arrays.sort(A);\\n        int[] graph = new int[A.length];\\n        int maxNum = 0;\\n        for (int i=0; i<graph.length; i++) {\\n            graph[i] = i;\\n            maxNum = Math.max(A[i], maxNum == 0 ? A[i] : maxNum);\\n        }\\n        \\n        // System.out.printf(\"max num is %d\\\\n\", maxNum);\\n        boolean[] isNotPrime = new boolean[maxNum + 1];\\n        \\n        for (int i=2; i*2<=maxNum; i++) {\\n            int prev = -1;\\n            if (!isNotPrime[i]) {\\n                for (int j=0; j<A.length; j++) {\\n                    if (A[j]%i == 0) {\\n                        if (prev != -1) {\\n                            this.union(graph, prev, j);\\n                        }\\n                        prev = j;\\n                    }\\n                }\\n                this.markFactors(isNotPrime, i);\\n            }\\n        }\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        int maxParentCount = 0;\\n        for (int i=0; i< A.length; i++) {\\n            int parent = this.find(graph, i);\\n            // System.out.printf(\"parent of %d is %d\\\\n\", A[i], A[parent]);\\n            int parentCount = map.getOrDefault(parent, 1);\\n            map.put(parent, parentCount+1);\\n            \\n            maxParentCount = Math.max(parentCount, maxParentCount);\\n        }\\n        \\n        return maxParentCount;\\n    }\\n    \\n    private void markFactors(boolean[] isNotPrime, int n) {\\n        for (int i=n; i<isNotPrime.length; i++) {\\n            if (i%n == 0) {\\n                isNotPrime[i] = true;\\n            }\\n        }\\n    }\\n    \\n    private int find(int[] graph, int k) {\\n        int num = k;\\n        if (graph[k] == k) {\\n            return k;\\n        }\\n        \\n        graph[k] = this.find(graph, graph[k]);\\n        \\n        return graph[k];\\n    }\\n    \\n    private void union(int[] graph, int x, int y) {\\n        int p = this.find(graph, x);\\n        int q = this.find(graph, y);\\n        \\n        if (p == q) {\\n            return;\\n        }\\n        \\n        graph[q] = p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820045,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int largestComponentSize(int[] A) {\\n        Map<Integer, Integer> parent = new HashMap<>();\\n        \\n        for (int num : A) {\\n            for (int fact = 2; fact * fact <= num; fact++) {\\n                if (num % fact == 0) {\\n                    union(num, fact, parent);\\n                    union(num, num/fact, parent);   \\n                }\\n            }\\n        }\\n        \\n        int maxValue = 1;\\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\\n        \\n        for (int num : A) {\\n            int findNum = find(num, parent);\\n            \\n            frequencyMap.put(findNum, frequencyMap.getOrDefault(findNum, 0) + 1);\\n            \\n            maxValue = Math.max(maxValue, frequencyMap.get(findNum));\\n        }\\n        \\n        return maxValue;\\n    }\\n    \\n    private void union(int n, int m, Map<Integer, Integer> parent) {\\n        int findN = find(n, parent);\\n        int findM = find(m, parent);\\n        \\n        if (findN < findM) parent.put(findM, findN);\\n        else parent.put(findN, findM);\\n    }\\n    \\n    private int find(int num, Map<Integer, Integer> parent) {\\n        if (parent.get(num) == null) parent.put(num, num);\\n        \\n        while (num != parent.get(num)) num = parent.get(num);\\n        \\n        return num;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int largestComponentSize(int[] A) {\\n        Map<Integer, Integer> parent = new HashMap<>();\\n        \\n        for (int num : A) {\\n            for (int fact = 2; fact * fact <= num; fact++) {\\n                if (num % fact == 0) {\\n                    union(num, fact, parent);\\n                    union(num, num/fact, parent);   \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 660072,
                "title": "python3-concise-and-small-easy-to-understand-unlike-other-solutions",
                "content": "```\\ndef largestComponentSize(self, a: List[int]) -> int:\\n\\td = {}    # simple union find data structure\\n\\tdef find(x):\\n\\t\\tif x != d.setdefault(x,x):\\n\\t\\t\\td[x] = find(d[x])\\n\\t\\treturn d[x]\\n\\tdef union(x,y):\\n\\t\\td[find(x)]=find(y)\\n\\n\\tfor n in a:\\n\\t\\tfor i in range(2,int(n**0.5)+1): #just connect all the factors of the number  to the number\\n\\t\\t\\tif n%i: continue\\n\\t\\t\\tunion(n,i)  \\n\\t\\t\\tunion(n,n//i)\\n\\n\\tcounter = Counter(find(i) for i in a) \\n\\treturn max(counter.values())  # return the parent with maximum children\\n        \\n```",
                "solutionTags": [],
                "code": "```\\ndef largestComponentSize(self, a: List[int]) -> int:\\n\\td = {}    # simple union find data structure\\n\\tdef find(x):\\n\\t\\tif x != d.setdefault(x,x):\\n\\t\\t\\td[x] = find(d[x])\\n\\t\\treturn d[x]\\n\\tdef union(x,y):\\n\\t\\td[find(x)]=find(y)\\n\\n\\tfor n in a:\\n\\t\\tfor i in range(2,int(n**0.5)+1): #just connect all the factors of the number  to the number\\n\\t\\t\\tif n%i: continue\\n\\t\\t\\tunion(n,i)  \\n\\t\\t\\tunion(n,n//i)\\n\\n\\tcounter = Counter(find(i) for i in a) \\n\\treturn max(counter.values())  # return the parent with maximum children\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 592210,
                "title": "java-union-find-sol",
                "content": "```\\nclass Solution {\\n    Map<Integer,Integer>map=new HashMap<>();\\n    Map<Integer,Integer>rootmap=new HashMap<>();\\n    int nums[];\\n    public int largestComponentSize(int[] A) {\\n        int max=0;\\n        int res=0;\\n        for(int n:A)max=Math.max(max,n);\\n        nums=new int[max+1];\\n        for(int i=0;i<nums.length;i++)nums[i]=i;\\n        for(int n:A){\\n            List<Integer>list=new ArrayList<>();\\n            for(int i=2;i*i<=n;i++){\\n                if(n%i==0){\\n                    list.add(i);\\n                    list.add(n/i);\\n                }\\n            }\\n            list.add(n);\\n            for(int i=1;i<list.size();i++){\\n                int r1=find(nums,list.get(i-1));\\n                int r2=find(nums,list.get(i));\\n                if(r1!=r2)nums[r2]=r1;\\n            }\\n            int last=list.get(list.size()-1);\\n            if(!map.containsKey(last))map.put(last,0);\\n            map.put(last,map.get(last)+1);\\n        }\\n        for(Integer prime:map.keySet()){\\n            int r=find(nums,prime);\\n            if(!rootmap.containsKey(r))rootmap.put(r,0);\\n            rootmap.put(r,rootmap.get(r)+map.get(prime));\\n        }\\n        for(Integer key:rootmap.keySet()){\\n            res=Math.max(res,rootmap.get(key));\\n        }\\n        return res;\\n    }\\n    public int find(int nums[],int x){\\n        if(nums[x]==x)return x;\\n        int root=find(nums,nums[x]);\\n        nums[x]=root;\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer,Integer>map=new HashMap<>();\\n    Map<Integer,Integer>rootmap=new HashMap<>();\\n    int nums[];\\n    public int largestComponentSize(int[] A) {\\n        int max=0;\\n        int res=0;\\n        for(int n:A)max=Math.max(max,n);\\n        nums=new int[max+1];\\n        for(int i=0;i<nums.length;i++)nums[i]=i;\\n        for(int n:A){\\n            List<Integer>list=new ArrayList<>();\\n            for(int i=2;i*i<=n;i++){\\n                if(n%i==0){\\n                    list.add(i);\\n                    list.add(n/i);\\n                }\\n            }\\n            list.add(n);\\n            for(int i=1;i<list.size();i++){\\n                int r1=find(nums,list.get(i-1));\\n                int r2=find(nums,list.get(i));\\n                if(r1!=r2)nums[r2]=r1;\\n            }\\n            int last=list.get(list.size()-1);\\n            if(!map.containsKey(last))map.put(last,0);\\n            map.put(last,map.get(last)+1);\\n        }\\n        for(Integer prime:map.keySet()){\\n            int r=find(nums,prime);\\n            if(!rootmap.containsKey(r))rootmap.put(r,0);\\n            rootmap.put(r,rootmap.get(r)+map.get(prime));\\n        }\\n        for(Integer key:rootmap.keySet()){\\n            res=Math.max(res,rootmap.get(key));\\n        }\\n        return res;\\n    }\\n    public int find(int nums[],int x){\\n        if(nums[x]==x)return x;\\n        int root=find(nums,nums[x]);\\n        nums[x]=root;\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 341206,
                "title": "c-solution-prime-factorization-union-find",
                "content": "```\\npublic class Solution \\n{\\n    private  Dictionary<int, int> dict = new Dictionary<int, int>();\\n    private  Dictionary<int, int> count = new Dictionary<int, int>();\\n    private  Dictionary<int, List<int>> group = new Dictionary<int, List<int>>();\\n    public int LargestComponentSize(int[] a) \\n    {\\n        var primes = new HashSet<int>();\\n        var isPrime = Enumerable.Repeat(true, 100001).ToArray();\\n        for (int i = 2; i <= 100000; i++) \\n        {\\n            if (isPrime[i]) \\n            {\\n                primes.Add(i);\\n                for (int j = 2; j * i <= 100000; j++) isPrime[j * i] = false;\\n            }\\n        }\\n        \\n        foreach(var num in a)\\n        {\\n            int n = num;\\n            foreach(var prime in primes)\\n            {\\n                if(prime > n) break;\\n                else if(primes.Contains(n))\\n                {\\n                    if(!group.ContainsKey(n)) group[n] = new List<int>();\\n                    group[n].Add(num);\\n                    break;\\n                }\\n                else if(n % prime == 0)\\n                {\\n                    if(!group.ContainsKey(prime)) group[prime] = new List<int>();\\n                    group[prime].Add(num);\\n                    n = n / prime;\\n                }\\n            }\\n        }\\n        \\n       foreach(var kvp in group)\\n       {\\n           var l = kvp.Value;\\n           for(int i = 0; i < l.Count -1 ; i++)\\n           {\\n               int j = i + 1;\\n               int p1 = GetParent(l[i]), p2 = GetParent(l[j]);\\n               if(p1 != p2)\\n               {\\n                    dict[p1] = p2;\\n                    count[p2] = count[p1] + count[p2];\\n                }\\n            }\\n        }\\n        \\n        return count.Values.Max();\\n    }\\n    \\n    private int GetParent( int n)\\n    {\\n       if(!dict.ContainsKey(n))\\n       {\\n           dict[n] = n;\\n           count[n] = 1;\\n       }\\n        if(dict[n] != n) dict[n] = GetParent(dict[n]);\\n        return dict[n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    private  Dictionary<int, int> dict = new Dictionary<int, int>();\\n    private  Dictionary<int, int> count = new Dictionary<int, int>();\\n    private  Dictionary<int, List<int>> group = new Dictionary<int, List<int>>();\\n    public int LargestComponentSize(int[] a) \\n    {\\n        var primes = new HashSet<int>();\\n        var isPrime = Enumerable.Repeat(true, 100001).ToArray();\\n        for (int i = 2; i <= 100000; i++) \\n        {\\n            if (isPrime[i]) \\n            {\\n                primes.Add(i);\\n                for (int j = 2; j * i <= 100000; j++) isPrime[j * i] = false;\\n            }\\n        }\\n        \\n        foreach(var num in a)\\n        {\\n            int n = num;\\n            foreach(var prime in primes)\\n            {\\n                if(prime > n) break;\\n                else if(primes.Contains(n))\\n                {\\n                    if(!group.ContainsKey(n)) group[n] = new List<int>();\\n                    group[n].Add(num);\\n                    break;\\n                }\\n                else if(n % prime == 0)\\n                {\\n                    if(!group.ContainsKey(prime)) group[prime] = new List<int>();\\n                    group[prime].Add(num);\\n                    n = n / prime;\\n                }\\n            }\\n        }\\n        \\n       foreach(var kvp in group)\\n       {\\n           var l = kvp.Value;\\n           for(int i = 0; i < l.Count -1 ; i++)\\n           {\\n               int j = i + 1;\\n               int p1 = GetParent(l[i]), p2 = GetParent(l[j]);\\n               if(p1 != p2)\\n               {\\n                    dict[p1] = p2;\\n                    count[p2] = count[p1] + count[p2];\\n                }\\n            }\\n        }\\n        \\n        return count.Values.Max();\\n    }\\n    \\n    private int GetParent( int n)\\n    {\\n       if(!dict.ContainsKey(n))\\n       {\\n           dict[n] = n;\\n           count[n] = 1;\\n       }\\n        if(dict[n] != n) dict[n] = GetParent(dict[n]);\\n        return dict[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296150,
                "title": "python-940-ms-95-efficient-factorization-o-m-log-m-2-where-m-is-largest-element",
                "content": "```\\nfrom collections import defaultdict\\n\\n# to factorize k numbers below N, if k is almost as big as N,\\n# it is more efficient to factorize all numbers by sieving\\n# to save space, only keep an array of the smallest factor for each number\\ndef factorList(n):\\n    lst=[0]*(n+1)\\n    lst[1]=1\\n    for i in range(2,n+1):\\n        if lst[i]==0:\\n            for j in range(i,n+1,i):\\n                lst[j]=i\\n    return lst\\n    \\n\\ndef factors(faclist,n):\\n    while n>1:\\n        curr=faclist[n]\\n        yield curr\\n        n//=curr\\n    \\n# union find from https://medium.com/100-days-of-algorithms/day-41-union-find-d0027148376d\\n# with path compression\\ndef find(data, i):\\n    if i != data[i]:\\n        data[i] = find(data, data[i])\\n    return data[i]\\n\\ndef union(data, i, j):\\n    pi, pj = find(data, i), find(data, j)\\n    if pi != pj:\\n        data[pi] = pj\\n    \\n\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        faclist=factorList(max(A))\\n        # for each prime number save a\\n        # representative, so that we have\\n        # a candidate to \"union\" on\\n        repre={}\\n        data={x:x for x in A}\\n        for n in A:\\n            for fac in factors(faclist,n):\\n                if fac in repre:\\n                    union(data,n,repre[fac])\\n                else:\\n                    repre[fac]=n\\n        counter=defaultdict(lambda :0)\\n        for n in A:\\n            counter[find(data,n)]+=1\\n        return max(counter.values())\\n```\\nlet m be the maximum of all input numbers and n ( so A[i]<m for all i and n<m)\\nthe leading factor in the complexity is the itertion over all distinct prime factors. There are O(m*log(log(m))) such factors at most.\\nfor each factor a \"union\" is done. since union with path compression is at least O(n*log(n)) for n operations, the overall complexity is better than O(m*log(m)^2)",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\n# to factorize k numbers below N, if k is almost as big as N,\\n# it is more efficient to factorize all numbers by sieving\\n# to save space, only keep an array of the smallest factor for each number\\ndef factorList(n):\\n    lst=[0]*(n+1)\\n    lst[1]=1\\n    for i in range(2,n+1):\\n        if lst[i]==0:\\n            for j in range(i,n+1,i):\\n                lst[j]=i\\n    return lst\\n    \\n\\ndef factors(faclist,n):\\n    while n>1:\\n        curr=faclist[n]\\n        yield curr\\n        n//=curr\\n    \\n# union find from https://medium.com/100-days-of-algorithms/day-41-union-find-d0027148376d\\n# with path compression\\ndef find(data, i):\\n    if i != data[i]:\\n        data[i] = find(data, data[i])\\n    return data[i]\\n\\ndef union(data, i, j):\\n    pi, pj = find(data, i), find(data, j)\\n    if pi != pj:\\n        data[pi] = pj\\n    \\n\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        faclist=factorList(max(A))\\n        # for each prime number save a\\n        # representative, so that we have\\n        # a candidate to \"union\" on\\n        repre={}\\n        data={x:x for x in A}\\n        for n in A:\\n            for fac in factors(faclist,n):\\n                if fac in repre:\\n                    union(data,n,repre[fac])\\n                else:\\n                    repre[fac]=n\\n        counter=defaultdict(lambda :0)\\n        for n in A:\\n            counter[find(data,n)]+=1\\n        return max(counter.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 261572,
                "title": "straight-forward-python-solution",
                "content": "```\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        factors = collections.defaultdict(set)\\n        uf = Union_find()\\n        for num in A:\\n            for i in range(2, int(math.sqrt(num)+1), 1):\\n                if num % i == 0:\\n                    uf.union(num, i)\\n                    uf.union(num, num//i)\\n        \\n        count = {}\\n        for num in A:\\n            parent = uf.find(num)\\n            if parent not in count:\\n                count[uf.find(num)] =1\\n            else:\\n                count[uf.find(num)] += 1\\n        \\n        return max(count.values())\\n\\nclass Union_find():\\n    def __init__(self):\\n        self.parents = {}\\n    \\n    def make_set(self, x):\\n        if x not in self.parents:\\n            self.parents[x] = x\\n    \\n    def find(self, x):\\n        if x not in self.parents:\\n            self.make_set(x)\\n            return x\\n        elif self.parents[x] is x:\\n            return x\\n        self.parents[x] = self.find(self.parents[x])\\n        return self.parents[x]\\n    \\n    def union(self, x, y):\\n        px = self.find(x)\\n        py = self.find(y)\\n        if px == py:\\n            return \\n\\n        self.parents[px] = py\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        factors = collections.defaultdict(set)\\n        uf = Union_find()\\n        for num in A:\\n            for i in range(2, int(math.sqrt(num)+1), 1):\\n                if num % i == 0:\\n                    uf.union(num, i)\\n                    uf.union(num, num//i)\\n        \\n        count = {}\\n        for num in A:\\n            parent = uf.find(num)\\n            if parent not in count:\\n                count[uf.find(num)] =1\\n            else:\\n                count[uf.find(num)] += 1\\n        \\n        return max(count.values())\\n\\nclass Union_find():\\n    def __init__(self):\\n        self.parents = {}\\n    \\n    def make_set(self, x):\\n        if x not in self.parents:\\n            self.parents[x] = x\\n    \\n    def find(self, x):\\n        if x not in self.parents:\\n            self.make_set(x)\\n            return x\\n        elif self.parents[x] is x:\\n            return x\\n        self.parents[x] = self.find(self.parents[x])\\n        return self.parents[x]\\n    \\n    def union(self, x, y):\\n        px = self.find(x)\\n        py = self.find(y)\\n        if px == py:\\n            return \\n\\n        self.parents[px] = py\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 201122,
                "title": "finally-passed-try-many-many-times-c-code-may-help-you-to-solve-your-tle",
                "content": "```\\n    int find(vector<int> &parent, int a) {\\n        if (parent[a] != a) parent[a] = find(parent, parent[a]);\\n        return parent[a];\\n    }\\n    \\n    int largestComponentSize(vector<int>& A) {\\n        int i, j, n, m, max_num = -1;\\n        int res = 1;\\n        vector<int> parent(A.size(), 0);\\n        vector<int> count(A.size(), 1);\\n        \\n        for(i = 0; i < A.size(); ++i) {\\n            parent[i] = i;\\n            max_num = max(max_num, A[i]);\\n        }\\n        \\n        vector<vector<int>> prime(max_num + 1, vector<int>());\\n        \\n        // This is the most time consuming part, so please not do it multi-times like the following one\\n        // First compute all the prime smaller than 100000\\n        // Second check which prime is the prime factor of A[i]\\n\\t// Because we can do them in one loop\\n        for(i = 0; i < A.size(); ++i) {\\n            // this part is very important, especially j * j <= A[i]\\n            for(j = 2; j * j <= A[i]; ++j) {\\n                if(A[i] % j) continue;\\n                // This is a little trick, the j must be a prime at this stage\\n                // Because in pervious loops: while(A[i] % j == 0) A[i] /= j;\\n                prime[j].push_back(i);\\n                while(A[i] % j == 0) A[i] /= j;\\n            }\\n            if (A[i] > 1) prime[A[i]].push_back(i);\\n            \\n            // if you write the code like this, it will get TLE\\n            /*for(j = 2; j <= A[i]; ++j) {\\n                if(A[i] % j) continue;\\n                prime[j].push_back(i);\\n                while(A[i] % j == 0) A[i] /= j;\\n            }*/\\n        }\\n        \\n        /*\\n        // This is the code will get TLE\\n        // Firstly, compute all the prime smaller than 100000\\n        vector<int> prime_num;\\n        for(i = 2; i <= max_num; ++i) {\\n            for(j = 0; j < prime_num.size(); ++j) {\\n                if(i % prime_num[j] == 0) break;\\n            }\\n            if(j == prime_num.size()) prime_num.push_back(i);\\n        }\\n        \\n        // Secondly, check which prime is the prime factor of A[i]\\n        for(i = 0; i < A.size(); ++i) {\\n            for(j = 0; j < prime_num.size(); ++j) {\\n                if(A[i] < prime_num[j] * prime_num[j]) break;\\n                if(A[i] % prime_num[j]) continue;\\n                prime[prime_num[j]].push_back(i);\\n                while(A[i] % prime_num[j] == 0) A[i] /= prime_num[j];\\n            }\\n            if (A[i] > 1) prime[A[i]].push_back(i);\\n        }\\n        */\\n        \\n        for(i = 2; i < prime.size(); ++i) {\\n            if(prime[i].size() < 2) continue;\\n            n = find(parent, prime[i][0]);\\n            for(j = 1; j < prime[i].size(); ++j) {\\n                m = find(parent, prime[i][j]);\\n                if(m != n) {\\n                    parent[m] = n;\\n                    count[n] += count[m];\\n                    res = max(res, count[n]);\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int find(vector<int> &parent, int a) {\\n        if (parent[a] != a) parent[a] = find(parent, parent[a]);\\n        return parent[a];\\n    }\\n    \\n    int largestComponentSize(vector<int>& A) {\\n        int i, j, n, m, max_num = -1;\\n        int res = 1;\\n        vector<int> parent(A.size(), 0);\\n        vector<int> count(A.size(), 1);\\n        \\n        for(i = 0; i < A.size(); ++i) {\\n            parent[i] = i;\\n            max_num = max(max_num, A[i]);\\n        }\\n        \\n        vector<vector<int>> prime(max_num + 1, vector<int>());\\n        \\n        // This is the most time consuming part, so please not do it multi-times like the following one\\n        // First compute all the prime smaller than 100000\\n        // Second check which prime is the prime factor of A[i]\\n\\t// Because we can do them in one loop\\n        for(i = 0; i < A.size(); ++i) {\\n            // this part is very important, especially j * j <= A[i]\\n            for(j = 2; j * j <= A[i]; ++j) {\\n                if(A[i] % j) continue;\\n                // This is a little trick, the j must be a prime at this stage\\n                // Because in pervious loops: while(A[i] % j == 0) A[i] /= j;\\n                prime[j].push_back(i);\\n                while(A[i] % j == 0) A[i] /= j;\\n            }\\n            if (A[i] > 1) prime[A[i]].push_back(i);\\n            \\n            // if you write the code like this, it will get TLE\\n            /*for(j = 2; j <= A[i]; ++j) {\\n                if(A[i] % j) continue;\\n                prime[j].push_back(i);\\n                while(A[i] % j == 0) A[i] /= j;\\n            }*/\\n        }\\n        \\n        /*\\n        // This is the code will get TLE\\n        // Firstly, compute all the prime smaller than 100000\\n        vector<int> prime_num;\\n        for(i = 2; i <= max_num; ++i) {\\n            for(j = 0; j < prime_num.size(); ++j) {\\n                if(i % prime_num[j] == 0) break;\\n            }\\n            if(j == prime_num.size()) prime_num.push_back(i);\\n        }\\n        \\n        // Secondly, check which prime is the prime factor of A[i]\\n        for(i = 0; i < A.size(); ++i) {\\n            for(j = 0; j < prime_num.size(); ++j) {\\n                if(A[i] < prime_num[j] * prime_num[j]) break;\\n                if(A[i] % prime_num[j]) continue;\\n                prime[prime_num[j]].push_back(i);\\n                while(A[i] % prime_num[j] == 0) A[i] /= prime_num[j];\\n            }\\n            if (A[i] > 1) prime[A[i]].push_back(i);\\n        }\\n        */\\n        \\n        for(i = 2; i < prime.size(); ++i) {\\n            if(prime[i].size() < 2) continue;\\n            n = find(parent, prime[i][0]);\\n            for(j = 1; j < prime[i].size(); ++j) {\\n                m = find(parent, prime[i][j]);\\n                if(m != n) {\\n                    parent[m] = n;\\n                    count[n] += count[m];\\n                    res = max(res, count[n]);\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 200842,
                "title": "tle-exact-same-algorithm-in-ruby-and-c",
                "content": "Hey, I was trying to do everything in ruby just for fun and realised even though my algorithm is good enough (Union Find and Factorization) in Ruby (probably due to high constant time instead of asymptotic complexity) I receive a TLE.\\n\\nI used a weighted union find with path compression.\\n\\nI\\'ve reimplemented the same algorithm in C# and got an accepted.\\n\\nHere are the algorithms (My attempt during the contest was using BFS + Factorization, but this was inspired by neal_wu submission, so I was not the \"creator\" of this approach)\\n\\nThe Ruby version (which received TLE):\\n\\n```\\nclass UnionFind\\n  def initialize(n)\\n    @id = (0..n-1).to_a\\n    @sz = @id.map{1}\\n  end\\n  \\n  def largest_size\\n    @sz.max\\n  end\\n  \\n  def unite(p, q)\\n    i = root(p)\\n    j = root(q)\\n    return if i == j\\n    \\n    if @sz[i] < @sz[j]\\n      @id[i] = j\\n      @sz[j] += @sz[i]\\n    else\\n      @id[j] = i\\n      @sz[i] += @sz[j]\\n    end\\n  end\\n  \\n  private\\n  \\n  def root(i)\\n    while i != @id[i]\\n      @id[i] = @id[@id[i]]\\n      i = @id[i]\\n    end\\n    i\\n  end\\nend\\n\\nclass Sieve\\n  def initialize(n)\\n    @lf = (0..n).map{-1}\\n    \\n    (2..n).each do |i|\\n      (i..n).step(i).each{|j| @lf[j] = i} if @lf[i] == -1\\n    end\\n  end\\n  \\n  def prime?(i)\\n    @lf[i] == i\\n  end\\n  \\n  def lowest_factor(i)\\n    @lf[i]\\n  end\\nend\\n\\nMAX = 100000\\n\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef largest_component_size(a)\\n  sieve = Sieve.new(MAX)\\n  uf = UnionFind.new(a.length)\\n  prime_to_index = (0..MAX).map{-1}\\n  \\n  a.each.with_index do |x, i|\\n    while x != 1\\n      p = sieve.lowest_factor(x)\\n      if prime_to_index[p] != -1\\n        uf.unite(i, prime_to_index[p])\\n      else\\n        prime_to_index[p] = i\\n      end\\n      \\n      loop do\\n        x /= p\\n        break if x % p != 0\\n      end\\n    end\\n  end\\n  \\n  uf.largest_size\\nend\\n```\\n\\nThe C# version:\\n\\n```\\nclass UnionFind {\\n  private int[] id;\\n  private int[] sz;\\n  \\n  public UnionFind(int n) {\\n    this.id = new int[n];\\n    this.sz = new int[n];\\n    for(int i = 0; i < n; i++){\\n      this.id[i] = i;\\n      this.sz[i] = 1;\\n    }\\n  }\\n  \\n  public int LargestSize() {\\n    int max = 1;\\n    for(int i = 0; i < this.sz.Length; i++) {\\n      if(this.sz[i] > max) max = this.sz[i];\\n    }\\n    return max;\\n  }\\n  \\n  public void Unite(int p, int q) {\\n    int i = this.Root(p);\\n    int j = this.Root(q);\\n    \\n    if (i == j) return;\\n    \\n    if(this.sz[i] < this.sz[j]) {\\n      this.id[i] = j;\\n      this.sz[j] += this.sz[i];\\n    } else {\\n      this.id[j] = i;\\n      this.sz[i] += this.sz[j];\\n    }\\n  }\\n\\n  private int Root(int i) {\\n    while(i != this.id[i]){\\n      this.id[i] = this.id[this.id[i]];\\n      i = this.id[i];\\n    }\\n    return i;\\n  }\\n}\\n\\npublic class Solution {\\n  public int LargestComponentSize(int[] A) {\\n    var lowest_factor = new int[100001];\\n    initializeSieve(lowest_factor);\\n    \\n    var uf = new UnionFind(A.Length);\\n    \\n    var primeToIndex = new int[100001];\\n    Array.Fill(primeToIndex, -1);\\n    \\n    for(int i = 0; i < A.Length; i++) {\\n      int x = A[i];\\n      while(x > 1){\\n        int p = lowest_factor[x];\\n        \\n        if(primeToIndex[p] == -1) {\\n          primeToIndex[p] = i;\\n        } else {\\n          uf.Unite(i, primeToIndex[p]);\\n        }\\n        \\n        while(x % p == 0) x /= p;\\n      }\\n    }\\n    \\n    return uf.LargestSize();\\n  }\\n  \\n  private void initializeSieve(int[] lowest_factor) {\\n    for(int i = 0; i <= 100000; i++) lowest_factor[i] = -1;\\n    \\n    for(int i = 2; i <= 100000; i++) {\\n      if (lowest_factor[i] == -1) {\\n        for(int j = i; j <= 100000; j = j + i) lowest_factor[j] = i;\\n      }\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass UnionFind\\n  def initialize(n)\\n    @id = (0..n-1).to_a\\n    @sz = @id.map{1}\\n  end\\n  \\n  def largest_size\\n    @sz.max\\n  end\\n  \\n  def unite(p, q)\\n    i = root(p)\\n    j = root(q)\\n    return if i == j\\n    \\n    if @sz[i] < @sz[j]\\n      @id[i] = j\\n      @sz[j] += @sz[i]\\n    else\\n      @id[j] = i\\n      @sz[i] += @sz[j]\\n    end\\n  end\\n  \\n  private\\n  \\n  def root(i)\\n    while i != @id[i]\\n      @id[i] = @id[@id[i]]\\n      i = @id[i]\\n    end\\n    i\\n  end\\nend\\n\\nclass Sieve\\n  def initialize(n)\\n    @lf = (0..n).map{-1}\\n    \\n    (2..n).each do |i|\\n      (i..n).step(i).each{|j| @lf[j] = i} if @lf[i] == -1\\n    end\\n  end\\n  \\n  def prime?(i)\\n    @lf[i] == i\\n  end\\n  \\n  def lowest_factor(i)\\n    @lf[i]\\n  end\\nend\\n\\nMAX = 100000\\n\\n# @param {Integer[]} a\\n# @return {Integer}\\ndef largest_component_size(a)\\n  sieve = Sieve.new(MAX)\\n  uf = UnionFind.new(a.length)\\n  prime_to_index = (0..MAX).map{-1}\\n  \\n  a.each.with_index do |x, i|\\n    while x != 1\\n      p = sieve.lowest_factor(x)\\n      if prime_to_index[p] != -1\\n        uf.unite(i, prime_to_index[p])\\n      else\\n        prime_to_index[p] = i\\n      end\\n      \\n      loop do\\n        x /= p\\n        break if x % p != 0\\n      end\\n    end\\n  end\\n  \\n  uf.largest_size\\nend\\n```\n```\\nclass UnionFind {\\n  private int[] id;\\n  private int[] sz;\\n  \\n  public UnionFind(int n) {\\n    this.id = new int[n];\\n    this.sz = new int[n];\\n    for(int i = 0; i < n; i++){\\n      this.id[i] = i;\\n      this.sz[i] = 1;\\n    }\\n  }\\n  \\n  public int LargestSize() {\\n    int max = 1;\\n    for(int i = 0; i < this.sz.Length; i++) {\\n      if(this.sz[i] > max) max = this.sz[i];\\n    }\\n    return max;\\n  }\\n  \\n  public void Unite(int p, int q) {\\n    int i = this.Root(p);\\n    int j = this.Root(q);\\n    \\n    if (i == j) return;\\n    \\n    if(this.sz[i] < this.sz[j]) {\\n      this.id[i] = j;\\n      this.sz[j] += this.sz[i];\\n    } else {\\n      this.id[j] = i;\\n      this.sz[i] += this.sz[j];\\n    }\\n  }\\n\\n  private int Root(int i) {\\n    while(i != this.id[i]){\\n      this.id[i] = this.id[this.id[i]];\\n      i = this.id[i];\\n    }\\n    return i;\\n  }\\n}\\n\\npublic class Solution {\\n  public int LargestComponentSize(int[] A) {\\n    var lowest_factor = new int[100001];\\n    initializeSieve(lowest_factor);\\n    \\n    var uf = new UnionFind(A.Length);\\n    \\n    var primeToIndex = new int[100001];\\n    Array.Fill(primeToIndex, -1);\\n    \\n    for(int i = 0; i < A.Length; i++) {\\n      int x = A[i];\\n      while(x > 1){\\n        int p = lowest_factor[x];\\n        \\n        if(primeToIndex[p] == -1) {\\n          primeToIndex[p] = i;\\n        } else {\\n          uf.Unite(i, primeToIndex[p]);\\n        }\\n        \\n        while(x % p == 0) x /= p;\\n      }\\n    }\\n    \\n    return uf.LargestSize();\\n  }\\n  \\n  private void initializeSieve(int[] lowest_factor) {\\n    for(int i = 0; i <= 100000; i++) lowest_factor[i] = -1;\\n    \\n    for(int i = 2; i <= 100000; i++) {\\n      if (lowest_factor[i] == -1) {\\n        for(int j = i; j <= 100000; j = j + i) lowest_factor[j] = i;\\n      }\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200838,
                "title": "java-factorization-dfs-with-explanation",
                "content": "\\nUpdate: Here is a more efficient solution: https://leetcode.com/problems/largest-component-size-by-common-factor/discuss/200923/Prime-Factorization-%2B-DFS-350ms-java\\n\\nProblem consists of two parts:\\n\\ni) Factorize all numbers in A and build a graph.\\nii) find biggest island\\n\\nFactorization for a single integer can be done in `O(sqrt(n))`. A tip here is to iterate until `Math.sqrt(n)` since when you find a factor `f` in that range, you also find the other factor which is `a / f`.\\n\\nCreate `Node` for every item in array and every factor you find and connect them. one thing to keep in mind is factors may or may not exist in array `A` therefore Node has `exists` flag. \\n\\nDo a DFS to find the biggest connected island. Skip the Nodes that do not exist while counting.\\n\\nRuntime : `O(k sqrt(n))` \\nk: # of elements in A + their factors\\nn: largest integer in A\\n\\n```java\\nclass Solution {\\n    public int largestComponentSize(int[] A) {\\n    \\n        Map<Integer, Node> nodes = new HashMap<>();\\n        for (int a : A) nodes.put(a, new Node(a));\\n        for (int a : A) connectFactorsOf(a, nodes);\\n        \\n        Set<Node> visited = new HashSet<>();\\n        int max = 0;\\n        for (Node n : nodes.values()) {\\n            max = Math.max(max, sink(n, visited));\\n        }\\n        return max;\\n    }\\n    \\n    private int sink(Node n, Set<Node> visited) {\\n        if (visited.contains(n)) return 0;\\n        visited.add(n);\\n        \\n        int count = n.exists ? 1 : 0;\\n        for (Node next : n.neighbors) {\\n            count += sink(next, visited);\\n        }\\n        return count;\\n    }\\n    \\n    private void connectFactorsOf(int a, Map<Integer,Node> nodes) {\\n        Node self = nodes.get(a);\\n        \\n        for (int i=2; i <= (int) Math.sqrt(a); i++) {\\n            if (a%i == 0) {\\n                Node factor = nodes.get(i);\\n                factor = factor == null ? new Node(i, false) : factor;\\n                factor.neighbors.add(self);\\n                self.neighbors.add(factor);\\n                \\n                nodes.put(i, factor);\\n                \\n                int other = a/i;\\n                factor = nodes.get(other);\\n                factor = factor == null ? new Node(other, false) : factor;\\n                factor.neighbors.add(self);\\n                self.neighbors.add(factor);\\n                \\n                nodes.put(other, factor);\\n                \\n            }\\n        }\\n    }\\n    \\n    public class Node {\\n        int val;\\n        boolean exists;\\n        Set<Node> neighbors = new HashSet<>();\\n        \\n        public Node(int val) {this(val, true);}\\n        public Node(int val, boolean exists) {\\n            this.val = val;\\n            this.exists = exists;\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int largestComponentSize(int[] A) {\\n    \\n        Map<Integer, Node> nodes = new HashMap<>();\\n        for (int a : A) nodes.put(a, new Node(a));\\n        for (int a : A) connectFactorsOf(a, nodes);\\n        \\n        Set<Node> visited = new HashSet<>();\\n        int max = 0;\\n        for (Node n : nodes.values()) {\\n            max = Math.max(max, sink(n, visited));\\n        }\\n        return max;\\n    }\\n    \\n    private int sink(Node n, Set<Node> visited) {\\n        if (visited.contains(n)) return 0;\\n        visited.add(n);\\n        \\n        int count = n.exists ? 1 : 0;\\n        for (Node next : n.neighbors) {\\n            count += sink(next, visited);\\n        }\\n        return count;\\n    }\\n    \\n    private void connectFactorsOf(int a, Map<Integer,Node> nodes) {\\n        Node self = nodes.get(a);\\n        \\n        for (int i=2; i <= (int) Math.sqrt(a); i++) {\\n            if (a%i == 0) {\\n                Node factor = nodes.get(i);\\n                factor = factor == null ? new Node(i, false) : factor;\\n                factor.neighbors.add(self);\\n                self.neighbors.add(factor);\\n                \\n                nodes.put(i, factor);\\n                \\n                int other = a/i;\\n                factor = nodes.get(other);\\n                factor = factor == null ? new Node(other, false) : factor;\\n                factor.neighbors.add(self);\\n                self.neighbors.add(factor);\\n                \\n                nodes.put(other, factor);\\n                \\n            }\\n        }\\n    }\\n    \\n    public class Node {\\n        int val;\\n        boolean exists;\\n        Set<Node> neighbors = new HashSet<>();\\n        \\n        public Node(int val) {this(val, true);}\\n        public Node(int val, boolean exists) {\\n            this.val = val;\\n            this.exists = exists;\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090548,
                "title": "python-union-find-prime-factor-decomposition",
                "content": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.n = n\\n        self.parents = [i for i in range(n)]\\n        self.childrenNum = n * [1]\\n        \\n    def find(self, i):\\n        if self.parents[i] == i:\\n            return i\\n        \\n        return self.find(self.parents[i])\\n    \\n    def union(self, i, j):\\n        x = self.find(i)\\n        y = self.find(j)\\n        if x != y:\\n            self.parents[y] = x\\n            self.childrenNum[x] += self.childrenNum[y]\\n            self.childrenNum[y] = 0\\n        \\n    def getLargestComponent(self):\\n        return max(self.childrenNum)\\n    \\n    def getSize(self):\\n        s = set()\\n        for i in range(self.n):\\n            s.add(self.find(i))\\n        return len(s)\\n        \\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        def primeset(n):\\n            for i in range(2, int(sqrt(n))+1):\\n                if n % i == 0:\\n                    return primeset(n // i) | {i}\\n                \\n            return {n}\\n        \\n        factorset = {}\\n        n = len(nums)\\n        uf = UnionFind(n)\\n        for i in range(n):\\n            fs = primeset(nums[i])\\n            for factor in fs:\\n                if factor not in factorset:\\n                    factorset[factor] = [i]\\n                    \\n                else:\\n                    factorset[factor].append(i)\\n                    \\n        for key, values in factorset.items():\\n            parent = values[0]\\n            for idx in values[1:]:\\n                uf.union(parent, idx)\\n                \\n        return uf.getLargestComponent()\\n\\'\\'\\'\\n\\u601D\\u8DEF\\uFF1A\\n1\\\\\\u4E00\\u5F00\\u59CB\\u7528\\u7684\\u662Fgcd\\u4F1A\\u5BFC\\u81F4TLE\\uFF0C\\u56E0\\u4E3A\\u6BCF\\u4E24\\u4E2A\\u6570\\u4E4B\\u95F4\\u90FD\\u8981gcd\\uFF0C\\u800C\\u4E14\\u6BD4\\u5982gcd(8195,2)\\u7684\\u8BDD\\u5176\\u5B9E\\u8981\\u5F88\\u4E45\\u5F88\\u4E45\\u2026\\n2\\\\\\u6240\\u4EE5\\u6211\\u4EEC\\u4E0D\\u5982\\u7528prime factor decomposition\\uFF0C\\u5373\\u57282...sqrt(nums[i])\\u4E4B\\u95F4\\u627E\\u51FAnums[i]\\u6240\\u6709\\u7684prime factor\\uFF0C\\u6BD4\\u5982nums[1] = 40\\uFF0C\\u662F\\u75312\\u548C5\\u7EC4\\u6210\\u7684\\uFF0C\\u6240\\u4EE5dict[2].append(1), dict[5].append(1)\\u3002\\n3\\\\\\u7B49\\u5230traverse\\u8FC7\\u4E00\\u904D\\u4E4B\\u540E\\uFF0C\\u5728\\u6BCF\\u4E2Aprime factor dict\\u91CC\\u7684\\u7FA4\\u843D\\u91CC\\u5F00\\u59CBunion\\uFF0C\\u6BD4\\u5982\\u4ECE\\u542B\\u6709\\u516C\\u56E0\\u65702\\u7684set\\u5F00\\u59CB\\uFF0Cvalue = dict[2]\\uFF0Cvalue[0]\\u4E3Aparent\\u548Cvalue[1...-1]\\u75AF\\u72C2union\\u3002\\n4\\\\time complexity\\uFF1A\\u611F\\u89C9\\u662FO(n) * O(log2(1e5))\\n\\'\\'\\'\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.n = n\\n        self.parents = [i for i in range(n)]\\n        self.childrenNum = n * [1]\\n        \\n    def find(self, i):\\n        if self.parents[i] == i:\\n            return i\\n        \\n        return self.find(self.parents[i])\\n    \\n    def union(self, i, j):\\n        x = self.find(i)\\n        y = self.find(j)\\n        if x != y:\\n            self.parents[y] = x\\n            self.childrenNum[x] += self.childrenNum[y]\\n            self.childrenNum[y] = 0\\n        \\n    def getLargestComponent(self):\\n        return max(self.childrenNum)\\n    \\n    def getSize(self):\\n        s = set()\\n        for i in range(self.n):\\n            s.add(self.find(i))\\n        return len(s)\\n        \\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        def primeset(n):\\n            for i in range(2, int(sqrt(n))+1):\\n                if n % i == 0:\\n                    return primeset(n // i) | {i}\\n                \\n            return {n}\\n        \\n        factorset = {}\\n        n = len(nums)\\n        uf = UnionFind(n)\\n        for i in range(n):\\n            fs = primeset(nums[i])\\n            for factor in fs:\\n                if factor not in factorset:\\n                    factorset[factor] = [i]\\n                    \\n                else:\\n                    factorset[factor].append(i)\\n                    \\n        for key, values in factorset.items():\\n            parent = values[0]\\n            for idx in values[1:]:\\n                uf.union(parent, idx)\\n                \\n        return uf.getLargestComponent()\\n\\'\\'\\'\\n\\u601D\\u8DEF\\uFF1A\\n1\\\\\\u4E00\\u5F00\\u59CB\\u7528\\u7684\\u662Fgcd\\u4F1A\\u5BFC\\u81F4TLE\\uFF0C\\u56E0\\u4E3A\\u6BCF\\u4E24\\u4E2A\\u6570\\u4E4B\\u95F4\\u90FD\\u8981gcd\\uFF0C\\u800C\\u4E14\\u6BD4\\u5982gcd(8195,2)\\u7684\\u8BDD\\u5176\\u5B9E\\u8981\\u5F88\\u4E45\\u5F88\\u4E45\\u2026\\n2\\\\\\u6240\\u4EE5\\u6211\\u4EEC\\u4E0D\\u5982\\u7528prime factor decomposition\\uFF0C\\u5373\\u57282...sqrt(nums[i])\\u4E4B\\u95F4\\u627E\\u51FAnums[i]\\u6240\\u6709\\u7684prime factor\\uFF0C\\u6BD4\\u5982nums[1] = 40\\uFF0C\\u662F\\u75312\\u548C5\\u7EC4\\u6210\\u7684\\uFF0C\\u6240\\u4EE5dict[2].append(1), dict[5].append(1)\\u3002\\n3\\\\\\u7B49\\u5230traverse\\u8FC7\\u4E00\\u904D\\u4E4B\\u540E\\uFF0C\\u5728\\u6BCF\\u4E2Aprime factor dict\\u91CC\\u7684\\u7FA4\\u843D\\u91CC\\u5F00\\u59CBunion\\uFF0C\\u6BD4\\u5982\\u4ECE\\u542B\\u6709\\u516C\\u56E0\\u65702\\u7684set\\u5F00\\u59CB\\uFF0Cvalue = dict[2]\\uFF0Cvalue[0]\\u4E3Aparent\\u548Cvalue[1...-1]\\u75AF\\u72C2union\\u3002\\n4\\\\time complexity\\uFF1A\\u611F\\u89C9\\u662FO(n) * O(log2(1e5))\\n\\'\\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026481,
                "title": "c-dsu-easy-to-understand",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- **Those elements which have any common prime factor should be one group.**\\n\\n# Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\n- Create a Union-Find data structure to group integers.\\n- Calculate prime factors for each integer in the array.\\n- **Connect integers with the same prime factors in the Union-Find structure.**\\n- Find the size of the largest connected component.\\n\\n# Complexity\\n### Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- O(n * sqrt(maxElement)), where n is the number of elements in the array, and maxElement is the maximum integer in the array.\\n\\n### Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- O(n) for the parent, componentSize, and pf arrays, and O(maxElement) for the isPresent array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint findSet(int v, vector<int> &parent){\\n    while(v!=parent[v]){\\n        parent[v] = parent[parent[v]];\\n        v = parent[v];\\n    }\\n    return v;\\n}\\n\\nvoid makeSet(int v, vector<int> &parent, vector<int> &componentSize){\\n\\tparent[v] = v;\\n\\tcomponentSize[v] = 1;\\n}\\n\\nvoid unionSets(int a, int b, vector<int> &parent, vector<int> &componentSize){\\n\\ta = findSet(a, parent);\\n\\tb = findSet(b, parent);\\n\\n\\tif (a != b){\\n\\n\\t\\tif (componentSize[a] < componentSize[b]){\\n\\t\\t\\tswap(a, b);\\n\\t\\t}\\n\\t\\tparent[b] = a;\\n\\t\\tcomponentSize[a] += componentSize[b];\\n\\t}\\n}\\n\\nvector<int> findPrimeFactors(int val){\\n\\tvector<int> pf;\\n\\n\\tfor (int i = 2; i * i <= val; i++){\\n\\t\\tif (val % i == 0){\\n\\t\\t\\twhile (val % i == 0){\\n\\t\\t\\t\\tval /= i;\\n\\t\\t\\t}\\n\\t\\t\\tpf.push_back(i);\\n\\t\\t}\\n\\t}\\n\\tif (val > 1){\\n\\t\\tpf.push_back(val);\\n\\t}\\n\\treturn pf;\\n}\\n\\n    int largestComponentSize(vector<int>& arr) {\\n\\n    int n = arr.size();\\n    // parent: Stores the parent of the set.\\n\\t// componentSize: Stores the size of the set.\\n\\tvector<int> parent(n), componentSize(n);\\n\\n\\tfor (int i = 0; i < n; i++){\\n\\t\\tmakeSet(i, parent, componentSize);\\n\\t}\\n\\n\\t// Finding prime factors.\\n\\tvector<int> pf[n];\\n\\tfor (int i = 0; i < n; i++){\\n\\t\\tpf[i] = findPrimeFactors(arr[i]);\\n\\t}\\n\\n\\t// Finding maximum element in the array.\\n\\tint maxElement = 0;\\n\\tfor (int i = 0; i < n; i++){\\n\\t\\tmaxElement = max(maxElement, arr[i]);\\n\\t}\\n\\n\\tvector<int> isPresent(maxElement + 1, -1);\\n\\tfor (int i = 0; i < n; i++){\\n\\n\\t\\tfor (int j = 0; j < pf[i].size(); j++){\\n\\t\\t\\tint x = pf[i][j];\\n\\t\\t\\t\\n\\t\\t\\tif (isPresent[x] != -1){\\n\\t\\t\\t\\tunionSets(isPresent[x], i, parent, componentSize);\\n\\t\\t\\t}\\n\\t\\t\\tisPresent[x] = i;\\n\\t\\t}\\n\\t}\\n\\n\\t// Stores the size of largest component.\\n\\tint ans = 0;\\n\\tfor (int i = 0; i < n; i++){\\n\\t\\tans = max(ans, componentSize[i]);\\n\\t}\\n\\n\\treturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Union Find",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint findSet(int v, vector<int> &parent){\\n    while(v!=parent[v]){\\n        parent[v] = parent[parent[v]];\\n        v = parent[v];\\n    }\\n    return v;\\n}\\n\\nvoid makeSet(int v, vector<int> &parent, vector<int> &componentSize){\\n\\tparent[v] = v;\\n\\tcomponentSize[v] = 1;\\n}\\n\\nvoid unionSets(int a, int b, vector<int> &parent, vector<int> &componentSize){\\n\\ta = findSet(a, parent);\\n\\tb = findSet(b, parent);\\n\\n\\tif (a != b){\\n\\n\\t\\tif (componentSize[a] < componentSize[b]){\\n\\t\\t\\tswap(a, b);\\n\\t\\t}\\n\\t\\tparent[b] = a;\\n\\t\\tcomponentSize[a] += componentSize[b];\\n\\t}\\n}\\n\\nvector<int> findPrimeFactors(int val){\\n\\tvector<int> pf;\\n\\n\\tfor (int i = 2; i * i <= val; i++){\\n\\t\\tif (val % i == 0){\\n\\t\\t\\twhile (val % i == 0){\\n\\t\\t\\t\\tval /= i;\\n\\t\\t\\t}\\n\\t\\t\\tpf.push_back(i);\\n\\t\\t}\\n\\t}\\n\\tif (val > 1){\\n\\t\\tpf.push_back(val);\\n\\t}\\n\\treturn pf;\\n}\\n\\n    int largestComponentSize(vector<int>& arr) {\\n\\n    int n = arr.size();\\n    // parent: Stores the parent of the set.\\n\\t// componentSize: Stores the size of the set.\\n\\tvector<int> parent(n), componentSize(n);\\n\\n\\tfor (int i = 0; i < n; i++){\\n\\t\\tmakeSet(i, parent, componentSize);\\n\\t}\\n\\n\\t// Finding prime factors.\\n\\tvector<int> pf[n];\\n\\tfor (int i = 0; i < n; i++){\\n\\t\\tpf[i] = findPrimeFactors(arr[i]);\\n\\t}\\n\\n\\t// Finding maximum element in the array.\\n\\tint maxElement = 0;\\n\\tfor (int i = 0; i < n; i++){\\n\\t\\tmaxElement = max(maxElement, arr[i]);\\n\\t}\\n\\n\\tvector<int> isPresent(maxElement + 1, -1);\\n\\tfor (int i = 0; i < n; i++){\\n\\n\\t\\tfor (int j = 0; j < pf[i].size(); j++){\\n\\t\\t\\tint x = pf[i][j];\\n\\t\\t\\t\\n\\t\\t\\tif (isPresent[x] != -1){\\n\\t\\t\\t\\tunionSets(isPresent[x], i, parent, componentSize);\\n\\t\\t\\t}\\n\\t\\t\\tisPresent[x] = i;\\n\\t\\t}\\n\\t}\\n\\n\\t// Stores the size of largest component.\\n\\tint ans = 0;\\n\\tfor (int i = 0; i < n; i++){\\n\\t\\tans = max(ans, componentSize[i]);\\n\\t}\\n\\n\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983137,
                "title": "simplest-code-of-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ninstead of all the factors can we use prime factors only?\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfind all the prime factors of a number and use union find \\nfor more clarity refer my code\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int find(int node,vector<int>&par){\\n        if(par[node]==node) return node;\\n        return par[node]=find(par[node],par);\\n    }\\n\\n    void merge(int u,int v,vector<int>&par,vector<int>&rank){\\n        int x=find(u,par),y=find(v,par);\\n        if(x==y) return;\\n\\n        if(rank[x]>=rank[y]){\\n            par[y]=par[x];\\n            rank[x]+=rank[y];\\n        }\\n        else{\\n            par[x]=par[y];\\n            rank[y]+=rank[x];\\n        }\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n        int mx=*max_element(nums.begin(),nums.end());\\n        vector<int>par(mx+1),rank(mx+1,0);\\n        for(int i=0;i<=mx;i++) par[i]=i;\\n        for(auto i:nums){\\n            if(i==1) continue;\\n            vector<int>fact;\\n            int f=2,num=i;\\n            while(i>1 and f*f<=num){\\n                if(i%f==0) fact.push_back(f);\\n                while(i%f==0) i/=f;\\n                f++;\\n            }\\n            if(i>1) fact.push_back(i);\\n            par[fact[0]]=find(fact[0],par);\\n            rank[par[fact[0]]]++;\\n            for(int k=1;k<fact.size();k++) merge(par[fact[0]],fact[k],par,rank);\\n            // cout<<\"par= \"<<par[fact[0]]<<\" rank= \"<<rank[par[fact[0]]]<<endl;\\n        }\\n        int ans=1;\\n        for(auto i:rank) ans=max(ans,i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int find(int node,vector<int>&par){\\n        if(par[node]==node) return node;\\n        return par[node]=find(par[node],par);\\n    }\\n\\n    void merge(int u,int v,vector<int>&par,vector<int>&rank){\\n        int x=find(u,par),y=find(v,par);\\n        if(x==y) return;\\n\\n        if(rank[x]>=rank[y]){\\n            par[y]=par[x];\\n            rank[x]+=rank[y];\\n        }\\n        else{\\n            par[x]=par[y];\\n            rank[y]+=rank[x];\\n        }\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n        int mx=*max_element(nums.begin(),nums.end());\\n        vector<int>par(mx+1),rank(mx+1,0);\\n        for(int i=0;i<=mx;i++) par[i]=i;\\n        for(auto i:nums){\\n            if(i==1) continue;\\n            vector<int>fact;\\n            int f=2,num=i;\\n            while(i>1 and f*f<=num){\\n                if(i%f==0) fact.push_back(f);\\n                while(i%f==0) i/=f;\\n                f++;\\n            }\\n            if(i>1) fact.push_back(i);\\n            par[fact[0]]=find(fact[0],par);\\n            rank[par[fact[0]]]++;\\n            for(int k=1;k<fact.size();k++) merge(par[fact[0]],fact[k],par,rank);\\n            // cout<<\"par= \"<<par[fact[0]]<<\" rank= \"<<rank[par[fact[0]]]<<endl;\\n        }\\n        int ans=1;\\n        for(auto i:rank) ans=max(ans,i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3949365,
                "title": "dsu-and-prime-factorisation",
                "content": "\\n# Code\\n```\\nstruct dsu{\\n\\n    vector<int> par;\\n    vector<int> lvl;\\n    dsu(){\\n        par.resize(100001);\\n        iota(par.begin(), par.end(),0);\\n        lvl.assign(100001,0);\\n    }\\n    int get(int a){\\n        if(par[a]==a) return a;\\n        return get(par[a]);\\n    }\\n    void unite(int a, int b){\\n        a=get(a);\\n        b=get(b);\\n        if(a==b) return;\\n        if(lvl[a]<lvl[b]){\\n            swap(a,b);\\n        }\\n        if(lvl[a]==lvl[b]) lvl[a]++;\\n        par[b]=a;\\n        return ;\\n    }\\n\\n};\\nclass Solution {\\npublic:\\n    vector<int> primefactors(int n){\\n        vector<int> v;\\n        for(int i=2; i*i<=n; i++){\\n            if(n%i==0){\\n                while(n%i==0){\\n                    n=n/i;\\n                }\\n                v.push_back(i);\\n            }\\n        }\\n        if(n>1) v.push_back(n);\\n        return v;\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n        dsu graph;\\n        int groups=0;\\n        for(auto u: nums){\\n            if(u==1){\\n                groups=1;\\n                continue;\\n            }\\n            vector<int> v=primefactors(u);\\n            int n=v.size();\\n            for(int i=0; i<n; i++){\\n                for(int j=i+1; j<n; j++){\\n                    graph.unite(v[i],v[j]);\\n                }\\n            }\\n        }\\n        map<int,int> mp;\\n        for(auto u: nums){\\n            if(u==1) continue;\\n            vector<int> v=primefactors(u);\\n            int k=graph.get(v[0]);\\n            mp[k]++;\\n            groups=max(groups, mp[k]);\\n        }\\n        return groups;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct dsu{\\n\\n    vector<int> par;\\n    vector<int> lvl;\\n    dsu(){\\n        par.resize(100001);\\n        iota(par.begin(), par.end(),0);\\n        lvl.assign(100001,0);\\n    }\\n    int get(int a){\\n        if(par[a]==a) return a;\\n        return get(par[a]);\\n    }\\n    void unite(int a, int b){\\n        a=get(a);\\n        b=get(b);\\n        if(a==b) return;\\n        if(lvl[a]<lvl[b]){\\n            swap(a,b);\\n        }\\n        if(lvl[a]==lvl[b]) lvl[a]++;\\n        par[b]=a;\\n        return ;\\n    }\\n\\n};\\nclass Solution {\\npublic:\\n    vector<int> primefactors(int n){\\n        vector<int> v;\\n        for(int i=2; i*i<=n; i++){\\n            if(n%i==0){\\n                while(n%i==0){\\n                    n=n/i;\\n                }\\n                v.push_back(i);\\n            }\\n        }\\n        if(n>1) v.push_back(n);\\n        return v;\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n        dsu graph;\\n        int groups=0;\\n        for(auto u: nums){\\n            if(u==1){\\n                groups=1;\\n                continue;\\n            }\\n            vector<int> v=primefactors(u);\\n            int n=v.size();\\n            for(int i=0; i<n; i++){\\n                for(int j=i+1; j<n; j++){\\n                    graph.unite(v[i],v[j]);\\n                }\\n            }\\n        }\\n        map<int,int> mp;\\n        for(auto u: nums){\\n            if(u==1) continue;\\n            vector<int> v=primefactors(u);\\n            int k=graph.get(v[0]);\\n            mp[k]++;\\n            groups=max(groups, mp[k]);\\n        }\\n        return groups;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928240,
                "title": "easy-to-understand-sieve-and-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n##### Use sieve algorithm to find the smallest prime factor (spf) for each number in 1 to 10**5\\n1. finding the spf of all numbers also gives us all the prime factors of the number, this is because by successively dividing by the spf we get a smaller number with potentially a differnt spf and continuing we would encounter all the prime factors.\\n\\n##### Union Find\\n1. Create a list for each prime where the list would contain multiples of the prime that belong to the array\\n2. union over all the elements for each prime\\n3. count the frequency of each representative element of union find\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(M\\\\log(M) + N\\\\log(M))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M + N\\\\log(M))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nM = 10**5 + 1\\nspf = [x for x in range(M)]\\nfor i in range(2, M):\\n    if spf[i] != i:\\n        continue\\n    j = i ** 2\\n    while j < M:\\n        spf[j] = min(spf[j], i)\\n        j += i\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        \\n        # Use sieve algorithm to find the smallest prime factor (spf) for each number in 1 to 10**5\\n        #       finding the spf of all numbers also gives us all the prime factors of the number\\n        #       this is because by successivel divifing by the spf gives us smaller number with potentially \\n        #       a differnt spf and so on\\n\\n        # create a list for each prime where the list would contain multiples of the prime that belong to the array\\n        # union over all the elements for each prime\\n        # count the number of times each representative element of the union find\\n        \\n        n = len(nums)\\n        divides = defaultdict(set)\\n        for i, x in enumerate(nums):\\n            num = x\\n            while num > 1:\\n                divides[spf[num]].add(i)\\n                num //= spf[num]\\n        parents = [x for x in range(n)]\\n        def find(a):\\n            if parents[a] != a:\\n                parents[a] = find(parents[a])\\n            return parents[a]\\n        \\n        def union(a, b):\\n            ua, ub = find(a), find(b)\\n            parents[ua] = ub\\n        \\n        for prime in divides:\\n            arr = list(divides[prime])\\n            for x in arr:\\n                union(x, arr[0])\\n        \\n        counts = defaultdict(int)\\n        for i in range(n):\\n            counts[find(i)] += 1\\n        \\n        return max(counts.values())\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math",
                    "Union Find",
                    "Number Theory"
                ],
                "code": "```\\nM = 10**5 + 1\\nspf = [x for x in range(M)]\\nfor i in range(2, M):\\n    if spf[i] != i:\\n        continue\\n    j = i ** 2\\n    while j < M:\\n        spf[j] = min(spf[j], i)\\n        j += i\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        \\n        # Use sieve algorithm to find the smallest prime factor (spf) for each number in 1 to 10**5\\n        #       finding the spf of all numbers also gives us all the prime factors of the number\\n        #       this is because by successivel divifing by the spf gives us smaller number with potentially \\n        #       a differnt spf and so on\\n\\n        # create a list for each prime where the list would contain multiples of the prime that belong to the array\\n        # union over all the elements for each prime\\n        # count the number of times each representative element of the union find\\n        \\n        n = len(nums)\\n        divides = defaultdict(set)\\n        for i, x in enumerate(nums):\\n            num = x\\n            while num > 1:\\n                divides[spf[num]].add(i)\\n                num //= spf[num]\\n        parents = [x for x in range(n)]\\n        def find(a):\\n            if parents[a] != a:\\n                parents[a] = find(parents[a])\\n            return parents[a]\\n        \\n        def union(a, b):\\n            ua, ub = find(a), find(b)\\n            parents[ua] = ub\\n        \\n        for prime in divides:\\n            arr = list(divides[prime])\\n            for x in arr:\\n                union(x, arr[0])\\n        \\n        counts = defaultdict(int)\\n        for i in range(n):\\n            counts[find(i)] += 1\\n        \\n        return max(counts.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924264,
                "title": "using-sieve-and-dfs-union-find",
                "content": "**Using DFS and sieve** \\n\\n```\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n      n,prime,isPresent = max(nums) + 11,[],set(nums) \\n      g,ans,curr = [[] for _ in range(n)],0,0\\n      \\n      \\n      def sieve(n):\\n        primes = [True for _ in range(n)] \\n        for i in range(2,n):\\n          if primes[i] : \\n            for j in range(i*i,n,i): primes[j] = False\\n            prime.append(i) \\n\\n      sieve(n) \\n      for number in prime : \\n        for x in range(2*number,n,number):\\n          if x in isPresent : \\n            g[x].append(number) \\n            g[number].append(x) \\n\\n      visited = [False for _ in range(n)] \\n      def dfs(x):\\n        nonlocal curr\\n        if x in isPresent : curr += 1 \\n        visited[x] = True \\n        for i in g[x] : \\n          if not visited[i] : dfs(i) \\n      \\n      for i in range(n):\\n        curr = 0 \\n        if not visited[i]:\\n          dfs(i) \\n          ans = max(ans ,curr) \\n          \\n      return ans\\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n      n,prime,isPresent = max(nums) + 11,[],set(nums) \\n      g,ans,curr = [[] for _ in range(n)],0,0\\n      \\n      \\n      def sieve(n):\\n        primes = [True for _ in range(n)] \\n        for i in range(2,n):\\n          if primes[i] : \\n            for j in range(i*i,n,i): primes[j] = False\\n            prime.append(i) \\n\\n      sieve(n) \\n      for number in prime : \\n        for x in range(2*number,n,number):\\n          if x in isPresent : \\n            g[x].append(number) \\n            g[number].append(x) \\n\\n      visited = [False for _ in range(n)] \\n      def dfs(x):\\n        nonlocal curr\\n        if x in isPresent : curr += 1 \\n        visited[x] = True \\n        for i in g[x] : \\n          if not visited[i] : dfs(i) \\n      \\n      for i in range(n):\\n        curr = 0 \\n        if not visited[i]:\\n          dfs(i) \\n          ans = max(ans ,curr) \\n          \\n      return ans\\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878705,
                "title": "typescript-dsu-prime-factor-calcs-max-group-runtime-beats-100",
                "content": "# Complexity\\n- Time complexity:\\nO(N * (logM^2 + sqrt(M)))\\n\\n- Space complexity:\\nO(M+N)\\n\\n# Code\\n```\\nclass DSU {\\n    rank: number[];\\n    root: number[];\\n\\n    constructor (size: number) {\\n        this.rank = new Array(size).fill(1);\\n        this.root = new Array(size).fill(0).map((_, i) => i);\\n    }\\n\\n    find(x: number): number {\\n        if (x === this.root[x]) {\\n            return x;\\n        }\\n        this.root[x] = this.find(this.root[x]);\\n        return this.root[x];\\n    }\\n\\n    union(x: number, y: number): void {\\n        const rootX = this.find(x);\\n        const rootY = this.find(y);\\n\\n        if (rootX !== rootY) {\\n            if (this.rank[rootX] > this.rank[rootY]) {\\n                this.root[rootY] = rootX;\\n            } else if (this.rank[rootX] < this.rank[rootY]) {\\n                this.root[rootX] = rootY;\\n            } else {\\n                this.rank[rootX] += 1;\\n                this.root[rootY] = rootX;\\n            }\\n        }\\n    }\\n\\n    connected(x: number, y: number): boolean {\\n        return this.find(x) == this.find(y);\\n    }\\n}\\n\\n\\nfunction largestComponentSize(nums: number[]): number {\\n    const dsu: DSU = new DSU(Math.max(...nums));\\n\\n    // sieve algo\\n    const primeDecompose = (num: number): number[] => {\\n        let factor: number = 2;\\n        const primeFactors = new Set<number>();\\n        while (num >= factor * factor) {\\n            if (num % factor === 0) {\\n                primeFactors.add(factor);\\n                num /= factor;\\n            } else {\\n                factor++;\\n            }\\n        }\\n        primeFactors.add(num);\\n\\n        return [...primeFactors];\\n    }\\n\\n    const numFactorMap: { [key: number]: number } = {};\\n    for (const num of nums) {\\n      const primeFactors = primeDecompose(num);\\n      numFactorMap[num] = primeFactors[0];\\n\\n      for (let i = 0; i < primeFactors.length - 1; i++) {\\n        dsu.union(primeFactors[i], primeFactors[i + 1]);\\n      }\\n    }\\n\\n    let maxSize: number = 0;\\n    const groupCount: { [key: number]: number } = {};\\n\\n    for (const num of nums) {\\n      const groupId = dsu.find(numFactorMap[num]);\\n      groupCount[groupId] = (groupCount[groupId] || 0) + 1;\\n      maxSize = Math.max(maxSize, groupCount[groupId]);\\n    }\\n\\n    return maxSize;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Math",
                    "Union Find",
                    "Number Theory"
                ],
                "code": "```\\nclass DSU {\\n    rank: number[];\\n    root: number[];\\n\\n    constructor (size: number) {\\n        this.rank = new Array(size).fill(1);\\n        this.root = new Array(size).fill(0).map((_, i) => i);\\n    }\\n\\n    find(x: number): number {\\n        if (x === this.root[x]) {\\n            return x;\\n        }\\n        this.root[x] = this.find(this.root[x]);\\n        return this.root[x];\\n    }\\n\\n    union(x: number, y: number): void {\\n        const rootX = this.find(x);\\n        const rootY = this.find(y);\\n\\n        if (rootX !== rootY) {\\n            if (this.rank[rootX] > this.rank[rootY]) {\\n                this.root[rootY] = rootX;\\n            } else if (this.rank[rootX] < this.rank[rootY]) {\\n                this.root[rootX] = rootY;\\n            } else {\\n                this.rank[rootX] += 1;\\n                this.root[rootY] = rootX;\\n            }\\n        }\\n    }\\n\\n    connected(x: number, y: number): boolean {\\n        return this.find(x) == this.find(y);\\n    }\\n}\\n\\n\\nfunction largestComponentSize(nums: number[]): number {\\n    const dsu: DSU = new DSU(Math.max(...nums));\\n\\n    // sieve algo\\n    const primeDecompose = (num: number): number[] => {\\n        let factor: number = 2;\\n        const primeFactors = new Set<number>();\\n        while (num >= factor * factor) {\\n            if (num % factor === 0) {\\n                primeFactors.add(factor);\\n                num /= factor;\\n            } else {\\n                factor++;\\n            }\\n        }\\n        primeFactors.add(num);\\n\\n        return [...primeFactors];\\n    }\\n\\n    const numFactorMap: { [key: number]: number } = {};\\n    for (const num of nums) {\\n      const primeFactors = primeDecompose(num);\\n      numFactorMap[num] = primeFactors[0];\\n\\n      for (let i = 0; i < primeFactors.length - 1; i++) {\\n        dsu.union(primeFactors[i], primeFactors[i + 1]);\\n      }\\n    }\\n\\n    let maxSize: number = 0;\\n    const groupCount: { [key: number]: number } = {};\\n\\n    for (const num of nums) {\\n      const groupId = dsu.find(numFactorMap[num]);\\n      groupCount[groupId] = (groupCount[groupId] || 0) + 1;\\n      maxSize = Math.max(maxSize, groupCount[groupId]);\\n    }\\n\\n    return maxSize;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842228,
                "title": "python-unionfind-disjointset-factorization",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\nfrom math import gcd\\n\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [0] * n\\n\\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])  # Path compression\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n        root_x = self.find(x)\\n        root_y = self.find(y)\\n\\n        if root_x == root_y:\\n            return False  # Both elements are already in the same set\\n\\n        # Union by rank\\n        if self.rank[root_x] < self.rank[root_y]:\\n            self.parent[root_x] = root_y\\n        elif self.rank[root_x] > self.rank[root_y]:\\n            self.parent[root_y] = root_x\\n        else:\\n            self.parent[root_y] = root_x\\n            self.rank[root_x] += 1\\n        return True  # Elements were successfully merged\\n\\ndef factorize(num):\\n    factors = []\\n    for j in range(2, int(num ** 0.5) + 1):\\n        if num % j == 0:\\n            while num % j == 0:\\n                num //= j\\n            factors.append(j)\\n    if num > 1:\\n        factors.append(num)\\n    return factors\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        max_num = max(nums)\\n        uf = UnionFind(max_num + 1)\\n\\n        # Preprocess and group numbers by their gcd\\n        gcd_groups = defaultdict(list)\\n        for i, num in enumerate(nums):\\n            for f in factorize(num):\\n                gcd_groups[f].append(i)\\n\\n        # Union numbers in each gcd group\\n        for group in gcd_groups.values():\\n            for i in range(len(group) - 1):\\n                uf.union(group[i], group[i + 1])\\n\\n        # Count the size of each component using UnionFind\\n        component_sizes = defaultdict(int)\\n        for i in range(len(nums)):\\n            component_sizes[uf.find(i)] += 1\\n\\n        # Return the size of the largest component\\n        return max(component_sizes.values())\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom math import gcd\\n\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [0] * n\\n\\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])  # Path compression\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n        root_x = self.find(x)\\n        root_y = self.find(y)\\n\\n        if root_x == root_y:\\n            return False  # Both elements are already in the same set\\n\\n        # Union by rank\\n        if self.rank[root_x] < self.rank[root_y]:\\n            self.parent[root_x] = root_y\\n        elif self.rank[root_x] > self.rank[root_y]:\\n            self.parent[root_y] = root_x\\n        else:\\n            self.parent[root_y] = root_x\\n            self.rank[root_x] += 1\\n        return True  # Elements were successfully merged\\n\\ndef factorize(num):\\n    factors = []\\n    for j in range(2, int(num ** 0.5) + 1):\\n        if num % j == 0:\\n            while num % j == 0:\\n                num //= j\\n            factors.append(j)\\n    if num > 1:\\n        factors.append(num)\\n    return factors\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        max_num = max(nums)\\n        uf = UnionFind(max_num + 1)\\n\\n        # Preprocess and group numbers by their gcd\\n        gcd_groups = defaultdict(list)\\n        for i, num in enumerate(nums):\\n            for f in factorize(num):\\n                gcd_groups[f].append(i)\\n\\n        # Union numbers in each gcd group\\n        for group in gcd_groups.values():\\n            for i in range(len(group) - 1):\\n                uf.union(group[i], group[i + 1])\\n\\n        # Count the size of each component using UnionFind\\n        component_sizes = defaultdict(int)\\n        for i in range(len(nums)):\\n            component_sizes[uf.find(i)] += 1\\n\\n        # Return the size of the largest component\\n        return max(component_sizes.values())\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767307,
                "title": "disjoint-set-union-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nmake an edge if gcd of two elements is >1. for this there is no need implement o(n2) but can be done through making a set for each element that holds the factors\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet {\\n    vector<int> rank, parent, size; \\npublic: \\n    DisjointSet(int n) {\\n        rank.resize(n+1, 0); \\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n    int findsize(int node){\\n        return size[node];\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u; \\n            rank[ulp_u]++; \\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n            size[ulp_v] += size[ulp_u]; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v]; \\n        }\\n    }\\n}; \\nclass Solution {\\npublic:\\n unordered_set<int> findfact(int n){\\n     unordered_set<int> factors;\\n     for(int i=2;i<=sqrt(n);i++){\\n         if(n%i==0){\\n             while(n%i==0){n=n/i;}\\n             factors.insert(i);\\n         }\\n     }if(n>1)factors.insert(n);\\n     return factors;\\n }\\n    int largestComponentSize(vector<int>& nums) {\\n        int n=nums.size();\\n        DisjointSet ds(n);\\n        unordered_map<int,int> lastind;\\n        for(int i=0;i<n;i++){\\n            unordered_set<int> factors=findfact(nums[i]);\\n            for(int fact:factors){\\n                if(lastind.find(fact)!=lastind.end()){\\n                    ds.unionBySize(i,lastind[fact]);\\n                }\\n                lastind[fact]=i;//store the last element that is divisible bt a factor and make an edge if it also divides the current number.\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans=max(ans,ds.findsize(i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass DisjointSet {\\n    vector<int> rank, parent, size; \\npublic: \\n    DisjointSet(int n) {\\n        rank.resize(n+1, 0); \\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n    int findsize(int node){\\n        return size[node];\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u; \\n            rank[ulp_u]++; \\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n            size[ulp_v] += size[ulp_u]; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v]; \\n        }\\n    }\\n}; \\nclass Solution {\\npublic:\\n unordered_set<int> findfact(int n){\\n     unordered_set<int> factors;\\n     for(int i=2;i<=sqrt(n);i++){\\n         if(n%i==0){\\n             while(n%i==0){n=n/i;}\\n             factors.insert(i);\\n         }\\n     }if(n>1)factors.insert(n);\\n     return factors;\\n }\\n    int largestComponentSize(vector<int>& nums) {\\n        int n=nums.size();\\n        DisjointSet ds(n);\\n        unordered_map<int,int> lastind;\\n        for(int i=0;i<n;i++){\\n            unordered_set<int> factors=findfact(nums[i]);\\n            for(int fact:factors){\\n                if(lastind.find(fact)!=lastind.end()){\\n                    ds.unionBySize(i,lastind[fact]);\\n                }\\n                lastind[fact]=i;//store the last element that is divisible bt a factor and make an edge if it also divides the current number.\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans=max(ans,ds.findsize(i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728944,
                "title": "java-optimized-solution-disjoint-set-union",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int count =0;\\n    public int largestComponentSize(int[] nums) {\\n\\n        int n=nums.length;\\n        DisjointSet ds=new DisjointSet(n);\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            int num = nums[i];\\n            for (int factor = 2; factor * factor <= num; factor++) {\\n                if (num % factor == 0) {\\n                    if (!map.containsKey(factor))\\n                        map.put(factor, i);\\n                    else\\n                        ds.unionBySize(i, map.get(factor));\\n\\n                    if (!map.containsKey(num / factor))\\n                        map.put(num / factor, i);\\n                    else \\n                        ds.unionBySize(i, map.get(num / factor));\\n                }\\n            }\\n\\n            if (!map.containsKey(num))\\n                map.put(num, i);\\n            else\\n                ds.unionBySize(i, map.get(num));\\n        }\\n\\n        int max = 1;\\n        int component[] = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            int root = ds.findUParent(i);\\n            component[root]++;\\n            max = Math.max(max, component[root]);\\n        }\\n\\n        return max;\\n    }\\n}\\nclass DisjointSet{\\n    List<Integer> rank=new ArrayList<>();\\n    List<Integer> parent=new ArrayList<>();\\n    List<Integer> size=new ArrayList<>();\\n    \\n    public DisjointSet(int n){\\n        for(int i=0;i<=n;i++){\\n            rank.add(0);\\n            parent.add(i);\\n            size.add(1);\\n        }\\n    }\\n    \\n    public int findUParent(int node){\\n        if(node == parent.get(node))\\n            return node;\\n        int ultPar=findUParent(parent.get(node));\\n        //Path Compression\\n        parent.set(node, ultPar);\\n        return parent.get(node);\\n    }\\n\\n    public void unionBySize(int u, int v){\\n        int ultPar_u=findUParent(u);\\n        int ultPar_v=findUParent(v);\\n        if(ultPar_u == ultPar_v)\\n            return;\\n        if(size.get(ultPar_u) < size.get(ultPar_v)){\\n            parent.set(ultPar_u, ultPar_v);\\n            size.set(ultPar_v,size.get(ultPar_v) + size.get(ultPar_u));\\n        }\\n        else{\\n            parent.set(ultPar_v , ultPar_u);\\n            size.set(ultPar_u,size.get(ultPar_v) + size.get(ultPar_u));\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int count =0;\\n    public int largestComponentSize(int[] nums) {\\n\\n        int n=nums.length;\\n        DisjointSet ds=new DisjointSet(n);\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            int num = nums[i];\\n            for (int factor = 2; factor * factor <= num; factor++) {\\n                if (num % factor == 0) {\\n                    if (!map.containsKey(factor))\\n                        map.put(factor, i);\\n                    else\\n                        ds.unionBySize(i, map.get(factor));\\n\\n                    if (!map.containsKey(num / factor))\\n                        map.put(num / factor, i);\\n                    else \\n                        ds.unionBySize(i, map.get(num / factor));\\n                }\\n            }\\n\\n            if (!map.containsKey(num))\\n                map.put(num, i);\\n            else\\n                ds.unionBySize(i, map.get(num));\\n        }\\n\\n        int max = 1;\\n        int component[] = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            int root = ds.findUParent(i);\\n            component[root]++;\\n            max = Math.max(max, component[root]);\\n        }\\n\\n        return max;\\n    }\\n}\\nclass DisjointSet{\\n    List<Integer> rank=new ArrayList<>();\\n    List<Integer> parent=new ArrayList<>();\\n    List<Integer> size=new ArrayList<>();\\n    \\n    public DisjointSet(int n){\\n        for(int i=0;i<=n;i++){\\n            rank.add(0);\\n            parent.add(i);\\n            size.add(1);\\n        }\\n    }\\n    \\n    public int findUParent(int node){\\n        if(node == parent.get(node))\\n            return node;\\n        int ultPar=findUParent(parent.get(node));\\n        //Path Compression\\n        parent.set(node, ultPar);\\n        return parent.get(node);\\n    }\\n\\n    public void unionBySize(int u, int v){\\n        int ultPar_u=findUParent(u);\\n        int ultPar_v=findUParent(v);\\n        if(ultPar_u == ultPar_v)\\n            return;\\n        if(size.get(ultPar_u) < size.get(ultPar_v)){\\n            parent.set(ultPar_u, ultPar_v);\\n            size.set(ultPar_v,size.get(ultPar_v) + size.get(ultPar_u));\\n        }\\n        else{\\n            parent.set(ultPar_v , ultPar_u);\\n            size.set(ultPar_u,size.get(ultPar_v) + size.get(ultPar_u));\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722839,
                "title": "my-solutions",
                "content": "**1. Use the Disjoint Set `I`**\\n```\\nclass Solution {\\n private:\\n  class DisjointSet {\\n   public:\\n    DisjointSet(const int n) : parents_(n), groups_(n, 1), max_group_(1) {\\n      iota(parents_.begin(), parents_.end(), 0);\\n    }\\n    \\n    int find(const int i) {\\n      if (parents_[i] == i) {\\n        return i;\\n      }\\n      \\n      parents_[i] = find(parents_[i]);\\n      return parents_[i];\\n    }\\n    \\n    bool do_union(const int i, const int j) {\\n      const int parent_i = find(i);\\n      const int parent_j = find(j);\\n      if (parent_i == parent_j) {\\n        return false;\\n      }\\n      \\n      const int final_group = groups_[parent_i] + groups_[parent_j];\\n      max_group_ = max(max_group_, final_group);\\n      if (groups_[parent_i] < groups_[parent_j]) {\\n        parents_[parent_i] = parent_j;\\n        groups_[parent_j] = final_group;\\n        groups_[parent_i] = 0;\\n      } else {\\n        parents_[parent_j] = parent_i;\\n        groups_[parent_i] = final_group;\\n        groups_[parent_j] = 0;\\n      }\\n      return true;\\n    }\\n    \\n    int max_group() const {\\n      return max_group_;\\n    }\\n    \\n   private:\\n    vector<int> parents_;\\n    vector<int> groups_;\\n    int max_group_;\\n  };\\n  \\n public:\\n  int largestComponentSize(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    unordered_map<int, vector<int>> factor_to_indices;\\n    for (int i = 0; i < n; ++i) {\\n      int num = nums[i];\\n      if (num % 2 == 0) {\\n        factor_to_indices[2].emplace_back(i);\\n        for (; num % 2 == 0; num /= 2) {\\n        }\\n      }\\n      for (int factor = 3; factor * factor <= num; factor += 2) {\\n        if (num % factor == 0) {\\n          factor_to_indices[factor].emplace_back(i);\\n          for (; num % factor == 0; num /= factor) {\\n          }\\n        }\\n      }\\n      if (num > 1) {\\n        factor_to_indices[num].emplace_back(i);\\n      }\\n    }\\n    \\n    DisjointSet ds(n);\\n    for (const auto &[_, indices] : factor_to_indices) {\\n      for (size_t i = 1; i < indices.size(); ++i) {\\n        ds.do_union(indices.front(), indices[i]);\\n      }\\n    }\\n    return ds.max_group();\\n  }\\n};\\n```\\n**2. Use the Disjoint Set `II`**\\n```\\nclass Solution {\\n private:\\n  class DisjointSet {\\n   public:\\n    DisjointSet(const int n) : parents_(n), ranks_(n) {\\n      iota(parents_.begin(), parents_.end(), 0);\\n    }\\n    \\n    int find(const int i) {\\n      if (parents_[i] == i) {\\n        return i;\\n      }\\n      \\n      parents_[i] = find(parents_[i]);\\n      return parents_[i];\\n    }\\n    \\n    bool do_union(const int i, const int j) {\\n      const int parent_i = find(i);\\n      const int parent_j = find(j);\\n      if (parent_i == parent_j) {\\n        return false;\\n      }\\n      \\n      if (ranks_[parent_i] < ranks_[parent_j]) {\\n        parents_[parent_i] = parent_j;\\n      } else if (ranks_[parent_i] > ranks_[parent_j]) {\\n        parents_[parent_j] = parent_i;\\n      } else {\\n        parents_[parent_i] = parent_j;\\n        ++ranks_[parent_j];\\n      }\\n      return true;\\n    }\\n    \\n   private:\\n    vector<int> parents_;\\n    vector<int> ranks_;\\n  };\\n  \\n public:\\n  int largestComponentSize(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    const int max_num = *max_element(nums.begin(), nums.end());\\n    DisjointSet ds(max_num + 1);\\n    \\n    for (int i = 0; i < n; ++i) {\\n      int num = nums[i];\\n      if (num % 2 == 0) {\\n        ds.do_union(2, nums[i]);\\n        for (; num % 2 == 0; num /= 2) {\\n        }\\n      }\\n      for (int factor = 3; factor * factor <= num; factor += 2) {\\n        if (num % factor == 0) {\\n          ds.do_union(factor, nums[i]);\\n          for (; num % factor == 0; num /= factor) {\\n          }\\n        }\\n      }\\n      if (num > 1) {\\n        ds.do_union(num, nums[i]);\\n      }\\n    }\\n    \\n    int ret = 1;\\n    int parent_to_count[max_num + 1];\\n    memset(parent_to_count, 0, sizeof(parent_to_count));\\n    for (const int num : nums) {\\n      ret = max(ret, ++parent_to_count[ds.find(num)]);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n private:\\n  class DisjointSet {\\n   public:\\n    DisjointSet(const int n) : parents_(n), groups_(n, 1), max_group_(1) {\\n      iota(parents_.begin(), parents_.end(), 0);\\n    }\\n    \\n    int find(const int i) {\\n      if (parents_[i] == i) {\\n        return i;\\n      }\\n      \\n      parents_[i] = find(parents_[i]);\\n      return parents_[i];\\n    }\\n    \\n    bool do_union(const int i, const int j) {\\n      const int parent_i = find(i);\\n      const int parent_j = find(j);\\n      if (parent_i == parent_j) {\\n        return false;\\n      }\\n      \\n      const int final_group = groups_[parent_i] + groups_[parent_j];\\n      max_group_ = max(max_group_, final_group);\\n      if (groups_[parent_i] < groups_[parent_j]) {\\n        parents_[parent_i] = parent_j;\\n        groups_[parent_j] = final_group;\\n        groups_[parent_i] = 0;\\n      } else {\\n        parents_[parent_j] = parent_i;\\n        groups_[parent_i] = final_group;\\n        groups_[parent_j] = 0;\\n      }\\n      return true;\\n    }\\n    \\n    int max_group() const {\\n      return max_group_;\\n    }\\n    \\n   private:\\n    vector<int> parents_;\\n    vector<int> groups_;\\n    int max_group_;\\n  };\\n  \\n public:\\n  int largestComponentSize(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    unordered_map<int, vector<int>> factor_to_indices;\\n    for (int i = 0; i < n; ++i) {\\n      int num = nums[i];\\n      if (num % 2 == 0) {\\n        factor_to_indices[2].emplace_back(i);\\n        for (; num % 2 == 0; num /= 2) {\\n        }\\n      }\\n      for (int factor = 3; factor * factor <= num; factor += 2) {\\n        if (num % factor == 0) {\\n          factor_to_indices[factor].emplace_back(i);\\n          for (; num % factor == 0; num /= factor) {\\n          }\\n        }\\n      }\\n      if (num > 1) {\\n        factor_to_indices[num].emplace_back(i);\\n      }\\n    }\\n    \\n    DisjointSet ds(n);\\n    for (const auto &[_, indices] : factor_to_indices) {\\n      for (size_t i = 1; i < indices.size(); ++i) {\\n        ds.do_union(indices.front(), indices[i]);\\n      }\\n    }\\n    return ds.max_group();\\n  }\\n};\\n```\n```\\nclass Solution {\\n private:\\n  class DisjointSet {\\n   public:\\n    DisjointSet(const int n) : parents_(n), ranks_(n) {\\n      iota(parents_.begin(), parents_.end(), 0);\\n    }\\n    \\n    int find(const int i) {\\n      if (parents_[i] == i) {\\n        return i;\\n      }\\n      \\n      parents_[i] = find(parents_[i]);\\n      return parents_[i];\\n    }\\n    \\n    bool do_union(const int i, const int j) {\\n      const int parent_i = find(i);\\n      const int parent_j = find(j);\\n      if (parent_i == parent_j) {\\n        return false;\\n      }\\n      \\n      if (ranks_[parent_i] < ranks_[parent_j]) {\\n        parents_[parent_i] = parent_j;\\n      } else if (ranks_[parent_i] > ranks_[parent_j]) {\\n        parents_[parent_j] = parent_i;\\n      } else {\\n        parents_[parent_i] = parent_j;\\n        ++ranks_[parent_j];\\n      }\\n      return true;\\n    }\\n    \\n   private:\\n    vector<int> parents_;\\n    vector<int> ranks_;\\n  };\\n  \\n public:\\n  int largestComponentSize(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    const int max_num = *max_element(nums.begin(), nums.end());\\n    DisjointSet ds(max_num + 1);\\n    \\n    for (int i = 0; i < n; ++i) {\\n      int num = nums[i];\\n      if (num % 2 == 0) {\\n        ds.do_union(2, nums[i]);\\n        for (; num % 2 == 0; num /= 2) {\\n        }\\n      }\\n      for (int factor = 3; factor * factor <= num; factor += 2) {\\n        if (num % factor == 0) {\\n          ds.do_union(factor, nums[i]);\\n          for (; num % factor == 0; num /= factor) {\\n          }\\n        }\\n      }\\n      if (num > 1) {\\n        ds.do_union(num, nums[i]);\\n      }\\n    }\\n    \\n    int ret = 1;\\n    int parent_to_count[max_num + 1];\\n    memset(parent_to_count, 0, sizeof(parent_to_count));\\n    for (const int num : nums) {\\n      ret = max(ret, ++parent_to_count[ds.find(num)]);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701955,
                "title": "disjoint-set-factoring-sieve-beats-90-fairly-readable",
                "content": "# Intuition\\nThis solution is optimized under the assumption that the input numbers are not too large and we have a large count of numbers to process.  Under these conditions it is sensible to use a single persistent factoring sieve so that we can use the prime factorization of each input number.  We will represent components as sets of prime factors, and for each number merge together all of the sets that contain any prime factor of that number.\\n\\n# Approach\\nWe create a growable Sieve of Eratosthenes where each index in the sieve points to the smallest prime factor of that index. Also associated with the sieve is a vector of primes within the size of the sieve. The sieve provides facilities for prime factorization as well as calculating the prime counting function $$\\\\pi$$ so that primes can be mapped down tightly to contiguous array indices.\\n\\nWe also implement a disjoint set data structure, for which each subset can have a point of data associated with it. In our use case the point of data will be the number of items in the component.\\n\\nThe main loop of the algorithm consists of picking the next number `n`from `nums`, factoring it, and merging together all of the sets corresponding to prime factors of `n`.  During this process we sum up the sizes of all these sets, and finally add 1 more to represent the addition of `n` to the connected component\\n\\n# Complexity\\nLet `n = nums.size()`, and let `N` be the maximum number. Also, although it\\'s not quite accurate, our analysis assumes that disjoint set operations all take time O(1).  Note that the sieve is *static*, so in repeated use the sieve construction term falls off.\\n- Time complexity:\\nO(N(log log N) + nlog N)\\nThe sieve construction contributes the term N(log log N), and the main loop iterating over numbers and factoring them efficiently using the sieve contributes the term nlog N.\\n\\n- Space complexity:\\nO(N) for the sieve.\\n\\n# Code\\n```\\nclass GrowingSieve {\\npublic:\\n    GrowingSieve() {\\n        sieve.push_back(0);\\n        sieve.push_back(1);\\n        sieve.push_back(2);\\n        primes.push_back(2);\\n    }\\n\\n    int nextPrimeFactor(int n) {\\n        if (n < sieve.size()) {\\n            return sieve[n];\\n        }\\n        growSieve(n);\\n        return sieve[n];\\n    }\\n\\n    // This can be optimized considerably with good initial guesses.\\n    int pi(int n) {\\n        while (n > primes.back()) {\\n            growSieve(0);\\n        }\\n        auto bound = upper_bound(primes.begin(), primes.end(), n);\\n        return bound - primes.begin();\\n    }\\n\\nprivate:\\n    vector<int> sieve;\\n    vector<int> primes;\\n\\n    void growSieve(size_t n) {\\n\\n        n = max(2 * sieve.size(), n);\\n        int oldMaxN = sieve.size() - 1;\\n        sieve.reserve(n + 1);\\n        for (int i = sieve.size(); i <= n; i++) {\\n            sieve.push_back(i);\\n        }\\n\\n        for (int prime: primes) {\\n            int nextIndex = prime * (1 + oldMaxN / prime);\\n            for (int i = nextIndex; i <= n; i += prime) {\\n                sieve[i] = min(sieve[i], prime);\\n            }\\n        }\\n\\n        for (int i = oldMaxN + 1; i <= n; i++) {\\n            if (sieve[i] != i) { continue; }\\n            primes.push_back(i);\\n            for (int j = i; j <= n; j += i) {\\n                sieve[j] = min(sieve[j], i);\\n            }\\n        }\\n    }\\n};\\n\\nclass DisjointSet {\\npublic:\\n    DisjointSet(int count = 0) {\\n        grow(count - 1);\\n    }\\n\\n    void grow(int newMaxIndex) {\\n        int n = nodes.size();\\n        for (int i = n; i <= newMaxIndex; i++) {\\n            nodes.push_back(SetNode(i));\\n        }\\n    }\\n\\n    int merge(int node1, int node2) {\\n        int rep1i = representative(node1);\\n        int rep2i = representative(node2);\\n        if (rep1i == rep2i) { return -1; }\\n        SetNode& rep1 = nodes[rep1i];\\n        SetNode& rep2 = nodes[rep2i];\\n        if (rep1.size > rep2.size) {\\n            rep2.parent = rep1i;\\n            rep1.size = rep1.size + rep2.size + 1;\\n            return rep1i;\\n        } else {\\n            rep1.parent = rep2i;\\n            rep2.size = rep1.size + rep2.size + 1;\\n            return rep2i;\\n        }\\n    }\\n\\n    int representative(int node) {\\n        int root = node;\\n        while (root != nodes[root].parent) {\\n            root = nodes[root].parent;\\n        }\\n\\n        int fixer = node;\\n        while (fixer != root) {\\n            int nextFixer = nodes[fixer].parent;\\n            nodes[fixer].parent = root;\\n            fixer = nextFixer;\\n        }\\n\\n        return root;\\n    }\\n\\n    int data(int node) {\\n        return nodes[representative(node)].data;\\n    }\\n\\n    void setData(int node, int data) {\\n        nodes[representative(node)].data = data;\\n    }\\n\\nprivate:\\n    struct SetNode {\\n        SetNode(int id): parent(id), data(0), size(1) {}\\n        int data;\\n        int size;\\n        int parent;\\n    };\\n\\n    vector<SetNode> nodes;\\n};\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        DisjointSet factorSets(0);\\n        int maxSize = 1;\\n        for (int n: nums) {\\n            if (n == 1) { continue; }\\n            int lastPrime = sieve.nextPrimeFactor(n);\\n            int representativeIndex = sieve.pi(lastPrime);\\n            factorSets.grow(representativeIndex);\\n            representativeIndex = factorSets.representative(representativeIndex);\\n            n /= lastPrime;\\n            while (n > 1) {\\n                lastPrime = sieve.nextPrimeFactor(n);\\n                int representativeIndex2 = sieve.pi(lastPrime);\\n                factorSets.grow(representativeIndex2);\\n                representativeIndex2 = factorSets.representative(representativeIndex2);\\n                if (representativeIndex == representativeIndex2) { \\n                    n /= lastPrime;\\n                    continue;\\n                }\\n                int data1 = factorSets.data(representativeIndex);\\n                int data2 = factorSets.data(representativeIndex2);\\n                representativeIndex = factorSets.merge(representativeIndex, representativeIndex2);\\n                factorSets.setData(representativeIndex, data1 + data2);\\n                n /= lastPrime;\\n            }\\n            int size = factorSets.data(representativeIndex) + 1;\\n            factorSets.setData(representativeIndex, size);\\n            maxSize = max(maxSize, size);\\n        }\\n        return maxSize;\\n    }\\n\\nprivate:\\n    static GrowingSieve sieve;\\n};\\n\\nGrowingSieve Solution::sieve = GrowingSieve();\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Union Find",
                    "Number Theory"
                ],
                "code": "```\\nclass GrowingSieve {\\npublic:\\n    GrowingSieve() {\\n        sieve.push_back(0);\\n        sieve.push_back(1);\\n        sieve.push_back(2);\\n        primes.push_back(2);\\n    }\\n\\n    int nextPrimeFactor(int n) {\\n        if (n < sieve.size()) {\\n            return sieve[n];\\n        }\\n        growSieve(n);\\n        return sieve[n];\\n    }\\n\\n    // This can be optimized considerably with good initial guesses.\\n    int pi(int n) {\\n        while (n > primes.back()) {\\n            growSieve(0);\\n        }\\n        auto bound = upper_bound(primes.begin(), primes.end(), n);\\n        return bound - primes.begin();\\n    }\\n\\nprivate:\\n    vector<int> sieve;\\n    vector<int> primes;\\n\\n    void growSieve(size_t n) {\\n\\n        n = max(2 * sieve.size(), n);\\n        int oldMaxN = sieve.size() - 1;\\n        sieve.reserve(n + 1);\\n        for (int i = sieve.size(); i <= n; i++) {\\n            sieve.push_back(i);\\n        }\\n\\n        for (int prime: primes) {\\n            int nextIndex = prime * (1 + oldMaxN / prime);\\n            for (int i = nextIndex; i <= n; i += prime) {\\n                sieve[i] = min(sieve[i], prime);\\n            }\\n        }\\n\\n        for (int i = oldMaxN + 1; i <= n; i++) {\\n            if (sieve[i] != i) { continue; }\\n            primes.push_back(i);\\n            for (int j = i; j <= n; j += i) {\\n                sieve[j] = min(sieve[j], i);\\n            }\\n        }\\n    }\\n};\\n\\nclass DisjointSet {\\npublic:\\n    DisjointSet(int count = 0) {\\n        grow(count - 1);\\n    }\\n\\n    void grow(int newMaxIndex) {\\n        int n = nodes.size();\\n        for (int i = n; i <= newMaxIndex; i++) {\\n            nodes.push_back(SetNode(i));\\n        }\\n    }\\n\\n    int merge(int node1, int node2) {\\n        int rep1i = representative(node1);\\n        int rep2i = representative(node2);\\n        if (rep1i == rep2i) { return -1; }\\n        SetNode& rep1 = nodes[rep1i];\\n        SetNode& rep2 = nodes[rep2i];\\n        if (rep1.size > rep2.size) {\\n            rep2.parent = rep1i;\\n            rep1.size = rep1.size + rep2.size + 1;\\n            return rep1i;\\n        } else {\\n            rep1.parent = rep2i;\\n            rep2.size = rep1.size + rep2.size + 1;\\n            return rep2i;\\n        }\\n    }\\n\\n    int representative(int node) {\\n        int root = node;\\n        while (root != nodes[root].parent) {\\n            root = nodes[root].parent;\\n        }\\n\\n        int fixer = node;\\n        while (fixer != root) {\\n            int nextFixer = nodes[fixer].parent;\\n            nodes[fixer].parent = root;\\n            fixer = nextFixer;\\n        }\\n\\n        return root;\\n    }\\n\\n    int data(int node) {\\n        return nodes[representative(node)].data;\\n    }\\n\\n    void setData(int node, int data) {\\n        nodes[representative(node)].data = data;\\n    }\\n\\nprivate:\\n    struct SetNode {\\n        SetNode(int id): parent(id), data(0), size(1) {}\\n        int data;\\n        int size;\\n        int parent;\\n    };\\n\\n    vector<SetNode> nodes;\\n};\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        DisjointSet factorSets(0);\\n        int maxSize = 1;\\n        for (int n: nums) {\\n            if (n == 1) { continue; }\\n            int lastPrime = sieve.nextPrimeFactor(n);\\n            int representativeIndex = sieve.pi(lastPrime);\\n            factorSets.grow(representativeIndex);\\n            representativeIndex = factorSets.representative(representativeIndex);\\n            n /= lastPrime;\\n            while (n > 1) {\\n                lastPrime = sieve.nextPrimeFactor(n);\\n                int representativeIndex2 = sieve.pi(lastPrime);\\n                factorSets.grow(representativeIndex2);\\n                representativeIndex2 = factorSets.representative(representativeIndex2);\\n                if (representativeIndex == representativeIndex2) { \\n                    n /= lastPrime;\\n                    continue;\\n                }\\n                int data1 = factorSets.data(representativeIndex);\\n                int data2 = factorSets.data(representativeIndex2);\\n                representativeIndex = factorSets.merge(representativeIndex, representativeIndex2);\\n                factorSets.setData(representativeIndex, data1 + data2);\\n                n /= lastPrime;\\n            }\\n            int size = factorSets.data(representativeIndex) + 1;\\n            factorSets.setData(representativeIndex, size);\\n            maxSize = max(maxSize, size);\\n        }\\n        return maxSize;\\n    }\\n\\nprivate:\\n    static GrowingSieve sieve;\\n};\\n\\nGrowingSieve Solution::sieve = GrowingSieve();\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687683,
                "title": "ram",
                "content": "class Solution {\\n    public:\\n        \\n        class DSU\\n        {\\n        public:\\n            vector<int> par;\\n            vector<int> rank;\\n            \\n            vector<int> size;\\n            DSU(int n)\\n            {\\n                rank.resize(n,1);\\n                size.resize(n,1);\\n                for(int i=0;i<n;i++)\\n                    par.push_back(i);\\n            }\\n            \\n            int find(int x)\\n            {\\n                if(par[x]==x)\\n                    return x;\\n                return par[x]=find(par[x]);\\n            }\\n            \\n            bool merge(int x,int y)\\n            {\\n                int lx=find(x);\\n                int ly=find(y);\\n                \\n                if(lx==ly)\\n                    return false;\\n                if(rank[lx]>rank[ly])\\n                {\\n                    par[ly]=lx;\\n                    size[lx]+=size[ly];\\n                }\\n                else if(rank[ly]>rank[lx])\\n                {\\n                    par[lx]=ly;\\n                    size[ly]+=size[lx];\\n                }\\n                else\\n                {\\n                    par[ly]=lx;\\n                    size[lx]+=size[ly];\\n                    rank[lx]++;\\n                }\\n                return true;\\n            }\\n            \\n            int max_size()\\n            {\\n                int ans=0;\\n                for(int e:size)\\n                    ans=max(ans,e);\\n                return ans;\\n            }\\n        };\\n        \\n        int largestComponentSize(vector<int>& nums) \\n        {\\n            int n=nums.size();\\n            DSU d(n);\\n            \\n            map<int,int> mpp;\\n            int maxi=0;\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                maxi=max(maxi,nums[i]);\\n                mpp[nums[i]]=i;\\n            }\\n            \\n            vector<bool> space(maxi+1,true);\\n            \\n            for(int i=2;i<=maxi;i++)\\n            {\\n                int last=0;\\n                if(space[i]==true)\\n                {\\n                    int j=i;\\n                    while(j<=maxi)\\n                    {\\n                        space[j]=false;\\n                        if(mpp.count(j)>0)\\n                        {\\n                            if(last!=0)\\n                            {\\n                                d.merge(mpp[last],mpp[j]);\\n                            }\\n                            last=j;\\n                        }\\n                        space[j]=false;\\n                        j+=i;\\n                    }\\n                }\\n            }\\n            return d.max_size();\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        \\n        class DSU\\n        {\\n        public:\\n            vector<int> par;\\n            vector<int> rank;\\n            \\n            vector<int> size;\\n            DSU(int n)\\n            {\\n                rank.resize(n,1);\\n                size.resize(n,1);\\n                for(int i=0;i<n;i++)\\n                    par.push_back(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3669558,
                "title": "union-find-algorithm-graphs-python3",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n\\n        union_find = DisjointSetUnion(max(nums))\\n\\n        for num in nums:\\n            for i in range(2, int(sqrt(num)) + 1):\\n                if(num % i == 0):\\n                    union_find.union(num, i)\\n                    union_find.union(num, num // i)\\n        \\n        greatest_comp_size = 0\\n        comps = defaultdict(int)\\n        for num in nums:\\n            parent = union_find.find(num)\\n            comps[parent] += 1\\n            greatest_comp_size = max(greatest_comp_size, comps[parent])\\n        return greatest_comp_size\\n\\n\\nclass DisjointSetUnion:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n+1)]\\n        self.rank = [0] * (n+1)\\n    \\n    def find(self, x):\\n        if(self.parent[x] != x):\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        root_x = self.find(x)\\n        root_y = self.find(y)\\n\\n        if(root_x == root_y):\\n            return\\n        \\n        rank_x = self.rank[root_x]\\n        rank_y = self.rank[root_y]\\n\\n        if(rank_x > rank_y):\\n            self.parent[root_y] = root_x\\n        elif(rank_x < rank_y):\\n            self.parent[root_x] = root_y\\n        else:\\n            self.parent[root_y] = root_x\\n            self.rank[root_x] += 1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n\\n        union_find = DisjointSetUnion(max(nums))\\n\\n        for num in nums:\\n            for i in range(2, int(sqrt(num)) + 1):\\n                if(num % i == 0):\\n                    union_find.union(num, i)\\n                    union_find.union(num, num // i)\\n        \\n        greatest_comp_size = 0\\n        comps = defaultdict(int)\\n        for num in nums:\\n            parent = union_find.find(num)\\n            comps[parent] += 1\\n            greatest_comp_size = max(greatest_comp_size, comps[parent])\\n        return greatest_comp_size\\n\\n\\nclass DisjointSetUnion:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n+1)]\\n        self.rank = [0] * (n+1)\\n    \\n    def find(self, x):\\n        if(self.parent[x] != x):\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        root_x = self.find(x)\\n        root_y = self.find(y)\\n\\n        if(root_x == root_y):\\n            return\\n        \\n        rank_x = self.rank[root_x]\\n        rank_y = self.rank[root_y]\\n\\n        if(rank_x > rank_y):\\n            self.parent[root_y] = root_x\\n        elif(rank_x < rank_y):\\n            self.parent[root_x] = root_y\\n        else:\\n            self.parent[root_y] = root_x\\n            self.rank[root_x] += 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669556,
                "title": "union-find-algorithm-graphs-python3",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n\\n        union_find = DisjointSetUnion(max(nums))\\n\\n        for num in nums:\\n            for i in range(2, int(sqrt(num)) + 1):\\n                if(num % i == 0):\\n                    union_find.union(num, i)\\n                    union_find.union(num, num // i)\\n        \\n        greatest_comp_size = 0\\n        comps = defaultdict(int)\\n        for num in nums:\\n            parent = union_find.find(num)\\n            comps[parent] += 1\\n            greatest_comp_size = max(greatest_comp_size, comps[parent])\\n        return greatest_comp_size\\n\\n\\nclass DisjointSetUnion:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n+1)]\\n        self.rank = [0] * (n+1)\\n    \\n    def find(self, x):\\n        if(self.parent[x] != x):\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        root_x = self.find(x)\\n        root_y = self.find(y)\\n\\n        if(root_x == root_y):\\n            return\\n        \\n        rank_x = self.rank[root_x]\\n        rank_y = self.rank[root_y]\\n\\n        if(rank_x > rank_y):\\n            self.parent[root_y] = root_x\\n        elif(rank_x < rank_y):\\n            self.parent[root_x] = root_y\\n        else:\\n            self.parent[root_y] = root_x\\n            self.rank[root_x] += 1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n\\n        union_find = DisjointSetUnion(max(nums))\\n\\n        for num in nums:\\n            for i in range(2, int(sqrt(num)) + 1):\\n                if(num % i == 0):\\n                    union_find.union(num, i)\\n                    union_find.union(num, num // i)\\n        \\n        greatest_comp_size = 0\\n        comps = defaultdict(int)\\n        for num in nums:\\n            parent = union_find.find(num)\\n            comps[parent] += 1\\n            greatest_comp_size = max(greatest_comp_size, comps[parent])\\n        return greatest_comp_size\\n\\n\\nclass DisjointSetUnion:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n+1)]\\n        self.rank = [0] * (n+1)\\n    \\n    def find(self, x):\\n        if(self.parent[x] != x):\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        root_x = self.find(x)\\n        root_y = self.find(y)\\n\\n        if(root_x == root_y):\\n            return\\n        \\n        rank_x = self.rank[root_x]\\n        rank_y = self.rank[root_y]\\n\\n        if(rank_x > rank_y):\\n            self.parent[root_y] = root_x\\n        elif(rank_x < rank_y):\\n            self.parent[root_x] = root_y\\n        else:\\n            self.parent[root_y] = root_x\\n            self.rank[root_x] += 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661433,
                "title": "clear-solution-using-union-find-n-log-m-c",
                "content": "# Intuition\\nThe questions revolves around finding the maximum length of a connected component in a graph. Thus, we should naturally think in direction of **Union Find** Incase you can\\'t figure this out I think you should do some related graph questions before jumping here!\\n\\n# Approach\\nWe know that nums[i] and nums[j] for any i != j  share an edge if both have any common factor greater than 1. \\n\\nSo we can do prime factorisation of all the number and maintain a  {prime , vector of nums} map. Now we will union all the num within mapped to a single prime number as they can be grouped in one connected component. \\n\\nEg : nums: { 4,6,15,35} then map will contain \\n{\\n{2: {4,6}},\\n{3: {6,15}},\\n{5: {15,35}},\\n{7: {35} }\\n}\\n\\nNow we will union all the number within a vector mapped to a prime number. \\nFor 2 we will union 4,6. Similarly we will union 6,15 for prime = 3. And so on.\\n\\nNow our DSU will have one connected component of size 4. Thus we will return 4. In this case we have only one connected component. Try with different numbers!\\n\\nAtlast we will find the maximum size among all the components.\\n\\n# Complexity\\n- Time complexity:\\nConsidering the Union-Find to be constant we have N * sqrt(M) where M is max element in the array.\\n\\n- Space complexity:\\nO(M) where M is max element in array.\\n\\n# Code\\n```\\n struct dsu{\\n     \\n      vector <int> par,size;\\n  \\n     dsu(int n) {\\n      \\n         par.resize(n);\\n         size.resize(n,1);\\n        for (int i=0;i<n;i++) {\\n             par[i]=i;\\n           \\n         }\\n     }\\n     \\n     int find(int x)  {\\n         if (par[x]==x) {return x;}\\n         return par[x]=find(par[x]);\\n     }\\n   \\n     void _union(int x,int y)  {\\n         x=find(x);y=find(y);\\n         if (x!=y) {\\n           // add subtree with larger parent to subtree with smaller parent and update the size\\n            if (x < y) {\\n    par[y]=x;\\n             size[x]+=size[y];size[y]=0;\\n            }\\n            else {\\n                    par[x]=y;\\n             size[y]+=size[x];\\n             size[x]=0;\\n            }\\n         \\n          \\n         }\\n     }\\n     \\n };\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        unordered_map < int , set <int> > mp;\\n    int mx=0;\\n        for (auto i:nums) {\\n         int n=i;mx=max(n,mx);\\n               while (i%2 == 0) {\\n                   i=i/2;\\n                   mp[2].insert(n);\\n               }\\n\\n               for (int j=3;j*j<=i;j++) {\\n                  while (i%j==0) {\\n                       mp[j].insert(n);\\n                       i=i/j;\\n                   }\\n               }\\n\\n               if (i>1) {\\n                   mp[i].insert(n);\\n               }\\n        }\\n     dsu mydsu(mx+1);\\n        for (auto &i:mp) {\\n             int fr=  *((i.second).begin());\\n            for (auto &num:i.second) {\\n                mydsu._union(fr,num);\\n         \\n            }\\n        }\\n\\n        int ans=1;\\n        for (int i=0;i<(mx+1);i++) {\\n            ans=max(ans , mydsu.size[i]);\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\n struct dsu{\\n     \\n      vector <int> par,size;\\n  \\n     dsu(int n) {\\n      \\n         par.resize(n);\\n         size.resize(n,1);\\n        for (int i=0;i<n;i++) {\\n             par[i]=i;\\n           \\n         }\\n     }\\n     \\n     int find(int x)  {\\n         if (par[x]==x) {return x;}\\n         return par[x]=find(par[x]);\\n     }\\n   \\n     void _union(int x,int y)  {\\n         x=find(x);y=find(y);\\n         if (x!=y) {\\n           // add subtree with larger parent to subtree with smaller parent and update the size\\n            if (x < y) {\\n    par[y]=x;\\n             size[x]+=size[y];size[y]=0;\\n            }\\n            else {\\n                    par[x]=y;\\n             size[y]+=size[x];\\n             size[x]=0;\\n            }\\n         \\n          \\n         }\\n     }\\n     \\n };\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        unordered_map < int , set <int> > mp;\\n    int mx=0;\\n        for (auto i:nums) {\\n         int n=i;mx=max(n,mx);\\n               while (i%2 == 0) {\\n                   i=i/2;\\n                   mp[2].insert(n);\\n               }\\n\\n               for (int j=3;j*j<=i;j++) {\\n                  while (i%j==0) {\\n                       mp[j].insert(n);\\n                       i=i/j;\\n                   }\\n               }\\n\\n               if (i>1) {\\n                   mp[i].insert(n);\\n               }\\n        }\\n     dsu mydsu(mx+1);\\n        for (auto &i:mp) {\\n             int fr=  *((i.second).begin());\\n            for (auto &num:i.second) {\\n                mydsu._union(fr,num);\\n         \\n            }\\n        }\\n\\n        int ans=1;\\n        for (int i=0;i<(mx+1);i++) {\\n            ans=max(ans , mydsu.size[i]);\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647459,
                "title": "approach-explained-largest-component-size-using-dsu-easy-to-understand",
                "content": "# Code\\n```\\nclass DisjointSet{\\npublic:\\n    vector<int>rank,size,parent;\\n\\n    DisjointSet(int n){\\n        rank.resize(n+1,0);\\n        size.resize(n+1,1);\\n        parent.resize(n+1);\\n\\n        //Initially,every node is a prent of itself \\n        for(int i=0;i<=n;i++){\\n            parent[i]=i;\\n        }\\n    }\\n\\n    //FIND ULTIMATE PARENT\\n    int findUltimatePrent(int node){\\n            return node==parent[node]?node:parent[node]=findUltimatePrent(parent[node]) ;\\n    }\\n\\n    //UNION BY RANK\\n    void UnionByRank(int u,int v){\\n        int ulp_u = findUltimatePrent(u);\\n        int ulp_v = findUltimatePrent(v);\\n\\n        //4 case \\n\\n        //case 1 :- SAME COMPONENT THAN RETURN \\n        if(ulp_u==ulp_v) return;\\n\\n        //case 2 :- rank[ulp_u] < ranl[ulp_v] \\n        //smaller get connected to larger and parent of smaller updated to larger one\\n        if(rank[ulp_u]<rank[ulp_v]){\\n            parent[ulp_u]=ulp_v;\\n        }\\n\\n         //case 3 :- rank[ulp_u] < ranl[ulp_v] \\n        //smaller get connected to larger and parent of smaller updated to larger one\\n        if(rank[ulp_u]>rank[ulp_v]){\\n            parent[ulp_v]=ulp_u;\\n        }\\n\\n         //case 4 :- rank[ulp_u] == ranl[ulp_v] \\n        //anyone get connected to other one and parent of node getting connected updated\\n        if(rank[ulp_u]==rank[ulp_v]){\\n            parent[ulp_u]=ulp_v; // ulp_u connected to ulp_v\\n            rank[ulp_v]++;// since connected to ulp_v its rank increased\\n        }\\n    }\\n    void UnionBySize(int u,int v){\\n        int ulp_u = findUltimatePrent(u);\\n        int ulp_v = findUltimatePrent(v);\\n\\n        //4 cases \\n\\n        //case 1:- SAME COMPONENT THAN RETURN \\n        if(ulp_u == ulp_v) return;\\n\\n        //case 2: -NOT BELONGING TO SAME COMPONENT \\n         //smaller get connected to larger and parent of smaller updated to larger one\\n         //and size of larger one updated by including size of smaller one\\n        if(size[ulp_u]<size[ulp_v]){\\n            parent[ulp_u]=ulp_v;\\n            size[ulp_v]+=size[ulp_u];\\n        }\\n\\n         //case 3: -NOT BELONGING TO SAME COMPONENT \\n         //smaller get connected to larger and parent of smaller updated to larger one\\n         //and size of larger one updated by including size of smaller one\\n        if(size[ulp_u]>size[ulp_v]){\\n            parent[ulp_v]=ulp_u;\\n            size[ulp_u]+=size[ulp_v];\\n        }\\n\\n         //case 4: -NOT BELONGING TO SAME COMPONENT \\n         //anyone get connected to other node and parent of node getting connected\\n         // is updated to one from whom connected\\n         //and size of node from whom connected is updated by including \\n         //size of node getting connected\\n        if(size[ulp_u]==size[ulp_v]){\\n            parent[ulp_u]=ulp_v; // ulp_u connected to ulp_v\\n            size[ulp_v]+=size[ulp_u]; // size of ulp_v increased by size of ulp_u\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        //2709. Greatest Common Divisor Traversal -> same concept question\\n        \\n        //Time Complexity : O(N * log(max(num)))  \\n        // USE PRIME FACTORIZATION \\n        // STORE EVERY INDEX AS A FACTOR FOR A PRIME NO \\n        //EX. 2-> POSITION WHERE 2 ARE FACTOR OF A NUMBER \\n        // 3 -> , 5-> ...SO ON \\n        //THAN, USE DSU AND MAKE COMPONENT USING INDEX \\n       //THAN, FIND LARGEST SIZE OF A COMPONENT \\n\\n       map<int,vector<int>>factor; \\n       int n = nums.size();\\n       for(int i=0;i<n;i++){\\n           for(int j=2;j*j<=nums[i];j++){\\n               if(nums[i]%j==0){\\n                   //CONTRIBUTION OF PRIME NO AT WHICH INDEX AS FACTOR ARE STORED\\n                   factor[j].push_back(i);\\n                   //ex:- 100%2=0 -> 100/2=50%2 =0 -> 50/2 = 25 -> now,stop\\n                  //  and search for other prime factor\\n                   while(nums[i]%j==0) nums[i]/=j; \\n               }\\n           }\\n           //ex:- 6 -> 6%2=0 -> 6/2=3 \\n           //now,since 3*3=9>6 therefore out of loop \\n           //but,still 3 left to see and store position \\n           if(nums[i]>1) factor[nums[i]].push_back(i) ; \\n       }\\n       \\n       //NOW, APPLY UNION LOGIC\\n       DisjointSet ds(n);\\n       for(auto&it:factor){\\n           vector<int>prime_pos = it.second;\\n           //DO UNION \\n           for(int i=0;i<prime_pos.size()-1;i++){\\n               ds.UnionBySize(prime_pos[i],prime_pos[i+1]);\\n           }\\n       }\\n\\n       //NOW,SEE FOR LARGEST COMPONENT SIZE \\n       int LargestComponent = 0 ;\\n       for(int i=0;i<n;i++){\\n        //   cout<<ds.size[i]<<\" \";\\n           LargestComponent=max(LargestComponent,ds.size[i]);\\n       }\\n       return LargestComponent;\\n    }\\n};\\n```\\n\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet{\\npublic:\\n    vector<int>rank,size,parent;\\n\\n    DisjointSet(int n){\\n        rank.resize(n+1,0);\\n        size.resize(n+1,1);\\n        parent.resize(n+1);\\n\\n        //Initially,every node is a prent of itself \\n        for(int i=0;i<=n;i++){\\n            parent[i]=i;\\n        }\\n    }\\n\\n    //FIND ULTIMATE PARENT\\n    int findUltimatePrent(int node){\\n            return node==parent[node]?node:parent[node]=findUltimatePrent(parent[node]) ;\\n    }\\n\\n    //UNION BY RANK\\n    void UnionByRank(int u,int v){\\n        int ulp_u = findUltimatePrent(u);\\n        int ulp_v = findUltimatePrent(v);\\n\\n        //4 case \\n\\n        //case 1 :- SAME COMPONENT THAN RETURN \\n        if(ulp_u==ulp_v) return;\\n\\n        //case 2 :- rank[ulp_u] < ranl[ulp_v] \\n        //smaller get connected to larger and parent of smaller updated to larger one\\n        if(rank[ulp_u]<rank[ulp_v]){\\n            parent[ulp_u]=ulp_v;\\n        }\\n\\n         //case 3 :- rank[ulp_u] < ranl[ulp_v] \\n        //smaller get connected to larger and parent of smaller updated to larger one\\n        if(rank[ulp_u]>rank[ulp_v]){\\n            parent[ulp_v]=ulp_u;\\n        }\\n\\n         //case 4 :- rank[ulp_u] == ranl[ulp_v] \\n        //anyone get connected to other one and parent of node getting connected updated\\n        if(rank[ulp_u]==rank[ulp_v]){\\n            parent[ulp_u]=ulp_v; // ulp_u connected to ulp_v\\n            rank[ulp_v]++;// since connected to ulp_v its rank increased\\n        }\\n    }\\n    void UnionBySize(int u,int v){\\n        int ulp_u = findUltimatePrent(u);\\n        int ulp_v = findUltimatePrent(v);\\n\\n        //4 cases \\n\\n        //case 1:- SAME COMPONENT THAN RETURN \\n        if(ulp_u == ulp_v) return;\\n\\n        //case 2: -NOT BELONGING TO SAME COMPONENT \\n         //smaller get connected to larger and parent of smaller updated to larger one\\n         //and size of larger one updated by including size of smaller one\\n        if(size[ulp_u]<size[ulp_v]){\\n            parent[ulp_u]=ulp_v;\\n            size[ulp_v]+=size[ulp_u];\\n        }\\n\\n         //case 3: -NOT BELONGING TO SAME COMPONENT \\n         //smaller get connected to larger and parent of smaller updated to larger one\\n         //and size of larger one updated by including size of smaller one\\n        if(size[ulp_u]>size[ulp_v]){\\n            parent[ulp_v]=ulp_u;\\n            size[ulp_u]+=size[ulp_v];\\n        }\\n\\n         //case 4: -NOT BELONGING TO SAME COMPONENT \\n         //anyone get connected to other node and parent of node getting connected\\n         // is updated to one from whom connected\\n         //and size of node from whom connected is updated by including \\n         //size of node getting connected\\n        if(size[ulp_u]==size[ulp_v]){\\n            parent[ulp_u]=ulp_v; // ulp_u connected to ulp_v\\n            size[ulp_v]+=size[ulp_u]; // size of ulp_v increased by size of ulp_u\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        //2709. Greatest Common Divisor Traversal -> same concept question\\n        \\n        //Time Complexity : O(N * log(max(num)))  \\n        // USE PRIME FACTORIZATION \\n        // STORE EVERY INDEX AS A FACTOR FOR A PRIME NO \\n        //EX. 2-> POSITION WHERE 2 ARE FACTOR OF A NUMBER \\n        // 3 -> , 5-> ...SO ON \\n        //THAN, USE DSU AND MAKE COMPONENT USING INDEX \\n       //THAN, FIND LARGEST SIZE OF A COMPONENT \\n\\n       map<int,vector<int>>factor; \\n       int n = nums.size();\\n       for(int i=0;i<n;i++){\\n           for(int j=2;j*j<=nums[i];j++){\\n               if(nums[i]%j==0){\\n                   //CONTRIBUTION OF PRIME NO AT WHICH INDEX AS FACTOR ARE STORED\\n                   factor[j].push_back(i);\\n                   //ex:- 100%2=0 -> 100/2=50%2 =0 -> 50/2 = 25 -> now,stop\\n                  //  and search for other prime factor\\n                   while(nums[i]%j==0) nums[i]/=j; \\n               }\\n           }\\n           //ex:- 6 -> 6%2=0 -> 6/2=3 \\n           //now,since 3*3=9>6 therefore out of loop \\n           //but,still 3 left to see and store position \\n           if(nums[i]>1) factor[nums[i]].push_back(i) ; \\n       }\\n       \\n       //NOW, APPLY UNION LOGIC\\n       DisjointSet ds(n);\\n       for(auto&it:factor){\\n           vector<int>prime_pos = it.second;\\n           //DO UNION \\n           for(int i=0;i<prime_pos.size()-1;i++){\\n               ds.UnionBySize(prime_pos[i],prime_pos[i+1]);\\n           }\\n       }\\n\\n       //NOW,SEE FOR LARGEST COMPONENT SIZE \\n       int LargestComponent = 0 ;\\n       for(int i=0;i<n;i++){\\n        //   cout<<ds.size[i]<<\" \";\\n           LargestComponent=max(LargestComponent,ds.size[i]);\\n       }\\n       return LargestComponent;\\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3646459,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUnion find \\n\\n# Complexity \\n- Time complexity: O(n * sqrt(m)), where m = max(nums)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def largestComponentSize(nums: Array[Int]): Int = {\\n\\n      val uf = UnionFind(100001)\\n      for (n <- nums) {\\n        var i = 2\\n        while (i * i <= n) {\\n          if (n % i == 0) {\\n            uf.union(n, i)\\n            uf.union(n, n / i)\\n          }\\n          i += 1\\n        }\\n      }\\n      val map = collection.mutable.Map[Int, Int]()\\n      var max = 1\\n      for (n <- nums) {\\n        val root = uf.find(n)\\n        val count = map.getOrElse(root, 0) + 1\\n        map(root) = count\\n        max = math.max(max, count)\\n      }\\n      max\\n    }\\n  }\\n\\n  case class UnionFind(n: Int) {\\n    private val parent = Array.tabulate(n)(identity)\\n    private val size = Array.fill(n)(1)\\n\\n    def find(x: Int): Int = {\\n      if (parent(x) != x) parent(x) = find(parent(x))\\n      parent(x)\\n    }\\n\\n    def union(x: Int, y: Int): Unit = {\\n      val (rootX, rootY) = (find(x), find(y))\\n      if (rootX != rootY) {\\n        if (size(rootX) < size(rootY)) {\\n          parent(rootX) = rootY\\n          size(rootY) += size(rootX)\\n        } else {\\n          parent(rootY) = rootX\\n          size(rootX) += size(rootY)\\n        }\\n      }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def largestComponentSize(nums: Array[Int]): Int = {\\n\\n      val uf = UnionFind(100001)\\n      for (n <- nums) {\\n        var i = 2\\n        while (i * i <= n) {\\n          if (n % i == 0) {\\n            uf.union(n, i)\\n            uf.union(n, n / i)\\n          }\\n          i += 1\\n        }\\n      }\\n      val map = collection.mutable.Map[Int, Int]()\\n      var max = 1\\n      for (n <- nums) {\\n        val root = uf.find(n)\\n        val count = map.getOrElse(root, 0) + 1\\n        map(root) = count\\n        max = math.max(max, count)\\n      }\\n      max\\n    }\\n  }\\n\\n  case class UnionFind(n: Int) {\\n    private val parent = Array.tabulate(n)(identity)\\n    private val size = Array.fill(n)(1)\\n\\n    def find(x: Int): Int = {\\n      if (parent(x) != x) parent(x) = find(parent(x))\\n      parent(x)\\n    }\\n\\n    def union(x: Int, y: Int): Unit = {\\n      val (rootX, rootY) = (find(x), find(y))\\n      if (rootX != rootY) {\\n        if (size(rootX) < size(rootY)) {\\n          parent(rootX) = rootY\\n          size(rootY) += size(rootX)\\n        } else {\\n          parent(rootY) = rootX\\n          size(rootX) += size(rootY)\\n        }\\n      }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586078,
                "title": "17-lines",
                "content": "```ruby\\nrequire \\'prime\\'\\n\\n@m = {}\\n\\ndef largest_component_size a\\n    p, c = Hash.new { _1[_2] = _2 }, Hash.new(0)\\n    f = -> x { p[x] == x ? x : (p[x] = f.(p[x])) }\\n    a.each { c[_1] = 1 }\\n    a.each do | a |\\n        (@m[a] ||= a.prime_division).each do | b, _ |\\n            next if (ra = f.(a)) == (rb = f.(b))\\n            ra, rb = rb, ra if c[ra] < c[rb]\\n            p[rb] = ra; c[ra] += c[rb]\\n        end\\n    end\\n    c.each_value.max\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nrequire \\'prime\\'\\n\\n@m = {}\\n\\ndef largest_component_size a\\n    p, c = Hash.new { _1[_2] = _2 }, Hash.new(0)\\n    f = -> x { p[x] == x ? x : (p[x] = f.(p[x])) }\\n    a.each { c[_1] = 1 }\\n    a.each do | a |\\n        (@m[a] ||= a.prime_division).each do | b, _ |\\n            next if (ra = f.(a)) == (rb = f.(b))\\n            ra, rb = rb, ra if c[ra] < c[rb]\\n            p[rb] = ra; c[ra] += c[rb]\\n        end\\n    end\\n    c.each_value.max\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3572255,
                "title": "c-dsu",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet {\\npublic:\\n    vector<int> parent, size;\\n\\n    DisjointSet(int n) {\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n   \\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int size = *max_element(nums.begin(), nums.end());\\n        DisjointSet ds(size+1);\\n\\n        for(int i=0; i<nums.size(); ++i){\\n            for(int j=2; j<=sqrt(nums[i]); ++j){\\n                if(nums[i]%j==0){\\n                    ds.unionBySize(nums[i], j);\\n                    ds.unionBySize(nums[i]/j, j);\\n                }\\n            }\\n        }\\n        \\n        map<int,int> k;\\n        int maxnodeconnected=0;\\n        for(auto it: nums){\\n            int p=ds.findUPar(it);\\n            k[p]++;\\n            maxnodeconnected=max(k[p],maxnodeconnected);\\n        }\\n        return maxnodeconnected;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DisjointSet {\\npublic:\\n    vector<int> parent, size;\\n\\n    DisjointSet(int n) {\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n   \\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int size = *max_element(nums.begin(), nums.end());\\n        DisjointSet ds(size+1);\\n\\n        for(int i=0; i<nums.size(); ++i){\\n            for(int j=2; j<=sqrt(nums[i]); ++j){\\n                if(nums[i]%j==0){\\n                    ds.unionBySize(nums[i], j);\\n                    ds.unionBySize(nums[i]/j, j);\\n                }\\n            }\\n        }\\n        \\n        map<int,int> k;\\n        int maxnodeconnected=0;\\n        for(auto it: nums){\\n            int p=ds.findUPar(it);\\n            k[p]++;\\n            maxnodeconnected=max(k[p],maxnodeconnected);\\n        }\\n        return maxnodeconnected;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554094,
                "title": "ruby-union-find-solution",
                "content": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\nrequire \\'prime\\'\\n\\nclass UnionFindTree\\n  def initialize(n)\\n    @parent = (0...n).to_a\\n    @rank = [0] * n\\n  end\\n\\n  def unite(a, b)\\n    root_a, root_b = root(a), root(b)\\n    return if root_a == root_b\\n    if @rank[root_a] < @rank[root_b]\\n      @parent[root_a] = root_b\\n    else\\n      @parent[root_b] = root_a\\n      @rank[root_a] += 1 if @rank[root_a] == @rank[root_b]\\n    end\\n  end\\n\\n  def root(a)\\n    return a if @parent[a] == a\\n    @parent[a] = root(@parent[a])\\n  end\\nend\\n\\ndef largest_component_size(nums)\\n  union_find_tree = UnionFindTree.new(nums.max+1)\\n  nums.each {|num|\\n    Prime.prime_division(num).each {|prime, _|\\n      union_find_tree.unite(prime, num)\\n    }\\n  }\\n  max = 0\\n  counts = Hash.new(0)\\n  nums.each {|num|\\n    max = [max, counts[union_find_tree.root(num)] += 1].max\\n  }\\n  max\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\nrequire \\'prime\\'\\n\\nclass UnionFindTree\\n  def initialize(n)\\n    @parent = (0...n).to_a\\n    @rank = [0] * n\\n  end\\n\\n  def unite(a, b)\\n    root_a, root_b = root(a), root(b)\\n    return if root_a == root_b\\n    if @rank[root_a] < @rank[root_b]\\n      @parent[root_a] = root_b\\n    else\\n      @parent[root_b] = root_a\\n      @rank[root_a] += 1 if @rank[root_a] == @rank[root_b]\\n    end\\n  end\\n\\n  def root(a)\\n    return a if @parent[a] == a\\n    @parent[a] = root(@parent[a])\\n  end\\nend\\n\\ndef largest_component_size(nums)\\n  union_find_tree = UnionFindTree.new(nums.max+1)\\n  nums.each {|num|\\n    Prime.prime_division(num).each {|prime, _|\\n      union_find_tree.unite(prime, num)\\n    }\\n  }\\n  max = 0\\n  counts = Hash.new(0)\\n  nums.each {|num|\\n    max = [max, counts[union_find_tree.root(num)] += 1].max\\n  }\\n  max\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509720,
                "title": "dsu-approch-c",
                "content": "\\n# Code\\n```\\nclass UnionFind {\\npublic:\\n    UnionFind(int sz) : root(sz+1), rank(sz+1) {\\n        for (int i = 0; i < sz+1; i++) {\\n            root[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n\\n    int find(int x) {\\n        if (x == root[x]) {\\n            return x;\\n        }\\n        return root[x] = find(root[x]);\\n    }\\n\\n    int unionSet(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if (rootX != rootY) {\\n            if (rank[rootX] > rank[rootY]) {\\n                root[rootY] = rootX;\\n            } else if (rank[rootX] < rank[rootY]) {\\n                root[rootX] = rootY;\\n            } else {\\n                root[rootY] = rootX;\\n                rank[rootX] += 1;\\n            }\\n        }\\n    return rootY;\\n    }\\n\\n    bool connected(int x, int y) {\\n        return find(x) == find(y);\\n    }\\n\\nprivate:\\n    vector<int> root;\\n    vector<int> rank;\\n};\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n      int maxValue = *max_element(nums.begin(),nums.end());\\n      UnionFind dsu(maxValue);\\n      for (int num:nums){\\n          for(int factor=2;factor<int(sqrt(num))+1;factor++) {\\n             // cout<<factor<<\" \";\\n              if(num%factor==0){\\n                  \\n                  dsu.unionSet(num,factor);\\n                  dsu.unionSet(num,int(num/factor));\\n              }\\n          }\\n\\n      }\\n      int maxG=0;\\n      unordered_map<int,int>gc;\\n      for(auto num:nums){\\n          int gid=dsu.find(num);\\n          int count=0;\\n          if(gc.find(gid)!=gc.end())\\n             count=gc[gid];\\n          gc[gid]++;\\n          maxG=max(maxG,count+1);\\n      }\\n     return maxG;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass UnionFind {\\npublic:\\n    UnionFind(int sz) : root(sz+1), rank(sz+1) {\\n        for (int i = 0; i < sz+1; i++) {\\n            root[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n\\n    int find(int x) {\\n        if (x == root[x]) {\\n            return x;\\n        }\\n        return root[x] = find(root[x]);\\n    }\\n\\n    int unionSet(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if (rootX != rootY) {\\n            if (rank[rootX] > rank[rootY]) {\\n                root[rootY] = rootX;\\n            } else if (rank[rootX] < rank[rootY]) {\\n                root[rootX] = rootY;\\n            } else {\\n                root[rootY] = rootX;\\n                rank[rootX] += 1;\\n            }\\n        }\\n    return rootY;\\n    }\\n\\n    bool connected(int x, int y) {\\n        return find(x) == find(y);\\n    }\\n\\nprivate:\\n    vector<int> root;\\n    vector<int> rank;\\n};\\n\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n      int maxValue = *max_element(nums.begin(),nums.end());\\n      UnionFind dsu(maxValue);\\n      for (int num:nums){\\n          for(int factor=2;factor<int(sqrt(num))+1;factor++) {\\n             // cout<<factor<<\" \";\\n              if(num%factor==0){\\n                  \\n                  dsu.unionSet(num,factor);\\n                  dsu.unionSet(num,int(num/factor));\\n              }\\n          }\\n\\n      }\\n      int maxG=0;\\n      unordered_map<int,int>gc;\\n      for(auto num:nums){\\n          int gid=dsu.find(num);\\n          int count=0;\\n          if(gc.find(gid)!=gc.end())\\n             count=gc[gid];\\n          gc[gid]++;\\n          maxG=max(maxG,count+1);\\n      }\\n     return maxG;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3477991,
                "title": "c-bfs-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a undirected graph using prime factors then count the largest connected component.\\n\\nNote: we only need to count those nodes which were there in the original list.\\n# Complexity\\n M: max digit\\n- Time complexity: O(N * sqrt(M))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N + M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> adj;\\n    void connect(int n){\\n        int val = n;\\n        bool canAdd = true;\\n        while(n % 2 == 0){\\n            if(canAdd){\\n                adj[2].push_back(val);\\n                adj[val].push_back(2);\\n                canAdd = false;\\n            }\\n            \\n            n = n / 2;\\n        }\\n        for(int i = 3; i * i <= n; i+=2){\\n            canAdd = true;\\n            while(n % i == 0){\\n                if(canAdd){\\n                    adj[i].push_back(val);\\n                    adj[val].push_back(i);\\n                    canAdd = false;\\n                }\\n                n = n / i;\\n            }\\n        }\\n        if(n > 2){\\n            adj[n].push_back(val);\\n            adj[val].push_back(n);\\n        }\\n    }\\n    int largestComponentSize(vector<int>& A) {\\n        unordered_set<int> visited, original;\\n        for(int &x: A)  connect(x), original.insert(x);\\n        int ans = 0;\\n        for(int &x: A){\\n            if(visited.count(x))    continue;\\n            int count = 0;\\n            queue<int> q;\\n            q.push(x);\\n            while(!q.empty()){\\n                int temp = q.front();\\n                q.pop();\\n                if(visited.count(temp)) continue;\\n                if(original.count(temp))    count++;\\n                visited.insert(temp);\\n                for(auto &v: adj[temp]) q.push(v);\\n            }\\n            ans = max(ans, count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> adj;\\n    void connect(int n){\\n        int val = n;\\n        bool canAdd = true;\\n        while(n % 2 == 0){\\n            if(canAdd){\\n                adj[2].push_back(val);\\n                adj[val].push_back(2);\\n                canAdd = false;\\n            }\\n            \\n            n = n / 2;\\n        }\\n        for(int i = 3; i * i <= n; i+=2){\\n            canAdd = true;\\n            while(n % i == 0){\\n                if(canAdd){\\n                    adj[i].push_back(val);\\n                    adj[val].push_back(i);\\n                    canAdd = false;\\n                }\\n                n = n / i;\\n            }\\n        }\\n        if(n > 2){\\n            adj[n].push_back(val);\\n            adj[val].push_back(n);\\n        }\\n    }\\n    int largestComponentSize(vector<int>& A) {\\n        unordered_set<int> visited, original;\\n        for(int &x: A)  connect(x), original.insert(x);\\n        int ans = 0;\\n        for(int &x: A){\\n            if(visited.count(x))    continue;\\n            int count = 0;\\n            queue<int> q;\\n            q.push(x);\\n            while(!q.empty()){\\n                int temp = q.front();\\n                q.pop();\\n                if(visited.count(temp)) continue;\\n                if(original.count(temp))    count++;\\n                visited.insert(temp);\\n                for(auto &v: adj[temp]) q.push(v);\\n            }\\n            ans = max(ans, count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477140,
                "title": "brute-ac-c-connect-the-factors-of-the-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n# brute force tle\\n**<!-- Describe your approach to solving the problem. -->\\n\\nclass disjointset{\\n    public:\\n    vector<int>parent,size;\\n    disjointset(int n){\\n        parent.resize(n+1);\\n        for(int i=0;i<=n;i++)parent[i]=i;\\n        size.resize(n+1,1);\\n    }\\n    int findp(int u){\\n        if(parent[u]==u)return u;\\n        return parent[u]=findp(parent[u]);\\n\\n    }\\n    void unionbysize(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return ;\\n        if(size[ult_u]<=size[ult_v]){\\n            parent[ult_u]=ult_v;\\n            size[ult_v]+=size[ult_u];\\n\\n        }\\n        else{\\n            parent[ult_v]=ult_u;\\n            size[ult_u]+=size[ult_v];\\n        }\\n        \\n    }\\n};\\nclass Solution {\\npublic:\\n    int gcd(int a, int b) {\\n\\tfor(int i=min(a,b);i>1;i--){\\n        if(a%i==0&&b%i==0)\\nreturn 5;\\n    }\\n    return 0;\\n}\\n    int largestComponentSize(vector<int>& nums) {\\n        int maxi=-1e9;\\n        disjointset ds(*max_element(nums.begin(),nums.end()));\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(gcd(nums[i],nums[j])>1){\\n                    ds.unionbysize(nums[i],nums[j]);\\n                    maxi=max(maxi,ds.size[ds.findp(nums[i])]);\\n\\n                }\\n                if(maxi==nums.size())break;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n# AC \\n```\\nclass disjointset{\\n    public:\\n    vector<int>parent,size;\\n    disjointset(int n){\\n        parent.resize(n+1);\\n        for(int i=0;i<=n;i++)parent[i]=i;\\n        size.resize(n+1,1);\\n    }\\n    int findp(int u){\\n        if(parent[u]==u)return u;\\n        return parent[u]=findp(parent[u]);\\n\\n    }\\n    void unionbysize(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return ;\\n        if(size[ult_u]<=size[ult_v]){\\n            parent[ult_u]=ult_v;\\n            size[ult_v]+=size[ult_u];\\n\\n        }\\n        else{\\n            parent[ult_v]=ult_u;\\n            size[ult_u]+=size[ult_v];\\n        }\\n        \\n    }\\n};\\nclass Solution {\\npublic:\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int maxi=-1e9;\\n        disjointset ds(*max_element(nums.begin(),nums.end()));\\n        for(auto i:nums){\\n            for(int j=2;j*j<=i;j++){\\n                if(i%j==0){\\n                    ds.unionbysize(i,j);\\n                    ds.unionbysize(i,i/j);\\n                }\\n            }\\n        }\\n        map<int,int>m;\\n        for(auto i:nums){\\n            maxi=max(maxi,m[ds.findp(i)]++);\\n            \\n            \\n        }\\n        return maxi+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass disjointset{\\n    public:\\n    vector<int>parent,size;\\n    disjointset(int n){\\n        parent.resize(n+1);\\n        for(int i=0;i<=n;i++)parent[i]=i;\\n        size.resize(n+1,1);\\n    }\\n    int findp(int u){\\n        if(parent[u]==u)return u;\\n        return parent[u]=findp(parent[u]);\\n\\n    }\\n    void unionbysize(int u,int v){\\n        int ult_u=findp(u);\\n        int ult_v=findp(v);\\n        if(ult_u==ult_v)return ;\\n        if(size[ult_u]<=size[ult_v]){\\n            parent[ult_u]=ult_v;\\n            size[ult_v]+=size[ult_u];\\n\\n        }\\n        else{\\n            parent[ult_v]=ult_u;\\n            size[ult_u]+=size[ult_v];\\n        }\\n        \\n    }\\n};\\nclass Solution {\\npublic:\\n    \\n    int largestComponentSize(vector<int>& nums) {\\n        int maxi=-1e9;\\n        disjointset ds(*max_element(nums.begin(),nums.end()));\\n        for(auto i:nums){\\n            for(int j=2;j*j<=i;j++){\\n                if(i%j==0){\\n                    ds.unionbysize(i,j);\\n                    ds.unionbysize(i,i/j);\\n                }\\n            }\\n        }\\n        map<int,int>m;\\n        for(auto i:nums){\\n            maxi=max(maxi,m[ds.findp(i)]++);\\n            \\n            \\n        }\\n        return maxi+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351595,
                "title": "simple-c-solution-using-dfs-and-sieve",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int prime[100001];\\n    void seive(){\\n        for(int i=0;i<=1e5;i++){\\n            prime[i]=i;\\n        }\\n        for(int i=2;i<=1e5;i+=2){\\n            prime[i]=2;\\n        }\\n        for(int i=3;i*i<=1e5;i++){\\n            if(prime[i]==i){\\n                for(int j=i*i;j<=1e5;j+=i){\\n                    prime[j]=i;\\n                }\\n            }\\n        }\\n    }\\n\\n    void dfs(int node, vector<int>adj[], vector<int>&vis, int& cy){\\n        vis[node]=1;\\n        cy++;\\n        for(auto it: adj[node]){\\n            if(!vis[it]){\\n                dfs(it,adj,vis,cy);\\n            }\\n        }\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n        seive();\\n        map<int,set<int>>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int x=nums[i];\\n            while(x!=1){\\n                mp[prime[x]].insert(i);\\n                x/=prime[x];\\n            }\\n        }\\n        vector<int>adj[n];\\n        for(auto i: mp){\\n            int p=0;\\n            int x;\\n            for(auto j: i.second){\\n                if(p==0){\\n                    x=j;\\n                    p=1;\\n                }\\n                else{\\n                    adj[j].push_back(x);\\n                    adj[x].push_back(j);\\n                }\\n            }\\n        }\\n        int ans=0;\\n        vector<int>vis(n,0);\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                int cy=0;\\n                dfs(i,adj,vis,cy);\\n                ans=max(cy,ans);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prime[100001];\\n    void seive(){\\n        for(int i=0;i<=1e5;i++){\\n            prime[i]=i;\\n        }\\n        for(int i=2;i<=1e5;i+=2){\\n            prime[i]=2;\\n        }\\n        for(int i=3;i*i<=1e5;i++){\\n            if(prime[i]==i){\\n                for(int j=i*i;j<=1e5;j+=i){\\n                    prime[j]=i;\\n                }\\n            }\\n        }\\n    }\\n\\n    void dfs(int node, vector<int>adj[], vector<int>&vis, int& cy){\\n        vis[node]=1;\\n        cy++;\\n        for(auto it: adj[node]){\\n            if(!vis[it]){\\n                dfs(it,adj,vis,cy);\\n            }\\n        }\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n        seive();\\n        map<int,set<int>>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int x=nums[i];\\n            while(x!=1){\\n                mp[prime[x]].insert(i);\\n                x/=prime[x];\\n            }\\n        }\\n        vector<int>adj[n];\\n        for(auto i: mp){\\n            int p=0;\\n            int x;\\n            for(auto j: i.second){\\n                if(p==0){\\n                    x=j;\\n                    p=1;\\n                }\\n                else{\\n                    adj[j].push_back(x);\\n                    adj[x].push_back(j);\\n                }\\n            }\\n        }\\n        int ans=0;\\n        vector<int>vis(n,0);\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                int cy=0;\\n                dfs(i,adj,vis,cy);\\n                ans=max(cy,ans);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281410,
                "title": "easy-solution-using-prime-factor-and-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int  N=100005;\\n    bool isPrime[100005];\\n    int spf[100005];\\n    vector<int> g[500005];\\n    map<int,int>mp;\\n   // spf.resize(100005,0);\\n    void sieve() {\\n        for( int i = 2 ; i<N ; i ++ ) {\\n            isPrime[ i ] = 1 ;\\n            spf[i]=i;\\n        }\\n    \\n        spf[1]=1;\\n        for( int i = 2 ; i*i <N ; i ++ ) {\\n            if(isPrime[i]!=0) {\\n                spf[i]=i;\\n                for( int j = i * i ; j <N ; j += i ) {\\n                    isPrime[ j ] = 0 ;\\n                    if(spf[j]==j) spf[j]=i;\\n                }\\n            }\\n        }\\n        \\n    }\\n    set<int> getFactorization(int x)\\n    {\\n        set<int> ret;\\n        while (x != 1)\\n        {\\n            ret.insert(spf[x]);\\n            x = x / spf[x];\\n        }\\n        return ret;\\n    }\\n\\n    int vis[500005];\\n    int c=0;\\n    void dfs(int node) {\\n        vis[node]=1;\\n        if(mp[node]) c++;\\n        for(int child : g[node]) {\\n            if(!vis[child]) {\\n                dfs(child);\\n            }\\n        }\\n    }\\n \\n    int largestComponentSize(vector<int>& v) {\\n        sieve();\\n        for(int i=0; i<v.size(); i++) {\\n            mp[v[i]]++;\\n            set<int>s=getFactorization(v[i]);\\n            for(auto it: s) {\\n                int u=v[i],v=it+100000;\\n                g[u].push_back(v);\\n                g[v].push_back(u);\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<v.size(); i++) {\\n            if(!vis[v[i]]) {\\n                c=0;\\n                dfs(v[i]);\\n                ans=max(ans,c);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int  N=100005;\\n    bool isPrime[100005];\\n    int spf[100005];\\n    vector<int> g[500005];\\n    map<int,int>mp;\\n   // spf.resize(100005,0);\\n    void sieve() {\\n        for( int i = 2 ; i<N ; i ++ ) {\\n            isPrime[ i ] = 1 ;\\n            spf[i]=i;\\n        }\\n    \\n        spf[1]=1;\\n        for( int i = 2 ; i*i <N ; i ++ ) {\\n            if(isPrime[i]!=0) {\\n                spf[i]=i;\\n                for( int j = i * i ; j <N ; j += i ) {\\n                    isPrime[ j ] = 0 ;\\n                    if(spf[j]==j) spf[j]=i;\\n                }\\n            }\\n        }\\n        \\n    }\\n    set<int> getFactorization(int x)\\n    {\\n        set<int> ret;\\n        while (x != 1)\\n        {\\n            ret.insert(spf[x]);\\n            x = x / spf[x];\\n        }\\n        return ret;\\n    }\\n\\n    int vis[500005];\\n    int c=0;\\n    void dfs(int node) {\\n        vis[node]=1;\\n        if(mp[node]) c++;\\n        for(int child : g[node]) {\\n            if(!vis[child]) {\\n                dfs(child);\\n            }\\n        }\\n    }\\n \\n    int largestComponentSize(vector<int>& v) {\\n        sieve();\\n        for(int i=0; i<v.size(); i++) {\\n            mp[v[i]]++;\\n            set<int>s=getFactorization(v[i]);\\n            for(auto it: s) {\\n                int u=v[i],v=it+100000;\\n                g[u].push_back(v);\\n                g[v].push_back(u);\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<v.size(); i++) {\\n            if(!vis[v[i]]) {\\n                c=0;\\n                dfs(v[i]);\\n                ans=max(ans,c);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267970,
                "title": "fastest-python-100-tc-700ms",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(NlogN)$$\\n# Code\\n```\\nimport math as mt\\nMAXN = 10**5 + 5\\n\\nspf = [i for i in range(MAXN)]\\n\\ndef sieve():\\n\\tspf[1] = 1\\n\\n\\tfor i in range(4, MAXN, 2):\\n\\t\\tspf[i] = 2\\n\\n\\tfor i in range(3, mt.ceil(mt.sqrt(MAXN))):\\n\\t\\tif (spf[i] == i):\\n\\t\\t\\t\\n\\t\\t\\tfor j in range(i * i, MAXN, i):\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (spf[j] == j):\\n\\t\\t\\t\\t\\tspf[j] = i\\n\\ndef factors(x):\\n\\tret = set()\\n\\twhile (x != 1):\\n\\t\\tret.add(spf[x])\\n\\t\\tx = x // spf[x]\\n\\n\\treturn ret\\n\\nsieve()\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        df = dict()\\n        uf = DSU(len(nums))\\n        for i,x in enumerate(nums):\\n            for f in factors(x):\\n                if(f in df): uf.union(i,df[f])\\n                else: df[f] = i\\n                    \\n        return uf.mx;\\n            \\n\\nclass DSU:\\n    def __init__(self, N):\\n        self.par = list(range(N))\\n        self.sz = [1] * N\\n        self.mx = 1\\n    def find(self, x):\\n        if self.par[x] != x:\\n            self.par[x] = self.find(self.par[x])\\n        return self.par[x]\\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        if xr == yr:\\n            return False\\n        if self.sz[xr] < self.sz[yr]:\\n            xr, yr = yr, xr\\n        self.par[yr] = xr\\n        self.sz[xr] += self.sz[yr]\\n        self.mx = max(self.mx,self.sz[xr])\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math as mt\\nMAXN = 10**5 + 5\\n\\nspf = [i for i in range(MAXN)]\\n\\ndef sieve():\\n\\tspf[1] = 1\\n\\n\\tfor i in range(4, MAXN, 2):\\n\\t\\tspf[i] = 2\\n\\n\\tfor i in range(3, mt.ceil(mt.sqrt(MAXN))):\\n\\t\\tif (spf[i] == i):\\n\\t\\t\\t\\n\\t\\t\\tfor j in range(i * i, MAXN, i):\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (spf[j] == j):\\n\\t\\t\\t\\t\\tspf[j] = i\\n\\ndef factors(x):\\n\\tret = set()\\n\\twhile (x != 1):\\n\\t\\tret.add(spf[x])\\n\\t\\tx = x // spf[x]\\n\\n\\treturn ret\\n\\nsieve()\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        df = dict()\\n        uf = DSU(len(nums))\\n        for i,x in enumerate(nums):\\n            for f in factors(x):\\n                if(f in df): uf.union(i,df[f])\\n                else: df[f] = i\\n                    \\n        return uf.mx;\\n            \\n\\nclass DSU:\\n    def __init__(self, N):\\n        self.par = list(range(N))\\n        self.sz = [1] * N\\n        self.mx = 1\\n    def find(self, x):\\n        if self.par[x] != x:\\n            self.par[x] = self.find(self.par[x])\\n        return self.par[x]\\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        if xr == yr:\\n            return False\\n        if self.sz[xr] < self.sz[yr]:\\n            xr, yr = yr, xr\\n        self.par[yr] = xr\\n        self.sz[xr] += self.sz[yr]\\n        self.mx = max(self.mx,self.sz[xr])\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248877,
                "title": "c-without-dsu",
                "content": "This approach uses ONLY DFS \\nsimply search for each factor and draw an edge between them\\ncode:-\\n```\\nclass Solution {\\npublic:\\n    void solve(map<int,int> &vis ,int i , map<int,vector<int>> &mp , int &cnt , map<int,int> &inside )\\n    {\\n        vis[i] = 1;\\n        cnt+=inside[i];\\n        // if(inside[i]) cout<<i<<\" \";\\n        for(auto a : mp[i])\\n        {\\n            if(vis[a] == 0)\\n            {\\n                solve(vis , a , mp , cnt , inside);\\n            }\\n        }\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n        map<int,vector<int>> mp;\\n        map<int,int> inside;\\n        for(auto a : nums)\\n        {\\n            inside[a] = 1;\\n            for(int i = 2 ;i<=sqrt(a);i++)\\n            {\\n               if(a%i == 0)\\n               {\\n                   if(a/i == i)\\n                   {\\n                       mp[i].push_back(a);\\n                       mp[a].push_back(i);\\n                   }\\n                   else\\n                   {\\n                       mp[i].push_back(a);\\n                       mp[a].push_back(i);\\n                       mp[a/i].push_back(a);\\n                       mp[a].push_back(a/i);\\n                   }\\n               }\\n            }\\n        }\\n        map<int,int> vis;\\n        int ans = 0;\\n        \\n        for(auto a : nums)\\n        {\\n            if(vis[a] == 0)\\n            {\\n                // cout<<a<<\" \";\\n                int cnt = 0;\\n                solve(vis , a , mp , cnt , inside);\\n                ans = max(cnt , ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(map<int,int> &vis ,int i , map<int,vector<int>> &mp , int &cnt , map<int,int> &inside )\\n    {\\n        vis[i] = 1;\\n        cnt+=inside[i];\\n        // if(inside[i]) cout<<i<<\" \";\\n        for(auto a : mp[i])\\n        {\\n            if(vis[a] == 0)\\n            {\\n                solve(vis , a , mp , cnt , inside);\\n            }\\n        }\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n        map<int,vector<int>> mp;\\n        map<int,int> inside;\\n        for(auto a : nums)\\n        {\\n            inside[a] = 1;\\n            for(int i = 2 ;i<=sqrt(a);i++)\\n            {\\n               if(a%i == 0)\\n               {\\n                   if(a/i == i)\\n                   {\\n                       mp[i].push_back(a);\\n                       mp[a].push_back(i);\\n                   }\\n                   else\\n                   {\\n                       mp[i].push_back(a);\\n                       mp[a].push_back(i);\\n                       mp[a/i].push_back(a);\\n                       mp[a].push_back(a/i);\\n                   }\\n               }\\n            }\\n        }\\n        map<int,int> vis;\\n        int ans = 0;\\n        \\n        for(auto a : nums)\\n        {\\n            if(vis[a] == 0)\\n            {\\n                // cout<<a<<\" \";\\n                int cnt = 0;\\n                solve(vis , a , mp , cnt , inside);\\n                ans = max(cnt , ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3234312,
                "title": "easiest-typescript-solution-ufs",
                "content": "- Define standard UFS writing using `root`, `find` and `union`\\n- Get primes until `100000` (max) with the most optimized function for getting prime number `O(Sqrt(N))` where `N` is the given number\\n- Loop through each primes we just got. Get the `remainder` of given `nums / each prime num`\\n    - Use `Union` to group every number that was divided with the same `prime number`\\n- Loop through once again to get the maximum number of any parent and return\\n    - Minimum is `1`\\n\\n# Code (UFS)\\n```\\nfunction largestComponentSize(nums: number[]): number {\\n    const primes = getPrimesUntil(100000)\\n    const root: (undefined | number)[] = [...Array(nums.length)]\\n\\n    const find = (i: number): number => {\\n        if (root[i] === undefined || root[i] === i) return i\\n        return root[i] = find(root[i])\\n    }\\n\\n    const union = (i: number, j: number) => {\\n        const iRoot = find(i), jRoot = find(j)\\n        root[iRoot] = root[jRoot] = Math.max(iRoot, jRoot)\\n    }\\n\\n    for (const prime of primes) {\\n        const indexes = [] // indexes\\n        let max = 1\\n        for (let i = 0; i < nums.length; i++) {\\n            if (nums[i] === 1) continue\\n            if (nums[i] % prime === 0) {\\n                indexes.push(i)\\n                while (nums[i] % prime === 0) nums[i] /= prime // Optimization\\n            }\\n            max = Math.max(nums[i], max)\\n        }\\n        \\n        for (let i = 0; i < indexes.length - 1; i++) {\\n            union(indexes[i], indexes[i + 1])\\n        }\\n\\n        if (max < prime) break // Optimization\\n    }\\n\\n    const map = new Map<number, number>() // number, count\\n    let maxCnt = 1 // There should be at least one independent component\\n    for (const rootI of root) {\\n        if (rootI === undefined) continue\\n        const foundI = find(rootI)\\n\\n        const newCount = (map.get(foundI) || 0) + 1\\n        map.set(foundI, newCount)\\n        maxCnt = Math.max(maxCnt, newCount)\\n    }\\n    \\n    return maxCnt\\n};\\n\\nconst getPrimesUntil = (untilThisNumber: number) => {\\n    const primes = [2]\\n    for (let i = 3; i <= untilThisNumber; i += 2) {\\n        let isPrime = true\\n        const max = Math.sqrt(i)\\n        for (let j = 2; j <= max; j++) {\\n            if (i % j !== 0) continue\\n\\n            isPrime = false\\n            break\\n        }\\n        if (isPrime) primes.push(i)\\n    }\\n    return primes\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction largestComponentSize(nums: number[]): number {\\n    const primes = getPrimesUntil(100000)\\n    const root: (undefined | number)[] = [...Array(nums.length)]\\n\\n    const find = (i: number): number => {\\n        if (root[i] === undefined || root[i] === i) return i\\n        return root[i] = find(root[i])\\n    }\\n\\n    const union = (i: number, j: number) => {\\n        const iRoot = find(i), jRoot = find(j)\\n        root[iRoot] = root[jRoot] = Math.max(iRoot, jRoot)\\n    }\\n\\n    for (const prime of primes) {\\n        const indexes = [] // indexes\\n        let max = 1\\n        for (let i = 0; i < nums.length; i++) {\\n            if (nums[i] === 1) continue\\n            if (nums[i] % prime === 0) {\\n                indexes.push(i)\\n                while (nums[i] % prime === 0) nums[i] /= prime // Optimization\\n            }\\n            max = Math.max(nums[i], max)\\n        }\\n        \\n        for (let i = 0; i < indexes.length - 1; i++) {\\n            union(indexes[i], indexes[i + 1])\\n        }\\n\\n        if (max < prime) break // Optimization\\n    }\\n\\n    const map = new Map<number, number>() // number, count\\n    let maxCnt = 1 // There should be at least one independent component\\n    for (const rootI of root) {\\n        if (rootI === undefined) continue\\n        const foundI = find(rootI)\\n\\n        const newCount = (map.get(foundI) || 0) + 1\\n        map.set(foundI, newCount)\\n        maxCnt = Math.max(maxCnt, newCount)\\n    }\\n    \\n    return maxCnt\\n};\\n\\nconst getPrimesUntil = (untilThisNumber: number) => {\\n    const primes = [2]\\n    for (let i = 3; i <= untilThisNumber; i += 2) {\\n        let isPrime = true\\n        const max = Math.sqrt(i)\\n        for (let j = 2; j <= max; j++) {\\n            if (i % j !== 0) continue\\n\\n            isPrime = false\\n            break\\n        }\\n        if (isPrime) primes.push(i)\\n    }\\n    return primes\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3189741,
                "title": "prime-factorisation-dfs-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;        // adjacency list of indexes connected with each other\\n    vector<int> vis;\\n    map<int, int> pr_ind;           // index of a number divisible by this prime\\n    \\n    int dfs(int i, int par){\\n        int size = 1;\\n        vis[i] = 1;\\n        for(int& ch : adj[i]){\\n            if(ch != par and vis[ch] == 0){\\n                size += dfs(ch, i);\\n            }\\n        }\\n        return size;\\n    }\\n    \\n    int largestComponentSize(vector<int>& a) {\\n        int n = a.size();\\n        adj.resize(n);\\n        for(int i = 0; i < n; ++i){\\n            int num = a[i];\\n            \\n            // find the prime factorisation of a[i]\\n            // connect a[i] with all the numbers which share the same prime numbers as divisors\\n            // CATCH : We dont have to connect a[i] with all the numbers that share the same prime number\\n            // connecting with only one of those numbers will be fine as through that number we have automatically\\n            // made an indirect connection with all the other numbers ( Imagine like a Linked List )\\n            \\n            {\\n                for(long k = 2; k * k <= num; ++k){\\n                    if(num % k == 0){\\n                        // add connection\\n                        // pr_ind me agar koi index pehle se hai to usse connect krdo\\n                        // if pr_ind has some former index then connect \\'i\\' with that index\\n                        \\n                        // otherwise any number divisible by prime number K has not been \\n                        // found before hence we cannot make any connection\\n                        if(pr_ind.count(k) == 0){\\n                            pr_ind[k] = i;\\n                        } else{\\n                            adj[pr_ind[k]].push_back(i);\\n                            adj[i].push_back(pr_ind[k]);\\n                        }\\n                        \\n                        // remove all occ of this prime number\\n                        while(num % k == 0){\\n                            num /= k;\\n                        }\\n                        \\n                    }\\n                }\\n                if(num > 1){\\n                    if(pr_ind.count(num) == 0){\\n                        pr_ind[num] = i;\\n                    } else{\\n                        adj[pr_ind[num]].push_back(i);\\n                        adj[i].push_back(pr_ind[num]);\\n                    }\\n                }\\n                \\n            }\\n        }\\n        // find the maximum component size\\n        int ans = 0;\\n        vis.resize(n);\\n        for(int i = 0; i < n; ++i){\\n            if(!vis[i]){\\n                int size = dfs(i, -1);\\n                ans = max(ans, size);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;        // adjacency list of indexes connected with each other\\n    vector<int> vis;\\n    map<int, int> pr_ind;           // index of a number divisible by this prime\\n    \\n    int dfs(int i, int par){\\n        int size = 1;\\n        vis[i] = 1;\\n        for(int& ch : adj[i]){\\n            if(ch != par and vis[ch] == 0){\\n                size += dfs(ch, i);\\n            }\\n        }\\n        return size;\\n    }\\n    \\n    int largestComponentSize(vector<int>& a) {\\n        int n = a.size();\\n        adj.resize(n);\\n        for(int i = 0; i < n; ++i){\\n            int num = a[i];\\n            \\n            // find the prime factorisation of a[i]\\n            // connect a[i] with all the numbers which share the same prime numbers as divisors\\n            // CATCH : We dont have to connect a[i] with all the numbers that share the same prime number\\n            // connecting with only one of those numbers will be fine as through that number we have automatically\\n            // made an indirect connection with all the other numbers ( Imagine like a Linked List )\\n            \\n            {\\n                for(long k = 2; k * k <= num; ++k){\\n                    if(num % k == 0){\\n                        // add connection\\n                        // pr_ind me agar koi index pehle se hai to usse connect krdo\\n                        // if pr_ind has some former index then connect \\'i\\' with that index\\n                        \\n                        // otherwise any number divisible by prime number K has not been \\n                        // found before hence we cannot make any connection\\n                        if(pr_ind.count(k) == 0){\\n                            pr_ind[k] = i;\\n                        } else{\\n                            adj[pr_ind[k]].push_back(i);\\n                            adj[i].push_back(pr_ind[k]);\\n                        }\\n                        \\n                        // remove all occ of this prime number\\n                        while(num % k == 0){\\n                            num /= k;\\n                        }\\n                        \\n                    }\\n                }\\n                if(num > 1){\\n                    if(pr_ind.count(num) == 0){\\n                        pr_ind[num] = i;\\n                    } else{\\n                        adj[pr_ind[num]].push_back(i);\\n                        adj[i].push_back(pr_ind[num]);\\n                    }\\n                }\\n                \\n            }\\n        }\\n        // find the maximum component size\\n        int ans = 0;\\n        vis.resize(n);\\n        for(int i = 0; i < n; ++i){\\n            if(!vis[i]){\\n                int size = dfs(i, -1);\\n                ans = max(ans, size);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164139,
                "title": "c-union-find-sieve",
                "content": "# Intuition\\nConnected components => union find\\nfactor => sieve\\n\\n# Approach\\nSimply loop over the common factors and their multiples\\nand merge them\\n\\n# Complexity\\n- Time complexity:\\naround O(sieve * union) = O(mlogm * logm) where m is the maximum possible value in nums\\n\\n- Space complexity:\\nO(m) where m is the maximum possible value in nums\\n\\n# Code\\n```\\nclass Solution {\\nvector<int>rank;\\nvector<int>siz;\\nvector<int>parent;\\nint find_set(int val){\\n    if(parent[val] == val) return val;\\n    return parent[val]=find_set(parent[val]);\\n}\\nint union_set(int a, int b){\\n    int pa=find_set(a);\\n    int pb=find_set(b);\\n    \\n    if(pa==pb) return siz[pa];\\n    if(rank[pa] < rank[pb]){\\n        swap(pa,pb);\\n        swap(a,b);\\n    }\\n    parent[pb]=pa;\\n    siz[pa]+=siz[pb];\\n    if(rank[pa]==rank[pb]) rank[pa]++;\\n    return siz[pa];\\n}\\nvoid make_set(vector<int>&nums){\\n    rank.resize(100001,0);\\n    siz.resize(100001,1);\\n    parent.resize(100001,-1);\\n    for(auto num : nums){\\n        parent[num]=num;\\n    }\\n}\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        make_set(nums);\\n        int ans=1;\\n        /* Loop over all the possible common factors */\\n        for(long long i=2;i<=100000;++i){\\n            int val=-1;\\n            /* Loop over all the multiples of common factors */\\n            for(long long j=i;j<=100000;j+=i){\\n                /* If number is present in nums we keep the parent[num]=num, same way as union find \\n                data structure */\\n                if(parent[j]>0){\\n                    if(val > 0){\\n                        /* Merge the set */\\n                        ans=max(union_set(val,j),ans);\\n                    }else{\\n                        val=j;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\nvector<int>rank;\\nvector<int>siz;\\nvector<int>parent;\\nint find_set(int val){\\n    if(parent[val] == val) return val;\\n    return parent[val]=find_set(parent[val]);\\n}\\nint union_set(int a, int b){\\n    int pa=find_set(a);\\n    int pb=find_set(b);\\n    \\n    if(pa==pb) return siz[pa];\\n    if(rank[pa] < rank[pb]){\\n        swap(pa,pb);\\n        swap(a,b);\\n    }\\n    parent[pb]=pa;\\n    siz[pa]+=siz[pb];\\n    if(rank[pa]==rank[pb]) rank[pa]++;\\n    return siz[pa];\\n}\\nvoid make_set(vector<int>&nums){\\n    rank.resize(100001,0);\\n    siz.resize(100001,1);\\n    parent.resize(100001,-1);\\n    for(auto num : nums){\\n        parent[num]=num;\\n    }\\n}\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        make_set(nums);\\n        int ans=1;\\n        /* Loop over all the possible common factors */\\n        for(long long i=2;i<=100000;++i){\\n            int val=-1;\\n            /* Loop over all the multiples of common factors */\\n            for(long long j=i;j<=100000;j+=i){\\n                /* If number is present in nums we keep the parent[num]=num, same way as union find \\n                data structure */\\n                if(parent[j]>0){\\n                    if(val > 0){\\n                        /* Merge the set */\\n                        ans=max(union_set(val,j),ans);\\n                    }else{\\n                        val=j;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159831,
                "title": "shortest-simplest-solution-sieve-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        mx = max(nums)\\n        par = [i for i in range(mx + 1)]\\n        nums = set(nums)\\n\\n        def find(u):\\n            if par[u] != u:\\n                par[u] = find(par[u])\\n            return par[u]\\n    \\n        def union(u, v):\\n            if find(u) == find(v):\\n                return\\n            par[find(u)] = find(v)\\n\\n        for i in range(2, mx + 1):\\n            for j in range(i, mx + 1, i):\\n                if j in nums:\\n                    union(i, j)\\n        return max(Counter(find(num) for num in nums).values())\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        mx = max(nums)\\n        par = [i for i in range(mx + 1)]\\n        nums = set(nums)\\n\\n        def find(u):\\n            if par[u] != u:\\n                par[u] = find(par[u])\\n            return par[u]\\n    \\n        def union(u, v):\\n            if find(u) == find(v):\\n                return\\n            par[find(u)] = find(v)\\n\\n        for i in range(2, mx + 1):\\n            for j in range(i, mx + 1, i):\\n                if j in nums:\\n                    union(i, j)\\n        return max(Counter(find(num) for num in nums).values())\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3155971,
                "title": "java-union-find",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n    public int find(int j, int[] parent) {\\n\\n        if (parent[j] == j) {\\n            return j;\\n        } else {\\n            return parent[j] = find(parent[j], parent);\\n        }\\n    }\\n\\n    public int largestComponentSize(int[] nums) {\\n\\n        int[] parent = new int[100001];\\n        for (int i = 0; i <= 100000; i++) {\\n            parent[i] = i;\\n        }\\n\\n        int[] rank = new int[100001];\\n\\n        int n = nums.length;\\n\\n        for (int i = 0; i < n; i++) {\\n\\n            for (int j = 2; j * j <= nums[i]; j++) {\\n                if (nums[i] % j == 0) {\\n\\n                    int a = find(j, parent);\\n                    int b = find(nums[i], parent);\\n\\n                    if (rank[a] > rank[b]) {\\n                        parent[b] = a;\\n                        rank[a]++;\\n                    } else {\\n                        parent[a] = b;\\n                        rank[b]++;\\n                    }\\n                }\\n\\n                if (nums[i] % j == 0 && nums[i] % (nums[i] / j) == 0) {\\n                    int a = find(nums[i] / j, parent);\\n                    int b = find(nums[i], parent);\\n                    if (rank[a] > rank[b]) {\\n                        parent[b] = a;\\n                        rank[a]++;\\n                    } else {\\n                        parent[a] = b;\\n                        rank[b]++;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n        int max = 1;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i <n; i++) {\\n            int a = find(nums[i],parent);\\n            if(map.containsKey(a)){\\n                int p = map.get(a);\\n                map.put(a,p+1);\\n                max = Math.max(p+1,max);\\n            }else{\\n                map.put(a,1);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n\\n    public int find(int j, int[] parent) {\\n\\n        if (parent[j] == j) {\\n            return j;\\n        } else {\\n            return parent[j] = find(parent[j], parent);\\n        }\\n    }\\n\\n    public int largestComponentSize(int[] nums) {\\n\\n        int[] parent = new int[100001];\\n        for (int i = 0; i <= 100000; i++) {\\n            parent[i] = i;\\n        }\\n\\n        int[] rank = new int[100001];\\n\\n        int n = nums.length;\\n\\n        for (int i = 0; i < n; i++) {\\n\\n            for (int j = 2; j * j <= nums[i]; j++) {\\n                if (nums[i] % j == 0) {\\n\\n                    int a = find(j, parent);\\n                    int b = find(nums[i], parent);\\n\\n                    if (rank[a] > rank[b]) {\\n                        parent[b] = a;\\n                        rank[a]++;\\n                    } else {\\n                        parent[a] = b;\\n                        rank[b]++;\\n                    }\\n                }\\n\\n                if (nums[i] % j == 0 && nums[i] % (nums[i] / j) == 0) {\\n                    int a = find(nums[i] / j, parent);\\n                    int b = find(nums[i], parent);\\n                    if (rank[a] > rank[b]) {\\n                        parent[b] = a;\\n                        rank[a]++;\\n                    } else {\\n                        parent[a] = b;\\n                        rank[b]++;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n        int max = 1;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i <n; i++) {\\n            int a = find(nums[i],parent);\\n            if(map.containsKey(a)){\\n                int p = map.get(a);\\n                map.put(a,p+1);\\n                max = Math.max(p+1,max);\\n            }else{\\n                map.put(a,1);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097814,
                "title": "union-find-and-primeset-approach-follow-up-question-why-is-recursive-find-faster-than-iterative",
                "content": "Recursive find() \\n```python\\nimport math\\nfrom collections import defaultdict, Counter\\nfrom typing import List\\n\\n\\nclass UnionSet:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n\\n    def find(self, x):\\n        curr = self.parent[x]\\n        while curr != self.parent[curr]:\\n            curr, self.parent[curr] = self.parent[curr], self.parent[self.parent[curr]]\\n        return self.parent[curr]\\n\\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        self.parent[xr] = yr\\n        \\n@cache\\ndef primeSet(n): # Time: O(sqrt(n)*logn), Space: O(logn), a prime set is a set of prime numbers that can express a composite number\\n    for i in range(2, int(math.sqrt(n) + 1)):\\n        if n % i == 0:\\n            return primeSet(n // i) | {i}\\n    return {n}\\n\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        unionFind = UnionSet(n)\\n        primes = defaultdict(list)\\n\\n        for i, num in enumerate(nums):  # { factor: [indexes for which has the factor] }\\n            for q in primeSet(num):\\n                primes[q].append(i)\\n\\n        for _, indexes in primes.items(): # unionFind for all indexes with a similar factor\\n            for i in range(len(indexes)-1):\\n                unionFind.union(indexes[i], indexes[i + 1])\\n                \\n        return max(Counter([unionFind.find(i) for i in range(n)]).values()) # find parent index with the largest size\\n```\\n\\nIterative find\\n```python\\nclass UnionSet:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n\\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[self.parent[x]])\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        self.parent[xr] = yr\\n        \\n@cache\\ndef primeSet(n): # Time: O(sqrt(n)*logn), Space: O(logn), a prime set is a set of prime numbers that can express a composite number\\n    for i in range(2, int(math.sqrt(n) + 1)):\\n        if n % i == 0:\\n            return primeSet(n // i) | {i}\\n    return {n}\\n\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        unionFind = UnionSet(n)\\n        primes = defaultdict(list)\\n\\n        for i, num in enumerate(nums):  # { factor: [indexes for which has the factor] }\\n            for q in primeSet(num):\\n                primes[q].append(i)\\n\\n        for _, indexes in primes.items(): # unionFind for all indexes with a similar factor\\n            for i in range(len(indexes)-1):\\n                unionFind.union(indexes[i], indexes[i + 1])\\n                \\n        return max(Counter([unionFind.find(i) for i in range(n)]).values()) # find parent index with the largest size\\n```\\n\\n\\nOddly the iterative find() implementation times out while the recursive does not. I\\'m wondering if anyone knows why\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nimport math\\nfrom collections import defaultdict, Counter\\nfrom typing import List\\n\\n\\nclass UnionSet:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n\\n    def find(self, x):\\n        curr = self.parent[x]\\n        while curr != self.parent[curr]:\\n            curr, self.parent[curr] = self.parent[curr], self.parent[self.parent[curr]]\\n        return self.parent[curr]\\n\\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        self.parent[xr] = yr\\n        \\n@cache\\ndef primeSet(n): # Time: O(sqrt(n)*logn), Space: O(logn), a prime set is a set of prime numbers that can express a composite number\\n    for i in range(2, int(math.sqrt(n) + 1)):\\n        if n % i == 0:\\n            return primeSet(n // i) | {i}\\n    return {n}\\n\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        unionFind = UnionSet(n)\\n        primes = defaultdict(list)\\n\\n        for i, num in enumerate(nums):  # { factor: [indexes for which has the factor] }\\n            for q in primeSet(num):\\n                primes[q].append(i)\\n\\n        for _, indexes in primes.items(): # unionFind for all indexes with a similar factor\\n            for i in range(len(indexes)-1):\\n                unionFind.union(indexes[i], indexes[i + 1])\\n                \\n        return max(Counter([unionFind.find(i) for i in range(n)]).values()) # find parent index with the largest size\\n```\n```python\\nclass UnionSet:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n\\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[self.parent[x]])\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        self.parent[xr] = yr\\n        \\n@cache\\ndef primeSet(n): # Time: O(sqrt(n)*logn), Space: O(logn), a prime set is a set of prime numbers that can express a composite number\\n    for i in range(2, int(math.sqrt(n) + 1)):\\n        if n % i == 0:\\n            return primeSet(n // i) | {i}\\n    return {n}\\n\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        unionFind = UnionSet(n)\\n        primes = defaultdict(list)\\n\\n        for i, num in enumerate(nums):  # { factor: [indexes for which has the factor] }\\n            for q in primeSet(num):\\n                primes[q].append(i)\\n\\n        for _, indexes in primes.items(): # unionFind for all indexes with a similar factor\\n            for i in range(len(indexes)-1):\\n                unionFind.union(indexes[i], indexes[i + 1])\\n                \\n        return max(Counter([unionFind.find(i) for i in range(n)]).values()) # find parent index with the largest size\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081164,
                "title": "simple-and-clean-dsu-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvector<int>par,siz;\\nclass Disjoint{\\n    public:\\n    Disjoint(int n){\\n        par.resize(n+1);\\n        siz.resize(n+1);\\n        int i;\\n        for(i=0;i<=n;i++){\\n            par[i]=i;\\n            siz[i]=1;\\n        }\\n    }\\n    int find(int node){\\n        if(node==par[node]) return node;\\n        return par[node]=find(par[node]);\\n    }\\n    void join(int u,int v){\\n        int ultu=find(u),ultv=find(v);\\n        if(ultu!=ultv){\\n            if(siz[ultu]>=siz[ultv]){\\n                par[ultv]=ultu;\\n                siz[ultu]+=siz[ultv];\\n            }\\n            else{\\n                 par[ultu]=ultv;\\n                siz[ultv]+=siz[ultu];\\n            }\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int num=*max_element(nums.begin(),nums.end());\\n        int maxi=1,i,j;\\n        Disjoint ds(num);\\n        for(i=0;i<nums.size();i++){\\n            for(j=2;j<=sqrt(nums[i]);j++){\\n                if(nums[i]%j==0){\\n                ds.join(nums[i],j);\\n                ds.join(j,nums[i]/j);\\n                }\\n            }\\n        }\\n        unordered_map<int,int>m;\\n        for(i=0;i<nums.size();i++){\\n            int pa=ds.find(nums[i]);\\n            m[pa]++;\\n            maxi=max(maxi,m[pa]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvector<int>par,siz;\\nclass Disjoint{\\n    public:\\n    Disjoint(int n){\\n        par.resize(n+1);\\n        siz.resize(n+1);\\n        int i;\\n        for(i=0;i<=n;i++){\\n            par[i]=i;\\n            siz[i]=1;\\n        }\\n    }\\n    int find(int node){\\n        if(node==par[node]) return node;\\n        return par[node]=find(par[node]);\\n    }\\n    void join(int u,int v){\\n        int ultu=find(u),ultv=find(v);\\n        if(ultu!=ultv){\\n            if(siz[ultu]>=siz[ultv]){\\n                par[ultv]=ultu;\\n                siz[ultu]+=siz[ultv];\\n            }\\n            else{\\n                 par[ultu]=ultv;\\n                siz[ultv]+=siz[ultu];\\n            }\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& nums) {\\n        int num=*max_element(nums.begin(),nums.end());\\n        int maxi=1,i,j;\\n        Disjoint ds(num);\\n        for(i=0;i<nums.size();i++){\\n            for(j=2;j<=sqrt(nums[i]);j++){\\n                if(nums[i]%j==0){\\n                ds.join(nums[i],j);\\n                ds.join(j,nums[i]/j);\\n                }\\n            }\\n        }\\n        unordered_map<int,int>m;\\n        for(i=0;i<nums.size();i++){\\n            int pa=ds.find(nums[i]);\\n            m[pa]++;\\n            maxi=max(maxi,m[pa]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049395,
                "title": "python-union-find-solution-prime-factor",
                "content": "```\\ndef largestComponentSize(self, nums: List[int]) -> int:\\n\\tdef prime(x):\\n\\t\\tfactors = set()\\n\\t\\tfor i in range(2, int(sqrt(x))+1):\\n\\t\\t\\twhile(x%i==0):\\n\\t\\t\\t\\tx//=i\\n\\t\\t\\t\\tfactors.add(i)\\n\\t\\treturn factors|{x} if x>1 else factors\\n\\n\\tuf, pf = list(range(len(nums))), defaultdict(list)\\n\\tfor i, x in enumerate(nums):\\n\\t\\tfor p in prime(x):\\n\\t\\t\\tpf[p].append(i)\\n\\n\\tdef find(i):\\n\\t\\tif uf[i]!=i:\\n\\t\\t\\tuf[i]=find(uf[i])\\n\\t\\treturn uf[i]\\n\\n\\tdef union(i, j):\\n\\t\\tfi, fj = find(i), find(j)\\n\\t\\tuf[fj] = fi\\n\\t\\treturn fi\\n\\n\\tfor i in pf:\\n\\t\\treduce(union, pf[i])\\n\\n\\treturn max(Counter([find(i) for i in range(len(nums))]).values())\\n```",
                "solutionTags": [],
                "code": "```\\ndef largestComponentSize(self, nums: List[int]) -> int:\\n\\tdef prime(x):\\n\\t\\tfactors = set()\\n\\t\\tfor i in range(2, int(sqrt(x))+1):\\n\\t\\t\\twhile(x%i==0):\\n\\t\\t\\t\\tx//=i\\n\\t\\t\\t\\tfactors.add(i)\\n\\t\\treturn factors|{x} if x>1 else factors\\n\\n\\tuf, pf = list(range(len(nums))), defaultdict(list)\\n\\tfor i, x in enumerate(nums):\\n\\t\\tfor p in prime(x):\\n\\t\\t\\tpf[p].append(i)\\n\\n\\tdef find(i):\\n\\t\\tif uf[i]!=i:\\n\\t\\t\\tuf[i]=find(uf[i])\\n\\t\\treturn uf[i]\\n\\n\\tdef union(i, j):\\n\\t\\tfi, fj = find(i), find(j)\\n\\t\\tuf[fj] = fi\\n\\t\\treturn fi\\n\\n\\tfor i in pf:\\n\\t\\treduce(union, pf[i])\\n\\n\\treturn max(Counter([find(i) for i in range(len(nums))]).values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3024226,
                "title": "dfs-and-map-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n* sqrt(n));\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(E) => E = edges\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool vis[100005];\\n    void dfs(int x , set<int> adj[], int &cnt, unordered_map<int,int>& m){\\n        vis[x]=1;\\n        if(m.count(x)) cnt++;\\n        for(auto it : adj[x]){\\n            if(!vis[it]){\\n                dfs(it, adj, cnt ,m);\\n            }\\n        }\\n\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n       \\n        unordered_map<int,int> m;\\n        set<int> adj[100005];\\n        for(auto x:nums) m[x]=1;\\n        for(int i =0;i<100005;i++) vis[i] = 0;\\n        int n = nums.size();\\n        for(int i =0;i<n;i++){\\n            for(int j = 2;j*j<=nums[i];j++){\\n                if(nums[i]%j==0){\\n                   adj[nums[i]].insert(j);\\n                   adj[j].insert(nums[i]);\\n                    adj[nums[i]].insert(nums[i]/j);\\n                   adj[nums[i]/j].insert(nums[i]);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i =2;i<=100000;i++){\\n            if(!vis[i]){\\n                int cnt= 0 ;\\n                dfs(i, adj,cnt,m);\\n                ans = max(ans, cnt);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool vis[100005];\\n    void dfs(int x , set<int> adj[], int &cnt, unordered_map<int,int>& m){\\n        vis[x]=1;\\n        if(m.count(x)) cnt++;\\n        for(auto it : adj[x]){\\n            if(!vis[it]){\\n                dfs(it, adj, cnt ,m);\\n            }\\n        }\\n\\n    }\\n    int largestComponentSize(vector<int>& nums) {\\n       \\n        unordered_map<int,int> m;\\n        set<int> adj[100005];\\n        for(auto x:nums) m[x]=1;\\n        for(int i =0;i<100005;i++) vis[i] = 0;\\n        int n = nums.size();\\n        for(int i =0;i<n;i++){\\n            for(int j = 2;j*j<=nums[i];j++){\\n                if(nums[i]%j==0){\\n                   adj[nums[i]].insert(j);\\n                   adj[j].insert(nums[i]);\\n                    adj[nums[i]].insert(nums[i]/j);\\n                   adj[nums[i]/j].insert(nums[i]);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i =2;i<=100000;i++){\\n            if(!vis[i]){\\n                int cnt= 0 ;\\n                dfs(i, adj,cnt,m);\\n                ans = max(ans, cnt);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981238,
                "title": "sieve-path-compression-algorithm-union-find",
                "content": "```\\nint flag=0,mx=1e5+10;\\nvector<int> spf;\\nclass Solution {\\n    vector<int> par;\\npublic:\\n    Solution(){\\n        if(!flag){\\n            flag=1;\\n            spf.resize(mx,2);\\n            for(int i=0;i<mx;i++)\\n                if(i&1)\\n                    spf[i]=i;\\n            int sq=sqrt(mx);\\n            for(int i=3;i<=sq;i+=2){\\n                if(spf[i]==i){\\n                    for(int j=i*i;j<mx;j+=i)\\n                        spf[j]=i;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int findPar(int p){\\n        if(par[p]==p)\\n            return p;\\n        return par[p]=findPar(par[p]);\\n    }\\n    \\n    int largestComponentSize(vector<int>& a) {\\n        par.resize(mx);\\n        for(int i=0;i<mx;i++)\\n            par[i]=i;\\n        \\n        sort(a.begin(),a.end());\\n        for(auto e:a){\\n            vector<int> p;\\n            int mn=e;\\n            while(e>1){\\n                int pr=spf[e];\\n                while(e%pr==0)\\n                    e/=pr;\\n                p.push_back(findPar(pr));\\n                mn=min(mn,findPar(pr));\\n            }\\n            mn=findPar(mn);\\n            for(auto e:p)\\n                par[e]=mn;\\n        }\\n        \\n        int ans=0;\\n        unordered_map<int,int> mp;\\n        for(auto e:a){\\n            mp[findPar(spf[e])]++;\\n            ans=max(ans,mp[findPar(spf[e])]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nint flag=0,mx=1e5+10;\\nvector<int> spf;\\nclass Solution {\\n    vector<int> par;\\npublic:\\n    Solution(){\\n        if(!flag){\\n            flag=1;\\n            spf.resize(mx,2);\\n            for(int i=0;i<mx;i++)\\n                if(i&1)\\n                    spf[i]=i;\\n            int sq=sqrt(mx);\\n            for(int i=3;i<=sq;i+=2){\\n                if(spf[i]==i){\\n                    for(int j=i*i;j<mx;j+=i)\\n                        spf[j]=i;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int findPar(int p){\\n        if(par[p]==p)\\n            return p;\\n        return par[p]=findPar(par[p]);\\n    }\\n    \\n    int largestComponentSize(vector<int>& a) {\\n        par.resize(mx);\\n        for(int i=0;i<mx;i++)\\n            par[i]=i;\\n        \\n        sort(a.begin(),a.end());\\n        for(auto e:a){\\n            vector<int> p;\\n            int mn=e;\\n            while(e>1){\\n                int pr=spf[e];\\n                while(e%pr==0)\\n                    e/=pr;\\n                p.push_back(findPar(pr));\\n                mn=min(mn,findPar(pr));\\n            }\\n            mn=findPar(mn);\\n            for(auto e:p)\\n                par[e]=mn;\\n        }\\n        \\n        int ans=0;\\n        unordered_map<int,int> mp;\\n        for(auto e:a){\\n            mp[findPar(spf[e])]++;\\n            ans=max(ans,mp[findPar(spf[e])]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967690,
                "title": "c-unionfind-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& A) {\\n        int root[100001]{}, res = 0;\\n        for(int i = 0; i < 100001; i++) root[i] = i;\\n\\n        auto findP = [&](int t) {\\n            while(t != root[t]) {\\n                root[t] = root[root[t]];\\n                t = root[t];\\n            }\\n            return t;\\n        };\\n\\n        for(auto e : A) {\\n            int p1 = findP(e);\\n            for(int i = 2; i <= sqrt(e); i++) {\\n                if((e%i) == 0) {\\n                    int p2 = findP(i), p3 = findP(e/i);\\n                    root[p2] = p1;\\n                    root[p3] = p1;\\n                }\\n            }\\n        }\\n\\n        unordered_map<int, int> mp;\\n        for(auto e : A) res = max(res, ++mp[findP(e)]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestComponentSize(vector<int>& A) {\\n        int root[100001]{}, res = 0;\\n        for(int i = 0; i < 100001; i++) root[i] = i;\\n\\n        auto findP = [&](int t) {\\n            while(t != root[t]) {\\n                root[t] = root[root[t]];\\n                t = root[t];\\n            }\\n            return t;\\n        };\\n\\n        for(auto e : A) {\\n            int p1 = findP(e);\\n            for(int i = 2; i <= sqrt(e); i++) {\\n                if((e%i) == 0) {\\n                    int p2 = findP(i), p3 = findP(e/i);\\n                    root[p2] = p1;\\n                    root[p3] = p1;\\n                }\\n            }\\n        }\\n\\n        unordered_map<int, int> mp;\\n        for(auto e : A) res = max(res, ++mp[findP(e)]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956437,
                "title": "python3-solution-beats-99",
                "content": "# Code\\n```\\nclass UnionFind: \\n    \\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [1]*n\\n        \\n    def find(self, p): \\n        if p != self.parent[p]: \\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union(self, p, q): \\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False \\n        if self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt\\n        self.parent[prt] = qrt\\n        self.rank[qrt] += self.rank[prt]\\n        return True \\n\\n\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        m = max(A)\\n        uf = UnionFind(m+1)\\n        seen = set(A)\\n        \\n        # modified sieve of eratosthenes \\n        sieve = [1]*(m+1)\\n        sieve[0] = sieve[1] = 0 \\n        for k in range(m//2+1): \\n            if sieve[k]: \\n                prev = k if k in seen else 0\\n                for x in range(2*k, m+1, k): \\n                    sieve[x] = 0\\n                    if x in seen: \\n                        if prev: uf.union(prev, x)\\n                        else: prev = x\\n        return max(uf.rank)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass UnionFind: \\n    \\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [1]*n\\n        \\n    def find(self, p): \\n        if p != self.parent[p]: \\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union(self, p, q): \\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False \\n        if self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt\\n        self.parent[prt] = qrt\\n        self.rank[qrt] += self.rank[prt]\\n        return True \\n\\n\\nclass Solution:\\n    def largestComponentSize(self, A: List[int]) -> int:\\n        m = max(A)\\n        uf = UnionFind(m+1)\\n        seen = set(A)\\n        \\n        # modified sieve of eratosthenes \\n        sieve = [1]*(m+1)\\n        sieve[0] = sieve[1] = 0 \\n        for k in range(m//2+1): \\n            if sieve[k]: \\n                prev = k if k in seen else 0\\n                for x in range(2*k, m+1, k): \\n                    sieve[x] = 0\\n                    if x in seen: \\n                        if prev: uf.union(prev, x)\\n                        else: prev = x\\n        return max(uf.rank)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887937,
                "title": "code-just-ran-on-edge-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMade a map in which each divisor contained a vector of the numbers in the list. Then made a graph and solved using dfs connected components\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint cc=0;\\n    void dfs(int i,vector<int> &vis,vector<vector<int> > &g){\\n        if(vis[i]){\\n            return;\\n        }\\n        cc++;\\n        vis[i]=1;\\n\\n        for(auto it: g[i]){\\n            \\n                dfs(it,vis,g);\\n        }\\n        return;\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n\\n        map<int,unordered_set<int> > m;\\n\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=2;j<=(sqrt(nums[i]));j++){\\n                if(nums[i]%j==0){\\n                    m[j].insert(i);\\n                    m[nums[i]/j].insert(i);\\n                }\\n               \\n            }\\n             m[nums[i]].insert(i);\\n        } \\n       /* \\n    for(auto it: m){\\n        cout<<it.first<<\"\\\\n\";\\n        for(auto kp:it.second){\\n            cout<<kp<<\" \";\\n        }\\n        cout<<\"\\\\n\";\\n\\n    }*/\\n        vector<vector<int> > g(nums.size());\\n\\n        for(auto it : m){\\n            //if(it.second.size()>1){\\n                auto kp = it.second.begin();\\n                auto op = it.second.begin();\\n                op++;\\n                while(op!=it.second.end()){\\n                    g[*op].push_back(*kp);\\n                    g[*kp].push_back(*op);\\n                    ++op;\\n                    ++kp;\\n                }\\n            \\n        }/*\\n for(int i=0;i<nums.size();i++){\\n            for(auto it: g[i]){\\n                cout<<it<<\" \";\\n            }\\n            cout<<\"\\\\n\";\\n        }*/\\n        vector<int> vis(nums.size(),0);\\nint ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(vis[i]==0){\\n                dfs(i,vis,g);\\n                ans=max(ans,cc);\\n                cc=0;\\n            }\\n        }\\n        return ans;\\n        \\n       \\n        return 0;\\n        \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint cc=0;\\n    void dfs(int i,vector<int> &vis,vector<vector<int> > &g){\\n        if(vis[i]){\\n            return;\\n        }\\n        cc++;\\n        vis[i]=1;\\n\\n        for(auto it: g[i]){\\n            \\n                dfs(it,vis,g);\\n        }\\n        return;\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n\\n        map<int,unordered_set<int> > m;\\n\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=2;j<=(sqrt(nums[i]));j++){\\n                if(nums[i]%j==0){\\n                    m[j].insert(i);\\n                    m[nums[i]/j].insert(i);\\n                }\\n               \\n            }\\n             m[nums[i]].insert(i);\\n        } \\n       /* \\n    for(auto it: m){\\n        cout<<it.first<<\"\\\\n\";\\n        for(auto kp:it.second){\\n            cout<<kp<<\" \";\\n        }\\n        cout<<\"\\\\n\";\\n\\n    }*/\\n        vector<vector<int> > g(nums.size());\\n\\n        for(auto it : m){\\n            //if(it.second.size()>1){\\n                auto kp = it.second.begin();\\n                auto op = it.second.begin();\\n                op++;\\n                while(op!=it.second.end()){\\n                    g[*op].push_back(*kp);\\n                    g[*kp].push_back(*op);\\n                    ++op;\\n                    ++kp;\\n                }\\n            \\n        }/*\\n for(int i=0;i<nums.size();i++){\\n            for(auto it: g[i]){\\n                cout<<it<<\" \";\\n            }\\n            cout<<\"\\\\n\";\\n        }*/\\n        vector<int> vis(nums.size(),0);\\nint ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(vis[i]==0){\\n                dfs(i,vis,g);\\n                ans=max(ans,cc);\\n                cc=0;\\n            }\\n        }\\n        return ans;\\n        \\n       \\n        return 0;\\n        \\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2828750,
                "title": "disjoint-set-prime-factorization-in-log-n-using-sieve-c",
                "content": "\\tclass Solution \\n\\t\\t{\\n\\t\\tprivate:\\n\\t\\tint findPar(vector<int>&parent,int node)\\n\\t\\t{\\n\\t\\t\\tif(node==parent[node])return node;\\n\\t\\t\\treturn parent[node] = findPar(parent,parent[node]);\\n\\t\\t}\\n\\t\\tvoid unite(vector<int>&size,vector<int>&parent,int u,int v)\\n\\t\\t{\\n\\t\\t\\tu = findPar(parent,u);\\n\\t\\t\\tv = findPar(parent,v);\\n\\t\\t\\tif(size[u]<size[v])\\n\\t\\t\\t{\\n\\t\\t\\t\\tparent[u] = v;\\n\\t\\t\\t\\tsize[v]+=size[u];\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tparent[v] = u;\\n\\t\\t\\t\\tsize[u]+=size[v];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvoid createSieve(vector<int>&sieve)\\n\\t\\t{\\n\\t\\t\\tfor(int i=2;i*i<=100000;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(sieve[i]==-1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfor(int j=i*i;j<=100000;j+=i)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tsieve[j] = i;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\tpublic:\\n\\t\\tint largestComponentSize(vector<int>& nums) \\n\\t\\t{\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<int>sieve(100001,-1);\\n\\t\\t\\tcreateSieve(sieve);\\n\\t\\t\\tmap<int,set<int>>mp;\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint x = nums[i];\\n\\t\\t\\t\\tint y = nums[i];\\n\\t\\t\\t\\tvector<int>temp;\\n\\t\\t\\t\\twhile(sieve[x]!=-1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp.push_back(sieve[x]);\\n\\t\\t\\t\\t\\tx/=sieve[x];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttemp.push_back(x);\\n\\t\\t\\t\\tfor(auto j:temp)mp[j].insert(i);\\n\\t\\t\\t}\\n\\t\\t\\tint m = mp.size();\\n\\t\\t\\tvector<int>parent(n+m,0),size(n+m,1);\\n\\t\\t\\tfor(int i=0;i<n+m;i++)parent[i] = i;\\n\\t\\t\\tint i = n-1;\\n\\t\\t\\tvector<pair<int,int>>edges;\\n\\t\\t\\tfor(auto it:mp)\\n\\t\\t\\t{\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tfor(auto j:it.second)edges.push_back({i,j});\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto i:edges)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint x = findPar(parent,i.first);\\n\\t\\t\\t\\tint y = findPar(parent,i.second);\\n\\t\\t\\t\\tif(x!=y)unite(size,parent,i.second,i.first);\\n\\t\\t\\t}\\n\\t\\t\\tmap<int,int>z;\\n\\t\\t\\tfor(int i=0;i<n;i++)z[findPar(parent,parent[i])]++;\\n\\t\\t\\tint maxi = 0;\\n\\t\\t\\tfor(auto i:z)maxi = max(maxi,i.second);\\n\\t\\t\\treturn maxi;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution \\n\\t\\t{\\n\\t\\tprivate:\\n\\t\\tint findPar(vector<int>&parent,int node)\\n\\t\\t{\\n\\t\\t\\tif(node==parent[node])return node;\\n\\t\\t\\treturn parent[node] = findPar(parent,parent[node]);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2821887,
                "title": "python-disjoint-set-solution-w-detailed-explanation",
                "content": "# Intuition\\nIt is clear that we need to use a disjoint set (aka union find) data structure for this problem. The first approach I tried was to iterate over each pair of elements in `nums`, check whether they share common factors, and union their set if they do. This results in O(N^2 * log(N)) time complexity and O(N) space complexity, which unfortunately raises TLE.\\nThe crux of the matter is to realize that we can group elements by their factors. This allows us to reduce for-loop iterations from O(N^2) to O(N * log(N)), as for each number we now only need to check all factors from 2 to `sqrt(x)`. \\nAs the official solution points out, we could further improve this solution by looping over prime factors only (which I did not implement).\\n\\n# Approach\\n1. For each element in `nums`, find all its factors. For each factor A, `union(x, A)` and `union(x, x // A)`.\\n2. Iterate over `nums` again to count the size of each set.\\n\\n# Complexity\\n- Time complexity:\\n    1. O(N * M * A(M)), where N is `len(nums)` and M is `max(nums)`. A() is the Ackermann function.\\n    2. O(N * A(M))\\nThus the total time complexity is O(N * M * A(M))\\n\\n- Space complexity:\\n    1. The disjoint set has size O(M)\\n    2. The counter has size O(N)\\nThus the total space complexity is O(M)\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass DisjointSet:\\n    def __init__(self, size):\\n        self.parent = list(range(size+1))\\n        self.size = [1 for _ in range(size+1)]\\n    \\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n        parent_x, parent_y = self.find(x), self.find(y)\\n        if parent_x == parent_y: return \\n        if self.size[parent_x] < self.size[parent_y]:\\n            self.parent[parent_x] = parent_y \\n            self.size[parent_y] += self.size[parent_x]\\n            return parent_y \\n        else:\\n            self.parent[parent_y] = parent_x \\n            self.size[parent_x] += self.size[parent_y]\\n            return parent_x\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        ds = DisjointSet(max(nums))\\n        for x in nums:\\n            for A in range(2, int(sqrt(x)) + 1):\\n                if x % A == 0:\\n                    ds.union(x, A)\\n                    ds.union(x, x // A)\\n        # find the max size among all sets\\n        c = Counter()\\n        for n in nums:\\n            c[ds.find(n)] += 1\\n        return max(c.values())\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass DisjointSet:\\n    def __init__(self, size):\\n        self.parent = list(range(size+1))\\n        self.size = [1 for _ in range(size+1)]\\n    \\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n        parent_x, parent_y = self.find(x), self.find(y)\\n        if parent_x == parent_y: return \\n        if self.size[parent_x] < self.size[parent_y]:\\n            self.parent[parent_x] = parent_y \\n            self.size[parent_y] += self.size[parent_x]\\n            return parent_y \\n        else:\\n            self.parent[parent_y] = parent_x \\n            self.size[parent_x] += self.size[parent_y]\\n            return parent_x\\n\\nclass Solution:\\n    def largestComponentSize(self, nums: List[int]) -> int:\\n        ds = DisjointSet(max(nums))\\n        for x in nums:\\n            for A in range(2, int(sqrt(x)) + 1):\\n                if x % A == 0:\\n                    ds.union(x, A)\\n                    ds.union(x, x // A)\\n        # find the max size among all sets\\n        c = Counter()\\n        for n in nums:\\n            c[ds.find(n)] += 1\\n        return max(c.values())\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776285,
                "title": "hashing-and-dsu",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static const int N =  1e5 +5;\\n    int n; \\n    int vis[N] = {0};\\n    int par[N];\\n    int rank[N] = {1};\\n    vector<int>prime;\\n\\n    void init(){\\n        for( int i = 0 ; i<N ; ++i ){\\n             par[i] = i;\\n            rank[i] = 1;\\n            if(vis[i]==1 || i<2 )continue;\\n            for( int j = i ; j<N ; j = 1ll*(j+i)){\\n                vis[j] = 1;\\n            }\\n            prime.emplace_back(i);\\n        }\\n    }\\n\\n\\n    int find_par( int node ){\\n        if(node == par[node])return node;\\n        return par[node] = find_par(par[node]);\\n    }\\n\\n\\n    void merge( int x , int y ){\\n        x = find_par(x);\\n        y = find_par(y);\\n\\n        if(x==y)\\n            return ;\\n            \\n        if(rank[x]==rank[y]){\\n            par[y] = x;\\n            rank[x] += 1;\\n        }\\n        else{\\n            if(rank[x] >  rank[y]){\\n                par[y] = x;\\n                rank[x] += rank[y];\\n            }\\n            else{\\n                par[x] = y;\\n                rank[y] += rank[x];\\n            }\\n        }\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n        init();\\n     \\n        unordered_map<int , int >int_mp;\\n\\n        for( int i = 0 ; i<nums.size() ; ++i  ){\\n              int_mp[nums[i]] = i;\\n        }\\n\\n\\n      \\n\\n        for( int p : prime  ){\\n            vector<int>temp;\\n            for( int x = p ; x<N ; x += p ){\\n                if(int_mp.find(x) != int_mp.end())\\n                      temp.emplace_back(int_mp[x]);\\n            }\\n            \\n            for( int i = 1  ; i<temp.size() ; ++i ){\\n                merge(temp[i] , temp[i-1]);\\n            }\\n            \\n            //cout<<temp.size()<<\"\\\\n\";\\n        }\\n\\n        \\n        int cnt = 1 ;\\n        unordered_map<int , int>mp;\\n        for( int x = 0  ; x<nums.size() ; ++x ){\\n            int p  = find_par(x);\\n            mp[p] += 1;\\n            cnt = max( cnt , mp[p]);\\n        }\\n        return cnt ;\\n        \\n        //return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static const int N =  1e5 +5;\\n    int n; \\n    int vis[N] = {0};\\n    int par[N];\\n    int rank[N] = {1};\\n    vector<int>prime;\\n\\n    void init(){\\n        for( int i = 0 ; i<N ; ++i ){\\n             par[i] = i;\\n            rank[i] = 1;\\n            if(vis[i]==1 || i<2 )continue;\\n            for( int j = i ; j<N ; j = 1ll*(j+i)){\\n                vis[j] = 1;\\n            }\\n            prime.emplace_back(i);\\n        }\\n    }\\n\\n\\n    int find_par( int node ){\\n        if(node == par[node])return node;\\n        return par[node] = find_par(par[node]);\\n    }\\n\\n\\n    void merge( int x , int y ){\\n        x = find_par(x);\\n        y = find_par(y);\\n\\n        if(x==y)\\n            return ;\\n            \\n        if(rank[x]==rank[y]){\\n            par[y] = x;\\n            rank[x] += 1;\\n        }\\n        else{\\n            if(rank[x] >  rank[y]){\\n                par[y] = x;\\n                rank[x] += rank[y];\\n            }\\n            else{\\n                par[x] = y;\\n                rank[y] += rank[x];\\n            }\\n        }\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n        init();\\n     \\n        unordered_map<int , int >int_mp;\\n\\n        for( int i = 0 ; i<nums.size() ; ++i  ){\\n              int_mp[nums[i]] = i;\\n        }\\n\\n\\n      \\n\\n        for( int p : prime  ){\\n            vector<int>temp;\\n            for( int x = p ; x<N ; x += p ){\\n                if(int_mp.find(x) != int_mp.end())\\n                      temp.emplace_back(int_mp[x]);\\n            }\\n            \\n            for( int i = 1  ; i<temp.size() ; ++i ){\\n                merge(temp[i] , temp[i-1]);\\n            }\\n            \\n            //cout<<temp.size()<<\"\\\\n\";\\n        }\\n\\n        \\n        int cnt = 1 ;\\n        unordered_map<int , int>mp;\\n        for( int x = 0  ; x<nums.size() ; ++x ){\\n            int p  = find_par(x);\\n            mp[p] += 1;\\n            cnt = max( cnt , mp[p]);\\n        }\\n        return cnt ;\\n        \\n        //return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2775966,
                "title": "dsu",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static const int N =  1e5 +5;\\n    int n; \\n    int vis[N] ;\\n    int par[N];\\n    int rank[N] = {1};\\n    vector<int>prime;\\n    \\n\\n    void init(){\\n        for( int i = 1 ; i< N ; ++i ){\\n            vis[i] = i;\\n            par[i] = i;\\n            rank[i] =1;\\n        }\\n        for( int i = 2 ; i*i<N ; ++i ){\\n            if(vis[i]==i){\\n                for( int j = 1ll*i*i ; j< N ;  j = j + i ){\\n                    if(vis[j]==j){\\n                        vis[j] = i;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n\\n    int find_par( int node ){\\n        if(node == par[node])return node;\\n        return par[node] = find_par(par[node]);\\n    }\\n\\n\\n    void merge( int x , int y ){\\n        x = find_par(x);\\n        y = find_par(y);\\n\\n        if(x==y)\\n            return ;\\n\\n        if(rank[x]==rank[y]){\\n            par[y] = x;\\n            rank[x] += 1;\\n        }\\n        else{\\n            if(rank[x] >  rank[y]){\\n                par[y] = x;\\n                rank[x] += rank[y];\\n            }\\n            else{\\n                par[x] = y;\\n                rank[y] += rank[x];\\n            }\\n        }\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n       \\n        init();\\n        vector<int>temp;\\n        for( int x : nums  ){\\n            temp.clear();\\n            int n = x;\\n            if(n==1) continue;\\n            while(n != 1 ){\\n                int p  = vis[n];\\n                temp.emplace_back(p);\\n                while( n % p == 0 ){\\n                    n = n/p;\\n                }\\n            }\\n            for( int i = 0  ; i<temp.size()-1 ; ++i ){\\n                merge(temp[i] , temp[i+1]);\\n            }\\n            // cout<<x<<\"->\";\\n            // for(auto u :  temp ){\\n            //     cout<<u<<\" \";\\n            //   }\\n            //   printf(\"\\\\n\");\\n        }\\n\\n        int cnt = 1 ;\\n        unordered_map<int , int>mp;\\n        for( int x :  nums ){\\n            int y = -1;\\n            for( int i =  2 ; i*i <= x ; ++i  ){\\n                if(x% i  == 0 ){\\n                    y = i ;\\n                    break;\\n                }\\n            }\\n            if(y==-1){\\n                y = x;\\n            }\\n            \\n            int p  = find_par(y);\\n            mp[p] += 1;\\n            cnt = max( cnt , mp[p]);\\n        }\\n        return cnt ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static const int N =  1e5 +5;\\n    int n; \\n    int vis[N] ;\\n    int par[N];\\n    int rank[N] = {1};\\n    vector<int>prime;\\n    \\n\\n    void init(){\\n        for( int i = 1 ; i< N ; ++i ){\\n            vis[i] = i;\\n            par[i] = i;\\n            rank[i] =1;\\n        }\\n        for( int i = 2 ; i*i<N ; ++i ){\\n            if(vis[i]==i){\\n                for( int j = 1ll*i*i ; j< N ;  j = j + i ){\\n                    if(vis[j]==j){\\n                        vis[j] = i;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n\\n    int find_par( int node ){\\n        if(node == par[node])return node;\\n        return par[node] = find_par(par[node]);\\n    }\\n\\n\\n    void merge( int x , int y ){\\n        x = find_par(x);\\n        y = find_par(y);\\n\\n        if(x==y)\\n            return ;\\n\\n        if(rank[x]==rank[y]){\\n            par[y] = x;\\n            rank[x] += 1;\\n        }\\n        else{\\n            if(rank[x] >  rank[y]){\\n                par[y] = x;\\n                rank[x] += rank[y];\\n            }\\n            else{\\n                par[x] = y;\\n                rank[y] += rank[x];\\n            }\\n        }\\n    }\\n\\n    int largestComponentSize(vector<int>& nums) {\\n       \\n        init();\\n        vector<int>temp;\\n        for( int x : nums  ){\\n            temp.clear();\\n            int n = x;\\n            if(n==1) continue;\\n            while(n != 1 ){\\n                int p  = vis[n];\\n                temp.emplace_back(p);\\n                while( n % p == 0 ){\\n                    n = n/p;\\n                }\\n            }\\n            for( int i = 0  ; i<temp.size()-1 ; ++i ){\\n                merge(temp[i] , temp[i+1]);\\n            }\\n            // cout<<x<<\"->\";\\n            // for(auto u :  temp ){\\n            //     cout<<u<<\" \";\\n            //   }\\n            //   printf(\"\\\\n\");\\n        }\\n\\n        int cnt = 1 ;\\n        unordered_map<int , int>mp;\\n        for( int x :  nums ){\\n            int y = -1;\\n            for( int i =  2 ; i*i <= x ; ++i  ){\\n                if(x% i  == 0 ){\\n                    y = i ;\\n                    break;\\n                }\\n            }\\n            if(y==-1){\\n                y = x;\\n            }\\n            \\n            int p  = find_par(y);\\n            mp[p] += 1;\\n            cnt = max( cnt , mp[p]);\\n        }\\n        return cnt ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2773863,
                "title": "swift-491-ms",
                "content": "```\\nclass Solution {\\n    func largestComponentSize(_ nums: [Int]) -> Int {\\n        let n = nums.count\\n        guard n > 1 else { return n }\\n        let groups = dividersGroups(nums)\\n        var graph = Array(0 ..< n)\\n        for items in groups.values {\\n            guard items.count > 1 else { continue }\\n            var parent = -1\\n            for i in items {\\n                if parent < 0 {\\n                    parent = searchParent(i, &graph)\\n                } else {\\n                    let p2 = searchParent(i, &graph)\\n                    if parent != p2 { graph[p2] = parent }\\n                }\\n            }\\n        }\\n        var counts = Array(repeating: 0, count: n)\\n        var maxCount = 0\\n        for i in 0 ..< n {\\n            let p = searchParent(i, &graph)\\n            counts[p] += 1\\n            maxCount = max(maxCount, counts[p])\\n        }\\n        return maxCount\\n    }\\n\\n    private func searchParent(_ e: Int, _ graph: inout [Int]) -> Int {\\n        if graph[e] == e { return e }\\n        graph[e] = searchParent(graph[e], &graph)\\n        return graph[e]\\n    }\\n\\n    // Returns map simpleNum -> [indexes in nums with simpleNum factor]\\n    private func dividersGroups(_ nums: [Int]) -> [Int: [Int]] {\\n        var simpleNums = [2, 3]\\n        var simplesMap: [Int: [Int]] = [:]\\n\\n        let addDivider: (Int, Int) -> Void = { s, i in\\n            if simplesMap[s] == nil {\\n                simplesMap[s] = [i]\\n            } else {\\n                simplesMap[s]?.append(i)\\n            }\\n        }\\n\\n        for (i, n) in nums.enumerated() {\\n            let sMax = Int(sqrt(Double(n)))\\n            var j = simpleNums.last!\\n            while j <= sMax {\\n                j += 2\\n                while simpleNums.contains(where: { j % $0 == 0 }) { j += 2 }\\n                simpleNums.append(j)\\n            }\\n            var n1 = n\\n            for s in simpleNums {\\n                if s > sMax || n1 < 2 { break }\\n                if n1 % s == 0 {\\n                    addDivider(s, i)\\n                    while n1 % s == 0 { n1 /= s }\\n                }\\n            }\\n            if n1 > 1 {\\n                addDivider(n1, i)\\n            }\\n        }\\n        return simplesMap\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func largestComponentSize(_ nums: [Int]) -> Int {\\n        let n = nums.count\\n        guard n > 1 else { return n }\\n        let groups = dividersGroups(nums)\\n        var graph = Array(0 ..< n)\\n        for items in groups.values {\\n            guard items.count > 1 else { continue }\\n            var parent = -1\\n            for i in items {\\n                if parent < 0 {\\n                    parent = searchParent(i, &graph)\\n                } else {\\n                    let p2 = searchParent(i, &graph)\\n                    if parent != p2 { graph[p2] = parent }\\n                }\\n            }\\n        }\\n        var counts = Array(repeating: 0, count: n)\\n        var maxCount = 0\\n        for i in 0 ..< n {\\n            let p = searchParent(i, &graph)\\n            counts[p] += 1\\n            maxCount = max(maxCount, counts[p])\\n        }\\n        return maxCount\\n    }\\n\\n    private func searchParent(_ e: Int, _ graph: inout [Int]) -> Int {\\n        if graph[e] == e { return e }\\n        graph[e] = searchParent(graph[e], &graph)\\n        return graph[e]\\n    }\\n\\n    // Returns map simpleNum -> [indexes in nums with simpleNum factor]\\n    private func dividersGroups(_ nums: [Int]) -> [Int: [Int]] {\\n        var simpleNums = [2, 3]\\n        var simplesMap: [Int: [Int]] = [:]\\n\\n        let addDivider: (Int, Int) -> Void = { s, i in\\n            if simplesMap[s] == nil {\\n                simplesMap[s] = [i]\\n            } else {\\n                simplesMap[s]?.append(i)\\n            }\\n        }\\n\\n        for (i, n) in nums.enumerated() {\\n            let sMax = Int(sqrt(Double(n)))\\n            var j = simpleNums.last!\\n            while j <= sMax {\\n                j += 2\\n                while simpleNums.contains(where: { j % $0 == 0 }) { j += 2 }\\n                simpleNums.append(j)\\n            }\\n            var n1 = n\\n            for s in simpleNums {\\n                if s > sMax || n1 < 2 { break }\\n                if n1 % s == 0 {\\n                    addDivider(s, i)\\n                    while n1 % s == 0 { n1 /= s }\\n                }\\n            }\\n            if n1 > 1 {\\n                addDivider(n1, i)\\n            }\\n        }\\n        return simplesMap\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565219,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-component-size-by-common-factor/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Union-Find via Factors \n\n  \n**Approach 2:** Union-Find on Prime Factors\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Horopter",
                        "content": "I\\'d like to report a spurious test case : [641,645,135,108,394,652,525,532,536,28,414,543,549,926,625,540,812,181,698,572,829,318,447,962,709,199,585,459,335,594,83,468,854,761,856,478,991,993,355,359,700,747,236,624,113,596,125]"
                    },
                    {
                        "username": "selder02",
                        "content": "I just wanted to comment on the constraints, and why I think they are poorly chosen. Say there are N elements and the maximum is M, and \\u03B1 is the inverse Ackermann function.\\n\\nThere are two main ways to solve this:\\n\\n* iterate over each number and compute all its factors. The runtime is O(N sqrt(M) \\u03B1(N)) since there are up to sqrt(M) factors of each number.\\n* iterate over all pairs of numbers and compute their GCF. The runtime is O(N^2 log(M) \\u03B1(N)) since the Euclidean algorithm runs in log(M) time.\\n\\nIn each case we use a union-find data structure, hence the \\u03B1(N)\\'s.\\n\\nThe second approach times out, but the first is accepted.\\n\\nMy complaint is that the first is only pseudopolynomial (polynomial in the size of the integers themselves), i.e. exponential in the size of the problem (the number of digits or bits in the input). It would blow up for larger problems, e.g. with long long inputs.\\n\\nThe second times out even though it\\'s truly polynomial.\\n\\nMoreover, sqrt(M) is not that much smaller than N, so the runtimes are not so vastly different.\\n\\nIt\\'s annoying to build a reasonable algorithm, and then have it time out. It should be more clear from the inputs which solutions will time out and which won\\'t."
                    },
                    {
                        "username": "sakuragrass",
                        "content": "According to the defination, \\n``\\nThere is an edge between A[i] and A[j] if and only if A[i] and A[j] share a common factor greater than 1.\\n``\\nThe two 1s are not connected as they only have the common factor 1 which is not greater than 1. Hence they are 4 isolated nodes, the output should be 1."
                    },
                    {
                        "username": "Rounak225",
                        "content": "I tried this by making a graph and going ahead with DFS. It passed 74/108 cases, and timed out for the rest. Guess it needs a better run time than O(n^2)"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Use Algorithm to Find All the distinct sets for given input array\\n2) Using A Map To Keep Tracking The No Of Nodes For All Distinct Subsets.\\n3) Take The Maximum Value.\\n4) Return The Maximum Value.\\n\\nCode (Please try it out first on your own) :- \\n\\nhttps://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Largest%20Component%20Size%20by%20Common%20Factor%20Day30.java\\n\\nExplanation :- \\nhttps://youtu.be/hP_ZxutreCE\\n"
                    },
                    {
                        "username": "shadyysf",
                        "content": "Something weird is happening for me. I pass all the 108 test cases but I still get TLE. The test case that fails the time limit is totally empty. I think there\\'s a bug in the test code or something."
                    }
                ]
            },
            {
                "id": 1570682,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-component-size-by-common-factor/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Union-Find via Factors \n\n  \n**Approach 2:** Union-Find on Prime Factors\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Horopter",
                        "content": "I\\'d like to report a spurious test case : [641,645,135,108,394,652,525,532,536,28,414,543,549,926,625,540,812,181,698,572,829,318,447,962,709,199,585,459,335,594,83,468,854,761,856,478,991,993,355,359,700,747,236,624,113,596,125]"
                    },
                    {
                        "username": "selder02",
                        "content": "I just wanted to comment on the constraints, and why I think they are poorly chosen. Say there are N elements and the maximum is M, and \\u03B1 is the inverse Ackermann function.\\n\\nThere are two main ways to solve this:\\n\\n* iterate over each number and compute all its factors. The runtime is O(N sqrt(M) \\u03B1(N)) since there are up to sqrt(M) factors of each number.\\n* iterate over all pairs of numbers and compute their GCF. The runtime is O(N^2 log(M) \\u03B1(N)) since the Euclidean algorithm runs in log(M) time.\\n\\nIn each case we use a union-find data structure, hence the \\u03B1(N)\\'s.\\n\\nThe second approach times out, but the first is accepted.\\n\\nMy complaint is that the first is only pseudopolynomial (polynomial in the size of the integers themselves), i.e. exponential in the size of the problem (the number of digits or bits in the input). It would blow up for larger problems, e.g. with long long inputs.\\n\\nThe second times out even though it\\'s truly polynomial.\\n\\nMoreover, sqrt(M) is not that much smaller than N, so the runtimes are not so vastly different.\\n\\nIt\\'s annoying to build a reasonable algorithm, and then have it time out. It should be more clear from the inputs which solutions will time out and which won\\'t."
                    },
                    {
                        "username": "sakuragrass",
                        "content": "According to the defination, \\n``\\nThere is an edge between A[i] and A[j] if and only if A[i] and A[j] share a common factor greater than 1.\\n``\\nThe two 1s are not connected as they only have the common factor 1 which is not greater than 1. Hence they are 4 isolated nodes, the output should be 1."
                    },
                    {
                        "username": "Rounak225",
                        "content": "I tried this by making a graph and going ahead with DFS. It passed 74/108 cases, and timed out for the rest. Guess it needs a better run time than O(n^2)"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Use Algorithm to Find All the distinct sets for given input array\\n2) Using A Map To Keep Tracking The No Of Nodes For All Distinct Subsets.\\n3) Take The Maximum Value.\\n4) Return The Maximum Value.\\n\\nCode (Please try it out first on your own) :- \\n\\nhttps://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Largest%20Component%20Size%20by%20Common%20Factor%20Day30.java\\n\\nExplanation :- \\nhttps://youtu.be/hP_ZxutreCE\\n"
                    },
                    {
                        "username": "shadyysf",
                        "content": "Something weird is happening for me. I pass all the 108 test cases but I still get TLE. The test case that fails the time limit is totally empty. I think there\\'s a bug in the test code or something."
                    }
                ]
            },
            {
                "id": 1569460,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-component-size-by-common-factor/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Union-Find via Factors \n\n  \n**Approach 2:** Union-Find on Prime Factors\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Horopter",
                        "content": "I\\'d like to report a spurious test case : [641,645,135,108,394,652,525,532,536,28,414,543,549,926,625,540,812,181,698,572,829,318,447,962,709,199,585,459,335,594,83,468,854,761,856,478,991,993,355,359,700,747,236,624,113,596,125]"
                    },
                    {
                        "username": "selder02",
                        "content": "I just wanted to comment on the constraints, and why I think they are poorly chosen. Say there are N elements and the maximum is M, and \\u03B1 is the inverse Ackermann function.\\n\\nThere are two main ways to solve this:\\n\\n* iterate over each number and compute all its factors. The runtime is O(N sqrt(M) \\u03B1(N)) since there are up to sqrt(M) factors of each number.\\n* iterate over all pairs of numbers and compute their GCF. The runtime is O(N^2 log(M) \\u03B1(N)) since the Euclidean algorithm runs in log(M) time.\\n\\nIn each case we use a union-find data structure, hence the \\u03B1(N)\\'s.\\n\\nThe second approach times out, but the first is accepted.\\n\\nMy complaint is that the first is only pseudopolynomial (polynomial in the size of the integers themselves), i.e. exponential in the size of the problem (the number of digits or bits in the input). It would blow up for larger problems, e.g. with long long inputs.\\n\\nThe second times out even though it\\'s truly polynomial.\\n\\nMoreover, sqrt(M) is not that much smaller than N, so the runtimes are not so vastly different.\\n\\nIt\\'s annoying to build a reasonable algorithm, and then have it time out. It should be more clear from the inputs which solutions will time out and which won\\'t."
                    },
                    {
                        "username": "sakuragrass",
                        "content": "According to the defination, \\n``\\nThere is an edge between A[i] and A[j] if and only if A[i] and A[j] share a common factor greater than 1.\\n``\\nThe two 1s are not connected as they only have the common factor 1 which is not greater than 1. Hence they are 4 isolated nodes, the output should be 1."
                    },
                    {
                        "username": "Rounak225",
                        "content": "I tried this by making a graph and going ahead with DFS. It passed 74/108 cases, and timed out for the rest. Guess it needs a better run time than O(n^2)"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Use Algorithm to Find All the distinct sets for given input array\\n2) Using A Map To Keep Tracking The No Of Nodes For All Distinct Subsets.\\n3) Take The Maximum Value.\\n4) Return The Maximum Value.\\n\\nCode (Please try it out first on your own) :- \\n\\nhttps://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Largest%20Component%20Size%20by%20Common%20Factor%20Day30.java\\n\\nExplanation :- \\nhttps://youtu.be/hP_ZxutreCE\\n"
                    },
                    {
                        "username": "shadyysf",
                        "content": "Something weird is happening for me. I pass all the 108 test cases but I still get TLE. The test case that fails the time limit is totally empty. I think there\\'s a bug in the test code or something."
                    }
                ]
            },
            {
                "id": 1687702,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-component-size-by-common-factor/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Union-Find via Factors \n\n  \n**Approach 2:** Union-Find on Prime Factors\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Horopter",
                        "content": "I\\'d like to report a spurious test case : [641,645,135,108,394,652,525,532,536,28,414,543,549,926,625,540,812,181,698,572,829,318,447,962,709,199,585,459,335,594,83,468,854,761,856,478,991,993,355,359,700,747,236,624,113,596,125]"
                    },
                    {
                        "username": "selder02",
                        "content": "I just wanted to comment on the constraints, and why I think they are poorly chosen. Say there are N elements and the maximum is M, and \\u03B1 is the inverse Ackermann function.\\n\\nThere are two main ways to solve this:\\n\\n* iterate over each number and compute all its factors. The runtime is O(N sqrt(M) \\u03B1(N)) since there are up to sqrt(M) factors of each number.\\n* iterate over all pairs of numbers and compute their GCF. The runtime is O(N^2 log(M) \\u03B1(N)) since the Euclidean algorithm runs in log(M) time.\\n\\nIn each case we use a union-find data structure, hence the \\u03B1(N)\\'s.\\n\\nThe second approach times out, but the first is accepted.\\n\\nMy complaint is that the first is only pseudopolynomial (polynomial in the size of the integers themselves), i.e. exponential in the size of the problem (the number of digits or bits in the input). It would blow up for larger problems, e.g. with long long inputs.\\n\\nThe second times out even though it\\'s truly polynomial.\\n\\nMoreover, sqrt(M) is not that much smaller than N, so the runtimes are not so vastly different.\\n\\nIt\\'s annoying to build a reasonable algorithm, and then have it time out. It should be more clear from the inputs which solutions will time out and which won\\'t."
                    },
                    {
                        "username": "sakuragrass",
                        "content": "According to the defination, \\n``\\nThere is an edge between A[i] and A[j] if and only if A[i] and A[j] share a common factor greater than 1.\\n``\\nThe two 1s are not connected as they only have the common factor 1 which is not greater than 1. Hence they are 4 isolated nodes, the output should be 1."
                    },
                    {
                        "username": "Rounak225",
                        "content": "I tried this by making a graph and going ahead with DFS. It passed 74/108 cases, and timed out for the rest. Guess it needs a better run time than O(n^2)"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Use Algorithm to Find All the distinct sets for given input array\\n2) Using A Map To Keep Tracking The No Of Nodes For All Distinct Subsets.\\n3) Take The Maximum Value.\\n4) Return The Maximum Value.\\n\\nCode (Please try it out first on your own) :- \\n\\nhttps://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Largest%20Component%20Size%20by%20Common%20Factor%20Day30.java\\n\\nExplanation :- \\nhttps://youtu.be/hP_ZxutreCE\\n"
                    },
                    {
                        "username": "shadyysf",
                        "content": "Something weird is happening for me. I pass all the 108 test cases but I still get TLE. The test case that fails the time limit is totally empty. I think there\\'s a bug in the test code or something."
                    }
                ]
            },
            {
                "id": 1574300,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-component-size-by-common-factor/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Union-Find via Factors \n\n  \n**Approach 2:** Union-Find on Prime Factors\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Horopter",
                        "content": "I\\'d like to report a spurious test case : [641,645,135,108,394,652,525,532,536,28,414,543,549,926,625,540,812,181,698,572,829,318,447,962,709,199,585,459,335,594,83,468,854,761,856,478,991,993,355,359,700,747,236,624,113,596,125]"
                    },
                    {
                        "username": "selder02",
                        "content": "I just wanted to comment on the constraints, and why I think they are poorly chosen. Say there are N elements and the maximum is M, and \\u03B1 is the inverse Ackermann function.\\n\\nThere are two main ways to solve this:\\n\\n* iterate over each number and compute all its factors. The runtime is O(N sqrt(M) \\u03B1(N)) since there are up to sqrt(M) factors of each number.\\n* iterate over all pairs of numbers and compute their GCF. The runtime is O(N^2 log(M) \\u03B1(N)) since the Euclidean algorithm runs in log(M) time.\\n\\nIn each case we use a union-find data structure, hence the \\u03B1(N)\\'s.\\n\\nThe second approach times out, but the first is accepted.\\n\\nMy complaint is that the first is only pseudopolynomial (polynomial in the size of the integers themselves), i.e. exponential in the size of the problem (the number of digits or bits in the input). It would blow up for larger problems, e.g. with long long inputs.\\n\\nThe second times out even though it\\'s truly polynomial.\\n\\nMoreover, sqrt(M) is not that much smaller than N, so the runtimes are not so vastly different.\\n\\nIt\\'s annoying to build a reasonable algorithm, and then have it time out. It should be more clear from the inputs which solutions will time out and which won\\'t."
                    },
                    {
                        "username": "sakuragrass",
                        "content": "According to the defination, \\n``\\nThere is an edge between A[i] and A[j] if and only if A[i] and A[j] share a common factor greater than 1.\\n``\\nThe two 1s are not connected as they only have the common factor 1 which is not greater than 1. Hence they are 4 isolated nodes, the output should be 1."
                    },
                    {
                        "username": "Rounak225",
                        "content": "I tried this by making a graph and going ahead with DFS. It passed 74/108 cases, and timed out for the rest. Guess it needs a better run time than O(n^2)"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Use Algorithm to Find All the distinct sets for given input array\\n2) Using A Map To Keep Tracking The No Of Nodes For All Distinct Subsets.\\n3) Take The Maximum Value.\\n4) Return The Maximum Value.\\n\\nCode (Please try it out first on your own) :- \\n\\nhttps://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Largest%20Component%20Size%20by%20Common%20Factor%20Day30.java\\n\\nExplanation :- \\nhttps://youtu.be/hP_ZxutreCE\\n"
                    },
                    {
                        "username": "shadyysf",
                        "content": "Something weird is happening for me. I pass all the 108 test cases but I still get TLE. The test case that fails the time limit is totally empty. I think there\\'s a bug in the test code or something."
                    }
                ]
            },
            {
                "id": 1981975,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/largest-component-size-by-common-factor/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Union-Find via Factors \n\n  \n**Approach 2:** Union-Find on Prime Factors\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Horopter",
                        "content": "I\\'d like to report a spurious test case : [641,645,135,108,394,652,525,532,536,28,414,543,549,926,625,540,812,181,698,572,829,318,447,962,709,199,585,459,335,594,83,468,854,761,856,478,991,993,355,359,700,747,236,624,113,596,125]"
                    },
                    {
                        "username": "selder02",
                        "content": "I just wanted to comment on the constraints, and why I think they are poorly chosen. Say there are N elements and the maximum is M, and \\u03B1 is the inverse Ackermann function.\\n\\nThere are two main ways to solve this:\\n\\n* iterate over each number and compute all its factors. The runtime is O(N sqrt(M) \\u03B1(N)) since there are up to sqrt(M) factors of each number.\\n* iterate over all pairs of numbers and compute their GCF. The runtime is O(N^2 log(M) \\u03B1(N)) since the Euclidean algorithm runs in log(M) time.\\n\\nIn each case we use a union-find data structure, hence the \\u03B1(N)\\'s.\\n\\nThe second approach times out, but the first is accepted.\\n\\nMy complaint is that the first is only pseudopolynomial (polynomial in the size of the integers themselves), i.e. exponential in the size of the problem (the number of digits or bits in the input). It would blow up for larger problems, e.g. with long long inputs.\\n\\nThe second times out even though it\\'s truly polynomial.\\n\\nMoreover, sqrt(M) is not that much smaller than N, so the runtimes are not so vastly different.\\n\\nIt\\'s annoying to build a reasonable algorithm, and then have it time out. It should be more clear from the inputs which solutions will time out and which won\\'t."
                    },
                    {
                        "username": "sakuragrass",
                        "content": "According to the defination, \\n``\\nThere is an edge between A[i] and A[j] if and only if A[i] and A[j] share a common factor greater than 1.\\n``\\nThe two 1s are not connected as they only have the common factor 1 which is not greater than 1. Hence they are 4 isolated nodes, the output should be 1."
                    },
                    {
                        "username": "Rounak225",
                        "content": "I tried this by making a graph and going ahead with DFS. It passed 74/108 cases, and timed out for the rest. Guess it needs a better run time than O(n^2)"
                    },
                    {
                        "username": "Souvik93",
                        "content": "Algorithm :-\\n\\n1) Use Algorithm to Find All the distinct sets for given input array\\n2) Using A Map To Keep Tracking The No Of Nodes For All Distinct Subsets.\\n3) Take The Maximum Value.\\n4) Return The Maximum Value.\\n\\nCode (Please try it out first on your own) :- \\n\\nhttps://github.com/Souvik93/August-LeetCoding-Challenge/blob/master/Largest%20Component%20Size%20by%20Common%20Factor%20Day30.java\\n\\nExplanation :- \\nhttps://youtu.be/hP_ZxutreCE\\n"
                    },
                    {
                        "username": "shadyysf",
                        "content": "Something weird is happening for me. I pass all the 108 test cases but I still get TLE. The test case that fails the time limit is totally empty. I think there\\'s a bug in the test code or something."
                    }
                ]
            }
        ]
    }
]