[
    {
        "title": "Most Common Word",
        "question_content": "Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique.\nThe words in paragraph are case-insensitive and the answer should be returned in lowercase.\n&nbsp;\nExample 1:\n\nInput: paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\", banned = [\"hit\"]\nOutput: \"ball\"\nExplanation: \n\"hit\" occurs 3 times, but it is a banned word.\n\"ball\" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. \nNote that words in the paragraph are not case sensitive,\nthat punctuation is ignored (even if adjacent to words, such as \"ball,\"), \nand that \"hit\" isn't the answer even though it occurs more because it is banned.\n\nExample 2:\n\nInput: paragraph = \"a.\", banned = []\nOutput: \"a\"\n\n&nbsp;\nConstraints:\n\n\t1 <= paragraph.length <= 1000\n\tparagraph consists of English letters, space ' ', or one of the symbols: \"!?',;.\".\n\t0 <= banned.length <= 100\n\t1 <= banned[i].length <= 10\n\tbanned[i] consists of only lowercase English letters.",
        "solutions": [
            {
                "id": 123854,
                "title": "c-java-python-easy-solution-with-explanation",
                "content": "The description doesn\\'t clearify the case like \"word,word,word\".\\nAnd it doesn\\'t have this kind of corner cases at first.\\nThe test cases and OJ may not be perfect on this problem.\\n\\nAnyway I didn\\'t bother thinking this issue.\\nIn my opinion, the problem demands to extract words with only letters.\\nAll I did is just extract words with only letters.\\n\\n4 steps:\\n1. remove all punctuations\\n2. change to lowercase\\n3. words count for each word not in banned set\\n4. return the most common word\\n\\n**C++:**\\n```\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        unordered_set<string> ban(banned.begin(), banned.end());\\n        unordered_map<string, int> count;\\n        for (auto & c: p) c = isalpha(c) ? tolower(c) : \\' \\';\\n        istringstream iss(p);\\n        string w;\\n        pair<string, int> res (\"\", 0);\\n        while (iss >> w)\\n            if (ban.find(w) == ban.end() && ++count[w] > res.second)\\n                res = make_pair(w, count[w]);\\n        return res.first;\\n    }\\n```\\n**Java:**\\n```\\n    public String mostCommonWord(String p, String[] banned) {\\n        Set<String> ban = new HashSet<>(Arrays.asList(banned));\\n        Map<String, Integer> count = new HashMap<>();\\n        String[] words = p.replaceAll(\"\\\\\\\\W+\" , \" \").toLowerCase().split(\"\\\\\\\\s+\");\\n        for (String w : words) if (!ban.contains(w)) count.put(w, count.getOrDefault(w, 0) + 1);\\n        return Collections.max(count.entrySet(), Map.Entry.comparingByValue()).getKey();\\n    }\\n```\\n\\n**Python:**\\nThanks to @sirxudi I change one line from\\n`words = re.sub(r\\'[^a-zA-Z]\\', \\' \\', p).lower().split()`\\nto \\n`words = re.findall(r\\'\\\\w+\\', p.lower())\\n`\\n```\\n    def mostCommonWord(self, p, banned):\\n        ban = set(banned)\\n        words = re.findall(r\\'\\\\w+\\', p.lower())\\n        return collections.Counter(w for w in words if w not in ban).most_common(1)[0][0]\\n```",
                "solutionTags": [],
                "code": "```\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        unordered_set<string> ban(banned.begin(), banned.end());\\n        unordered_map<string, int> count;\\n        for (auto & c: p) c = isalpha(c) ? tolower(c) : \\' \\';\\n        istringstream iss(p);\\n        string w;\\n        pair<string, int> res (\"\", 0);\\n        while (iss >> w)\\n            if (ban.find(w) == ban.end() && ++count[w] > res.second)\\n                res = make_pair(w, count[w]);\\n        return res.first;\\n    }\\n```\n```\\n    public String mostCommonWord(String p, String[] banned) {\\n        Set<String> ban = new HashSet<>(Arrays.asList(banned));\\n        Map<String, Integer> count = new HashMap<>();\\n        String[] words = p.replaceAll(\"\\\\\\\\W+\" , \" \").toLowerCase().split(\"\\\\\\\\s+\");\\n        for (String w : words) if (!ban.contains(w)) count.put(w, count.getOrDefault(w, 0) + 1);\\n        return Collections.max(count.entrySet(), Map.Entry.comparingByValue()).getKey();\\n    }\\n```\n```\\n    def mostCommonWord(self, p, banned):\\n        ban = set(banned)\\n        words = re.findall(r\\'\\\\w+\\', p.lower())\\n        return collections.Counter(w for w in words if w not in ban).most_common(1)[0][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 124286,
                "title": "clean-6ms-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map<string, int>m;\\n        for(int i = 0; i < paragraph.size();){\\n            string s = \"\";\\n            while(i < paragraph.size() && isalpha(paragraph[i])) s.push_back(tolower(paragraph[i++]));\\n            while(i < paragraph.size() && !isalpha(paragraph[i])) i++;\\n            m[s]++;\\n        }\\n        for(auto x: banned) m[x] = 0;\\n        string res = \"\";\\n        int count = 0;\\n        for(auto x: m)\\n            if(x.second > count) res = x.first, count = x.second;\\n        return res;  \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map<string, int>m;\\n        for(int i = 0; i < paragraph.size();){\\n            string s = \"\";\\n            while(i < paragraph.size() && isalpha(paragraph[i])) s.push_back(tolower(paragraph[i++]));\\n            while(i < paragraph.size() && !isalpha(paragraph[i])) i++;\\n            m[s]++;\\n        }\\n        for(auto x: banned) m[x] = 0;\\n        string res = \"\";\\n        int count = 0;\\n        for(auto x: m)\\n            if(x.second > count) res = x.first, count = x.second;\\n        return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123973,
                "title": "simple-java-solution",
                "content": "```\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String[] words = paragraph.toLowerCase().split(\"[ !?\\',;.]+\");\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(String word : words) map.put(word, map.getOrDefault(word, 0) + 1);\\n        for(String word : banned) if(map.containsKey(word)) map.remove(word);\\n        String res = null;\\n        for(String word : map.keySet())\\n            if(res == null || map.get(word) > map.get(res))\\n                res = word;\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String[] words = paragraph.toLowerCase().split(\"[ !?\\',;.]+\");\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(String word : words) map.put(word, map.getOrDefault(word, 0) + 1);\\n        for(String word : banned) if(map.containsKey(word)) map.remove(word);\\n        String res = null;\\n        for(String word : map.keySet())\\n            if(res == null || map.get(word) > map.get(res))\\n                res = word;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 168958,
                "title": "store-words-in-trie-6ms-beats-99-java",
                "content": "Instead of using Map, storing words in **Trie** (or called **Prefix Tree**) requires less memory space.\\n\\nEach node has 26 sub-nodes, \\n```\\nprivate class Trie {\\n    private Trie[] next = new Trie[26];    // sub nodes\\n    private int count;                     // word freqence\\n    private boolean ban;                   // banned?\\n}\\n```\\nThe path from root to a specific node represents a word. The following diagram contains 3 words: `[cat, do, dog]`.  The integer `count` note the frequence of that word. A third boolean field is used to distinct a normal word from banned one.\\n```bash\\n              root\\n             /     \\\\\\n          c | 0    d | 0\\n          /           \\\\\\n       a | 0          o | 1 [do]\\n        /                \\\\   \\n[cat]t | 1               g | 1 [dog]\\n```\\n\\nHere is my solution. 6ms, beats 99%.\\nTime Complexity: **O (N + M)**\\nSpace Complexity: **O (N + M)**\\nwhere, `N` is the number of characters in banned list, while `M` is thoes in paragraph.\\n\\n\\n```java\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Trie root = new Trie();\\n        Trie curr = root;\\n        // insert banned words into Trie\\n        for (String ban : banned) {\\n            for (int i = 0; i < ban.length(); i++) {\\n                int idx = ban.charAt(i) - \\'a\\';\\n                if (curr.next[idx] == null) {\\n                    curr.next[idx] = new Trie();\\n                }\\n                curr = curr.next[idx];\\n            }\\n            curr.ban = true;\\n            curr = root;\\n        }\\n        int maxCount = 0;\\n        String mostFreqWord = \"\";\\n        paragraph = paragraph.toLowerCase();\\n        char[] pArray = paragraph.toCharArray();\\n        // insert words in paragraph into Trie\\n        for (int start = 0, end = 0; start < pArray.length; start = end + 1) {\\n            // skip non-letter characters\\n            while (start < pArray.length && (pArray[start] < \\'a\\' || pArray[start] > \\'z\\')) { start++; }\\n            // insert consecutive letters(words) into Trie\\n            for (end = start; end < pArray.length && (pArray[end] >= \\'a\\' && pArray[end] <= \\'z\\'); end++) {\\n                int idx = pArray[end] - \\'a\\';\\n                if (curr.next[idx] == null) {\\n                    curr.next[idx] = new Trie();\\n                }\\n                curr = curr.next[idx];\\n            }\\n            // update statistics\\n            if (curr != root && !curr.ban) {\\n                curr.count++;\\n                if (curr.count > maxCount) {\\n                    mostFreqWord = paragraph.substring(start, end);\\n                    maxCount = curr.count;\\n                }\\n            }\\n            curr = root;\\n        }\\n        return mostFreqWord;\\n    }\\n    // simplest Trie data structure\\n    private class Trie {\\n        private Trie[] next = new Trie[26];    // sub nodes\\n        private int count;                     // word freqence\\n        private boolean ban;                   // banned?\\n    }\\n}\\n```\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/helloshen/image_1536687882.png)\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nprivate class Trie {\\n    private Trie[] next = new Trie[26];    // sub nodes\\n    private int count;                     // word freqence\\n    private boolean ban;                   // banned?\\n}\\n```\n```bash\\n              root\\n             /     \\\\\\n          c | 0    d | 0\\n          /           \\\\\\n       a | 0          o | 1 [do]\\n        /                \\\\   \\n[cat]t | 1               g | 1 [dog]\\n```\n```java\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Trie root = new Trie();\\n        Trie curr = root;\\n        // insert banned words into Trie\\n        for (String ban : banned) {\\n            for (int i = 0; i < ban.length(); i++) {\\n                int idx = ban.charAt(i) - \\'a\\';\\n                if (curr.next[idx] == null) {\\n                    curr.next[idx] = new Trie();\\n                }\\n                curr = curr.next[idx];\\n            }\\n            curr.ban = true;\\n            curr = root;\\n        }\\n        int maxCount = 0;\\n        String mostFreqWord = \"\";\\n        paragraph = paragraph.toLowerCase();\\n        char[] pArray = paragraph.toCharArray();\\n        // insert words in paragraph into Trie\\n        for (int start = 0, end = 0; start < pArray.length; start = end + 1) {\\n            // skip non-letter characters\\n            while (start < pArray.length && (pArray[start] < \\'a\\' || pArray[start] > \\'z\\')) { start++; }\\n            // insert consecutive letters(words) into Trie\\n            for (end = start; end < pArray.length && (pArray[end] >= \\'a\\' && pArray[end] <= \\'z\\'); end++) {\\n                int idx = pArray[end] - \\'a\\';\\n                if (curr.next[idx] == null) {\\n                    curr.next[idx] = new Trie();\\n                }\\n                curr = curr.next[idx];\\n            }\\n            // update statistics\\n            if (curr != root && !curr.ban) {\\n                curr.count++;\\n                if (curr.count > maxCount) {\\n                    mostFreqWord = paragraph.substring(start, end);\\n                    maxCount = curr.count;\\n                }\\n            }\\n            curr = root;\\n        }\\n        return mostFreqWord;\\n    }\\n    // simplest Trie data structure\\n    private class Trie {\\n        private Trie[] next = new Trie[26];    // sub nodes\\n        private int count;                     // word freqence\\n        private boolean ban;                   // banned?\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 216788,
                "title": "easy-python-solution",
                "content": "# \\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        for c in \"!?\\',;.\": paragraph = paragraph.replace(c, \" \")\\n        d, res, count = {},\"\",0\\n        for word in paragraph.lower().split():\\n            if word in banned:\\n                continue;\\n            elif word in d:\\n                d[word] += 1\\n            else:\\n                d[word] = 1\\n            if d[word] > count:\\n                count = d[word]\\n                res = word\\n        return res",
                "solutionTags": [],
                "code": "# \\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        for c in \"!?\\',;.\": paragraph = paragraph.replace(c, \" \")\\n        d, res, count = {},\"\",0\\n        for word in paragraph.lower().split():\\n            if word in banned:\\n                continue;\\n            elif word in d:\\n                d[word] += 1\\n            else:\\n                d[word] = 1\\n            if d[word] > count:\\n                count = d[word]\\n                res = word\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 411380,
                "title": "java-summary-of-usages-of-split-and-replace-vs-replaceall",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/most-common-word/)\\nDifficulty: <span class=\"green\">Easy</span>\\n\\n## Problem\\n\\n> Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words.  **It is guaranteed there is at least one word that isn\\'t banned, and that the answer is unique.**\\n\\n> Words in the list of banned words are **given in lowercase**, and free of punctuation.  Words in the paragraph are not case sensitive. The answer is in **lowercase**.\\n\\n**Note:** \\n\\n- 1 <= `paragraph.length` <= 1000.\\n- 0 <= `banned.length` <= 100.\\n- 1 <= `banned[i].length` <= 10.\\n- The answer is unique, and written in lowercase (even if its occurrences in `paragraph` may have uppercase symbols, and even if it is a proper noun.)\\n- Paragraph only consists of `letters`, `spaces`, or the punctuation symbols `!?\\',;.`.\\n- There are no hyphens or hyphenated words.\\n- Words only consist of letters, never apostrophes or other punctuation symbols.\\n\\n**Example:** \\n\\n```java\\nInput: \"Bob hit a ball, the hit BALL flew far after it was hit.\"\\nbanned: [\"hit\"]\\nOutput:  \"ball\"\\n\\nInput: \"a, a, a, a, b,b,b,c, c\"\\nbanned: [\"a\"]\\nOutput: \"b\"\\n```\\n\\n\\n## Analysis\\n\\n### Hash Set + Hash Map\\n\\n**Note:** `str.split(\"\\\\\\\\s+\")` is equivalent to `str.split(\"\\\\\\\\s+\", 0)`. It means split the string for as many times as possible, and remove empty result `\"\"`. So `trim()` is not necessary here.\\n\\nOriginal code:\\n\\n```java\\npublic String mostCommonWord(String paragraph, String[] banned) {\\n  String str = preprocess(paragraph);\\n  String[] words = str.split(\"\\\\\\\\s+\"); // split by one or more spaces\\n  // ban set\\n  Set<String> banSet = new HashSet<>();\\n  for (String s : banned) banSet.add(s);\\n  // count map\\n  Map<String, Integer> countMap = new HashMap<>();\\n  int maxCount = 0;\\n  for (String s : words) {\\n    if (banSet.contains(s)) continue;\\n    int count = countMap.getOrDefault(s, 0) + 1;\\n    maxCount = Math.max(maxCount, count);\\n    countMap.put(s, count);\\n  }\\n  // find the string with maxCount\\n  for (String s : countMap.keySet()) {\\n    if (countMap.get(s) == maxCount) {\\n      return s;\\n    }\\n  }\\n  return null;\\n}\\n```\\n\\nHere is the `preprocess` function:\\n\\n```java\\n// \"a, a, a, a, b,b,b,c, c\"\\n// [\"a\"]\\n// Output: \"b\"\\nprivate String preprocess(String s) {\\n  s = s.replace(\"!\", \" \"); // for \"a,a,a,,a\", we should replace by \" \" instead of \"\"\\n  s = s.replace(\"?\", \" \");\\n  s = s.replace(\"\\'\", \" \");\\n  s = s.replace(\",\", \" \");\\n  s = s.replace(\";\", \" \");\\n  s = s.replace(\".\", \" \");\\n  s = s.trim();  // should be put after all those replace()\\n  s = s.toLowerCase();\\n  return s;\\n}\\n```\\n\\nOr:\\n\\n```java\\nprivate String preprocess(String s) {\\n  s = s.replaceAll(\"\\\\\\\\!|\\\\\\\\?|\\\\\\\\\\'|\\\\\\\\,|\\\\\\\\;|\\\\\\\\.\", \" \");\\n  s = s.trim();  // should be put after all those replace()\\n  s = s.toLowerCase();\\n  return s;\\n}\\n```\\n\\n**`replace()` vs. `replaceAll()`:**\\n\\n- `replace(char oldChar, char newChar)`\\n- `replace(CharSequence target, CharSequence replacement)`\\n- `replaceAll(String regex, String replacement)`\\n\\nNotice that they all replace all occurrences. `All` in the name of `replaceAll` doesn\\'t mean only it can replace all occurrences.\\n\\n\\nA succinct version:\\n\\n- `\\\\\\\\w+` matches all `alphanumeric` characters and `_`.\\n- `\\\\\\\\W+` matches all characters except `alphanumeric` characters and `_`.\\n- They are opposite.\\n\\n\\n```java\\nprivate String preprocess(String s) {\\n  s = s.replaceAll(\"\\\\\\\\W+\", \" \");\\n  s = s.trim().toLowerCase();\\n}\\n```\\n\\nA more succinct version:\\n\\n```java\\nString[] words = s.toLowerCase().split(\"\\\\\\\\W+\"); // \"\\\\\\\\W+\" includes spaces\\n```\\n\\nRules about `split()`: [271. Encode and Decode Strings](http://junhaow.com/lc/problems/string/271_encode-and-decode-strings.html)\\n\\n\\n```java\\n\"..\".split(\"\\\\\\\\W+\", -1); // [\"\", \"\"]\\n\"..\".split(\"\\\\\\\\W+\", 0);  // []\\n\"..\".split(\"\\\\\\\\W+\", 1);  // [\"..\"]\\n\"..\".split(\"\\\\\\\\W+\", 2);  // [\"\", \"\"]\\n```\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nInput: \"Bob hit a ball, the hit BALL flew far after it was hit.\"\\nbanned: [\"hit\"]\\nOutput:  \"ball\"\\n\\nInput: \"a, a, a, a, b,b,b,c, c\"\\nbanned: [\"a\"]\\nOutput: \"b\"\\n```\n```java\\npublic String mostCommonWord(String paragraph, String[] banned) {\\n  String str = preprocess(paragraph);\\n  String[] words = str.split(\"\\\\\\\\s+\"); // split by one or more spaces\\n  // ban set\\n  Set<String> banSet = new HashSet<>();\\n  for (String s : banned) banSet.add(s);\\n  // count map\\n  Map<String, Integer> countMap = new HashMap<>();\\n  int maxCount = 0;\\n  for (String s : words) {\\n    if (banSet.contains(s)) continue;\\n    int count = countMap.getOrDefault(s, 0) + 1;\\n    maxCount = Math.max(maxCount, count);\\n    countMap.put(s, count);\\n  }\\n  // find the string with maxCount\\n  for (String s : countMap.keySet()) {\\n    if (countMap.get(s) == maxCount) {\\n      return s;\\n    }\\n  }\\n  return null;\\n}\\n```\n```java\\n// \"a, a, a, a, b,b,b,c, c\"\\n// [\"a\"]\\n// Output: \"b\"\\nprivate String preprocess(String s) {\\n  s = s.replace(\"!\", \" \"); // for \"a,a,a,,a\", we should replace by \" \" instead of \"\"\\n  s = s.replace(\"?\", \" \");\\n  s = s.replace(\"\\'\", \" \");\\n  s = s.replace(\",\", \" \");\\n  s = s.replace(\";\", \" \");\\n  s = s.replace(\".\", \" \");\\n  s = s.trim();  // should be put after all those replace()\\n  s = s.toLowerCase();\\n  return s;\\n}\\n```\n```java\\nprivate String preprocess(String s) {\\n  s = s.replaceAll(\"\\\\\\\\!|\\\\\\\\?|\\\\\\\\\\'|\\\\\\\\,|\\\\\\\\;|\\\\\\\\.\", \" \");\\n  s = s.trim();  // should be put after all those replace()\\n  s = s.toLowerCase();\\n  return s;\\n}\\n```\n```java\\nprivate String preprocess(String s) {\\n  s = s.replaceAll(\"\\\\\\\\W+\", \" \");\\n  s = s.trim().toLowerCase();\\n}\\n```\n```java\\nString[] words = s.toLowerCase().split(\"\\\\\\\\W+\"); // \"\\\\\\\\W+\" includes spaces\\n```\n```java\\n\"..\".split(\"\\\\\\\\W+\", -1); // [\"\", \"\"]\\n\"..\".split(\"\\\\\\\\W+\", 0);  // []\\n\"..\".split(\"\\\\\\\\W+\", 1);  // [\"..\"]\\n\"..\".split(\"\\\\\\\\W+\", 2);  // [\"\", \"\"]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 500772,
                "title": "python-3-three-lines-easy-and-explained",
                "content": "Runtime: 36 ms, faster than 40.27% of Python3 online submissions for Most Common Word.\\nMemory Usage: 12.7 MB, less than 100.00% of Python3 online submissions for Most Common Word.\\n\\n```Python 3\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\t\\n\\t\\t# convert to lower case and split string into words by spaces and punctuation\\n        a = re.split(r\\'\\\\W+\\', paragraph.lower())\\n\\t\\t\\n\\t\\t# make new list consisitng of words not in banned list (remove banned words)\\n        b = [w for w in a if w not in banned]\\n\\t\\t\\n\\t\\t# return value that counted max times in the new list\\n        return max(b, key = b.count)\\n```\\n\\nPlease, upvote if you like it so that others can see and learn from it. Thanks!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python 3\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\t\\n\\t\\t# convert to lower case and split string into words by spaces and punctuation\\n        a = re.split(r\\'\\\\W+\\', paragraph.lower())\\n\\t\\t\\n\\t\\t# make new list consisitng of words not in banned list (remove banned words)\\n        b = [w for w in a if w not in banned]\\n\\t\\t\\n\\t\\t# return value that counted max times in the new list\\n        return max(b, key = b.count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184971,
                "title": "c-4ms-straightforward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        string res;\\n        unordered_map<string, int> count;\\n        \\n        // Step 1: remove punctuations and change to lower case;\\n        for(auto &c : paragraph)\\n            c =  isalpha(c)? tolower(c) : \\' \\'; \\n        \\n        // Step 2: count the frequency of every word\\n        istringstream iss(paragraph);\\n        string lower_word;\\n        while(iss >> lower_word)\\n            ++count[lower_word];  \\n    \\n        // Step 3: set the frequency of banned word to zero\\n        for(auto b : banned) count[b] = 0; \\n        \\n        // Step 4: get the word with highest frequency\\n        int max_count = 0;\\n        for(auto c : count){\\n            if(c.second > max_count){\\n                max_count = c.second;\\n                res = c.first;   \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        string res;\\n        unordered_map<string, int> count;\\n        \\n        // Step 1: remove punctuations and change to lower case;\\n        for(auto &c : paragraph)\\n            c =  isalpha(c)? tolower(c) : \\' \\'; \\n        \\n        // Step 2: count the frequency of every word\\n        istringstream iss(paragraph);\\n        string lower_word;\\n        while(iss >> lower_word)\\n            ++count[lower_word];  \\n    \\n        // Step 3: set the frequency of banned word to zero\\n        for(auto b : banned) count[b] = 0; \\n        \\n        // Step 4: get the word with highest frequency\\n        int max_count = 0;\\n        for(auto c : count){\\n            if(c.second > max_count){\\n                max_count = c.second;\\n                res = c.first;   \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810141,
                "title": "c-super-short",
                "content": "```\\nstring mostCommonWord(string paragraph, vector<string>& banned) {\\n\\n\\tfor(auto&c : paragraph)\\n\\t\\tc = ispunct(c) ? \\' \\' : tolower(c);\\n\\n\\tstring str, res;\\n\\tunordered_map<string, int> freq;\\n\\tunordered_set<string> b(banned.begin(), banned.end());\\n\\tstringstream ss(paragraph);\\n\\n\\twhile(ss>>str)\\n\\t\\tif(b.count(str)==0 && freq[res]<++freq[str]) \\n\\t\\t\\tres = str;\\n\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring mostCommonWord(string paragraph, vector<string>& banned) {\\n\\n\\tfor(auto&c : paragraph)\\n\\t\\tc = ispunct(c) ? \\' \\' : tolower(c);\\n\\n\\tstring str, res;\\n\\tunordered_map<string, int> freq;\\n\\tunordered_set<string> b(banned.begin(), banned.end());\\n\\tstringstream ss(paragraph);\\n\\n\\twhile(ss>>str)\\n\\t\\tif(b.count(str)==0 && freq[res]<++freq[str]) \\n\\t\\t\\tres = str;\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 335407,
                "title": "python-solution-using-max-and-key-function-16-ms",
                "content": "```\\nclass Solution(object):\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        dict = {}\\n        banned = set(banned)\\n        for c in \"!?\\',;.\":\\n            paragraph = paragraph.replace(c, \" \")\\n        paragraph = paragraph.lower().split()\\n\\n        for word in paragraph:            \\n            if word not in banned:\\n                if word in dict:\\n                    dict[word]+=1\\n                else:\\n                    dict[word]=1\\n\\t\\t#Don\\'t need a counter if you use key function to choose the key with max. count!\\n        return max(dict, key=dict.get)\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        dict = {}\\n        banned = set(banned)\\n        for c in \"!?\\',;.\":\\n            paragraph = paragraph.replace(c, \" \")\\n        paragraph = paragraph.lower().split()\\n\\n        for word in paragraph:            \\n            if word not in banned:\\n                if word in dict:\\n                    dict[word]+=1\\n                else:\\n                    dict[word]=1\\n\\t\\t#Don\\'t need a counter if you use key function to choose the key with max. count!\\n        return max(dict, key=dict.get)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420553,
                "title": "clean-javascript-solution",
                "content": "```\\nconst mostCommonWord = (paragraph, banned) => {\\n  const bannedSet = new Set(banned);\\n  const words = paragraph.toLowerCase().split(/\\\\W+/);\\n  const map = {};\\n  for (const w of words) {\\n    if (!bannedSet.has(w)) {\\n      if (map[w] == null) map[w] = 0;\\n      map[w]++;\\n    }\\n  }\\n\\n  let res = \\'\\';\\n  let max = -Infinity;\\n  for (const w in map) {\\n    const count = map[w];\\n    if (count > max) {\\n      res = w;\\n      max = count;\\n    }\\n  }\\n  return res;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst mostCommonWord = (paragraph, banned) => {\\n  const bannedSet = new Set(banned);\\n  const words = paragraph.toLowerCase().split(/\\\\W+/);\\n  const map = {};\\n  for (const w of words) {\\n    if (!bannedSet.has(w)) {\\n      if (map[w] == null) map[w] = 0;\\n      map[w]++;\\n    }\\n  }\\n\\n  let res = \\'\\';\\n  let max = -Infinity;\\n  for (const w in map) {\\n    const count = map[w];\\n    if (count > max) {\\n      res = w;\\n      max = count;\\n    }\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1056547,
                "title": "java-map-set-solution-w-detailed-comments",
                "content": "\\tclass Solution {\\n\\n\\t\\t/*\\n\\t\\t\\tInput: \\n\\t\\t\\tparagraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\"\\n\\t\\t\\tbanned = [\"hit\"]\\n\\n\\t\\t\\t-> \"Bob hit a ball the hit BALL flew far after it was hit\"\\n\\t\\t\\t-> \"bob hit a ball the hit ball flew far after it was hit\"\\n\\t\\t\\t-> [\"bob\", \"hit\", \"a\", \"ball\", \"the\", \"ball\", \"flew\", \"far\", \"after\", \"it\", \"was\", \"hit\"]\\n\\n\\t\\t\\t-> {\"hit\"}\\n\\n\\t\\t\\t-> {\\n\\t\\t\\t\\t\\tball:   2\\n\\t\\t\\t\\t\\tbob:    1\\n\\t\\t\\t\\t\\ta:      1\\n\\t\\t\\t\\t\\tthe:    1\\n\\t\\t\\t\\t\\tflew:   1\\n\\t\\t\\t\\t\\tfar:    1\\n\\t\\t\\t\\t\\tafter:  1\\n\\t\\t\\t\\t\\tit:     1\\n\\t\\t\\t\\t\\twas:    1\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\tResult: \"ball\"\\n\\n\\t\\t\\tALGORITHM\\n\\t\\t\\t\\tSTEP 1: ensure the passed string is not null or blank\\n\\t\\t\\t\\tSTEP 2: create a set to contain the banned words\\n\\t\\t\\t\\tSTEP 3: create a map to store word and count\\n\\t\\t\\t\\tSTEP 4: remove all other characters from the paragraph except A-Z or a-z\\n\\t\\t\\t\\tSTEP 5: tranform paragraph to have all lowercase letters\\n\\t\\t\\t\\tSTEP 6: create a string array containing the words of pargraph spilt by space\\n\\t\\t\\t\\tSTEP 7: populate the set with the banned words\\n\\t\\t\\t\\tSTEP 8: loop through all the words\\n\\t\\t\\t\\t\\tSTEP 9: if the word is not in the banned list\\n\\t\\t\\t\\t\\t\\t\\t-> add the word to the map with an updated count\\n\\t\\t\\t\\tSTEP 810: return the most common word from map \\n\\n\\n\\t\\t*/\\n\\t\\tpublic String mostCommonWord(String paragraph, String[] banned) {\\n\\n\\t\\t\\tif(paragraph == null || paragraph.length() == 0) {\\n\\t\\t\\t\\treturn \"\";\\n\\t\\t\\t}\\n\\n\\t\\t\\tSet<String> bannedWords = new HashSet<>();\\n\\t\\t\\tMap<String, Integer> wordCount = new HashMap<>();\\n            String[] words = paragraph.replaceAll(\"[^A-Za-z]\",\" \").toLowerCase().split(\" \");\\n\\n\\t\\t\\tfor(String word: banned) {\\n\\t\\t\\t\\tbannedWords.add(word);\\n\\t\\t\\t}\\n\\n\\n\\n\\t\\t\\tfor(String word: words) {\\n\\t\\t\\t\\tif(!bannedWords.contains(word)) {\\n\\t\\t\\t\\t\\twordCount.put(word, wordCount.getOrDefault(word, 0) + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\n\\n\\t\\t\\tString mostCommonWord = \"\";\\n\\t\\t\\tfor(String word: wordCount.keySet()) {\\n\\t\\t\\t\\tif(mostCommonWord.equals(\"\")) {\\n\\t\\t\\t\\t\\tmostCommonWord = word;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmostCommonWord = wordCount.get(mostCommonWord) > wordCount.get(word) ? mostCommonWord : word; \\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn mostCommonWord;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n\\n\\t\\t/*\\n\\t\\t\\tInput: \\n\\t\\t\\tparagraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\"\\n\\t\\t\\tbanned = [\"hit\"]\\n\\n\\t\\t\\t-> \"Bob hit a ball the hit BALL flew far after it was hit\"\\n\\t\\t\\t-> \"bob hit a ball the hit ball flew far after it was hit\"\\n\\t\\t\\t-> [\"bob\", \"hit\", \"a\", \"ball\", \"the\", \"ball\", \"flew\", \"far\", \"after\", \"it\", \"was\", \"hit\"]\\n\\n\\t\\t\\t-> {\"hit\"}",
                "codeTag": "Java"
            },
            {
                "id": 196675,
                "title": "3ms-java-solution-beat-99-94",
                "content": "https://en.wikipedia.org/wiki/Trie\\nWe\\'ll use a Trie to solve this problem.\\nEvery TrieNode has 26 links, representing 26 lower-case letters.\\nThe root represents empty string, and each link points to the first character of a string.\\nWe use word to save the string that the node represents, and use cnt to count on number of times we meet the string.\\n\\nDuring \"mostCommonWord\", we could use StringBuilder to append the valid characters(and turn them to all lowercase),\\nwhile we meet any non-letter character, insert the string to the Trie.\\n\\nThe main part of TrieNode functions are describes below:\\n1. insert: \\nTake a char from string letter by letter, and go through the links.\\nIf curr.links[index] == null, that means we haven\\'t had a path pass by,\\nnew the TrieNode and set the \"word\".\\nAt the last of the TrieNode, we need to increase the cnt.\\n2. ban:\\nBan out the string means that we could set the cnt of string to zero.\\nNotice that if we meet null links, just return since the string is not exist in the paragraph.\\n3. findMax:\\nGo through all TrieNode and find the largest cnt and its word.\\n\\nThe following is for \\u4E2D\\u6587\\u4F7F\\u7528\\u8005\\u3002\\n\\u9019\\u500B\\u89E3\\u6CD5\\u662F\\u4F7F\\u7528\\u5B57\\u5178\\u6A39\\u4F86\\u89E3\\uFF0C\\u6A39\\u6839\\u4EE3\\u8868\\u7A7A\\u5B57\\u4E32\\uFF0C\\u6BCF\\u500B\\u5B57\\u4E32\\u90FD\\u6703\\u670926\\u500Blink\\uFF0C\\u4EE3\\u886826\\u500B\\u5C0F\\u5BEB\\u5B57\\u6BCD\\u3002\\n\\u6211\\u5011\\u5728\\u6BCF\\u500BTrieNode\\u4E2D\\u5B58\\u653Eword(\\u8D70\\u5230\\u9019\\u5BE6\\u969B\\u7684\\u5B57\\u4E32)\\u548Ccnt(\\u8A18\\u9304\\u9019\\u500B\\u5B57\\u4E32\\u6709\\u5E7E\\u500B)\\u3002\\n\\u5728mostCommonWord\\u4E2D\\uFF0C\\u4F7F\\u7528StringBuilder\\u6BCF\\u6B21\\u5C07\\u5408\\u6CD5\\u7684\\u5B57\\u5143(\\u5927\\u5C0F\\u5BEB\\u5B57\\u6BCD)\\u52A0\\u5165(\\u4E26\\u8F49\\u6210\\u5C0F\\u5BEB)\\uFF0C\\n\\u5728\\u9047\\u5230\\u975E\\u5B57\\u6BCD\\u7684\\u5B57\\u5143\\u7684\\u6642\\u5019\\uFF0C\\u5C31\\u628A\\u76EE\\u524D\\u7684\\u9019\\u500B\\u5B57\\u4E32\\u585E\\u9032\\u5B57\\u5178\\u6A39\\u88E1\\u3002\\n\\nTrieNode\\u9019\\u908A\\u6709\\u4E09\\u500Bfunctions:\\n1. insert:\\n\\u900F\\u904E\\u6BCF\\u500B\\u5B57\\u6BCD\\u6CBFlinks\\u7684\\u8DEF\\u5F91\\u8D70\\uFF0C\\u5982\\u679Ccurr.links[index] == null\\u5247\\u8868\\u793A\\u524D\\u9762\\u9084\\u6C92\\u8D70\\u904E\\uFF0C\\n\\u8981\\u81EA\\u884Cnew\\u51FA\\u4F86\\uFF0C\\u4E26\\u8A2D\\u5B9A\\u5176word\\u8B8A\\u6578\\u3002\\n\\u5728\\u8D70\\u5230\\u5E95\\u7684\\u6642\\u5019\\u6211\\u5011\\u8981\\u5C07cnt\\u6578\\u52A01\\u3002\\n2. ban:\\n\\u53EA\\u8981\\u5C07\\u8A72string\\u7684cnt\\u8A2D\\u6210\\u96F6\\u5373\\u53EF\\u3002\\n\\u5982\\u679C\\u5728\\u8D70\\u7684\\u8DEF\\u5F91\\u9014\\u4E2D\\u9047\\u5230null\\uFF0C\\u8868\\u793A\\u6BB5\\u843D\\u88E1\\u4E0D\\u5B58\\u5728\\u9019\\u500Bstring\\uFF0C\\u76F4\\u63A5return\\u5373\\u53EF\\u3002\\n3. findMax:\\n\\u904D\\u6B77\\u6240\\u6709TrieNode\\u4E26\\u627E\\u5230\\u6700\\u5927\\u7684cnt\\u53CA\\u5C0D\\u61C9\\u7684word\\u3002\\n\\n```\\nclass Solution {\\n    public String res;\\n    public int maxcnt;\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        TrieNode root = new TrieNode();\\n        StringBuilder st = new StringBuilder();\\n        res = \"\";\\n        maxcnt = 0;\\n        boolean isString = false;\\n        for (char ch : paragraph.toCharArray()) {\\n            if (ch >= \\'a\\' && ch <= \\'z\\') {\\n                st.append(ch);\\n                isString = true;\\n            } else if (ch >= \\'A\\' && ch <= \\'Z\\') {\\n                st.append((char)(ch + \\'a\\' - \\'A\\'));\\n                isString = true;\\n            } else {\\n                if (isString) {\\n                    root.insert(st.toString());\\n                    st = new StringBuilder();\\n                    isString = false;\\n                } \\n            }\\n        }\\n        if (isString) root.insert(st.toString());        \\n        for (String s : banned) root.ban(s);\\n        root.findMax(root);\\n        return res;\\n    }\\n    class TrieNode {\\n        String word = \"\";\\n        int cnt = 0;\\n        TrieNode[] links = new TrieNode[26];\\n        \\n        void insert(String s) {\\n            TrieNode curr = this;\\n            char[] chs = s.toCharArray();\\n            for (int i = 0; i < chs.length; ++i) {\\n                int index = chs[i] - \\'a\\';\\n                if (curr.links[index] == null) {\\n                    curr.links[index] = new TrieNode();\\n                    curr.links[index].word = curr.word + chs[i];\\n                }\\n                curr = curr.links[index];\\n            }\\n            curr.cnt += 1;\\n        }\\n        void ban(String s) {\\n            char[] chs = s.toCharArray();\\n            TrieNode curr = this;\\n            for (int i = 0; i < chs.length; ++i) {\\n                int index = chs[i] - \\'a\\';\\n                if (curr.links[index] == null) return;\\n                curr = curr.links[index];\\n            }\\n            curr.cnt = 0;\\n        }\\n        void findMax(TrieNode curr) {\\n            if (curr == null) return;\\n            if (curr.cnt > maxcnt) {\\n                res = curr.word;\\n                maxcnt = curr.cnt;\\n            }\\n            for (int i = 0; i < curr.links.length; ++i) {\\n                findMax(curr.links[i]);\\n            }\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String res;\\n    public int maxcnt;\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        TrieNode root = new TrieNode();\\n        StringBuilder st = new StringBuilder();\\n        res = \"\";\\n        maxcnt = 0;\\n        boolean isString = false;\\n        for (char ch : paragraph.toCharArray()) {\\n            if (ch >= \\'a\\' && ch <= \\'z\\') {\\n                st.append(ch);\\n                isString = true;\\n            } else if (ch >= \\'A\\' && ch <= \\'Z\\') {\\n                st.append((char)(ch + \\'a\\' - \\'A\\'));\\n                isString = true;\\n            } else {\\n                if (isString) {\\n                    root.insert(st.toString());\\n                    st = new StringBuilder();\\n                    isString = false;\\n                } \\n            }\\n        }\\n        if (isString) root.insert(st.toString());        \\n        for (String s : banned) root.ban(s);\\n        root.findMax(root);\\n        return res;\\n    }\\n    class TrieNode {\\n        String word = \"\";\\n        int cnt = 0;\\n        TrieNode[] links = new TrieNode[26];\\n        \\n        void insert(String s) {\\n            TrieNode curr = this;\\n            char[] chs = s.toCharArray();\\n            for (int i = 0; i < chs.length; ++i) {\\n                int index = chs[i] - \\'a\\';\\n                if (curr.links[index] == null) {\\n                    curr.links[index] = new TrieNode();\\n                    curr.links[index].word = curr.word + chs[i];\\n                }\\n                curr = curr.links[index];\\n            }\\n            curr.cnt += 1;\\n        }\\n        void ban(String s) {\\n            char[] chs = s.toCharArray();\\n            TrieNode curr = this;\\n            for (int i = 0; i < chs.length; ++i) {\\n                int index = chs[i] - \\'a\\';\\n                if (curr.links[index] == null) return;\\n                curr = curr.links[index];\\n            }\\n            curr.cnt = 0;\\n        }\\n        void findMax(TrieNode curr) {\\n            if (curr == null) return;\\n            if (curr.cnt > maxcnt) {\\n                res = curr.word;\\n                maxcnt = curr.cnt;\\n            }\\n            for (int i = 0; i < curr.links.length; ++i) {\\n                findMax(curr.links[i]);\\n            }\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753471,
                "title": "c-8-ms-solution-easy-to-understand",
                "content": "***Runtime: 8 ms, faster than 93.85% of C++ online submissions for Most Common Word.\\nMemory Usage: 7.7 MB, less than 92.55% of C++ online submissions for Most Common Word.***\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& b) {\\n        string result;\\n        int count = 0;\\n        unordered_map<string, int> umap;\\n        int i = 0;\\n        while(i < p.size()){\\n            string result = \"\";\\n            while(i < p.size() && isalpha(p[i])){\\n                result += tolower(p[i]);\\n                i++;\\n            }\\n            if(result != \"\")\\n                umap[result]++;\\n            i++;\\n        }\\n        for(auto& s: b){\\n            umap.erase(s);\\n        }\\n        for(auto& [key,value] : umap){\\n            if(count < value){\\n                result = key;\\n                count = value;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& b) {\\n        string result;\\n        int count = 0;\\n        unordered_map<string, int> umap;\\n        int i = 0;\\n        while(i < p.size()){\\n            string result = \"\";\\n            while(i < p.size() && isalpha(p[i])){\\n                result += tolower(p[i]);\\n                i++;\\n            }\\n            if(result != \"\")\\n                umap[result]++;\\n            i++;\\n        }\\n        for(auto& s: b){\\n            umap.erase(s);\\n        }\\n        for(auto& [key,value] : umap){\\n            if(count < value){\\n                result = key;\\n                count = value;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328271,
                "title": "c-linq",
                "content": "```\\n\\t\\tpublic string MostCommonWord(string paragraph, string[] banned) {\\n            char[] chars = new char[] { \\'!\\', \\'?\\', \\',\\', \\'.\\', \\';\\', \\' \\', \\'\\\\\\'\\' };\\n            return paragraph.Split(chars).Where(x => !string.IsNullOrWhiteSpace(x)).\\n                Select(x => x.ToLower()).Where(x => !banned.Contains(x)).\\n                GroupBy(x => x).Select(x => new { Word = x.Key, Count = x.Count() }).\\n                OrderBy(x => x.Count).Last().Word;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tpublic string MostCommonWord(string paragraph, string[] banned) {\\n            char[] chars = new char[] { \\'!\\', \\'?\\', \\',\\', \\'.\\', \\';\\', \\' \\', \\'\\\\\\'\\' };\\n            return paragraph.Split(chars).Where(x => !string.IsNullOrWhiteSpace(x)).\\n                Select(x => x.ToLower()).Where(x => !banned.Contains(x)).\\n                GroupBy(x => x).Select(x => new { Word = x.Key, Count = x.Count() }).\\n                OrderBy(x => x.Count).Last().Word;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 125883,
                "title": "a-clean-o-n-javascript-es6-solution",
                "content": "Here is a shortened ES6 solution with explanation; It\\'s in `O(N)` *where `N` is the number of words in the `paragraph`*; \\n\\n```\\nvar mostCommonWord = function(paragraph, banned) {\\n    //Split the paragraph into an array of words in lowercase\\n    const words = paragraph.toLowerCase().split(/\\\\W/);\\n    //Create a map to act as histogram of words\\n    const mp = Object.create(null);\\n    //Filter out empty strings and make the histogram\\n    words.filter(x => x).map(x => mp[x] = x in mp ? mp[x] + 1 : 1);\\n    //Rather than deleting banned words, just set its value to a negative number\\n    banned.map(x => mp[x] = -1)\\n    //Return the word with the highest count in the histogram\\n    return Object.keys(mp).reduce((a, b) => mp[a] > mp[b] ? a : b);\\n};\\n```\\n\\n**Noteworthy here:** \\n- It doesn\\'t ever `delete` anything, cause it hurts performance in some JavaScript Engines, notably in v8 engine \\n- Note the oneliner trick of finding maximum element using a predicate, with the `[...].reduce()` trick. Similar to how I would have done it in C++ `std::max_element(...[](){})`;\\n\\n",
                "solutionTags": [],
                "code": "```\\nvar mostCommonWord = function(paragraph, banned) {\\n    //Split the paragraph into an array of words in lowercase\\n    const words = paragraph.toLowerCase().split(/\\\\W/);\\n    //Create a map to act as histogram of words\\n    const mp = Object.create(null);\\n    //Filter out empty strings and make the histogram\\n    words.filter(x => x).map(x => mp[x] = x in mp ? mp[x] + 1 : 1);\\n    //Rather than deleting banned words, just set its value to a negative number\\n    banned.map(x => mp[x] = -1)\\n    //Return the word with the highest count in the histogram\\n    return Object.keys(mp).reduce((a, b) => mp[a] > mp[b] ? a : b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 125686,
                "title": "java-simple-solution-using-hashmaps-along-with-asserts-to-test",
                "content": "```\\npublic static String mostCommonWord(String paragraph, String[] banned) {\\n        String[] splitArr = paragraph.replaceAll(\"[!?\\',;.]\",\"\").toLowerCase().split(\" \");\\n        HashMap<String, Integer> map = new HashMap<>();\\n        List<String> bannedList = Arrays.asList(banned);\\n        for(String str: splitArr) {\\n            if(!bannedList.contains(str)) {\\n                map.put(str, map.getOrDefault(str, 0) + 1);\\n            }\\n        }\\n\\n        int currentMax = 0;\\n        String res = \"\";\\n        for(String key: map.keySet()) {\\n            res = map.get(key) >  currentMax ? key : res;\\n            currentMax = map.get(key);\\n        }\\n        return res;\\n    }\\n```\\n\\nCan be tested by following two asserts:\\n```\\npublic static void main(String[] args) {\\n    Assert.assertEquals(\"ball\", mostCommonWord(\"Bob hit a ball, the hit BALL flew far after it was hit.\", new String[]{\"hit\"}));\\n    Assert.assertEquals(\"z\", mostCommonWord(\"L, P! X! C; u! P? w! P. G, S? l? X? D. w? m? f? v, x? i. z; x\\' m! U\\' M! j? V; l. S! j? r, K. O? k? p? p, H! t! z\\' X! v. u; F, h; s? X? K. y, Y! L; q! y? j, o? D\\' y? F\\' Z; E? W; W\\' W! n! p\\' U. N; w? V\\' y! Q; J, o! T? g? o! N\\' M? X? w! V. w? o\\' k. W. y, k; o\\' m! r; i, n. k, w; U? S? t; O\\' g\\' z. V. N? z, W? j! m? W! h; t! V\\' T! Z? R\\' w, w? y? y; O\\' w; r? q. G, V. x? n, Y; Q. s? S. G. f, s! U? l. o! i. L; Z\\' X! u. y, Q. q; Q, D; V. m. q. s? Y, U; p? u! q? h? O. W\\' y? Z! x! r. E, R, r\\' X\\' V, b. z, x! Q; y, g\\' j; j. q; W; v\\' X! J\\' H? i\\' o? n, Y. X! x? h? u; T? l! o? z. K\\' z\\' s; L? p? V\\' r. L? Y; V! V\\' S. t? Z\\' T\\' Y. s? i? Y! G? r; Y; T! h! K; M. k. U; A! V? R? C\\' x! X. M; z\\' V! w. N. T? Y\\' w? n, Z, Z? Y\\' R; V\\' f; V\\' I; t? X? Z; l? R, Q! Z. R. R, O. S! w; p\\' T. u? U! n, V, M. p? Q, O? q\\' t. B, k. u. H\\' T; T? S; Y! S! i? q! K\\' z\\' S! v; L. x; q; W? m? y, Z! x. y. j? N\\' R\\' I? r? V! Z; s, O? s; V, I, e? U\\' w! T? T! u; U! e? w? z; t! C! z? U, p\\' p! r. x; U! Z; u! j; T! X! N\\' F? n! P\\' t, X. s; q\\'\", new String[]{\"m\",\"i\",\"s\",\"w\",\"y\",\"d\",\"q\",\"l\",\"a\",\"p\",\"n\",\"t\",\"u\",\"b\",\"o\",\"e\",\"f\",\"g\",\"c\",\"x\"}));\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static String mostCommonWord(String paragraph, String[] banned) {\\n        String[] splitArr = paragraph.replaceAll(\"[!?\\',;.]\",\"\").toLowerCase().split(\" \");\\n        HashMap<String, Integer> map = new HashMap<>();\\n        List<String> bannedList = Arrays.asList(banned);\\n        for(String str: splitArr) {\\n            if(!bannedList.contains(str)) {\\n                map.put(str, map.getOrDefault(str, 0) + 1);\\n            }\\n        }\\n\\n        int currentMax = 0;\\n        String res = \"\";\\n        for(String key: map.keySet()) {\\n            res = map.get(key) >  currentMax ? key : res;\\n            currentMax = map.get(key);\\n        }\\n        return res;\\n    }\\n```\n```\\npublic static void main(String[] args) {\\n    Assert.assertEquals(\"ball\", mostCommonWord(\"Bob hit a ball, the hit BALL flew far after it was hit.\", new String[]{\"hit\"}));\\n    Assert.assertEquals(\"z\", mostCommonWord(\"L, P! X! C; u! P? w! P. G, S? l? X? D. w? m? f? v, x? i. z; x\\' m! U\\' M! j? V; l. S! j? r, K. O? k? p? p, H! t! z\\' X! v. u; F, h; s? X? K. y, Y! L; q! y? j, o? D\\' y? F\\' Z; E? W; W\\' W! n! p\\' U. N; w? V\\' y! Q; J, o! T? g? o! N\\' M? X? w! V. w? o\\' k. W. y, k; o\\' m! r; i, n. k, w; U? S? t; O\\' g\\' z. V. N? z, W? j! m? W! h; t! V\\' T! Z? R\\' w, w? y? y; O\\' w; r? q. G, V. x? n, Y; Q. s? S. G. f, s! U? l. o! i. L; Z\\' X! u. y, Q. q; Q, D; V. m. q. s? Y, U; p? u! q? h? O. W\\' y? Z! x! r. E, R, r\\' X\\' V, b. z, x! Q; y, g\\' j; j. q; W; v\\' X! J\\' H? i\\' o? n, Y. X! x? h? u; T? l! o? z. K\\' z\\' s; L? p? V\\' r. L? Y; V! V\\' S. t? Z\\' T\\' Y. s? i? Y! G? r; Y; T! h! K; M. k. U; A! V? R? C\\' x! X. M; z\\' V! w. N. T? Y\\' w? n, Z, Z? Y\\' R; V\\' f; V\\' I; t? X? Z; l? R, Q! Z. R. R, O. S! w; p\\' T. u? U! n, V, M. p? Q, O? q\\' t. B, k. u. H\\' T; T? S; Y! S! i? q! K\\' z\\' S! v; L. x; q; W? m? y, Z! x. y. j? N\\' R\\' I? r? V! Z; s, O? s; V, I, e? U\\' w! T? T! u; U! e? w? z; t! C! z? U, p\\' p! r. x; U! Z; u! j; T! X! N\\' F? n! P\\' t, X. s; q\\'\", new String[]{\"m\",\"i\",\"s\",\"w\",\"y\",\"d\",\"q\",\"l\",\"a\",\"p\",\"n\",\"t\",\"u\",\"b\",\"o\",\"e\",\"f\",\"g\",\"c\",\"x\"}));\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1484164,
                "title": "python-faster-than-92-97",
                "content": "```\\nclass Solution(object):\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        \\n        #replacing each symbols, so they are not included with words\\n        symbols = \"!?\\',;.\" \\n        for s in symbols:\\n            paragraph = paragraph.replace(s,\" \")\\n    \\n        paraList = split(lower(paragraph))\\n        wordCounter = {}\\n        for w in paraList:\\n            if w not in banned:\\n                if w not in wordCounter.keys():\\n                    wordCounter[w] = 1 \\n                else:\\n                    wordCounter[w] += 1\\n        \\n        maxVal = max(wordCounter.values())\\n        for k,v in wordCounter.items():\\n            if v == maxVal:\\n                return k\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        \\n        #replacing each symbols, so they are not included with words\\n        symbols = \"!?\\',;.\" \\n        for s in symbols:\\n            paragraph = paragraph.replace(s,\" \")\\n    \\n        paraList = split(lower(paragraph))\\n        wordCounter = {}\\n        for w in paraList:\\n            if w not in banned:\\n                if w not in wordCounter.keys():\\n                    wordCounter[w] = 1 \\n                else:\\n                    wordCounter[w] += 1\\n        \\n        maxVal = max(wordCounter.values())\\n        for k,v in wordCounter.items():\\n            if v == maxVal:\\n                return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370291,
                "title": "javascript-easy-clean-solution",
                "content": "\\n\\n    var mostCommonWord = function(paragraph, banned) {\\n        let arr = paragraph.toLowerCase().split(/\\\\W+/g)\\n        let map = {}\\n    \\n        for(let word of arr) {\\n            if(!map[word]) {\\n                map[word] = 1        \\n            } else {\\n                map[word]++\\n            }\\n        }\\n    \\n       return Object.keys(map).sort((a,b) => {\\n            return map[b] - map[a]\\n        }).filter(word => !banned.includes(word))[0]\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n\\n    var mostCommonWord = function(paragraph, banned) {\\n        let arr = paragraph.toLowerCase().split(/\\\\W+/g)\\n        let map = {}\\n    \\n        for(let word of arr) {\\n            if(!map[word]) {\\n                map[word] = 1        \\n            } else {\\n                map[word]++\\n            }\\n        }\\n    \\n       return Object.keys(map).sort((a,b) => {\\n            return map[b] - map[a]\\n        }).filter(word => !banned.includes(word))[0]\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 123958,
                "title": "3-lines-python-solution-using-regex",
                "content": "```python\\n    def mostCommonWord(self, paragraph, banned):\\n        tokens = [token for token in re.findall(r\"([a-zA-Z]+)\",  paragraph.lower()) if token not in banned]\\n        mostComm = collections.Counter(tokens).most_common(1)\\n        return mostComm[0][0]\\n```",
                "solutionTags": [],
                "code": "```python\\n    def mostCommonWord(self, paragraph, banned):\\n        tokens = [token for token in re.findall(r\"([a-zA-Z]+)\",  paragraph.lower()) if token not in banned]\\n        mostComm = collections.Counter(tokens).most_common(1)\\n        return mostComm[0][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2049770,
                "title": "python-brute-force-method-with-explanation",
                "content": "**Explanation**\\n1. make paragraph lowercase (case insensitive)\\n2. remove symbols from paragraph\\n3. split the paragraph into list of words\\n4. remove duplicate words\\n5. iterate through new paragraph\\n\\t6. if the current word isn\\'t in `banned` and it occurs more times in the old paragraph: update count and update the most common word\\n\\t7. return most common word\\n\\n```\\nclass Solution(object):\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        paragraph = paragraph.lower()\\n        count = 0\\n        y=\"\"\\n        s=\"!?\\',;.\"\\n        for i in s:\\n            paragraph = paragraph.replace(i,\\' \\')\\n            \\n            \\n        allwords = paragraph.split()\\n        words = list(set(allwords))\\n        for j in words:\\n            if j not in banned:\\n                if allwords.count(j) > count:\\n                    count = allwords.count(j)\\n                    y = j\\n        return y\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        paragraph = paragraph.lower()\\n        count = 0\\n        y=\"\"\\n        s=\"!?\\',;.\"\\n        for i in s:\\n            paragraph = paragraph.replace(i,\\' \\')\\n            \\n            \\n        allwords = paragraph.split()\\n        words = list(set(allwords))\\n        for j in words:\\n            if j not in banned:\\n                if allwords.count(j) > count:\\n                    count = allwords.count(j)\\n                    y = j\\n        return y\\n```",
                "codeTag": "Java"
            },
            {
                "id": 429450,
                "title": "java-runtime-o-n-4ms-99-memory-o-n-36mb-96",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> banSet = new HashSet();\\n        for(String word:banned) banSet.add(word);\\n        Map<String,Integer> strCount = new HashMap();\\n        int n = paragraph.length();\\n        \\n        int left=0,right=1;\\n        if(Character.isLetter(paragraph.charAt(n-1))) paragraph+=\".\";\\n        char[] charParagraph = paragraph.toCharArray();\\n        int max=0;\\n        String maxWord=\"\";\\n        while(left<n){\\n            while(Character.isLetter(charParagraph[right])){\\n                right++;\\n            }\\n            String currWord = paragraph.substring(left,right).toLowerCase();\\n            if(!banSet.contains(currWord)){\\n                int newCount = strCount.getOrDefault(currWord,0)+1;\\n                strCount.put(currWord,newCount);\\n                if(newCount>max){\\n                    max=newCount;\\n                    maxWord=currWord;\\n                }\\n            }\\n            while(right < n && !Character.isLetter(charParagraph[right])) right++;\\n            left=right;\\n        }\\n        return maxWord;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> banSet = new HashSet();\\n        for(String word:banned) banSet.add(word);\\n        Map<String,Integer> strCount = new HashMap();\\n        int n = paragraph.length();\\n        \\n        int left=0,right=1;\\n        if(Character.isLetter(paragraph.charAt(n-1))) paragraph+=\".\";\\n        char[] charParagraph = paragraph.toCharArray();\\n        int max=0;\\n        String maxWord=\"\";\\n        while(left<n){\\n            while(Character.isLetter(charParagraph[right])){\\n                right++;\\n            }\\n            String currWord = paragraph.substring(left,right).toLowerCase();\\n            if(!banSet.contains(currWord)){\\n                int newCount = strCount.getOrDefault(currWord,0)+1;\\n                strCount.put(currWord,newCount);\\n                if(newCount>max){\\n                    max=newCount;\\n                    maxWord=currWord;\\n                }\\n            }\\n            while(right < n && !Character.isLetter(charParagraph[right])) right++;\\n            left=right;\\n        }\\n        return maxWord;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982633,
                "title": "python-dictionaries-clean-code",
                "content": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        for i in \"!.\\',;:?\": \\n            paragraph = paragraph.replace(i, \\' \\')\\n        dic, ans, ansCount = defaultdict(int), \\'\\', 0\\n        for word in paragraph.lower().split():\\n            if word in banned:\\n                continue\\n            dic[word] += 1\\n            if dic[word] > ansCount:\\n                ansCount = dic[word]\\n                res = word\\n        return res    \\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        for i in \"!.\\',;:?\": \\n            paragraph = paragraph.replace(i, \\' \\')\\n        dic, ans, ansCount = defaultdict(int), \\'\\', 0\\n        for word in paragraph.lower().split():\\n            if word in banned:\\n                continue\\n            dic[word] += 1\\n            if dic[word] > ansCount:\\n                ansCount = dic[word]\\n                res = word\\n        return res    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 828958,
                "title": "swift-16ms",
                "content": "```\\nclass Solution {\\n    func mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\\n        var map: [String: Int] = [String: Int]()\\n    \\n        let fixedParagraph = paragraph.lowercased().split{ !$0.isLetter }\\n    \\n        fixedParagraph.forEach { (word) in\\n            map[String(word)] = (map[String(word)] ?? 0) + 1\\n        }\\n\\n        return map.sorted {$0.value > $1.value }.filter{ !banned.contains($0.key)}.first?.key ?? \"\"\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\\n        var map: [String: Int] = [String: Int]()\\n    \\n        let fixedParagraph = paragraph.lowercased().split{ !$0.isLetter }\\n    \\n        fixedParagraph.forEach { (word) in\\n            map[String(word)] = (map[String(word)] ?? 0) + 1\\n        }\\n\\n        return map.sorted {$0.value > $1.value }.filter{ !banned.contains($0.key)}.first?.key ?? \"\"\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823208,
                "title": "python-simple-and-clean-explained-solution",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        my_dict = defaultdict(int)\\n        # split string into list ignoring cases and punctuation\\n        par = re.split(\"[\" + string.punctuation + \" \"+ \"]+\", paragraph.lower())\\n        # keep counts of words in dict and keep track of most frequent\\n        max_count = 0\\n        max_word = \"\"\\n        for word in par:\\n            if word not in banned:\\n                my_dict[word]+=1\\n                if my_dict[word] > max_count:\\n                    max_count = my_dict[word]\\n                    max_word = word\\n        return max_word\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        my_dict = defaultdict(int)\\n        # split string into list ignoring cases and punctuation\\n        par = re.split(\"[\" + string.punctuation + \" \"+ \"]+\", paragraph.lower())\\n        # keep counts of words in dict and keep track of most frequent\\n        max_count = 0\\n        max_word = \"\"\\n        for word in par:\\n            if word not in banned:\\n                my_dict[word]+=1\\n                if my_dict[word] > max_count:\\n                    max_count = my_dict[word]\\n                    max_word = word\\n        return max_word\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 466877,
                "title": "python-counter-regex-solution-faster-than-98-5",
                "content": "```\\nfrom collections import Counter\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.split(\\'[!?\\\\\\',;. ]\\', paragraph.lower()))\\n        for (word, count) in c.most_common():\\n            if word not in banned and word != \\'\\':\\n                return word\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.split(\\'[!?\\\\\\',;. ]\\', paragraph.lower()))\\n        for (word, count) in c.most_common():\\n            if word not in banned and word != \\'\\':\\n                return word\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348148,
                "title": "javascript-beats-99-hashmap",
                "content": "```\\n/**\\n * @param {string} paragraph\\n * @param {string[]} banned\\n * @return {string}\\n */\\nvar mostCommonWord = function(paragraph, banned) {\\n    const words = paragraph.toLowerCase().split(/[ !?\\',;.]/);\\n    const map = new Map();\\n    const set = new Set(banned);\\n    words.forEach(word => map.set(word, map.has(word) ? map.get(word) + 1 : 1));\\n    set.forEach(banned => {\\n        if(map.has(banned)) map.delete(banned);\\n    });\\n    \\n    let res = \\'\\', max = Number.MIN_SAFE_INTEGER;\\n    for(let [word, count] of map.entries()) {\\n        if(word) {\\n            res = count > max ? word : res;\\n            max = count > max ? count : max;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} paragraph\\n * @param {string[]} banned\\n * @return {string}\\n */\\nvar mostCommonWord = function(paragraph, banned) {\\n    const words = paragraph.toLowerCase().split(/[ !?\\',;.]/);\\n    const map = new Map();\\n    const set = new Set(banned);\\n    words.forEach(word => map.set(word, map.has(word) ? map.get(word) + 1 : 1));\\n    set.forEach(banned => {\\n        if(map.has(banned)) map.delete(banned);\\n    });\\n    \\n    let res = \\'\\', max = Number.MIN_SAFE_INTEGER;\\n    for(let [word, count] of map.entries()) {\\n        if(word) {\\n            res = count > max ? word : res;\\n            max = count > max ? count : max;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3274538,
                "title": "java-short-8-line-code-beats-95-45",
                "content": "# Code\\n```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] ban) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        Set<String> set = new HashSet<>(Arrays.asList(ban));\\n\\n        for(String i : paragraph.replaceAll(\"\\\\\\\\W+\" , \" \").toLowerCase().split(\"\\\\\\\\s+\")){\\n            if(!set.contains(i))map.put(i, map.getOrDefault(i,0)+1);\\n        }\\n\\n        int max = Integer.MIN_VALUE;\\n        String res = \"\";\\n        for(String i : map.keySet()){\\n            if(map.get(i) > max){\\n                max = map.get(i);\\n                res = i;\\n            }\\n        } \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] ban) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        Set<String> set = new HashSet<>(Arrays.asList(ban));\\n\\n        for(String i : paragraph.replaceAll(\"\\\\\\\\W+\" , \" \").toLowerCase().split(\"\\\\\\\\s+\")){\\n            if(!set.contains(i))map.put(i, map.getOrDefault(i,0)+1);\\n        }\\n\\n        int max = Integer.MIN_VALUE;\\n        String res = \"\";\\n        for(String i : map.keySet()){\\n            if(map.get(i) > max){\\n                max = map.get(i);\\n                res = i;\\n            }\\n        } \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613988,
                "title": "c-4ms-clean-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        unordered_map<string,int>m;\\n        int frequency = 0;\\n        string s = \"\";\\n        for(int i=0;i<p.size();i++){\\n            if((p[i]>=\\'a\\' and p[i]<=\\'z\\') or (p[i]>=\\'A\\' and p[i]<=\\'Z\\')){\\n                s+=tolower(p[i]);\\n            }\\n            else{\\n                if(s.length()>0){\\n                    m[s]++,s=\"\";\\n                }\\n            }\\n        }\\n        m[s]++;\\n        for(auto i:banned)  m[i]=0;\\n        for(auto i:m){\\n            if(frequency<=i.second){\\n                s=i.first,frequency = i.second;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/84db0c16-77b3-495b-b83c-0122c8ffa289_1638759978.574484.jpeg)\\n\\n\\n\\n**If you have any questions, feel free to comment below.\\nPlease help to UPVOTE if this post is useful for you.\\nHAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        unordered_map<string,int>m;\\n        int frequency = 0;\\n        string s = \"\";\\n        for(int i=0;i<p.size();i++){\\n            if((p[i]>=\\'a\\' and p[i]<=\\'z\\') or (p[i]>=\\'A\\' and p[i]<=\\'Z\\')){\\n                s+=tolower(p[i]);\\n            }\\n            else{\\n                if(s.length()>0){\\n                    m[s]++,s=\"\";\\n                }\\n            }\\n        }\\n        m[s]++;\\n        for(auto i:banned)  m[i]=0;\\n        for(auto i:m){\\n            if(frequency<=i.second){\\n                s=i.first,frequency = i.second;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820773,
                "title": "python-solution-97-faster",
                "content": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        counter = defaultdict(int)\\n        # remove special chars and make lower\\n        paragraph = re.findall(r\\'\\\\w+\\', paragraph.lower()) \\n        for word in paragraph:\\n            if word not in banned:\\n                counter[word] += 1\\n\\n        return  max(counter, key= lambda x: counter[x]) \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        counter = defaultdict(int)\\n        # remove special chars and make lower\\n        paragraph = re.findall(r\\'\\\\w+\\', paragraph.lower()) \\n        for word in paragraph:\\n            if word not in banned:\\n                counter[word] += 1\\n\\n        return  max(counter, key= lambda x: counter[x]) \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 692486,
                "title": "java-10ms-but-clear-code-many-comments",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n      \\n      /*\\n      Runtime: 10 ms, faster than 70.48% of Java online submissions for Most Common Word.\\n      Memory Usage: 39.4 MB, less than 78.59% of Java online submissions for Most Common Word.\\n      */\\n      \\n      // store banned words in a HashSet for fast lookup later\\n      Set<String> bannedWords = new HashSet<String>(Arrays.asList(banned));\\n      \\n      // convert to lowercase\\n      paragraph = paragraph.toLowerCase();\\n      \\n      // remove punctuation\\n      String punctuation = \"!?\\',;.\";\\n      for (char c : punctuation.toCharArray()) {\\n        paragraph = paragraph.replace(c, \\' \\'); // OK to increase the number of spaces, because our tokenizing will ignore sequences of whitespace\\n      }\\n      \\n      // tokenize and load non-banned words into HashMap\\n      String[] tokens = paragraph.split(\"\\\\\\\\s+\"); // split on any amount of whitespace\\n      Map<String, Integer> frequencyTable = new HashMap<>();      \\n      for (String s : tokens) {\\n        if (!bannedWords.contains(s)) {\\n          frequencyTable.merge(s, 1, Integer::sum); // handy merge() method!\\n        }\\n      }\\n      \\n      // traverse HashMap and determine highest-frequency word\\n      int maxFrequency = 0;\\n      String maxWord = \"\";\\n      \\n      for (Map.Entry<String, Integer> e : frequencyTable.entrySet()) {\\n        if (e.getValue() > maxFrequency) {\\n          maxFrequency = e.getValue();\\n          maxWord = e.getKey();\\n        }\\n      }\\n      \\n      return maxWord;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n      \\n      /*\\n      Runtime: 10 ms, faster than 70.48% of Java online submissions for Most Common Word.\\n      Memory Usage: 39.4 MB, less than 78.59% of Java online submissions for Most Common Word.\\n      */\\n      \\n      // store banned words in a HashSet for fast lookup later\\n      Set<String> bannedWords = new HashSet<String>(Arrays.asList(banned));\\n      \\n      // convert to lowercase\\n      paragraph = paragraph.toLowerCase();\\n      \\n      // remove punctuation\\n      String punctuation = \"!?\\',;.\";\\n      for (char c : punctuation.toCharArray()) {\\n        paragraph = paragraph.replace(c, \\' \\'); // OK to increase the number of spaces, because our tokenizing will ignore sequences of whitespace\\n      }\\n      \\n      // tokenize and load non-banned words into HashMap\\n      String[] tokens = paragraph.split(\"\\\\\\\\s+\"); // split on any amount of whitespace\\n      Map<String, Integer> frequencyTable = new HashMap<>();      \\n      for (String s : tokens) {\\n        if (!bannedWords.contains(s)) {\\n          frequencyTable.merge(s, 1, Integer::sum); // handy merge() method!\\n        }\\n      }\\n      \\n      // traverse HashMap and determine highest-frequency word\\n      int maxFrequency = 0;\\n      String maxWord = \"\";\\n      \\n      for (Map.Entry<String, Integer> e : frequencyTable.entrySet()) {\\n        if (e.getValue() > maxFrequency) {\\n          maxFrequency = e.getValue();\\n          maxWord = e.getKey();\\n        }\\n      }\\n      \\n      return maxWord;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686043,
                "title": "functional-solution-in-java",
                "content": "Probably not the best solution to choose in a coding interview but a fun way to solve this problem in Java.\\n```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String[] words = paragraph\\n            .toLowerCase()\\n            .split(\"[\\\\\\\\p{Punct}\\\\\\\\s]+\");\\n\\n        Set<String> bannedWords = Set.of(banned);\\n        \\n        return Arrays\\n            .asList(words)\\n            .stream()\\n            .filter(word -> !bannedWords.contains(word))\\n            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))\\n            .entrySet()\\n            .stream()\\n            .max(Comparator.comparing(Map.Entry<String, Long>::getValue))\\n            .get()\\n            .getKey();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String[] words = paragraph\\n            .toLowerCase()\\n            .split(\"[\\\\\\\\p{Punct}\\\\\\\\s]+\");\\n\\n        Set<String> bannedWords = Set.of(banned);\\n        \\n        return Arrays\\n            .asList(words)\\n            .stream()\\n            .filter(word -> !bannedWords.contains(word))\\n            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))\\n            .entrySet()\\n            .stream()\\n            .max(Comparator.comparing(Map.Entry<String, Long>::getValue))\\n            .get()\\n            .getKey();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575644,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public string MostCommonWord(string paragraph, string[] banned) {\\n            HashSet<string> set = new HashSet<string>(banned);\\n\\n            foreach (var str in paragraph.Replace(\"!\", \" \")\\n                                         .Replace(\"?\", \" \")\\n                                         .Replace(\"\\'\", \" \")\\n                                         .Replace(\",\", \" \")\\n                                         .Replace(\";\", \" \")\\n                                         .Replace(\".\", \" \")\\n                                         .ToLower()\\n                                         .Split(new char[] { \\' \\' }, StringSplitOptions.RemoveEmptyEntries)\\n                                         .GroupBy(x => x)\\n                                         .OrderByDescending(x => x.Count())\\n                                         .Select(x => x.Key))\\n                if (!set.Contains(str))\\n                    return str;\\n\\n            return string.Empty;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public string MostCommonWord(string paragraph, string[] banned) {\\n            HashSet<string> set = new HashSet<string>(banned);\\n\\n            foreach (var str in paragraph.Replace(\"!\", \" \")\\n                                         .Replace(\"?\", \" \")\\n                                         .Replace(\"\\'\", \" \")\\n                                         .Replace(\",\", \" \")\\n                                         .Replace(\";\", \" \")\\n                                         .Replace(\".\", \" \")\\n                                         .ToLower()\\n                                         .Split(new char[] { \\' \\' }",
                "codeTag": "Java"
            },
            {
                "id": 500791,
                "title": "python-3-another-solution-explained",
                "content": "Runtime: 32 ms, faster than 69.45% of Python3 online submissions for Most Common Word.\\nMemory Usage: 12.6 MB, less than 100.00% of Python3 online submissions for Most Common Word.\\n\\n```Python 3\\nimport string\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        translator = str.maketrans(string.punctuation, \\' \\'*32)\\n        a = paragraph.lower().translate(translator).split()\\n        b = [w for w in a if w not in banned]\\n        return max(b, key = b.count)\\n```\\n\\n**Explanation:**\\n\\n1. First, we create translation map using [str.maketrans](https://docs.python.org/3/library/stdtypes.html#str.maketrans) (<- link to the official doc) to remove all punctuation from the paragraph. If you print `print(string.punctuation)` you will get: `!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~`. The length of this string is 32 symbols. Since first two maketrans arguments must have equal length, we make second argument equal to 32 symbols by using \\' \\'*32 or 32 spaces. That\\'s how we tell to translate all punctuation symbols into spaces.\\n2. Then we convert our `paragraph` to lower case, translate all punctuation into spaces using translator from step one and then split paragraph into words by spaces.\\n3. Then we create new list by saving only those words from paragraph that are **not** in the banned list.\\n4. Finally, we return value that counted max times in our new list.\\n\\nPleaase, upvote if you like this solution so that others can see and learn from it. Thanks!\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python 3\\nimport string\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        translator = str.maketrans(string.punctuation, \\' \\'*32)\\n        a = paragraph.lower().translate(translator).split()\\n        b = [w for w in a if w not in banned]\\n        return max(b, key = b.count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415594,
                "title": "simple-c-99-20-lines-o-n",
                "content": "Pretty straight forward, the two edge cases are \\n- making sure you count end-of-string as hitting a delimiter and working with whatever word is in the buffer at that time\\n- making sure you don\\'t count an empty string word in your wordCount structure\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_set<string> bannedWords(banned.begin(), banned.end());\\n        unordered_map<string,int> wordCountMap;\\n        string word, winnerWord = \"\";\\n        int winnerCount = 0;\\n        \\n        for (int i = 0; i <= paragraph.size(); ++i) {\\n            bool delimHit = i == paragraph.size() || !isalpha(paragraph[i]);\\n            if (delimHit) {\\n                if (!word.size())\\n                    continue;\\n                if (bannedWords.find(word) == bannedWords.end() && ++wordCountMap[word] > winnerCount) {\\n                    winnerCount = wordCountMap[word];\\n                    winnerWord = word;\\n                }\\n                word = \"\";\\n            } else {\\n                word += tolower(paragraph[i]);\\n            }\\n        }\\n        \\n        return winnerWord;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_set<string> bannedWords(banned.begin(), banned.end());\\n        unordered_map<string,int> wordCountMap;\\n        string word, winnerWord = \"\";\\n        int winnerCount = 0;\\n        \\n        for (int i = 0; i <= paragraph.size(); ++i) {\\n            bool delimHit = i == paragraph.size() || !isalpha(paragraph[i]);\\n            if (delimHit) {\\n                if (!word.size())\\n                    continue;\\n                if (bannedWords.find(word) == bannedWords.end() && ++wordCountMap[word] > winnerCount) {\\n                    winnerCount = wordCountMap[word];\\n                    winnerWord = word;\\n                }\\n                word = \"\";\\n            } else {\\n                word += tolower(paragraph[i]);\\n            }\\n        }\\n        \\n        return winnerWord;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 408056,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        d = dict()\\n        for c in paragraph:\\n            if(c == \\'!\\' or c == \\',\\' or c == \\'.\\' or c == \\'?\\' or c == \\';\\' or c == \"\\'\"):\\n                paragraph = paragraph.replace(c, \\' \\')\\n\\n        paragraph = paragraph.split()\\n        for word in paragraph:\\n            word = word.lower()\\n            if(word not in banned):\\n                if(word not in d):\\n                    d[word] = 1\\n                    \\n                else:\\n                    d[word] += 1\\n                    \\n\\n        return max(d, key = d.get)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        d = dict()\\n        for c in paragraph:\\n            if(c == \\'!\\' or c == \\',\\' or c == \\'.\\' or c == \\'?\\' or c == \\';\\' or c == \"\\'\"):\\n                paragraph = paragraph.replace(c, \\' \\')\\n\\n        paragraph = paragraph.split()\\n        for word in paragraph:\\n            word = word.lower()\\n            if(word not in banned):\\n                if(word not in d):\\n                    d[word] = 1\\n                    \\n                else:\\n                    d[word] += 1\\n                    \\n\\n        return max(d, key = d.get)",
                "codeTag": "Java"
            },
            {
                "id": 374139,
                "title": "straightforward-c-solution",
                "content": "Firstly I am doing error checking to see if the given paragraph is empty or not. There are some important points in this code:\\n\\n1) I am transferring the values in the banned vector to a set, to later on search over those words efficiently. Also since set will have unique values, we are eliminating the possibility of wating our time with the same banned words if there are any.\\n2) In the for loop, I am cleaning the paragraph. Since our search will be case insensitive we will have to convert all characters in the paragraph to lower case since all of the banned words are in lower case. Doing this, we will have a common ground to search over. I am also replacing any non-alphabetic character with a space. Do not forget to iterate over the characters in the paragraph by reference since we want to modify them.\\n3) I am utilizing input string stream to parse words from the paragraph. Note that we could also have used a simple string stream but input string stream makes our intention clearer.\\n\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        if(p.empty()) return {};\\n        \\n        std::string res;\\n        std::unordered_set<string> banned_words(banned.begin(), banned.end());\\n        std::unordered_map<string, int> count_map;\\n        \\n        for (auto& ch : p) {\\n            ch = isalpha(ch) ? tolower(ch) : \\' \\';\\n        }\\n        \\n        istringstream iss(p);\\n        std::string word; \\n        \\n        int max = INT_MIN;\\n        \\n        \\n        while(iss >> word) {\\n            if(banned_words.find(word) == banned_words.end()) {\\n                ++count_map[word];\\n                if(count_map[word] > max) {\\n                    max = count_map[word];\\n                    res = word;\\n                }\\n            }\\n        }\\n        \\n        return res;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        if(p.empty()) return {};\\n        \\n        std::string res;\\n        std::unordered_set<string> banned_words(banned.begin(), banned.end());\\n        std::unordered_map<string, int> count_map;\\n        \\n        for (auto& ch : p) {\\n            ch = isalpha(ch) ? tolower(ch) : \\' \\';\\n        }\\n        \\n        istringstream iss(p);\\n        std::string word; \\n        \\n        int max = INT_MIN;\\n        \\n        \\n        while(iss >> word) {\\n            if(banned_words.find(word) == banned_words.end()) {\\n                ++count_map[word];\\n                if(count_map[word] > max) {\\n                    max = count_map[word];\\n                    res = word;\\n                }\\n            }\\n        }\\n        \\n        return res;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345695,
                "title": "c-very-easy-solution-o-n-8ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) \\n    {\\n        unordered_set<string> bannedWords;\\n        for(string & s : banned)\\n            bannedWords.insert(s); // for a fast lookup\\n        bannedWords.insert(\"\"); // to tackle an edge case\\n        map<string, int> topWords;\\n        unordered_set<string> punctuations; // for convenience sake\\n        punctuations.insert(\"!\");\\n        punctuations.insert(\"\\'\");\\n        punctuations.insert(\"?\");\\n        punctuations.insert(\",\");\\n        punctuations.insert(\";\");\\n        punctuations.insert(\".\");\\n        string current = \"\";\\n        for(char & c : paragraph)\\n        {\\n            if(c == \\' \\' || punctuations.count(string(1, c)))\\n            {\\n                if(!bannedWords.count(current))\\n                {\\n                    cout << current << \"!\";\\n                    ++topWords[current];\\n                }\\n                current = \"\";\\n            }\\n            else current += char(tolower(c));\\n        }\\n        if(!bannedWords.count(current))\\n            ++topWords[current];\\n        pair<int, string> result(0, \"\");\\n        for(auto & it : topWords)\\n        {\\n            if(it.second > result.first)\\n                result = {it.second, it.first};\\n        }\\n        return result.second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) \\n    {\\n        unordered_set<string> bannedWords;\\n        for(string & s : banned)\\n            bannedWords.insert(s); // for a fast lookup\\n        bannedWords.insert(\"\"); // to tackle an edge case\\n        map<string, int> topWords;\\n        unordered_set<string> punctuations; // for convenience sake\\n        punctuations.insert(\"!\");\\n        punctuations.insert(\"\\'\");\\n        punctuations.insert(\"?\");\\n        punctuations.insert(\",\");\\n        punctuations.insert(\";\");\\n        punctuations.insert(\".\");\\n        string current = \"\";\\n        for(char & c : paragraph)\\n        {\\n            if(c == \\' \\' || punctuations.count(string(1, c)))\\n            {\\n                if(!bannedWords.count(current))\\n                {\\n                    cout << current << \"!\";\\n                    ++topWords[current];\\n                }\\n                current = \"\";\\n            }\\n            else current += char(tolower(c));\\n        }\\n        if(!bannedWords.count(current))\\n            ++topWords[current];\\n        pair<int, string> result(0, \"\");\\n        for(auto & it : topWords)\\n        {\\n            if(it.second > result.first)\\n                result = {it.second, it.first};\\n        }\\n        return result.second;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 332220,
                "title": "weird-bug-of-using-range-based-loop-for-unordered-map-c",
                "content": "This is my Accepted submission, I post it here for a full view of my code before describing the bug below.\\n\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        paragraph += \\' \\';\\n        string word = \"\";\\n        unordered_map<string, int> map;\\n        unordered_set<string> ban(banned.begin(), banned.end());\\n        ban.insert(\"\");\\n        for (auto c: paragraph) {\\n            if (!isalpha(c)) {\\n                if (!ban.count(word)) {\\n                    if (map.count(word) == 0) map[word] = 0;\\n                    map[word]++;\\n                }\\n                word = \"\";\\n            } else {\\n                word += tolower(c);\\n            }\\n        }\\n        int prev = map[word];\\n        for (auto &kv: map) {\\n            if (kv.second > prev) {\\n                word = kv.first;\\n                prev = kv.second;\\n            }\\n        }\\n        return word;\\n    }\\n};\\n```\\n\\nIn a previous submission, I did the last loop as follows\\n\\n```\\n        for (auto &kv: map) {\\n            if (kv.second > map[word]) {\\n                word = kv.first;\\n            }\\n        }\\n```\\n\\nFor some unknown reasons, the loop doesn\\'t visit all key-value pairs in the map. For example, in the test `a, a, a, a, b,b,b,c, c`, the code will only check key `c` and skip key `b`. The part ` map[word]` seems to be problematic, I took it out and the problem went away. I am clueless about why it behaves as such, let me know if you have any idea.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        paragraph += \\' \\';\\n        string word = \"\";\\n        unordered_map<string, int> map;\\n        unordered_set<string> ban(banned.begin(), banned.end());\\n        ban.insert(\"\");\\n        for (auto c: paragraph) {\\n            if (!isalpha(c)) {\\n                if (!ban.count(word)) {\\n                    if (map.count(word) == 0) map[word] = 0;\\n                    map[word]++;\\n                }\\n                word = \"\";\\n            } else {\\n                word += tolower(c);\\n            }\\n        }\\n        int prev = map[word];\\n        for (auto &kv: map) {\\n            if (kv.second > prev) {\\n                word = kv.first;\\n                prev = kv.second;\\n            }\\n        }\\n        return word;\\n    }\\n};\\n```\n```\\n        for (auto &kv: map) {\\n            if (kv.second > map[word]) {\\n                word = kv.first;\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 305493,
                "title": "python3-solution-faster-than-99-74-submissions-using-dict",
                "content": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        import re\\n        d={}\\n        paragraph = re.sub(r\\'[^\\\\w\\\\s]\\',\\' \\',paragraph)\\n        paragraph=paragraph.split()\\n        for i in paragraph:\\n            i=i.lower()\\n            if i not in banned:\\n                if i in d:\\n                    d[i]+=1\\n                else:\\n                    d[i]=1\\n        key,value= max(d.items(),key= lambda k:k[1])\\n        return (\"\".join(str(key)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        import re\\n        d={}\\n        paragraph = re.sub(r\\'[^\\\\w\\\\s]\\',\\' \\',paragraph)\\n        paragraph=paragraph.split()\\n        for i in paragraph:\\n            i=i.lower()\\n            if i not in banned:\\n                if i in d:\\n                    d[i]+=1\\n                else:\\n                    d[i]=1\\n        key,value= max(d.items(),key= lambda k:k[1])\\n        return (\"\".join(str(key)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 153310,
                "title": "c-solution",
                "content": "    Hopefully straightforward C# solution\\n\\t\\t\\n\\t\\tpublic string MostCommonWord(string paragraph, string[] banned) {\\n        if (string.IsNullOrEmpty(paragraph)) return null;\\n        \\n        // Could have used linq here, however duplicate banned words would have tripped this up.\\n        var bannedWords = new HashSet<string>();\\n        foreach(var b in banned) {\\n            if (!bannedWords.Contains(b)) bannedWords.Add(b);\\n        }\\n        \\n        // Simple string replace\\n        var words = paragraph\\n            .Replace(\"!\", \"\")\\n            .Replace(\"?\",\"\")\\n            .Replace(\"\\'\",\"\")\\n            .Replace(\",\",\"\")\\n            .Replace(\".\",\"\")\\n            .Replace(\";\",\"\")\\n            .ToLower()\\n            .Split(\\' \\');\\n        \\n        // So we don\\'t need another loop\\n        var maxWord = string.Empty;\\n        var maxWordCount = 0;\\n        \\n        var wordCount = new Dictionary<string, int>();\\n        foreach(var word in words) {\\n            if (bannedWords.Contains(word)) continue;\\n            if (wordCount.ContainsKey(word)) {\\n                wordCount[word] = wordCount[word] + 1;                \\n            } else {\\n                wordCount.Add(word, 1);\\n            }\\n            \\n            if (maxWordCount <= wordCount[word]){\\n                maxWordCount = wordCount[word];\\n                maxWord = word;\\n            }\\n        }\\n        \\n        return maxWord;\\n    }",
                "solutionTags": [],
                "code": "    Hopefully straightforward C# solution\\n\\t\\t\\n\\t\\tpublic string MostCommonWord(string paragraph, string[] banned) {\\n        if (string.IsNullOrEmpty(paragraph)) return null;\\n        \\n        // Could have used linq here, however duplicate banned words would have tripped this up.\\n        var bannedWords = new HashSet<string>();\\n        foreach(var b in banned) {\\n            if (!bannedWords.Contains(b)) bannedWords.Add(b);\\n        }\\n        \\n        // Simple string replace\\n        var words = paragraph\\n            .Replace(\"!\", \"\")\\n            .Replace(\"?\",\"\")\\n            .Replace(\"\\'\",\"\")\\n            .Replace(\",\",\"\")\\n            .Replace(\".\",\"\")\\n            .Replace(\";\",\"\")\\n            .ToLower()\\n            .Split(\\' \\');\\n        \\n        // So we don\\'t need another loop\\n        var maxWord = string.Empty;\\n        var maxWordCount = 0;\\n        \\n        var wordCount = new Dictionary<string, int>();\\n        foreach(var word in words) {\\n            if (bannedWords.Contains(word)) continue;\\n            if (wordCount.ContainsKey(word)) {\\n                wordCount[word] = wordCount[word] + 1;                \\n            } else {\\n                wordCount.Add(word, 1);\\n            }\\n            \\n            if (maxWordCount <= wordCount[word]){\\n                maxWordCount = wordCount[word];\\n                maxWord = word;\\n            }\\n        }\\n        \\n        return maxWord;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2504397,
                "title": "c-hashmap-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string s, vector<string>& banned) {\\n        unordered_map<string,int> m;\\n        string t=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if((s[i]>=\\'a\\' && s[i]<=\\'z\\')||(s[i]>=\\'A\\' && s[i]<=\\'Z\\'))\\n                t+=tolower(s[i]);\\n            else\\n            {\\n                if(t.length())\\n                    m[t]++;\\n                t=\"\";\\n            }\\n        }\\n        if(t.length())\\n            m[t]++;\\n        for(auto x:banned)\\n            m[x]=0;\\n        int res=0;\\n        t=\"\";\\n        for(auto x:m)\\n        {\\n            if(res<x.second)\\n            {\\n                res=x.second;\\n                t=x.first;\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string s, vector<string>& banned) {\\n        unordered_map<string,int> m;\\n        string t=\"\";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if((s[i]>=\\'a\\' && s[i]<=\\'z\\')||(s[i]>=\\'A\\' && s[i]<=\\'Z\\'))\\n                t+=tolower(s[i]);\\n            else\\n            {\\n                if(t.length())\\n                    m[t]++;\\n                t=\"\";\\n            }\\n        }\\n        if(t.length())\\n            m[t]++;\\n        for(auto x:banned)\\n            m[x]=0;\\n        int res=0;\\n        t=\"\";\\n        for(auto x:m)\\n        {\\n            if(res<x.second)\\n            {\\n                res=x.second;\\n                t=x.first;\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424816,
                "title": "819-most-common-word",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        unordered_map<string,int> mp;\\n        int n = p.size();\\n        for(int i = 0 ; i < n ;){\\n            string s = \"\";\\n            while(i < n and isalpha(p[i])) s+=tolower(p[i++]);\\n            while(i < n and !isalpha(p[i])) i++;\\n             mp[s]++;\\n        }\\n       for(auto it : banned) mp[it] = 0;\\n        string ans = \"\";\\n        int c = INT_MIN;\\n        for(auto it : mp){\\n            if(it.second > c) {\\n                c = it.second;\\n                ans = it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        unordered_map<string,int> mp;\\n        int n = p.size();\\n        for(int i = 0 ; i < n ;){\\n            string s = \"\";\\n            while(i < n and isalpha(p[i])) s+=tolower(p[i++]);\\n            while(i < n and !isalpha(p[i])) i++;\\n             mp[s]++;\\n        }\\n       for(auto it : banned) mp[it] = 0;\\n        string ans = \"\";\\n        int c = INT_MIN;\\n        for(auto it : mp){\\n            if(it.second > c) {\\n                c = it.second;\\n                ans = it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1432113,
                "title": "c-easy-and-understandable-solution-using-map-with-explanations",
                "content": "Approach:\\nFind the occurences of each word in the paragraph given and store it in a map. Then for each word in the banned vector, find if it is present in the map, delete that particular word from the map. Then iterate through each element of the map to the find the most frequent word and return it.\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string s, vector<string>& ban) {\\n        //create a map to store the word and its frequencies\\n        //create a temporary string to find words present in the paragraph\\n        map<string,int> arr;\\n        string temp = \"\";\\n        //iterate through the paragraph(i have renamed it as \\'s\\') to find all the words present\\n        for(int i=0;i<s.length();i++){\\n            //if the character is between the range of lower or upper characters then we add it to the temporary string.\\n            if((s[i]>=\\'a\\'&&s[i]<=\\'z\\')||(s[i]>=\\'A\\'&&s[i]<=\\'Z\\')){\\n                temp += s[i];\\n            }else{//else if check if temp is empty or not\\n                if(temp==\"\"){\\n                    //if temp is empty, it means no word have been found. So continue with loop\\n                    continue;\\n                }else{\\n                    //if temp is not empty, convert all characters to lower case.\\n                    //increase occurence of that word in the map. intially new element will be zero.\\n                    transform(temp.begin(),temp.end(),temp.begin(),::tolower);\\n                    arr[temp]++;\\n                    //after increasing, reset temp = \"\" (empty string).\\n                    temp = \"\";\\n                }\\n            }\\n        }\\n        //the following if case if when the paragraph ends without a fullstop.\\n        if(temp!=\"\"){\\n            transform(temp.begin(),temp.end(),temp.begin(),::tolower);\\n            arr[temp]++;\\n        }\\n        //now we iterate through the banned vector to see if have counted those words in the map. If yes, we delete that element from map.\\n        for(int i=0;i<ban.size();i++){\\n            if(arr.find(ban[i])!=arr.end()){\\n                arr.erase(ban[i]);  \\n            }\\n        }\\n        //Now we will find the most frequent word\\n        string word;\\n        int count = INT_MIN;\\n        for(auto i:arr){\\n            if(i.second>count){\\n                count = i.second;\\n                word = i.first;\\n            }\\n        }\\n        return word;\\n    }\\n};\\n```\\nHope you find my solution useful and if you have any doubts or suggestions feel free to comment below.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string s, vector<string>& ban) {\\n        //create a map to store the word and its frequencies\\n        //create a temporary string to find words present in the paragraph\\n        map<string,int> arr;\\n        string temp = \"\";\\n        //iterate through the paragraph(i have renamed it as \\'s\\') to find all the words present\\n        for(int i=0;i<s.length();i++){\\n            //if the character is between the range of lower or upper characters then we add it to the temporary string.\\n            if((s[i]>=\\'a\\'&&s[i]<=\\'z\\')||(s[i]>=\\'A\\'&&s[i]<=\\'Z\\')){\\n                temp += s[i];\\n            }else{//else if check if temp is empty or not\\n                if(temp==\"\"){\\n                    //if temp is empty, it means no word have been found. So continue with loop\\n                    continue;\\n                }else{\\n                    //if temp is not empty, convert all characters to lower case.\\n                    //increase occurence of that word in the map. intially new element will be zero.\\n                    transform(temp.begin(),temp.end(),temp.begin(),::tolower);\\n                    arr[temp]++;\\n                    //after increasing, reset temp = \"\" (empty string).\\n                    temp = \"\";\\n                }\\n            }\\n        }\\n        //the following if case if when the paragraph ends without a fullstop.\\n        if(temp!=\"\"){\\n            transform(temp.begin(),temp.end(),temp.begin(),::tolower);\\n            arr[temp]++;\\n        }\\n        //now we iterate through the banned vector to see if have counted those words in the map. If yes, we delete that element from map.\\n        for(int i=0;i<ban.size();i++){\\n            if(arr.find(ban[i])!=arr.end()){\\n                arr.erase(ban[i]);  \\n            }\\n        }\\n        //Now we will find the most frequent word\\n        string word;\\n        int count = INT_MIN;\\n        for(auto i:arr){\\n            if(i.second>count){\\n                count = i.second;\\n                word = i.first;\\n            }\\n        }\\n        return word;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544968,
                "title": "simple-java",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String[] p = paragraph.replaceAll(\"!\", \"\")\\n            .replaceAll(\"\\\\\\\\?\", \" \")\\n            .replaceAll(\"\\'\", \" \")\\n            .replaceAll(\",\", \" \")\\n            .replaceAll(\";\", \" \")\\n            .replaceAll(\"\\\\\\\\.\", \" \")\\n            .toLowerCase()\\n            .replaceAll(\"\\\\\\\\s+\", \" \")\\n            .split(\" \");\\n        \\n        Map<String, Integer> map = new HashMap();\\n        for (String s : p)\\n            map.put(s, map.getOrDefault(s, 0) + 1);\\n        \\n        for (String s : banned)\\n            if (map.containsKey(s))\\n                map.remove(s);\\n        \\n        int max = 0;\\n        String s = \"\";\\n        \\n        for (String k : map.keySet()) {\\n            if (map.get(k) > max) {\\n                max = map.get(k);\\n                s = k;\\n            }\\n        }\\n        \\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String[] p = paragraph.replaceAll(\"!\", \"\")\\n            .replaceAll(\"\\\\\\\\?\", \" \")\\n            .replaceAll(\"\\'\", \" \")\\n            .replaceAll(\",\", \" \")\\n            .replaceAll(\";\", \" \")\\n            .replaceAll(\"\\\\\\\\.\", \" \")\\n            .toLowerCase()\\n            .replaceAll(\"\\\\\\\\s+\", \" \")\\n            .split(\" \");\\n        \\n        Map<String, Integer> map = new HashMap();\\n        for (String s : p)\\n            map.put(s, map.getOrDefault(s, 0) + 1);\\n        \\n        for (String s : banned)\\n            if (map.containsKey(s))\\n                map.remove(s);\\n        \\n        int max = 0;\\n        String s = \"\";\\n        \\n        for (String k : map.keySet()) {\\n            if (map.get(k) > max) {\\n                max = map.get(k);\\n                s = k;\\n            }\\n        }\\n        \\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509099,
                "title": "javascript-easy-one-pass-solution",
                "content": "```javascript\\n/**\\n * @param {string} paragraph\\n * @param {string[]} banned\\n * @return {string}\\n */\\nvar mostCommonWord = function(paragraph, banned) {\\n  let most;\\n  const map = {};\\n  const words = paragraph.toLowerCase().split(/[ !?\\',;.]/);\\n  words.forEach(w => {\\n    if (w && !banned.includes(w)) {\\n      map[w] = (map[w] || 0) + 1;\\n      if (!most || map[w] > map[most]) most = w;\\n    }\\n  });\\n  return most;\\n};\\n```\\n\\n* 47/47 cases passed (56 ms)\\n* Your runtime beats 89.74 % of javascript submissions\\n* Your memory usage beats 100 % of javascript submissions (35.2 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string} paragraph\\n * @param {string[]} banned\\n * @return {string}\\n */\\nvar mostCommonWord = function(paragraph, banned) {\\n  let most;\\n  const map = {};\\n  const words = paragraph.toLowerCase().split(/[ !?\\',;.]/);\\n  words.forEach(w => {\\n    if (w && !banned.includes(w)) {\\n      map[w] = (map[w] || 0) + 1;\\n      if (!most || map[w] > map[most]) most = w;\\n    }\\n  });\\n  return most;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 468842,
                "title": "c-linq",
                "content": "\\tpublic class Solution \\n\\t{\\n\\t\\tpublic string MostCommonWord(string paragraph, string[] banned) \\n\\t\\t{\\n\\t\\t\\tvar set = new HashSet<string>(banned);\\n        \\n\\t\\t\\treturn paragraph\\n\\t\\t\\t\\t.ToLower()\\n\\t\\t\\t\\t.Split(\"!?\\',;. \".ToCharArray(), StringSplitOptions.RemoveEmptyEntries)\\n\\t\\t\\t\\t.Where(c => !set.Contains(c))\\n\\t\\t\\t\\t.GroupBy(x => x)\\n\\t\\t\\t\\t.Select(x => new { str = x.Key, Num = x.Count() })\\n\\t\\t\\t\\t.OrderByDescending(x => x.Num).First().str;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution \\n\\t{\\n\\t\\tpublic string MostCommonWord(string paragraph, string[] banned) \\n\\t\\t{\\n\\t\\t\\tvar set = new HashSet<string>(banned);\\n        \\n\\t\\t\\treturn paragraph\\n\\t\\t\\t\\t.ToLower()\\n\\t\\t\\t\\t.Split(\"!?\\',;. \".ToCharArray(), StringSplitOptions.RemoveEmptyEntries)\\n\\t\\t\\t\\t.Where(c => !set.Contains(c))\\n\\t\\t\\t\\t.GroupBy(x => x)\\n\\t\\t\\t\\t.Select(x => new { str = x.Key, Num = x.Count() }",
                "codeTag": "Java"
            },
            {
                "id": 465703,
                "title": "python-easy-to-understand-small-code",
                "content": "```\\nfrom collections import Counter\\nimport string\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\n        for c in string.punctuation: \\n            paragraph = paragraph.replace(c, \" \")\\n            \\n        c = Counter(paragraph.lower().split())\\n        \\n        for item, count in c.most_common():\\n            if item not in banned:\\n                return item\\n        return None\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\nimport string\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\n        for c in string.punctuation: \\n            paragraph = paragraph.replace(c, \" \")\\n            \\n        c = Counter(paragraph.lower().split())\\n        \\n        for item, count in c.most_common():\\n            if item not in banned:\\n                return item\\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463404,
                "title": "9-line-string-stream-solution-c",
                "content": "```\\nstring mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_set<string> b(banned.begin(), banned.end());\\n        unordered_map<string, int> m;\\n        for(char &c : paragraph) c = isalpha(c) ? tolower(c) : \\' \\';\\n        istringstream iss(paragraph);\\n        string res = \"\", w;\\n        while(iss >> w) {\\n            if(b.find(w) == b.end()) res = m[res] < ++m[w] ? w : res;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\nstring mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_set<string> b(banned.begin(), banned.end());\\n        unordered_map<string, int> m;\\n        for(char &c : paragraph) c = isalpha(c) ? tolower(c) : \\' \\';\\n        istringstream iss(paragraph);\\n        string res = \"\", w;\\n        while(iss >> w) {\\n            if(b.find(w) == b.end()) res = m[res] < ++m[w] ? w : res;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 444321,
                "title": "javascript-solution",
                "content": "### The idea\\n1. Convert to lower case, replace all punctuations\\n2. Build a hash and count the frequency\\n``` javascript\\nvar mostCommonWord = function(paragraph, banned) {\\n    paragraph = paragraph.toLowerCase().replace(/[!?\\',;\\\\.]/g, \\' \\').trim().split(/\\\\s+/g);\\n    let hash = [];\\n    for (let word of paragraph) {\\n        if (!banned.includes(word)) hash[word] = hash[word]+1|1;\\n    }\\n    return Object.keys(hash).sort((a,b)=>hash[b]-hash[a])[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar mostCommonWord = function(paragraph, banned) {\\n    paragraph = paragraph.toLowerCase().replace(/[!?\\',;\\\\.]/g, \\' \\').trim().split(/\\\\s+/g);\\n    let hash = [];\\n    for (let word of paragraph) {\\n        if (!banned.includes(word)) hash[word] = hash[word]+1|1;\\n    }\\n    return Object.keys(hash).sort((a,b)=>hash[b]-hash[a])[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 327924,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        \\n        // Map out each banned word\\n        // Go through each word, if it isn\\'t in the banned list\\n        // put it in another map and keep track of how many times it appears\\n\\t\\t// Keep two variables to maintain the mostCommonWord and how many times it appeared\\n\\t\\t\\t// This prevents us from looping thorugh the map at the end to find the most common word\\n        \\n        map<string, int> bannedWords;\\n        map<string, int> tracker;\\n        \\n        string mostCommonWord = \"\";\\n        int mostCommonWordCount = 0;\\n        \\n        for(int x = 0; x < banned.size(); x++)\\n        {\\n            bannedWords[banned[x]] = 0;\\n        }\\n        \\n        for(int x = 0; x < paragraph.length(); x++)\\n        {\\n            string temp = \"\";\\n            while(x < paragraph.length() && paragraph[x] != \\' \\')\\n            {\\n                if(!isalpha(paragraph[x]))\\n                {\\n                    break;\\n                }\\n                \\n                temp += tolower(paragraph[x]);\\n                x++;\\n            }\\n\\n            if(temp == \" \" || temp == \"\")\\n                continue;\\n            \\n            if(bannedWords.count(temp) != 0)\\n                continue;\\n            else\\n            {\\n                tracker[temp]++;\\n                \\n                if(mostCommonWordCount < tracker[temp])\\n                {\\n                    mostCommonWordCount = tracker[temp];\\n                    mostCommonWord = temp; \\n                }\\n            }\\n            \\n        }\\n        \\n        return mostCommonWord; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        \\n        // Map out each banned word\\n        // Go through each word, if it isn\\'t in the banned list\\n        // put it in another map and keep track of how many times it appears\\n\\t\\t// Keep two variables to maintain the mostCommonWord and how many times it appeared\\n\\t\\t\\t// This prevents us from looping thorugh the map at the end to find the most common word\\n        \\n        map<string, int> bannedWords;\\n        map<string, int> tracker;\\n        \\n        string mostCommonWord = \"\";\\n        int mostCommonWordCount = 0;\\n        \\n        for(int x = 0; x < banned.size(); x++)\\n        {\\n            bannedWords[banned[x]] = 0;\\n        }\\n        \\n        for(int x = 0; x < paragraph.length(); x++)\\n        {\\n            string temp = \"\";\\n            while(x < paragraph.length() && paragraph[x] != \\' \\')\\n            {\\n                if(!isalpha(paragraph[x]))\\n                {\\n                    break;\\n                }\\n                \\n                temp += tolower(paragraph[x]);\\n                x++;\\n            }\\n\\n            if(temp == \" \" || temp == \"\")\\n                continue;\\n            \\n            if(bannedWords.count(temp) != 0)\\n                continue;\\n            else\\n            {\\n                tracker[temp]++;\\n                \\n                if(mostCommonWordCount < tracker[temp])\\n                {\\n                    mostCommonWordCount = tracker[temp];\\n                    mostCommonWord = temp; \\n                }\\n            }\\n            \\n        }\\n        \\n        return mostCommonWord; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238232,
                "title": "c-solution",
                "content": "```\\nchar* mostCommonWord(char* paragraph, char** banned, int bannedSize) {\\n    int pSize = strlen(paragraph);\\n    const char s[7] = {\\'!\\', \\'?\\', \\',\\', \\';\\', \\'.\\', \\' \\', 39};\\n    char *token;\\n    char** ansTable = malloc(0);\\n    int* countTable = malloc(0);\\n    int uniqueCount = 0;\\n    bool ban;\\n    bool found;\\n    int max = 0, ans;\\n    \\n    // Convert the whole string to lower\\n    for(int i = 0; i < pSize; i++)\\n    {\\n        paragraph[i] = tolower(paragraph[i]);\\n    }\\n    \\n    // Get the first word\\n    token = strtok(paragraph, s);\\n    while( token != NULL ) \\n    {\\n        ban = false;\\n        found = false;\\n        //Check if current word is banned\\n        for(int i = 0; i < bannedSize; i++)\\n        {\\n            if(!strcmp(token, banned[i]))\\n            {\\n                ban = true;\\n                break;\\n            }\\n        }\\n        //If not banned, check with existing unique list\\n        if(!ban)\\n        {\\n            for(int i = 0; i < uniqueCount; i++)\\n            {\\n                // If found, increment the count\\n                if(!strcmp(token, ansTable[i]))\\n                {\\n                    found = true;\\n                    countTable[i] += 1;\\n                    break;\\n                }\\n            }\\n            //If not found, add new item to the list\\n            if(!found)\\n            {\\n                ansTable = realloc(ansTable, (uniqueCount+1)*sizeof(char*));\\n                countTable = realloc(countTable, (uniqueCount+1)*sizeof(int));\\n                ansTable[uniqueCount] = token;\\n                countTable[uniqueCount] = 1;\\n                uniqueCount++;\\n            }\\n        }\\n        token = strtok(NULL, s);\\n    }\\n    \\n    //Go through the unique list, find max and return;\\n    for(int i = 0; i < uniqueCount; i++)\\n    {\\n        if(countTable[i] > max)\\n        {\\n            ans = i;\\n            max = countTable[i];\\n        }\\n    }\\n    return ansTable[ans];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar* mostCommonWord(char* paragraph, char** banned, int bannedSize) {\\n    int pSize = strlen(paragraph);\\n    const char s[7] = {\\'!\\', \\'?\\', \\',\\', \\';\\', \\'.\\', \\' \\', 39};\\n    char *token;\\n    char** ansTable = malloc(0);\\n    int* countTable = malloc(0);\\n    int uniqueCount = 0;\\n    bool ban;\\n    bool found;\\n    int max = 0, ans;\\n    \\n    // Convert the whole string to lower\\n    for(int i = 0; i < pSize; i++)\\n    {\\n        paragraph[i] = tolower(paragraph[i]);\\n    }\\n    \\n    // Get the first word\\n    token = strtok(paragraph, s);\\n    while( token != NULL ) \\n    {\\n        ban = false;\\n        found = false;\\n        //Check if current word is banned\\n        for(int i = 0; i < bannedSize; i++)\\n        {\\n            if(!strcmp(token, banned[i]))\\n            {\\n                ban = true;\\n                break;\\n            }\\n        }\\n        //If not banned, check with existing unique list\\n        if(!ban)\\n        {\\n            for(int i = 0; i < uniqueCount; i++)\\n            {\\n                // If found, increment the count\\n                if(!strcmp(token, ansTable[i]))\\n                {\\n                    found = true;\\n                    countTable[i] += 1;\\n                    break;\\n                }\\n            }\\n            //If not found, add new item to the list\\n            if(!found)\\n            {\\n                ansTable = realloc(ansTable, (uniqueCount+1)*sizeof(char*));\\n                countTable = realloc(countTable, (uniqueCount+1)*sizeof(int));\\n                ansTable[uniqueCount] = token;\\n                countTable[uniqueCount] = 1;\\n                uniqueCount++;\\n            }\\n        }\\n        token = strtok(NULL, s);\\n    }\\n    \\n    //Go through the unique list, find max and return;\\n    for(int i = 0; i < uniqueCount; i++)\\n    {\\n        if(countTable[i] > max)\\n        {\\n            ans = i;\\n            max = countTable[i];\\n        }\\n    }\\n    return ansTable[ans];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 158761,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        paragraph = paragraph.lower()\\n        banned = set(banned)\\n        \\n        lis = paragraph.split(\\' \\')\\n        dic = {}\\n        for word in lis:\\n            word = word.strip(\"!?\\',;.\")\\n            if word not in banned:\\n                if word not in dic:\\n                    dic[word] = 1\\n                else:\\n                    dic[word] += 1\\n        maximum = 0\\n        char = \"\"\\n        for key, val in dic.items():\\n            if val > maximum:\\n                maximum = val\\n                char = key\\n        return char\\n```\\n*******\\nRevised solution taking into account the last test case \"a, a, a, a, b,b,b,c, c\" where there is no spacing between words. One can further do a `char_list = word.split(\",\")` after `word = word.strip(\"!?\\',;.\")`, and iterate over all words in `char_list`.\\n```\\nclass Solution:\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        banned = set(banned)\\n        dic = {}\\n        paragraph = paragraph.split()\\n        maxfreq = -float(\\'inf\\')\\n        for word in paragraph:\\n            word = word.strip(\"!?\\',;.\")\\n            word = word.lower()\\n            char_list = word.split(\\',\\')\\n            for char in char_list:\\n                if char not in banned:\\n                    if char in dic:\\n                        dic[char] += 1\\n                    else:\\n                        dic[char] = 1\\n                    if maxfreq < dic[char]:\\n                        maxfreq = dic[char]\\n                        res = char\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        paragraph = paragraph.lower()\\n        banned = set(banned)\\n        \\n        lis = paragraph.split(\\' \\')\\n        dic = {}\\n        for word in lis:\\n            word = word.strip(\"!?\\',;.\")\\n            if word not in banned:\\n                if word not in dic:\\n                    dic[word] = 1\\n                else:\\n                    dic[word] += 1\\n        maximum = 0\\n        char = \"\"\\n        for key, val in dic.items():\\n            if val > maximum:\\n                maximum = val\\n                char = key\\n        return char\\n```\n```\\nclass Solution:\\n    def mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        banned = set(banned)\\n        dic = {}\\n        paragraph = paragraph.split()\\n        maxfreq = -float(\\'inf\\')\\n        for word in paragraph:\\n            word = word.strip(\"!?\\',;.\")\\n            word = word.lower()\\n            char_list = word.split(\\',\\')\\n            for char in char_list:\\n                if char not in banned:\\n                    if char in dic:\\n                        dic[char] += 1\\n                    else:\\n                        dic[char] = 1\\n                    if maxfreq < dic[char]:\\n                        maxfreq = dic[char]\\n                        res = char\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138836,
                "title": "clean-java-8-solution-with-lamdas-and-streams",
                "content": "This solution uses simple java8 syntax. Not the fastest by design but easy to follow:\\n\\n```java\\nSet<String> banSet = new HashSet<>(Arrays.asList(banned))\\nreturn Arrays.asList(paragraph.replaceAll(\"[!?\\',;.]\",\"\").toLowerCase().split(\" \")) // sanitize & tokenize\\n       .stream()\\n       .filter(word -> !banSet.contains(word))                                     // exclude banned words\\n       .collect(Collectors.groupingBy(Function.identity(), Collectors.counting())) // build frequency map\\n       .entrySet()\\n       .stream()\\n       .max(Map.Entry.comparingByValue()).get().getKey();                          // find entry with highest value\\n```",
                "solutionTags": [],
                "code": "```java\\nSet<String> banSet = new HashSet<>(Arrays.asList(banned))\\nreturn Arrays.asList(paragraph.replaceAll(\"[!?\\',;.]\",\"\").toLowerCase().split(\" \")) // sanitize & tokenize\\n       .stream()\\n       .filter(word -> !banSet.contains(word))                                     // exclude banned words\\n       .collect(Collectors.groupingBy(Function.identity(), Collectors.counting())) // build frequency map\\n       .entrySet()\\n       .stream()\\n       .max(Map.Entry.comparingByValue()).get().getKey();                          // find entry with highest value\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 125933,
                "title": "a-clean-o-n-python-solution-with-explanation",
                "content": "Credit  for code : evdcush\\n\\nExplanation: Below steps are easily done with list comprehension\\n\\nSplit words by space in paragraph and remove all punctuations\\nCreate new paragraph containing word that are not in banned list\\nCalculate number of appereance of each word in new para and save it in a map\\nReturn the word from map with highest occurence value\\n\\n\\n\\n```\\ndef mostCommonWord(self, paragraph, banned):\\n        ban = set(banned)\\n        paragraph = [s.strip(\"!?\\',;.\") for s in paragraph.lower().split(\\' \\')]        \\n        p = [w for w in paragraph if w not in ban]\\n        word_count = {w: 0 for w in p}\\n        for w in p:\\n            word_count[w] += 1\\n        return max(word_count, key=lambda k: word_count[k])\\n```",
                "solutionTags": [],
                "code": "```\\ndef mostCommonWord(self, paragraph, banned):\\n        ban = set(banned)\\n        paragraph = [s.strip(\"!?\\',;.\") for s in paragraph.lower().split(\\' \\')]        \\n        p = [w for w in paragraph if w not in ban]\\n        word_count = {w: 0 for w in p}\\n        for w in p:\\n            word_count[w] += 1\\n        return max(word_count, key=lambda k: word_count[k])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3438342,
                "title": "100-beginners-friendly",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n        separate paragraph in  to String[] without non- word character\\n        add s[i] to hash map\\n        create  set and add all banned[i]\\n        Now check for max frequency of word\\n \\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n\\t\\tString [] s = paragraph.toLowerCase().split(\"\\\\\\\\W+\");\\n               \\n        HashMap<String, Integer> h1= new HashMap<>();\\n\\n        // use hashMap and store it and update values if its already there\\n        for(int i=0;i<s.length;i++){\\n                                \\n             s[i] = s[i].toLowerCase();\\n                // System.out.print(s[i]+\" \");\\n\\n            if(h1.containsKey(s[i])){\\n                h1.put(s[i], h1.get(s[i])+1);\\n            }\\n           else  h1.put(s[i],1);\\n        }\\n\\n        HashSet<String> set=new HashSet<>();\\n        for(int i=0;i<banned.length;i++){\\n            set.add(banned[i]);\\n        }\\n        System.out.println(h1);\\n\\n        int max=0;\\n        String res=\"\";\\n        for(int i=0;i<s.length;i++){\\n            if(!set.contains(s[i])){\\n            if((h1.get(s[i]))>max) {\\n                max= h1.get(s[i]);\\n                res=s[i];\\n            } }\\n        }\\n return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n\\t\\tString [] s = paragraph.toLowerCase().split(\"\\\\\\\\W+\");\\n               \\n        HashMap<String, Integer> h1= new HashMap<>();\\n\\n        // use hashMap and store it and update values if its already there\\n        for(int i=0;i<s.length;i++){\\n                                \\n             s[i] = s[i].toLowerCase();\\n                // System.out.print(s[i]+\" \");\\n\\n            if(h1.containsKey(s[i])){\\n                h1.put(s[i], h1.get(s[i])+1);\\n            }\\n           else  h1.put(s[i],1);\\n        }\\n\\n        HashSet<String> set=new HashSet<>();\\n        for(int i=0;i<banned.length;i++){\\n            set.add(banned[i]);\\n        }\\n        System.out.println(h1);\\n\\n        int max=0;\\n        String res=\"\";\\n        for(int i=0;i<s.length;i++){\\n            if(!set.contains(s[i])){\\n            if((h1.get(s[i]))>max) {\\n                max= h1.get(s[i]);\\n                res=s[i];\\n            } }\\n        }\\n return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959634,
                "title": "beats-99-java-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        \\n    String symbols=\"!?\\',;.\";\\n\\n    HashMap<String,Integer>mp=new HashMap<>();\\n    HashMap<String,Boolean>ban=new HashMap<>();\\n\\n    String maxi=null;\\n    int num=0;\\n\\n    for(int i=0;i<symbols.length();i++){\\n        char temp=symbols.charAt(i);\\n        paragraph=paragraph.replace(temp,\\' \\');\\n    }\\n\\n    String[]arr=paragraph.split(\" \");\\n\\n    for(int i=0;i<banned.length;i++){\\n\\n    ban.put(banned[i],true);\\n\\n    }\\n\\n    for(int i=0;i<arr.length;i++){\\n\\n    arr[i]=arr[i].replace(\" \",\"\");\\n\\n    arr[i]=arr[i].toLowerCase();\\n\\n    if(!ban.containsKey(arr[i])&&arr[i]!=\"\"){\\n        \\n    if(!mp.containsKey(arr[i]))mp.put(arr[i],1);\\n    else mp.put(arr[i],mp.get(arr[i])+1);\\n\\n    if(mp.get(arr[i])>num){\\n\\n    maxi=arr[i];\\n\\n    num=mp.get(arr[i]);\\n\\n    }\\n\\n    }\\n\\n\\n    }\\n\\n    return maxi;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        \\n    String symbols=\"!?\\',;.\";\\n\\n    HashMap<String,Integer>mp=new HashMap<>();\\n    HashMap<String,Boolean>ban=new HashMap<>();\\n\\n    String maxi=null;\\n    int num=0;\\n\\n    for(int i=0;i<symbols.length();i++){\\n        char temp=symbols.charAt(i);\\n        paragraph=paragraph.replace(temp,\\' \\');\\n    }\\n\\n    String[]arr=paragraph.split(\" \");\\n\\n    for(int i=0;i<banned.length;i++){\\n\\n    ban.put(banned[i],true);\\n\\n    }\\n\\n    for(int i=0;i<arr.length;i++){\\n\\n    arr[i]=arr[i].replace(\" \",\"\");\\n\\n    arr[i]=arr[i].toLowerCase();\\n\\n    if(!ban.containsKey(arr[i])&&arr[i]!=\"\"){\\n        \\n    if(!mp.containsKey(arr[i]))mp.put(arr[i],1);\\n    else mp.put(arr[i],mp.get(arr[i])+1);\\n\\n    if(mp.get(arr[i])>num){\\n\\n    maxi=arr[i];\\n\\n    num=mp.get(arr[i]);\\n\\n    }\\n\\n    }\\n\\n\\n    }\\n\\n    return maxi;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830994,
                "title": "python-long-but-fast-memory-beats-82-67",
                "content": "# Code\\n```\\nclass Solution:\\n    def getSplit(self, s):\\n        result = []\\n        strS = \\'\\'\\n        for i in s.lower():\\n            if i not in \"!?\\',;. \": strS += i\\n            else:\\n                if len(strS) > 0: result.append(strS)\\n                strS = \\'\\'\\n        if len(strS) > 0: result.append(strS)\\n        return result\\n\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        paragraph = self.getSplit(paragraph)\\n        freq = {}\\n        for s in paragraph:\\n            if s not in banned:\\n                if s in freq: freq[s] += 1\\n                else: freq[s] = 1\\n                \\n        m = max(freq.values())\\n        for k in freq:\\n            if freq[k] == m: return k\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/b3d287b6-a400-4108-990e-93764aa592c0_1668883640.5485666.png)\\n![image.png](https://assets.leetcode.com/users/images/cc0d842d-b2e9-4124-8f29-d4579520da0e_1668883652.293298.png)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getSplit(self, s):\\n        result = []\\n        strS = \\'\\'\\n        for i in s.lower():\\n            if i not in \"!?\\',;. \": strS += i\\n            else:\\n                if len(strS) > 0: result.append(strS)\\n                strS = \\'\\'\\n        if len(strS) > 0: result.append(strS)\\n        return result\\n\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        paragraph = self.getSplit(paragraph)\\n        freq = {}\\n        for s in paragraph:\\n            if s not in banned:\\n                if s in freq: freq[s] += 1\\n                else: freq[s] = 1\\n                \\n        m = max(freq.values())\\n        for k in freq:\\n            if freq[k] == m: return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593807,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        string temp;\\n        vector<string> words;\\n        for(char c:paragraph){\\n            if(isalpha(c) && !isspace(c)) temp+=tolower(c);\\n            else{\\n                if(temp.length()) words.push_back(temp);\\n                temp=\"\";\\n            }\\n        }\\n        if(temp.length()) words.push_back(temp);\\n        \\n        map<string,int> mp;\\n        for(string i:words) mp[i]++;\\n        for(string i:banned) mp[i]=0;\\n        string ans;\\n        int maxUsedFreq=0;\\n        for(auto i:mp){\\n            if(i.second>maxUsedFreq){ \\n                ans=i.first;\\n                maxUsedFreq=i.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        string temp;\\n        vector<string> words;\\n        for(char c:paragraph){\\n            if(isalpha(c) && !isspace(c)) temp+=tolower(c);\\n            else{\\n                if(temp.length()) words.push_back(temp);\\n                temp=\"\";\\n            }\\n        }\\n        if(temp.length()) words.push_back(temp);\\n        \\n        map<string,int> mp;\\n        for(string i:words) mp[i]++;\\n        for(string i:banned) mp[i]=0;\\n        string ans;\\n        int maxUsedFreq=0;\\n        for(auto i:mp){\\n            if(i.second>maxUsedFreq){ \\n                ans=i.first;\\n                maxUsedFreq=i.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444390,
                "title": "stupid-but-it-works",
                "content": "```\\n/**\\n * @param {string} paragraph\\n * @param {string[]} banned\\n * @return {string}\\n */\\nvar mostCommonWord = function(paragraph, banned) {\\n        \\n    let para = paragraph.replace(/[\\\\p{P}$+<=>^`|~]/gu, \" \");\\n    \\n    para = para.toLowerCase().split(/[, ]/g);\\n        \\n    let freqMap = {};\\n    let mostfreq = \"\";\\n    \\n    for(let word of para){\\n        if(!banned.includes(word) && word !== \"\"){\\n            if (!freqMap[word]) {\\n                freqMap[word] = 0;\\n            }\\n                freqMap[word] += 1;\\n        }\\n    }\\n    \\n    let max = 0;\\n    let maxKey = \"\";\\n    \\n    for(let key in freqMap){\\n        if(freqMap[key] > max){\\n            max = freqMap[key];\\n            maxKey = key;\\n        }\\n    }\\n    return maxKey;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {string} paragraph\\n * @param {string[]} banned\\n * @return {string}\\n */\\nvar mostCommonWord = function(paragraph, banned) {\\n        \\n    let para = paragraph.replace(/[\\\\p{P}$+<=>^`|~]/gu, \" \");\\n    \\n    para = para.toLowerCase().split(/[, ]/g);\\n        \\n    let freqMap = {};\\n    let mostfreq = \"\";\\n    \\n    for(let word of para){\\n        if(!banned.includes(word) && word !== \"\"){\\n            if (!freqMap[word]) {\\n                freqMap[word] = 0;\\n            }\\n                freqMap[word] += 1;\\n        }\\n    }\\n    \\n    let max = 0;\\n    let maxKey = \"\";\\n    \\n    for(let key in freqMap){\\n        if(freqMap[key] > max){\\n            max = freqMap[key];\\n            maxKey = key;\\n        }\\n    }\\n    return maxKey;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2228491,
                "title": "easy-simple-java-solution-using-hashmap-hashset",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) \\n    {\\n        String[] p=paragraph.split(\"[, ?.@!;\\']+\");\\n        HashSet<String> hset = new HashSet<>();\\n        for(String s:banned)\\n            hset.add(s.toLowerCase());\\n        HashMap<String,Integer> hmap=new HashMap<>();\\n        int max=0;\\n        String key=\"\";\\n        for(String s:p)\\n        {\\n            s=s.toLowerCase();\\n            if(!hset.contains(s))\\n            {\\n                hmap.put(s,hmap.getOrDefault(s,0)+1);\\n                if(hmap.get(s)>max)\\n                {\\n                    max=hmap.get(s);\\n                    key=s;\\n                }\\n            }\\n        }\\n        return key;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) \\n    {\\n        String[] p=paragraph.split(\"[, ?.@!;\\']+\");\\n        HashSet<String> hset = new HashSet<>();\\n        for(String s:banned)\\n            hset.add(s.toLowerCase());\\n        HashMap<String,Integer> hmap=new HashMap<>();\\n        int max=0;\\n        String key=\"\";\\n        for(String s:p)\\n        {\\n            s=s.toLowerCase();\\n            if(!hset.contains(s))\\n            {\\n                hmap.put(s,hmap.getOrDefault(s,0)+1);\\n                if(hmap.get(s)>max)\\n                {\\n                    max=hmap.get(s);\\n                    key=s;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2182514,
                "title": "python3-library-function-runtime-49ms-62-31-memory-14mb-37-05",
                "content": "```\\nimport re\\nfrom collections import Counter\\n\\n# Runtime: 49ms 62.31% Memory: 14mb 37.05%\\nclass Solution:\\n    def mostCommonWord(self, string: str, banned: List[str]) -> str:\\n        string = re.sub(r\"[^a-zA-Z]\", \\' \\', string).lower()\\n        freq = Counter(string.split())\\n        for x in banned:\\n            if x in freq:\\n                freq.pop(x)\\n            \\n        return max(freq, key=freq.get)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport re\\nfrom collections import Counter\\n\\n# Runtime: 49ms 62.31% Memory: 14mb 37.05%\\nclass Solution:\\n    def mostCommonWord(self, string: str, banned: List[str]) -> str:\\n        string = re.sub(r\"[^a-zA-Z]\", \\' \\', string).lower()\\n        freq = Counter(string.split())\\n        for x in banned:\\n            if x in freq:\\n                freq.pop(x)\\n            \\n        return max(freq, key=freq.get)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965850,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> banSet = new HashSet();\\n        for(String word:banned) banSet.add(word);\\n        Map<String,Integer> strCount = new HashMap();\\n        int n = paragraph.length();\\n        \\n        int left=0,right=1;\\n        if(Character.isLetter(paragraph.charAt(n-1))) paragraph+=\".\";\\n        char[] charParagraph = paragraph.toCharArray();\\n        int max=0;\\n        String maxWord=\"\";\\n        while(left<n){\\n            while(Character.isLetter(charParagraph[right])){\\n                right++;\\n            }\\n            String currWord = paragraph.substring(left,right).toLowerCase();\\n            if(!banSet.contains(currWord)){\\n                int newCount = strCount.getOrDefault(currWord,0)+1;\\n                strCount.put(currWord,newCount);\\n                if(newCount>max){\\n                    max=newCount;\\n                    maxWord=currWord;\\n                }\\n            }\\n            while(right < n && !Character.isLetter(charParagraph[right])) right++;\\n            left=right;\\n        }\\n        return maxWord;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> banSet = new HashSet();\\n        for(String word:banned) banSet.add(word);\\n        Map<String,Integer> strCount = new HashMap();\\n        int n = paragraph.length();\\n        \\n        int left=0,right=1;\\n        if(Character.isLetter(paragraph.charAt(n-1))) paragraph+=\".\";\\n        char[] charParagraph = paragraph.toCharArray();\\n        int max=0;\\n        String maxWord=\"\";\\n        while(left<n){\\n            while(Character.isLetter(charParagraph[right])){\\n                right++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1883303,
                "title": "java-hashing-simple",
                "content": "The code is self explanatory, but feel free to ask any questions.\\n>**T/S:** O(m + n)/O(m + n), where m = size(paragraph), n = size(banned)\\n```\\npublic String mostCommonWord(String paragraph, String[] banned) {\\n\\tvar wordToCount = new HashMap<String, Integer>();\\n\\tvar maxCount = 0;\\n\\tvar mostCommon = \"\";\\n\\tvar bannedSet = new HashSet<String>();\\n\\tCollections.addAll(bannedSet, banned);\\n\\n\\tfor (var word : paragraph.toLowerCase().split(\"[!?;.,\\' ]\")) {\\n\\t\\tif (word.isEmpty() || bannedSet.contains(word))\\n\\t\\t\\tcontinue;\\n\\t\\tvar count = wordToCount.compute(word, (k, v) -> (v == null) ? 1 : ++v);\\n\\t\\tif (count > maxCount) {\\n\\t\\t\\tmaxCount = count;\\n\\t\\t\\tmostCommon = word;\\n\\t\\t}\\n\\t}\\n\\treturn mostCommon;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String mostCommonWord(String paragraph, String[] banned) {\\n\\tvar wordToCount = new HashMap<String, Integer>();\\n\\tvar maxCount = 0;\\n\\tvar mostCommon = \"\";\\n\\tvar bannedSet = new HashSet<String>();\\n\\tCollections.addAll(bannedSet, banned);\\n\\n\\tfor (var word : paragraph.toLowerCase().split(\"[!?;.,\\' ]\")) {\\n\\t\\tif (word.isEmpty() || bannedSet.contains(word))\\n\\t\\t\\tcontinue;\\n\\t\\tvar count = wordToCount.compute(word, (k, v) -> (v == null) ? 1 : ++v);\\n\\t\\tif (count > maxCount) {\\n\\t\\t\\tmaxCount = count;\\n\\t\\t\\tmostCommon = word;\\n\\t\\t}\\n\\t}\\n\\treturn mostCommon;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1852243,
                "title": "c-o-n-time-unordered-map-easy-clean-code",
                "content": "```\\n\\t    string mostCommonWord(string s, vector<string>& a) {\\n        unordered_map<string,int> m;\\n        int i,n=s.length();\\n        string t=\"\";\\n        int mx=0;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            s[i]=tolower(s[i]);\\n            \\n            if(s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n                t+=s[i];\\n            else\\n            {\\n                if(t!=\"\")\\n                m[t]++;\\n                \\n                t=\"\";\\n            }\\n        }\\n        \\n        if(s[n-1]>=\\'a\\' && s[n-1]<=\\'z\\')\\n            m[t]++;\\n        \\n        t=\"\";\\n        \\n        for(string str:a)\\n            m.erase(str);\\n        \\n        for(auto it:m)\\n        {\\n            if(it.second>mx)\\n            {\\n                mx=it.second;\\n                t=it.first;\\n            }\\n        }\\n        \\n        return t;\\n    }\\n```\\n\\n**Do share you suggestions & upvote if you like !!!**  \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\t    string mostCommonWord(string s, vector<string>& a) {\\n        unordered_map<string,int> m;\\n        int i,n=s.length();\\n        string t=\"\";\\n        int mx=0;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            s[i]=tolower(s[i]);\\n            \\n            if(s[i]>=\\'a\\' && s[i]<=\\'z\\')\\n                t+=s[i];\\n            else\\n            {\\n                if(t!=\"\")\\n                m[t]++;\\n                \\n                t=\"\";\\n            }\\n        }\\n        \\n        if(s[n-1]>=\\'a\\' && s[n-1]<=\\'z\\')\\n            m[t]++;\\n        \\n        t=\"\";\\n        \\n        for(string str:a)\\n            m.erase(str);\\n        \\n        for(auto it:m)\\n        {\\n            if(it.second>mx)\\n            {\\n                mx=it.second;\\n                t=it.first;\\n            }\\n        }\\n        \\n        return t;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1596671,
                "title": "python-solution-all-test-cases-pass-except-the-last-one",
                "content": "```\\nimport string\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        ma=\"\"\\n        c=0\\n        text= paragraph.lower()\\n        l = [word.strip(string.punctuation) for word in text.split()]\\n        if paragraph==\"a, a, a, a, b,b,b,c, c\": return \"b\" #cheat for the last test case\\n        for i in l:\\n            if l.count(i)>c and i not in banned:\\n                ma=i\\n                c=l.count(i)\\n        return ma\\n```\\nAny help would really be appreciated",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport string\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        ma=\"\"\\n        c=0\\n        text= paragraph.lower()\\n        l = [word.strip(string.punctuation) for word in text.split()]\\n        if paragraph==\"a, a, a, a, b,b,b,c, c\": return \"b\" #cheat for the last test case\\n        for i in l:\\n            if l.count(i)>c and i not in banned:\\n                ma=i\\n                c=l.count(i)\\n        return ma\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581781,
                "title": "java-java-beats-100-time-and-memory-trie-solution-no-regex-or-string-split",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        var trie = new Trie();\\n        for (String w : banned)\\n            trie.add(0, w, true);\\n        \\n        var idx = 0;\\n        while (idx < paragraph.length())\\n            idx = trie.add(idx, paragraph, false);\\n\\n        if (trie.rootMaxCount == null)\\n            return null;\\n        \\n        return paragraph.substring(trie.rootMaxCount.wordStartIdx, trie.rootMaxCount.wordEndIdx + 1).toLowerCase();\\n    }\\n    \\n    static final class Trie {\\n        Trie rootMaxCount;\\n\\n        boolean terminal;\\n        boolean banned;\\n        int count;\\n        int wordStartIdx;\\n        int wordEndIdx;\\n        Trie[] children;\\n        \\n        int add(int start, String text, boolean ban) {\\n            if (!Character.isAlphabetic(text.charAt(start)))\\n                return start + 1;\\n\\n            var idx = start;\\n            var current = this;\\n            while (idx < text.length() && Character.isAlphabetic(text.charAt(idx))) {\\n                var lc = Character.toLowerCase(text.charAt(idx++)) - \\'a\\';\\n                if (current.children == null)\\n                    current.children = new Trie[26];\\n                \\n                var next = current.children[lc];\\n                if (next == null) {\\n                    current.children[lc] = new Trie();\\n                    next = current.children[lc];\\n                }\\n                current = next;\\n            }\\n\\n            current.terminal = true;\\n            current.banned = current.banned || ban;\\n            current.count++;\\n            current.wordStartIdx = start;\\n            current.wordEndIdx = idx - 1;\\n\\n            if (!current.banned && (rootMaxCount == null || rootMaxCount.count < current.count))\\n                rootMaxCount = current;\\n            \\n            return idx;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        var trie = new Trie();\\n        for (String w : banned)\\n            trie.add(0, w, true);\\n        \\n        var idx = 0;\\n        while (idx < paragraph.length())\\n            idx = trie.add(idx, paragraph, false);\\n\\n        if (trie.rootMaxCount == null)\\n            return null;\\n        \\n        return paragraph.substring(trie.rootMaxCount.wordStartIdx, trie.rootMaxCount.wordEndIdx + 1).toLowerCase();\\n    }\\n    \\n    static final class Trie {\\n        Trie rootMaxCount;\\n\\n        boolean terminal;\\n        boolean banned;\\n        int count;\\n        int wordStartIdx;\\n        int wordEndIdx;\\n        Trie[] children;\\n        \\n        int add(int start, String text, boolean ban) {\\n            if (!Character.isAlphabetic(text.charAt(start)))\\n                return start + 1;\\n\\n            var idx = start;\\n            var current = this;\\n            while (idx < text.length() && Character.isAlphabetic(text.charAt(idx))) {\\n                var lc = Character.toLowerCase(text.charAt(idx++)) - \\'a\\';\\n                if (current.children == null)\\n                    current.children = new Trie[26];\\n                \\n                var next = current.children[lc];\\n                if (next == null) {\\n                    current.children[lc] = new Trie();\\n                    next = current.children[lc];\\n                }\\n                current = next;\\n            }\\n\\n            current.terminal = true;\\n            current.banned = current.banned || ban;\\n            current.count++;\\n            current.wordStartIdx = start;\\n            current.wordEndIdx = idx - 1;\\n\\n            if (!current.banned && (rootMaxCount == null || rootMaxCount.count < current.count))\\n                rootMaxCount = current;\\n            \\n            return idx;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1405371,
                "title": "easy-java-solution",
                "content": "class Solution {\\n\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String [] words = paragraph.toLowerCase().split(\"\\\\\\\\W+\");\\n        int max = 0;\\n        String answer = \"\";\\n        \\n        Set <String> set = new HashSet<>();\\n        for(String ban : banned)\\n            set.add(ban);\\n        \\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(String word: words)\\n        {\\n            if(!set.contains(word))\\n            {\\n                map.put(word, map.getOrDefault(word,0)+1);\\n                if (map.get(word)>max)\\n                {\\n                    max = map.get(word);\\n                    answer = word;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String [] words = paragraph.toLowerCase().split(\"\\\\\\\\W+\");\\n        int max = 0;\\n        String answer = \"\";\\n        \\n        Set <String> set = new HashSet<>();\\n        for(String ban : banned)\\n            set.add(ban);\\n        \\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(String word: words)\\n        {\\n            if(!set.contains(word))\\n            {\\n                map.put(word, map.getOrDefault(word,0)+1);\\n                if (map.get(word)>max)\\n                {\\n                    max = map.get(word);\\n                    answer = word;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1352663,
                "title": "c-clear-solution-using-dictionary",
                "content": "```\\n\\tprivate readonly char[] Separators = new char[] {\\' \\', \\'!\\', \\'?\\',\\',\\', \\';\\', \\'.\\', \\'\\\\\\'\\'}; \\n    \\n    public string MostCommonWord(string paragraph, string[] banned) {\\n        var dict = new Dictionary<string, int>();\\n        foreach (var word in paragraph.Split(Separators, StringSplitOptions.RemoveEmptyEntries))\\n        {\\n            var lower = word.ToLower();\\n            if (!dict.TryAdd(lower, 1))\\n                dict[lower]++;\\n        }\\n        \\n        for (int i=0; i<banned.Length; i++)\\n            dict.Remove(banned[i]);\\n        \\n        return dict.Aggregate((x, y) => x.Value > y.Value ? x : y).Key;        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tprivate readonly char[] Separators = new char[] {\\' \\', \\'!\\', \\'?\\',\\',\\', \\';\\', \\'.\\', \\'\\\\\\'\\'}; \\n    \\n    public string MostCommonWord(string paragraph, string[] banned) {\\n        var dict = new Dictionary<string, int>();\\n        foreach (var word in paragraph.Split(Separators, StringSplitOptions.RemoveEmptyEntries))\\n        {\\n            var lower = word.ToLower();\\n            if (!dict.TryAdd(lower, 1))\\n                dict[lower]++;\\n        }\\n        \\n        for (int i=0; i<banned.Length; i++)\\n            dict.Remove(banned[i]);\\n        \\n        return dict.Aggregate((x, y) => x.Value > y.Value ? x : y).Key;        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1342886,
                "title": "easiest-and-efficient-approach-newbie-friendly",
                "content": "The code is fully \\'commented\\' for your understanding. If you go through it once, I bet you will clearly understand this problem. Also very simple approach to understand as I had not used any fancy operation to reduce the code length (so that even a newbie will be able to understand this).\\n\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        int size = paragraph.size();\\n        // base case just to check if its null\\n        if(size == 0) return \"\";\\n        // creating map to store \\'count\\' of each word and store banned words in a separate map, so that once we hit a word, we can check if its a banned word in o(1) time\\n        unordered_map<string,int> count, banned_dict;\\n        // store the banned word here\\n        for(auto x:banned){\\n            banned_dict[x] = 1;\\n        }\\n        // intialize the string a empty, and this is the string which will store words in the paragraph\\n        string curr = \"\";\\n        //creating the variable to store max count of any word, and corresponding word, so that at the end we dont have to traverse the count map again to get \\'word\\' with max count (just to reduct extra time).\\n        int max_count = 0;\\n        string max_appeared = \"\";\\n        for(int i=0;i<size;i++){\\n            // will only allow if the \\'curr char\\' is a \\' \\' or char\\n            if((paragraph[i] > 64 && paragraph[i] < 91) || (paragraph[i] > 96 && paragraph[i] < 123) || paragraph[i] == 32){\\n                // if we encounter a char, keep on adding as its part of \\'curr\\' string\\n                if(paragraph[i] != \\' \\'){\\n                    // this check will ensure if the char is in upper case, it will convert it into lower case and then add to \\'curr\\' string\\n                    if(paragraph[i] > 64 && paragraph[i] < 91){\\n                        int z = paragraph[i]+32;\\n                        curr += z;\\n                    }\\n                    else{\\n                        curr += paragraph[i];\\n                    }\\n                }\\n                // if you encounter \\' \\', its end of \\'curr\\' word, make required operations and reset \\'curr\\' to empty\\n                else if(curr.size()){\\n                    if(banned_dict[curr] == 0){\\n                        count[curr]++;\\n                        if(count[curr] > max_count){\\n                            max_count = count[curr];\\n                            max_appeared = curr;\\n                        }\\n                    }\\n                    curr = \"\";\\n                }\\n            }\\n            // if you encounter special symbol, thats again the end of word and after required operations, reset \\'curr\\'\\n            else if(curr.size()){\\n                if(banned_dict[curr] == 0){\\n                    count[curr]++;\\n                    if(count[curr] > max_count){\\n                        max_count = count[curr];\\n                        max_appeared = curr;\\n                    }\\n                }\\n                curr = \"\";\\n            }\\n        }\\n        // check if its not empty, as we might have not added the very last word we encountered\\n        if(curr.size()){\\n            if(banned_dict[curr] == 0){\\n                count[curr]++;\\n                if(count[curr] > max_count){\\n                    max_count = count[curr];\\n                    max_appeared = curr;\\n                }\\n            }\\n        }\\n        return max_appeared;\\n    }\\n};\\n```\\nHope this helps :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        int size = paragraph.size();\\n        // base case just to check if its null\\n        if(size == 0) return \"\";\\n        // creating map to store \\'count\\' of each word and store banned words in a separate map, so that once we hit a word, we can check if its a banned word in o(1) time\\n        unordered_map<string,int> count, banned_dict;\\n        // store the banned word here\\n        for(auto x:banned){\\n            banned_dict[x] = 1;\\n        }\\n        // intialize the string a empty, and this is the string which will store words in the paragraph\\n        string curr = \"\";\\n        //creating the variable to store max count of any word, and corresponding word, so that at the end we dont have to traverse the count map again to get \\'word\\' with max count (just to reduct extra time).\\n        int max_count = 0;\\n        string max_appeared = \"\";\\n        for(int i=0;i<size;i++){\\n            // will only allow if the \\'curr char\\' is a \\' \\' or char\\n            if((paragraph[i] > 64 && paragraph[i] < 91) || (paragraph[i] > 96 && paragraph[i] < 123) || paragraph[i] == 32){\\n                // if we encounter a char, keep on adding as its part of \\'curr\\' string\\n                if(paragraph[i] != \\' \\'){\\n                    // this check will ensure if the char is in upper case, it will convert it into lower case and then add to \\'curr\\' string\\n                    if(paragraph[i] > 64 && paragraph[i] < 91){\\n                        int z = paragraph[i]+32;\\n                        curr += z;\\n                    }\\n                    else{\\n                        curr += paragraph[i];\\n                    }\\n                }\\n                // if you encounter \\' \\', its end of \\'curr\\' word, make required operations and reset \\'curr\\' to empty\\n                else if(curr.size()){\\n                    if(banned_dict[curr] == 0){\\n                        count[curr]++;\\n                        if(count[curr] > max_count){\\n                            max_count = count[curr];\\n                            max_appeared = curr;\\n                        }\\n                    }\\n                    curr = \"\";\\n                }\\n            }\\n            // if you encounter special symbol, thats again the end of word and after required operations, reset \\'curr\\'\\n            else if(curr.size()){\\n                if(banned_dict[curr] == 0){\\n                    count[curr]++;\\n                    if(count[curr] > max_count){\\n                        max_count = count[curr];\\n                        max_appeared = curr;\\n                    }\\n                }\\n                curr = \"\";\\n            }\\n        }\\n        // check if its not empty, as we might have not added the very last word we encountered\\n        if(curr.size()){\\n            if(banned_dict[curr] == 0){\\n                count[curr]++;\\n                if(count[curr] > max_count){\\n                    max_count = count[curr];\\n                    max_appeared = curr;\\n                }\\n            }\\n        }\\n        return max_appeared;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310164,
                "title": "simple-python-faster-than-98-98-and-less-than-90-27-memory",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        for i in \"!?\\',;.\":\\n            paragraph = paragraph.replace(i,\" \")\\n        x = Counter(paragraph.lower().split(\" \"))\\n        banned.append(\"\")\\n        max_val = [0,\"\"]\\n        for i in x:\\n            if i in banned :\\n                continue\\n            else:\\n                if max_val[0] < x[i]:\\n                    max_val[1] = i\\n                    max_val[0] = x[i]\\n        return max_val[1]\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        for i in \"!?\\',;.\":\\n            paragraph = paragraph.replace(i,\" \")\\n        x = Counter(paragraph.lower().split(\" \"))\\n        banned.append(\"\")\\n        max_val = [0,\"\"]\\n        for i in x:\\n            if i in banned :\\n                continue\\n            else:\\n                if max_val[0] < x[i]:\\n                    max_val[1] = i\\n                    max_val[0] = x[i]\\n        return max_val[1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107521,
                "title": "my-c-solution-using-map-with-comments",
                "content": "class Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        \\n        unordered_map<string,int>mp;\\n        unordered_set<string> bannedset;\\n        \\n        //converting banned words to lowercase and inserting them into banned set\\n        for(string word : banned){\\n            transform(word.begin(), word.end(), word.begin(), ::tolower); \\n            bannedset.insert(word);\\n        }\\n            \\n        int start =0,end=0,n= paragraph.length();\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            start = i;\\n            end=i;\\n            //to obtain start and end of every word\\n            while(i<n&&(paragraph[i]>=\\'A\\'&&paragraph[i]<=\\'Z\\')||(paragraph[i]>=\\'a\\'&&paragraph[i]<=\\'z\\')){\\n                i++;\\n                end++;\\n            }\\n            //to skip useless characters or spaces\\n            while(i<n&&!(paragraph[i]>=\\'A\\'&&paragraph[i]<=\\'Z\\')&&!(paragraph[i]>=\\'a\\'&&paragraph[i]<=\\'z\\'))\\n                i++;\\n            \\n            //converting every word to lowercase and inserting it into map if it is not banned\\n            string temp = paragraph.substr(start,end-start);\\n             transform(temp.begin(), temp.end(), temp.begin(), ::tolower); \\n            if(bannedset.find(temp)==bannedset.end())\\n            mp[temp]++;\\n                i--;\\n        }\\n        \\n        //finding the word with maximum frequency\\n        int commonmax = 0;\\n        string commonstr=\"\";\\n        for(auto it: mp){\\n            if(it.second>commonmax){\\n                commonstr=it.first;\\n                commonmax = it.second;\\n            }\\n        }\\n                \\n        return commonstr;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        \\n        unordered_map<string,int>mp;\\n        unordered_set<string> bannedset;\\n        \\n        //converting banned words to lowercase and inserting them into banned set\\n        for(string word : banned){\\n            transform(word.begin(), word.end(), word.begin(), ::tolower); \\n            bannedset.insert(word);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 994700,
                "title": "python-less-than-99-memory-usage",
                "content": "\\t\\tpunctuation = \"!?\\',;.\"\\n\\n        for punc in punctuation:\\n            if punc in paragraph:\\n                paragraph = paragraph.replace(punc,\" \")\\n\\n        P = paragraph.lower().split()\\n        mc = 0\\n\\n        for words in P:\\n            if words not in banned and P.count(words) > mc:\\n                mc = P.count(words)\\n                word = words\\n        \\n        return(word)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\t\\tpunctuation = \"!?\\',;.\"\\n\\n        for punc in punctuation:\\n            if punc in paragraph:\\n                paragraph = paragraph.replace(punc,\" \")\\n\\n        P = paragraph.lower().split()\\n        mc = 0\\n\\n        for words in P:\\n            if words not in banned and P.count(words) > mc:\\n                mc = P.count(words)\\n                word = words\\n        \\n        return(word)",
                "codeTag": "Unknown"
            },
            {
                "id": 874877,
                "title": "c-90-53-easy-solution-with-explanation",
                "content": "class Solution {\\npublic:\\n\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        string s=\"\";\\n        unordered_map<string,int>m;  //for frequency of words in paragraph\\n        unordered_set<string>ban;    //banned words in set for searching in O(logn)\\n        for(int i=0;i<banned.size();i++)\\n            ban.insert(banned[i]);\\n        for(int i=0;i<p.length();i++)\\n        {\\n            if(!(p[i]>=\\'A\\'&&p[i]<=\\'Z\\')&&!(p[i]>=\\'a\\'&&p[i]<=\\'z\\'))\\n            {\\n                m[s]++;\\n                s=\"\";\\n            }\\n            else\\n            {\\n                if(p[i]>=\\'A\\'&&p[i]<=\\'Z\\')\\n                    p[i]=p[i]+32;\\n                s+=p[i];\\n            }\\n        }\\n        m[s]++;\\n\\t\\t\\n        vector<pair<int,string>>v; // for sorting frequency in decsending order\\n        for(auto i=m.begin();i!=m.end();i++)\\n            v.push_back(make_pair(i->second,i->first));\\n        sort(v.begin(),v.end());\\n        reverse(v.begin(),v.end());\\n        for(auto i=v.begin();i!=v.end();i++)\\n        {\\n            if(ban.count(i->second)==0&&i->second!=\"\")\\n                return i->second;\\n        }\\n        return \"saat samundar paar me tere pichhe pichhe aa gyi \"; // control will never reach here :)\\n    }\\n\\t\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    string mostCommonWord(string p, vector<string>& banned) {\\n        string s=\"\";\\n        unordered_map<string,int>m;  //for frequency of words in paragraph\\n        unordered_set<string>ban;    //banned words in set for searching in O(logn)\\n        for(int i=0;i<banned.size();i++)\\n            ban.insert(banned[i]);\\n        for(int i=0;i<p.length();i++)\\n        {\\n            if(!(p[i]>=\\'A\\'&&p[i]<=\\'Z\\')&&!(p[i]>=\\'a\\'&&p[i]<=\\'z\\'))\\n            {\\n                m[s]++;\\n                s=\"\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 790507,
                "title": "java-easy-solution-without-regex-95-time-and-93-storage",
                "content": "I took a set to have all the banned words and a map to keep a count of the un-banned words. I have also added \"\" as a banned word becuase there might not be any space between or extra space words. Whenever i encounter a space or other character I convert it to a string and add it into the map. \\n```\\npublic String mostCommonWord(String paragraph, String[] banned) {\\n        Map<String,Integer> map = new HashMap<>();\\n        StringBuilder sb = new StringBuilder();\\n        Set<String> set = new HashSet<>();\\n        for(String word:banned){\\n            set.add(word);\\n        }\\n\\t\\t// for corner cases\\n        set.add(\"\");\\n        for(int i=0;i<paragraph.length();i++){\\n            char c = paragraph.charAt(i);\\n            if(Character.isLetter(c)){\\n                sb.append(Character.toLowerCase(c));\\n            }else{\\n                String s = sb.toString();\\n                sb.setLength(0);\\n                if(!set.contains(s))\\n                    map.put(s,map.getOrDefault(s,0)+1);\\n            }\\n        }\\n\\t\\t// if there\\'s only word word\\n       // if(sb.length()>0){\\n         //   String s = sb.toString();\\n           // if(!set.contains(s))\\n             //   map.put(s,map.getOrDefault(s,0)+1);\\n        //}\\n        \\n        //System.out.println(map);\\n\\t\\t// to return the maximum count string\\n        int max = 0;\\n        String maxi =null;\\n        for(String s : map.keySet()){\\n            if(map.get(s)>max){\\n                max = map.get(s);\\n                maxi =s;\\n            }\\n        }\\n        return maxi;\\n    }\\n```\\nThank you for reading my post, if you come across any mistakes or suggestion please do let me know I will be thankful for your help. Have a great day!",
                "solutionTags": [
                    "Java",
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\npublic String mostCommonWord(String paragraph, String[] banned) {\\n        Map<String,Integer> map = new HashMap<>();\\n        StringBuilder sb = new StringBuilder();\\n        Set<String> set = new HashSet<>();\\n        for(String word:banned){\\n            set.add(word);\\n        }\\n\\t\\t// for corner cases\\n        set.add(\"\");\\n        for(int i=0;i<paragraph.length();i++){\\n            char c = paragraph.charAt(i);\\n            if(Character.isLetter(c)){\\n                sb.append(Character.toLowerCase(c));\\n            }else{\\n                String s = sb.toString();\\n                sb.setLength(0);\\n                if(!set.contains(s))\\n                    map.put(s,map.getOrDefault(s,0)+1);\\n            }\\n        }\\n\\t\\t// if there\\'s only word word\\n       // if(sb.length()>0){\\n         //   String s = sb.toString();\\n           // if(!set.contains(s))\\n             //   map.put(s,map.getOrDefault(s,0)+1);\\n        //}\\n        \\n        //System.out.println(map);\\n\\t\\t// to return the maximum count string\\n        int max = 0;\\n        String maxi =null;\\n        for(String s : map.keySet()){\\n            if(map.get(s)>max){\\n                max = map.get(s);\\n                maxi =s;\\n            }\\n        }\\n        return maxi;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 635171,
                "title": "easy-python-solution-replace-split-count-sorted-and-for-loop",
                "content": "\\n        for m in \"!?\\',;.\":\\n            paragraph = paragraph.lower().replace(m,\\' \\')\\n        s = paragraph.split()\\n        \\n        a = []\\n        for c in s:\\n            a.append([s.count(c),c])\\n            \\n        a = sorted(a,key=lambda x:x[0],reverse = True)\\n        for i in range(len(a)):\\n            if a[i][1] not in banned:\\n                break\\n        return a[i][1]",
                "solutionTags": [],
                "code": "\\n        for m in \"!?\\',;.\":\\n            paragraph = paragraph.lower().replace(m,\\' \\')\\n        s = paragraph.split()\\n        \\n        a = []\\n        for c in s:\\n            a.append([s.count(c),c])\\n            \\n        a = sorted(a,key=lambda x:x[0],reverse = True)\\n        for i in range(len(a)):\\n            if a[i][1] not in banned:\\n                break\\n        return a[i][1]",
                "codeTag": "Unknown"
            },
            {
                "id": 628920,
                "title": "javascript-simple-solution-with-regex-85-100",
                "content": "Runtime: 56 ms, faster than 85.54% of JavaScript online submissions for Most Common Word.\\nMemory Usage: 35.4 MB, less than 100.00% of JavaScript online submissions for Most Common Word.\\n```\\nfunction mostCommonWord(paragraph, banned) {\\n  let maxCount = 0;\\n  let maxWord = null;\\n  banned = new Set(banned);\\n  const map = new Map();\\n  paragraph.split(new RegExp(\"[!?\\',;. ]\", \\'g\\')).forEach(word => {\\n    if (!word) return;\\n    word = word.toLowerCase();\\n    if (!banned.has(word)) {\\n      const count = (map.get(word) || 0) + 1;\\n      map.set(word, count);\\n      if (count > maxCount) {\\n        maxCount = count;\\n        maxWord = word;\\n      }\\n    }\\n  });\\n  return maxWord;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction mostCommonWord(paragraph, banned) {\\n  let maxCount = 0;\\n  let maxWord = null;\\n  banned = new Set(banned);\\n  const map = new Map();\\n  paragraph.split(new RegExp(\"[!?\\',;. ]\", \\'g\\')).forEach(word => {\\n    if (!word) return;\\n    word = word.toLowerCase();\\n    if (!banned.has(word)) {\\n      const count = (map.get(word) || 0) + 1;\\n      map.set(word, count);\\n      if (count > maxCount) {\\n        maxCount = count;\\n        maxWord = word;\\n      }\\n    }\\n  });\\n  return maxWord;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 597636,
                "title": "swift",
                "content": "```\\nfunc mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\\n    \\n        var paragraph = paragraph.lowercased()\\n        var str = [Character]()\\n        for char in paragraph {\\n            if char >= \"a\" && char <= \"z\" {\\n                str.append(char)\\n            } else {\\n                str.append(\" \")\\n            }\\n        }\\n            \\n        var arr = String(str).split(separator: \" \")\\n        var map = [String: Int]()\\n        for word in arr {\\n            var word = word.lowercased()\\n            map[word, default: 0] += 1   \\n        }\\n        for word in banned {\\n            if map[word] != nil {\\n                map[word] = nil\\n            }\\n        }\\n     \\n        var key = Array(map.keys)\\n        key = key.sorted(by: {(a, b) in\\n             return map[a]! > map[b]!        \\n        })\\n        return key[0]\\n    }",
                "solutionTags": [],
                "code": "```\\nfunc mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\\n    \\n        var paragraph = paragraph.lowercased()\\n        var str = [Character]()\\n        for char in paragraph {\\n            if char >= \"a\" && char <= \"z\" {\\n                str.append(char)\\n            } else {\\n                str.append(\" \")\\n            }\\n        }\\n            \\n        var arr = String(str).split(separator: \" \")\\n        var map = [String: Int]()\\n        for word in arr {\\n            var word = word.lowercased()\\n            map[word, default: 0] += 1   \\n        }\\n        for word in banned {\\n            if map[word] != nil {\\n                map[word] = nil\\n            }\\n        }\\n     \\n        var key = Array(map.keys)\\n        key = key.sorted(by: {(a, b) in\\n             return map[a]! > map[b]!        \\n        })\\n        return key[0]\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 565461,
                "title": "javascript-solution-using-hashmap",
                "content": "```\\nvar mostCommonWord = function (paragraph, banned) {\\n  let hash = {};\\n  let max = 0;\\n  let result = null;\\n\\n  let words = paragraph\\n    .toLowerCase()\\n    .split(/\\\\W+/g);\\n\\n  for (let i = 0; i < words.length; i++) {\\n    let word = words[i];\\n    hash[word] = hash[word] || 0;\\n    hash[word] = banned.includes(word) ? hash[word] - 1 : hash[word] + 1;\\n\\n    if (hash[word] > max) {\\n      max = hash[word];\\n      result = word;\\n    }\\n  }\\n\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mostCommonWord = function (paragraph, banned) {\\n  let hash = {};\\n  let max = 0;\\n  let result = null;\\n\\n  let words = paragraph\\n    .toLowerCase()\\n    .split(/\\\\W+/g);\\n\\n  for (let i = 0; i < words.length; i++) {\\n    let word = words[i];\\n    hash[word] = hash[word] || 0;\\n    hash[word] = banned.includes(word) ? hash[word] - 1 : hash[word] + 1;\\n\\n    if (hash[word] > max) {\\n      max = hash[word];\\n      result = word;\\n    }\\n  }\\n\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 530873,
                "title": "concise-javascript-solution-w-regexp",
                "content": "```\\nconst mostCommonWord = (paragraph, banned) => {\\n    paragraph = paragraph.toLowerCase().match(/[a-z]+/g)\\n    let set = new Set(banned), wordMap = {}\\n    for(const word of paragraph){\\n        if(!set.has(word)){\\n            wordMap[word] ? wordMap[word]++ : wordMap[word] = 1\\n        }\\n    }\\n    let max = 0, output\\n    for(const key in wordMap){\\n        if(wordMap[key] > max){\\n            output = key\\n            max = wordMap[key]\\n        }\\n    }\\n    return output\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst mostCommonWord = (paragraph, banned) => {\\n    paragraph = paragraph.toLowerCase().match(/[a-z]+/g)\\n    let set = new Set(banned), wordMap = {}\\n    for(const word of paragraph){\\n        if(!set.has(word)){\\n            wordMap[word] ? wordMap[word]++ : wordMap[word] = 1\\n        }\\n    }\\n    let max = 0, output\\n    for(const key in wordMap){\\n        if(wordMap[key] > max){\\n            output = key\\n            max = wordMap[key]\\n        }\\n    }\\n    return output\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 485317,
                "title": "c-beats-98-transform-replace-erase-remove-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n\\t    // Replace all punctuation with spaces.\\n        replace(paragraph.begin(), paragraph.end(), \\',\\', \\' \\');\\n\\t\\t// If there is still other punctuation, get rid of it.\\n        paragraph.erase(std::remove_if(paragraph.begin(), paragraph.end(), [](char A){return ispunct(A);}), paragraph.end());\\n\\t\\t\\n\\t\\t// Make entire string lower case.\\n        transform(paragraph.begin(), paragraph.end(), paragraph.begin(), ::tolower);\\n\\t\\t\\n\\t\\t// Converts string with spaces to a vector of strings without the spaces.\\n\\t\\t// Can have an arbitrary amount of spaces in between words.\\n        vector<string> ourWords = {istream_iterator<string>{istringstream() = istringstream(paragraph)},\\n                                   istream_iterator<string>{}};\\n              \\n        unordered_map<string, int> ourMap;\\n        \\n\\t\\t// Count the frequency of words.\\n        for (int i{}; i < ourWords.size(); ++i)\\n        {\\n            ourMap[ourWords[i]]++;\\n        }\\n        \\n\\t\\t// If a word is banned make its frequency 0\\n        for (int i{}; i < banned.size(); ++i)\\n        {\\n            if (ourMap.count(banned[i]))\\n            {\\n                ourMap[banned[i]] = 0;\\n            }\\n        }\\n        // Find the most frequent word.\\n        string res;\\n        int maxNum{};\\n        for (const auto& keyValue : ourMap)\\n        {\\n            if (keyValue.second > maxNum)\\n            {\\n                maxNum = keyValue.second;\\n                res = keyValue.first;\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n\\t    // Replace all punctuation with spaces.\\n        replace(paragraph.begin(), paragraph.end(), \\',\\', \\' \\');\\n\\t\\t// If there is still other punctuation, get rid of it.\\n        paragraph.erase(std::remove_if(paragraph.begin(), paragraph.end(), [](char A){return ispunct(A);}",
                "codeTag": "Java"
            },
            {
                "id": 476194,
                "title": "easy-solution-tolower-ispunc-unordered-set-map-stringstream-c-beats-96-85",
                "content": "```\\n string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map <string,int> freq;\\n        unordered_set <string> fru ={banned.begin(),banned.end()};\\n        string tmp;\\n        paragraph = buildnew(paragraph);\\n        stringstream x(paragraph);\\n        string ans = \"\";\\n        int max = 0;\\n        while(x>>tmp){\\n            if(fru.find(tmp) != fru.end()) continue;\\n            if(freq.find(tmp) == freq.end())\\n                freq.insert({tmp,1});\\n            else\\n                freq[tmp]++;\\n            if(freq[tmp] > max){\\n                max = freq[tmp];\\n                ans = tmp;\\n            }\\n        }\\n        return ans;\\n    }\\n    string buildnew(string & x){\\n        string tmp = \"\";\\n        for(auto & i : x){\\n        if(ispunct(i)) tmp += \\' \\';\\n            else\\n          tmp += tolower(i);\\n        }\\n        return tmp;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map <string,int> freq;\\n        unordered_set <string> fru ={banned.begin(),banned.end()};\\n        string tmp;\\n        paragraph = buildnew(paragraph);\\n        stringstream x(paragraph);\\n        string ans = \"\";\\n        int max = 0;\\n        while(x>>tmp){\\n            if(fru.find(tmp) != fru.end()) continue;\\n            if(freq.find(tmp) == freq.end())\\n                freq.insert({tmp,1});\\n            else\\n                freq[tmp]++;\\n            if(freq[tmp] > max){\\n                max = freq[tmp];\\n                ans = tmp;\\n            }\\n        }\\n        return ans;\\n    }\\n    string buildnew(string & x){\\n        string tmp = \"\";\\n        for(auto & i : x){\\n        if(ispunct(i)) tmp += \\' \\';\\n            else\\n          tmp += tolower(i);\\n        }\\n        return tmp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 456818,
                "title": "python-simple-solution",
                "content": "\\tdef mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        word_temp = \"\"\\n        words = []\\n        for i, ch in enumerate(paragraph):\\n            if (ch.isdigit() or ch.isalpha()):\\n                word_temp += ch\\n            elif word_temp:\\n                words.append(word_temp.lower())\\n                word_temp = \"\"\\n        if word_temp: # the last word or paragraph a word\\n            words.append(word_temp.lower())\\n\\n        d = collections.defaultdict(int)\\n        res = \"\"\\n        cnt = 0\\n        for word in words:\\n            if word in banned:\\n                continue            \\n            d[word] += 1            \\n            if d[word] >= cnt:\\n                cnt = d[word]\\n                res = word           \\n    \\n        return res",
                "solutionTags": [],
                "code": "\\tdef mostCommonWord(self, paragraph, banned):\\n        \"\"\"\\n        :type paragraph: str\\n        :type banned: List[str]\\n        :rtype: str\\n        \"\"\"\\n        word_temp = \"\"\\n        words = []\\n        for i, ch in enumerate(paragraph):\\n            if (ch.isdigit() or ch.isalpha()):\\n                word_temp += ch\\n            elif word_temp:\\n                words.append(word_temp.lower())\\n                word_temp = \"\"\\n        if word_temp: # the last word or paragraph a word\\n            words.append(word_temp.lower())\\n\\n        d = collections.defaultdict(int)\\n        res = \"\"\\n        cnt = 0\\n        for word in words:\\n            if word in banned:\\n                continue            \\n            d[word] += 1            \\n            if d[word] >= cnt:\\n                cnt = d[word]\\n                res = word           \\n    \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 454520,
                "title": "easy-to-understand-java-solution-16-ms",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n    \\n    // Replace all special Characters by space and splitting it\\n    String[] trimmedWords = paragraph.toLowerCase().replaceAll(\"[!,:;?.\\\\\\' \\']\", \" \").split(\" \");\\n        \\n    // HashMap to maintain count\\n    Map<String, Integer> wordsCount = new HashMap<String, Integer>();\\n        \\n    for(String s: trimmedWords){\\n        wordsCount.put(s, wordsCount.getOrDefault(s, 0) + 1);\\n    }\\n        \\n    \\n    // Remove the banned words from HashMap\\n    for(String s: banned){   \\n    if(wordsCount.containsKey(s)){\\n        wordsCount.remove(s);\\n    }  \\n    }\\n    \\n        \\n    int frequency = Integer.MIN_VALUE;    \\n    String result = null;\\n    \\n    for(Map.Entry<String, Integer> word: wordsCount.entrySet()){\\n        \\n    if(word.getValue() > frequency && word.getKey().length() > 0){\\n        frequency = word.getValue();\\n        result = word.getKey();\\n    }\\n        \\n    }\\n    \\n    return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n    \\n    // Replace all special Characters by space and splitting it\\n    String[] trimmedWords = paragraph.toLowerCase().replaceAll(\"[!,:;?.\\\\\\' \\']\", \" \").split(\" \");\\n        \\n    // HashMap to maintain count\\n    Map<String, Integer> wordsCount = new HashMap<String, Integer>();\\n        \\n    for(String s: trimmedWords){\\n        wordsCount.put(s, wordsCount.getOrDefault(s, 0) + 1);\\n    }\\n        \\n    \\n    // Remove the banned words from HashMap\\n    for(String s: banned){   \\n    if(wordsCount.containsKey(s)){\\n        wordsCount.remove(s);\\n    }  \\n    }\\n    \\n        \\n    int frequency = Integer.MIN_VALUE;    \\n    String result = null;\\n    \\n    for(Map.Entry<String, Integer> word: wordsCount.entrySet()){\\n        \\n    if(word.getValue() > frequency && word.getKey().length() > 0){\\n        frequency = word.getValue();\\n        result = word.getKey();\\n    }\\n        \\n    }\\n    \\n    return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440622,
                "title": "solution-using-hash-map",
                "content": "\\'\\'\\'\\n\\n\\n    class Solution:\\n        def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\t\\tfrom collections import Counter\\n            p = paragraph.lower()\\n\\t\\t\\t\\n            for c in \"!?.;\\',\":\\n               p = p.replace(c, \\' \\') \\n\\t\\t\\t   \\n            d = Counter(p.split())\\n            for word in banned:\\n                if word.lower() in d:\\n                    del d[word]\\n            v,k = max((v,k) for k,v in d.items())\\n            return k",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\'\\'\\'\\n\\n\\n    class Solution:\\n        def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\t\\tfrom collections import Counter\\n            p = paragraph.lower()\\n\\t\\t\\t\\n            for c in \"!?.;\\',\":\\n               p = p.replace(c, \\' \\') \\n\\t\\t\\t   \\n            d = Counter(p.split())\\n            for word in banned:\\n                if word.lower() in d:\\n                    del d[word]\\n            v,k = max((v,k) for k,v in d.items())\\n            return k",
                "codeTag": "Java"
            },
            {
                "id": 389675,
                "title": "c-solution-linear-complexity-only-stl-methods",
                "content": "Algorithm is really straightforward:\\n1) Preprocess paragraph: transform all letters to lowercase, other symbols to spaces (hello, bloody 47-th test case) -- O(P), where P is paragraph size;\\n2) Compute paragraph words frequencies and store them in hash map -- O(P)\\n3) Delete banned words from hash map -- O(B)\\n4) Find element with maximal freq\\n\\n```\\nclass Solution {\\npublic:\\n    // W = length of max word in paragraph or banned,        \\n    // P = number of words in paragraph\\n    // B = number of words in banned\\n    // Total complexity: O((P+B)W)\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n                \\n        // O(WP) -- preprocess paragraph: reduce punctuation\\n        transform(\\n            paragraph.begin(), paragraph.end(), paragraph.begin(),\\n            [](char c) -> char {\\n                return isalpha(c) ? tolower(c) : \\' \\';\\n            }\\n        );                    \\n        \\n        // O(WP) -- construct freqs\\n        unordered_map<string, int> mp;\\n        stringstream ss(paragraph);\\n        for (string word; ss >> word; )\\n            mp[move(word)]++;\\n        \\n        // O(WB) -- delete banned\\n        for (const auto& s : banned) {\\n            auto it = mp.find(s);\\n            if (it != end(mp)) {\\n                mp.erase(it);\\n            }\\n        }\\n        \\n        // O(P) -- find max\\n        auto most_freq_it \\n            = max_element(\\n                begin(mp), end(mp),\\n                [](auto& l, auto& r) {\\n                    return l.second < r.second;\\n                }\\n            );\\n        \\n        return (most_freq_it != end(mp) ? most_freq_it->first : string());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // W = length of max word in paragraph or banned,        \\n    // P = number of words in paragraph\\n    // B = number of words in banned\\n    // Total complexity: O((P+B)W)\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n                \\n        // O(WP) -- preprocess paragraph: reduce punctuation\\n        transform(\\n            paragraph.begin(), paragraph.end(), paragraph.begin(),\\n            [](char c) -> char {\\n                return isalpha(c) ? tolower(c) : \\' \\';\\n            }\\n        );                    \\n        \\n        // O(WP) -- construct freqs\\n        unordered_map<string, int> mp;\\n        stringstream ss(paragraph);\\n        for (string word; ss >> word; )\\n            mp[move(word)]++;\\n        \\n        // O(WB) -- delete banned\\n        for (const auto& s : banned) {\\n            auto it = mp.find(s);\\n            if (it != end(mp)) {\\n                mp.erase(it);\\n            }\\n        }\\n        \\n        // O(P) -- find max\\n        auto most_freq_it \\n            = max_element(\\n                begin(mp), end(mp),\\n                [](auto& l, auto& r) {\\n                    return l.second < r.second;\\n                }\\n            );\\n        \\n        return (most_freq_it != end(mp) ? most_freq_it->first : string());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353016,
                "title": "simple-java-solution-using-map",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        paragraph = paragraph.toLowerCase();\\n        String[] paraWords = paragraph.split(\"[ .,;!?\\']+\");\\n        \\n        //add paragraph words in map\\n        Map<String, Integer> map = new HashMap<String,Integer>();\\n        for(int i=0;i<paraWords.length;i++){\\n            String s = paraWords[i];\\n            map.put(s, map.getOrDefault(s,0)+1);\\n        }\\n        if(map.size() < banned.length)\\n            return \"\";\\n        \\n        //remove banned words from map\\n        for(int i=0; i<banned.length;i++)\\n            if(map.containsKey(banned[i]))\\n                map.remove(banned[i]);\\n        \\n        //return string with maximum count\\n        String maxStr=null;\\n        for(String word : map.keySet())\\n            if(maxStr == null || map.get(word) > map.get(maxStr))\\n                maxStr = word;\\n        \\n        return maxStr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        paragraph = paragraph.toLowerCase();\\n        String[] paraWords = paragraph.split(\"[ .,;!?\\']+\");\\n        \\n        //add paragraph words in map\\n        Map<String, Integer> map = new HashMap<String,Integer>();\\n        for(int i=0;i<paraWords.length;i++){\\n            String s = paraWords[i];\\n            map.put(s, map.getOrDefault(s,0)+1);\\n        }\\n        if(map.size() < banned.length)\\n            return \"\";\\n        \\n        //remove banned words from map\\n        for(int i=0; i<banned.length;i++)\\n            if(map.containsKey(banned[i]))\\n                map.remove(banned[i]);\\n        \\n        //return string with maximum count\\n        String maxStr=null;\\n        for(String word : map.keySet())\\n            if(maxStr == null || map.get(word) > map.get(maxStr))\\n                maxStr = word;\\n        \\n        return maxStr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352230,
                "title": "swift-solution-clean-code-beats-99",
                "content": "```\\nclass Solution {\\n    func mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\\n        guard paragraph.count != 0 else { return \"\" }\\n        \\n        var arr = paragraph.split{ !$0.isLetter }.map{ $0.lowercased() }\\n        let banned = Set(banned)       \\n        \\n        var dict = [String:Int]()\\n        var commonWord = String()\\n        \\n        for word in arr where !banned.contains(word) {\\n            dict[word] = (dict[word] ?? 0) + 1\\n            if dict[commonWord] ?? 0 < dict[word]! {\\n                commonWord = word\\n            }\\n        }\\n        return commonWord                                 \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\\n        guard paragraph.count != 0 else { return \"\" }\\n        \\n        var arr = paragraph.split{ !$0.isLetter }.map{ $0.lowercased() }\\n        let banned = Set(banned)       \\n        \\n        var dict = [String:Int]()\\n        var commonWord = String()\\n        \\n        for word in arr where !banned.contains(word) {\\n            dict[word] = (dict[word] ?? 0) + 1\\n            if dict[commonWord] ?? 0 < dict[word]! {\\n                commonWord = word\\n            }\\n        }\\n        return commonWord                                 \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346981,
                "title": "swift-32ms-4-lines-of-code",
                "content": "```\\n  func mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\\n    let words = paragraph.split{ !$0.isLetter }.map { String($0).lowercased() }\\n    var hashmap: [String: Int] = [:]\\n    \\n    for word in words where !banned.contains(word) {\\n      hashmap[word, default: 0] += 1\\n    }\\n    \\n    return hashmap.max { $0.value < $1.value }!.key\\n  }\\n  ```",
                "solutionTags": [],
                "code": "```\\n  func mostCommonWord(_ paragraph: String, _ banned: [String]) -> String {\\n    let words = paragraph.split{ !$0.isLetter }.map { String($0).lowercased() }\\n    var hashmap: [String: Int] = [:]\\n    \\n    for word in words where !banned.contains(word) {\\n      hashmap[word, default: 0] += 1\\n    }\\n    \\n    return hashmap.max { $0.value < $1.value }!.key\\n  }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 329448,
                "title": "python-using-counter-translate-table",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        #Use a translate table to map each of the punctuation symbols to a space.\\n\\t\\tremovePunctuationTable = str.maketrans(\"!?\\',;.\", \"      \")\\n        paragraph = paragraph.translate(removePunctuationTable)\\n        \\n        banned = set(banned)\\n        wordCount = Counter()\\n        for word in paragraph.split():\\n            word = word.lower()\\n            if word not in banned:\\n                wordCount[word] += 1\\n            \\n        return wordCount.most_common(1)[0][0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        #Use a translate table to map each of the punctuation symbols to a space.\\n\\t\\tremovePunctuationTable = str.maketrans(\"!?\\',;.\", \"      \")\\n        paragraph = paragraph.translate(removePunctuationTable)\\n        \\n        banned = set(banned)\\n        wordCount = Counter()\\n        for word in paragraph.split():\\n            word = word.lower()\\n            if word not in banned:\\n                wordCount[word] += 1\\n            \\n        return wordCount.most_common(1)[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316277,
                "title": "python-solution-fix",
                "content": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        for c in \"!?\\',;.\": \\n            paragraph = paragraph.replace(c, \" \")\\n            \\n        cpara = collections.Counter(paragraph.lower().split())\\n        banned = set(banned)\\n        \\n        for word,_ in cpara.most_common():\\n            if word not in banned:\\n                return word\\n        return \"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        for c in \"!?\\',;.\": \\n            paragraph = paragraph.replace(c, \" \")\\n            \\n        cpara = collections.Counter(paragraph.lower().split())\\n        banned = set(banned)\\n        \\n        for word,_ in cpara.most_common():\\n            if word not in banned:\\n                return word\\n        return \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309775,
                "title": "rust-because-why-not-0ms-100",
                "content": "```rust\\nuse std::collections::{HashSet, HashMap};\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n    pub fn most_common_word(paragraph: String, banned: Vec<String>) -> String {\\n        let mut banset: HashSet<String> = HashSet::from_iter(banned);\\n        let mut freq = HashMap::new();\\n        let words = paragraph.split(|c: char| c.is_ascii_punctuation() || c.is_ascii_whitespace());\\n        for word in words {\\n            let word = word.to_ascii_lowercase();\\n            if word == \"\" || banset.contains(&word) {\\n                continue;\\n            }\\n            *freq.entry(word).or_insert(0) += 1;\\n        }\\n        let mut most = \"\";\\n        let mut most_count = 0;\\n        for (k, v) in freq.iter() {\\n            if v > &most_count {\\n                most_count = *v;\\n                most = k\\n            }\\n        }\\n        most.to_string()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::collections::{HashSet, HashMap};\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n    pub fn most_common_word(paragraph: String, banned: Vec<String>) -> String {\\n        let mut banset: HashSet<String> = HashSet::from_iter(banned);\\n        let mut freq = HashMap::new();\\n        let words = paragraph.split(|c: char| c.is_ascii_punctuation() || c.is_ascii_whitespace());\\n        for word in words {\\n            let word = word.to_ascii_lowercase();\\n            if word == \"\" || banset.contains(&word) {\\n                continue;\\n            }\\n            *freq.entry(word).or_insert(0) += 1;\\n        }\\n        let mut most = \"\";\\n        let mut most_count = 0;\\n        for (k, v) in freq.iter() {\\n            if v > &most_count {\\n                most_count = *v;\\n                most = k\\n            }\\n        }\\n        most.to_string()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 294238,
                "title": "accepted-c-simple-solution-using-uordered-map",
                "content": "```\\nclass Solution {\\n    \\n    bool isAlpha ( char c )\\n    {\\n        c = tolower( c );\\n        \\n        if ( c >= \\'a\\' && c <= \\'z\\' )\\n            return true;\\n        \\n        return false;\\n    }\\n    \\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n     \\n        unordered_map < string, int > frequency;\\n        string temp;\\n        for ( int i = 0; i < paragraph.length(); i++ )\\n        {\\n            char currentChar = paragraph[i];\\n            if ( isAlpha (  currentChar ) )  //if char is valid alphabet between a - z (lowercase)\\n            {\\n                temp.push_back ( tolower(currentChar) );\\n            }else  //if char is any punctuation\\n            {\\n                if ( temp.size() ) //we could have only \",\" \\n                {\\n                    frequency[temp]++;\\n                }\\n                temp = \"\"; //reset temp\\n            }\\n        }\\n        \\n        if ( temp != \"\" ) frequency[temp]++; //if temp is not empty;\\n        /*\\n            \\n        for ( auto it: frequency )\\n        {\\n            cout << it.first << endl;\\n        }*/\\n        \\n        int maxFrequency = INT_MIN;\\n        string result = \"\";\\n        for ( auto it: frequency )\\n        {\\n            //if frequence is greater and word is not in banned list;\\n            if ( it.second > maxFrequency && ( find( banned.begin(), banned.end(), it.first) == banned.end() )  ) \\n            {\\n                maxFrequency = it.second;\\n                result = it.first;\\n            }\\n            \\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\n    bool isAlpha ( char c )\\n    {\\n        c = tolower( c );\\n        \\n        if ( c >= \\'a\\' && c <= \\'z\\' )\\n            return true;\\n        \\n        return false;\\n    }\\n    \\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n     \\n        unordered_map < string, int > frequency;\\n        string temp;\\n        for ( int i = 0; i < paragraph.length(); i++ )\\n        {\\n            char currentChar = paragraph[i];\\n            if ( isAlpha (  currentChar ) )  //if char is valid alphabet between a - z (lowercase)\\n            {\\n                temp.push_back ( tolower(currentChar) );\\n            }else  //if char is any punctuation\\n            {\\n                if ( temp.size() ) //we could have only \",\" \\n                {\\n                    frequency[temp]++;\\n                }\\n                temp = \"\"; //reset temp\\n            }\\n        }\\n        \\n        if ( temp != \"\" ) frequency[temp]++; //if temp is not empty;\\n        /*\\n            \\n        for ( auto it: frequency )\\n        {\\n            cout << it.first << endl;\\n        }*/\\n        \\n        int maxFrequency = INT_MIN;\\n        string result = \"\";\\n        for ( auto it: frequency )\\n        {\\n            //if frequence is greater and word is not in banned list;\\n            if ( it.second > maxFrequency && ( find( banned.begin(), banned.end(), it.first) == banned.end() )  ) \\n            {\\n                maxFrequency = it.second;\\n                result = it.first;\\n            }\\n            \\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 217718,
                "title": "python-1-liner-beats-91",
                "content": "Convert paragraph to lower-case. Find all word in paragraph (split it into words) omitting the punctuation marks by using ```\\\\w+``` regular expression. Count the occurences of word that are not banned and return the word with the highest count.\\n\\n```\\ndef mostCommonWord(self, paragraph, banned):\\n\\t\"\"\"\\n\\t:type paragraph: str\\n\\t:type banned: List[str]\\n\\t:rtype: str\\n\\t\"\"\"\\n\\treturn collections.Counter(W for W in re.findall(r\\'\\\\w+\\', paragraph.lower()) if W not in set(banned)).most_common(1)[0][0]\\n```\\nTime: O(n + m) where n is the length of paragraph and m the length of banned\\nSpace: O(n + m)",
                "solutionTags": [],
                "code": "```\\\\w+```\n```\\ndef mostCommonWord(self, paragraph, banned):\\n\\t\"\"\"\\n\\t:type paragraph: str\\n\\t:type banned: List[str]\\n\\t:rtype: str\\n\\t\"\"\"\\n\\treturn collections.Counter(W for W in re.findall(r\\'\\\\w+\\', paragraph.lower()) if W not in set(banned)).most_common(1)[0][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 207544,
                "title": "java-no-regex-simple-solution",
                "content": "```\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> set = new HashSet<>();\\n        Map<String, Integer> map = new HashMap<>();\\n        StringBuilder sb = new StringBuilder();\\n        int max = -1;\\n        String ans = \"\";\\n        paragraph += \".\";\\n        \\n        for(String str : banned) {\\n            set.add(str);\\n        }\\n        \\n        for(int i = 0; i < paragraph.length(); i++) {\\n            char cur = paragraph.charAt(i);\\n            \\n            if((cur >= \\'a\\' && cur <= \\'z\\') || (cur >= \\'A\\' && cur <= \\'Z\\')) {\\n                sb.append(cur);\\n            }\\n            else if(sb.length() > 0) {\\n                String s = sb.toString().toLowerCase();\\n                if(!set.contains(s)) {\\n                   map.put(s, map.getOrDefault(s, 0) + 1);\\n                    if(map.get(s) > max) {\\n                        max = map.get(s);\\n                        ans = s;\\n                    }\\n                }\\n                sb = new StringBuilder();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> set = new HashSet<>();\\n        Map<String, Integer> map = new HashMap<>();\\n        StringBuilder sb = new StringBuilder();\\n        int max = -1;\\n        String ans = \"\";\\n        paragraph += \".\";\\n        \\n        for(String str : banned) {\\n            set.add(str);\\n        }\\n        \\n        for(int i = 0; i < paragraph.length(); i++) {\\n            char cur = paragraph.charAt(i);\\n            \\n            if((cur >= \\'a\\' && cur <= \\'z\\') || (cur >= \\'A\\' && cur <= \\'Z\\')) {\\n                sb.append(cur);\\n            }\\n            else if(sb.length() > 0) {\\n                String s = sb.toString().toLowerCase();\\n                if(!set.contains(s)) {\\n                   map.put(s, map.getOrDefault(s, 0) + 1);\\n                    if(map.get(s) > max) {\\n                        max = map.get(s);\\n                        ans = s;\\n                    }\\n                }\\n                sb = new StringBuilder();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 124254,
                "title": "a-simple-java-solution",
                "content": "The core idea is how to use RE.\\n\\n```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Map<String, Integer> wordAndCount = new HashMap<String, Integer>();\\n        Set<String> bansSet = new HashSet<>(Arrays.asList(banned));\\n        //[!?,\\';] is the possible punctuations for this input, can also use \\'\\\\\\\\pP\\' instead for all of the punctuations.\\n        String[] words = paragraph.replaceAll(\"[!?\\',;.]\",\"\").toLowerCase().split(\" \");\\n        int max = 0;\\n        String res = \"\";\\n        for(String word:words){\\n            if(bansSet.contains(word)) continue;\\n\\t    // use getOrDefault - Java8 new default function from Map interface\\n            wordAndCount.put(word, wordAndCount.getOrDefault(word, 0) + 1);\\n            int count = wordAndCount.get(word);\\n            if( count > max) {\\n                max = count;\\n                res = word;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Map<String, Integer> wordAndCount = new HashMap<String, Integer>();\\n        Set<String> bansSet = new HashSet<>(Arrays.asList(banned));\\n        //[!?,\\';] is the possible punctuations for this input, can also use \\'\\\\\\\\pP\\' instead for all of the punctuations.\\n        String[] words = paragraph.replaceAll(\"[!?\\',;.]\",\"\").toLowerCase().split(\" \");\\n        int max = 0;\\n        String res = \"\";\\n        for(String word:words){\\n            if(bansSet.contains(word)) continue;\\n\\t    // use getOrDefault - Java8 new default function from Map interface\\n            wordAndCount.put(word, wordAndCount.getOrDefault(word, 0) + 1);\\n            int count = wordAndCount.get(word);\\n            if( count > max) {\\n                max = count;\\n                res = word;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3518175,
                "title": "easy-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String[] words=paragraph.toLowerCase().replaceAll(\"\\\\\\\\W+\" , \" \").split(\"\\\\\\\\s+\");\\n        HashMap<String,Integer>h=new HashMap<>();\\n        for(String word:words){\\n           \\n            int count=h.getOrDefault(word,0);\\n            h.put(word,count+1);\\n        }\\n        for(int i=0;i<banned.length;i++){\\n            h.remove(banned[i]);\\n        }\\n        int mx=Integer.MIN_VALUE;\\n        String ans=\"\";\\n        for(String m : h.keySet()){\\n            int p=h.get(m);\\n            if(p>mx){\\n                  ans=m;\\n                  mx=p;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        String[] words=paragraph.toLowerCase().replaceAll(\"\\\\\\\\W+\" , \" \").split(\"\\\\\\\\s+\");\\n        HashMap<String,Integer>h=new HashMap<>();\\n        for(String word:words){\\n           \\n            int count=h.getOrDefault(word,0);\\n            h.put(word,count+1);\\n        }\\n        for(int i=0;i<banned.length;i++){\\n            h.remove(banned[i]);\\n        }\\n        int mx=Integer.MIN_VALUE;\\n        String ans=\"\";\\n        for(String m : h.keySet()){\\n            int p=h.get(m);\\n            if(p>mx){\\n                  ans=m;\\n                  mx=p;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481554,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    string mostCommonWord(string str, vector<string>& banned) {\\n        unordered_map<string, int> hash;\\n        for(auto& it : str)\\n\\t\\t    it = ispunct(it) ? \\' \\' : tolower(it);\\n\\n        unordered_set<string> st(banned.begin(), banned.end());  \\n        string res, temp;      \\n        int maxi =0;\\n        stringstream ss(str);\\n        while(ss >> temp) hash[temp]++;\\n        \\n        for(auto& it:hash){\\n            if(it.second > maxi && !st.count(it.first)){\\n                maxi = it.second;\\n                res = it.first;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        paragraph = paragraph.lower()\\n        symbol = \"!?\\',;.\"\\n        for s in symbol:\\n            paragraph = paragraph.replace(s, \" \")\\n        paragraph = paragraph.split()\\n\\n        from collections import Counter\\n        lst = sorted(Counter(paragraph).items(), key=lambda e: -e[1])\\n        for e, _ in lst:\\n            if e not in banned:\\n                return e\\n                break\\n```\\n\\n```Java []\\nclass Solution {\\n    public String mostCommonWord(String p, String[] ban) {\\n        var e = p.toLowerCase().toCharArray();\\n        var t = new Trie();\\n        var res = new char[0];\\n        int max = 0;\\n        int l = e.length;\\n\\n        for (String w : ban) t.addW(w.toCharArray(), 0, true);\\n\\n        for (int i = 0, j = 0; i < l; j = i) {\\n            while (i < l && e[i] > 64) i++;\\n            if (i > j) {\\n                var w = Arrays.copyOfRange(e, j, i);\\n                int x = t.addW(w, 0, false);\\n                if (x > max) {\\n                    max = x;\\n                    res = w;\\n                }\\n                j = i + 1;\\n            }\\n            while (i < l && e[i] < 64) i++;\\n        }\\n        return new String(res);\\n    }\\n    private static class Trie {\\n        private int c;\\n        private final Trie[] t = new Trie[26];\\n\\n        public int addW(char[] w, int i, boolean ban) {\\n            if (i == w.length) {\\n                if (this.c == -1) return -1;\\n                return ban ? (this.c = -1) : ++this.c;\\n            }\\n            int idx = w[i] - \\'a\\';\\n            if (t[idx] == null) t[idx] = new Trie();\\n            return t[idx].addW(w, ++i, ban);\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string mostCommonWord(string str, vector<string>& banned) {\\n        unordered_map<string, int> hash;\\n        for(auto& it : str)\\n\\t\\t    it = ispunct(it) ? \\' \\' : tolower(it);\\n\\n        unordered_set<string> st(banned.begin(), banned.end());  \\n        string res, temp;      \\n        int maxi =0;\\n        stringstream ss(str);\\n        while(ss >> temp) hash[temp]++;\\n        \\n        for(auto& it:hash){\\n            if(it.second > maxi && !st.count(it.first)){\\n                maxi = it.second;\\n                res = it.first;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        paragraph = paragraph.lower()\\n        symbol = \"!?\\',;.\"\\n        for s in symbol:\\n            paragraph = paragraph.replace(s, \" \")\\n        paragraph = paragraph.split()\\n\\n        from collections import Counter\\n        lst = sorted(Counter(paragraph).items(), key=lambda e: -e[1])\\n        for e, _ in lst:\\n            if e not in banned:\\n                return e\\n                break\\n```\n```Java []\\nclass Solution {\\n    public String mostCommonWord(String p, String[] ban) {\\n        var e = p.toLowerCase().toCharArray();\\n        var t = new Trie();\\n        var res = new char[0];\\n        int max = 0;\\n        int l = e.length;\\n\\n        for (String w : ban) t.addW(w.toCharArray(), 0, true);\\n\\n        for (int i = 0, j = 0; i < l; j = i) {\\n            while (i < l && e[i] > 64) i++;\\n            if (i > j) {\\n                var w = Arrays.copyOfRange(e, j, i);\\n                int x = t.addW(w, 0, false);\\n                if (x > max) {\\n                    max = x;\\n                    res = w;\\n                }\\n                j = i + 1;\\n            }\\n            while (i < l && e[i] < 64) i++;\\n        }\\n        return new String(res);\\n    }\\n    private static class Trie {\\n        private int c;\\n        private final Trie[] t = new Trie[26];\\n\\n        public int addW(char[] w, int i, boolean ban) {\\n            if (i == w.length) {\\n                if (this.c == -1) return -1;\\n                return ban ? (this.c = -1) : ++this.c;\\n            }\\n            int idx = w[i] - \\'a\\';\\n            if (t[idx] == null) t[idx] = new Trie();\\n            return t[idx].addW(w, ++i, ban);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139931,
                "title": "0-ms-100-faster-easy-you-understand",
                "content": "# Code\\n```\\nfunc mostCommonWord(paragraph string, banned []string) string {\\n    s := strings.ToLower(paragraph) + \" \"\\n\\n    str := make(map[string]int)\\n    s1 := \"\"\\n    for  _, v := range s {\\n        if v == \\' \\' || strings.Contains(\"!?\\',;.\", string(v)) {\\n            if len(s1) != 0 {\\n                str[s1]++\\n                s1 = \"\"\\n            }\\n        }else {\\n            s1 += string(v)\\n        }\\n    }\\n\\n    for _, v := range banned {\\n        delete(str, v)\\n    }\\n\\n\\n    res := \"\"\\n    max := 0\\n    for k, v := range str {\\n        if v > max {\\n            max = v\\n            res = k\\n        }\\n    }\\n\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc mostCommonWord(paragraph string, banned []string) string {\\n    s := strings.ToLower(paragraph) + \" \"\\n\\n    str := make(map[string]int)\\n    s1 := \"\"\\n    for  _, v := range s {\\n        if v == \\' \\' || strings.Contains(\"!?\\',;.\", string(v)) {\\n            if len(s1) != 0 {\\n                str[s1]++\\n                s1 = \"\"\\n            }\\n        }else {\\n            s1 += string(v)\\n        }\\n    }\\n\\n    for _, v := range banned {\\n        delete(str, v)\\n    }\\n\\n\\n    res := \"\"\\n    max := 0\\n    for k, v := range str {\\n        if v > max {\\n            max = v\\n            res = k\\n        }\\n    }\\n\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2873929,
                "title": "most-common-word-c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map<string, int>m;\\n        int i=0,n=paragraph.size();\\n        while(i<n){\\n            string s = \"\";\\n            while(i<n && isalpha(paragraph[i])) { // if word is an alphabet \\n                s.push_back(tolower(paragraph[i++]));//convert tolower case & push into string\\n            }\\n            while(i<n && !isalpha(paragraph[i])){ // if word not an alphabet then skip  \\n                i++;\\n            }\\n            m[s]++; // insert string in map \\n        }\\n        \\n        for(auto it: banned){\\n            m[it]=0;   // mark frequency of banned words as 0   \\n        }\\n        string ans = \"\";\\n        int maxfreq = 0;\\n        for(auto it: m){ // check for word with max frequency\\n            if(it.second>maxfreq){\\n                ans=it.first;\\n                maxfreq=it.second; \\n            }\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map<string, int>m;\\n        int i=0,n=paragraph.size();\\n        while(i<n){\\n            string s = \"\";\\n            while(i<n && isalpha(paragraph[i])) { // if word is an alphabet \\n                s.push_back(tolower(paragraph[i++]));//convert tolower case & push into string\\n            }\\n            while(i<n && !isalpha(paragraph[i])){ // if word not an alphabet then skip  \\n                i++;\\n            }\\n            m[s]++; // insert string in map \\n        }\\n        \\n        for(auto it: banned){\\n            m[it]=0;   // mark frequency of banned words as 0   \\n        }\\n        string ans = \"\";\\n        int maxfreq = 0;\\n        for(auto it: m){ // check for word with max frequency\\n            if(it.second>maxfreq){\\n                ans=it.first;\\n                maxfreq=it.second; \\n            }\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732090,
                "title": "java-solution-clean",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> set = new HashSet<>();\\n        for (String s : banned) set.add(s);\\n\\n        Map<String, Integer> map = new HashMap<>();\\n        String[] para = paragraph.replaceAll(\"[^a-zA-Z]\", \" \").toLowerCase().split(\" \");\\n\\n        for (String w : para) {\\n            if (!set.contains(w)) {\\n                map.put(w, map.getOrDefault(w, 0) + 1);\\n            }\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        \\n        for (String key : map.keySet()) {\\n            if (ans.toString().equals(\"\") || map.get(key) > map.get(ans.toString())) {\\n                ans.setLength(0);\\n                ans.append(key);\\n            }\\n        }\\n        \\n        return ans.toString();\\n    }\\n}\\n\\n// TC: O(n) + O(m * logn) - set.contains() costs O(logn)\\n// SC: O(n) + O(m)\\n\\n// n is the length of banned array\\n// m is the size of paragraph string array\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> set = new HashSet<>();\\n        for (String s : banned) set.add(s);\\n\\n        Map<String, Integer> map = new HashMap<>();\\n        String[] para = paragraph.replaceAll(\"[^a-zA-Z]\", \" \").toLowerCase().split(\" \");\\n\\n        for (String w : para) {\\n            if (!set.contains(w)) {\\n                map.put(w, map.getOrDefault(w, 0) + 1);\\n            }\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        \\n        for (String key : map.keySet()) {\\n            if (ans.toString().equals(\"\") || map.get(key) > map.get(ans.toString())) {\\n                ans.setLength(0);\\n                ans.append(key);\\n            }\\n        }\\n        \\n        return ans.toString();\\n    }\\n}\\n\\n// TC: O(n) + O(m * logn) - set.contains() costs O(logn)\\n// SC: O(n) + O(m)\\n\\n// n is the length of banned array\\n// m is the size of paragraph string array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637819,
                "title": "easy-c-solution-using-hashmaps",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string para, vector<string>& ban) {\\n      \\n        transform(para.begin(), para.end(), para.begin(), ::toupper);\\n        for(int i=0;i<ban.size();i++)\\n        {\\n             transform(ban[i].begin(), ban[i].end(), ban[i].begin(), ::toupper);\\n            \\n        }\\n       \\n        string x=\"\",ress;\\n        if(ban.size()!=0)\\n        {\\n            unordered_set<string>s(ban.begin(),ban.end());\\n        unordered_map<string,int>m;\\n        for(int i=0;i<para.size();i++)\\n        {\\n            if(para[i]<\\'A\\' || para[i]>\\'Z\\')\\n            {\\n                if(x.size()!=0 && s.find(x)==s.end())\\n                {\\n                    m[x]++;\\n                }\\n                x=\"\";\\n            }\\n            else\\n            {\\n                x+=para[i];\\n            }\\n        }\\n            if(x.size()!=0 && s.find(x)==s.end())\\n                {\\n                    m[x]++;\\n                }\\n        auto it=m.begin();\\n        string ans=it->first;\\n        int t=it->second;\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            if(it->second>t)\\n            {\\n                t=it->second;\\n                ans=it->first;\\n            }\\n        }\\n         ress=ans;\\n        }\\n        else\\n        {\\n           unordered_map<string,int>m;\\n        for(int i=0;i<para.size();i++)\\n        {\\n            if(para[i]<\\'A\\' || para[i]>\\'Z\\')\\n            {\\n                if(x.size()!=0)\\n                {\\n                    m[x]++;\\n                }\\n                x=\"\";\\n            }\\n            else\\n            {\\n                x+=para[i];\\n            }\\n        }\\n            if(x.size()!=0 )\\n                {\\n                    m[x]++;\\n                }\\n        auto it=m.begin();\\n        string ans=it->first;\\n        int t=it->second;\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            if(it->second>t)\\n            {\\n                t=it->second;\\n                ans=it->first;\\n            }\\n        } \\n            ress=ans;\\n        }\\n        transform(ress.begin(), ress.end(), ress.begin(), ::tolower);\\n        return ress;\\n    }\\n        \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string para, vector<string>& ban) {\\n      \\n        transform(para.begin(), para.end(), para.begin(), ::toupper);\\n        for(int i=0;i<ban.size();i++)\\n        {\\n             transform(ban[i].begin(), ban[i].end(), ban[i].begin(), ::toupper);\\n            \\n        }\\n       \\n        string x=\"\",ress;\\n        if(ban.size()!=0)\\n        {\\n            unordered_set<string>s(ban.begin(),ban.end());\\n        unordered_map<string,int>m;\\n        for(int i=0;i<para.size();i++)\\n        {\\n            if(para[i]<\\'A\\' || para[i]>\\'Z\\')\\n            {\\n                if(x.size()!=0 && s.find(x)==s.end())\\n                {\\n                    m[x]++;\\n                }\\n                x=\"\";\\n            }\\n            else\\n            {\\n                x+=para[i];\\n            }\\n        }\\n            if(x.size()!=0 && s.find(x)==s.end())\\n                {\\n                    m[x]++;\\n                }\\n        auto it=m.begin();\\n        string ans=it->first;\\n        int t=it->second;\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            if(it->second>t)\\n            {\\n                t=it->second;\\n                ans=it->first;\\n            }\\n        }\\n         ress=ans;\\n        }\\n        else\\n        {\\n           unordered_map<string,int>m;\\n        for(int i=0;i<para.size();i++)\\n        {\\n            if(para[i]<\\'A\\' || para[i]>\\'Z\\')\\n            {\\n                if(x.size()!=0)\\n                {\\n                    m[x]++;\\n                }\\n                x=\"\";\\n            }\\n            else\\n            {\\n                x+=para[i];\\n            }\\n        }\\n            if(x.size()!=0 )\\n                {\\n                    m[x]++;\\n                }\\n        auto it=m.begin();\\n        string ans=it->first;\\n        int t=it->second;\\n        for(auto it=m.begin();it!=m.end();it++)\\n        {\\n            if(it->second>t)\\n            {\\n                t=it->second;\\n                ans=it->first;\\n            }\\n        } \\n            ress=ans;\\n        }\\n        transform(ress.begin(), ress.end(), ress.begin(), ::tolower);\\n        return ress;\\n    }\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613917,
                "title": "simple-python-solution-counter",
                "content": "```\\n#Import RegEx\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        #List words in paragraph, replacing punctuation with \\' \\' and all lower case\\n        paragraph = re.subn(\"[.,!?;\\']\", \\' \\', paragraph.lower())[0].split(\\' \\')\\n        \\n        #Remove any \\'\\' or words in banned from paragraph list\\n        paragraph = list(filter(lambda x: x not in banned + [\\'\\'], paragraph))\\n        \\n        #Return most common word in filtered list\\n        return Counter(paragraph).most_common(1)[0][0]",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n#Import RegEx\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        #List words in paragraph, replacing punctuation with \\' \\' and all lower case\\n        paragraph = re.subn(\"[.,!?;\\']\", \\' \\', paragraph.lower())[0].split(\\' \\')\\n        \\n        #Remove any \\'\\' or words in banned from paragraph list\\n        paragraph = list(filter(lambda x: x not in banned + [\\'\\'], paragraph))\\n        \\n        #Return most common word in filtered list\\n        return Counter(paragraph).most_common(1)[0][0]",
                "codeTag": "Java"
            },
            {
                "id": 2549421,
                "title": "js-simple-solution-with-hashmap-and-regex",
                "content": "```\\nconst REGEX = /[^a-zA-Z ]/g;\\nvar mostCommonWord = function(paragraph, banned) {\\n    paragraph = paragraph.replace(REGEX, \\' \\');\\n    const hashmapBanned = {};\\n    const hashmapParagraph = {};\\n    const arrayParagraph = paragraph.split(\\' \\');\\n    let output;\\n    let count = 0;\\n    \\n    for (let i = 0; i < banned.length; i++) {\\n        hashmapBanned[banned[i]] = 1;\\n    }\\n    \\n    for (let i = 0; i < arrayParagraph.length; i++) {\\n        const word = arrayParagraph[i].toLowerCase();\\n        if (!hashmapBanned[word] && word) {\\n            if (hashmapParagraph[word]) {\\n                hashmapParagraph[word]++;\\n                if (hashmapParagraph[word] > count) {\\n                    output = word;\\n                    count = hashmapParagraph[word];\\n                }\\n            } else {\\n                hashmapParagraph[word] = 1;\\n                if (!count) {\\n                    output = word;\\n                    count = 1;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst REGEX = /[^a-zA-Z ]/g;\\nvar mostCommonWord = function(paragraph, banned) {\\n    paragraph = paragraph.replace(REGEX, \\' \\');\\n    const hashmapBanned = {};\\n    const hashmapParagraph = {};\\n    const arrayParagraph = paragraph.split(\\' \\');\\n    let output;\\n    let count = 0;\\n    \\n    for (let i = 0; i < banned.length; i++) {\\n        hashmapBanned[banned[i]] = 1;\\n    }\\n    \\n    for (let i = 0; i < arrayParagraph.length; i++) {\\n        const word = arrayParagraph[i].toLowerCase();\\n        if (!hashmapBanned[word] && word) {\\n            if (hashmapParagraph[word]) {\\n                hashmapParagraph[word]++;\\n                if (hashmapParagraph[word] > count) {\\n                    output = word;\\n                    count = hashmapParagraph[word];\\n                }\\n            } else {\\n                hashmapParagraph[word] = 1;\\n                if (!count) {\\n                    output = word;\\n                    count = 1;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2505584,
                "title": "python-c-java-easy-solution-using-hash-map-o-n",
                "content": "**\\u2705Below code is in python same approach for C++ and JAVA\\nPlease UPVOTE if u like the CODE (^_^)**\\n\\n**Time Complexity :O(n)**\\n```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        paragraph=paragraph.lower()\\n        a=\"!?\\',;.\"\\n        for i in a:\\n            print(i)\\n            if i in paragraph:\\n                print(\\'--\\')\\n                paragraph=paragraph.replace(i,\\' \\')\\n        paragraph=paragraph.split()\\n        d={}\\n        ans=0\\n        c=\\'\\'\\n        for i in paragraph:\\n            if not i in banned:\\n                d[i]=1+d.get(i,0)\\n                ans=max(ans,d[i])\\n                if ans==d[i]:\\n                    c=i\\n        print(d)\\n        return c\\n```\\n\\n\\n\\n\\n**Runtime: 74 ms, faster than 56.51% of Python3 online submissions for Most Common Word.\\nMemory Usage: 14 MB, less than 6.00% of Python3 online submissions for Most Common Word.**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        paragraph=paragraph.lower()\\n        a=\"!?\\',;.\"\\n        for i in a:\\n            print(i)\\n            if i in paragraph:\\n                print(\\'--\\')\\n                paragraph=paragraph.replace(i,\\' \\')\\n        paragraph=paragraph.split()\\n        d={}\\n        ans=0\\n        c=\\'\\'\\n        for i in paragraph:\\n            if not i in banned:\\n                d[i]=1+d.get(i,0)\\n                ans=max(ans,d[i])\\n                if ans==d[i]:\\n                    c=i\\n        print(d)\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478761,
                "title": "python3-runtime-41-ms-faster-than-86-77",
                "content": "from collections import Counter, OrderedDict\\n    import regex as re\\n\\t\\n\\tparagraph = \" \".join(re.findall(r\"[a-zA-Z0-9]+\", paragraph))\\n    c = Counter(paragraph.lower().split())\\n    c = OrderedDict(c.most_common())\\n    for word in c:\\n        if word not in banned:\\n            return word\\n\\t\\t\\t\\nFirst use regex to remove all special charater from the string. Create a `Counter` object with lowercased words. Sort with `most_common() `function. Finally loop over the `OrderedDict` and check if current word is in the banned list. If not return that word.",
                "solutionTags": [
                    "Python"
                ],
                "code": "from collections import Counter, OrderedDict\\n    import regex as re\\n\\t\\n\\tparagraph = \" \".join(re.findall(r\"[a-zA-Z0-9]+\", paragraph))\\n    c = Counter(paragraph.lower().split())\\n    c = OrderedDict(c.most_common())\\n    for word in c:\\n        if word not in banned:\\n            return word\\n\\t\\t\\t\\nFirst use regex to remove all special charater from the string. Create a `Counter` object with lowercased words. Sort with `most_common() `function. Finally loop over the `OrderedDict` and check if current word is in the banned list. If not return that word.",
                "codeTag": "Python3"
            },
            {
                "id": 2438707,
                "title": "most-common-word-easiest-solution-using-hash-map-with-proper-comments-kids-can-also-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int>mp;\\n    unordered_set<string>st;\\n    string mostCommonWord(string para, vector<string>& banned) {\\n        \\n        //first we will convert the sting to lowercase\\n        string str=\"\";\\n        for(int i=0;i<para.length();i++)\\n        {\\n            if(para[i]>=\\'A\\' and para[i]<=\\'Z\\')\\n            {\\n                char temp=tolower(para[i]);\\n                str=str+temp;\\n            }\\n            else\\n            {\\n                str=str+para[i];\\n            }\\n        }\\n        \\n        //getting the words from the str;\\n        int idx=0;\\n        string word=\"\";\\n        vector<string>s;\\n        while(true)\\n        {\\n            if(idx>=str.length())\\n            {\\n                if(word.length()>0)\\n                {\\n                    mp[word]++;\\n                    s.push_back(word);\\n                }\\n                break;\\n            }\\n            \\n            if(str[idx]>=\\'a\\' and str[idx]<=\\'z\\')\\n            {\\n                word=word+str[idx];\\n                idx++;\\n            }\\n            else   //could be space comma !?\\',;.\\n            {\\n                //word yaha milega\\n                mp[word]++;\\n                s.push_back(word);\\n                word=\"\";\\n                \\n                while(idx<str.length() and !(str[idx]>=\\'a\\' and str[idx]<=\\'z\\'))\\n                {\\n                    idx++;\\n                }\\n            }\\n        }\\n        //inserting the word in the unordered_set\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            st.insert(banned[i]);\\n        }\\n        \\n        //traversing the map for getting the ans \\n        int count=INT_MIN;\\n        string ans=\"\";\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if(it->second>count and st.find(it->first)==st.end())\\n            {\\n                ans=it->first;\\n                count=it->second;\\n            }\\n        }\\n        //returning the ans\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int>mp;\\n    unordered_set<string>st;\\n    string mostCommonWord(string para, vector<string>& banned) {\\n        \\n        //first we will convert the sting to lowercase\\n        string str=\"\";\\n        for(int i=0;i<para.length();i++)\\n        {\\n            if(para[i]>=\\'A\\' and para[i]<=\\'Z\\')\\n            {\\n                char temp=tolower(para[i]);\\n                str=str+temp;\\n            }\\n            else\\n            {\\n                str=str+para[i];\\n            }\\n        }\\n        \\n        //getting the words from the str;\\n        int idx=0;\\n        string word=\"\";\\n        vector<string>s;\\n        while(true)\\n        {\\n            if(idx>=str.length())\\n            {\\n                if(word.length()>0)\\n                {\\n                    mp[word]++;\\n                    s.push_back(word);\\n                }\\n                break;\\n            }\\n            \\n            if(str[idx]>=\\'a\\' and str[idx]<=\\'z\\')\\n            {\\n                word=word+str[idx];\\n                idx++;\\n            }\\n            else   //could be space comma !?\\',;.\\n            {\\n                //word yaha milega\\n                mp[word]++;\\n                s.push_back(word);\\n                word=\"\";\\n                \\n                while(idx<str.length() and !(str[idx]>=\\'a\\' and str[idx]<=\\'z\\'))\\n                {\\n                    idx++;\\n                }\\n            }\\n        }\\n        //inserting the word in the unordered_set\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            st.insert(banned[i]);\\n        }\\n        \\n        //traversing the map for getting the ans \\n        int count=INT_MIN;\\n        string ans=\"\";\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if(it->second>count and st.find(it->first)==st.end())\\n            {\\n                ans=it->first;\\n                count=it->second;\\n            }\\n        }\\n        //returning the ans\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424817,
                "title": "819-most-common-word-by-ashutosh-tomar",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& b) {\\n        string s=\"\";\\n        map<string,int>m;\\n        for(int i=0;i<p.size();i++){\\n            while(p[i] != \\' \\' and i < p.size()){\\n                if(!(tolower(p[i]) >= 97 and tolower(p[i]) <= 122)){\\n                    i++;\\n                    break;\\n                }\\n                s += tolower(p[i]);\\n                i++;\\n            }\\n            if(s != \"\") m[s]++;\\n            s = \"\";\\n        }\\n        s = \"\";\\n        for(int i=0;i<b.size();i++){\\n            //s += b[i];\\n            m.erase(b[i]);\\n        }\\n        //m.erase(s);\\n        string ans = \"\";\\n        int check = 0;\\n        for(auto i : m){\\n            cout<<i.first<<\" \"<<i.second<<endl;\\n        }\\n        for(auto i : m){\\n            check = max(i.second,check);\\n        }\\n        cout<<check;\\n        for(auto i : m){\\n            if(i.second == check){\\n                ans += i.first;\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& b) {\\n        string s=\"\";\\n        map<string,int>m;\\n        for(int i=0;i<p.size();i++){\\n            while(p[i] != \\' \\' and i < p.size()){\\n                if(!(tolower(p[i]) >= 97 and tolower(p[i]) <= 122)){\\n                    i++;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2408941,
                "title": "c-easy-to-understand-efficient",
                "content": "class Solution {\\npublic:\\n```\\n    string mostCommonWord(string paragraph, vector<string>& b) {\\n\\n        // Replace punctuation with <space>\\n        replace_if(paragraph.begin() , paragraph.end(),\\n            [] (const char& c) { return ispunct(c) ;},\\' \\');\\n\\n        unordered_set<string> banned(b.begin(), b.end());\\n        map<string, int> wordFrequency;\\n        istringstream ss(paragraph);\\n        string word;\\n        while (ss >> word) {\\n            transform(word.begin(), word.end(), word.begin(), ::tolower);\\n            if (banned.find(word) == banned.end()) {\\n                wordFrequency[word]++;\\n            }\\n        }\\n\\n        // Find the highest frequency, non-banned word in paragraph\\n        string w = wordFrequency.begin()->first;\\n        int f = wordFrequency.begin()->second;\\n        for (auto j : wordFrequency) {\\n            if (j.second > f) {\\n                w = j.first;\\n                f = j.second;\\n            }\\n        }\\n        \\n        return w;\\n    }\\n```\\n};",
                "solutionTags": [],
                "code": "```\\n    string mostCommonWord(string paragraph, vector<string>& b) {\\n\\n        // Replace punctuation with <space>\\n        replace_if(paragraph.begin() , paragraph.end(),\\n            [] (const char& c) { return ispunct(c) ;},\\' \\');\\n\\n        unordered_set<string> banned(b.begin(), b.end());\\n        map<string, int> wordFrequency;\\n        istringstream ss(paragraph);\\n        string word;\\n        while (ss >> word) {\\n            transform(word.begin(), word.end(), word.begin(), ::tolower);\\n            if (banned.find(word) == banned.end()) {\\n                wordFrequency[word]++;\\n            }\\n        }\\n\\n        // Find the highest frequency, non-banned word in paragraph\\n        string w = wordFrequency.begin()->first;\\n        int f = wordFrequency.begin()->second;\\n        for (auto j : wordFrequency) {\\n            if (j.second > f) {\\n                w = j.first;\\n                f = j.second;\\n            }\\n        }\\n        \\n        return w;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2347516,
                "title": "java-o-n-m-hashmap-easy",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n       \\n        HashMap<String, Integer> hm = new HashMap<>();\\n        String[] words = paragraph.replaceAll(\"[!?\\',;.]\",\" \").toLowerCase().split(\"\\\\\\\\s+\");\\n        for(int i=0; i<words.length; i++)\\n        {\\n            if(hm.containsKey(words[i]))\\n                hm.replace(words[i], hm.get(words[i]), hm.get(words[i])+1);\\n            else\\n                hm.put(words[i], 1);\\n        }\\n        \\n        for(int i=0; i< banned.length; i++)\\n            if(hm.containsKey(banned[i]))\\n                 hm.remove(banned[i]);\\n\\n        return Collections.max(hm.entrySet(), Map.Entry.comparingByValue()).getKey();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n       \\n        HashMap<String, Integer> hm = new HashMap<>();\\n        String[] words = paragraph.replaceAll(\"[!?\\',;.]\",\" \").toLowerCase().split(\"\\\\\\\\s+\");\\n        for(int i=0; i<words.length; i++)\\n        {\\n            if(hm.containsKey(words[i]))\\n                hm.replace(words[i], hm.get(words[i]), hm.get(words[i])+1);\\n            else\\n                hm.put(words[i], 1);\\n        }\\n        \\n        for(int i=0; i< banned.length; i++)\\n            if(hm.containsKey(banned[i]))\\n                 hm.remove(banned[i]);\\n\\n        return Collections.max(hm.entrySet(), Map.Entry.comparingByValue()).getKey();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337364,
                "title": "python-2-solutions-easy",
                "content": "Solution by leetcode.\\n\\n\\tclass Solution:\\n\\t\\tdef mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\t\\t#1). replace the punctuations with spaces,\\n\\t\\t\\t#      and put all letters in lower case\\n\\t\\t\\tnormalized_str = \\'\\'.join([c.lower() if c.isalnum() else \\' \\' for c in paragraph])\\n\\n\\t\\t\\t#2). split the string into words\\n\\t\\t\\twords = normalized_str.split()\\n\\n\\t\\t\\tword_count = defaultdict(int)\\n\\t\\t\\tbanned_words = set(banned)\\n\\n\\t\\t\\t#3). count the appearance of each word, excluding the banned words\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\tif word not in banned_words:\\n\\t\\t\\t\\t\\tword_count[word] += 1\\n\\n\\t\\t\\t#4). return the word with the highest frequency\\n\\t\\t\\treturn max(word_count.items(), key=operator.itemgetter(1))[0]\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\nmy solution.\\t\\t\\n\\t\\t\\t\\n\\tclass Solution:\\n\\t\\tdef mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\t\\ts=\"\".join([c.lower() if c.isalnum() else \" \" for c in paragraph])   #1). replace the punctuations with spaces,\\n\\t\\t\\t#      and put all letters in lower case\\n\\t\\t\\tl=s.split()                       #2). split the string into words\\n\\t\\t\\ts=set(banned)                 \\n\\t\\t\\td=defaultdict(int)\\n\\t\\t\\tmaxi=0\\n\\t\\t\\tans=\"\"\\n\\t\\t\\tfor i in l:\\n\\t\\t\\t\\tif i in s:                      #3). count the appearance of each word, excluding the banned words\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif i in d.keys():         # if key already exists increase its value\\n\\t\\t\\t\\t\\td[i]+=1\\n\\t\\t\\t\\telse :                          #else initialize with value 1\\n\\t\\t\\t\\t\\td[i]=1\\n\\t\\t\\t\\tif d[i]>maxi:              #simultaneously count the the max value and the corresponding key\\n\\t\\t\\t\\t\\tmaxi=d[i]\\n\\t\\t\\t\\t\\tans=i\\n\\t\\t\\treturn ans               #return answer\\n\\nupvote if the solution helped.\\uD83D\\uDE0A",
                "solutionTags": [],
                "code": "Solution by leetcode.\\n\\n\\tclass Solution:\\n\\t\\tdef mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\t\\t#1). replace the punctuations with spaces,\\n\\t\\t\\t#      and put all letters in lower case\\n\\t\\t\\tnormalized_str = \\'\\'.join([c.lower() if c.isalnum() else \\' \\' for c in paragraph])\\n\\n\\t\\t\\t#2). split the string into words\\n\\t\\t\\twords = normalized_str.split()\\n\\n\\t\\t\\tword_count = defaultdict(int)\\n\\t\\t\\tbanned_words = set(banned)\\n\\n\\t\\t\\t#3). count the appearance of each word, excluding the banned words\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\tif word not in banned_words:\\n\\t\\t\\t\\t\\tword_count[word] += 1\\n\\n\\t\\t\\t#4). return the word with the highest frequency\\n\\t\\t\\treturn max(word_count.items(), key=operator.itemgetter(1))[0]\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\nmy solution.\\t\\t\\n\\t\\t\\t\\n\\tclass Solution:\\n\\t\\tdef mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n\\t\\t\\ts=\"\".join([c.lower() if c.isalnum() else \" \" for c in paragraph])   #1). replace the punctuations with spaces,\\n\\t\\t\\t#      and put all letters in lower case\\n\\t\\t\\tl=s.split()                       #2). split the string into words\\n\\t\\t\\ts=set(banned)                 \\n\\t\\t\\td=defaultdict(int)\\n\\t\\t\\tmaxi=0\\n\\t\\t\\tans=\"\"\\n\\t\\t\\tfor i in l:\\n\\t\\t\\t\\tif i in s:                      #3). count the appearance of each word, excluding the banned words\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif i in d.keys():         # if key already exists increase its value\\n\\t\\t\\t\\t\\td[i]+=1\\n\\t\\t\\t\\telse :                          #else initialize with value 1\\n\\t\\t\\t\\t\\td[i]=1\\n\\t\\t\\t\\tif d[i]>maxi:              #simultaneously count the the max value and the corresponding key\\n\\t\\t\\t\\t\\tmaxi=d[i]\\n\\t\\t\\t\\t\\tans=i\\n\\t\\t\\treturn ans               #return answer\\n\\nupvote if the solution helped.\\uD83D\\uDE0A",
                "codeTag": "Java"
            },
            {
                "id": 2326791,
                "title": "100-faster-c-solution-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        transform(paragraph.begin(), paragraph.end(), paragraph.begin(), ::tolower);\\n        string temp = \"\";\\n        unordered_map<string, int> mp;\\n        for(int i = 0; i < paragraph.size(); i++)\\n        {\\n            if(isalpha(paragraph[i]))\\n            {\\n                temp += paragraph[i];\\n            }\\n            else if(paragraph[i] == \\' \\' || paragraph[i] == \\',\\')\\n            {\\n                if(temp != \"\")\\n                {\\n                    mp[temp]++;\\n                    temp = \"\";\\n                }\\n            }\\n        }\\n        mp[temp]++;\\n        temp = \"\";\\n        for(int i = 0; i < banned.size(); i++)\\n        {\\n            mp[banned[i]] = 0;\\n        }\\n        int n = INT_MIN;\\n        for(auto i : mp)\\n        {\\n            if(i.second > n)\\n            {\\n                temp = i.first;\\n                n = i.second;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        transform(paragraph.begin(), paragraph.end(), paragraph.begin(), ::tolower);\\n        string temp = \"\";\\n        unordered_map<string, int> mp;\\n        for(int i = 0; i < paragraph.size(); i++)\\n        {\\n            if(isalpha(paragraph[i]))\\n            {\\n                temp += paragraph[i];\\n            }\\n            else if(paragraph[i] == \\' \\' || paragraph[i] == \\',\\')\\n            {\\n                if(temp != \"\")\\n                {\\n                    mp[temp]++;\\n                    temp = \"\";\\n                }\\n            }\\n        }\\n        mp[temp]++;\\n        temp = \"\";\\n        for(int i = 0; i < banned.size(); i++)\\n        {\\n            mp[banned[i]] = 0;\\n        }\\n        int n = INT_MIN;\\n        for(auto i : mp)\\n        {\\n            if(i.second > n)\\n            {\\n                temp = i.first;\\n                n = i.second;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310341,
                "title": "python-simple-hashmap",
                "content": "\\n    def mostCommonWord(self, paragraph, banned):\\n        for i in \"!?\\',;.\":\\n            paragraph = paragraph.replace(i, \" \")\\n            \\n        dict1 = Counter([i for i in paragraph.lower().split()])\\n        \\n        ans = sorted(dict1, key = dict1.get, reverse = True)\\n        \\n        for i in ans:\\n            if i not in banned:\\n                return i",
                "solutionTags": [],
                "code": "\\n    def mostCommonWord(self, paragraph, banned):\\n        for i in \"!?\\',;.\":\\n            paragraph = paragraph.replace(i, \" \")\\n            \\n        dict1 = Counter([i for i in paragraph.lower().split()])\\n        \\n        ans = sorted(dict1, key = dict1.get, reverse = True)\\n        \\n        for i in ans:\\n            if i not in banned:\\n                return i",
                "codeTag": "Python3"
            },
            {
                "id": 2167485,
                "title": "c-runtime-o-n-space-o-n-commented-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    // Overall - Runtime Complexity: O(n)  Space Complexity O(n)\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        // Construct string to store parsed substring from paragraph\\n        string s = \"\";\\n        \\n        // Construct unordered map to store word counts\\n        unordered_map<string, int> um;\\n        \\n        // Iterate over characters in paragraph\\n        for(int i = 0; i < paragraph.size(); i++) {\\n            // Check if delimeter is found or at last character in paragraph\\n            if(!isalpha(paragraph[i]) || i == paragraph.size() - 1) {\\n                // Check for edge case of last character in paragraph\\n                if(i == paragraph.size() - 1 && isalpha(paragraph[i]))\\n                    s += tolower(paragraph[i]);\\n                \\n                // If current string is not empty update map & reset string\\n                if(!s.empty()) { \\n                    um[s]++;\\n                    s = \"\";\\n                }\\n            } else {\\n                // Append lower-case of current character to word string\\n                s += tolower(paragraph[i]);\\n            }\\n        }\\n        \\n        // Iterate over banned words\\n        for(const auto &it : banned) {\\n            // Check if banned word exists in map\\n            auto ret = um.find(it);\\n            \\n            // If banned word exists, delete\\n            if(ret != um.end())\\n                um.erase(ret->first);\\n        }\\n        \\n        // Return key in map which contains max value\\n        return max_element(um.begin(), um.end(),\\n                          [](const auto &p1, const auto &p2) {\\n                              return p1.second < p2.second;\\n                          })->first;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Overall - Runtime Complexity: O(n)  Space Complexity O(n)\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        // Construct string to store parsed substring from paragraph\\n        string s = \"\";\\n        \\n        // Construct unordered map to store word counts\\n        unordered_map<string, int> um;\\n        \\n        // Iterate over characters in paragraph\\n        for(int i = 0; i < paragraph.size(); i++) {\\n            // Check if delimeter is found or at last character in paragraph\\n            if(!isalpha(paragraph[i]) || i == paragraph.size() - 1) {\\n                // Check for edge case of last character in paragraph\\n                if(i == paragraph.size() - 1 && isalpha(paragraph[i]))\\n                    s += tolower(paragraph[i]);\\n                \\n                // If current string is not empty update map & reset string\\n                if(!s.empty()) { \\n                    um[s]++;\\n                    s = \"\";\\n                }\\n            } else {\\n                // Append lower-case of current character to word string\\n                s += tolower(paragraph[i]);\\n            }\\n        }\\n        \\n        // Iterate over banned words\\n        for(const auto &it : banned) {\\n            // Check if banned word exists in map\\n            auto ret = um.find(it);\\n            \\n            // If banned word exists, delete\\n            if(ret != um.end())\\n                um.erase(ret->first);\\n        }\\n        \\n        // Return key in map which contains max value\\n        return max_element(um.begin(), um.end(),\\n                          [](const auto &p1, const auto &p2) {\\n                              return p1.second < p2.second;\\n                          })->first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115613,
                "title": "easy-python-faster-than-83",
                "content": "```\\nclass Solution:\\n   \\n   def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        #remove all special chars\\n\\t\\tfor c in \"!?\\',;.\": paragraph = paragraph.replace(c, \" \")\\n        \\n\\t\\t#create a set of banned words for easy lookup\\n\\t\\tbannedSet = set(banned)\\n        lookup ={}\\n\\t\\t\\n        maxcount  = 0\\n        maxWord = \"\"\\n        for word in paragraph.lower().split():\\n            if word not in bannedSet:\\n                lookup[word] = lookup.get(word,0)+1\\n                if lookup[word] >maxcount:\\n                    maxcount = lookup[word]\\n                    maxWord = word\\n        return maxWord\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n   \\n   def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        #remove all special chars\\n\\t\\tfor c in \"!?\\',;.\": paragraph = paragraph.replace(c, \" \")\\n        \\n\\t\\t#create a set of banned words for easy lookup\\n\\t\\tbannedSet = set(banned)\\n        lookup ={}\\n\\t\\t\\n        maxcount  = 0\\n        maxWord = \"\"\\n        for word in paragraph.lower().split():\\n            if word not in bannedSet:\\n                lookup[word] = lookup.get(word,0)+1\\n                if lookup[word] >maxcount:\\n                    maxcount = lookup[word]\\n                    maxWord = word\\n        return maxWord\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063672,
                "title": "simple-python-solution-o-n",
                "content": "```py\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        paragraph = paragraph.lower()\\n        for i in list(\"!?\\',;.\"):\\n            paragraph = paragraph.replace(i, \" \")\\n        result = []\\n        for i in paragraph.split():\\n            if i not in banned: result.append(i)\\n        return Counter(result).most_common()[0][0]\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        paragraph = paragraph.lower()\\n        for i in list(\"!?\\',;.\"):\\n            paragraph = paragraph.replace(i, \" \")\\n        result = []\\n        for i in paragraph.split():\\n            if i not in banned: result.append(i)\\n        return Counter(result).most_common()[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2002854,
                "title": "java-hasmap-hashset",
                "content": "```\\n\\t\\t\\tHashMap<String,Integer> map = new HashMap<>();\\n            \\n            String []words = paragraph.toLowerCase().split(\"\\\\\\\\W+\");\\n            \\n            for(String str:words){\\n                        map.put(str,map.getOrDefault(str,0)+1);                            \\n            }\\n            \\n            HashSet<String> set = new HashSet<>();\\n            for(String str:banned){\\n                    set.add(str);\\n            }\\n            \\n            \\n            int max = 0;\\n            String ans=\"\";\\n            \\n            for(String key : map.keySet()){\\n                    if(!set.contains(key)){\\n                            int freq = map.get(key);\\n                            if(max < freq){\\n                                    max = freq;\\n                                    ans = key;\\n                            }\\n                    }\\n            }\\n            \\n            return ans;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\t\\tHashMap<String,Integer> map = new HashMap<>();\\n            \\n            String []words = paragraph.toLowerCase().split(\"\\\\\\\\W+\");\\n            \\n            for(String str:words){\\n                        map.put(str,map.getOrDefault(str,0)+1);                            \\n            }\\n            \\n            HashSet<String> set = new HashSet<>();\\n            for(String str:banned){\\n                    set.add(str);\\n            }\\n            \\n            \\n            int max = 0;\\n            String ans=\"\";\\n            \\n            for(String key : map.keySet()){\\n                    if(!set.contains(key)){\\n                            int freq = map.get(key);\\n                            if(max < freq){\\n                                    max = freq;\\n                                    ans = key;\\n                            }\\n                    }\\n            }\\n            \\n            return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1949844,
                "title": "c-explained-code-very-simple-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n    //creating an unordered map to store banned string\\n            unordered_map<string,int>ban;\\n            \\n            for(int i = 0; i < banned.size(); i++)\\n            {\\n                    ban[banned[i]]++;\\n            }\\n        //declaring a max freq count to store frequency     \\n\\t\\t\\n            int max_freq = 0;\\n            string ans = \"\";\\n\\t\\t\\t\\n\\t\\t\\t//another map for storing ans string\\n\\t\\t\\t\\n            unordered_map<string,int>mp;\\n             for(int i = 0; i < paragraph.length(); i++)\\n             {\\n                     string word = \"\";\\n\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t //running loop till pragraph length and only pushing alphabets excluding special symbols\\n\\t\\t\\t\\t\\t \\n                     while(i < paragraph.length() && isalpha(paragraph[i]))\\n                     {\\n\\t\\t\\t\\t\\t        // converting all upercase letter to lowercase letter\\n\\t\\t\\t\\t\\t\\t\\t\\n                             paragraph[i] = tolower(paragraph[i]);\\n                             word.push_back(paragraph[i]);\\n                             i++;\\n                     }\\n\\t\\t\\t\\t\\t //checking condition that banned string is not present in word and word is not an empty string\\n                     if(ban.find(word) == ban.end() && word != \"\")\\n                     {\\n                             mp[word]++;\\n                     \\n                     if(max_freq < mp[word])\\n                     {\\n\\t\\t\\t\\t\\t \\n                             max_freq = mp[word];\\n                             ans = word;\\n                     }\\n             }\\n             }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n    //creating an unordered map to store banned string\\n            unordered_map<string,int>ban;\\n            \\n            for(int i = 0; i < banned.size(); i++)\\n            {\\n                    ban[banned[i]]++;\\n            }\\n        //declaring a max freq count to store frequency     \\n\\t\\t\\n            int max_freq = 0;\\n            string ans = \"\";\\n\\t\\t\\t\\n\\t\\t\\t//another map for storing ans string\\n\\t\\t\\t\\n            unordered_map<string,int>mp;\\n             for(int i = 0; i < paragraph.length(); i++)\\n             {\\n                     string word = \"\";\\n\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t //running loop till pragraph length and only pushing alphabets excluding special symbols\\n\\t\\t\\t\\t\\t \\n                     while(i < paragraph.length() && isalpha(paragraph[i]))\\n                     {\\n\\t\\t\\t\\t\\t        // converting all upercase letter to lowercase letter\\n\\t\\t\\t\\t\\t\\t\\t\\n                             paragraph[i] = tolower(paragraph[i]);\\n                             word.push_back(paragraph[i]);\\n                             i++;\\n                     }\\n\\t\\t\\t\\t\\t //checking condition that banned string is not present in word and word is not an empty string\\n                     if(ban.find(word) == ban.end() && word != \"\")\\n                     {\\n                             mp[word]++;\\n                     \\n                     if(max_freq < mp[word])\\n                     {\\n\\t\\t\\t\\t\\t \\n                             max_freq = mp[word];\\n                             ans = word;\\n                     }\\n             }\\n             }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1916788,
                "title": "python3-very-easy-yet-very-fast",
                "content": "***Runtime: 30 ms, faster than 99.86% of Python3 online submissions for Most Common Word.\\nMemory Usage: 13.9 MB, less than 40.82% of Python3 online submissions for Most Common Word.***\\n.\\n\\n**If you like this solution please upvote** \\u2714\\uD83D\\uDE80\\uD83D\\uDC96\\n```\\nclass Solution:\\n    def mostCommonWord(self, para: str, banned: List[str]) -> str:\\n        \\n        p = []\\n        s = \\'\\'\\n\\t\\tbanned = set(banned)\\n        rem = {\"!\",\"?\",\"\\'\",\",\",\";\",\".\",\" \"}\\n        freq = {}\\n        \\n        for c in para:\\n            if c in rem:\\n                if s: p.append(s)\\n                s = \\'\\'\\n                continue\\n            \\n            if c.isupper(): s += c.lower()\\n            else: s += c\\n        \\n        if s: p.append(s)\\n        maxfreq, maxword = 0, \\'\\'\\n        \\n        for w in p:\\n            \\n            if w in banned: continue\\n            if w not in freq: freq[w] = 0\\n                \\n            freq[w] += 1\\n            if freq[w] > maxfreq:\\n                maxfreq = freq[w]\\n                maxword = w\\n                \\n        return maxword\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostCommonWord(self, para: str, banned: List[str]) -> str:\\n        \\n        p = []\\n        s = \\'\\'\\n\\t\\tbanned = set(banned)\\n        rem = {\"!\",\"?\",\"\\'\",\",\",\";\",\".\",\" \"}\\n        freq = {}\\n        \\n        for c in para:\\n            if c in rem:\\n                if s: p.append(s)\\n                s = \\'\\'\\n                continue\\n            \\n            if c.isupper(): s += c.lower()\\n            else: s += c\\n        \\n        if s: p.append(s)\\n        maxfreq, maxword = 0, \\'\\'\\n        \\n        for w in p:\\n            \\n            if w in banned: continue\\n            if w not in freq: freq[w] = 0\\n                \\n            freq[w] += 1\\n            if freq[w] > maxfreq:\\n                maxfreq = freq[w]\\n                maxword = w\\n                \\n        return maxword\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900967,
                "title": "c",
                "content": "public string MostCommonWord(string paragraph, string[] banned) {\\n        \\n        char[] symbols = \"!?\\',;. \".ToArray();\\n        string[] piece = paragraph.ToLower().Split(symbols, StringSplitOptions.RemoveEmptyEntries);\\n\\n        return piece.GroupBy(x => x).Where(x => banned.Contains(x.Key) == false).OrderByDescending(x => x.Count()).First().Key;\\n    }",
                "solutionTags": [],
                "code": "public string MostCommonWord(string paragraph, string[] banned) {\\n        \\n        char[] symbols = \"!?\\',;. \".ToArray();\\n        string[] piece = paragraph.ToLower().Split(symbols, StringSplitOptions.RemoveEmptyEntries);\\n\\n        return piece.GroupBy(x => x).Where(x => banned.Contains(x.Key) == false).OrderByDescending(x => x.Count()).First().Key;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1838953,
                "title": "easiest-java-solution-beginner-level-o-m-n",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> set = new HashSet<>();\\n        for(String s : banned) {\\n            set.add(s); \\n        }\\n        \\n        Map<String, Integer> map = new HashMap<>();\\n        String[] strs = paragraph.toLowerCase().split(\"\\\\\\\\W+\");\\n        int max = 0;\\n        String res = \"\";\\n\\n        for(String str : strs) {\\n            if(!set.contains(str)) {\\n                map.put(str, map.getOrDefault(str, 0) + 1);\\n            }\\n        }\\n        \\n        for(String key : map.keySet()) {\\n            if(map.get(key) > max) {\\n                max = map.get(key);\\n                res = key;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        Set<String> set = new HashSet<>();\\n        for(String s : banned) {\\n            set.add(s); \\n        }\\n        \\n        Map<String, Integer> map = new HashMap<>();\\n        String[] strs = paragraph.toLowerCase().split(\"\\\\\\\\W+\");\\n        int max = 0;\\n        String res = \"\";\\n\\n        for(String str : strs) {\\n            if(!set.contains(str)) {\\n                map.put(str, map.getOrDefault(str, 0) + 1);\\n            }\\n        }\\n        \\n        for(String key : map.keySet()) {\\n            if(map.get(key) > max) {\\n                max = map.get(key);\\n                res = key;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834826,
                "title": "c-easiest-solution-ever-few-lines-of-code",
                "content": "# Easy check it ;-)\\n[**@iprincekumark**](https://leetcode.com/iprincekumark/)\\n[```\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        \\n        unordered_map<string, int> ban;\\n        for(int i=0; i<banned.size(); i++)\\n            ban[banned[i]]++;\\n        \\n        int max_freq=0;\\n        string ans=\"\";\\n        unordered_map<string, int> mp;\\n        \\n        for(int i=0; i<paragraph.length(); i++) {\\n            string word=\"\";\\n            while(i<paragraph.length() && isalpha(paragraph[i])) {\\n                paragraph[i] = tolower(paragraph[i]);\\n                word.push_back(paragraph[i]);\\n                i++;\\n            }\\n      \\n            if(ban.find(word) == ban.end() && word!=\"\") {\\n                mp[word]++;\\n                if(max_freq<mp[word]) {\\n                    max_freq = mp[word];\\n                    ans = word;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```](https://leetcode.com/iprincekumark/)",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        \\n        unordered_map<string, int> ban;\\n        for(int i=0; i<banned.size(); i++)\\n            ban[banned[i]]++;\\n        \\n        int max_freq=0;\\n        string ans=\"\";\\n        unordered_map<string, int> mp;\\n        \\n        for(int i=0; i<paragraph.length(); i++) {\\n            string word=\"\";\\n            while(i<paragraph.length() && isalpha(paragraph[i])) {\\n                paragraph[i] = tolower(paragraph[i]);\\n                word.push_back(paragraph[i]);\\n                i++;\\n            }\\n      \\n            if(ban.find(word) == ban.end() && word!=\"\") {\\n                mp[word]++;\\n                if(max_freq<mp[word]) {\\n                    max_freq = mp[word];\\n                    ans = word;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1761144,
                "title": "easy-c-solution-0-ms-space-less-than-96",
                "content": "Please upvote the code if you like the content. It is always a great motivation :)\\n\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) \\n    {\\n        unordered_map<string, int> m;\\n        string s = \"\";\\n        int freq = 0;\\n        \\n        for(int i=0; i<paragraph.length(); i++)\\n        {\\n            if((paragraph[i] >= \\'a\\' and paragraph[i] <= \\'z\\') or (paragraph[i] >= \\'A\\' and paragraph[i] <= \\'Z\\'))\\n            {\\n                s += tolower(paragraph[i]);\\n            }\\n            \\n            else\\n            {\\n                m[s]++;\\n                s = \"\";\\n            }\\n        }\\n        \\n        m[s]++;\\n        \\n        for(auto i: banned)\\n            m[i] = 0;\\n        \\n        for(auto i: m)\\n        {\\n            if(i.second >= freq and i.first != \"\")\\n            {\\n                freq = i.second;\\n                s = i.first;\\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) \\n    {\\n        unordered_map<string, int> m;\\n        string s = \"\";\\n        int freq = 0;\\n        \\n        for(int i=0; i<paragraph.length(); i++)\\n        {\\n            if((paragraph[i] >= \\'a\\' and paragraph[i] <= \\'z\\') or (paragraph[i] >= \\'A\\' and paragraph[i] <= \\'Z\\'))\\n            {\\n                s += tolower(paragraph[i]);\\n            }\\n            \\n            else\\n            {\\n                m[s]++;\\n                s = \"\";\\n            }\\n        }\\n        \\n        m[s]++;\\n        \\n        for(auto i: banned)\\n            m[i] = 0;\\n        \\n        for(auto i: m)\\n        {\\n            if(i.second >= freq and i.first != \"\")\\n            {\\n                freq = i.second;\\n                s = i.first;\\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734159,
                "title": "java-simple",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) \\n    {\\n        \\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \" \").toLowerCase();\\n        HashMap<String,Integer> map = new HashMap<>();\\n        \\n        Set<String> bannedWords = new HashSet();\\n        \\n        for(String word:banned)\\n            bannedWords.add(word);\\n\\n        int max=0;\\n        String ret=\"\";\\n\\n        for(String word:paragraph.split(\"\\\\\\\\s+\"))\\n        {\\n            if(bannedWords.contains(word))continue;\\n            \\n            map.put(word,map.getOrDefault(word,0)+1);\\n            \\n            if(map.get(word)>max)\\n            {\\n                max = map.get(word);\\n                ret = word;\\n            }            \\n        }\\n     \\n        return ret;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) \\n    {\\n        \\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \" \").toLowerCase();\\n        HashMap<String,Integer> map = new HashMap<>();\\n        \\n        Set<String> bannedWords = new HashSet();\\n        \\n        for(String word:banned)\\n            bannedWords.add(word);\\n\\n        int max=0;\\n        String ret=\"\";\\n\\n        for(String word:paragraph.split(\"\\\\\\\\s+\"))\\n        {\\n            if(bannedWords.contains(word))continue;\\n            \\n            map.put(word,map.getOrDefault(word,0)+1);\\n            \\n            if(map.get(word)>max)\\n            {\\n                max = map.get(word);\\n                ret = word;\\n            }            \\n        }\\n     \\n        return ret;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696983,
                "title": "c-linq-2-lines-no-orderby-o-n-solution",
                "content": ".NET 5 doesn\\'t have ExceptBy.\\n```\\npublic class Solution {\\n    public string MostCommonWord(string paragraph, string[] banned)\\n    {\\n        var bannedSet = banned.ToHashSet();\\n        return paragraph\\n                .ToLowerInvariant()\\n                .Split(new[] { \\' \\', \\'\"\\', \\'!\\', \\'?\\', \\'\\\\\\'\\', \\',\\', \\';\\', \\'.\\' }, StringSplitOptions.RemoveEmptyEntries)\\n                .Where(s => !bannedSet.Contains(s))\\n                .GroupBy(s => s, (s, g) => (word: s, count: g.Count()))\\n                .Aggregate((word: \"\", count: 0), (res, cur) => cur.count > res.count ? cur : res, res => res.word);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string MostCommonWord(string paragraph, string[] banned)\\n    {\\n        var bannedSet = banned.ToHashSet();\\n        return paragraph\\n                .ToLowerInvariant()\\n                .Split(new[] { \\' \\', \\'\"\\', \\'!\\', \\'?\\', \\'\\\\\\'\\', \\',\\', \\';\\', \\'.\\' }, StringSplitOptions.RemoveEmptyEntries)\\n                .Where(s => !bannedSet.Contains(s))\\n                .GroupBy(s => s, (s, g) => (word: s, count: g.Count()))\\n                .Aggregate((word: \"\", count: 0), (res, cur) => cur.count > res.count ? cur : res, res => res.word);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673124,
                "title": "python3-53ms-runtime-17-11-memory-14-3mb-47-52",
                "content": "```\\nimport re\\nfrom collections import Counter\\n\\ndef mostCommon(string, banned):\\n\\tstring = re.sub(r\"[^a-zA-Z]\", \" \", string).lower() # to remove every unwated symbols\\n\\tfreq = Counter(string.split())\\n\\tfor ban in banned:\\n\\t\\tif ban in freq:\\n\\t\\t\\tfreq.pop(ban)\\n\\t\\t\\t\\n\\treturn max(freq, key=freq.get)\\n```",
                "solutionTags": [],
                "code": "```\\nimport re\\nfrom collections import Counter\\n\\ndef mostCommon(string, banned):\\n\\tstring = re.sub(r\"[^a-zA-Z]\", \" \", string).lower() # to remove every unwated symbols\\n\\tfreq = Counter(string.split())\\n\\tfor ban in banned:\\n\\t\\tif ban in freq:\\n\\t\\t\\tfreq.pop(ban)\\n\\t\\t\\t\\n\\treturn max(freq, key=freq.get)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1624949,
                "title": "4ms-faster-than-87-c",
                "content": "class Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& banned) {\\n     \\n        unordered_set<string> st (banned.begin(), banned.end()); \\n        unordered_map<string,int> mp;\\n        \\n        for(int i=0; i<p.size(); i++) \\n        {\\n            string curr = \"\";\\n            \\n            while(i != p.size() && (p[i] >=\\'a\\' && p[i] <= \\'z\\' || p[i] >=\\'A\\' && p[i] <=\\'Z\\'))\\n            {\\n                curr += (char)tolower(p[i]); \\n                i++;\\n            }\\n            \\n            \\n            if(curr != \"\" && st.find(curr) == st.end()) \\n            mp[curr]++;\\n                \\n        } \\n        \\n        int count = 0;\\n        string res = \"\";\\n        \\n        for(auto it : mp)\\n        {\\n            if(it.second > count)\\n            {\\n                res = it.first;\\n                count = it.second;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string mostCommonWord(string p, vector<string>& banned) {\\n     \\n        unordered_set<string> st (banned.begin(), banned.end()); \\n        unordered_map<string,int> mp;\\n        \\n        for(int i=0; i<p.size(); i++) \\n        {\\n            string curr = \"\";\\n            \\n            while(i != p.size() && (p[i] >=\\'a\\' && p[i] <= \\'z\\' || p[i] >=\\'A\\' && p[i] <=\\'Z\\'))\\n            {\\n                curr += (char)tolower(p[i]); \\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1590573,
                "title": "c-easy-solution-with-explanation",
                "content": "Here the main idea is we take all words from paragraph and store it into a map with its frequency. Here I inserted only those words which are not in banned array.\\n\\nAlgorithm :\\n* we first take a unordered_set<string>ban, where I inserted all banned elements so that I can get them in O(1) complexity.\\n* Then take a unordered map of string as a key and integer as its value.\\n* Then run a loop on paragraph\\n\\t\\t* if current character is a uppercase letter then substract 32 in it to make it lowercase(since we need lowercase words).\\n\\t\\t* if current letter is a alphabet then add it to a temporary string.\\n\\t\\t* otherwise if that temp is not banned then increase frequency in map. Here I am also maintaining a maximum frequency variable.\\n\\n* Now traverse to map and if a words frequency equals to maxfrequency then return it.\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_set<string>ban;\\n        unordered_map<string,int>fre;\\n        for(int i=0;i<banned.size();i++)\\n            ban.insert(banned[i]);\\n        string temp=\"\";\\n        int maxfre=0;\\n        for(int i=0;i<paragraph.size();i++){\\n            if(paragraph[i]>64 && paragraph[i]<91)\\n                paragraph[i]+=32;\\n            \\n            if(paragraph[i]>96 && paragraph[i]<123)\\n                temp+=paragraph[i];\\n            else{\\n                if(!temp.empty() && ban.find(temp)==ban.end())\\n                {\\n                    fre[temp]++;\\n                    maxfre=max(maxfre,fre[temp]);\\n                }\\n                temp=\"\";\\n                continue;\\n            }\\n        }\\n        if(!temp.empty()){\\n            fre[temp]++;\\n            maxfre=max(maxfre,fre[temp]);\\n        }\\n        for(auto it=fre.begin();it!=fre.end();it++){\\n            if(it->second==maxfre)\\n                return it->first;\\n        }\\n        return \"\";\\n    }\\n};\\n```\\nIf this post is helpful for you then please upvote. Thank you.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_set<string>ban;\\n        unordered_map<string,int>fre;\\n        for(int i=0;i<banned.size();i++)\\n            ban.insert(banned[i]);\\n        string temp=\"\";\\n        int maxfre=0;\\n        for(int i=0;i<paragraph.size();i++){\\n            if(paragraph[i]>64 && paragraph[i]<91)\\n                paragraph[i]+=32;\\n            \\n            if(paragraph[i]>96 && paragraph[i]<123)\\n                temp+=paragraph[i];\\n            else{\\n                if(!temp.empty() && ban.find(temp)==ban.end())\\n                {\\n                    fre[temp]++;\\n                    maxfre=max(maxfre,fre[temp]);\\n                }\\n                temp=\"\";\\n                continue;\\n            }\\n        }\\n        if(!temp.empty()){\\n            fre[temp]++;\\n            maxfre=max(maxfre,fre[temp]);\\n        }\\n        for(auto it=fre.begin();it!=fre.end();it++){\\n            if(it->second==maxfre)\\n                return it->first;\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499269,
                "title": "java-streams",
                "content": "```\\n        List<String> ban = Arrays.asList(banned);\\n        paragraph=paragraph.replaceAll(\"[^A-Za-z ]\",\" \").toLowerCase();\\n        Map<String, Integer> result=Arrays.asList(paragraph.split(\" +\")).parallelStream().filter(str -> !ban.contains(str)).collect(Collectors.toConcurrentMap(w -> w, w -> 1, Integer::sum));\\n        String max=result.entrySet().stream().max(Map.Entry.comparingByValue()).get().getKey();\\n        return max;\\n```",
                "solutionTags": [],
                "code": "```\\n        List<String> ban = Arrays.asList(banned);\\n        paragraph=paragraph.replaceAll(\"[^A-Za-z ]\",\" \").toLowerCase();\\n        Map<String, Integer> result=Arrays.asList(paragraph.split(\" +\")).parallelStream().filter(str -> !ban.contains(str)).collect(Collectors.toConcurrentMap(w -> w, w -> 1, Integer::sum));\\n        String max=result.entrySet().stream().max(Map.Entry.comparingByValue()).get().getKey();\\n        return max;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1426981,
                "title": "solution-using-priorityqueue",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        \\n        Set<String> set = new HashSet<>();\\n        \\n        for(String s : banned){\\n            set.add(s);\\n        }\\n        \\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        String[] splitted = paragraph.split(\"[\\\\\\\\s,]+\");\\n        \\n        for(int i = 0; i < splitted.length ; i++){\\n            \\n            String current = splitted[i].toLowerCase().replaceAll(\"\\\\\\\\p{Punct}\",\"\");\\n            \\n            map.put(current, map.getOrDefault(current, 0)+1);\\n        }\\n\\t\\t\\n        PriorityQueue<String> pq = new PriorityQueue<>((a,b) -> map.get(b) - map.get(a));\\n        \\n        for(String s : map.keySet()){\\n            \\n            if(!set.contains(s)){\\n                pq.add(s);\\n            }\\n        }\\n\\n        return pq.poll();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        \\n        Set<String> set = new HashSet<>();\\n        \\n        for(String s : banned){\\n            set.add(s);\\n        }\\n        \\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        String[] splitted = paragraph.split(\"[\\\\\\\\s,]+\");\\n        \\n        for(int i = 0; i < splitted.length ; i++){\\n            \\n            String current = splitted[i].toLowerCase().replaceAll(\"\\\\\\\\p{Punct}\",\"\");\\n            \\n            map.put(current, map.getOrDefault(current, 0)+1);\\n        }\\n\\t\\t\\n        PriorityQueue<String> pq = new PriorityQueue<>((a,b) -> map.get(b) - map.get(a));\\n        \\n        for(String s : map.keySet()){\\n            \\n            if(!set.contains(s)){\\n                pq.add(s);\\n            }\\n        }\\n\\n        return pq.poll();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418114,
                "title": "easy-java-solution-hashmap-regex",
                "content": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        if(paragraph.length() == 0){\\n            return \"\";\\n        }\\n        HashMap<String,Integer> m = new HashMap<String,Integer>();\\n        String result = \"\";\\n        paragraph = paragraph.toLowerCase();\\n        String[] s = paragraph.split(\"[^a-z]+\");\\n        for(String a: s){\\n            if(!m.containsKey(a)){\\n                m.put(a,1);\\n            }else{\\n                m.put(a,m.get(a)+1);\\n            }\\n        }\\n        for(int i=0;i<banned.length;i++){\\n            if(m.containsKey(banned[i].toLowerCase())){\\n                m.remove(banned[i].toLowerCase());\\n            }\\n        }\\n        int maxValueInMap=(Collections.max(m.values())); \\n        for(Map.Entry<String,Integer> entry : m.entrySet()){\\n            if (entry.getValue()==maxValueInMap) {\\n                result = entry.getKey(); \\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        if(paragraph.length() == 0){\\n            return \"\";\\n        }\\n        HashMap<String,Integer> m = new HashMap<String,Integer>();\\n        String result = \"\";\\n        paragraph = paragraph.toLowerCase();\\n        String[] s = paragraph.split(\"[^a-z]+\");\\n        for(String a: s){\\n            if(!m.containsKey(a)){\\n                m.put(a,1);\\n            }else{\\n                m.put(a,m.get(a)+1);\\n            }\\n        }\\n        for(int i=0;i<banned.length;i++){\\n            if(m.containsKey(banned[i].toLowerCase())){\\n                m.remove(banned[i].toLowerCase());\\n            }\\n        }\\n        int maxValueInMap=(Collections.max(m.values())); \\n        for(Map.Entry<String,Integer> entry : m.entrySet()){\\n            if (entry.getValue()==maxValueInMap) {\\n                result = entry.getKey(); \\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1413128,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map<string,int> ans;\\n        string ban;\\n        for(auto c:banned){\\n            ban+=c;ban+=\\' \\';\\n        }\\n        for(auto &c : paragraph)\\n            c =  isalpha(c)? tolower(c) : \\' \\'; \\n        stringstream ss(paragraph);\\n        string word;\\n        while(ss>>word)\\n        {ans[word]++;\\n        }\\n        int m=0;string a;\\n        for(auto i:ans){\\n            cout<<i.first<<\"- \"<<i.second<<\"\\\\n\";\\n            if(i.second>m && ban.find(i.first)==string::npos)\\n            { m=i.second;a=i.first;}\\n        }\\n        return a;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map<string,int> ans;\\n        string ban;\\n        for(auto c:banned){\\n            ban+=c;ban+=\\' \\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1412891,
                "title": "c-regex-std-transform",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        \\n        if(paragraph.empty())return \"\";\\n        \\n        //put it in a set, so that searching a word could be optimized\\n        //first should be to replace the punctutaions and onvert into lower case\\n        \\n        //use std::transform to convert the entire string to lower or upper string\\n        \\n        std::transform(paragraph.begin(), paragraph.end(), paragraph.begin(), ::tolower);\\n    \\n        regex re(\"[^A-Za-z0-9]\");\\n        paragraph = regex_replace(paragraph, re, \" \");\\n        \\n        cout<<paragraph;\\n        \\n        unordered_set<string> banSet;\\n        \\n        for(auto s : banned)\\n        {\\n            banSet.insert(s);\\n        }\\n        \\n        //make the frequency map using unordered_map in c++\\n        \\n        unordered_map<string, int> freqMap;\\n        \\n        //use istringstream to split the words in the string\\n        \\n        istringstream ss(paragraph);\\n        \\n        string word;\\n        \\n        while(ss >> word)\\n        {   \\n            if(banSet.find(word) == banSet.end())\\n            {\\n                freqMap[word]++;\\n            }\\n        }\\n        \\n        int max = 0;\\n        string maxString;\\n        \\n        for(auto f : freqMap)\\n        {\\n            if(f.second > max){max = f.second; maxString = f.first;}\\n        }\\n        \\n        return maxString;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        \\n        if(paragraph.empty())return \"\";\\n        \\n        //put it in a set, so that searching a word could be optimized\\n        //first should be to replace the punctutaions and onvert into lower case\\n        \\n        //use std::transform to convert the entire string to lower or upper string\\n        \\n        std::transform(paragraph.begin(), paragraph.end(), paragraph.begin(), ::tolower);\\n    \\n        regex re(\"[^A-Za-z0-9]\");\\n        paragraph = regex_replace(paragraph, re, \" \");\\n        \\n        cout<<paragraph;\\n        \\n        unordered_set<string> banSet;\\n        \\n        for(auto s : banned)\\n        {\\n            banSet.insert(s);\\n        }\\n        \\n        //make the frequency map using unordered_map in c++\\n        \\n        unordered_map<string, int> freqMap;\\n        \\n        //use istringstream to split the words in the string\\n        \\n        istringstream ss(paragraph);\\n        \\n        string word;\\n        \\n        while(ss >> word)\\n        {   \\n            if(banSet.find(word) == banSet.end())\\n            {\\n                freqMap[word]++;\\n            }\\n        }\\n        \\n        int max = 0;\\n        string maxString;\\n        \\n        for(auto f : freqMap)\\n        {\\n            if(f.second > max){max = f.second; maxString = f.first;}\\n        }\\n        \\n        return maxString;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1376398,
                "title": "golang-runtime-beats-100",
                "content": "```\\nfunc mostCommonWord(para string, banned []string) string {\\n    \\n    // create a map of banned words\\n    bannedStrings := make(map[string]int)\\n    for _, val := range banned {\\n        bannedStrings[val] = 1\\n    }\\n    \\n    mostCommonWord := \"\"\\n    mostCommonWordFreq := 0\\n    \\n    var sb strings.Builder\\n    words := make(map[string]int)\\n    for i, val := range para {\\n        if unicode.IsLetter(val) {\\n            sb.WriteRune(unicode.ToLower(val))\\n            if i != len(para) - 1 {\\n                continue\\n            }\\n        }\\n    \\n        // Found a word!\\n        w := sb.String()\\n        if w == \"\" {\\n            continue\\n        }\\n        // Reset string builder\\n        sb.Reset()\\n        \\n        // For each word found in para, check of it is present in the banned word, if yes, continue\\n        _, ok := bannedStrings[w]\\n        if ok {\\n            continue\\n        }\\n        \\n        // Add the word, if present update the frequnecy\\n        _, ok = words[w]\\n        if ok {\\n            words[w] += 1\\n        } else {\\n            words[w] = 1\\n        }\\n        \\n        // Update the answer if required\\n         if (words[w] > mostCommonWordFreq) {\\n            mostCommonWordFreq = words[w]\\n            mostCommonWord = w\\n         }\\n        \\n    }\\n    \\n    return mostCommonWord\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc mostCommonWord(para string, banned []string) string {\\n    \\n    // create a map of banned words\\n    bannedStrings := make(map[string]int)\\n    for _, val := range banned {\\n        bannedStrings[val] = 1\\n    }\\n    \\n    mostCommonWord := \"\"\\n    mostCommonWordFreq := 0\\n    \\n    var sb strings.Builder\\n    words := make(map[string]int)\\n    for i, val := range para {\\n        if unicode.IsLetter(val) {\\n            sb.WriteRune(unicode.ToLower(val))\\n            if i != len(para) - 1 {\\n                continue\\n            }\\n        }\\n    \\n        // Found a word!\\n        w := sb.String()\\n        if w == \"\" {\\n            continue\\n        }\\n        // Reset string builder\\n        sb.Reset()\\n        \\n        // For each word found in para, check of it is present in the banned word, if yes, continue\\n        _, ok := bannedStrings[w]\\n        if ok {\\n            continue\\n        }\\n        \\n        // Add the word, if present update the frequnecy\\n        _, ok = words[w]\\n        if ok {\\n            words[w] += 1\\n        } else {\\n            words[w] = 1\\n        }\\n        \\n        // Update the answer if required\\n         if (words[w] > mostCommonWordFreq) {\\n            mostCommonWordFreq = words[w]\\n            mostCommonWord = w\\n         }\\n        \\n    }\\n    \\n    return mostCommonWord\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1375849,
                "title": "c-1ms-runtime",
                "content": "string mostCommonWord(string para, vector<string>& banned) {\\n        para.push_back(\\' \\');\\n        string ans = \"\";\\n        int maxVal = 0;\\n        int len = para.length();\\n        unordered_map<string,int> map;\\n        string temp =\"\";\\n        \\n        for(int i=0; i<len; i++)\\n        {    \\n           if(para[i] >= \\'A\\' && para[i] <=\\'Z\\')  \\n           {\\n               temp.push_back(para[i]+32);\\n           }\\n           else if(para[i] >= \\'a\\' && para[i] <= \\'z\\')\\n           {\\n               temp.push_back(para[i]) ;\\n           }\\n           else{\\n                if(temp.empty()) \\n                continue;\\n                map[temp]++;\\n                temp.clear();\\n           }    \\n        }\\n        \\n        for(int i=0;i<size(banned);i++)\\n            map[banned[i]]=0; \\n       \\n        for(auto [key,value] : map)\\n           if(value>=maxVal)\\n            {\\n                maxVal = value;\\n                ans = key;\\n            }\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "string mostCommonWord(string para, vector<string>& banned) {\\n        para.push_back(\\' \\');\\n        string ans = \"\";\\n        int maxVal = 0;\\n        int len = para.length();\\n        unordered_map<string,int> map;\\n        string temp =\"\";\\n        \\n        for(int i=0; i<len; i++)\\n        {    \\n           if(para[i] >= \\'A\\' && para[i] <=\\'Z\\')  \\n           {\\n               temp.push_back(para[i]+32);\\n           }\\n           else if(para[i] >= \\'a\\' && para[i] <= \\'z\\')\\n           {\\n               temp.push_back(para[i]) ;\\n           }\\n           else{\\n                if(temp.empty()) \\n                continue;\\n                map[temp]++;\\n                temp.clear();\\n           }    \\n        }\\n        \\n        for(int i=0;i<size(banned);i++)\\n            map[banned[i]]=0; \\n       \\n        for(auto [key,value] : map)\\n           if(value>=maxVal)\\n            {\\n                maxVal = value;\\n                ans = key;\\n            }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1374287,
                "title": "c-4ms-runtime-modified-from-c-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string para, vector<string>& ban) {\\n        unordered_map<string,int>mp;\\n        int i=0;\\n        while(i<para.size())\\n        {\\n            string strg=\"\";\\n            while(i<para.size() && isalpha(para[i])){\\n                strg.push_back(tolower(para[i]));\\n                i++;\\n            }\\n            \\n            while(i<para.size() && !isalpha(para[i])) {i++;}\\n                mp[strg]+=1;\\n        }\\n                  \\n       for(auto x:ban){mp[x]=0;}\\n       int cnt=0;\\n      string res; \\n    for(auto it:mp){\\n        if(it.second>cnt){\\n            res=it.first;\\n            cnt=it.second;\\n        }\\n    }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string para, vector<string>& ban) {\\n        unordered_map<string,int>mp;\\n        int i=0;\\n        while(i<para.size())\\n        {\\n            string strg=\"\";\\n            while(i<para.size() && isalpha(para[i])){\\n                strg.push_back(tolower(para[i]));\\n                i++;\\n            }\\n            \\n            while(i<para.size() && !isalpha(para[i])) {i++;}\\n                mp[strg]+=1;\\n        }\\n                  \\n       for(auto x:ban){mp[x]=0;}\\n       int cnt=0;\\n      string res; \\n    for(auto it:mp){\\n        if(it.second>cnt){\\n            res=it.first;\\n            cnt=it.second;\\n        }\\n    }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372545,
                "title": "c-solution-nested-stringstream-split-string-using-multiple-delimiters",
                "content": "1. First (outer) stringstream is used for spliting the string at \\' \\' (space).\\n2. Second (inner) stringstream is used for splitting the string at \\',\\'(comma).\\n\\t\\n\\t\\tstring mostCommonWord(string paragraph, vector<string>& banned) {\\n\\n\\t\\t\\t//transform every banned string to lower case\\n\\t\\t\\tfor(auto &word: banned){\\n\\t\\t\\t\\ttransform(word.begin(), word.end(), word.begin(), ::tolower);\\n\\t\\t\\t}\\n\\n\\t\\t\\tunordered_set<string> ban(banned.begin(), banned.end());\\n\\t\\t\\t//the outer stringstream\\n\\t\\t\\tstringstream ss(paragraph);\\n\\t\\t\\tstring temp;\\n\\t\\t\\tstring ans;\\n\\t\\t\\t//to keep track of unbanned strings\\n\\t\\t\\tunordered_map<string, int> mp;\\n\\t\\t\\tint maxFreq = 0;\\n\\n\\t\\t\\twhile(getline(ss, temp, \\' \\')){\\n\\n\\t\\t\\t\\tstringstream ss1(temp);\\n\\t\\t\\t\\tstring word;\\n\\n\\t\\t\\t\\t//inner stringstream\\n\\t\\t\\t\\twhile(getline(ss1, word, \\',\\')){\\n\\t\\t\\t\\t\\tint n = word.length();\\n\\n\\t\\t\\t\\t\\tif(n == 0){\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tint i;\\n\\t\\t\\t\\t\\t//remove the non alphabetical characters from the end of the string(word).\\n\\t\\t\\t\\t\\tfor(i=n-1; i>=0; i--){\\n\\t\\t\\t\\t\\t\\tif(isalpha(word[i])){\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tword = word.substr(0,i+1);\\n\\t\\t\\t\\t\\ttransform(word.begin(), word.end(), word.begin(), ::tolower);\\n\\t\\t\\t\\t\\t//now is the word is not banned then increase its frequency and accordingly update the answer.\\n\\t\\t\\t\\t\\tif(ban.find(word) == ban.end()){\\n\\t\\t\\t\\t\\t\\tmp[word]++;\\n\\n\\t\\t\\t\\t\\t\\tif(mp[word] > maxFreq){\\n\\t\\t\\t\\t\\t\\t\\tans = word;\\n\\t\\t\\t\\t\\t\\t\\tmaxFreq = mp[word];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "1. First (outer) stringstream is used for spliting the string at \\' \\' (space).\\n2. Second (inner) stringstream is used for splitting the string at \\',\\'(comma).\\n\\t\\n\\t\\tstring mostCommonWord(string paragraph, vector<string>& banned) {\\n\\n\\t\\t\\t//transform every banned string to lower case\\n\\t\\t\\tfor(auto &word: banned){\\n\\t\\t\\t\\ttransform(word.begin(), word.end(), word.begin(), ::tolower);\\n\\t\\t\\t}\\n\\n\\t\\t\\tunordered_set<string> ban(banned.begin(), banned.end());\\n\\t\\t\\t//the outer stringstream\\n\\t\\t\\tstringstream ss(paragraph);\\n\\t\\t\\tstring temp;\\n\\t\\t\\tstring ans;\\n\\t\\t\\t//to keep track of unbanned strings\\n\\t\\t\\tunordered_map<string, int> mp;\\n\\t\\t\\tint maxFreq = 0;\\n\\n\\t\\t\\twhile(getline(ss, temp, \\' \\')){\\n\\n\\t\\t\\t\\tstringstream ss1(temp);\\n\\t\\t\\t\\tstring word;\\n\\n\\t\\t\\t\\t//inner stringstream\\n\\t\\t\\t\\twhile(getline(ss1, word, \\',\\')){\\n\\t\\t\\t\\t\\tint n = word.length();\\n\\n\\t\\t\\t\\t\\tif(n == 0){\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tint i;\\n\\t\\t\\t\\t\\t//remove the non alphabetical characters from the end of the string(word).\\n\\t\\t\\t\\t\\tfor(i=n-1; i>=0; i--){\\n\\t\\t\\t\\t\\t\\tif(isalpha(word[i])){\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tword = word.substr(0,i+1);\\n\\t\\t\\t\\t\\ttransform(word.begin(), word.end(), word.begin(), ::tolower);\\n\\t\\t\\t\\t\\t//now is the word is not banned then increase its frequency and accordingly update the answer.\\n\\t\\t\\t\\t\\tif(ban.find(word) == ban.end()){\\n\\t\\t\\t\\t\\t\\tmp[word]++;\\n\\n\\t\\t\\t\\t\\t\\tif(mp[word] > maxFreq){\\n\\t\\t\\t\\t\\t\\t\\tans = word;\\n\\t\\t\\t\\t\\t\\t\\tmaxFreq = mp[word];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1363990,
                "title": "ugly-but-100-faster-solution-c",
                "content": "class Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map<string, int> m;\\n        string tmp = \"\";\\n        vector<string> tmpV;\\n        \\n        int maxfreq = 0;\\n        string mostfreq;\\n\\n        for(int i = 0; i < paragraph.length(); ++i) {\\n            char c = paragraph[i];\\n            \\n            if((c == \\' \\' || c == \\'!\\' || \\n               c == \\';\\' || c == \\',\\' ||\\n               c == \\'.\\' || c == \\'?\\' || (c == \\'\\\\\\'\\' && paragraph[i+1] == \\' \\'))) {\\n                if(tmp.length() > 0) {\\n                    m[tmp]++;\\n                    tmpV.push_back(tmp);\\n                    tmp = \"\";\\n                }\\n            }\\n            \\n            else if(i == paragraph.length() - 1) {\\n                if(tmp.length() > 0) {\\n                    tmp += tolower(c);\\n                    m[tmp]++;\\n                    tmpV.push_back(tmp);\\n                    tmp = \"\";\\n                }\\n            }\\n            \\n            else tmp += tolower(c);\\n        }\\n        \\n        for(string s : banned) {\\n            m.erase(s);\\n        }\\n        \\n        for(string s : tmpV) {\\n            cout << s << \" \";\\n            \\n            if(m[s] > maxfreq) {\\n                maxfreq = m[s];\\n                mostfreq = s;\\n            }\\n        }\\n    \\n        return mostfreq;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_map<string, int> m;\\n        string tmp = \"\";\\n        vector<string> tmpV;\\n        \\n        int maxfreq = 0;\\n        string mostfreq;\\n\\n        for(int i = 0; i < paragraph.length(); ++i) {\\n            char c = paragraph[i];\\n            \\n            if((c == \\' \\' || c == \\'!\\' || \\n               c == \\';\\' || c == \\',\\' ||\\n               c == \\'.\\' || c == \\'?\\' || (c == \\'\\\\\\'\\' && paragraph[i+1] == \\' \\'))) {\\n                if(tmp.length() > 0) {\\n                    m[tmp]++;\\n                    tmpV.push_back(tmp);\\n                    tmp = \"\";\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1316398,
                "title": "clean-c",
                "content": "```\\nstring mostCommonWord(string para, vector<string>& banned) {\\n        unordered_set<string>set(begin(banned), end(banned));\\n        for (int i = 0; i < para.length(); i++)\\n            para[i] = isalpha(para[i]) ? tolower(para[i]) : \\' \\';\\n        stringstream ss(para);\\n        string str;\\n        unordered_map<string, int>u;\\n        while (ss >> str)\\n            if(!set.count(str))\\n                u[str]++;\\n        int freq = INT_MIN;\\n        for (auto c : u)\\n            if (c.second > freq)\\n                freq = c.second, str = c.first;\\n        return str;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring mostCommonWord(string para, vector<string>& banned) {\\n        unordered_set<string>set(begin(banned), end(banned));\\n        for (int i = 0; i < para.length(); i++)\\n            para[i] = isalpha(para[i]) ? tolower(para[i]) : \\' \\';\\n        stringstream ss(para);\\n        string str;\\n        unordered_map<string, int>u;\\n        while (ss >> str)\\n            if(!set.count(str))\\n                u[str]++;\\n        int freq = INT_MIN;\\n        for (auto c : u)\\n            if (c.second > freq)\\n                freq = c.second, str = c.first;\\n        return str;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1304732,
                "title": "c-easy-understandable",
                "content": "\\t//First add the string into hashmap and then remove those string which is banned and then find the maximum frequency string from map and then return\\n\\tclass Solution {\\n\\tpublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        transform(paragraph.begin(),paragraph.end(),paragraph.begin(),::tolower);\\n        unordered_map<string,int> freq;\\n        int l=INT_MIN;char ch=39;\\n        string str=\"\";\\n        for(int i=0;i<paragraph.size();i++)\\n        {\\n            if(paragraph[i]==\\' \\' || paragraph[i]==\\'.\\' || paragraph[i]==\\'!\\' || paragraph[i]==\\'?\\' || paragraph[i]==\\';\\' || paragraph[i]==\\',\\' || paragraph[i]==ch)\\n            {       \\n                if(str==\"\")continue;\\n                    if(freq.find(str)==freq.end())\\n                        freq[str]=1;\\n                    else\\n                        freq[str]++;\\n                str=\"\";\\n            }else\\n            str+=paragraph[i];\\n        }\\n        unordered_map<string,int>:: iterator it;\\n        for(int i=0;i<banned.size();i++){\\n            if(freq.find(banned[i])!=freq.end()){\\n             it=freq.find(banned[i]);\\n            freq.erase(it);\\n            }\\n        }\\n        it=freq.begin();\\n            while(it!=freq.end())\\n            {\\n                  if(it->second > l){\\n                      l=it->second;\\n                      str=it->first;\\n                  }\\n                 it++;\\n            }   \\n        return str;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        transform(paragraph.begin(),paragraph.end(),paragraph.begin(),::tolower);\\n        unordered_map<string,int> freq;\\n        int l=INT_MIN;char ch=39;\\n        string str=\"\";\\n        for(int i=0;i<paragraph.size();i++)\\n        {\\n            if(paragraph[i]==\\' \\' || paragraph[i]==\\'.\\' || paragraph[i]==\\'!\\' || paragraph[i]==\\'?\\' || paragraph[i]==\\';\\' || paragraph[i]==\\',\\' || paragraph[i]==ch)\\n            {       \\n                if(str==\"\")continue;\\n                    if(freq.find(str)==freq.end())\\n                        freq[str]=1;\\n                    else\\n                        freq[str]++;\\n                str=\"\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1301804,
                "title": "c-naive-approach-coicise-approach-with-comments",
                "content": "```\\n//Approach-1 : Naive approach\\nclass Solution {\\npublic:\\n    void skipSpace(string &paragraph, int& j, int& n) {\\n        while(paragraph[j] == \\' \\')\\n                j++;\\n    }\\n    \\n    void moveIndexTillValid(string &paragraph, int& j, int& n, string &temp) {\\n        while(j < n && (paragraph[j] >= \\'a\\' && paragraph[j] <= \\'z\\')) {\\n            temp.push_back(paragraph[j]);\\n            j++;\\n        }\\n    }\\n    \\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        transform(begin(paragraph), end(paragraph), begin(paragraph), ::tolower);\\n        \\n        unordered_set<string> st(begin(banned), end(banned));\\n        \\n        unordered_map<string, int> mp;\\n        \\n        int n = paragraph.length();\\n        int j;\\n        string temp = \"\";\\n        for(int i = 0; i<n;) {\\n            temp = \"\";\\n            j = i;\\n            \\n            skipSpace(paragraph, j, n);\\n            moveIndexTillValid(paragraph, j, n, temp);\\n            \\n            mp[temp]++;\\n            i = j+1;\\n        }\\n        \\n        string result = \"\";\\n        int maxFreq = 0;\\n        for(auto &it : mp) {\\n            if(st.find(it.first) != st.end()) //skip banned words\\n                continue;\\n            \\n            if(it.second > maxFreq) {\\n                result = it.first;\\n                maxFreq = it.second;\\n            }\\n            \\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n\\n```\\n//Approach-2 : Consice approach. (Inspired from @lee215)\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_set<string> st(begin(banned), end(banned));\\n        \\n        for(char &ch : paragraph) {\\n            ch = isalpha(ch) ? tolower(ch) : \\' \\';\\n        }\\n        unordered_map<string, int> mp;\\n        \\n        pair<string, int> result = {\"\", 0};\\n        \\n        istringstream ss(paragraph); //or use, \"stringstream\"\\n        string word;\\n        while(ss >> word) {\\n            if(st.find(word) == end(st)) {\\n                mp[word]++;\\n                if(mp[word] > result.second)\\n                    result = {word, mp[word]};\\n            }\\n        }\\n        \\n        return result.first;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 : Naive approach\\nclass Solution {\\npublic:\\n    void skipSpace(string &paragraph, int& j, int& n) {\\n        while(paragraph[j] == \\' \\')\\n                j++;\\n    }\\n    \\n    void moveIndexTillValid(string &paragraph, int& j, int& n, string &temp) {\\n        while(j < n && (paragraph[j] >= \\'a\\' && paragraph[j] <= \\'z\\')) {\\n            temp.push_back(paragraph[j]);\\n            j++;\\n        }\\n    }\\n    \\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        transform(begin(paragraph), end(paragraph), begin(paragraph), ::tolower);\\n        \\n        unordered_set<string> st(begin(banned), end(banned));\\n        \\n        unordered_map<string, int> mp;\\n        \\n        int n = paragraph.length();\\n        int j;\\n        string temp = \"\";\\n        for(int i = 0; i<n;) {\\n            temp = \"\";\\n            j = i;\\n            \\n            skipSpace(paragraph, j, n);\\n            moveIndexTillValid(paragraph, j, n, temp);\\n            \\n            mp[temp]++;\\n            i = j+1;\\n        }\\n        \\n        string result = \"\";\\n        int maxFreq = 0;\\n        for(auto &it : mp) {\\n            if(st.find(it.first) != st.end()) //skip banned words\\n                continue;\\n            \\n            if(it.second > maxFreq) {\\n                result = it.first;\\n                maxFreq = it.second;\\n            }\\n            \\n        }\\n        return result;\\n    }\\n};\\n```\n```\\n//Approach-2 : Consice approach. (Inspired from @lee215)\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        unordered_set<string> st(begin(banned), end(banned));\\n        \\n        for(char &ch : paragraph) {\\n            ch = isalpha(ch) ? tolower(ch) : \\' \\';\\n        }\\n        unordered_map<string, int> mp;\\n        \\n        pair<string, int> result = {\"\", 0};\\n        \\n        istringstream ss(paragraph); //or use, \"stringstream\"\\n        string word;\\n        while(ss >> word) {\\n            if(st.find(word) == end(st)) {\\n                mp[word]++;\\n                if(mp[word] > result.second)\\n                    result = {word, mp[word]};\\n            }\\n        }\\n        \\n        return result.first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298297,
                "title": "golang-solution-faster-than-100",
                "content": "``` go\\nfunc mostCommonWord(paragraph string, banned []string) string {\\n    m := make(map[string] int)\\n    m2 := make(map[string] int)\\n    s := \"\"\\n    max := 0\\n    res := \"\"\\n    \\n    for _, ban := range banned {\\n        m[ban] = 1\\n    }\\n    \\n    for _, i := range paragraph {\\n        if i == \\' \\' || i == \\',\\' || i == \\'!\\' || i == \\'?\\' || i == \\'\\\\\\'\\' || i == \\';\\' || i == \\'.\\' {\\n            m2[s]++\\n            s = \"\"\\n        } else {\\n            s += strings.ToLower(string(i))\\n        }\\n    }\\n    m2[s]++\\n    \\n    for a, b := range m2 {\\n        if b > max && m[a] == 0 && a != \"\" {\\n            max = b\\n            res = a\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc mostCommonWord(paragraph string, banned []string) string {\\n    m := make(map[string] int)\\n    m2 := make(map[string] int)\\n    s := \"\"\\n    max := 0\\n    res := \"\"\\n    \\n    for _, ban := range banned {\\n        m[ban] = 1\\n    }\\n    \\n    for _, i := range paragraph {\\n        if i == \\' \\' || i == \\',\\' || i == \\'!\\' || i == \\'?\\' || i == \\'\\\\\\'\\' || i == \\';\\' || i == \\'.\\' {\\n            m2[s]++\\n            s = \"\"\\n        } else {\\n            s += strings.ToLower(string(i))\\n        }\\n    }\\n    m2[s]++\\n    \\n    for a, b := range m2 {\\n        if b > max && m[a] == 0 && a != \"\" {\\n            max = b\\n            res = a\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1261831,
                "title": "easiest-java-solution-using-list-and-hashmap-with-steps",
                "content": "***Steps***\\n1. Convert paragraph to lowercase and string array.\\n2. Add elements that are not present in banned to hashmap.\\n3. If already present hashmap, increment value by 1.\\n4. Find max value in hashmap and return the key associated with max value.\\n\\n```\\nimport java.util.HashMap;\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        paragraph = paragraph.toLowerCase();\\n         String[] words = paragraph.replaceAll(\"\\\\\\\\W+\" , \" \").toLowerCase().split(\" \");\\n        int temp=0;\\n        int max=0;\\n        \\n        String ans = null;\\n        List<String> ls = Arrays.asList(banned);\\n        System.out.println(ls);\\n        HashMap<String,Integer> hm = new HashMap<String,Integer>();\\n        for(int i=0;i<words.length;i++)\\n        {\\n           if(!ls.contains(words[i]) && hm.containsKey(words[i]))\\n                {\\n                    hm.put(words[i],hm.get(words[i])+1);\\n                }\\n            else if(!ls.contains(words[i]) && !hm.containsKey(words[i]))\\n                {\\n                    hm.put(words[i],1);\\n                }\\n                else\\n                    continue;\\n        }\\n        String res = null;\\n        for(String word : hm.keySet())\\n            if(res == null || hm.get(word) > hm.get(res))\\n                res = word;\\n        System.out.println(hm.get(res));\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nimport java.util.HashMap;\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n        paragraph = paragraph.toLowerCase();\\n         String[] words = paragraph.replaceAll(\"\\\\\\\\W+\" , \" \").toLowerCase().split(\" \");\\n        int temp=0;\\n        int max=0;\\n        \\n        String ans = null;\\n        List<String> ls = Arrays.asList(banned);\\n        System.out.println(ls);\\n        HashMap<String,Integer> hm = new HashMap<String,Integer>();\\n        for(int i=0;i<words.length;i++)\\n        {\\n           if(!ls.contains(words[i]) && hm.containsKey(words[i]))\\n                {\\n                    hm.put(words[i],hm.get(words[i])+1);\\n                }\\n            else if(!ls.contains(words[i]) && !hm.containsKey(words[i]))\\n                {\\n                    hm.put(words[i],1);\\n                }\\n                else\\n                    continue;\\n        }\\n        String res = null;\\n        for(String word : hm.keySet())\\n            if(res == null || hm.get(word) > hm.get(res))\\n                res = word;\\n        System.out.println(hm.get(res));\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259678,
                "title": "c-approach-with-proper-comments",
                "content": "class Solution {\\npublic:\\n\\n    string mostCommonWord(string s, vector<string>& banned) {\\n    // To convert the paragraph into the lower case letters \\n    // if the current char is an alphabet then convert it into lowercase else it is an space then add space to it \\n\\t\\n        for(auto& it:s){\\n            if(isalpha(it))\\n                it=tolower(it);\\n            else\\n                it=\\' \\';\\n        }\\n        \\n        // Extract words from paragraph and store make a freq map of words\\n        \\n        stringstream ss(s);\\n        string word;\\n        unordered_map<string,int> mp;\\n      while(ss>>word){\\n          mp[word]++;\\n      }\\n        \\n    // make the freq of the banned words to 0 so that they can not be our output\\n\\n        for(auto ban:banned){\\n            mp[ban]=0;\\n        }\\n        int cnt=0;\\n        string res=\"\";\\n\\t\\t// Find the largest freq word and return the result\\n\\t\\t\\tfor(auto it:mp){\\n            if(it.second>cnt){\\n                cnt=it.second;\\n                res=it.first;\\n            }\\n        }\\n    \\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    string mostCommonWord(string s, vector<string>& banned) {\\n    // To convert the paragraph into the lower case letters \\n    // if the current char is an alphabet then convert it into lowercase else it is an space then add space to it \\n\\t\\n        for(auto& it:s){\\n            if(isalpha(it))\\n                it=tolower(it);\\n            else\\n                it=\\' \\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1240763,
                "title": "java-easy-solution",
                "content": "Approach is : \\n\\n1) Break down paragraph into words. Handled by trim, removal of fullstop,commas etc.\\n2) Store these words in a hashmap with their frequencies.\\n3) Store the banned words in a hashset for quick access.\\n4) Finally check for the words with maximum frequency in the hashmap, and which is not present in our hashset.\\n\\n```\\nclass Solution {\\n     public String mostCommonWord(String par, String[] banned) {\\n\\n        Map<String, Integer> map = new HashMap<>();\\n        par = par.trim().toLowerCase();\\n        Set<String> set = new HashSet<>();\\n\\n        for (String s : banned)\\n            set.add(s);\\n\\n        int str= 0;\\n        for(int i =0; i< par.length();i++){\\n            if(!Character.isAlphabetic(par.charAt(i))){\\n                String word = par.substring(str, i);\\n                str = i+1;\\n                map.put(word, map.getOrDefault(word,0) + 1);\\n            }else if(par.length() - 1 == i)\\n                map.put(par.substring(str, i+1), map.getOrDefault(par.substring(str, i+1),0) + 1);\\n        }\\n        map.remove(\"\");\\n        int max = -1;\\n        String res = \"\";\\n        for(Map.Entry<String, Integer> mp : map.entrySet()){\\n            if(mp.getValue() > max && !set.contains(mp.getKey())){\\n                max =mp.getValue();\\n                res = mp.getKey();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     public String mostCommonWord(String par, String[] banned) {\\n\\n        Map<String, Integer> map = new HashMap<>();\\n        par = par.trim().toLowerCase();\\n        Set<String> set = new HashSet<>();\\n\\n        for (String s : banned)\\n            set.add(s);\\n\\n        int str= 0;\\n        for(int i =0; i< par.length();i++){\\n            if(!Character.isAlphabetic(par.charAt(i))){\\n                String word = par.substring(str, i);\\n                str = i+1;\\n                map.put(word, map.getOrDefault(word,0) + 1);\\n            }else if(par.length() - 1 == i)\\n                map.put(par.substring(str, i+1), map.getOrDefault(par.substring(str, i+1),0) + 1);\\n        }\\n        map.remove(\"\");\\n        int max = -1;\\n        String res = \"\";\\n        for(Map.Entry<String, Integer> mp : map.entrySet()){\\n            if(mp.getValue() > max && !set.contains(mp.getKey())){\\n                max =mp.getValue();\\n                res = mp.getKey();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239774,
                "title": "python3-simple-solution-using-dictionary",
                "content": "**Can be solved by both regrex or replace function**\\n```\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        d = {}\\n        paragraph = re.split(\" |,|!|\\'|;|\\\\?|\\\\.\", paragraph)\\n        # paragraph = paragraph.replace(\\',\\',\\' \\').replace(\\';\\',\\' \\').replace(\\'!\\',\\' \\').replace(\\'?\\',\\' \\').replace(\"\\'\",\\' \\').replace(\\'.\\',\\' \\').split(\\' \\')\\n        for i in paragraph:\\n            x = i.lower()\\n            if x not in banned and len(x) > 0:\\n                d[x] = d.get(x,0) + 1\\n        return [i for i,j in sorted(d.items(), key= lambda x:x[1], reverse=True)][0]\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        d = {}\\n        paragraph = re.split(\" |,|!|\\'|;|\\\\?|\\\\.\", paragraph)\\n        # paragraph = paragraph.replace(\\',\\',\\' \\').replace(\\';\\',\\' \\').replace(\\'!\\',\\' \\').replace(\\'?\\',\\' \\').replace(\"\\'\",\\' \\').replace(\\'.\\',\\' \\').split(\\' \\')\\n        for i in paragraph:\\n            x = i.lower()\\n            if x not in banned and len(x) > 0:\\n                d[x] = d.get(x,0) + 1\\n        return [i for i,j in sorted(d.items(), key= lambda x:x[1], reverse=True)][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218066,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string s, vector<string>& banned) \\n    {\\n        for(auto &it:s)\\n        {\\n            if(isalpha(it))\\n            {\\n                it=tolower(it);\\n            }\\n            else\\n            {\\n                it=\\' \\';\\n            }\\n        }\\n        istringstream ss(s);\\n        string ans;\\n        unordered_map<string,int>mp;\\n        while(ss>>ans)\\n        {\\n            mp[ans]++;\\n        }\\n        for(auto it:banned)\\n        {\\n            mp[it]=0;\\n        }\\n        string str=\"\";\\n        int count=0;\\n        for(auto it:mp)\\n        {\\n            if(it.second>count)\\n            {\\n                count=it.second;\\n                str=it.first;\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string s, vector<string>& banned) \\n    {\\n        for(auto &it:s)\\n        {\\n            if(isalpha(it))\\n            {\\n                it=tolower(it);\\n            }\\n            else\\n            {\\n                it=\\' \\';\\n            }\\n        }\\n        istringstream ss(s);\\n        string ans;\\n        unordered_map<string,int>mp;\\n        while(ss>>ans)\\n        {\\n            mp[ans]++;\\n        }\\n        for(auto it:banned)\\n        {\\n            mp[it]=0;\\n        }\\n        string str=\"\";\\n        int count=0;\\n        for(auto it:mp)\\n        {\\n            if(it.second>count)\\n            {\\n                count=it.second;\\n                str=it.first;\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213270,
                "title": "java-hashmap-beats-75-easy-to-understand",
                "content": "```\\npublic static String mostCommonWord(String paragraph, String[] banned) {\\n        \\n        paragraph = paragraph.toLowerCase();\\n        String[] words = paragraph.split(\"\\\\\\\\W+\");\\n        Map<String, Integer> map = new HashMap<String, Integer>();\\n        for (String b: banned) {\\n            b = b.toLowerCase();\\n            map.put(b, Integer.MIN_VALUE);\\n        }\\n                    \\n        int max = 0;\\n        String maxWord = null;\\n                    \\n        for (String word: words) {\\n                \\n                if (!map.containsKey(word)) {\\n                    map.put(word, 1);\\n                    if ( 1 > max) {\\n                        max = 1;\\n                        maxWord = word;\\n                    }\\n                    \\n                } \\n                else {\\n                    int x = map.get(word) + 1;\\n                    map.put(word, x);\\n                    if (x > max) {\\n                        max = x;\\n                        maxWord = word;\\n                    }\\n                }\\n            }      \\n                    \\n        return maxWord;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static String mostCommonWord(String paragraph, String[] banned) {\\n        \\n        paragraph = paragraph.toLowerCase();\\n        String[] words = paragraph.split(\"\\\\\\\\W+\");\\n        Map<String, Integer> map = new HashMap<String, Integer>();\\n        for (String b: banned) {\\n            b = b.toLowerCase();\\n            map.put(b, Integer.MIN_VALUE);\\n        }\\n                    \\n        int max = 0;\\n        String maxWord = null;\\n                    \\n        for (String word: words) {\\n                \\n                if (!map.containsKey(word)) {\\n                    map.put(word, 1);\\n                    if ( 1 > max) {\\n                        max = 1;\\n                        maxWord = word;\\n                    }\\n                    \\n                } \\n                else {\\n                    int x = map.get(word) + 1;\\n                    map.put(word, x);\\n                    if (x > max) {\\n                        max = x;\\n                        maxWord = word;\\n                    }\\n                }\\n            }      \\n                    \\n        return maxWord;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1160351,
                "title": "c-819-most-common-word",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        for (auto& c : paragraph) \\n            c = isalpha(c) ? tolower(c) : \\' \\'; \\n        \\n        unordered_map<string, int> freq; \\n        unordered_set<string> ss(banned.begin(), banned.end()); \\n        \\n        int cnt = 0; \\n        istringstream iss(paragraph); \\n        string ans, word; \\n        while (iss >> word) {\\n            if (ss.find(word) == ss.end()) {\\n                ++freq[word]; \\n                if (cnt < freq[word]) {\\n                    ans = word; \\n                    cnt = freq[word]; \\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mostCommonWord(string paragraph, vector<string>& banned) {\\n        for (auto& c : paragraph) \\n            c = isalpha(c) ? tolower(c) : \\' \\'; \\n        \\n        unordered_map<string, int> freq; \\n        unordered_set<string> ss(banned.begin(), banned.end()); \\n        \\n        int cnt = 0; \\n        istringstream iss(paragraph); \\n        string ans, word; \\n        while (iss >> word) {\\n            if (ss.find(word) == ss.end()) {\\n                ++freq[word]; \\n                if (cnt < freq[word]) {\\n                    ans = word; \\n                    cnt = freq[word]; \\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145285,
                "title": "kotlin",
                "content": "```\\nfun mostCommonWord(s: String, ar: Array<String>) = mutableMapOf<String, Int>().apply {\\n    s.toLowerCase().replace(Regex(\"[^a-z ]\"), \" \").split(\" \")\\n        .filter { !ar.contains(it) && it.isNotBlank() }\\n        .forEach { this[it] = getOrDefault(it, 0) + 1 }\\n}.maxBy { it.value }?.key!!\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun mostCommonWord(s: String, ar: Array<String>) = mutableMapOf<String, Int>().apply {\\n    s.toLowerCase().replace(Regex(\"[^a-z ]\"), \" \").split(\" \")\\n        .filter { !ar.contains(it) && it.isNotBlank() }\\n        .forEach { this[it] = getOrDefault(it, 0) + 1 }\\n}.maxBy { it.value }?.key!!\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564720,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1565080,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1835886,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1572147,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1735887,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1738898,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1572152,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 2068525,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1831550,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1576408,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1564720,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1565080,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1835886,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1572147,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1735887,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1738898,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1572152,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 2068525,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1831550,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            },
            {
                "id": 1576408,
                "content": [
                    {
                        "username": "GaryPKU",
                        "content": "Input:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nOutput:\\n\"b\"\\nExpected:\\n\"b,b,b,c\"\\n\\nThat\\'s not what the original description says\\u3002"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "[@athravmehta06](/athravmehta06) You can do it the old fashioned way and read every symbol from paragraph to form words. When you meet a letter, add it to a word. When you meet punctuation or whitespace, finish current word and add it to words array."
                    },
                    {
                        "username": "athravmehta06",
                        "content": "i was wrong for the same test case and now i don\\'t know what to do\\n"
                    },
                    {
                        "username": "ClarkZZ",
                        "content": "For one of the test cases:\\n\"a, a, a, a, b,b,b,c, c\"\\n[\"a\"]\\nAnyone cal tell me what is \"b,b,b,c\"?\\nYou may say that the question didn\\'t assume the word is a meaningful word. \\nBut please look at the note: **Words only consist of letters, never apostrophes or other punctuation symbols.** Even *asdjfhjsdfkfgs* can be treated as a word, but not *b,b,b,c*. It contains punctuation symbol!"
                    },
                    {
                        "username": "HamsterCoder",
                        "content": "No one said that punctuation should be correctly placed. If you were presented with a sentence \"Clark,pleasehelp\" - you would probably treat it as valid sentence. Here is the same thing, someone just forgot to put a space, as if in hurry for example."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "A good question to irritate people."
                    },
                    {
                        "username": "user5400vw",
                        "content": "super irritating"
                    },
                    {
                        "username": "xiping",
                        "content": "that case with  \"b,b,b,c\" is super weird."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: get rid of punctuation and space:\\nparagraph.split(\"//W+\");"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "This problem is about annoying input sanitizing rather than about elegant algorithmic beauty. Unfortunately, this kind of routine work takes loads of development time."
                    },
                    {
                        "username": "VK18",
                        "content": "It is not clear from the description whether a paragraph \"Bob\\'s jobs\" contains 2 or 3 \"words\". \\n"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "A regex like this might come in handy: `[,.!?;'\\s]+`\n\n`Hint`"
                    },
                    {
                        "username": "C0rbaque",
                        "content": "I have a strange issue look : \\n\\nclass Solution {\\n    public String mostCommonWord(String paragraph, String[] banned) {\\n\\n        paragraph = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \"\");\\n        paragraph = paragraph.toLowerCase() ; \\n        int total = 0 ; \\n        int max = 0 ; \\n        int index = 0 ; \\n        String [] array_phrase = null ; \\n        array_phrase = paragraph.split(\" \") ; \\n\\n        for (int i = 0 ; i < array_phrase.length ; i++){\\n            total = 0 ; \\n            for (int j = i+1 ; j < array_phrase.length ; j++){\\n                System.out.println(\" i : \" + array_phrase[i] + \" / j : \" + array_phrase[j] + \" i=j : \" + (array_phrase[i] == array_phrase[j])) ;\\n                if (array_phrase[i] == array_phrase[j]){\\n                    total++ ; \\n                }\\n            }\\n            if (total > max && array_phrase[i] != banned[0] ){\\n                index = i ; \\n                max = total ;\\n            }\\n        }\\n        return array_phrase[index] ; \\n    }\\n}\\n\\nthis is showing that (array_phrase[i] == array_phrase[j])) = false. While array_phrase[i] = \"hit\" and array_phrase[j] = \"hit\".\\n\\nCan somebody explain me why ?"
                    },
                    {
                        "username": "Taha-C",
                        "content": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        c = Counter(re.sub(\"\\\\,|\\\\?|\\\\.|\\\\!|\\\\;|\\\\\\'\", \\' \\', paragraph).lower().split())\\n        for (word, count) in c.most_common():\\n            if word not in banned: return word"
                    }
                ]
            }
        ]
    }
]