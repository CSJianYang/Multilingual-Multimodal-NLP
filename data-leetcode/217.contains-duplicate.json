[
    {
        "title": "Contains Duplicate",
        "question_content": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\n&nbsp;\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: true\nExample 2:\nInput: nums = [1,2,3,4]\nOutput: false\nExample 3:\nInput: nums = [1,1,1,3,3,4,3,2,4,2]\nOutput: true\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t-109 <= nums[i] <= 109",
        "solutions": [
            {
                "id": 2728722,
                "title": "all-possible-easy-solution-with-single-line-code-c",
                "content": "# Try to code by yourself by listing Approach \\uD83E\\uDD7A.\\n\\n**Brute Force** : Idea behind code\\n* Make nested loop , generate all possible pair \\n* Put a condition if both of the number generate in a pair are same\\nIn this approach only the unique pair will be formed becouse outerloop is running from 0 to n - 1, and inner loop will start from one value extra from previous loop value ( which make it to run n*(n+1)/2 ) . if we are matching each and every pair of vector , then possibly we can compare if any of them have same value then return true. else at end of nested form loop return false.\\n```\\n// Brute Force\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        bool flag = false;\\n        for(int i =0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i] == nums[j]) return true;\\n            }\\n        }\\n        return flag;\\n    }\\n};\\n```\\n###### Complexity\\n- Time complexity: $$O((n*(n+1))/2)$$ \\u2248 $$O(n^2)$$\\n- Space complexity: $$O(1)$$\\n<br/>\\n\\n**Shorted Approach** : Idea behind code\\n* sort the array.\\n* linearly traverse , find if there is any of the number and its greater one are equal or not\\n\\n```\\n// Shorted Approach\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        bool flag = false;\\n        for(int i =0;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1]) return true;\\n        }\\n        return flag;\\n    }\\n};\\n```\\n###### Complexity\\n- Time complexity: $$O(n*log(n))$$\\n- Space complexity: $$O(1)$$\\n<br/>\\n\\n**Set Approach** : Idea behind code\\n* Set only don\\'t contain duplicate elment .\\n* If the size of set if less than  the original vector then it contain duplicate element.\\n\\n* For your set approach, time complexity can be reduced from O(nlogn) to O(n) using an unordered_set. Regular set uses trees with O(logn) insert, but unordered_sets use hashing for O(1). :)\\n```\\n// Set Approach\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        return nums.size() > set<int>(nums.begin(),nums.end()).size();\\n    }\\n};\\n```\\n###### Complexity\\n- Time complexity: $$O(n*log(n))$$\\n- Space complexity: $$O(n)$$\\n<br/>\\n\\n**Map** : Idea behind code\\n* traverse vector and count frequency using any data structure.\\n* Iterate through data structure to find if the frequency is beyond 1.\\n\\n```\\n// Contains Duplicate\\n  class Solution {\\n  public:\\n      bool containsDuplicate(vector<int>& nums) {\\n          map<int,int> mp;\\n          for(auto i : nums) mp[i]++;\\n          bool flag = false;\\n          for(auto i : mp){\\n              if(i.second >= 2) return true;\\n          }\\n          return flag;\\n      }\\n  };\\n```\\n###### Complexity\\n- Time complexity: $$O(n*log(n))$$\\n- Space complexity: $$O(n)$$\\n\\n**Hashmap** : Idea behind code\\n* traverse vector and count frequency using any data structure.\\n* Iterate through data structure to find if the frequency is beyond 1.\\n* same as above but difference is that it will be in `O(n)`\\n\\n```\\n// Contains Duplicate\\n  class Solution {\\n  public:\\n      bool containsDuplicate(vector<int>& nums) {\\n          unordered_map<int,int> mp;\\n          for(auto i : nums) mp[i]++;\\n          bool flag = false;\\n          for(auto i : mp){\\n              if(i.second >= 2) return true;\\n          }\\n          return flag;\\n      }\\n  };\\n```\\n###### Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n**My Opinion**\\nIt depend on situation which Complexity is best for you.\\n\\nHappy coding, Please do upvote this post.\\n\\n![image](https://assets.leetcode.com/users/images/5ce11bf6-0db9-4239-bbb9-dfe5d76443f3_1666346629.9681695.gif)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n// Brute Force\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        bool flag = false;\\n        for(int i =0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i] == nums[j]) return true;\\n            }\\n        }\\n        return flag;\\n    }\\n};\\n```\n```\\n// Shorted Approach\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        bool flag = false;\\n        for(int i =0;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1]) return true;\\n        }\\n        return flag;\\n    }\\n};\\n```\n```\\n// Set Approach\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        return nums.size() > set<int>(nums.begin(),nums.end()).size();\\n    }\\n};\\n```\n```\\n// Contains Duplicate\\n  class Solution {\\n  public:\\n      bool containsDuplicate(vector<int>& nums) {\\n          map<int,int> mp;\\n          for(auto i : nums) mp[i]++;\\n          bool flag = false;\\n          for(auto i : mp){\\n              if(i.second >= 2) return true;\\n          }\\n          return flag;\\n      }\\n  };\\n```\n```\\n// Contains Duplicate\\n  class Solution {\\n  public:\\n      bool containsDuplicate(vector<int>& nums) {\\n          unordered_map<int,int> mp;\\n          for(auto i : nums) mp[i]++;\\n          bool flag = false;\\n          for(auto i : mp){\\n              if(i.second >= 2) return true;\\n          }\\n          return flag;\\n      }\\n  };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60858,
                "title": "possible-solutions",
                "content": "This problem seems trivial, so lets try different approaches to solve it:\\n\\nStarting from worst time complexity to the best one:\\n\\n----------\\n\\nTime complexity: O(N^2), memory: O(1)\\n\\nThe naive approach would be to run a iteration for each element and see whether a duplicate value can be found: this results in O(N^2) time complexity.\\n\\n----------\\n\\n    public boolean containsDuplicate(int[] nums) {\\n    \\n            for(int i = 0; i < nums.length; i++) {\\n                for(int j = i + 1; j < nums.length; j++) {\\n                    if(nums[i] == nums[j]) {\\n                        return true;\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n\\n----------\\n\\nTime complexity: O(N lg N), memory: O(1) - not counting the memory used by sort\\n\\nSince it is trivial task to find duplicates in sorted array, we can sort it as the first step of the algorithm and then search for consecutive duplicates.\\n\\n----------\\n\\n        public boolean containsDuplicate(int[] nums) {\\n    \\n            Arrays.sort(nums);\\n            for(int ind = 1; ind < nums.length; ind++) {\\n                if(nums[ind] == nums[ind - 1]) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\n----------\\n\\nTime complexity: O(N), memory: O(N)\\n\\nFinally we can used a well known data structure hash table that will help us to identify whether an element has been previously encountered in the array.\\n\\n----------\\n\\n    public boolean containsDuplicate(int[] nums) {\\n    \\n        final Set<Integer> distinct = new HashSet<Integer>();\\n        for(int num : nums) {\\n            if(distinct.contains(num)) {\\n                return true;\\n            }\\n            distinct.add(num);\\n        }\\n        return false;\\n    }\\n\\n----------\\n\\nThis is trivial but quite nice example of space-time tradeoff.",
                "solutionTags": [],
                "code": "This problem seems trivial, so lets try different approaches to solve it:\\n\\nStarting from worst time complexity to the best one:\\n\\n----------\\n\\nTime complexity: O(N^2), memory: O(1)\\n\\nThe naive approach would be to run a iteration for each element and see whether a duplicate value can be found: this results in O(N^2) time complexity.\\n\\n----------\\n\\n    public boolean containsDuplicate(int[] nums) {\\n    \\n            for(int i = 0; i < nums.length; i++) {\\n                for(int j = i + 1; j < nums.length; j++) {\\n                    if(nums[i] == nums[j]) {\\n                        return true;\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n\\n----------\\n\\nTime complexity: O(N lg N), memory: O(1) - not counting the memory used by sort\\n\\nSince it is trivial task to find duplicates in sorted array, we can sort it as the first step of the algorithm and then search for consecutive duplicates.\\n\\n----------\\n\\n        public boolean containsDuplicate(int[] nums) {\\n    \\n            Arrays.sort(nums);\\n            for(int ind = 1; ind < nums.length; ind++) {\\n                if(nums[ind] == nums[ind - 1]) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\n----------\\n\\nTime complexity: O(N), memory: O(N)\\n\\nFinally we can used a well known data structure hash table that will help us to identify whether an element has been previously encountered in the array.\\n\\n----------\\n\\n    public boolean containsDuplicate(int[] nums) {\\n    \\n        final Set<Integer> distinct = new HashSet<Integer>();\\n        for(int num : nums) {\\n            if(distinct.contains(num)) {\\n                return true;\\n            }\\n            distinct.add(num);\\n        }\\n        return false;\\n    }\\n\\n----------\\n\\nThis is trivial but quite nice example of space-time tradeoff.",
                "codeTag": "Unknown"
            },
            {
                "id": 2459020,
                "title": "very-easy-100-fully-explained-c-java-python-javascript-python3-creating-set",
                "content": "# **C++ Solution (Using Set / Sort & Find Approach)**\\n```\\n/** Approach : Using Set **/\\n// Time Complexity: O(n)\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // Create a set...\\n        unordered_set<int> hset;\\n        // Traverse all the elements through the loop...\\n        for(int idx = 0; idx < nums.size(); idx++) {\\n            // Searches set. if present, it contains duplicate...\\n            if(hset.count(nums[idx]))\\n                return true;\\n            // insert nums[i] in set...\\n            hset.insert(nums[idx]);\\n        }\\n        return false;\\n    }\\n};\\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n/**   Approach : Sort & Find Duplicates **/\\n// Time Complexity: O(nlogn)\\n// Space Complexity: O(1)\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // Sort the nums...\\n        sort(nums.begin(), nums.end());\\n        // Traverse all the elements through the loop...\\n        for(int idx = 0; idx < nums.size() - 1; idx++) {\\n            // Check the duplicate element...\\n            if(nums[idx] == nums[idx + 1])\\n                return true;\\n        }\\n        // Otherwise return false...\\n        return false;\\n    }\\n};\\n```\\n\\n# **Java Solution (Using Hashset):**\\n```\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        // Create a hashset...\\n        HashSet<Integer> hset = new HashSet<Integer>();\\n        // Traverse all the elements through the loop...\\n        for (int idx = 0; idx < nums.length; idx ++){\\n            // Searches hashset. if present, it contains duplicate...\\n            if (hset.contains(nums[idx])){\\n                return true;\\n            }\\n            // if not present it will update hashset...\\n            hset.add(nums[idx]);\\n        }\\n        // Otherwise return false...\\n        return false;\\n    }\\n}\\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        // Base case...\\n        if(nums==null || nums.length==0)\\n            return false;\\n        // Create a hashset...\\n        HashSet<Integer> hset = new HashSet<Integer>();\\n        // Traverse all the elements through the loop...\\n        for(int idx: nums){\\n            // If it contains duplicate...\\n            if(!hset.add(idx)){\\n                return true;\\n            }\\n        }\\n        // Otherwise return false...\\n        return false;\\n    }\\n}\\n```\\n\\n# **Python / Python3 Solution (Creating a Set):**\\n```\\n# Time complexity: O(n)\\n# Space complexity: O(n)\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        hset = set()\\n        for idx in nums:\\n            if idx in hset:\\n                return True\\n            else:\\n                hset.add(idx)\\n```\\n                    \\n# **JavaScript Solution (Creating a Set):**\\n```\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\nvar containsDuplicate = function(nums) {\\n    const s = new Set(nums); return s.size !== nums.length\\n};\\n```\\n\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\n/** Approach : Using Set **/\\n// Time Complexity: O(n)\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // Create a set...\\n        unordered_set<int> hset;\\n        // Traverse all the elements through the loop...\\n        for(int idx = 0; idx < nums.size(); idx++) {\\n            // Searches set. if present, it contains duplicate...\\n            if(hset.count(nums[idx]))\\n                return true;\\n            // insert nums[i] in set...\\n            hset.insert(nums[idx]);\\n        }\\n        return false;\\n    }\\n};\\n------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n/**   Approach : Sort & Find Duplicates **/\\n// Time Complexity: O(nlogn)\\n// Space Complexity: O(1)\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // Sort the nums...\\n        sort(nums.begin(), nums.end());\\n        // Traverse all the elements through the loop...\\n        for(int idx = 0; idx < nums.size() - 1; idx++) {\\n            // Check the duplicate element...\\n            if(nums[idx] == nums[idx + 1])\\n                return true;\\n        }\\n        // Otherwise return false...\\n        return false;\\n    }\\n};\\n```\n```\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        // Create a hashset...\\n        HashSet<Integer> hset = new HashSet<Integer>();\\n        // Traverse all the elements through the loop...\\n        for (int idx = 0; idx < nums.length; idx ++){\\n            // Searches hashset. if present, it contains duplicate...\\n            if (hset.contains(nums[idx])){\\n                return true;\\n            }\\n            // if not present it will update hashset...\\n            hset.add(nums[idx]);\\n        }\\n        // Otherwise return false...\\n        return false;\\n    }\\n}\\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        // Base case...\\n        if(nums==null || nums.length==0)\\n            return false;\\n        // Create a hashset...\\n        HashSet<Integer> hset = new HashSet<Integer>();\\n        // Traverse all the elements through the loop...\\n        for(int idx: nums){\\n            // If it contains duplicate...\\n            if(!hset.add(idx)){\\n                return true;\\n            }\\n        }\\n        // Otherwise return false...\\n        return false;\\n    }\\n}\\n```\n```\\n# Time complexity: O(n)\\n# Space complexity: O(n)\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        hset = set()\\n        for idx in nums:\\n            if idx in hset:\\n                return True\\n            else:\\n                hset.add(idx)\\n```\n```\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\nvar containsDuplicate = function(nums) {\\n    const s = new Set(nums); return s.size !== nums.length\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163705,
                "title": "java-best-solution-3-ways",
                "content": "# Approach\\n- First Sort the Array.\\n- Then Compare elements one by one.\\n- We Only have to return a boolean value.\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(log(n))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n\\n\\n\\n```\\n# Complexity using a HashMap\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i])) {\\n                return true;\\n            }\\n            map.put(nums[i],1);\\n        }\\n        return false;\\n    }\\n}\\n```\\n# Complexity using a HashSet\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n                if (set.contains(nums[i])) {\\n                    return true;\\n                }\\n                set.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n\\n\\n\\n```\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i])) {\\n                return true;\\n            }\\n            map.put(nums[i],1);\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n                if (set.contains(nums[i])) {\\n                    return true;\\n                }\\n                set.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672475,
                "title": "4-method-s-c-java-python-beginner-friendly",
                "content": "# Approach 1: Brute Force\\n\\n# Intuition:\\nThe brute force approach compares each element with every other element in the array to check for duplicates. If any duplicates are found, it returns `true`. This approach is straightforward but has a time complexity of O(n^2), making it less efficient for large arrays.\\n\\n# Explanation:\\nThe brute force approach involves comparing each element in the array with every other element to check for duplicates. If any duplicates are found, return `true`, otherwise return `false`.\\n\\n# Code [TLE]:\\n```C++ []\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int i = 0; i < n - 1; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (nums[i] == nums[j])\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        int n = nums.length;\\n        for (int i = 0; i < n - 1; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (nums[i] == nums[j])\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        for i in range(n - 1):\\n            for j in range(i + 1, n):\\n                if nums[i] == nums[j]:\\n                    return True\\n        return False\\n```\\n\\nThe time complexity of this approach is `O(n^2)`, where n is the length of the array.\\nso, this approach is not efficient for large arrays -> **TLE**\\n\\n# Approach 2: Sorting\\n\\n# Intuition:\\nThe sorting approach sorts the array in ascending order and then checks for adjacent elements that are the same. If any duplicates are found, it returns `true`. Sorting helps in bringing duplicates together, simplifying the check. However, sorting has a time complexity of O(n log n).\\n\\n# Explanation:\\nAnother approach is to sort the array and then check for adjacent elements that are the same. If any duplicates are found, return `true`, otherwise return `false`.\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] == nums[i - 1])\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] == nums[i - 1])\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        nums.sort()\\n        n = len(nums)\\n        for i in range(1, n):\\n            if nums[i] == nums[i - 1]:\\n                return True\\n        return False\\n```\\n\\nThe time complexity of this approach is `O(n log n)`, where n is the length of the array.\\n\\n# Approach 3: Hash Set\\n\\n# Intuition:\\nThe hash set approach uses a hash set data structure to store encountered elements. It iterates through the array, checking if an element is already in the set. If so, it returns `true`. Otherwise, it adds the element to the set. This approach has a time complexity of O(n) and provides an efficient way to check for duplicates.\\n\\n# Explanation:\\nA more efficient approach is to use a hash set data structure to store the encountered elements. While iterating through the array, if an element is already present in the hash set, return `true`. Otherwise, add the element to the hash set. If the loop completes without finding any duplicates, return `false`.\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        unordered_set<int> seen;\\n        for (int num : nums) {\\n            if (seen.count(num) > 0)\\n                return true;\\n            seen.insert(num);\\n        }\\n        return false;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num))\\n                return true;\\n            seen.add(num);\\n        }\\n        return false;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        seen = set()\\n        for num in nums:\\n            if num in seen:\\n                return True\\n            seen.add(num)\\n        return False\\n```\\n\\nThe time complexity of this approach is `O(n)`, where n is the length of the array.\\n\\n# Approach 4: Hash Map \\n\\n# Intuition:\\nThe hash map approach is similar to the hash set approach but also keeps track of the count of occurrences for each element. It uses a hash map to store the elements as keys and their counts as values. If a duplicate element is encountered (count greater than or equal to 1), it returns `true`. This approach provides more information than just the presence of duplicates and has a time complexity of O(n).\\n\\n# Explanation:\\nIn this approach, we iterate through the array and store each element as a key in a hash map. The value associated with each key represents the count of occurrences of that element. If we encounter an element that already exists in the hash map with a count greater than or equal to 1, we return `true`, indicating that a duplicate has been found. Otherwise, we update the count of that element in the hash map. If we complete the iteration without finding any duplicates, we return `false`.\\n\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> seen;\\n        for (int num : nums) {\\n            if (seen[num] >= 1)\\n                return true;\\n            seen[num]++;\\n        }\\n        return false;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashMap<Integer, Integer> seen = new HashMap<>();\\n        for (int num : nums) {\\n            if (seen.containsKey(num) && seen.get(num) >= 1)\\n                return true;\\n            seen.put(num, seen.getOrDefault(num, 0) + 1);\\n        }\\n        return false;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        seen = {}\\n        for num in nums:\\n            if num in seen and seen[num] >= 1:\\n                return True\\n            seen[num] = seen.get(num, 0) + 1\\n        return False\\n```\\n\\nThe time complexity of this approach is `O(n)`, where n is the length of the array.\\n\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/e9e2577b-5afd-4af0-8666-15afd390c2d9_1687503822.6608438.png)\\n\\n**If you are a beginner solve these problems which makes concepts clear for future coding:**\\n1. [Two Sum](https://leetcode.com/problems/two-sum/solutions/3619262/3-method-s-c-java-python-beginner-friendly/)\\n2. [Roman to Integer](https://leetcode.com/problems/roman-to-integer/solutions/3651672/best-method-c-java-python-beginner-friendly/)\\n3. [Palindrome Number](https://leetcode.com/problems/palindrome-number/solutions/3651712/2-method-s-c-java-python-beginner-friendly/)\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/solutions/3666304/beats-100-c-java-python-beginner-friendly/)\\n5. [Remove Element](https://leetcode.com/problems/remove-element/solutions/3670940/best-100-c-java-python-beginner-friendly/)\\n6. [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/solutions/3672475/4-method-s-c-java-python-beginner-friendly/)\\n7. [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/solutions/3675747/beats-100-c-java-python-beginner-friendly/)\\n8. [Majority Element](https://leetcode.com/problems/majority-element/solutions/3676530/3-methods-beats-100-c-java-python-beginner-friendly/)\\n9. [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3676877/best-method-100-c-java-python-beginner-friendly/)\\n10. **Practice them in a row for better understanding and please Upvote for more questions.**\\n\\n\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        for (int i = 0; i < n - 1; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (nums[i] == nums[j])\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        int n = nums.length;\\n        for (int i = 0; i < n - 1; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (nums[i] == nums[j])\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        for i in range(n - 1):\\n            for j in range(i + 1, n):\\n                if nums[i] == nums[j]:\\n                    return True\\n        return False\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] == nums[i - 1])\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] == nums[i - 1])\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        nums.sort()\\n        n = len(nums)\\n        for i in range(1, n):\\n            if nums[i] == nums[i - 1]:\\n                return True\\n        return False\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        unordered_set<int> seen;\\n        for (int num : nums) {\\n            if (seen.count(num) > 0)\\n                return true;\\n            seen.insert(num);\\n        }\\n        return false;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num))\\n                return true;\\n            seen.add(num);\\n        }\\n        return false;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        seen = set()\\n        for num in nums:\\n            if num in seen:\\n                return True\\n            seen.add(num)\\n        return False\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> seen;\\n        for (int num : nums) {\\n            if (seen[num] >= 1)\\n                return true;\\n            seen[num]++;\\n        }\\n        return false;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashMap<Integer, Integer> seen = new HashMap<>();\\n        for (int num : nums) {\\n            if (seen.containsKey(num) && seen.get(num) >= 1)\\n                return true;\\n            seen.put(num, seen.getOrDefault(num, 0) + 1);\\n        }\\n        return false;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        seen = {}\\n        for num in nums:\\n            if num in seen and seen[num] >= 1:\\n                return True\\n            seen[num] = seen.get(num, 0) + 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60898,
                "title": "single-line-c-solution-60ms",
                "content": "Using anonymous set<>.<br>\\nNot the most efficient as many already pointed out... but if you like one-liners ;) <br>\\nakin to the solution possible with python. \\n\\n    #include <set>\\n    using namespace std;\\n    \\n    class Solution {\\n    public:\\n        bool containsDuplicate(vector<int>& nums) {\\n            return nums.size() > set<int>(nums.begin(), nums.end()).size();        \\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool containsDuplicate(vector<int>& nums) {\\n            return nums.size() > set<int>(nums.begin(), nums.end()).size();        \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 60850,
                "title": "one-line-solution-in-python",
                "content": "    class Solution(object):\\n    def containsDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        return len(nums) != len(set(nums))",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "    class Solution(object):\\n    def containsDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        return len(nums) != len(set(nums))",
                "codeTag": "Java"
            },
            {
                "id": 3257522,
                "title": "one-line-code-python3",
                "content": "\\n\\n# One Line Of Code\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums))!=len(nums)\\n```\\n# please upvote me it would encourage me alot",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums))!=len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515531,
                "title": "javascript-set-vs-object",
                "content": "A lot of the posted Javascript solutions here use a one-line expression using Sets, which is certainly an elegant way of solving the problem. But I was a bit surprised that they were, according to LeetCode, faster than my solution, which uses Objects (a hash table, essentially). One immediate advantage of using Objects is that you can return early if you detect a duplicate, whereas with Sets, you have to convert the entire array to a Set before you can decide if there are duplicates.\\n\\nSo with a little bit of testing, it turns out that for small arrays, using Sets is faster. For larger arrays, even if there are no duplicates and you have to go through the entire array, using Objects becomes significantly faster. For me, the crossover point happens at arrays of about 10,000 elements. Here\\'s some test code (run on my 2016 Macbook Pro in Node, your results may vary):\\n\\n```\\nconst { performance } = require(\\'perf_hooks\\'); //Timing library\\n\\nfunction objectSolution(nums) {\\n  let testObj = {};\\n  for (var i = 0; i < nums.length; i++) {\\n    let aNum = nums[i];\\n    if (testObj[aNum]) {\\n      return true;\\n    } else {\\n      testObj[aNum] = true;\\n    }\\n  }\\n\\n  return false;\\n}\\n\\nfunction setSolution(nums) {\\n  let testSet = new Set(nums);\\n  return testSet.size !== nums.length;\\n}\\n\\nfunction runTest(testFunction, testArray) {\\n  console.log(\\'   Running test:\\', testFunction.name);\\n  let start = performance.now();\\n  let result = testFunction(testArray);\\n  let end = performance.now();\\n  console.log(\\'      Duration:\\', end - start);\\n}\\n\\nlet arr = [];\\nlet setSize = 1000;\\nfor (var i = 0; i < setSize; i++) {\\n  arr.push(i);\\n}\\nconsole.log(\\'Set size:\\', setSize);\\nrunTest(objectSolution, arr);\\nrunTest(setSolution, arr);\\n```\\n\\n**1,000 elements (Set is 7x faster):**\\n*Set: 0.15ms*\\nObject: 1.02ms\\n\\n**10,000 elements:**\\n*Set: 0.87ms*\\nObject: 0.88ms\\n\\n**100,000 elements:**\\nSet: 10.91ms\\n*Object: 7.58ms*\\n\\n**1,000,000 elements (Object is almost 3x faster):**\\nSet: 166.79ms\\n*Object: 59.55ms*\\n\\n**10,000,000 elements (Object about 5x faster):**\\nSet: 3,575.32ms (3.5 seconds!)\\n*Object: 678.08ms*",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nconst { performance } = require(\\'perf_hooks\\'); //Timing library\\n\\nfunction objectSolution(nums) {\\n  let testObj = {};\\n  for (var i = 0; i < nums.length; i++) {\\n    let aNum = nums[i];\\n    if (testObj[aNum]) {\\n      return true;\\n    } else {\\n      testObj[aNum] = true;\\n    }\\n  }\\n\\n  return false;\\n}\\n\\nfunction setSolution(nums) {\\n  let testSet = new Set(nums);\\n  return testSet.size !== nums.length;\\n}\\n\\nfunction runTest(testFunction, testArray) {\\n  console.log(\\'   Running test:\\', testFunction.name);\\n  let start = performance.now();\\n  let result = testFunction(testArray);\\n  let end = performance.now();\\n  console.log(\\'      Duration:\\', end - start);\\n}\\n\\nlet arr = [];\\nlet setSize = 1000;\\nfor (var i = 0; i < setSize; i++) {\\n  arr.push(i);\\n}\\nconsole.log(\\'Set size:\\', setSize);\\nrunTest(objectSolution, arr);\\nrunTest(setSolution, arr);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 60861,
                "title": "5-lines-in-java",
                "content": "The Set's add method can be used for this situation,because it will return false if the element already exists .   \\n\\n    public  boolean containsDuplicate(int[] nums) {\\n    \\t\\t Set<Integer> set = new HashSet<Integer>();\\n    \\t\\t for(int i : nums)\\n    \\t\\t\\t if(!set.add(i))// if there is same\\n    \\t\\t\\t\\t return true; \\n    \\t\\t return false;\\n    \\t }",
                "solutionTags": [],
                "code": "The Set's add method can be used for this situation,because it will return false if the element already exists .   \\n\\n    public  boolean containsDuplicate(int[] nums) {\\n    \\t\\t Set<Integer> set = new HashSet<Integer>();\\n    \\t\\t for(int i : nums)\\n    \\t\\t\\t if(!set.add(i))// if there is same\\n    \\t\\t\\t\\t return true; \\n    \\t\\t return false;\\n    \\t }",
                "codeTag": "Unknown"
            },
            {
                "id": 1698064,
                "title": "5-different-approaches-w-explanations",
                "content": "**Approach #1**: Brute Force - *Time Limit Exceeded*\\n\\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    n = len(nums)\\n    for i in range(n - 1):\\n        for j in range(i + 1, n):\\n            if nums[i] == nums[j]: return True\\n    return False\\n```\\n\\n* **Explanation**: Use two for loops to compare pairs of integers in the array. Once we reach a comparison in which the numbers are the same, we return true. If we loop through all the integers of the array without reaching a similar pair of numbers, we return false.\\n* **Runtime**: Time Limit Exceeded\\n---\\n**Approach #2**: Sorting\\n\\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    nums.sort()\\n    for i in range(len(nums)-1):\\n        if nums[i] == nums[i+1]: return True\\n    return False\\n```\\n\\n* **Explanation**: We start off by sorting the given array. Once we loop through the array from the beginning, if we see that the current number is the same as the next one in the array, there contains a duplicate in the array and therefore we return true. If we finish looping and there are no duplicates, we return false.\\n* **Runtime**: Faster than 15% (715 ms)\\n---\\n**Approach #3**: Using Counter Function\\n\\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    freq = Counter(nums)\\n    for num, freq in freq.items():\\n        if freq > 1:\\n            return True\\n    return False\\n```\\n\\n* **Explanation**: `Counter` is a subclass of `dict` designed for counting hashable objects in Python. It\\u2019s a dictionary that stores the objects as keys and the frequencies of those objects as values. In this approach, we utilize `Counter` to count the frequencies of each integer for us. For example, if the input array is `[1, 2, 3, 4, 4, 5]`, using `Counter` on that input array will give us the following dictionary: `Counter({4: 2, 1: 1, 2: 1, 3: 1, 5: 1})`. Utilizing this function, we will loop through the `freq` dictionary to see if any values (frequencies) are greater than 1, which means there exists an integer in the given array that is duplicated.\\n* **Runtime**: Faster than 7% (797 ms)\\n---\\n**Approach #4**: Using Hashmap\\n\\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    counter = {}\\n    for num in nums:\\n        if num not in counter:\\n            counter[num] = 0\\n        counter[num] += 1\\n    for num, freq in counter.items():\\n        if freq > 1:\\n            return True\\n    return False\\n```\\n\\n* **Explanation**: In this approach, we essentially mimick what the `Counter` function does in the previous approach. We first initialize a hashmap, to which we loop through the given array and plot the frequencies of each integer by incrementing the values in the hashmap. Then, we try to look for a frequency that is greater than 1 and return the result accordingly.\\n* **Runtime**: Faster than 7% (810 ms)\\n---\\n**Approach #5**: Using Set\\n\\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    return False if len(set(nums)) == len(nums) else True\\n```\\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    return len(set(nums)) != len(nums)\\n```\\n\\n* **Explanation**: This approach can be done a number of ways in just one line. Essentially we are using `set()` to convert the given array to a set. In a set, the values are unique and there exists no duplicates, therefore if the set version of the input array has a different length than the regular array itself, there exists a duplicate in the original input array.\\n* **Runtime**: Faster than 5% (885 ms)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    n = len(nums)\\n    for i in range(n - 1):\\n        for j in range(i + 1, n):\\n            if nums[i] == nums[j]: return True\\n    return False\\n```\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    nums.sort()\\n    for i in range(len(nums)-1):\\n        if nums[i] == nums[i+1]: return True\\n    return False\\n```\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    freq = Counter(nums)\\n    for num, freq in freq.items():\\n        if freq > 1:\\n            return True\\n    return False\\n```\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    counter = {}\\n    for num in nums:\\n        if num not in counter:\\n            counter[num] = 0\\n        counter[num] += 1\\n    for num, freq in counter.items():\\n        if freq > 1:\\n            return True\\n    return False\\n```\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    return False if len(set(nums)) == len(nums) else True\\n```\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    return len(set(nums)) != len(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3217571,
                "title": "javascript-easiest-logic-ever",
                "content": "# Intuition\\nThere are generally many ways to solve it.\\nI used this because it is easy to understand the logic and can use in any language.\\n\\n# Approach\\nJust look at the array . The array is sorted by using Sort() , if the next element is same as first it will return true.\\n\\n# Complexity\\n- Time complexity:\\nIts Linear Time Comlexity Big-O = O(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# JavaScript Solution (Using Loop):\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n    nums.sort((a,b) => a-b);\\n    for(let i = 0; i <= nums.length-1; i++){\\n        if(nums[i] === nums[i+1]){\\n            return true\\n        }\\n    }\\n    return false\\n};\\n```\\n# JavaScript Solution (Creating a Set):\\n````\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\nvar containsDuplicate = function(nums) {\\n    const s = new Set(nums); \\n    return s.size !== nums.length\\n};\\n````\\n#### I am working hard for you guys...\\n#### Please upvote if you found any help with this code...\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n    nums.sort((a,b) => a-b);\\n    for(let i = 0; i <= nums.length-1; i++){\\n        if(nums[i] === nums[i+1]){\\n            return true\\n        }\\n    }\\n    return false\\n};\\n```\n````\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\nvar containsDuplicate = function(nums) {\\n    const s = new Set(nums); \\n    return s.size !== nums.length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 60937,
                "title": "3ms-java-solution-with-bit-manipulation",
                "content": "if the range of element provided, we can use byte array as a marker.    \\n\\n\\n    public class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        byte[] mark = new byte[150000];\\n        for (int i : nums) {\\n            int j = i/8;\\n            int k = i%8;\\n            int check = 1<<k;\\n            if ((mark[j] & check) != 0) {\\n                return true;\\n            }\\n            mark[j]|=check;\\n        }\\n        return false;\\n    }\\n    }",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        byte[] mark = new byte[150000];\\n        for (int i : nums) {\\n            int j = i/8;\\n            int k = i%8;\\n            int check = 1<<k;\\n            if ((mark[j] & check) != 0) {\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 61110,
                "title": "c-solutions-sorting-maps-and-sets",
                "content": "        \\n    bool containsDuplicate1(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for (int i=0; i<int(nums.size())-1; i++) {\\n            if (nums[i]==nums[i+1])\\n                return true;\\n        }\\n        return false;    \\n    }\\n    \\n    bool containsDuplicate2(vector<int>& nums) {\\n        map<int, bool> myMap;\\n        // unordered_map<int, bool> myMap;\\n        for (auto& num: nums) {\\n            if (myMap.find(num) != myMap.end())\\n                return true;\\n            else\\n                myMap[num] = true;\\n        }\\n        return false;\\n    }\\n    \\n    bool containsDuplicate3(vector<int>& nums) {\\n        multimap<int, bool> myMap;\\n        // unordered_multimap<int, bool> myMap;\\n        for (auto& num: nums) {\\n            if (myMap.find(num) != myMap.end())\\n                return true;\\n            myMap.insert(make_pair(num, true));\\n        }\\n        return false;\\n    }\\n    \\n    bool containsDuplicate4(vector<int>& nums) {\\n        set<int> mySet;\\n        // unordered_set<int> mySet;\\n        // multiset<int> mySet;\\n        // unordered_multiset<int> mySet;\\n        for (auto& num: nums) {\\n            if (mySet.find(num) != mySet.end())\\n                return true;\\n            mySet.insert(num);\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "        \\n    bool containsDuplicate1(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for (int i=0; i<int(nums.size())-1; i++) {\\n            if (nums[i]==nums[i+1])\\n                return true;\\n        }\\n        return false;    \\n    }\\n    \\n    bool containsDuplicate2(vector<int>& nums) {\\n        map<int, bool> myMap;\\n        // unordered_map<int, bool> myMap;\\n        for (auto& num: nums) {\\n            if (myMap.find(num) != myMap.end())\\n                return true;\\n            else\\n                myMap[num] = true;\\n        }\\n        return false;\\n    }\\n    \\n    bool containsDuplicate3(vector<int>& nums) {\\n        multimap<int, bool> myMap;\\n        // unordered_multimap<int, bool> myMap;\\n        for (auto& num: nums) {\\n            if (myMap.find(num) != myMap.end())\\n                return true;\\n            myMap.insert(make_pair(num, true));\\n        }\\n        return false;\\n    }\\n    \\n    bool containsDuplicate4(vector<int>& nums) {\\n        set<int> mySet;\\n        // unordered_set<int> mySet;\\n        // multiset<int> mySet;\\n        // unordered_multiset<int> mySet;\\n        for (auto& num: nums) {\\n            if (mySet.find(num) != mySet.end())\\n                return true;\\n            mySet.insert(num);\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 60872,
                "title": "1-line-javascript-solutions",
                "content": "Using `Set`:\\n```\\nvar containsDuplicate = function(nums) {\\n    return new Set(nums).size < nums.length;\\n};\\n```\\nWe can also use `sort` which is slower O(n log n) time but improved O(1) space (although we mutate the input):\\n```\\nvar containsDuplicate = function(nums) {\\n    return nums.sort().some((a, i) => a === nums[i - 1]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar containsDuplicate = function(nums) {\\n    return new Set(nums).size < nums.length;\\n};\\n```\n```\\nvar containsDuplicate = function(nums) {\\n    return nums.sort().some((a, i) => a === nums[i - 1]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 60852,
                "title": "three-python-solution-for-contain-duplicates",
                "content": "        # Method 1 -- Apply hashtable O(n)\\n        # hashNum = {}\\n        # for i in nums:\\n        #     if i not in hashNum:\\n        #         hashNum[i] = 1\\n        #     else:\\n        #         return True\\n        # return False\\n        \\n        # Method 2 -- Sorting\\n        # l =  len(nums)\\n        # if l < 2:\\n        #     return False\\n        # nums.sort()\\n        # for i in range(l-1):\\n        #     if nums[i] == nums[i+1]:\\n        #         return True\\n        # return False\\n        \\n        # Method 3 -- Set solution for python\\n        numsSet =  set(nums)\\n        if len(nums) == len(numsSet):\\n            return False\\n        return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "        # Method 1 -- Apply hashtable O(n)\\n        # hashNum = {}\\n        # for i in nums:\\n        #     if i not in hashNum:\\n        #         hashNum[i] = 1\\n        #     else:\\n        #         return True\\n        # return False\\n        \\n        # Method 2 -- Sorting\\n        # l =  len(nums)\\n        # if l < 2:\\n        #     return False\\n        # nums.sort()\\n        # for i in range(l-1):\\n        #     if nums[i] == nums[i+1]:\\n        #         return True\\n        # return False\\n        \\n        # Method 3 -- Set solution for python\\n        numsSet =  set(nums)\\n        if len(nums) == len(numsSet):\\n            return False\\n        return True",
                "codeTag": "Unknown"
            },
            {
                "id": 2677785,
                "title": "python-1-liner",
                "content": "```\\ndef containsDuplicate(nums):\\n\\treturn len(set(nums)) != len(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef containsDuplicate(nums):\\n\\treturn len(set(nums)) != len(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 61076,
                "title": "in-python-this-problem-is-a-joke",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @return {boolean}\\n        def containsDuplicate(self, nums):\\n            return not (len(nums) == len(set(nums)))",
                "solutionTags": [],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 60909,
                "title": "c-solution-simply-one-line",
                "content": "    class Solution {\\n      public:\\n        bool containsDuplicate(vector<int>& nums) {\\n            return set<int>(nums.begin(), nums.end()).size() < nums.size();\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n      public:\\n        bool containsDuplicate(vector<int>& nums) {\\n            return set<int>(nums.begin(), nums.end()).size() < nums.size();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3216138,
                "title": "best-c-3-solution-hash-table-two-pointers-brute-force-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Using Array(Two Nested Loop). Brute Force Approach.\\n2. Using Array + Sorting. Brute Better Approach.\\n3. Using Array + Hash Table. Optimized Approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N^2), where N is the size of the array(nums). As we check for possible pair, and the\\n    total number of pairs are : N*(N\\u20131)/2.\\n\\n    Space complexity : O(1), Constant space.\\n\\n    Using Array(Two Nested Loop). Brute Force Approach.\\n\\n    Note : this will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                if(nums[i] == nums[j]){\\n                    return ture;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(NlogN), Sorting creates the time complexity. Where N is the size of the array(nums).\\n\\n    Space complexity : O(1), Constant space.\\n\\n    Using Array + Sorting. Brute Better Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());\\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i] == nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Here loop creates the time complexity. Where N is the size of the array(nums).\\n\\n    Space complexity : O(N), Hash Table(unordered map) space.\\n\\n    Using Array + Hash Table. Optimized Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        unordered_map<long,long> map;   \\n        for(int i=0; i<nums.size(); i++){\\n            map[nums[i]]++;\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if(map[nums[i]] > 1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^2), where N is the size of the array(nums). As we check for possible pair, and the\\n    total number of pairs are : N*(N\\u20131)/2.\\n\\n    Space complexity : O(1), Constant space.\\n\\n    Using Array(Two Nested Loop). Brute Force Approach.\\n\\n    Note : this will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                if(nums[i] == nums[j]){\\n                    return ture;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(NlogN), Sorting creates the time complexity. Where N is the size of the array(nums).\\n\\n    Space complexity : O(1), Constant space.\\n\\n    Using Array + Sorting. Brute Better Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin() , nums.end());\\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i] == nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Here loop creates the time complexity. Where N is the size of the array(nums).\\n\\n    Space complexity : O(N), Hash Table(unordered map) space.\\n\\n    Using Array + Hash Table. Optimized Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        unordered_map<long,long> map;   \\n        for(int i=0; i<nums.size(); i++){\\n            map[nums[i]]++;\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if(map[nums[i]] > 1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500880,
                "title": "java-tc-o-n-sc-o-n-clean-concise-solution-using-hashset",
                "content": "```java\\n/**\\n * Using HashSet\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(N)\\n */\\nclass Solution1 {\\n    public boolean containsDuplicate(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n        if (nums.length <= 1) {\\n            return false;\\n        }\\n\\n        HashSet<Integer> found = new HashSet<>();\\n        for (int n : nums) {\\n            if (!found.add(n)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n/**\\n * Sort the array\\n *\\n * Time Complexity: O(N log N)\\n *\\n * Space Complexity: O(Space used by sorting algorithm)\\n */\\nclass Solution2 {\\n    public boolean containsDuplicate(int[] nums) {\\n        if (nums == null || nums.length < 2) {\\n            return false;\\n        }\\n\\n        Arrays.sort(nums);\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == nums[i - 1]) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Contains Duplicate question on LeetCode:\\n- [219. Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/discuss/1500887/Java-or-TC:-O(N)-or-SC:-O(min(N-K))-or-Sliding-Window-using-HashSet)\\n- [220. Contains Duplicate III](https://leetcode.com/problems/contains-duplicate-iii/discuss/1500895/Java-or-TC:-O(N)-or-SC:-O(min(NK))-or-Sliding-Window-using-Buckets)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```java\\n/**\\n * Using HashSet\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(N)\\n */\\nclass Solution1 {\\n    public boolean containsDuplicate(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n        if (nums.length <= 1) {\\n            return false;\\n        }\\n\\n        HashSet<Integer> found = new HashSet<>();\\n        for (int n : nums) {\\n            if (!found.add(n)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n/**\\n * Sort the array\\n *\\n * Time Complexity: O(N log N)\\n *\\n * Space Complexity: O(Space used by sorting algorithm)\\n */\\nclass Solution2 {\\n    public boolean containsDuplicate(int[] nums) {\\n        if (nums == null || nums.length < 2) {\\n            return false;\\n        }\\n\\n        Arrays.sort(nums);\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == nums[i - 1]) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61054,
                "title": "javascript-very-fast-solution",
                "content": "    var containsDuplicate = function(nums) {\\n        var obj = {};\\n        \\n        for(var i = 0; i < nums.length; i++){\\n            obj[nums[i]] = obj[nums[i]] + 1 || 1;\\n            \\n            if(obj[nums[i]] > 1) return true;\\n        }\\n        \\n        return false;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var containsDuplicate = function(nums) {\\n        var obj = {};\\n        \\n        for(var i = 0; i < nums.length; i++){\\n            obj[nums[i]] = obj[nums[i]] + 1 || 1;\\n            \\n            if(obj[nums[i]] > 1) return true;\\n        }\\n        \\n        return false;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3419018,
                "title": "3-best-swift-solutions-easy-to-understand",
                "content": "# First solution using Set\\n\\n## Approach\\nThis approach to solving the problem uses the property of sets in Swift that they cannot contain duplicates. Therefore, if we convert the given integer array `nums` to a set using `Set(nums)`, it will automatically remove any duplicate elements from `nums`. \\n\\nIf there are no duplicates in `nums`, the `count` of the set will be equal to the `count` of the original array, so `nums.count == Set(nums).count` will be `true`, and the function will return `false`. \\n\\nHowever, if there are duplicates in `nums`, the count of the set will be less than the count of the original array, so `nums.count != Set(nums).count` will be `true`, and the function will return `true`.\\n\\n## Complexity\\nThe time complexity of this approach is $$O(n)$$, where $$n$$ is the number of elements in the input array `nums`.\\n\\nThe space complexity of this approach is also $$O(n)$$, as the size of the set `Set(nums)` will be at most $$n$$ if there are no duplicates.\\n\\nTherefore, this approach has *linear time* and *space complexity*, which is efficient for an array of a moderate size.\\n\\n## Code\\n```swift\\nclass Solution {\\n    func containsDuplicate(_ nums: [Int]) -> Bool {\\n        nums.count != Set(nums).count\\n    }\\n}\\n```\\n\\n---\\n\\n# Second solution using Dictionary\\n\\n## Approach\\nThis approach uses a dictionary to keep track of the frequency of each element in the input array.\\n\\nThe function initializes an empty dictionary dict to keep track of the frequency of each element. It then loops through each element in the input array `nums`. For each element, it checks if the element is already in the dictionary or not. If the element is already in the dictionary, it means that it appears more than once in the array, so the function returns `true`. Otherwise, it adds the element to the dictionary with a value of `1`.\\n\\nIf the function has looped through all the elements in the array without finding any duplicates, it means that every element is distinct, so the function returns `false`.\\n\\n## Complexity\\nThis approach has a time complexity of $$O(n)$$ because it loops through each element in the array exactly once, and a space complexity of $$O(n)$$ because it creates a dictionary with at most $$n$$ key-value pairs, where $$n$$ is the length of the input array.\\n\\n## Code\\n```swift\\nclass Solution {\\n    func containsDuplicate(_ nums: [Int]) -> Bool {\\n        var dict = [Int: Int]()\\n\\n        for num in nums {\\n            if dict[num] != nil {\\n                return true\\n            } else {\\n                dict[num] = 1\\n            }\\n        }\\n\\n        return false\\n    }\\n}\\n```\\n\\n---\\n\\n# Third solution using Sorting\\n\\n## Approach\\nThe solution approach first sorts the given array `nums` using the `sorted()` method which arranges the elements in *ascending* order. Sorting the array makes it easier to identify duplicates as they will be placed next to each other after sorting.\\n\\nThen, the function iterates over the sorted array using a for-loop from the first element until the second last element. Within the loop, it compares the current element with the next element in the array. If they are equal, it means that there is a duplicate in the array and the function returns `true`.\\n\\nIf the for-loop completes its iteration without finding any duplicates, the function returns `false`, indicating that there are no duplicate elements in the array.\\n\\n## Complexity\\nThis approach has a time complexity of $$O(n \\\\cdot \\\\log n)$$ due to the sorting operation, where $$n$$ is the size of the input array.\\n\\nThe space complexity of the function is $$O(n)$$ due to the creation of a sorted version of the input array.\\n\\n## Code\\n```swift\\nclass Solution {\\n    func containsDuplicate(_ nums: [Int]) -> Bool {\\n        let sortedNums = nums.sorted()\\n\\n        for i in 0 ..< sortedNums.count - 1 {\\n            if sortedNums[i] == sortedNums[i + 1] {\\n                return true\\n            }\\n        }\\n\\n        return false\\n    }\\n}\\n```\\n\\n# Upvote ^_^\\n\\n![upvote.png](https://assets.leetcode.com/users/images/3fc71cb4-8ae5-4d42-8631-ca17c423afa8_1681550043.7428308.png)\\n\\n",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```swift\\nclass Solution {\\n    func containsDuplicate(_ nums: [Int]) -> Bool {\\n        nums.count != Set(nums).count\\n    }\\n}\\n```\n```swift\\nclass Solution {\\n    func containsDuplicate(_ nums: [Int]) -> Bool {\\n        var dict = [Int: Int]()\\n\\n        for num in nums {\\n            if dict[num] != nil {\\n                return true\\n            } else {\\n                dict[num] = 1\\n            }\\n        }\\n\\n        return false\\n    }\\n}\\n```\n```swift\\nclass Solution {\\n    func containsDuplicate(_ nums: [Int]) -> Bool {\\n        let sortedNums = nums.sorted()\\n\\n        for i in 0 ..< sortedNums.count - 1 {\\n            if sortedNums[i] == sortedNums[i + 1] {\\n                return true\\n            }\\n        }\\n\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1521790,
                "title": "4-solutions-in-python",
                "content": "1. Brute force \\nTime Complexity: O(n^2)  [It gets Time Limit Exceeded when n \\u226510^5] \\nSpace Complexity: O(1) \\n```\\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    return True\\n        return False\\n```\\n\\n2. use sort()\\nTime Complexity: O(n Log n)   \\nSpace Complexity: O(1) \\n```\\n        nums.sort()\\n        for i in range(1,len(nums)):\\n            if nums[i] == nums[i-1]:\\n                return True\\n        return False\\n```\\n\\n\\n3. use set()\\nTime Complexity: O(n)   \\nSpace Complexity: O(n) \\n```\\n            new_List = set()\\n            for i in range(len(nums)):\\n                if nums[i] in new_List:\\n                    return True\\n                new_List.add(nums[i])\\n            return False\\n```\\n\\n4. use hash Table\\nTime Complexity: O(n)   \\nSpace Complexity: O(n) \\n\\n```\\n# easy to understand\\n        hashTable = {}\\n        for i in range(len(nums)):\\n            if nums[i] not in hashTable:\\n                hashTable[nums[i]] = 1\\n            else:\\n                hashTable[nums[i]] += 1\\n        \\n        for i in range(len(nums)):\\n            if hashTable[nums[i]] >= 2:\\n                return True\\n        return False\\n```\\n\\n```\\n# more straightforward, similar to set(): \\n        hashTable = {}\\n        for i in range(len(nums)):\\n            if nums[i] not in hashTable:\\n                hashTable[nums[i]] = 1\\n            else:\\n                return True\\n        return False\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    return True\\n        return False\\n```\n```\\n        nums.sort()\\n        for i in range(1,len(nums)):\\n            if nums[i] == nums[i-1]:\\n                return True\\n        return False\\n```\n```\\n            new_List = set()\\n            for i in range(len(nums)):\\n                if nums[i] in new_List:\\n                    return True\\n                new_List.add(nums[i])\\n            return False\\n```\n```\\n# easy to understand\\n        hashTable = {}\\n        for i in range(len(nums)):\\n            if nums[i] not in hashTable:\\n                hashTable[nums[i]] = 1\\n            else:\\n                hashTable[nums[i]] += 1\\n        \\n        for i in range(len(nums)):\\n            if hashTable[nums[i]] >= 2:\\n                return True\\n        return False\\n```\n```\\n# more straightforward, similar to set(): \\n        hashTable = {}\\n        for i in range(len(nums)):\\n            if nums[i] not in hashTable:\\n                hashTable[nums[i]] = 1\\n            else:\\n                return True\\n        return False\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 60851,
                "title": "basic-48ms-c-solution-with-unordered-map",
                "content": "    class Solution {\\n    public:\\n        bool containsDuplicate(vector<int>& nums) {\\n            if (nums.empty()) { return false; }\\n            unordered_map<int,int> mp;\\n            for (int i : nums) {\\n                if (++mp[i] > 1) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool containsDuplicate(vector<int>& nums) {\\n            if (nums.empty()) { return false; }",
                "codeTag": "Java"
            },
            {
                "id": 60866,
                "title": "12ms-c-language-solution-with-in-house-hashset",
                "content": "    struct Node\\n    {\\n        int val;\\n        struct Node *next;\\n    };\\n    \\n    struct Set\\n    {\\n        int bucketSize;\\n        struct Node **table;\\n    };\\n    \\n    void initSet(struct Set *set, int bucketSize)\\n    {\\n        set->bucketSize = bucketSize;\\n        set->table = malloc(sizeof(struct Node*) * bucketSize);\\n        memset(set->table, 0, sizeof(struct Node*) * bucketSize);\\n    }\\n    \\n    bool addValue(struct Set *s, int val)\\n    {\\n        int idx = val > 0 ? val : -val;\\n        idx %= s->bucketSize;\\n        struct Node *ptr = s->table[idx];\\n        while(ptr != NULL)\\n        {\\n            if(ptr->val == val)\\n            {\\n                return false;\\n            }\\n        \\n            ptr = ptr->next;\\n        }\\n        ptr = malloc(sizeof(struct Node));\\n        ptr->val = val;\\n        ptr->next = s->table[idx];\\n        s->table[idx] = ptr;\\n        return true;\\n    }\\n    void releaseSet(struct Set *s)\\n    {\\n        struct Node *ptr, *tmp;\\n        for(int i = 0; i < s->bucketSize; ++i)\\n        {\\n            ptr = s->table[i];\\n            while(ptr != NULL)\\n            {\\n                tmp = ptr;\\n                ptr = ptr->next;\\n                free(tmp);\\n            }\\n        }\\n        free(s->table);\\n        s->table = NULL;\\n        s->bucketSize = 0;\\n    }\\n    bool containsDuplicate(int* nums, int numsSize) {\\n        if(numsSize < 2)\\n        {\\n            return false;\\n        }\\n        struct Set set;\\n        initSet(&set, numsSize / 2);\\n        for(int i = 0; i < numsSize; ++i)\\n        {\\n            if(!addValue(&set, nums[i]))\\n            {\\n                releaseSet(&set);\\n                return true;\\n            }\\n        }\\n        releaseSet(&set);\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    struct Node\\n    {\\n        int val;\\n        struct Node *next;\\n    };\\n    \\n    struct Set\\n    {\\n        int bucketSize;\\n        struct Node **table;\\n    };\\n    \\n    void initSet(struct Set *set, int bucketSize)\\n    {\\n        set->bucketSize = bucketSize;\\n        set->table = malloc(sizeof(struct Node*) * bucketSize);\\n        memset(set->table, 0, sizeof(struct Node*) * bucketSize);\\n    }\\n    \\n    bool addValue(struct Set *s, int val)\\n    {\\n        int idx = val > 0 ? val : -val;\\n        idx %= s->bucketSize;\\n        struct Node *ptr = s->table[idx];\\n        while(ptr != NULL)\\n        {\\n            if(ptr->val == val)\\n            {\\n                return false;\\n            }\\n        \\n            ptr = ptr->next;\\n        }\\n        ptr = malloc(sizeof(struct Node));\\n        ptr->val = val;\\n        ptr->next = s->table[idx];\\n        s->table[idx] = ptr;\\n        return true;\\n    }\\n    void releaseSet(struct Set *s)\\n    {\\n        struct Node *ptr, *tmp;\\n        for(int i = 0; i < s->bucketSize; ++i)\\n        {\\n            ptr = s->table[i];\\n            while(ptr != NULL)\\n            {\\n                tmp = ptr;\\n                ptr = ptr->next;\\n                free(tmp);\\n            }\\n        }\\n        free(s->table);\\n        s->table = NULL;\\n        s->bucketSize = 0;\\n    }\\n    bool containsDuplicate(int* nums, int numsSize) {\\n        if(numsSize < 2)\\n        {\\n            return false;\\n        }\\n        struct Set set;\\n        initSet(&set, numsSize / 2);\\n        for(int i = 0; i < numsSize; ++i)\\n        {\\n            if(!addValue(&set, nums[i]))\\n            {\\n                releaseSet(&set);\\n                return true;\\n            }\\n        }\\n        releaseSet(&set);\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 861276,
                "title": "python3-one-line-solution",
                "content": "```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    return len(set(nums)) != len(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n    return len(set(nums)) != len(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 856678,
                "title": "swift-one-liner",
                "content": "Swift one liner\\n```\\nclass Solution {\\n    func containsDuplicate(_ nums: [Int]) -> Bool {\\n        Set(nums).count != nums.count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func containsDuplicate(_ nums: [Int]) -> Bool {\\n        Set(nums).count != nums.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725096,
                "title": "c-solution-multiple-approaches-o-n",
                "content": "There are multiple approaches to solve this question. \\n\\n**APPROACH 1 : USING MAPS**\\nWe have to find out whether there is an element with a frequency >=2. \\nIf yes , we **return TRUE** .\\nElse , we **return FALSE**.\\n\\nSo , we create a map and store the frequency of each element in the map. \\nThen we can traverse the map to check if any key has a value >=2 . \\nIf yes , *return true* else , *return false*. \\n\\nAnother way is to compare the size of the map with the size of the array. \\nIf all the elements are unique , then , \\n\\t\\t**NUMS SIZE == SIZE OF THE MAP**  --> *RETURN FALSE*\\n\\telse *RETURN TRUE*\\n\\t\\n```\\n\\tclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int,int> a;\\n        for(auto &x:nums)\\n        {\\n            a[x]++;\\n        }\\n        \\n        for(auto &z:a)\\n        {\\n            if(z.second>=2)\\n                return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```\\n\\n**APPROACH 2 : FIND ALL THE UNIQUE ELEMENTS**\\nCreate a set and store all the unique elements of the array. \\nIf the set size == array size , this means all the elements are distinct and hence , occur only once.\\nSo , \\n\\t if(**set size == array size**)\\n\\t return false;\\n\\t else\\n\\t return true;\\n\\t \\n ```\\n\\t class Solution {\\n\\t\\tpublic:\\n\\t\\tbool containsDuplicate(vector<int>& nums) {\\n\\t\\t\\tset<int> a;\\n\\t\\t\\tfor(auto &x:nums)\\n\\t\\t\\ta.insert(x);\\n\\t\\t\\treturn (a.size()!=nums.size());\\n    }\\n};\\n```\\n\\n**APPROACH 3 : SORT THE ARRAY .**\\nAfter sorting the array , if any 2 adjacent elements are equal , this means that 1 value has a \\nfrequency>=2. \\nSo , \\n1. Sort the array.\\n2. If any 2 adjacent elements are equal , **return true**.\\n3. Else **return false**.\\n\\n```\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\tbool containsDuplicate(vector<int>& nums) {\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\tfor(int i=1;i<nums.size();i++)\\n\\t\\t\\t\\tif(nums[i]==nums[i-1])\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n    }\\n};\\n```\\n**THANKS FOR READING . HAVE A NICE DAY AND KEEP CODING !!**",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\n\\tclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int,int> a;\\n        for(auto &x:nums)\\n        {\\n            a[x]++;\\n        }\\n        \\n        for(auto &z:a)\\n        {\\n            if(z.second>=2)\\n                return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```\n```\\n\\t class Solution {\\n\\t\\tpublic:\\n\\t\\tbool containsDuplicate(vector<int>& nums) {\\n\\t\\t\\tset<int> a;\\n\\t\\t\\tfor(auto &x:nums)\\n\\t\\t\\ta.insert(x);\\n\\t\\t\\treturn (a.size()!=nums.size());\\n    }\\n};\\n```\n```\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\tbool containsDuplicate(vector<int>& nums) {\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\tfor(int i=1;i<nums.size();i++)\\n\\t\\t\\t\\tif(nums[i]==nums[i-1])\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2552285,
                "title": "go-multiple-solutions-in-go-golang",
                "content": "Hello gophers!\\n\\n# Problem: 217. Contains Duplicate (Easy)\\n\\n## Solutions\\n\\nFrom worst to best solutions!\\n\\n| Solution #       | Solution Name                                 | Time Complexity | Space Complexity |\\n|------------------|------------------------------------------------|-----------------|------------------|\\n| Solution 1 (Worst)       | Brute Force                                    | `O(n^2)`        | `O(1)`           |\\n| Solution 2       | Sorting                                        | `O(nlogn)`      | `O(logn)`           |\\n| Solution 3       | Using a `multiset`                             | `O(n)`          | `O(n)`           |\\n| Solution 4       | Another `multiset` solution                    | `O(n)`          | `O(n)`           |\\n| Solution 5 (Clean)       | Using a `set` with custom data structure       | `O(n)`          | `O(n)`           |\\n| Solution 6 (Interview)       | Using a `set` for interviews (No custom struct)| `O(n)`          | `O(n)`           |\\n\\n\\n### Solution1: Brute Force\\n\\nWe check every possible pairs! \\uD83D\\uDC80\\n\\nTime: `O(n^2)`\\nSpace: `O(1)`\\n\\n```go\\n// Time: O(n*n) = O(n^2)\\n// Space: O(1)\\nfunc containsDuplicate(nums []int) bool {\\n    // Time: O(n-1) = O(n)\\n    for i := 0; i < len(nums)-1; i++ {\\n        // Time: O(n-1) = O(n)\\n        for j := i+1; j < len(nums); j++ {\\n            if nums[i] == nums[j] {\\n                return true\\n            }\\n        }\\n    }\\n    return false\\n}\\n```\\n\\n### Solution 2: Sorting\\n\\nWe sort all nums and we check the pairs that are beside each others!\\n\\nTime: `O(nlogn)`\\nSpace: `O(logn)` (see `sort` pkg doc)\\n\\n```go\\n// Time: O(nlogn + n) = O(nlogn)\\n// Space: O(logn)\\nfunc containsDuplicate(nums []int) bool {\\n    if len(nums) <= 1 {\\n        return false\\n    }\\n    \\n    // Time: O(nlogn)\\n    // Space: O(logn)\\n    sort.Ints(nums)\\n    \\n    // Time: O(n)\\n    for i := 0; i < len(nums)-1; i++ {\\n        if nums[i] == nums[i+1] {\\n            return true\\n        }\\n    }\\n    \\n    return false\\n}\\n```\\n\\n### Solution 3: Using a `multiset`\\n\\nWe create a `multiset` (`map[num]occurence` where both `num` and `occurence` are `int`s).  \\nWhen the `multiset` is created, we checked if one of the `num` has more than one `occurence`.\\n\\nTime: `O(n)`\\nSpace: `O(n)`\\n\\n```go\\n// Time: O(n+n) = O(2n) = O(n)\\n// Space: O(n)\\nfunc containsDuplicate(nums []int) bool {\\n    // Space: O(n)\\n    set := NewMultiSet()\\n    \\n    // Time: O(n)\\n    set.AddNums(nums)\\n    \\n    // Time: O(n)\\n    for _, num := range nums {\\n        // Time: O(1)\\n        if set.HasDuplicate(num) {\\n            return true\\n        }\\n    }\\n    \\n    return false\\n}\\n\\ntype MultiSet struct {\\n    items map[int]int\\n}\\n\\nfunc NewMultiSet() *MultiSet {\\n    return &MultiSet{\\n        items: make(map[int]int),\\n    }\\n}\\n\\n// Time: O(n)\\n// Space: O(1)\\nfunc (s *MultiSet) AddNums(nums []int) {\\n    // Time: O(n)\\n    for _, num := range nums {\\n        // Time: O(1)\\n        s.AddNum(num)\\n    }\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc (s *MultiSet) AddNum(num int) {\\n    // Time: O(1)\\n    s.items[num]++\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc (s *MultiSet) OccurenceOf(num int) int {\\n    // Time: O(1)\\n    occ, ok := s.items[num]\\n    if !ok {\\n        return 0\\n    }\\n    return occ\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc (s *MultiSet) HasDuplicate(num int) bool {\\n    // Time: O(n)\\n    occ := s.OccurenceOf(num)\\n    return occ > 1\\n}\\n```\\n\\nWe could have also create\\n\\n```go\\n// Time: O(n)\\n// Space: O(n)\\nfunc BuildMultiSet(nums []int) *MultiSet {\\n    s := NewMultiSet()\\n    // Time: O(n)\\n    // Space: O(n)\\n    s.Add(nums)\\n    return s\\n}\\n```\\n\\n### Solution 4: Another `multiset` solution\\n\\nor we could iterate over the map instead of the slice (same algorithm):\\n\\n```go\\n// Time: O(n+n) = O(2n) = O(n)\\n// Space: O(n)\\nfunc containsDuplicate(nums []int) bool {\\n    // Space: O(n)\\n    set := NewMultiSet()\\n    \\n    // Time: O(n)\\n    set.AddNums(nums)\\n    \\n    // Time: O(n)\\n    return set.HasDuplicate()\\n}\\n\\ntype MultiSet struct {\\n    items map[int]int\\n}\\n\\nfunc NewMultiSet() *MultiSet {\\n    return &MultiSet{\\n        items: make(map[int]int),\\n    }\\n}\\n\\n// Time: O(n)\\n// Space: O(1)\\nfunc (s *MultiSet) AddNums(nums []int) {\\n    // Time: O(n)\\n    for _, num := range nums {\\n        // Time: O(1)\\n        s.AddNum(num)\\n    }\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc (s *MultiSet) AddNum(num int) {\\n    // Time: O(1)\\n    s.items[num]++\\n}\\n\\n// Time: O(n)\\n// Space: O(1)\\nfunc (s *MultiSet) HasDuplicate() bool {\\n    // Time: O(n)\\n    for _, val := range s.items {\\n        // Time: O(1)\\n        if val > 1 {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```\\n\\n### Solution 5: Using a `set` with custom data structure\\n\\nWe don\\'t need to keep in memory the occurence.  \\nAs soon as we have a second occurence, we return true.  \\nThis mean we can use a `set` instead of a `multiset`!  \\nIn go, we usually implement a set with a `map[int]bool` or `map[int]struct{}`.\\n\\nTime: `O(n)`\\nSpace: `O(n)`\\n\\n```go\\n// Time: O(n)\\n// Space: O(n)\\nfunc containsDuplicate(nums []int) bool {\\n    // Space: O(n)\\n    set := NewSet()\\n    \\n    // Time: O(n)\\n    for _, num := range nums {\\n        // Time: O(1)\\n        if set.Has(num) {\\n            return true\\n        }\\n        // Time: O(1)\\n        set.Add(num)\\n    }\\n\\n    return false\\n}\\n\\ntype Set struct {\\n    items map[int]struct{}\\n}\\n\\nfunc NewSet() *Set{\\n    return &Set{\\n        items: make(map[int]struct{}),\\n    }\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc (s *Set) Add(val int) {\\n    // Time: O(1)\\n    s.items[val] = struct{}{}\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc (s *Set) Has(val int) bool {\\n    // Time: O(1)\\n    _, ok := s.items[val]\\n    return ok\\n}\\n```\\n\\n### Solution 6 : Using a `set` for interviews\\n\\nSolution `6`, but without a custom data structure and comments to save time! **This is the solution I would do if I was short on time**.  \\n\\nTime: `O(n)`\\nSpace: `O(n)`\\n\\n```go\\nfunc containsDuplicate(nums []int) bool {\\n    set := make(map[int]struct{})\\n    for _, num := range nums {\\n        if _, hasNum := set[num]; hasNum {\\n            return true\\n        }\\n        set[num] = struct{}{}\\n    }\\n    return false\\n}\\n```\\n\\n## `set` vs `multiset`\\n\\nSet:\\n- **Description**: Collection of distinct elements\\n- **Operations**: Insertion (if not present), Deletion, Membership testing\\n- **Go Implementation**: `set := make(map[ElementType]struct{})`\\n- **Examples**: Students in a class, Countries in the world\\n\\nMultiset (Bag)\\n- **Description**: Collection where elements can appear multiple times\\n- **Operations**: Insertion (anytime), Deletion (specific occurrence), Counting occurrences\\n- **Go Implementation**: `multiset := make(map[ElementType]int)` where `int` is the **occurence**\\n- **Examples**: Word frequency in a document, Fruit counts in a basket\\n\\n## Next problems\\n\\n- [219. Contains Duplicate II (Easy)](https://leetcode.com/problems/contains-duplicate-ii/) (see my solution [here](https://leetcode.com/problems/contains-duplicate-ii/discuss/1737679/Go-Sliding-Window-Clean-code-(100)))\\n- [220. Contains Duplicate III (Hard)](https://leetcode.com/problems/contains-duplicate-iii/) (my solution = WIP)\\n\\nI hope it helped! =)",
                "solutionTags": [
                    "Go",
                    "Ordered Set"
                ],
                "code": "```go\\n// Time: O(n*n) = O(n^2)\\n// Space: O(1)\\nfunc containsDuplicate(nums []int) bool {\\n    // Time: O(n-1) = O(n)\\n    for i := 0; i < len(nums)-1; i++ {\\n        // Time: O(n-1) = O(n)\\n        for j := i+1; j < len(nums); j++ {\\n            if nums[i] == nums[j] {\\n                return true\\n            }\\n        }\\n    }\\n    return false\\n}\\n```\n```go\\n// Time: O(nlogn + n) = O(nlogn)\\n// Space: O(logn)\\nfunc containsDuplicate(nums []int) bool {\\n    if len(nums) <= 1 {\\n        return false\\n    }\\n    \\n    // Time: O(nlogn)\\n    // Space: O(logn)\\n    sort.Ints(nums)\\n    \\n    // Time: O(n)\\n    for i := 0; i < len(nums)-1; i++ {\\n        if nums[i] == nums[i+1] {\\n            return true\\n        }\\n    }\\n    \\n    return false\\n}\\n```\n```go\\n// Time: O(n+n) = O(2n) = O(n)\\n// Space: O(n)\\nfunc containsDuplicate(nums []int) bool {\\n    // Space: O(n)\\n    set := NewMultiSet()\\n    \\n    // Time: O(n)\\n    set.AddNums(nums)\\n    \\n    // Time: O(n)\\n    for _, num := range nums {\\n        // Time: O(1)\\n        if set.HasDuplicate(num) {\\n            return true\\n        }\\n    }\\n    \\n    return false\\n}\\n\\ntype MultiSet struct {\\n    items map[int]int\\n}\\n\\nfunc NewMultiSet() *MultiSet {\\n    return &MultiSet{\\n        items: make(map[int]int),\\n    }\\n}\\n\\n// Time: O(n)\\n// Space: O(1)\\nfunc (s *MultiSet) AddNums(nums []int) {\\n    // Time: O(n)\\n    for _, num := range nums {\\n        // Time: O(1)\\n        s.AddNum(num)\\n    }\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc (s *MultiSet) AddNum(num int) {\\n    // Time: O(1)\\n    s.items[num]++\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc (s *MultiSet) OccurenceOf(num int) int {\\n    // Time: O(1)\\n    occ, ok := s.items[num]\\n    if !ok {\\n        return 0\\n    }\\n    return occ\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc (s *MultiSet) HasDuplicate(num int) bool {\\n    // Time: O(n)\\n    occ := s.OccurenceOf(num)\\n    return occ > 1\\n}\\n```\n```go\\n// Time: O(n)\\n// Space: O(n)\\nfunc BuildMultiSet(nums []int) *MultiSet {\\n    s := NewMultiSet()\\n    // Time: O(n)\\n    // Space: O(n)\\n    s.Add(nums)\\n    return s\\n}\\n```\n```go\\n// Time: O(n+n) = O(2n) = O(n)\\n// Space: O(n)\\nfunc containsDuplicate(nums []int) bool {\\n    // Space: O(n)\\n    set := NewMultiSet()\\n    \\n    // Time: O(n)\\n    set.AddNums(nums)\\n    \\n    // Time: O(n)\\n    return set.HasDuplicate()\\n}\\n\\ntype MultiSet struct {\\n    items map[int]int\\n}\\n\\nfunc NewMultiSet() *MultiSet {\\n    return &MultiSet{\\n        items: make(map[int]int),\\n    }\\n}\\n\\n// Time: O(n)\\n// Space: O(1)\\nfunc (s *MultiSet) AddNums(nums []int) {\\n    // Time: O(n)\\n    for _, num := range nums {\\n        // Time: O(1)\\n        s.AddNum(num)\\n    }\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc (s *MultiSet) AddNum(num int) {\\n    // Time: O(1)\\n    s.items[num]++\\n}\\n\\n// Time: O(n)\\n// Space: O(1)\\nfunc (s *MultiSet) HasDuplicate() bool {\\n    // Time: O(n)\\n    for _, val := range s.items {\\n        // Time: O(1)\\n        if val > 1 {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```\n```go\\n// Time: O(n)\\n// Space: O(n)\\nfunc containsDuplicate(nums []int) bool {\\n    // Space: O(n)\\n    set := NewSet()\\n    \\n    // Time: O(n)\\n    for _, num := range nums {\\n        // Time: O(1)\\n        if set.Has(num) {\\n            return true\\n        }\\n        // Time: O(1)\\n        set.Add(num)\\n    }\\n\\n    return false\\n}\\n\\ntype Set struct {\\n    items map[int]struct{}\\n}\\n\\nfunc NewSet() *Set{\\n    return &Set{\\n        items: make(map[int]struct{}),\\n    }\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc (s *Set) Add(val int) {\\n    // Time: O(1)\\n    s.items[val] = struct{}{}\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc (s *Set) Has(val int) bool {\\n    // Time: O(1)\\n    _, ok := s.items[val]\\n    return ok\\n}\\n```\n```go\\nfunc containsDuplicate(nums []int) bool {\\n    set := make(map[int]struct{})\\n    for _, num := range nums {\\n        if _, hasNum := set[num]; hasNum {\\n            return true\\n        }\\n        set[num] = struct{}{}\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 790062,
                "title": "c",
                "content": "A hashset is the most efficient way to check if a collection has duplicates in C#. Always remember this when you see descriptions asking to check for dupes, distinct things, pairs of socks, etc.  Sorting, on the other hand, is a very inneficient procedure and should be avoided if possible. HashSet.Add and .Remove methods will return false if element already exists, or not found, which can be used in a wide range of situations, replacing methods like List.Exists() or Array.IndexOf when checking collections.\\n```\\n    var hash=new HashSet<int>();\\n    foreach (var item in nums)\\n        if (!hash.Add(item)) return true;\\n    return false;\\n```",
                "solutionTags": [],
                "code": "```\\n    var hash=new HashSet<int>();\\n    foreach (var item in nums)\\n        if (!hash.Add(item)) return true;\\n    return false;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1782699,
                "title": "three-javascript-solutions-with-explanation",
                "content": "The first solution is based on sorting. We sort array elements, so that all of elements with the same value become adjacent. Then we iterate through the array and check if the adjacent elements are equal. If so, we found a duplicate.\\n\\nSorting takes up O(NLog(N)) time, iterating through the arrray takes O(N) time.\\nWe sort the array in-place, we do not create a new array, so it doesn\\'t take up any extra space.\\n\\n**Time complexity:** *O(NLog(N)) + O(N) = O(NLog(N))*\\n**Space complexity:** *O(1)*\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n   nums.sort();\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (nums[i] === nums[i + 1]) {\\n            return true;\\n        }\\n    }\\n    \\n    return false;\\n};\\n```\\n\\nThe next two solutions are based on [Set](https://tutorialedge.net/compsci/data-structures/sets-for-beginners/#:~:text=A%20set%20is%20a%20data,repeated%2C%20unique%20values%20within%20them.&text=We%20can%20then%20view%20these,the%20contents%20of%20our%20set.) data structure, which is akin to set in mathematics. Set can only contain unique elements and if the element appears more than once, it will be included only once.\\n\\nThe first solution iterartes through array and adds elements which we already saw, and if that element appears again we return true.\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n    const set = new Set();\\n    for (let i = 0; i < nums.length; i++) {\\n        if (set.has(nums[i])) {\\n            return true;\\n        }\\n        \\n        set.add(nums[i]);\\n    }\\n    \\n    return false;\\n};\\n```\\n\\nIn the worst case we need to traverse the whole array and also insert every element from the array in our set. Each set insertion is O(1), so inserting N elemnts will cost us O(N).\\nNew set can contain up to N elements in case there are no duplicates.\\n\\n**Time complexity:** *O(N) + O(N) = O(N)*\\n**Space complexity:** *O(N)*\\n\\nThe second solution creates a new set from an array of numbers and check that the length of this set is the same as the length of the array it was constructed from. If that\\'s not the case it means there is 1 or more duplicates and we return true.\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n    return (new Set(nums)).size !== nums.length;\\n};\\n```\\n\\nIn this case we just need to create a set from numbers that we are given.\\nConstructing a set has O(N) time complexity.\\nStorign each element from the numbers array in set has O(N) time complexity.\\n\\n**Time complexity:** *O(N)*\\n**Space complexity:** *O(N)*\\n\\nIf you found this useful, please upvote! If you have some comments or remarks, please leave them! Thank you.",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n   nums.sort();\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (nums[i] === nums[i + 1]) {\\n            return true;\\n        }\\n    }\\n    \\n    return false;\\n};\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n    const set = new Set();\\n    for (let i = 0; i < nums.length; i++) {\\n        if (set.has(nums[i])) {\\n            return true;\\n        }\\n        \\n        set.add(nums[i]);\\n    }\\n    \\n    return false;\\n};\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n    return (new Set(nums)).size !== nums.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1836662,
                "title": "faster-than-97-easy-to-read-one-liner",
                "content": "```\\npublic class Solution\\n{\\n    public bool ContainsDuplicate(int[] nums)\\n    {\\n        return new HashSet<int>(nums).Count < nums.Length;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public bool ContainsDuplicate(int[] nums)\\n    {\\n        return new HashSet<int>(nums).Count < nums.Length;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383485,
                "title": "javascript",
                "content": "```\\nvar containsDuplicate = function(nums) {\\n    return nums.length !== new Set(nums).size\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar containsDuplicate = function(nums) {\\n    return nums.length !== new Set(nums).size\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2381975,
                "title": "python-easily-understood-dp-faster-than-88-simple",
                "content": "Since transforming the nums from list to set can remove those duplicates, the length will be different if the list contains dupicates.\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(nums) != len(set(nums))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(nums) != len(set(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61055,
                "title": "5-lines-simple-java-solution",
                "content": "public class Solution {\\n    \\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        HashSet<Integer> flag = new HashSet<Integer>();\\n        \\n        for(int i : nums) {\\n            if(!flag.add(i)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        HashSet<Integer> flag = new HashSet<Integer>();\\n        \\n        for(int i : nums) {\\n            if(!flag.add(i)) {\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1490824,
                "title": "c-python",
                "content": "In this problem we\\'ve to find out an element whose frequency is **greater** than 1. We can do this problem by using two approaches:-\\n\\n\\n* 1:-\\nIn this approach, first we\\'ll sort the array, then we\\'ll check whether the two adjacent elements are equal or not. If we find out there are two adjacent elements that are equal, then we\\'ll return **true**, and if there are no such adjacent elements, then we\\'ll return **false**.\\n\\n   <iframe src=\"https://leetcode.com/playground/AQ5jq99H/shared\" frameBorder=\"0\" width=\"450\" height=\"255\"></iframe>\\n\\n  **Time Complexity:-** `O(nlogn)`\\n  **Space Complexity :-** `O(1)`\\n\\n* 2:-\\nIn this approach, we\\'ll store all the elements of array *nums* in a set. This set will store the unique elements of nums. Then we\\'ll compare the size of the set with size of array *nums*. \\n\\ti. If the size of set is **equal** to size of nums, then we\\'ll return **false**, because this means all the elements are unique in the array *nums*.\\n\\tii. If the size of set is **not equal** to size of nums, then we\\'ll return **true**.\\n\\t\\n\\n\\t<iframe src=\"https://leetcode.com/playground/RaixEqtk/shared\" frameBorder=\"0\" width=\"570\" height=\"160\"></iframe>\\n\\t\\n\\t**Time Complexity:-** `O(n)`\\n\\t**Space Complexity :-** `O(n)`\\n\\n**Checkout my github repository:- https://github.com/hassanrahim26/LEETCODE**",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C"
                ],
                "code": "In this problem we\\'ve to find out an element whose frequency is **greater** than 1. We can do this problem by using two approaches:-\\n\\n\\n* 1:-\\nIn this approach, first we\\'ll sort the array, then we\\'ll check whether the two adjacent elements are equal or not. If we find out there are two adjacent elements that are equal, then we\\'ll return **true**, and if there are no such adjacent elements, then we\\'ll return **false**.\\n\\n   <iframe src=\"https://leetcode.com/playground/AQ5jq99H/shared\" frameBorder=\"0\" width=\"450\" height=\"255\"></iframe>\\n\\n  **Time Complexity:-** `O(nlogn)`\\n  **Space Complexity :-** `O(1)`\\n\\n* 2:-\\nIn this approach, we\\'ll store all the elements of array *nums* in a set. This set will store the unique elements of nums. Then we\\'ll compare the size of the set with size of array *nums*. \\n\\ti. If the size of set is **equal** to size of nums, then we\\'ll return **false**, because this means all the elements are unique in the array *nums*.\\n\\tii. If the size of set is **not equal** to size of nums, then we\\'ll return **true**.\\n\\t\\n\\n\\t<iframe src=\"https://leetcode.com/playground/RaixEqtk/shared\" frameBorder=\"0\" width=\"570\" height=\"160\"></iframe>\\n\\t\\n\\t**Time Complexity:-** `O(n)`\\n\\t**Space Complexity :-** `O(n)`\\n\\n**Checkout my github repository:- https://github.com/hassanrahim26/LEETCODE**",
                "codeTag": "Unknown"
            },
            {
                "id": 174189,
                "title": "javascript-1-line",
                "content": "`Set` can only store unique values. So if `Set.size` is less than `nums.length` - there have been duplicates.\\n```\\nvar containsDuplicate = function(nums) {\\n    return (new Set(nums).size !== nums.length);    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar containsDuplicate = function(nums) {\\n    return (new Set(nums).size !== nums.length);    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3374283,
                "title": "easy-c-solution-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Just `sorted` the array.\\n- then used `two pointers` to check if they are equal at any point.\\n- if the are equal then return `true` other wise return `false`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## `Upvote! If you it helps :)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int i=0;\\n        int j=1;\\n        while(i<nums.size()-1 && j<nums.size()){\\n            if(nums[i] == nums[j]){\\n                return true;\\n            }\\n            i++;\\n            j++;\\n        }\\n        return false;\\n    }\\n};\\n```\\n![Upvote.jpeg](https://assets.leetcode.com/users/images/98c22f7e-e3a6-4ed7-b0ee-dcfd6d8a8e8a_1680519332.2082071.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int i=0;\\n        int j=1;\\n        while(i<nums.size()-1 && j<nums.size()){\\n            if(nums[i] == nums[j]){\\n                return true;\\n            }\\n            i++;\\n            j++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010587,
                "title": "c-two-line-solution",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public bool ContainsDuplicate(int[] nums) \\n    {\\n        HashSet<int> set = new HashSet<int>(nums);\\n        \\n        return nums.Length != set.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public bool ContainsDuplicate(int[] nums) \\n    {\\n        HashSet<int> set = new HashSet<int>(nums);\\n        \\n        return nums.Length != set.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084097,
                "title": "2-line-solution-with-rust-hashset",
                "content": "Simple solution with Rust using only 2 lines within the function.\\n\\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n        let mut exists = HashSet::new();\\n        !nums.into_iter().all(|n| exists.insert(n))\\n    }\\n}\\n```\\n\\n### Explanation\\n- `HashSet.insert` will return `true` if the inserted value does not yet exist in the set, otherwise false.\\n- Using this behaviour in an `Iter.all()` on the number list, it will return `true` if all the numbers are different and `false` if there is a duplicate number.\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n        let mut exists = HashSet::new();\\n        !nums.into_iter().all(|n| exists.insert(n))\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1818765,
                "title": "short-only-2-lines-sweet-typescript-solution-top-1-speed",
                "content": "## Solution\\n**Link to submission \\u2192  ([click here](https://leetcode.com/submissions/detail/653157243/))**\\n```typescript \\nfunction containsDuplicate(nums: number[]): boolean {\\n    const set = new Set<number>(nums);\\n    return (set.size < nums.length);\\n};\\n```\\n\\n### LeetCode output:\\n* Runtime: **76 ms**, faster than **99.50%** of TypeScript online submissions for Contains Duplicate.\\n* Memory Usage: **51.7 MB**, less than **22.17%** of TypeScript online submissions for Contains Duplicate.\\n\\n\\n\\n ### \\u261D\\uFE0F Considerations:\\n>  Although this solution is acceptable given the constraints, it is worth noting that as the input\\n>   *```nums```* grows larger in size, constructing a new Set object with an input array (*```nums```*, in this case) becomes increasingly less efficient.\\n>\\n> For larger input array sizes, it may be more performant to add to the set iteratively (see below)...\\n> \\n\\n## Solution (alt.)\\n**Link to submission \\u2192  ([click here](https://leetcode.com/submissions/detail/653717028/))**\\n```javascript\\n// javascript\\nvar containsDuplicate = function(nums) {\\n    let set = new Set();\\n    for (let x of nums) {\\n\\t\\t// short circuits the loop at the first instance of a duplicate\\n        if (set.has(x)) return true;\\n        set.add(x);\\n    }\\n    return false;\\n};\\n```\\n\\n### LeetCode output:\\n* Runtime: **76 ms**, faster than **98.71%** of JavaScript online submissions for Contains Duplicate.\\n* Memory Usage: **51.4 MB**, less than **22.30%** of JavaScript online submissions for Contains Duplicate.\\n\\n---\\n\\n## Explanation:\\nSource: [mdn web docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set#specifications)\\n### \\u301D\\n>  [In JavaScript] the ```Set``` object lets you **store unique values** of any type, whether primitive >values or object references.\\n>\\n> ### ...\\n>\\n>### Relationship with arrays:\\n>```javascript\\n>let myArray = [\\'value1\\', \\'value2\\', \\'value3\\']\\n> \\n> // Use the regular Set constructor to transform an Array into a Set\\n> let mySet = new Set(myArray)\\n>\\n> mySet.has(\\'value1\\')     // returns true\\n> \\n> // Use the spread operator to transform a set into an Array.\\n> console.log([...mySet]) // Will show you exactly the same Array as myArray\\n>\\n>```\\n>\\n###  \\u301E",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```typescript \\nfunction containsDuplicate(nums: number[]): boolean {\\n    const set = new Set<number>(nums);\\n    return (set.size < nums.length);\\n};\\n```\n```nums```\n```nums```\n```javascript\\n// javascript\\nvar containsDuplicate = function(nums) {\\n    let set = new Set();\\n    for (let x of nums) {\\n\\t\\t// short circuits the loop at the first instance of a duplicate\\n        if (set.has(x)) return true;\\n        set.add(x);\\n    }\\n    return false;\\n};\\n```\n```Set```\n```javascript\\n>let myArray = [\\'value1\\', \\'value2\\', \\'value3\\']\\n> \\n> // Use the regular Set constructor to transform an Array into a Set\\n> let mySet = new Set(myArray)\\n>\\n> mySet.has(\\'value1\\')     // returns true\\n> \\n> // Use the spread operator to transform a set into an Array.\\n> console.log([...mySet]) // Will show you exactly the same Array as myArray\\n>\\n>```",
                "codeTag": "Unknown"
            },
            {
                "id": 1632329,
                "title": "brute-force-and-optimal-approach-well-explained",
                "content": "* Brute-Sorting Approach\\n```\\nclass Solution {\\n    public  boolean containsDuplicate(int[] nums) { \\n        Arrays.sort(nums); // Sorting the array\\n        // Run a loop till end;\\n        for (int i =0 ; i<nums.length-1; i++){\\n            if(nums[i] == nums[i+1]) return true;\\n            // if the value of current index is equals to next index, then return true\\n        }\\n        return false; // otherwise return false  \\n\\t }\\n}\\n```\\n* Time Complexity = BigO(NlogN) as we are sorting\\n\\n* Space Complexity= BigO(1) as no memory used\\n\\n\\n \\n* HashSet Approach\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        // Created HashSet to store all different Integers\\n        Set<Integer> set = new HashSet<>();\\n        for (int i: nums){ // run loop till end\\n                if(!set.add(i))return true;// if we found the similar value which is already present in set, then no need to add simply return true;\\n            // as it mean\\'s the one of the same value is already over there\\n        }\\n        return false;// otherwise, return false\\n    }\\n}\\n```\\n* Time Complexity = BigO(N) where N is no of integers to traverse\\n\\n* Space Complexity = BigO(N) as for worse case it can add N no of nodes",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public  boolean containsDuplicate(int[] nums) { \\n        Arrays.sort(nums); // Sorting the array\\n        // Run a loop till end;\\n        for (int i =0 ; i<nums.length-1; i++){\\n            if(nums[i] == nums[i+1]) return true;\\n            // if the value of current index is equals to next index, then return true\\n        }\\n        return false; // otherwise return false  \\n\\t }\\n}\\n```\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        // Created HashSet to store all different Integers\\n        Set<Integer> set = new HashSet<>();\\n        for (int i: nums){ // run loop till end\\n                if(!set.add(i))return true;// if we found the similar value which is already present in set, then no need to add simply return true;\\n            // as it mean\\'s the one of the same value is already over there\\n        }\\n        return false;// otherwise, return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249813,
                "title": "100-faster-solution-0ms",
                "content": "```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int n : nums){\\n            if(!set.add(n)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\nIf you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int n : nums){\\n            if(!set.add(n)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894268,
                "title": "c-90-sort-solution-o-n-log-n-n",
                "content": "```\\nint cmp(const void *a, const void *b)\\n{\\n    return (*(int*)a - *(int*)b);\\n}\\n\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n    qsort(nums, numsSize, sizeof(int), cmp); \\n\\n    for (int i = 1; i < numsSize; i++)\\n        if (nums[i] == nums[i-1])\\n            return true;\\n\\n    return false;\\n}\\n```\\n\\n**If this was helpful, don\\'t hesitate to upvote! :)**\\nHave a nice day!",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint cmp(const void *a, const void *b)\\n{\\n    return (*(int*)a - *(int*)b);\\n}\\n\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n    qsort(nums, numsSize, sizeof(int), cmp); \\n\\n    for (int i = 1; i < numsSize; i++)\\n        if (nums[i] == nums[i-1])\\n            return true;\\n\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1025835,
                "title": "kotlin-1-line",
                "content": "```\\nfun containsDuplicate(nums: IntArray) = nums.size > nums.toSet().size\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun containsDuplicate(nums: IntArray) = nums.size > nums.toSet().size\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 61156,
                "title": "1-line-in-python",
                "content": "    return len(set(nums)) < len(nums)\\n\\nIt's not optimal solution (64 ms), however it simple and clear.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    return len(set(nums)) < len(nums)\\n\\nIt's not optimal solution (64 ms), however it simple and clear.",
                "codeTag": "Unknown"
            },
            {
                "id": 3097839,
                "title": "contains-duplicate-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        num2=set(nums)\\n        l1=len(nums)\\n        l2=len(num2)\\n        if(l1!=l2):\\n            return True\\n        else:\\n            return False\\n```\\nIf you find it helful, please give your valuable vote!!\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        num2=set(nums)\\n        l1=len(nums)\\n        l2=len(num2)\\n        if(l1!=l2):\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215124,
                "title": "python-solutions",
                "content": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        \\n        # Compare the length of array with the length of set of (array)\\n\\t\\t# Converting into set will automatically remove all the duplicates.\\n\\t\\t# That means if the length doesn\\'t match each other, it implies there is duplicate.\\n        # T: O(N)\\n        # S: O(N)\\n        \\n        return len(set(nums)) != len(nums)\\n    \\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        \\n        # Convert list into dictionary then check if there are more than \"two\" in values of dictionary.\\n        # T: O(N)\\n        # S: O(N)\\n        \\n        d = {}\\n        \\n        for num in nums:\\n            if num in d:\\n                d[num] += 1\\n            else:\\n                d[num] = 1\\n        \\n        for k, v in d.items():\\n            if v >= 2:\\n                return True\\n            \\n        return False\\n    \\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        \\n        # Convert list into dictionary by using Python library\\n        # T: O(N)\\n        # S: O(N)\\n        \\n        d = Counter(nums)\\n        \\n        for k,v in d.items():\\n            if v >= 2:\\n                return True\\n            \\n        return False\\n    \\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        \\n        # Bitwise operation gives 0 if there is duplicates. \\n        # For example, 1 ^ 1 will give you 0.\\n\\t\\t# 2 ^ 2 = 0\\n\\t\\t# 3 ^ 3 = 0\\n\\t\\t# 1 XOR 1 equals 0\\n\\t\\t# 1 XOR 0 equals 1\\n        # T: O(n log n)\\n        # S: O(1)\\n        \\n        if len(nums) == 0:\\n            return False\\n        \\n        # In-place sort.\\n        # Ex) [1,2,3,1] to [1,1,2,3]\\n        nums.sort()\\n        \\n        curr = nums[0]\\n        for i in range(1, len(nums)):\\n            if nums[i]^curr == 0:\\n                return True\\n            curr = nums[i]\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        \\n        # Compare the length of array with the length of set of (array)\\n\\t\\t# Converting into set will automatically remove all the duplicates.\\n\\t\\t# That means if the length doesn\\'t match each other, it implies there is duplicate.\\n        # T: O(N)\\n        # S: O(N)\\n        \\n        return len(set(nums)) != len(nums)\\n    \\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        \\n        # Convert list into dictionary then check if there are more than \"two\" in values of dictionary.\\n        # T: O(N)\\n        # S: O(N)\\n        \\n        d = {}\\n        \\n        for num in nums:\\n            if num in d:\\n                d[num] += 1\\n            else:\\n                d[num] = 1\\n        \\n        for k, v in d.items():\\n            if v >= 2:\\n                return True\\n            \\n        return False\\n    \\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        \\n        # Convert list into dictionary by using Python library\\n        # T: O(N)\\n        # S: O(N)\\n        \\n        d = Counter(nums)\\n        \\n        for k,v in d.items():\\n            if v >= 2:\\n                return True\\n            \\n        return False\\n    \\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        \\n        # Bitwise operation gives 0 if there is duplicates. \\n        # For example, 1 ^ 1 will give you 0.\\n\\t\\t# 2 ^ 2 = 0\\n\\t\\t# 3 ^ 3 = 0\\n\\t\\t# 1 XOR 1 equals 0\\n\\t\\t# 1 XOR 0 equals 1\\n        # T: O(n log n)\\n        # S: O(1)\\n        \\n        if len(nums) == 0:\\n            return False\\n        \\n        # In-place sort.\\n        # Ex) [1,2,3,1] to [1,1,2,3]\\n        nums.sort()\\n        \\n        curr = nums[0]\\n        for i in range(1, len(nums)):\\n            if nums[i]^curr == 0:\\n                return True\\n            curr = nums[i]\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222337,
                "title": "java-solution-from-pratik",
                "content": "**Solution 1: Linear Search Approach - Brute-Force Algorithm**\\n\\n**Time complexity** : O(N<sup>2</sup>). In the worst case, there are `n * (n + 1) / 2` pairs of integers to check. Therefore, the time complexity is O(N<sup>2</sup>).\\n**Space complexity** : `O(1)`. We only used constant extra space.\\n\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] A) {\\n        for (int i = 0; i < A.length; i++) {\\n            for (int j = i + 1; j < A.length; j++) {\\n                if (A[i] == A[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n**Solution 2: Sorting Approach**\\n\\n**Explanation**:\\n- If there are any duplicate integers, they will be consecutive after sorting.\\n- The implementation here modifies the original array by sorting it. In general, it is not a good practice to modify the input. We can also make a copy of input array and operate on the copy instead.\\n\\n**Algorithm**:\\n- This approach employs sorting algorithm. Since comparison sorting algorithm like `HeapSort` is known to provide `O(N log N)` worst-case performance, sorting is often a good PreProcessing step.\\n- After sorting, we can traverse the sorted array to find if there are any two consecutive duplicate elements.\\n\\n**Time complexity** : `O(N log N)`. Sorting is `O(N log N)` and the traversing is `O(N)`. The entire algorithm is dominated by the sorting step, which is `O(N log N)`.\\n**Space complexity** : `O(1)`. Space depends on the sorting implementation which, usually, costs `O(1)` auxiliary space if `HeapSort` is used.\\n\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] A) {\\n        Arrays.sort(A);\\n\\n        for (int i = 0; i < A.length - 1; i++) {\\n            if (A[i] == A[i + 1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n**Solution 3: Hash Table Approach Using Set**\\n\\n**Explanation**:\\n- Utilize a dynamic data structure that supports fast search and insert operations.\\n- For certain test cases with not very large `N`, the runtime of this method can be slower than Sorting Approach. The reason is hash table has some overhead in maintaining its property. \\n- We should keep in mind that real world performance can be different from what the Big-O notation says. The Big-O notation only tells us that for sufficiently large input, one will be faster than the other. Therefore, when `N` is not sufficiently large, an `O(N)` algorithm can be slower than an `O(N log N)` algorithm.\\n\\n**Algorithm**:\\n- Utilizing a data structure with faster search time will speed up the entire algorithm.\\n- There are many data structures commonly used as dynamic sets such as `Binary Search Tree` and `Hash Table`. \\n- The operations we need to support here are `search()` and `insert()`. \\n- For a self-balancing `Binary Search Tree` (`TreeSet` or `TreeMap` in Java), `search()` and `insert()` are both `O(log N)` time. For a `Hash Table` (`HashSet` or `HashMap` in Java), `search()` and `insert()` are both `O(1)` on average. Therefore, by using `Hash Table`, we can achieve linear time complexity for finding the duplicate in an unsorted array.\\n\\n**Time complexity** : `O(N)`. We do `search()` and `insert()` for `N` times and each operation takes a constant time.\\n**Space complexity** : `O(N)`. The space used by a hash table is linear with the number of elements in it.\\n\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] A) {\\n        Set<Integer> set = new HashSet<>();\\n\\n        for (int n : A) {\\n            if (set.contains(n)) {\\n                return true;\\n            } else {\\n                set.add(n);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean containsDuplicate(int[] A) {\\n        for (int i = 0; i < A.length; i++) {\\n            for (int j = i + 1; j < A.length; j++) {\\n                if (A[i] == A[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] A) {\\n        Arrays.sort(A);\\n\\n        for (int i = 0; i < A.length - 1; i++) {\\n            if (A[i] == A[i + 1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] A) {\\n        Set<Integer> set = new HashSet<>();\\n\\n        for (int n : A) {\\n            if (set.contains(n)) {\\n                return true;\\n            } else {\\n                set.add(n);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60991,
                "title": "java-9ms-solution-using-hashset-very-very-easy-version",
                "content": "    public boolean containsDuplicate(int[] nums) {\\n    \\tHashSet<Integer> set = new HashSet<Integer>();\\n    \\tfor(int i=0;i<nums.length;i++){\\n    \\t\\tif(!set.add(nums[i])) return true;\\n    \\t}\\n\\t\\treturn false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean containsDuplicate(int[] nums) {\\n    \\tHashSet<Integer> set = new HashSet<Integer>();\\n    \\tfor(int i=0;i<nums.length;i++){\\n    \\t\\tif(!set.add(nums[i])) return true;\\n    \\t}\\n\\t\\treturn false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2697900,
                "title": "c-java-python3-javascript-solutions-faster-than-93",
                "content": "C#,Java,Python3,JavaScript different solution with explanation\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-217-contains-duplicate-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-217-contains-duplicate-solution-and-explanation-en/)\\u2B50**\\n\\n**Example : C# Solution1 - HashSet ( \\u2B06To see other languages \\u2B06)**\\n```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        HashSet<int> hSet = new HashSet<int>();\\n        \\n        for(int i = 0;i<nums.Length;i++)\\n        {\\n            if(hSet.Contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hSet.Add(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n**Example : C# Solution2 - sort the array first**\\n```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        Array.Sort(nums);\\n        \\n        for(int i = 0;i<nums.Length-1;i++)\\n        {\\n            if(nums[i]==nums[i+1])\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n\\nIf you got any problem or want other programming language solution, please feel free to let me know.\\n\\n**\\uD83E\\uDDE1See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        HashSet<int> hSet = new HashSet<int>();\\n        \\n        for(int i = 0;i<nums.Length;i++)\\n        {\\n            if(hSet.Contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hSet.Add(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        Array.Sort(nums);\\n        \\n        for(int i = 0;i<nums.Length-1;i++)\\n        {\\n            if(nums[i]==nums[i+1])\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509447,
                "title": "c-python-one-line-solution",
                "content": "**C++ :**\\n\\n```\\nbool containsDuplicate(vector<int>& nums) {\\n\\treturn nums.size() != set(nums.begin(), nums.end()).size();\\n}\\n```\\n\\n**Python :**\\n\\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n\\treturn not len(nums) == len(set(nums))\\n```\\n        \\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nbool containsDuplicate(vector<int>& nums) {\\n\\treturn nums.size() != set(nums.begin(), nums.end()).size();\\n}\\n```\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n\\treturn not len(nums) == len(set(nums))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 61094,
                "title": "very-simple-c-solution",
                "content": "Sort and search\\n\\n    int comp (const void * a, const void * b) {\\n       return ( *(int*)a - *(int*)b );\\n    }\\n    \\n    \\n    bool containsDuplicate(int* nums, int numsSize) {\\n        // Sort\\n        qsort(nums, numsSize, sizeof(int), comp);\\n        \\n        // Loop\\n        for (int i = 0; i < numsSize - 1; i++) {\\n            if (nums[i] == nums[i+1]) return true;\\n        }\\n        \\n        return false;\\n    }",
                "solutionTags": [],
                "code": "Sort and search\\n\\n    int comp (const void * a, const void * b) {\\n       return ( *(int*)a - *(int*)b );\\n    }\\n    \\n    \\n    bool containsDuplicate(int* nums, int numsSize) {\\n        // Sort\\n        qsort(nums, numsSize, sizeof(int), comp);\\n        \\n        // Loop\\n        for (int i = 0; i < numsSize - 1; i++) {\\n            if (nums[i] == nums[i+1]) return true;\\n        }\\n        \\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1904169,
                "title": "java-solutions-100-efficiency-3-different-approaches",
                "content": "Java solutions, 100% efficiency, 3 different approaches\\n##### Please Upvote, If you like the solution.\\n\\n\\n\\n    class Solution {\\n\\tpublic boolean containsDuplicate(int[] nums) {\\n    \\n\\tHashSet<Integer> set = new HashSet<Integer>();\\t\\n\\tfor(int i:nums){\\n          \\n\\t\\t  if(set.contains(i)){ return true; }\\n\\t\\t  \\n            set.add(i);   \\n        }\\n        return false;\\n\\t\\t}\\n\\t}\\n\\n\\nRuntime: 6 ms\\nMemory Usage: 54.8 MB\\n\\n\\n\\n\\n\\tclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\nRuntime: 31 ms\\nMemory Usage: 71.9 MB\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic boolean containsDuplicate(int[] nums) {\\n\\t\\t   HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i<nums.length;i++){\\n\\t\\t\\t\\tif(!map.containsKey(nums[i])){\\n\\t\\t\\t\\t\\tmap.put(nums[i],1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(Map.Entry<Integer, Integer> entry: map.entrySet()){\\n\\t\\t\\t\\tif(entry.getValue()>1){\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\nRuntime: 46 ms\\nMemory Usage: 76.5 MB",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\tpublic boolean containsDuplicate(int[] nums) {\\n    \\n\\tHashSet<Integer> set = new HashSet<Integer>();\\t\\n\\tfor(int i:nums){\\n          \\n\\t\\t  if(set.contains(i)){ return true; }",
                "codeTag": "Java"
            },
            {
                "id": 1346854,
                "title": "javascript",
                "content": "we can create object in javascript and in JS object key will always be unique in nature so we can story array element as key in object and check if key exists already means element is duplicated.\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    let hashMap = {};\\n    \\n    for(let i=0;i<nums.length;i++){\\n        if(hashMap[nums[i]]){\\n            return true;\\n        }else{\\n            hashMap[nums[i]]=true\\n        }\\n    }\\n    return false\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar containsDuplicate = function(nums) {\\n    let hashMap = {};\\n    \\n    for(let i=0;i<nums.length;i++){\\n        if(hashMap[nums[i]]){\\n            return true;\\n        }else{\\n            hashMap[nums[i]]=true\\n        }\\n    }\\n    return false\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794517,
                "title": "c-simplest-one-liner-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        return (std::set<int>(nums.begin(), nums.end())).size() != nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        return (std::set<int>(nums.begin(), nums.end())).size() != nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980397,
                "title": "java-solved-using-multiple-6-approaches-brute-force-to-optimal-explained",
                "content": "\\tpublic class ContainsDuplicates {\\n\\n \\n\\n    /*approach 1: sort and see if two adjacent elements are equal\\n    * TC: O(nlogn) SC: O(1)\\n    * */\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){// run loop till nums.length-1 otherwise\\n                                        // you will get Indexoutofbound while doing nums[i]==nums[i+1] for last index\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /*approach 2: add elements to the set. if set already contains element then duplicate exists\\n     * TC: O(n) SC: O(n)\\n     * */\\n    public boolean containsDuplicateApproach2(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(!set.add(nums[i])){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /*approach 3: add elements to the map. if map frequency is greater then 1 return true\\n     * TC: O(n) SC: O(n)\\n     * */\\n    public boolean containsDuplicateApproach3(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                return true;\\n            } else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /*approach 4: using XOR property A^A=0 and 0^A=A\\n     * TC: O(n^2) SC: O(1)\\n     * */\\n    public boolean containsDuplicateApproach4(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if((nums[i]^nums[j])==0){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /*approach 5: brute force\\n     * TC: O(n^2) SC: O(1)\\n     * */\\n    public boolean containsDuplicateBruteForce(int[] nums) {\\n        for (int i = 0; i + 1 < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (nums[i] == nums[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\t/* using java stream api */\\n\\tpublic boolean containsDuplicateStreamApi(int[] nums) {\\n        return nums.length != Arrays.stream(nums)\\n                .distinct()\\n                .count();\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "\\tpublic class ContainsDuplicates {\\n\\n \\n\\n    /*approach 1: sort and see if two adjacent elements are equal\\n    * TC: O(nlogn) SC: O(1)\\n    * */\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){// run loop till nums.length-1 otherwise\\n                                        // you will get Indexoutofbound while doing nums[i]==nums[i+1] for last index\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /*approach 2: add elements to the set. if set already contains element then duplicate exists\\n     * TC: O(n) SC: O(n)\\n     * */\\n    public boolean containsDuplicateApproach2(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(!set.add(nums[i])){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /*approach 3: add elements to the map. if map frequency is greater then 1 return true\\n     * TC: O(n) SC: O(n)\\n     * */\\n    public boolean containsDuplicateApproach3(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                return true;\\n            } else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /*approach 4: using XOR property A^A=0 and 0^A=A\\n     * TC: O(n^2) SC: O(1)\\n     * */\\n    public boolean containsDuplicateApproach4(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if((nums[i]^nums[j])==0){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /*approach 5: brute force\\n     * TC: O(n^2) SC: O(1)\\n     * */\\n    public boolean containsDuplicateBruteForce(int[] nums) {\\n        for (int i = 0; i + 1 < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (nums[i] == nums[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\t/* using java stream api */\\n\\tpublic boolean containsDuplicateStreamApi(int[] nums) {\\n        return nums.length != Arrays.stream(nums)\\n                .distinct()\\n                .count();\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 61106,
                "title": "32-lines-in-c-by-hashtable-only-12ms",
                "content": "    typedef struct hashlist {\\n         int val;\\n         struct hashlist *next;\\n    }list;\\n    \\n    int containsDuplicate(int* nums, int numsSize) {\\n    \\tint i;\\n    \\tint mask = numsSize - 1;\\n    \\tlist *tmp[numsSize];\\n    \\tmemset(tmp, 0, sizeof(list*)*numsSize);\\n    \\tif(numsSize == 0 || numsSize == 1) {\\n    \\t\\treturn false;\\n    \\t}\\n    \\tfor(i=0; i < numsSize; i++) {\\n    \\t\\tint idx;\\n    \\t\\tlist *p;\\n    \\t\\tlist *node = malloc(sizeof(list));\\n    \\t\\tnode->val = *nums;\\n    \\t\\tidx = abs(*nums) % mask;\\t\\n    \\t\\tp = tmp[idx];\\n    \\t\\tnode->next = p;\\n    \\t\\ttmp[idx] = node;\\n    \\t\\twhile(p) {\\n    \\t\\t\\tif (p->val == node->val) {\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t\\t}\\n    \\t\\t\\tp = p->next;\\n    \\t\\t}\\n    \\t\\tnums++;\\n    \\t}\\n    \\treturn false;\\n    }",
                "solutionTags": [],
                "code": "    typedef struct hashlist {\\n         int val;\\n         struct hashlist *next;\\n    }list;\\n    \\n    int containsDuplicate(int* nums, int numsSize) {\\n    \\tint i;\\n    \\tint mask = numsSize - 1;\\n    \\tlist *tmp[numsSize];\\n    \\tmemset(tmp, 0, sizeof(list*)*numsSize);\\n    \\tif(numsSize == 0 || numsSize == 1) {\\n    \\t\\treturn false;\\n    \\t}\\n    \\tfor(i=0; i < numsSize; i++) {\\n    \\t\\tint idx;\\n    \\t\\tlist *p;\\n    \\t\\tlist *node = malloc(sizeof(list));\\n    \\t\\tnode->val = *nums;\\n    \\t\\tidx = abs(*nums) % mask;\\t\\n    \\t\\tp = tmp[idx];\\n    \\t\\tnode->next = p;\\n    \\t\\ttmp[idx] = node;\\n    \\t\\twhile(p) {\\n    \\t\\t\\tif (p->val == node->val) {\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t\\t}\\n    \\t\\t\\tp = p->next;\\n    \\t\\t}\\n    \\t\\tnums++;\\n    \\t}\\n    \\treturn false;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 2546139,
                "title": "3-different-python-solutions",
                "content": "\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) != len(nums)\\n```\\n\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        res = {}\\n        for i in nums:\\n            if i not in res:\\n                res[i] = 1\\n            else:\\n                return True\\n        return False\\n```\\n\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return set(collections.Counter(nums).values()) != set([1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) != len(nums)\\n```\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        res = {}\\n        for i in nums:\\n            if i not in res:\\n                res[i] = 1\\n            else:\\n                return True\\n        return False\\n```\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return set(collections.Counter(nums).values()) != set([1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188618,
                "title": "3-lines-of-code-with-explanation-simple-and-easy",
                "content": "# Easy and Simple code in just 3 line\\n**217. Contains Duplicate Solution:**\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        LinkedHashSet<Integer> set = new LinkedHashSet<Integer>();\\n        for (int i = 0; i < nums.length; i++) set.add(nums[i]);\\n        return set.size() != nums.length;\\n    }\\n}\\n```\\n**Explanation:**\\nUse LinkedHashSet to remove the duplicates \\nthen compare hashset size with array size.\\nreturn result...\\n\\n\\n**Happy Coding** \\uD83D\\uDE0A!!!\\nIf you get value from this, then show some love by ***upvoting*** it !!\\n",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        LinkedHashSet<Integer> set = new LinkedHashSet<Integer>();\\n        for (int i = 0; i < nums.length; i++) set.add(nums[i]);\\n        return set.size() != nums.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934190,
                "title": "python-3-approachs-easy-explanation-faster-than-97",
                "content": "# Please upvote if it helps\\n**1st approach**\\n- As we know, set in python store only unique value and removes duplicate\\n- So just return not( len(nums)==len(set(nums))\\n\\t- not ( length of nums == length of unique value)\\n\\t- not ( False )\\n\\t- will return True\\n\\t- else not (True)\\n\\t- will return False\\n\\tCode:\\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n        return not(len(nums)==len(set(nums)))\\n```\\n\\n**2nd Approach:**\\n- Declair a HashMap/Dictionary\\n- Check all the elements if it\\'s exist in hashmap or not.\\n\\t- If it exisits return True\\n\\t- If it doesn\\'t then, just set dic[element]= 1/any_value\\nNote: It\\'s the most efficient way.\\nCode: \\n\\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n        dic = {}\\n        \\n        for n in nums:\\n            if n in dic:\\n                return True\\n            else:\\n                dic[n]=1\\n```\\n**3rd Approach**\\n- Similiar to second approach just use set instead of dictionary\\nCode:\\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n        stack = set()\\n        for n in nums:\\n            if n in stack:\\n                return True\\n            else:\\n                stack.add(n)\\n            \\n        return False\\n```\\n\\n**4th approach**\\n- Sort the nums list\\n- Loop through the list return True if the nums[i]==nums[i+1] else False\\n\\nCode:\\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n        nums.sort()\\n\\n        for i in range(len(nums) - 1):\\n            if nums[i] - nums[i+1] == 0:\\n                return True\\n        \\n        return False\\n```\\n\\n## Leave a comment if you have any question.\\n\\n![image](https://assets.leetcode.com/users/images/f0b1e99d-9004-4d92-95d8-18dd55d86627_1649619264.0194342.png)\\n",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n        return not(len(nums)==len(set(nums)))\\n```\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n        dic = {}\\n        \\n        for n in nums:\\n            if n in dic:\\n                return True\\n            else:\\n                dic[n]=1\\n```\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n        stack = set()\\n        for n in nums:\\n            if n in stack:\\n                return True\\n            else:\\n                stack.add(n)\\n            \\n        return False\\n```\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n        nums.sort()\\n\\n        for i in range(len(nums) - 1):\\n            if nums[i] - nums[i+1] == 0:\\n                return True\\n        \\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 315147,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func containsDuplicate(_ nums: [Int]) -> Bool {\\n        return Set(nums).count != nums.count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func containsDuplicate(_ nums: [Int]) -> Bool {\\n        return Set(nums).count != nums.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257460,
                "title": "easiest-maths-problem-ever-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        x=set(nums)\\n        return not len(nums)==len(x)\\n        #please do upvote if found helpful.\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        x=set(nums)\\n        return not len(nums)==len(x)\\n        #please do upvote if found helpful.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007472,
                "title": "c-easy-approach-with-explanation-2-line-code",
                "content": "# Approach:\\n*  Creating a set\\n*  Insert all the values of the nums vector to set\\n*  Why using set? Because - >Set contains only unique values\\n*  If any value appears at least twice in the array then it will not store the value twice\\n*  Compare both the sizes of array and set\\n*  If both sizes are equal that means every element occurs once so return true\\n*  Otherwise return false.\\n\\n```\\n=> IF THE SOLUTION WAS USEFUL, THEN DO NOT FORGET TO UPVOTE!! \\u2714\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) \\n\\t{\\n        set<int> s;\\n\\t\\t\\n        s.insert(nums.begin(),nums.end()); \\n\\t\\t\\n        bool ans = nums.size()!=s.size();  \\n\\t\\t\\n        return ans;\\n        \\n    }\\n};\\n\\n=> IF THE SOLUTION WAS USEFUL, THEN DO NOT FORGET TO UPVOTE!! \\u2714",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) \\n\\t{\\n        set<int> s;\\n\\t\\t\\n        s.insert(nums.begin(),nums.end()); \\n\\t\\t\\n        bool ans = nums.size()!=s.size();  \\n\\t\\t\\n        return ans;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1678724,
                "title": "python-one-line-code",
                "content": "```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n\\treturn len(set(nums)) != len(nums)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n\\treturn len(set(nums)) != len(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1496268,
                "title": "python-98-speed-faster",
                "content": "```python\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) != len(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) != len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975497,
                "title": "xor-based-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nps: I know it can be solved with hashset in better time complexity but here I wanted to solve it with a different, xor approach\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nas we know when two equal numbers are xor\\'ed the output is zero,hence we will first sort array, if a duplicate element exist they would be adjacent,hence xor them and if output comes out as 0 return true. note that without sorting this won\\'t work as you would think of doing xor of all elements and checking for zero value along the way, but keep in mind that a similar number can be generated by xor which is already present in array giving us pseudo ans.\\n\\nfor ex-[1,2,3,4]\\nx=1^2=3\\nx=3^3=0\\nbut there is no duplicate that\\'s why it won\\'t work\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            if((nums[i]^nums[i+1])==0){\\n                return true;\\n            }\\n        }\\n      return false;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            if((nums[i]^nums[i+1])==0){\\n                return true;\\n            }\\n        }\\n      return false;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593840,
                "title": "simple-python3-solution-one-liner-easiest-using-set",
                "content": "***UPVOTE*** if it is helpful\\n``` \\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return False if len(nums)==len(list(set(nums))) else True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` \\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return False if len(nums)==len(list(set(nums))) else True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196197,
                "title": "python-one-liner",
                "content": "**Using dictionary**\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        seen = {}\\n        for i in range(len(nums)):\\n            seen[nums[i]] = seen.get(nums[i], 0) + 1\\n        \\n        for k, v in seen.items():\\n            if v > 1:\\n                return True\\n        return False\\n```\\n\\n**One-liner**\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return not len(nums) == len(set(nums))\\n```\\n\\n**Efficient** [Updated] \\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        temp = set()\\n        count = 0\\n        for num in nums:\\n            temp.add(num)\\n            count += 1\\n            if len(temp) != count:\\n                return True\\n        return False\\n```\\nPlease upvote if you find it helpful. Thank You",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        seen = {}\\n        for i in range(len(nums)):\\n            seen[nums[i]] = seen.get(nums[i], 0) + 1\\n        \\n        for k, v in seen.items():\\n            if v > 1:\\n                return True\\n        return False\\n```\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return not len(nums) == len(set(nums))\\n```\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        temp = set()\\n        count = 0\\n        for num in nums:\\n            temp.add(num)\\n            count += 1\\n            if len(temp) != count:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159583,
                "title": "c-solution-all-possible-approaches-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        \\n       // Brute Force Method   -> O(n^2)\\n        int n =nums.size();\\n       for(int i=0;i<n-1;i++)\\n       {\\n            for(int j=i+1;j<n;j++)\\n            {\\n               if(nums[i]==nums[j])return true\\n            }\\n        }\\n        return false;\\n        \\n        //Using Sort Function    -> O(nlogn)\\n       \\n      sort(nums.begin() , nums.end())\\n      for(int i=0;i<n;i++)\\n       if(nums[i]==nums[i+1])return true;\\n         return false;\\n        \\n        //Using Map      -> O(n)\\n     unordered_map<int,int> m;\\n     for(auto a: nums) m[a]++;\\n        for(auto a: m)\\n            if(a.second>1)return 1;\\n        return 0;\\n        \\n        //Using Sets     -> O(n)\\n        unordered_set<int> s;\\n        for(auto a:nums)s.insert(a);\\n        if(nums.size()==s.size())return false;\\n        return true;\\n       \\n        \\n        \\n    }\\n};\\n```\\nIf you really like this or it is helpfulto you, please UpVote",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        \\n       // Brute Force Method   -> O(n^2)\\n        int n =nums.size();\\n       for(int i=0;i<n-1;i++)\\n       {\\n            for(int j=i+1;j<n;j++)\\n            {\\n               if(nums[i]==nums[j])return true\\n            }\\n        }\\n        return false;\\n        \\n        //Using Sort Function    -> O(nlogn)\\n       \\n      sort(nums.begin() , nums.end())\\n      for(int i=0;i<n;i++)\\n       if(nums[i]==nums[i+1])return true;\\n         return false;\\n        \\n        //Using Map      -> O(n)\\n     unordered_map<int,int> m;\\n     for(auto a: nums) m[a]++;\\n        for(auto a: m)\\n            if(a.second>1)return 1;\\n        return 0;\\n        \\n        //Using Sets     -> O(n)\\n        unordered_set<int> s;\\n        for(auto a:nums)s.insert(a);\\n        if(nums.size()==s.size())return false;\\n        return true;\\n       \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1779939,
                "title": "simple-2-lines-of-c-hash-set-comments-for-beginners",
                "content": "```\\n bool containsDuplicate(vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(), nums.end());\\n     // property of set is only unique elements are allowed\\n\\t // it will add only unique elements\\n\\t // so, its size will always be less, if duplicates are there\\n\\t // and equal size means no duplicates\\n        return (s.size() != nums.size());\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n bool containsDuplicate(vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(), nums.end());\\n     // property of set is only unique elements are allowed\\n\\t // it will add only unique elements\\n\\t // so, its size will always be less, if duplicates are there\\n\\t // and equal size means no duplicates\\n        return (s.size() != nums.size());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1538157,
                "title": "c-3-solutions-easy-to-understand",
                "content": "Contains Duplicate - \\n\\n**1) One Line -**\\n\\n```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums)\\n     {\\n        return nums.size()!=set(nums.begin(),nums.end()).size();\\n     }  \\n};\\n```\\n\\n**2) Five Lines -**\\n\\n```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums)\\n    {\\n      sort(nums.begin(),nums.end());\\n      for(int i=1;i<nums.size();i++)\\n        {\\n          if(nums[i-1]==nums[i])\\n          return true;\\n        }\\n     return false;   \\n    } \\n};\\n```\\n\\n**3) Using Counter -**\\n\\n```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums)\\n    {\\n       int n=nums.size();\\n       sort(nums.begin(),nums.end());\\n       int cnt=1;\\n       for(int i=0;i<n-1;i++)\\n        {\\n          if(nums[i]==nums[i+1])\\n            {\\n              cnt++;\\n            }\\n        }\\n         if(cnt>1)\\n           {\\n             return true;\\n           }\\n        else\\n          {\\n            return false;  \\n          }\\n    } \\n};\\n```\\n\\nPlease comment if you have any doubt.\\nWill get back to you as soon as possible.\\n**UPVOTE if you find it useful!**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums)\\n     {\\n        return nums.size()!=set(nums.begin(),nums.end()).size();\\n     }  \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums)\\n    {\\n      sort(nums.begin(),nums.end());\\n      for(int i=1;i<nums.size();i++)\\n        {\\n          if(nums[i-1]==nums[i])\\n          return true;\\n        }\\n     return false;   \\n    } \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums)\\n    {\\n       int n=nums.size();\\n       sort(nums.begin(),nums.end());\\n       int cnt=1;\\n       for(int i=0;i<n-1;i++)\\n        {\\n          if(nums[i]==nums[i+1])\\n            {\\n              cnt++;\\n            }\\n        }\\n         if(cnt>1)\\n           {\\n             return true;\\n           }\\n        else\\n          {\\n            return false;  \\n          }\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726562,
                "title": "rust-solutions",
                "content": "### 1. Set-len\\n```Rust\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n        nums.len() > nums.iter().collect::<HashSet<_>>().len()\\n    }\\n}\\n```\\n\\n### 2. Linear Scan\\n```Rust\\nimpl Solution {\\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n        let len = nums.len();\\n        for i in 0..len {\\n            for j in (i + 1)..len {\\n                if nums[i] == nums[j] {\\n                    return true;\\n                }\\n            }\\n        }\\n        false\\n    }\\n}\\n```\\n\\n### 3. Set-contains\\n```Rust\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n        let mut set = HashSet::new();\\n        for n in nums {\\n            if set.contains(&n) {\\n                return true;\\n            } else {\\n                set.insert(n);\\n            }\\n        }\\n        false\\n    }\\n}\\n```\\n\\n### 4. Sort\\n```Rust\\nimpl Solution {\\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n        let mut nums = nums;\\n        nums.sort_unstable();\\n        for i in 1..nums.len() {\\n            if nums[i - 1] == nums[i] {\\n                return true;\\n            }\\n        }\\n        false\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```Rust\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n        nums.len() > nums.iter().collect::<HashSet<_>>().len()\\n    }\\n}\\n```\n```Rust\\nimpl Solution {\\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n        let len = nums.len();\\n        for i in 0..len {\\n            for j in (i + 1)..len {\\n                if nums[i] == nums[j] {\\n                    return true;\\n                }\\n            }\\n        }\\n        false\\n    }\\n}\\n```\n```Rust\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n        let mut set = HashSet::new();\\n        for n in nums {\\n            if set.contains(&n) {\\n                return true;\\n            } else {\\n                set.insert(n);\\n            }\\n        }\\n        false\\n    }\\n}\\n```\n```Rust\\nimpl Solution {\\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n        let mut nums = nums;\\n        nums.sort_unstable();\\n        for i in 1..nums.len() {\\n            if nums[i - 1] == nums[i] {\\n                return true;\\n            }\\n        }\\n        false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 258771,
                "title": "python-beats-100-o-n",
                "content": "Using the set function of python.\\n```\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        numSet = list(set(nums))\\n        return not (len(numSet) == len(nums))\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        numSet = list(set(nums))\\n        return not (len(numSet) == len(nums))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 200829,
                "title": "simple-java-solution",
                "content": "set.add(val) in java returns true if the val is not already present in the set and it returns false otherwise.\\n```class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int val : nums) {\\n            if(!set.add(val))\\n                return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int val : nums) {\\n            if(!set.add(val))\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 61142,
                "title": "one-line-52ms-python-solution",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @return {boolean}\\n        def containsDuplicate(self, nums):\\n            return len(set(nums)) != len(nums)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 3500516,
                "title": "solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225442,
                "title": "217-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can solve this problem using a hash set. We can iterate over the array and add each element to the hash set. If we encounter an element that is already in the hash set, we can return True, since it means that we have found a duplicate. If we finish iterating over the entire array and have not found a duplicate, we can return False.\\n\\nAlgorithm:\\n\\n1. Create an empty hash set.\\n2. Iterate over the array.\\n3. If an element is already in the hash set, return True.\\n4. Otherwise, add the element to the hash set.\\n5. If we finish iterating over the array and have not found a duplicate, return False.\\n\\n# Complexity\\n- Time complexity:\\nO(n) - We iterate over the array once.\\n\\n- Space complexity:\\n O(n) - We use a hash set to store the elements.\\n\\n# Code\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        # Create an empty hash set\\n        seen = set()\\n        # Iterate over the array\\n        for num in nums:\\n            # If an element is already in the hash set, return True\\n            if num in seen:\\n                return True\\n            # Otherwise, add the element to the hash set\\n            seen.add(num)\\n        # If we finish iterating over the array and have not found a duplicate, return False\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        # Create an empty hash set\\n        seen = set()\\n        # Iterate over the array\\n        for num in nums:\\n            # If an element is already in the hash set, return True\\n            if num in seen:\\n                return True\\n            # Otherwise, add the element to the hash set\\n            seen.add(num)\\n        # If we finish iterating over the array and have not found a duplicate, return False\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109031,
                "title": "without-using-hashing-in-java-onlycode",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632114,
                "title": "python-set-no-loop-solution",
                "content": "```\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        unique = set(nums)\\n        if len(unique) < len(nums):\\n            return True\\n        return False\\n```\\n\\t\\t\\nAbove solution converts the input array into a set inorder to remove the duplicates. Then, the length of set is compared to length of input array. If the array contained duplicates, then the length of set will be less than input array(return true).",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        unique = set(nums)\\n        if len(unique) < len(nums):\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583026,
                "title": "c-easiest-solution-100-best-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool containsDuplicate(vector<int>& nums) {\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\n\\t\\t\\tfor(int i=1;i<nums.size();i++){\\n\\t\\t\\t\\tif(nums[i]==nums[i-1]){\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t};\\n\\t\\n**Upvote if you liked the solution\\uD83D\\uDE42**",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool containsDuplicate(vector<int>& nums) {\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\n\\t\\t\\tfor(int i=1;i<nums.size();i++){\\n\\t\\t\\t\\tif(nums[i]==nums[i-1]){\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2403618,
                "title": "rust-one-liner",
                "content": "```rust\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\n\\nimpl Solution {\\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n        nums.len() != HashSet::<i32>::from_iter(nums).len()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\n\\nimpl Solution {\\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n        nums.len() != HashSet::<i32>::from_iter(nums).len()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2141805,
                "title": "c-java-c-c-javascript-python-possible-solutions-easy-to-understand",
                "content": "To solve this problem, we can use a HashSet in C#. This data structure allows us to efficiently identify whether an element has been previously encountered in the array by using the Add or Contains methods. By adding each element to the HashSet as we iterate through the array, we can quickly determine if a duplicate element is encountered. This approach is simple and effective, making it a useful solution for this problem.\\n\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n         return nums.size() > set<int>(nums.begin(), nums.end()).size(); \\n    }\\n};\\n```\\n```Java []\\n// 1. \\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> Secondary = new HashSet<Integer>();\\n\\t\\t for(int i : nums)\\n\\t\\t\\t if(!Secondary.add(i))\\n\\t\\t\\t\\t return true; \\n\\t\\t return false;\\n    }\\n}\\n// 2. \\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n         return nums.length != Arrays.stream(nums)\\n                .distinct()\\n                .count();\\n    }\\n}\\n```\\n```csharp []\\n// 1. \\n//Count all the unique elements in the array and checks its equality with the size of the array. Time complexity: O(N), memory: O(N)\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        HashSet<int> secondary = new HashSet<int>();\\n        int counter = 0;\\n        for (int i = 0; i < nums.Length; i++) {\\n\\t\\t\\t if (secondary.Add(nums[i]))\\n\\t\\t\\t\\tcounter++;                                       \\n        }\\n        if(counter == nums.Length)\\n\\t\\t\\treturn false;\\n        return true;\\n    }\\n}\\n// 2. \\n// A more optimized solution is to end the loop as soon as the element is repeated. Time complexity: O(N), memory: O(N)\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        HashSet<int> distinct = new HashSet<int>();\\n        for (int i = 0; i < nums.Length; i++) {\\n            if (distinct.Contains(nums[i]))\\n                return true;\\n            distinct.Add(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n// 3. \\n// Another solution approach can by using sorted array. Time complexity: O(N lg N), memory: O(1) - not counting the memory used by sort\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n\\t\\tArray.Sort(nums);\\n        HashSet<int> secondary = new HashSet<int>();\\n            for (int i = 0; i < nums.Length; i++)\\n                if (!secondary.Add(nums[i]))                  \\n                    return true;            \\n        return false;  \\n    }\\n}\\n```\\n-------\\n```C []\\nstatic int _cmp(const int *l, const int *r) { \\n    return (*l - *r); \\n}\\nbool containsDuplicate(int* nums, int numsSize) {\\n    qsort(nums, numsSize, sizeof(int), _cmp);\\n    for (int i = 1; i < numsSize; ++i) {\\n        if (nums[i] == nums[i - 1]) return true;\\n    }\\n    return false;\\n}\\n```\\n```javascript []\\nvar containsDuplicate = function(nums) {\\n    let hashMap = {};\\n    for(let i=0;i<nums.length;i++) {\\n        if(hashMap[nums[i]])\\n            return true;\\n        else\\n            hashMap[nums[i]]=true;\\n    }\\n    return false\\n};\\n```\\n```Python []\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        return len(nums) > len(set(nums))\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n         return nums.size() > set<int>(nums.begin(), nums.end()).size(); \\n    }\\n};\\n```\n```Java []\\n// 1. \\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> Secondary = new HashSet<Integer>();\\n\\t\\t for(int i : nums)\\n\\t\\t\\t if(!Secondary.add(i))\\n\\t\\t\\t\\t return true; \\n\\t\\t return false;\\n    }\\n}\\n// 2. \\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n         return nums.length != Arrays.stream(nums)\\n                .distinct()\\n                .count();\\n    }\\n}\\n```\n```csharp []\\n// 1. \\n//Count all the unique elements in the array and checks its equality with the size of the array. Time complexity: O(N), memory: O(N)\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        HashSet<int> secondary = new HashSet<int>();\\n        int counter = 0;\\n        for (int i = 0; i < nums.Length; i++) {\\n\\t\\t\\t if (secondary.Add(nums[i]))\\n\\t\\t\\t\\tcounter++;                                       \\n        }\\n        if(counter == nums.Length)\\n\\t\\t\\treturn false;\\n        return true;\\n    }\\n}\\n// 2. \\n// A more optimized solution is to end the loop as soon as the element is repeated. Time complexity: O(N), memory: O(N)\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        HashSet<int> distinct = new HashSet<int>();\\n        for (int i = 0; i < nums.Length; i++) {\\n            if (distinct.Contains(nums[i]))\\n                return true;\\n            distinct.Add(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n// 3. \\n// Another solution approach can by using sorted array. Time complexity: O(N lg N), memory: O(1) - not counting the memory used by sort\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n\\t\\tArray.Sort(nums);\\n        HashSet<int> secondary = new HashSet<int>();\\n            for (int i = 0; i < nums.Length; i++)\\n                if (!secondary.Add(nums[i]))                  \\n                    return true;            \\n        return false;  \\n    }\\n}\\n```\n```C []\\nstatic int _cmp(const int *l, const int *r) { \\n    return (*l - *r); \\n}\\nbool containsDuplicate(int* nums, int numsSize) {\\n    qsort(nums, numsSize, sizeof(int), _cmp);\\n    for (int i = 1; i < numsSize; ++i) {\\n        if (nums[i] == nums[i - 1]) return true;\\n    }\\n    return false;\\n}\\n```\n```javascript []\\nvar containsDuplicate = function(nums) {\\n    let hashMap = {};\\n    for(let i=0;i<nums.length;i++) {\\n        if(hashMap[nums[i]])\\n            return true;\\n        else\\n            hashMap[nums[i]]=true;\\n    }\\n    return false\\n};\\n```\n```Python []\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        return len(nums) > len(set(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628394,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n         return(len(set(nums))!=len(nums))\\n    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n         return(len(set(nums))!=len(nums))\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457561,
                "title": "python-one-line-solution-easy",
                "content": "```\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) != len(nums)\\n```\\nIt utilizes sets and if the length of set of array and length of original array is not equal, we can say that our array contains duplicate.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) != len(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 343102,
                "title": "solution-in-python-3-beats-100",
                "content": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n    \\treturn len(set(nums)) != len(nums)\\n\\t\\t\\n\\t\\t\\n- Python 3\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n    \\treturn len(set(nums)) != len(nums)\\n\\t\\t\\n\\t\\t\\n- Python 3\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 61111,
                "title": "python-set-36ms-o-n",
                "content": "    class Solution(object):\\n        def containsDuplicate(self, nums):\\n            s = set()\\n            for num in nums:\\n                if num in s: return True\\n                else: s.add(num)\\n            return False",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "    class Solution(object):\\n        def containsDuplicate(self, nums):\\n            s = set()\\n            for num in nums:\\n                if num in s: return True\\n                else: s.add(num)\\n            return False",
                "codeTag": "Java"
            },
            {
                "id": 3380086,
                "title": "4-line-solution-javascript-easy-explanation-99-71-beats",
                "content": "# What is **Set()** in Javascript\\nIn JavaScript, Set is a built-in object that allows you to store unique values of any type. A Set can be created by using the new keyword with the Set() constructor, and it can be initialized with an iterable object such as an array. When elements are added to a Set, it automatically removes any duplicates. Set objects have methods to add, remove, check for the existence of, and iterate over their elements.\\n\\n\\n# Explanation \\nThe containsDuplicate function takes an array of numbers called nums as its input.\\n\\nIt creates a new Set object called set that contains the same elements as the nums array.\\n\\nThe Set object automatically removes any duplicate values that are added to it. So, if the size of the set is equal to the length of the nums array, it means that all of the elements in the nums array are unique.\\n\\nIf the size of the set is not equal to the length of the nums array, it means that there is at least one duplicate element in the nums array.\\n\\nThe containsDuplicate function returns true if there are duplicates in the nums array, and false otherwise.\\n\\n# Complexity\\n- Time complexity:\\nO(n), where n is the length of the input array\\n\\n- Space complexity:\\nO(n), where n is the length of the input array, due to the creation of a Set object to store the unique elements\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n  const set = new Set(nums)\\n  if(set.size == nums.length){\\n      return false\\n  }  \\n  return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n  const set = new Set(nums)\\n  if(set.size == nums.length){\\n      return false\\n  }  \\n  return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3347093,
                "title": "contains-duplicate-made-simple",
                "content": "# Intuition\\nThe input we have will contain a set of numbers , possibly dublicates of existing numbers or perhabs all unique numbers , if we get the unique numbers and store them somewhere , we can then easily check if the number of unique elements we have is smaller than the actual length of the array.\\nSo , how do we get only a single occurance for each element ?\\n\\n# Approach\\nWe can use a hashset , which will store the distinct elements from the nums array in it , after doing so , we can check the number of elements we have inside our hashset , if it\\'s smaller than the length of the array , then that implies the set left out some duplicates out there , and that results in the array containing duplicate values.\\n\\nIf the count of elements in the set is equal to the array length then the array doesn\\'t contain any duplicates, which solves our problem !\\n\\n# Complexity\\n- Time complexity: O(n) \\nWhere n is the length of the input array nums , becuase the hashset constructor takes takes O(n) time to add the elements from the input array to the hashset.\\nThe Count property and the comparisions performed take constant time O(1) , so that doesn\\'t affect the overall time complexity.\\n\\n\\n\\n- Space complexity: O(n)\\nWhere n is the length of the input array nums , that\\'s because a hashset of size n is created to accomodate the unique elements from the received array.\\n# Code\\n```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        \\n        var uniqueNums = new HashSet<int>(nums);\\n\\n        if(uniqueNums.Count < nums.Length)\\n            return true;\\n        else\\n            return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        \\n        var uniqueNums = new HashSet<int>(nums);\\n\\n        if(uniqueNums.Count < nums.Length)\\n            return true;\\n        else\\n            return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965652,
                "title": "there-is-no-shorter-1-line-of-code-and-simpler-for-beginners-solution-like-this-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n    return new Set(nums).size !== nums.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n    return new Set(nums).size !== nums.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2727168,
                "title": "o-n-c-solution-easy-to-understand-92-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> umap;\\n        for (int i = 0; i < nums.size(); i++)\\n            if (++umap[nums[i]] == 2) return true;\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> umap;\\n        for (int i = 0; i < nums.size(); i++)\\n            if (++umap[nums[i]] == 2) return true;\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478270,
                "title": "easy-javascript-solution-faster-than-99-88",
                "content": "var containsDuplicate = function(nums){\\n    if(nums.length == 1)\\n        return false\\n    let set = new Set(nums)\\n    if(nums.length > set.size)\\n        return true\\n    return false    \\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var containsDuplicate = function(nums){\\n    if(nums.length == 1)\\n        return false\\n    let set = new Set(nums)\\n    if(nums.length > set.size)\\n        return true\\n    return false    \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2376162,
                "title": "c-92-faster",
                "content": "```\\npublic bool ContainsDuplicate(int[] nums) {\\n\\tif (nums.Distinct().Count() == nums.Length)\\n\\t\\treturn false;\\n\\treturn true; \\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\npublic bool ContainsDuplicate(int[] nums) {\\n\\tif (nums.Distinct().Count() == nums.Length)\\n\\t\\treturn false;\\n\\treturn true; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2019031,
                "title": "two-line-c-solution-most-optimal-two-approaches",
                "content": "**Approach 1:**  Using sorting. Time: O(nlogn)    Space: O(1)\\n```\\nbool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i] == nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```\\n\\n**Approach 2:** Using hash set . This takes less time than the above code but takes more memory. \\n**Idea:** If we make a set form array then the size will not be same if the array contains atleast one repeating element.\\nTime: O(n)    Space : O(n)\\n```\\nbool containsDuplicate(vector<int>& nums) {\\n        unordered_set<int> hsh(nums.begin(), nums.end());\\n        return !(nums.size() == hsh.size());\\n    }\\n```\\n\\n*Please upvote if you liked the solutions*",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nbool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i] == nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```\n```\\nbool containsDuplicate(vector<int>& nums) {\\n        unordered_set<int> hsh(nums.begin(), nums.end());\\n        return !(nums.size() == hsh.size());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1703567,
                "title": "2-line-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(),nums.end());\\n        return !(s.size()==nums.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(),nums.end());\\n        return !(s.size()==nums.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591505,
                "title": "simple-one-line-solution-using-linq-c",
                "content": "```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        return nums.GroupBy(x=>x).Any(x=>x.Count() > 1);\\n    }\\n}",
                "solutionTags": [
                    "C#",
                    "Array"
                ],
                "code": "class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        return nums.GroupBy(x=>x).Any(x=>x.Count() > 1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1541530,
                "title": "3-different-c-solutions-using-stl-with-time-and-space-complexities",
                "content": "* Approach 1 : First sort the vector and then check if any two adjacent elements are equal.\\nTime Complexity :- O(nlogn)\\nSpace Complexity :- O(1)\\n```\\n\\t\\tsort(nums.begin(), nums.end());\\n        for (int i = 1; i < nums.size(); i++)\\n            if (nums[i] == nums[i - 1]) return true;\\n        return false;\\n```\\n* STL version\\n```\\n\\t\\tsort(nums.begin(), nums.end());\\n        return adjacent_find(nums.begin(), nums.end()) != nums.end();\\n```\\n* Approach 2 : Convert the vector into hashset and check if the size is reduced.\\nTime Complexity :- O(n) for all cases\\nSpace Complexity :- O(n) for all cases\\n```\\n\\t\\tunordered_set<int> st(nums.begin(), nums.end());\\n        return nums.size() > st.size();\\n```\\n* One-liner\\n```\\n\\t\\treturn nums.size() > unordered_set(nums.begin(), nums.end()).size();\\n```\\n* Approach 3 : While inserting, check if we have encountered this number before\\nTime Complexity :- O(n) worst case [ ignoring unordered_set worst case i.e. assuming constant time insertions ]\\nSpace Complexity :- O(n) worst case\\n```\\n\\t\\tunordered_set<int> st;\\n        for (const int& i : nums) {\\n            if (st.count(i)) return true;\\n            st.insert(i);\\n        }\\n        return false;\\n```\\n* STL version\\n```\\n\\t\\tunordered_set<int> st;\\n        return any_of(nums.begin(), nums.end(), [&](const auto& num) { return !st.insert(num).second; });\\n```\\n\\nIf you have any doubts or suggestions, please feel free to comment.\\nIf you find this solution useful, you know where the upvote is :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\t\\tsort(nums.begin(), nums.end());\\n        for (int i = 1; i < nums.size(); i++)\\n            if (nums[i] == nums[i - 1]) return true;\\n        return false;\\n```\n```\\n\\t\\tsort(nums.begin(), nums.end());\\n        return adjacent_find(nums.begin(), nums.end()) != nums.end();\\n```\n```\\n\\t\\tunordered_set<int> st(nums.begin(), nums.end());\\n        return nums.size() > st.size();\\n```\n```\\n\\t\\treturn nums.size() > unordered_set(nums.begin(), nums.end()).size();\\n```\n```\\n\\t\\tunordered_set<int> st;\\n        for (const int& i : nums) {\\n            if (st.count(i)) return true;\\n            st.insert(i);\\n        }\\n        return false;\\n```\n```\\n\\t\\tunordered_set<int> st;\\n        return any_of(nums.begin(), nums.end(), [&](const auto& num) { return !st.insert(num).second; });\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1128103,
                "title": "simple-python-solution-faster-than-95",
                "content": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums))!=len(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums))!=len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806966,
                "title": "easy-python-set-algorithm",
                "content": "**Easy Python | Set Algorithm**\\n\\nEasy Python solution iterating through every element in the input array \"A\"; checking in O(1) time if we had already seen each value \"x\" before. We return \"True\" the first time we detect a duplicate. If the loop ends without finding duplicates, we return \"False\".\\n\\nTime/Space Complexity: O(N)\\n\\n```\\nclass Solution:\\n    def containsDuplicate(self, A):\\n        D = set()\\n        for x in A:\\n            if x in D:\\n                return True\\n            D.add(x)\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, A):\\n        D = set()\\n        for x in A:\\n            if x in D:\\n                return True\\n            D.add(x)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538862,
                "title": "go",
                "content": "```\\nfunc containsDuplicate(nums []int) bool {\\n    set := make(map[int]struct{})\\n    for _, v := range nums {\\n        if _, ok := set[v]; ok {\\n            return true\\n        } else {\\n            set[v] = struct{}{}\\n        }\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc containsDuplicate(nums []int) bool {\\n    set := make(map[int]struct{})\\n    for _, v := range nums {\\n        if _, ok := set[v]; ok {\\n            return true\\n        } else {\\n            set[v] = struct{}{}\\n        }\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 60901,
                "title": "12ms-c-solution-with-hashtable",
                "content": "```\\n#define PRIME 941\\nstruct Data{\\n\\tint val;\\n\\tint empty;\\n\\tstruct Data *link;\\n}Hashtable[PRIME];\\n\\n\\nint containsDuplicate(int* nums, int numsSize) {\\n    int i;\\n    for(i=0;i<PRIME;i++)           //initialize hashtable\\n    {\\n    \\tHashtable[i].empty = 1;\\n    \\tHashtable[i].link = NULL;\\n    }\\n    for(i=0;i<numsSize;i++)\\n    {\\n        if(Hashtable[hash(nums[i])].empty == 1)\\n        {\\n\\t\\tHashtable[hash(nums[i])].val = nums[i];\\n\\t\\tHashtable[hash(nums[i])].empty = 0;\\n        }\\n        else if(Hashtable[hash(nums[i])].empty == 0)\\n        {\\n\\t\\tif(Hashtable[hash(nums[i])].val == nums[i])\\n\\t\\t\\treturn 1;\\n\\t\\t\\t\\n\\t\\tstruct Data *prev = &Hashtable[hash(nums[i])],*current;\\n\\t\\twhile(prev->link != NULL)\\n\\t\\t{\\n\\t\\t\\tprev = prev->link;\\n\\t\\t\\tif(prev->val == nums[i])\\n\\t\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tcurrent = (struct Data*)malloc(sizeof(struct Data));\\n\\t\\tcurrent->link = NULL;\\n\\t\\tcurrent->val = nums[i];\\n\\t\\tprev->link = current;\\n        }\\n    }\\n    return 0;\\n}\\n\\nint hash(int number)    //get hash value\\n{\\n\\treturn abs(number%PRIME);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n#define PRIME 941\\nstruct Data{\\n\\tint val;\\n\\tint empty;\\n\\tstruct Data *link;\\n}Hashtable[PRIME];\\n\\n\\nint containsDuplicate(int* nums, int numsSize) {\\n    int i;\\n    for(i=0;i<PRIME;i++)           //initialize hashtable\\n    {\\n    \\tHashtable[i].empty = 1;\\n    \\tHashtable[i].link = NULL;\\n    }\\n    for(i=0;i<numsSize;i++)\\n    {\\n        if(Hashtable[hash(nums[i])].empty == 1)\\n        {\\n\\t\\tHashtable[hash(nums[i])].val = nums[i];\\n\\t\\tHashtable[hash(nums[i])].empty = 0;\\n        }\\n        else if(Hashtable[hash(nums[i])].empty == 0)\\n        {\\n\\t\\tif(Hashtable[hash(nums[i])].val == nums[i])\\n\\t\\t\\treturn 1;\\n\\t\\t\\t\\n\\t\\tstruct Data *prev = &Hashtable[hash(nums[i])],*current;\\n\\t\\twhile(prev->link != NULL)\\n\\t\\t{\\n\\t\\t\\tprev = prev->link;\\n\\t\\t\\tif(prev->val == nums[i])\\n\\t\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tcurrent = (struct Data*)malloc(sizeof(struct Data));\\n\\t\\tcurrent->link = NULL;\\n\\t\\tcurrent->val = nums[i];\\n\\t\\tprev->link = current;\\n        }\\n    }\\n    return 0;\\n}\\n\\nint hash(int number)    //get hash value\\n{\\n\\treturn abs(number%PRIME);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 61003,
                "title": "c-one-liner",
                "content": "    public bool ContainsDuplicate(int[] nums) {\\n        return new HashSet<int>(nums).Count != nums.Length;\\n    }",
                "solutionTags": [],
                "code": "    public bool ContainsDuplicate(int[] nums) {\\n        return new HashSet<int>(nums).Count != nums.Length;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 61013,
                "title": "20ms-c-use-bitmap",
                "content": "    #define BITSPERWORD 32  \\n    #define SHIFT 5  \\n    #define MASK 0x1F  \\n    #define N 10000000  \\n    int a[1 + N/BITSPERWORD]; \\n    void set_(int i) {        a[i>>SHIFT] |=  (1<<(i & MASK)); }  \\n    void clr(int i) {        a[i>>SHIFT] &= ~(1<<(i & MASK)); }  \\n    int  test(int i){ return a[i>>SHIFT] &   (1<<(i & MASK)); }  \\n      \\n     \\n    class Solution {\\n        \\n    public:\\n        bool containsDuplicate(vector<int>& nums) {\\n            if(nums.size()==0)return false;\\n            int i;  \\n        for (i = 0; i < nums.size(); i++)  \\n            clr(nums[i]);    \\n        for (i = 0; i < nums.size(); i++)  \\n        {\\n            if(test(nums[i]))return true;\\n            else set_(nums[i]);  \\n        }\\n       return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n    public:\\n        bool containsDuplicate(vector<int>& nums) {\\n            if(nums.size()==0)return false;\\n            int i;  \\n        for (i = 0; i < nums.size(); i++)  \\n            clr(nums[i]);    \\n        for (i = 0; i < nums.size(); i++)  \\n        {\\n            if(test(nums[i]))return true;\\n            else set_(nums[i]);  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3038832,
                "title": "easy-4-line-approach-please-upvote-if-you-like-the-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        set<int> s;\\n        for(auto i:nums)\\n            s.insert(i);\\n\\n        if(s.size()!=nums.size()) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        set<int> s;\\n        for(auto i:nums)\\n            s.insert(i);\\n\\n        if(s.size()!=nums.size()) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802251,
                "title": "simple-solution-using-set",
                "content": "# Intuition\\nUsing set and it contains only unique elements \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n       set <int> s;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            s.insert(nums[i]);\\n        }\\n        if(s.size()<nums.size())\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n       set <int> s;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            s.insert(nums[i]);\\n        }\\n        if(s.size()<nums.size())\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702984,
                "title": "two-line-solution-clean-code",
                "content": "```\\nvar containsDuplicate = function(nums) {\\n    var unique = new Set(nums);\\n    return unique.size !== nums.length\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar containsDuplicate = function(nums) {\\n    var unique = new Set(nums);\\n    return unique.size !== nums.length\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2688614,
                "title": "python3-java-2-approach-easy-to-understand-well-explained",
                "content": "# Contains Duplicate\\n\\n#### Intusion: If all the elements are unique the length of set of element will be equal to the the length of the array. If they are not equal it means it contains duplicate.\\n\\n**Python3**\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) != len(nums)\\n        \\n```\\n**Java**\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int num: nums)\\n            set.add(num);\\n        // set.addAll(nums);\\n        return !(set.size() == nums.length);\\n    }\\n}\\n```\\n**S.C of O(N) for the set**\\n**T.C of O(1) for the length comparision + O(N) for set Creation, which is equal to O(N)**\\n****\\n\\n### Another way to solve this proble could be to sort the array and see if the adjacent elements are equal\\n\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        nums.sort()\\n        n = len(nums)\\n        for i in range(n-1):\\n            if (nums[i]==nums[i+1]):\\n                return True\\n        return False\\n```\\n\\n**S.C of O(1)**\\n**T.C of O(nlogn + n) for sort and linear traversal respectively. So overall time complexcity will be O(nlogn)**\\n",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) != len(nums)\\n        \\n```\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int num: nums)\\n            set.add(num);\\n        // set.addAll(nums);\\n        return !(set.size() == nums.length);\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        nums.sort()\\n        n = len(nums)\\n        for i in range(n-1):\\n            if (nums[i]==nums[i+1]):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674094,
                "title": "fast-solution-using-hashmap-with-logic-operation-with-explanation",
                "content": "\\t* class Solution {\\n\\t\\t\\tpublic boolean containsDuplicate(int[] nums) {\\n\\t\\t\\t\\tHashMap size = new HashMap(); \\n\\t\\t\\t\\tfor (int n : nums) {\\n\\t\\t\\t\\t\\tsize.put(n,null);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn size.size() != nums.length;\\n\\t\\t\\t}\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic boolean containsDuplicate(int[] nums) {\\n\\t\\t\\t\\tHashMap size = new HashMap(); \\n\\t\\t\\t\\tfor (int n : nums) {\\n\\t\\t\\t\\t\\tsize.put(n,null);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2555381,
                "title": "why-you-should-not-use-set-when-searching-for-duplicates-in-an-array",
                "content": "# The Problem\\n**Contains Duplicate**: Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\\n\\n## Solution using `set`\\n\\nYou might have seen the solution with `set ` touted as a one liner:\\n\\nIn Javascript:\\n\\n```javascript\\nvar containsDuplicate = function(nums) {\\n  return nums.length > (new Set(nums)).size;\\n};\\n```\\n\\n### Issues with using `set` for finding duplicates\\n\\n**The best case and the worst case are the same**:\\n\\nConsider an array with one billion elements that goes as `[1, 1, 2, 3, ...]`. As soon as you see the second element you know the answer:  duplicaters exist in the array. But if you use the above solution with `set` all the one billion elements will be processed. So what could be `O(2)` ends up being `O(n)`. \\n But you might say `O(2)` is `O(n)`; constant factors are ignored. Yes, but within reasonable limits. \\n\\n> A few words of caution about asymptotic notation are in order at this point. First, note that the use of the big-Oh and related notations can be somewhat misleading should the constant factors they \\u201Chide\\u201D be very large. For example, while it is true that the function 10^100 n is O(n), if this is the running time of an algorithm being compared to one whose running time is 10n log n, we prefer the O(n log n) time algorithm, even though the linear-time algorithm is asymptotically faster. This preference is because the constant factor, 10^100 , which is called \\u201Cone googol,\\u201D is believed by many astronomers to be an upper bound on the number of atoms in the observable universe. So we are unlikely to ever have a real-world problem that has this number as its input size. Thus, even when using the big-Oh notation, we should at least be somewhat mindful of the constant factors and lower order terms we are \\u201Chiding.\\u201D\\n> > Data Structures and Algorithms in C++,  Goodrich, Tamassia, Mount \\n\\n**It does not engage with the intentions of the question:**\\n\\nThe question is asked to test your problem solving ability not your knowledge of the standard library or built in functions of a programming language. While it is okay to use libraries or built in functions for some steps in the algorithm not directly related to the question you can\\'t skip the problem entirely by using a library or built in function.\\n\\n> The primary reason for using C is that I want to teach you data structures and algorithms from the ground up. When we want a hash table, we\\u2019ll build it ourselves. There will be no reliance on dictionaries or hashmaps or similar data structures of other languages. When we don\\u2019t know the maximum length of a string, we\\u2019ll build an extensible array: we won\\u2019t let the language handle memory allocation for us. **I want you to know exactly what\\u2019s going on, with no tricks up my sleeve**. Using C helps me toward this goal.\\n>> Algorithmic Thinking: A Problem-Based Introduction, Daniel Zingaro\\n\\nWhile you don\\'t have to use C or build everything by yourself, I hope you appreciate the intentions of the author.\\n\\n**Less code is not better:**\\n\\nWe are here to build effecient algorithms not play [code golf](https://en.wikipedia.org/wiki/Code_golf). While code golf can be a great [recreational activity](https://codegolf.stackexchange.com/) in itself it does not figure in learning algorithms. Code  that is easy to read and understand is better than shorter code.\\n\\nYou can read more about [code readability on wikipedia](https://en.wikipedia.org/wiki/Computer_programming#Readability_of_source_code).\\n\\n## Conclusion\\n\\nIt is easier to forget the interviewer when we grind on leetcode. Leetcode will gladly accept the solution with `set` but the interview might raise objects if their intention is to test you on hash tables or sorting. It\\'s not just about passing the test but engaging with the interviewer and understanding the intentions behind their questions. \\n\\nAlternate solution using a `map` in Javascript:\\n\\n```javascript\\nvar containsDuplicate = function(nums) {\\n  const seen = new Map();\\n  \\n  for(const num of nums) {\\n  /*\\n\\t  best case scenario:\\n\\t  does not process the whole array,\\n\\t  exits as soons as a duplicate is found\\n  */\\n    if(seen.get(num) === true) {\\n      return true;\\n    } else {\\n      seen.set(num, true);\\n    }\\n  }\\n  \\n  return false;\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```javascript\\nvar containsDuplicate = function(nums) {\\n  return nums.length > (new Set(nums)).size;\\n};\\n```\n```javascript\\nvar containsDuplicate = function(nums) {\\n  const seen = new Map();\\n  \\n  for(const num of nums) {\\n  /*\\n\\t  best case scenario:\\n\\t  does not process the whole array,\\n\\t  exits as soons as a duplicate is found\\n  */\\n    if(seen.get(num) === true) {\\n      return true;\\n    } else {\\n      seen.set(num, true);\\n    }\\n  }\\n  \\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2536972,
                "title": "python-3-sol-one-line",
                "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums))<len(nums)",
                "solutionTags": [],
                "code": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums))<len(nums)",
                "codeTag": "Java"
            },
            {
                "id": 2227993,
                "title": "python-easy",
                "content": "I remember Python has a set data structure)\\n\\n```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(nums) != len(set(nums))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(nums) != len(set(nums))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2031977,
                "title": "python-3-easy-solution",
                "content": "\\n\\n        if len(nums) == len(set(nums)):\\n            #example nums= [2,3,5,3]\\n            #len of nums is 4 and when you use set, set will take only once of the each element in array.\\n            #so with set(nums) will be [2,3,5] after that we will check if the length of the set and len(nums) are equal.\\n            return False\\n        else:\\n            return True",
                "solutionTags": [],
                "code": "\\n\\n        if len(nums) == len(set(nums)):\\n            #example nums= [2,3,5,3]\\n            #len of nums is 4 and when you use set, set will take only once of the each element in array.\\n            #so with set(nums) will be [2,3,5] after that we will check if the length of the set and len(nums) are equal.\\n            return False\\n        else:\\n            return True",
                "codeTag": "Unknown"
            },
            {
                "id": 1893521,
                "title": "3-methods-java-solution",
                "content": "Method 1: BRUTE FORCE \\n``` \\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        for(int i=0;i<nums.length-1;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\nMethod 2: SORTING\\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n      Arrays.sort(nums);\\n\\t  for(int i=0; i<nums.length-1;i++)\\n        {\\n            if(nums[i]==nums[i+1]) return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\nMethod 3: HASHSET\\n``` \\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> distinct = new HashSet<Integer>();\\n        for(int num : nums) {\\n            if(distinct.contains(num)) {\\n                return true;\\n            }\\n            distinct.add(num);\\n        }\\n        return false;\\n    }\\n}\\n```\\nDO UPVOTE!!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` \\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        for(int i=0;i<nums.length-1;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n      Arrays.sort(nums);\\n\\t  for(int i=0; i<nums.length-1;i++)\\n        {\\n            if(nums[i]==nums[i+1]) return true;\\n        }\\n        return false;\\n    }\\n}\\n```\n``` \\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> distinct = new HashSet<Integer>();\\n        for(int num : nums) {\\n            if(distinct.contains(num)) {\\n                return true;\\n            }\\n            distinct.add(num);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1657752,
                "title": "easiest-python3-solution",
                "content": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        a = set(nums)\\n        if len(a)!=len(nums):\\n            return True\\n        else: \\n            return False\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        a = set(nums)\\n        if len(a)!=len(nums):\\n            return True\\n        else: \\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1452827,
                "title": "python-contains-duplicate",
                "content": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return False if len(nums) == len(set(nums)) else True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return False if len(nums) == len(set(nums)) else True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1059554,
                "title": "python-one-line-beats-98-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return  len(set(nums)) != len(nums)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return  len(set(nums)) != len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 904845,
                "title": "kotlin-solution",
                "content": "Use a hashSet object, if the num already exists we already found a duplicated:\\n```\\nclass Solution {\\n    fun containsDuplicate(nums: IntArray): Boolean {\\n    val hashSet = HashSet<Int>()\\n    \\n    nums.forEach {\\n        if(!hashSet.add(it))\\n            return true\\n    }\\n    \\n    return false\\n}\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun containsDuplicate(nums: IntArray): Boolean {\\n    val hashSet = HashSet<Int>()\\n    \\n    nums.forEach {\\n        if(!hashSet.add(it))\\n            return true\\n    }\\n    \\n    return false\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 619056,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        \\n        unordered_set<int>s(nums.begin(), nums.end());\\n        \\n        return (s.size() != nums.size());\\n        \\n    }\\n};``\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        \\n        unordered_set<int>s(nums.begin(), nums.end());\\n        \\n        return (s.size() != nums.size());\\n        \\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60912,
                "title": "golang-concise-solution-using-map",
                "content": "```\\nfunc containsDuplicate(nums []int) bool {\\n\\tappearance := make(map[int]bool)\\n\\n\\tfor _, num := range nums {\\n\\t\\tif _, ok := appearance[num]; ok {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tappearance[num] = true\\n\\t}\\n\\treturn false\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc containsDuplicate(nums []int) bool {\\n\\tappearance := make(map[int]bool)\\n\\n\\tfor _, num := range nums {\\n\\t\\tif _, ok := appearance[num]; ok {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tappearance[num] = true\\n\\t}\\n\\treturn false\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 60984,
                "title": "simple-5-lines-7ms-java",
                "content": "Simple 5-liner using sort. You could implement your own sort and break when you find a duplicate making it faster.\\n\\n    public boolean containsDuplicate(int[] nums) {\\n\\tArrays.sort(nums);\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t    if (nums[i] == nums[i - 1])\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Simple 5-liner using sort. You could implement your own sort and break when you find a duplicate making it faster.\\n\\n    public boolean containsDuplicate(int[] nums) {\\n\\tArrays.sort(nums);\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t    if (nums[i] == nums[i - 1])\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 61120,
                "title": "simple-java-solution-using-hashset-o-n",
                "content": "    public class Solution {\\n        public boolean containsDuplicate(int[] nums) {\\n            Set<Integer> set = new HashSet<>();\\n            for(int i : nums){ set.add(i); }\\n            return nums.length!=0 && set.size()!=nums.length;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean containsDuplicate(int[] nums) {\\n            Set<Integer> set = new HashSet<>();\\n            for(int i : nums){ set.add(i); }",
                "codeTag": "Java"
            },
            {
                "id": 4062087,
                "title": "video-clear-visualization-of-o-n-solution",
                "content": "https://www.youtube.com/watch?v=JTIq3m8F4hw\\n\\nThe brute force approach would be to simply check each element with every other element in the array, and return `True` if a duplicate is found or `False` otherwise.  Unfortunately, this runs in O(n<sup>2</sup>).\\n\\nWe can reduce this to O(n) by using a hash set, or simply a `set()` in Python. For each element in the array, we\\'ll check to see if it is already in the set.  If it isn\\'t, we\\'ll add it to the set and move on, and if it is, then that means it is a duplicate and we\\'ll return `True`.  If we get through the whole array without finding a duplicate, we\\'ll return `False`\\n\\nThis runs in O(n) time because hash set lookup runs in O(1) time.  Similar to a hash table, when you need to check for a key in the set, you don\\'t have to iterate over all elements in the set.  Instead, the corresponding hash is calculated, and you can jump straight to it.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        num_set = set()\\n        for i in nums:\\n            if i in num_set:\\n                return True\\n            else:\\n                num_set.add(i)\\n        return False\\n  \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        num_set = set()\\n        for i in nums:\\n            if i in num_set:\\n                return True\\n            else:\\n                num_set.add(i)\\n        return False\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736588,
                "title": "easy-and-elegant-solution-using-hashset",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\n\\nThe solution uses a HashSet data structure to check for duplicate elements in the given array.\\n\\n# Approach\\n1. Create an empty HashSet called \\'st\\' to store the unique elements.\\n1. Iterate through each element in the array.\\n1. For each element, check if it already exists in the HashSet.\\n1. If it does, return true to indicate the presence of a duplicate.\\n1. If it doesn\\'t exist, add the element to the HashSet.\\n1. After checking all elements, return false to indicate that no duplicates were found.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this approach is $$O(n)$$, where n is the length of the input array. This is because we iterate through each element in the array once.\\n\\n\\n- Space complexity:\\nThe space complexity is also $$O(n)$$ in the worst case, where all elements in the array are unique. This is because the HashSet will store all n elements.\\n\\n# Code\\n```java []\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        // Create a HashSet to store unique elements\\n        HashSet<Integer> set = new HashSet<>();\\n\\n        // Iterate through the array\\n        for (int i = 0; i < nums.length; i++) {\\n            // Check if the element is already in the HashSet\\n            if (set.contains(nums[i])) {\\n                return true; // Found a duplicate\\n            } else {\\n                set.add(nums[i]); // Add the element to the HashSet\\n            }\\n        }\\n        return false; // No duplicates found\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\n        # Create an empty set to store unique elements\\n        st = set()\\n\\n        # Iterate through each element in the array\\n        for num in nums:\\n            # Check if the element already exists in the set\\n            if num in st:\\n                return True  # Duplicate found, return True\\n            else:\\n                st.add(num)  # Add the element to the set\\n\\n        return False  # No duplicates found, return False\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // Create an empty set to store unique elements\\n        unordered_set<int> st;\\n\\n        // Iterate through each element in the array\\n        for (int num : nums) {\\n            // Check if the element already exists in the set\\n            if (st.find(num) != st.end()) {\\n                return true;  // Duplicate found, return true\\n            } else {\\n                st.insert(num);  // Add the element to the set\\n            }\\n        }\\n\\n        return false;  // No duplicates found, return false\\n    }\\n};\\n```\\n## ***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/661ff5b1-ca20-4a6c-b4bd-9c763646f18e_1688822668.3935153.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Hash Table"
                ],
                "code": "```java []\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        // Create a HashSet to store unique elements\\n        HashSet<Integer> set = new HashSet<>();\\n\\n        // Iterate through the array\\n        for (int i = 0; i < nums.length; i++) {\\n            // Check if the element is already in the HashSet\\n            if (set.contains(nums[i])) {\\n                return true; // Found a duplicate\\n            } else {\\n                set.add(nums[i]); // Add the element to the HashSet\\n            }\\n        }\\n        return false; // No duplicates found\\n    }\\n}\\n\\n```\n```python []\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\n        # Create an empty set to store unique elements\\n        st = set()\\n\\n        # Iterate through each element in the array\\n        for num in nums:\\n            # Check if the element already exists in the set\\n            if num in st:\\n                return True  # Duplicate found, return True\\n            else:\\n                st.add(num)  # Add the element to the set\\n\\n        return False  # No duplicates found, return False\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // Create an empty set to store unique elements\\n        unordered_set<int> st;\\n\\n        // Iterate through each element in the array\\n        for (int num : nums) {\\n            // Check if the element already exists in the set\\n            if (st.find(num) != st.end()) {\\n                return true;  // Duplicate found, return true\\n            } else {\\n                st.insert(num);  // Add the element to the set\\n            }\\n        }\\n\\n        return false;  // No duplicates found, return false\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715609,
                "title": "2-best-methods-to-solve-c-sorting-maps",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n<!------- By Sorting ------>\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        int i=0;\\n        while(i<n-1){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};\\n\\n<!-------- Using Unordered Map -------->\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= nums.size();\\n        unordered_map<int,int> m;\\n        for(int i=0; i<n; i++){\\n            m[nums[i]]++;\\n        }\\n\\n        for(auto p : m){\\n            if(p.second>1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```\\n![4i5ri4f9.png](https://assets.leetcode.com/users/images/280cc0bf-e1b5-417b-a72d-4ba7e737f34f_1688448157.4485767.png)",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\n<!------- By Sorting ------>\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= nums.size();\\n        sort(nums.begin(),nums.end());\\n\\n        int i=0;\\n        while(i<n-1){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};\\n\\n<!-------- Using Unordered Map -------->\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= nums.size();\\n        unordered_map<int,int> m;\\n        for(int i=0; i<n; i++){\\n            m[nums[i]]++;\\n        }\\n\\n        for(auto p : m){\\n            if(p.second>1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498681,
                "title": "one-liner-c",
                "content": "Use the Linq Distinct to remove duplicates and compare the collection lengths\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        return nums.Distinct().Count() != nums.Count();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        return nums.Distinct().Count() != nums.Count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112564,
                "title": "one-line-solution-using-set-c-python3-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConvert the `nums` into an unordered set and compare its size to that of `nums`. If the size of the unordered set is smaller, it indicates the presence of duplicate item(s) in `nums`.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        return unordered_set(nums.begin(), nums.end()).size() != nums.size();\\n    }\\n};\\n```\\nPython 3\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) != len(nums)\\n```\\nJavascript\\n```\\nvar containsDuplicate = function(nums) {\\n    return new Set(nums).size != nums.length;\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        return unordered_set(nums.begin(), nums.end()).size() != nums.size();\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) != len(nums)\\n```\n```\\nvar containsDuplicate = function(nums) {\\n    return new Set(nums).size != nums.length;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841814,
                "title": "no-for-or-count-needed-python",
                "content": "```\\ndef containsDuplicate(self, nums):\\n        if len(set(nums)) < len(nums):\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef containsDuplicate(self, nums):\\n        if len(set(nums)) < len(nums):\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2808487,
                "title": "php-beats-99-79",
                "content": "# Intuition\\n```\\nSpeed: isset($arr[$i]) is much faster than in_array()\\n```\\n```\\nSpeed: $arr[$i] is much faster than array_push()\\n```\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Boolean\\n     */\\n    function containsDuplicate($nums) {\\n        \\n        $tempArr = [];\\n\\n        foreach($nums as $num) {\\n            if(isset($tempArr[$num])) return true;\\n            $tempArr[$num] = 1;\\n        }\\n        \\n        return false;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nSpeed: isset($arr[$i]) is much faster than in_array()\\n```\n```\\nSpeed: $arr[$i] is much faster than array_push()\\n```\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Boolean\\n     */\\n    function containsDuplicate($nums) {\\n        \\n        $tempArr = [];\\n\\n        foreach($nums as $num) {\\n            if(isset($tempArr[$num])) return true;\\n            $tempArr[$num] = 1;\\n        }\\n        \\n        return false;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632214,
                "title": "java-solution-using-hashset",
                "content": "```\\npublic boolean containsDuplicate(int[] nums) \\n    {\\n        HashSet<Integer> hs = new HashSet<>();  //taken a HashSet \\n        for(int x: nums) { hs.add(x);} //added all the array elements in HashSet and HashSet will remove the Duplicacy \\n        return hs.size()!=nums.length; // if HashSet Size is not equal to array Length it means there were duplicate elements and if HashSet size and Array length is same then no Duplicates present\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean containsDuplicate(int[] nums) \\n    {\\n        HashSet<Integer> hs = new HashSet<>();  //taken a HashSet \\n        for(int x: nums) { hs.add(x);} //added all the array elements in HashSet and HashSet will remove the Duplicacy \\n        return hs.size()!=nums.length; // if HashSet Size is not equal to array Length it means there were duplicate elements and if HashSet size and Array length is same then no Duplicates present\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2603321,
                "title": "c-java-python3-javascript-solutions-faster-than-93",
                "content": "C#,Java,Python3,JavaScript different solution with explanation\\n\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-217-contains-duplicate-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-217-contains-duplicate-solution-and-explanation-en/)\\u2B50**\\n\\n**Example : C# Solution1 - HashSet ( \\u2B06To see other languages \\u2B06)**\\n```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        HashSet<int> hSet = new HashSet<int>();\\n        \\n        for(int i = 0;i<nums.Length;i++)\\n        {\\n            if(hSet.Contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hSet.Add(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n**Example : C# Solution2 - sort the array first**\\n```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        Array.Sort(nums);\\n        \\n        for(int i = 0;i<nums.Length-1;i++)\\n        {\\n            if(nums[i]==nums[i+1])\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n\\nIf you got any problem or want other programming language solution, please feel free to let me know.\\n\\n**\\uD83E\\uDDE1See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        HashSet<int> hSet = new HashSet<int>();\\n        \\n        for(int i = 0;i<nums.Length;i++)\\n        {\\n            if(hSet.Contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hSet.Add(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public bool ContainsDuplicate(int[] nums) {\\n        Array.Sort(nums);\\n        \\n        for(int i = 0;i<nums.Length-1;i++)\\n        {\\n            if(nums[i]==nums[i+1])\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514407,
                "title": "javascript-o-n-comments-appreciated",
                "content": "const map = new Map();\\n\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tif (map.has(nums[i])) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tmap.set(nums[i]);\\n\\t}\\n\\n\\treturn false;",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "const map = new Map();\\n\\n\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\tif (map.has(nums[i])) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tmap.set(nums[i]);\\n\\t}\\n\\n\\treturn false;",
                "codeTag": "Unknown"
            },
            {
                "id": 2480584,
                "title": "c-fastest-easiest-solution",
                "content": "**UP VOTE**\\n\\t\\n\\t//1 solution - passed\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tbool containsDuplicate(vector<int>& nums) {\\n\\t\\t\\tstd::sort(nums.begin(), nums.end()); \\n\\t\\t\\tfor(int i = 0; i < nums.size() - 1; i++)  \\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i] == nums[i+1]) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t//2\\'th solution - Time Limit Exceeded\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tbool containsDuplicate(vector<int>& nums) {\\n\\t\\t\\t\\tfor(int i = 0; i < nums.size(); i++) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfor(int j = 0; j < nums.size(); j++) \\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(nums[i] == nums[j] && i != j) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tbool containsDuplicate(vector<int>& nums) {\\n\\t\\t\\tstd::sort(nums.begin(), nums.end()); \\n\\t\\t\\tfor(int i = 0; i < nums.size() - 1; i++)  \\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i] == nums[i+1]) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2345319,
                "title": "easy-c-solution-2-approaches",
                "content": "\\tbool containsDuplicate(vector<int>& nums){\\n        unordered_map<int,int> m;\\n        for(auto i : nums){\\n            if(++m[i]>1)\\n                return 1;\\n            }\\n        return 0;\\n    }\\n\\t\\nAnother approach would be:\\n\\n\\tbool containsDuplicate(vector& nums){\\n\\t\\treturn set(nums.begin(),nums.end()).size() < nums.size(); // set contain only unique elements\\n\\t}\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\tbool containsDuplicate(vector<int>& nums){\\n        unordered_map<int,int> m;\\n        for(auto i : nums){\\n            if(++m[i]>1)\\n                return 1;\\n            }\\n        return 0;\\n    }\\n\\t\\nAnother approach would be:\\n\\n\\tbool containsDuplicate(vector& nums){\\n\\t\\treturn set(nums.begin(),nums.end()).size() < nums.size(); // set contain only unique elements\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2340241,
                "title": "fast-short-simple-python-code",
                "content": "Runtime: 441 ms, faster than 99.46% of Python3 online submissions for Contains Duplicate.\\nMemory Usage: 26.1 MB, less than 30.56% of Python3 online submissions for Contains Duplicate.\\n**Python3** code\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        ls=len(set(nums))\\n        l=len(nums)\\n        return l>ls\\n```\\nIf you find it helpful, do not forget to **upvote**.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        ls=len(set(nums))\\n        l=len(nums)\\n        return l>ls\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212692,
                "title": "python-solution-one-liner",
                "content": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) < len(nums)\\n```\\nMore LeetCode solutions of mine at https://github.com/aurimas13/SolutionsToProblems\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) < len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026269,
                "title": "python-one-line-of-code-d",
                "content": "```\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        return len(set(nums))!=len(nums)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        return len(set(nums))!=len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956970,
                "title": "simple-python-one-liner",
                "content": "Make a set from the list to ensure that every element is present only once and compare the lenght of the nums agains the length of the set. \\n\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) != len(nums)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        return len(set(nums)) != len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715275,
                "title": "python-solutions-brute-force-sorting-python-sets-hashmap",
                "content": "### **1. Brute Force Solution**\\n\\n```\\n# Time Complexity: O(n^2)\\ndef contains_duplicate(nums):\\n    for i in range(0, len(nums)):\\n        for j in range(i+1, len(nums)):\\n            if nums[i] == nums[j]: return True\\n    return False\\n```\\n\\n### **2. Using Sorting**\\n\\n```\\n# Total Time Complexity : O(nlogn)\\ndef contains_duplicate(nums):\\n    nums.sort() # O(log N)\\n\\n    # O(N)\\n    for i in range(0, len(nums)-1):\\n        if nums[i] == nums[i+1]: return True\\n    return False\\n```\\n\\n### **2. Using Python Sets**\\n\\n```\\n# Total Time Complexity : O(n)\\ndef contains_duplicate(nums):\\n    new_nums = set(nums)\\n    if len(new_nums) == len(nums): return False\\n    return True\\n```\\n\\n### **2. Using Python Dictionary or HashMap**\\n\\n```\\n# Total Time Complexity : O(n)\\ndef contains_duplicate(nums):\\n    occurence = dict()\\n    for item in nums:\\n        if item not in occurence:\\n            occurence[item] = 1\\n        else:\\n            occurence[item] = occurence.get(item) + 1\\n\\n    for k,v in occurence.items():\\n        if v > 1: return True\\n        return False\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Time Complexity: O(n^2)\\ndef contains_duplicate(nums):\\n    for i in range(0, len(nums)):\\n        for j in range(i+1, len(nums)):\\n            if nums[i] == nums[j]: return True\\n    return False\\n```\n```\\n# Total Time Complexity : O(nlogn)\\ndef contains_duplicate(nums):\\n    nums.sort() # O(log N)\\n\\n    # O(N)\\n    for i in range(0, len(nums)-1):\\n        if nums[i] == nums[i+1]: return True\\n    return False\\n```\n```\\n# Total Time Complexity : O(n)\\ndef contains_duplicate(nums):\\n    new_nums = set(nums)\\n    if len(new_nums) == len(nums): return False\\n    return True\\n```\n```\\n# Total Time Complexity : O(n)\\ndef contains_duplicate(nums):\\n    occurence = dict()\\n    for item in nums:\\n        if item not in occurence:\\n            occurence[item] = 1\\n        else:\\n            occurence[item] = occurence.get(item) + 1\\n\\n    for k,v in occurence.items():\\n        if v > 1: return True\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1652670,
                "title": "js-solutions",
                "content": "**1. O(n)**\\n\\nRuntime: 92 ms, faster than 51.72% of JavaScript online submissions for Contains Duplicate.\\nMemory Usage: 49.5 MB, less than 5.13% of JavaScript online submissions for Contains Duplicate.\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    let obj = {};\\n    for (let num of nums) {\\n        if (obj[num]) {\\n            return true;\\n        } else {\\n            obj[num] = true;\\n        }\\n    }\\n    return false;\\n};\\n```\\n\\n**2. O(n)**\\n\\nRuntime: 96 ms, faster than 43.95% of JavaScript online submissions for Contains Duplicate.\\nMemory Usage: 47.6 MB, less than 21.20% of JavaScript online submissions for Contains Duplicate.\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    return nums.length !== new Set(nums).size\\n};\\n```\\n\\n**3. O(n log n)**\\n\\nRuntime: 168 ms, faster than 19.65% of JavaScript online submissions for Contains Duplicate.\\nMemory Usage: 48.2 MB, less than 12.69% of JavaScript online submissions for Contains Duplicate.\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    nums.sort();\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] === nums[i-1]) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```\\n\\n**4. O(n^2)**\\n\\nRuntime: 2924 ms, faster than 5.01% of JavaScript online submissions for Contains Duplicate.\\nMemory Usage: 46.2 MB, less than 46.41% of JavaScript online submissions for Contains Duplicate.\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    return !nums.every((item, index, array) => index === array.lastIndexOf(item))\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar containsDuplicate = function(nums) {\\n    let obj = {};\\n    for (let num of nums) {\\n        if (obj[num]) {\\n            return true;\\n        } else {\\n            obj[num] = true;\\n        }\\n    }\\n    return false;\\n};\\n```\n```\\nvar containsDuplicate = function(nums) {\\n    return nums.length !== new Set(nums).size\\n};\\n```\n```\\nvar containsDuplicate = function(nums) {\\n    nums.sort();\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] === nums[i-1]) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```\n```\\nvar containsDuplicate = function(nums) {\\n    return !nums.every((item, index, array) => index === array.lastIndexOf(item))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1498681,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        boolean flag = false;\\n        for(int i=0;i<nums.length;i++){\\n            if(hm.containsKey(nums[i])){\\n                flag = true;\\n                //hm.put(nums[i],hm.get(nums[i])+1);\\n            }else{\\n                hm.put(nums[i],1);\\n            }\\n        }\\n        return flag;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        boolean flag = false;\\n        for(int i=0;i<nums.length;i++){\\n            if(hm.containsKey(nums[i])){\\n                flag = true;\\n                //hm.put(nums[i],hm.get(nums[i])+1);\\n            }else{\\n                hm.put(nums[i],1);\\n            }\\n        }\\n        return flag;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445483,
                "title": "two-liner-simple-solution-in-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool containsDuplicate(vector<int>& nums) {\\n\\t\\t\\tunordered_set<int> s(nums.begin(),nums.end());\\n\\t\\t\\treturn s.size()==nums.size()? false:true;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool containsDuplicate(vector<int>& nums) {\\n\\t\\t\\tunordered_set<int> s(nums.begin(),nums.end());\\n\\t\\t\\treturn s.size()==nums.size()? false:true;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1192632,
                "title": "javascript-solution",
                "content": "Runtime: 84 ms, faster than 84.29% of JavaScript online submissions for Contains Duplicate.\\nMemory Usage: 45.1 MB, less than 57.85% of JavaScript online submissions for Contains Duplicate.\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n   // use the Set to store array element \\n    let found = new Set(nums);\\n\\t// check if the size of the set is the same as the original array\\n\\t// if array has duplicate they won\\'t be the same\\n    return found.size !== nums.length;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar containsDuplicate = function(nums) {\\n   // use the Set to store array element \\n    let found = new Set(nums);\\n\\t// check if the size of the set is the same as the original array\\n\\t// if array has duplicate they won\\'t be the same\\n    return found.size !== nums.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 966313,
                "title": "scala-single-line-solution",
                "content": "```\\ndef containsDuplicate(nums: Array[Int]): Boolean = {\\n\\tnums.size != nums.toSet.size\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\ndef containsDuplicate(nums: Array[Int]): Boolean = {\\n\\tnums.size != nums.toSet.size\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 814651,
                "title": "0-ms-2-7mb-simple-2-line-solution-using-hashset",
                "content": "\\n```\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n      pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n            //add vector to hashset.\\n            //sets don\\'t add dupes\\n            let set_of_nums: HashSet<i32> = HashSet::from_iter(nums.clone());\\n            //returns a bool\\n            !(&nums.len() == &set_of_nums.len())\\n      }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n\\nimpl Solution {\\n      pub fn contains_duplicate(nums: Vec<i32>) -> bool {\\n            //add vector to hashset.\\n            //sets don\\'t add dupes\\n            let set_of_nums: HashSet<i32> = HashSet::from_iter(nums.clone());\\n            //returns a bool\\n            !(&nums.len() == &set_of_nums.len())\\n      }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 691212,
                "title": "java-sorting-solution",
                "content": "```\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=1; i < nums.length; i++) {\\n            if(nums[i] == nums[i-1]) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\t\\n\\t// Runtime: 3 ms, faster than 99.65% of Java online submissions\\n\\t// Memory Usage: 42.9 MB, less than 99.23% of Java online submissions.\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=1; i < nums.length; i++) {\\n            if(nums[i] == nums[i-1]) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\t\\n\\t// Runtime: 3 ms, faster than 99.65% of Java online submissions\\n\\t// Memory Usage: 42.9 MB, less than 99.23% of Java online submissions.\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 563897,
                "title": "c-hash-solution-o-n-time-o-n-space",
                "content": "Having used c++ stl library to show [various solutions](https://leetcode.com/problems/contains-duplicate/discuss/191396/c%2B%2B-fast-simple-short-solutions.-1-line-without-modifying-input.-2-lines-with-modifying.), I thought I would put up a c hash solution using uhash.h.\\n\\n```cpp\\nstruct number_set {\\n  int value;\\n  UT_hash_handle hh;\\n};\\n\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n  struct number_set* set = NULL;\\n  struct number_set* element;\\n  bool result = false;\\n  \\n  for (int i = 0; i < numsSize; ++i) {\\n    HASH_FIND_INT(set, &nums[i], element);\\n    if (element) {\\n      result = true;\\n      break;\\n    }\\n    \\n    element = (struct number_set *) malloc(sizeof(*element));\\n    element->value = nums[i];\\n    HASH_ADD_INT(set, value, element);\\n  }\\n \\n  /* Destroy the hashset */\\n  struct number_set* curr;\\n  struct number_set* tmp;\\n  HASH_ITER(hh, set, curr, tmp) {\\n    HASH_DEL(set, curr);\\n    free(curr);\\n  }\\n  \\n  return result;\\n}\\n```\\n\\nPretty simple concempt of checking for existance in hashset, returning true if it does and adding it to the hashset if it doesn\\'t. Rinse and repeat.",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nstruct number_set {\\n  int value;\\n  UT_hash_handle hh;\\n};\\n\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n  struct number_set* set = NULL;\\n  struct number_set* element;\\n  bool result = false;\\n  \\n  for (int i = 0; i < numsSize; ++i) {\\n    HASH_FIND_INT(set, &nums[i], element);\\n    if (element) {\\n      result = true;\\n      break;\\n    }\\n    \\n    element = (struct number_set *) malloc(sizeof(*element));\\n    element->value = nums[i];\\n    HASH_ADD_INT(set, value, element);\\n  }\\n \\n  /* Destroy the hashset */\\n  struct number_set* curr;\\n  struct number_set* tmp;\\n  HASH_ITER(hh, set, curr, tmp) {\\n    HASH_DEL(set, curr);\\n    free(curr);\\n  }\\n  \\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 440357,
                "title": "easy-to-understand-python-python3-code-using-dictionary",
                "content": "The time complexity is O(n), because search in dicitonary is O(1). This is achieved at the expense of extra O(n) space.\\n\\n        dic = {}\\n        for n in nums:\\n            if n in dic: return True\\n            else: dic[n] = 1\\n        return False",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "The time complexity is O(n), because search in dicitonary is O(1). This is achieved at the expense of extra O(n) space.\\n\\n        dic = {}\\n        for n in nums:\\n            if n in dic: return True\\n            else: dic[n] = 1\\n        return False",
                "codeTag": "Unknown"
            },
            {
                "id": 216923,
                "title": "c-qsort-8ms",
                "content": "```\\nstatic int _cmp(const int *l, const int *r)  \\n{ \\n    return (*l - *r); \\n}\\n\\nbool containsDuplicate(int* nums, int numsSize) {\\n    qsort(nums, numsSize, sizeof(int), _cmp);\\n    \\n    for (int i = 1; i < numsSize; ++i) {\\n        if (nums[i] == nums[i - 1]) return true;\\n    }\\n    \\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstatic int _cmp(const int *l, const int *r)  \\n{ \\n    return (*l - *r); \\n}\\n\\nbool containsDuplicate(int* nums, int numsSize) {\\n    qsort(nums, numsSize, sizeof(int), _cmp);\\n    \\n    for (int i = 1; i < numsSize; ++i) {\\n        if (nums[i] == nums[i - 1]) return true;\\n    }\\n    \\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 140954,
                "title": "python-one-liner",
                "content": "```\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        return len(nums) != len(set(nums))\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def containsDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        return len(nums) != len(set(nums))\\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1805121,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1570451,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1568303,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1567688,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1571445,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1566700,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1572616,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1576158,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1568546,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1567227,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1805121,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1570451,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1568303,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1567688,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1571445,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1566700,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1572616,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1576158,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1568546,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1567227,
                "content": [
                    {
                        "username": "Spenderr",
                        "content": "its all fun until you hit the time limit exceed error"
                    },
                    {
                        "username": "ch_shikha",
                        "content": "how to fix it then?"
                    },
                    {
                        "username": "sergei99",
                        "content": "Why not use an efficient algorithm? A rhethorical question..."
                    },
                    {
                        "username": "rakesh_donga",
                        "content": "I MADE THAT ; }"
                    },
                    {
                        "username": "henriquebelotto",
                        "content": "I noticed that I submit the same solution multiple times, the run time varies a lot.\\nThat is a quite bad design of LeetCode as it makes things harder to compare, since one solution might have a very fast response and 1 minute later, that same solution is \"Slow\"."
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "applying brute force approach when submitting the code, the run time is exceeded."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "I also noticed that"
                    },
                    {
                        "username": "sergei99",
                        "content": "Well, if I\\'m not satisfied with the result of the first submission, then I try to submit it a few more times, averaging times. I guess it depends on load spikes of the server, which is why it\\'s good to try at different times of the day."
                    },
                    {
                        "username": "diptaraj23",
                        "content": "Exactly why we use the Big O Notation."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s funny how everyone gets super confident criticizing the website while solving literally the easiest problem on the entire site. The only problem that would generate a worse comment section would be \"Print \\'Hello World\\'\""
                    },
                    {
                        "username": "mnothman",
                        "content": "you compute the run time from analyzing the code itself, there is no real baseline since every machine and other factors change everything. therefore just know the time and space complexity from looking at it not running it"
                    },
                    {
                        "username": "user4790Al",
                        "content": "I noticed file submissions are faster for some reason."
                    },
                    {
                        "username": "portikCoder",
                        "content": "Just wanted to post the same thing actually... Once I run I got 153ms, another time I got 95ms... Wanted to see what I did that mine wasn\\'t done in ~60ms, the code looked literally the same (OFC with differences in naming), so man, frustrating sh*t, u don\\'t even know if u\\'re really slower or just probably the input is different ooor most probably the measuring is not about wall-time but based on how busy is their machine(s)."
                    },
                    {
                        "username": "Blaise_Mahoro",
                        "content": "When you click submit, your browser makes an API call to the API service that compiles, run, and test the code. So, anything can happen in such setup. Many people may submit at the same time and the runtime for the exact same code can vary depending on how busy the system/server is. \\nEven if you run it on your local, you will see different runtimes for the same piece of code.\\nThat\\'s why the Big O is used to compare runtime and space complexity."
                    },
                    {
                        "username": "jumong39122580",
                        "content": "I agree with you"
                    },
                    {
                        "username": "ashwin918",
                        "content": "return (len(nums) != len(set(nums)))"
                    },
                    {
                        "username": "Logic0807",
                        "content": "[@vardhansworldd](/vardhansworldd) The output should be a bool instead of a string"
                    },
                    {
                        "username": "shaanaliyev",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) The constructor of Set automatically iterates the array anyways in this case. That means there is a loop under the hood. And [@CharlesDCM](/123CarlosDaniel) is right. "
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\n\\nwhat is the problem in this code?"
                    },
                    {
                        "username": "123CarlosDaniel",
                        "content": "this is not the best solution, supose the duplicate numbers are in the init of the array and the array have a extreme large length, so you will have to create a extreme large set using more memory and time "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "I created the unique set manually first, then I found this set method that does it automatically for me. This way, not even a single for loop was needed. Best approach yet. "
                    },
                    {
                        "username": "sonu28sharma99",
                        "content": "![image](https://assets.leetcode.com/users/images/5112167d-05b1-4182-938f-0413c22bd3ef_1635525119.5442066.png)\\n\\n![image](https://assets.leetcode.com/users/images/b514d8ec-ddb0-45c4-8b14-136df3015ca6_1635525143.7365952.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/92bb264e-5713-48fd-91df-7158f8ed304f_1635525160.9229846.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/e401d65e-90f4-4e76-9d25-dc1869ffcde0_1635525173.4317365.png)\\n"
                    },
                    {
                        "username": "lbhong",
                        "content": "Did you read Discussion Rule #1?"
                    },
                    {
                        "username": "Finesse7",
                        "content": "i did with the same method but my time limit is exceeding "
                    },
                    {
                        "username": "srushtiii",
                        "content": "in order to find a size of an array nums.size() is used. it\\'ll take a linear time. so will the overall time complexity be O(n^2)?"
                    },
                    {
                        "username": "mj2carlsbad",
                        "content": "Why are you posting solutions here?"
                    },
                    {
                        "username": "mulcro",
                        "content": "[@dartpixel](/dartpixel) Hey man it\\'s to prevent the nums[i+1] from going out of bounds"
                    },
                    {
                        "username": "atninthsky",
                        "content": "can u plz explain why in case 2 in for loop , the loop was taken till nums.size()-1 and not nums.size() ??  btw loved your case 3 solution using unordered map :)"
                    },
                    {
                        "username": "seangradyhicks",
                        "content": "where are you getting nlogn for containsduplicate2? The usual sorting used is n, and you\\'re iterating through the array once, so wouldn\\'t that just be n?"
                    },
                    {
                        "username": "pallavia1204",
                        "content": "Can you please explain how the time complexity is O(NLog(N)) for the solution with maps."
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": "I tried the first one and the time limit exceeded."
                    },
                    {
                        "username": "noskillzjusthackz",
                        "content": "The first one is n^2 which wont pass the test case for the submission since its super long."
                    },
                    {
                        "username": "Neemdar",
                        "content": "Can you solve it in N time without using extra memory? I.e. no hash set or dictionary and not a n^2 solution where you check every other element."
                    },
                    {
                        "username": "sergei99",
                        "content": "Sorting is already O(n log n). But even hash with preallocation and early exit gives it quite mediocre rating. The input data has been chosen very carefully, I would say... with the aim of making STL crawl. I don't know who are those guys earning the top 10% score, but I couldn't beat their execution time without writing my own collection. I didn't realize STL sucks so badly until I encountered this \"Easy\" task."
                    },
                    {
                        "username": "yo-mama",
                        "content": "For anyone wondering. It's possible using bitwise operations only if there are even number of duplicates. Here is a similar problem which can be modified to this https://leetcode.com/problems/find-the-duplicate-number/description/"
                    },
                    {
                        "username": "TheShadowblast123",
                        "content": "Probably with some form of sorting. If you could sort the array, duplicates should be next to each other, but it depends on the sort operation how much memory would end up being used."
                    },
                    {
                        "username": "nick7albert",
                        "content": "I\\'m trying the same thing rn, I tried checking for imbalances in the size of sums and an array list that doesn\\'t allow in every iteration so that it catches duplicates immediately, but I\\'m still getting time limit...It\\'s fun looking for a non set solution."
                    },
                    {
                        "username": "suyash_23",
                        "content": "return !(nums.size()==set<int>(nums.begin(),nums.end()).size());"
                    },
                    {
                        "username": "sergei99",
                        "content": "And 300ms execution time presumably..."
                    },
                    {
                        "username": "Nightywind",
                        "content": "I used 2 for-loops to solve this problem, it\\'s easy to understand."
                    },
                    {
                        "username": "z_acc",
                        "content": "[@dilsherb](/dilsherb) sort internally uses more than one loop I\\'d bet."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "it willincrease time complexity.\\n"
                    },
                    {
                        "username": "randomchikibum123",
                        "content": "[@dilsherb](/dilsherb) isnt this just checking the adjacent elements "
                    },
                    {
                        "username": "goodoldjoe",
                        "content": "[@dilsherb](/dilsherb) This will create an index out of bounds exception for an array that doesn\\'t have a duplicate."
                    },
                    {
                        "username": "Belkassem",
                        "content": "[@dilsherb](/dilsherb)  if the complexity of the sort function O(n) ?"
                    },
                    {
                        "username": "dilsherb",
                        "content": "what you say about this one for loop\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } "
                    },
                    {
                        "username": "newzreview",
                        "content": "var containsDuplicate = function(nums) { \\n\\n  test = [...new Set(nums)];\\n  if(test.length<nums.length){return true;}\\n\\nreturn false;\\n}"
                    },
                    {
                        "username": "newzreview",
                        "content": "u can use zero loops."
                    },
                    {
                        "username": "pjanardhan7u",
                        "content": "just convert into set only single line"
                    },
                    {
                        "username": "Kapish3067",
                        "content": "yes it is easy but it has more time complexity Read more at - https://www.enjoyalgorithms.com/blog/time-complexity-analysis-of-loop-in-programming"
                    },
                    {
                        "username": "miketts",
                        "content": "[@abirdutta90990](/abirdutta90990) how did you solve?\\n"
                    },
                    {
                        "username": "MarcinMN",
                        "content": "[@abirdutta90990](/abirdutta90990) Yeah, I got the time limit exceeded as well.  I figured that solution was too good to be true since this was the first \"easy\" problem that I truly felt was \"easy.\"  haha\\n\\nI just finished a similar problem where I was determining if there was a unique character that only appears once in a String.  I used a HashMap for that so I could tally the number of instances of each character and then go through the String and look if anything only occurred once.  I suppose a similar approach would work for this too.  It might actually be easier in this problem.  You could probably use a HashSet to add each value in the array.  Since any duplicates will only be added once, you could then compare the length of the original array with the length of the HashSet.  If they aren\\'t the same, then you know you had some duplicate values!"
                    },
                    {
                        "username": "abirdutta90990",
                        "content": "but it is giving time limit exceeded when you try to submit"
                    },
                    {
                        "username": "mirchandani",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "vardhansworldd",
                        "content": "numset=list(set(nums))\\n        if len(nums) == len(numset):\\n            # print(len(numset))\\n            # print(len(nums))\\n            return \\'false\\'\\n        else:\\n            return \\'true\\'\\nwhat is the problem in this code"
                    },
                    {
                        "username": "aechtee42",
                        "content": "I can understand why Arrays.sort() is a better option in terms of space but how usingArrays.Sort() (3ms) is giving faster results than using HashSet (5ms) ?"
                    },
                    {
                        "username": "lkubica",
                        "content": "[@Kamal_Kumar12](/Kamal_Kumar12) HashSets are very complex. It works well when hash array is quite a bit larger than a data set. Max array size is 10^5, try a HashSet solution on 10^5 DISTINCT values and you will see why. Every Java Object header is 12 bytes + 8byte for int (which is really a long on 64 bit) + alignment and you have 24 bytes per Integer. Plus a hash set itself, plus a linked list/tree for duplicates. Plus growing the set if you do not give a hint in the constructor. Plus boxing all those ints. HashSet solution is a very unstable solution, it woks great for sets with lots of repetitions ans works very badly for large arrays with no repetitions. Sorting solution requires no extra objects on heap, does it in place and is not very dependent on the nature of the data (assuming sort algo has no weak points)."
                    },
                    {
                        "username": "JetHsu",
                        "content": "Technically, the time complexity of HashSet is O(N) rather than O(1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "The performance difference you\\'re observing between `Arrays.sort()` and `HashSet` in Java could be attributed to several factors:\\n\\n1. **Nature of the data**: If the array has lots of duplicates, adding elements to a HashSet might lead to more collisions and consequently, more time complexity to resolve these collisions. This would result in slower performance compared to sorting.\\n\\n2. **CPU Cache Utilization**: CPUs have a small amount of very fast cache memory. When data is accessed sequentially (like in sorting algorithms), the CPU can prefetch data into cache, making the access faster. This type of optimization is generally more beneficial for sorting (which is memory access pattern friendly due to its sequential nature) compared to hash based data structures (where memory accesses are scattered).\\n\\n3. **Overhead of Object Wrapping**: In Java, `HashSet` handles primitive types (like `int`) as their wrapper object equivalents (like `Integer`). The overhead of object wrapping and unwrapping can add to the execution time.\\n\\n4. **Overhead of Hashing**: Hashing each element to place it in the `HashSet` can also introduce overhead, particularly for larger data sizes.\\n\\nIt\\'s worth noting that while `Arrays.sort()` might be faster for some specific inputs and conditions, `HashSet` has a constant average time complexity which can be significantly faster for certain other types of input. Therefore, the optimal choice depends on the specific context and requirements of the problem. \\n\\nRemember that micro-benchmarks like these may not always give an accurate reflection of real-world performance due to the factors mentioned above as well as others like Java\\'s Just-In-Time (JIT) compiler optimizations, garbage collection, etc. Therefore, always consider the trade-offs and choose the approach that best fits your use case."
                    },
                    {
                        "username": "Kamal_Kumar12",
                        "content": "The same question I have. Using map, we are solving this by O(n) but array.sort() is better solution even it is taking nlogn. I don\\'t know why?"
                    },
                    {
                        "username": "user9279ec",
                        "content": "perhaps there\\'s resizing of the underlying array in your hashset"
                    },
                    {
                        "username": "vrajpatelk",
                        "content": "can we solve in c language ,you can solve so please get the answer....!"
                    },
                    {
                        "username": "bangbang93",
                        "content": "    var containsDuplicate = (nums) =>new Set(nums).size != nums.length;"
                    }
                ]
            },
            {
                "id": 1576843,
                "content": [
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation \\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/"
                    },
                    {
                        "username": "user3379wo",
                        "content": "Hmm, is it actually the fastest solution? I used this exact approach (a hashmap) and it only beats 70% of solutions time wise."
                    },
                    {
                        "username": "peanutavenger",
                        "content": "lmao\\n   \\n\\treturn False if len(nums) == len(set(nums)) else True"
                    },
                    {
                        "username": "ezraorich",
                        "content": "lmao what a genius <3"
                    },
                    {
                        "username": "tejaschauhan2003",
                        "content": "what means of time limit exceeded"
                    },
                    {
                        "username": "AKaxor",
                        "content": "it means the life is short man , its like a little easter in cpp to remind us the value of time. -_-"
                    },
                    {
                        "username": "user3651PR",
                        "content": "Why is this giving me wrong answer in Testcase 1?\n\n ```class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for idx in range(len(nums)-1): # 0 ~length\n            if nums[idx] == nums[idx+1]:\n                return True\n        return False```"
                    },
                    {
                        "username": "OGx09",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) You don\\'t have to sort the given values to arrive at the solution"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "also your solution will not work if the nums array only has single element. "
                    },
                    {
                        "username": "sscswapnil",
                        "content": "Because you are comparing adjacent values, not with the other remaining value. "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "You could try sorting the array first. Once sorted, the duplicate values would be adjacent to each other. Before for loop, put nums.sort()"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // sorting array\\n        // for any same return true\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1) return false;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]) return true;\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user3651PR",
                        "content": " ```python\n     dups={}\n        for idx, num in enumerate(nums):\n            if num in dups:\n                return True\n           \n            dups[idx]=num\nreturn False\n````\n\nit works but fails on case like [3,3]\nshould return True but returns False"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your code lies in this line: `dups[idx]=num`. In your current code, you\\'re using the index (`idx`) as the key in your dictionary `dups` and the number (`num`) as the value. This means that when you\\'re checking if `num in dups`, you\\'re actually checking if `num` is one of the keys in the dictionary, which it is not since the keys are the indices.\\n\\nYou should actually be using the number itself (`num`) as the key and the index (`idx`) as the value (or you could just use any value if you don\\'t need the index). This way, you\\'re correctly checking if the number is already in the dictionary.\\n\\nHere\\'s how you can fix your code:\\n\\n```python\\ndups={}\\nfor idx, num in enumerate(nums):\\n    if num in dups:\\n        return True\\n    dups[num] = idx  # num is the key, idx is the value\\nreturn False\\n```\\n\\nNow the code will correctly return `True` for the input `[3,3]`."
                    },
                    {
                        "username": "billxu1975",
                        "content": "It seems line3 is checking if dups has this key num instead of checking the value. "
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\n"
                    },
                    {
                        "username": "khaled_acmilan",
                        "content": "\\tpublic bool ContainsDuplicate(int[] nums) {\\n\\t\\t\\treturn new HashSet<int>(nums).Count < nums.Length;\\n\\t}"
                    },
                    {
                        "username": "DivyanshSangal",
                        "content": "How are hashset based solution slower than the sorting based solutions in cpp?"
                    },
                    {
                        "username": "bbare",
                        "content": "My original solution was to use an ArrayList to see if there has been a duplicate. My solution passed all TestCases but I got a TIme Limit Exceeded. I looked at the solution and saw it used a Set so I changed my ArrayList to a Set and it worked. Why does a Set work but not an Array List?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you use contains in ArrayList, it is o(n)"
                    }
                ]
            },
            {
                "id": 1576599,
                "content": [
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation \\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/"
                    },
                    {
                        "username": "user3379wo",
                        "content": "Hmm, is it actually the fastest solution? I used this exact approach (a hashmap) and it only beats 70% of solutions time wise."
                    },
                    {
                        "username": "peanutavenger",
                        "content": "lmao\\n   \\n\\treturn False if len(nums) == len(set(nums)) else True"
                    },
                    {
                        "username": "ezraorich",
                        "content": "lmao what a genius <3"
                    },
                    {
                        "username": "tejaschauhan2003",
                        "content": "what means of time limit exceeded"
                    },
                    {
                        "username": "AKaxor",
                        "content": "it means the life is short man , its like a little easter in cpp to remind us the value of time. -_-"
                    },
                    {
                        "username": "user3651PR",
                        "content": "Why is this giving me wrong answer in Testcase 1?\n\n ```class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for idx in range(len(nums)-1): # 0 ~length\n            if nums[idx] == nums[idx+1]:\n                return True\n        return False```"
                    },
                    {
                        "username": "OGx09",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) You don\\'t have to sort the given values to arrive at the solution"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "also your solution will not work if the nums array only has single element. "
                    },
                    {
                        "username": "sscswapnil",
                        "content": "Because you are comparing adjacent values, not with the other remaining value. "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "You could try sorting the array first. Once sorted, the duplicate values would be adjacent to each other. Before for loop, put nums.sort()"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // sorting array\\n        // for any same return true\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1) return false;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]) return true;\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user3651PR",
                        "content": " ```python\n     dups={}\n        for idx, num in enumerate(nums):\n            if num in dups:\n                return True\n           \n            dups[idx]=num\nreturn False\n````\n\nit works but fails on case like [3,3]\nshould return True but returns False"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your code lies in this line: `dups[idx]=num`. In your current code, you\\'re using the index (`idx`) as the key in your dictionary `dups` and the number (`num`) as the value. This means that when you\\'re checking if `num in dups`, you\\'re actually checking if `num` is one of the keys in the dictionary, which it is not since the keys are the indices.\\n\\nYou should actually be using the number itself (`num`) as the key and the index (`idx`) as the value (or you could just use any value if you don\\'t need the index). This way, you\\'re correctly checking if the number is already in the dictionary.\\n\\nHere\\'s how you can fix your code:\\n\\n```python\\ndups={}\\nfor idx, num in enumerate(nums):\\n    if num in dups:\\n        return True\\n    dups[num] = idx  # num is the key, idx is the value\\nreturn False\\n```\\n\\nNow the code will correctly return `True` for the input `[3,3]`."
                    },
                    {
                        "username": "billxu1975",
                        "content": "It seems line3 is checking if dups has this key num instead of checking the value. "
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\n"
                    },
                    {
                        "username": "khaled_acmilan",
                        "content": "\\tpublic bool ContainsDuplicate(int[] nums) {\\n\\t\\t\\treturn new HashSet<int>(nums).Count < nums.Length;\\n\\t}"
                    },
                    {
                        "username": "DivyanshSangal",
                        "content": "How are hashset based solution slower than the sorting based solutions in cpp?"
                    },
                    {
                        "username": "bbare",
                        "content": "My original solution was to use an ArrayList to see if there has been a duplicate. My solution passed all TestCases but I got a TIme Limit Exceeded. I looked at the solution and saw it used a Set so I changed my ArrayList to a Set and it worked. Why does a Set work but not an Array List?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you use contains in ArrayList, it is o(n)"
                    }
                ]
            },
            {
                "id": 1795206,
                "content": [
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation \\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/"
                    },
                    {
                        "username": "user3379wo",
                        "content": "Hmm, is it actually the fastest solution? I used this exact approach (a hashmap) and it only beats 70% of solutions time wise."
                    },
                    {
                        "username": "peanutavenger",
                        "content": "lmao\\n   \\n\\treturn False if len(nums) == len(set(nums)) else True"
                    },
                    {
                        "username": "ezraorich",
                        "content": "lmao what a genius <3"
                    },
                    {
                        "username": "tejaschauhan2003",
                        "content": "what means of time limit exceeded"
                    },
                    {
                        "username": "AKaxor",
                        "content": "it means the life is short man , its like a little easter in cpp to remind us the value of time. -_-"
                    },
                    {
                        "username": "user3651PR",
                        "content": "Why is this giving me wrong answer in Testcase 1?\n\n ```class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for idx in range(len(nums)-1): # 0 ~length\n            if nums[idx] == nums[idx+1]:\n                return True\n        return False```"
                    },
                    {
                        "username": "OGx09",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) You don\\'t have to sort the given values to arrive at the solution"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "also your solution will not work if the nums array only has single element. "
                    },
                    {
                        "username": "sscswapnil",
                        "content": "Because you are comparing adjacent values, not with the other remaining value. "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "You could try sorting the array first. Once sorted, the duplicate values would be adjacent to each other. Before for loop, put nums.sort()"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // sorting array\\n        // for any same return true\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1) return false;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]) return true;\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user3651PR",
                        "content": " ```python\n     dups={}\n        for idx, num in enumerate(nums):\n            if num in dups:\n                return True\n           \n            dups[idx]=num\nreturn False\n````\n\nit works but fails on case like [3,3]\nshould return True but returns False"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your code lies in this line: `dups[idx]=num`. In your current code, you\\'re using the index (`idx`) as the key in your dictionary `dups` and the number (`num`) as the value. This means that when you\\'re checking if `num in dups`, you\\'re actually checking if `num` is one of the keys in the dictionary, which it is not since the keys are the indices.\\n\\nYou should actually be using the number itself (`num`) as the key and the index (`idx`) as the value (or you could just use any value if you don\\'t need the index). This way, you\\'re correctly checking if the number is already in the dictionary.\\n\\nHere\\'s how you can fix your code:\\n\\n```python\\ndups={}\\nfor idx, num in enumerate(nums):\\n    if num in dups:\\n        return True\\n    dups[num] = idx  # num is the key, idx is the value\\nreturn False\\n```\\n\\nNow the code will correctly return `True` for the input `[3,3]`."
                    },
                    {
                        "username": "billxu1975",
                        "content": "It seems line3 is checking if dups has this key num instead of checking the value. "
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\n"
                    },
                    {
                        "username": "khaled_acmilan",
                        "content": "\\tpublic bool ContainsDuplicate(int[] nums) {\\n\\t\\t\\treturn new HashSet<int>(nums).Count < nums.Length;\\n\\t}"
                    },
                    {
                        "username": "DivyanshSangal",
                        "content": "How are hashset based solution slower than the sorting based solutions in cpp?"
                    },
                    {
                        "username": "bbare",
                        "content": "My original solution was to use an ArrayList to see if there has been a duplicate. My solution passed all TestCases but I got a TIme Limit Exceeded. I looked at the solution and saw it used a Set so I changed my ArrayList to a Set and it worked. Why does a Set work but not an Array List?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you use contains in ArrayList, it is o(n)"
                    }
                ]
            },
            {
                "id": 1692282,
                "content": [
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation \\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/"
                    },
                    {
                        "username": "user3379wo",
                        "content": "Hmm, is it actually the fastest solution? I used this exact approach (a hashmap) and it only beats 70% of solutions time wise."
                    },
                    {
                        "username": "peanutavenger",
                        "content": "lmao\\n   \\n\\treturn False if len(nums) == len(set(nums)) else True"
                    },
                    {
                        "username": "ezraorich",
                        "content": "lmao what a genius <3"
                    },
                    {
                        "username": "tejaschauhan2003",
                        "content": "what means of time limit exceeded"
                    },
                    {
                        "username": "AKaxor",
                        "content": "it means the life is short man , its like a little easter in cpp to remind us the value of time. -_-"
                    },
                    {
                        "username": "user3651PR",
                        "content": "Why is this giving me wrong answer in Testcase 1?\n\n ```class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for idx in range(len(nums)-1): # 0 ~length\n            if nums[idx] == nums[idx+1]:\n                return True\n        return False```"
                    },
                    {
                        "username": "OGx09",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) You don\\'t have to sort the given values to arrive at the solution"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "also your solution will not work if the nums array only has single element. "
                    },
                    {
                        "username": "sscswapnil",
                        "content": "Because you are comparing adjacent values, not with the other remaining value. "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "You could try sorting the array first. Once sorted, the duplicate values would be adjacent to each other. Before for loop, put nums.sort()"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // sorting array\\n        // for any same return true\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1) return false;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]) return true;\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user3651PR",
                        "content": " ```python\n     dups={}\n        for idx, num in enumerate(nums):\n            if num in dups:\n                return True\n           \n            dups[idx]=num\nreturn False\n````\n\nit works but fails on case like [3,3]\nshould return True but returns False"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your code lies in this line: `dups[idx]=num`. In your current code, you\\'re using the index (`idx`) as the key in your dictionary `dups` and the number (`num`) as the value. This means that when you\\'re checking if `num in dups`, you\\'re actually checking if `num` is one of the keys in the dictionary, which it is not since the keys are the indices.\\n\\nYou should actually be using the number itself (`num`) as the key and the index (`idx`) as the value (or you could just use any value if you don\\'t need the index). This way, you\\'re correctly checking if the number is already in the dictionary.\\n\\nHere\\'s how you can fix your code:\\n\\n```python\\ndups={}\\nfor idx, num in enumerate(nums):\\n    if num in dups:\\n        return True\\n    dups[num] = idx  # num is the key, idx is the value\\nreturn False\\n```\\n\\nNow the code will correctly return `True` for the input `[3,3]`."
                    },
                    {
                        "username": "billxu1975",
                        "content": "It seems line3 is checking if dups has this key num instead of checking the value. "
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\n"
                    },
                    {
                        "username": "khaled_acmilan",
                        "content": "\\tpublic bool ContainsDuplicate(int[] nums) {\\n\\t\\t\\treturn new HashSet<int>(nums).Count < nums.Length;\\n\\t}"
                    },
                    {
                        "username": "DivyanshSangal",
                        "content": "How are hashset based solution slower than the sorting based solutions in cpp?"
                    },
                    {
                        "username": "bbare",
                        "content": "My original solution was to use an ArrayList to see if there has been a duplicate. My solution passed all TestCases but I got a TIme Limit Exceeded. I looked at the solution and saw it used a Set so I changed my ArrayList to a Set and it worked. Why does a Set work but not an Array List?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you use contains in ArrayList, it is o(n)"
                    }
                ]
            },
            {
                "id": 1793517,
                "content": [
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation \\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/"
                    },
                    {
                        "username": "user3379wo",
                        "content": "Hmm, is it actually the fastest solution? I used this exact approach (a hashmap) and it only beats 70% of solutions time wise."
                    },
                    {
                        "username": "peanutavenger",
                        "content": "lmao\\n   \\n\\treturn False if len(nums) == len(set(nums)) else True"
                    },
                    {
                        "username": "ezraorich",
                        "content": "lmao what a genius <3"
                    },
                    {
                        "username": "tejaschauhan2003",
                        "content": "what means of time limit exceeded"
                    },
                    {
                        "username": "AKaxor",
                        "content": "it means the life is short man , its like a little easter in cpp to remind us the value of time. -_-"
                    },
                    {
                        "username": "user3651PR",
                        "content": "Why is this giving me wrong answer in Testcase 1?\n\n ```class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for idx in range(len(nums)-1): # 0 ~length\n            if nums[idx] == nums[idx+1]:\n                return True\n        return False```"
                    },
                    {
                        "username": "OGx09",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) You don\\'t have to sort the given values to arrive at the solution"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "also your solution will not work if the nums array only has single element. "
                    },
                    {
                        "username": "sscswapnil",
                        "content": "Because you are comparing adjacent values, not with the other remaining value. "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "You could try sorting the array first. Once sorted, the duplicate values would be adjacent to each other. Before for loop, put nums.sort()"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // sorting array\\n        // for any same return true\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1) return false;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]) return true;\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user3651PR",
                        "content": " ```python\n     dups={}\n        for idx, num in enumerate(nums):\n            if num in dups:\n                return True\n           \n            dups[idx]=num\nreturn False\n````\n\nit works but fails on case like [3,3]\nshould return True but returns False"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your code lies in this line: `dups[idx]=num`. In your current code, you\\'re using the index (`idx`) as the key in your dictionary `dups` and the number (`num`) as the value. This means that when you\\'re checking if `num in dups`, you\\'re actually checking if `num` is one of the keys in the dictionary, which it is not since the keys are the indices.\\n\\nYou should actually be using the number itself (`num`) as the key and the index (`idx`) as the value (or you could just use any value if you don\\'t need the index). This way, you\\'re correctly checking if the number is already in the dictionary.\\n\\nHere\\'s how you can fix your code:\\n\\n```python\\ndups={}\\nfor idx, num in enumerate(nums):\\n    if num in dups:\\n        return True\\n    dups[num] = idx  # num is the key, idx is the value\\nreturn False\\n```\\n\\nNow the code will correctly return `True` for the input `[3,3]`."
                    },
                    {
                        "username": "billxu1975",
                        "content": "It seems line3 is checking if dups has this key num instead of checking the value. "
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\n"
                    },
                    {
                        "username": "khaled_acmilan",
                        "content": "\\tpublic bool ContainsDuplicate(int[] nums) {\\n\\t\\t\\treturn new HashSet<int>(nums).Count < nums.Length;\\n\\t}"
                    },
                    {
                        "username": "DivyanshSangal",
                        "content": "How are hashset based solution slower than the sorting based solutions in cpp?"
                    },
                    {
                        "username": "bbare",
                        "content": "My original solution was to use an ArrayList to see if there has been a duplicate. My solution passed all TestCases but I got a TIme Limit Exceeded. I looked at the solution and saw it used a Set so I changed my ArrayList to a Set and it worked. Why does a Set work but not an Array List?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you use contains in ArrayList, it is o(n)"
                    }
                ]
            },
            {
                "id": 1693438,
                "content": [
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation \\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/"
                    },
                    {
                        "username": "user3379wo",
                        "content": "Hmm, is it actually the fastest solution? I used this exact approach (a hashmap) and it only beats 70% of solutions time wise."
                    },
                    {
                        "username": "peanutavenger",
                        "content": "lmao\\n   \\n\\treturn False if len(nums) == len(set(nums)) else True"
                    },
                    {
                        "username": "ezraorich",
                        "content": "lmao what a genius <3"
                    },
                    {
                        "username": "tejaschauhan2003",
                        "content": "what means of time limit exceeded"
                    },
                    {
                        "username": "AKaxor",
                        "content": "it means the life is short man , its like a little easter in cpp to remind us the value of time. -_-"
                    },
                    {
                        "username": "user3651PR",
                        "content": "Why is this giving me wrong answer in Testcase 1?\n\n ```class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for idx in range(len(nums)-1): # 0 ~length\n            if nums[idx] == nums[idx+1]:\n                return True\n        return False```"
                    },
                    {
                        "username": "OGx09",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) You don\\'t have to sort the given values to arrive at the solution"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "also your solution will not work if the nums array only has single element. "
                    },
                    {
                        "username": "sscswapnil",
                        "content": "Because you are comparing adjacent values, not with the other remaining value. "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "You could try sorting the array first. Once sorted, the duplicate values would be adjacent to each other. Before for loop, put nums.sort()"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // sorting array\\n        // for any same return true\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1) return false;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]) return true;\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user3651PR",
                        "content": " ```python\n     dups={}\n        for idx, num in enumerate(nums):\n            if num in dups:\n                return True\n           \n            dups[idx]=num\nreturn False\n````\n\nit works but fails on case like [3,3]\nshould return True but returns False"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your code lies in this line: `dups[idx]=num`. In your current code, you\\'re using the index (`idx`) as the key in your dictionary `dups` and the number (`num`) as the value. This means that when you\\'re checking if `num in dups`, you\\'re actually checking if `num` is one of the keys in the dictionary, which it is not since the keys are the indices.\\n\\nYou should actually be using the number itself (`num`) as the key and the index (`idx`) as the value (or you could just use any value if you don\\'t need the index). This way, you\\'re correctly checking if the number is already in the dictionary.\\n\\nHere\\'s how you can fix your code:\\n\\n```python\\ndups={}\\nfor idx, num in enumerate(nums):\\n    if num in dups:\\n        return True\\n    dups[num] = idx  # num is the key, idx is the value\\nreturn False\\n```\\n\\nNow the code will correctly return `True` for the input `[3,3]`."
                    },
                    {
                        "username": "billxu1975",
                        "content": "It seems line3 is checking if dups has this key num instead of checking the value. "
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\n"
                    },
                    {
                        "username": "khaled_acmilan",
                        "content": "\\tpublic bool ContainsDuplicate(int[] nums) {\\n\\t\\t\\treturn new HashSet<int>(nums).Count < nums.Length;\\n\\t}"
                    },
                    {
                        "username": "DivyanshSangal",
                        "content": "How are hashset based solution slower than the sorting based solutions in cpp?"
                    },
                    {
                        "username": "bbare",
                        "content": "My original solution was to use an ArrayList to see if there has been a duplicate. My solution passed all TestCases but I got a TIme Limit Exceeded. I looked at the solution and saw it used a Set so I changed my ArrayList to a Set and it worked. Why does a Set work but not an Array List?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you use contains in ArrayList, it is o(n)"
                    }
                ]
            },
            {
                "id": 1576803,
                "content": [
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation \\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/"
                    },
                    {
                        "username": "user3379wo",
                        "content": "Hmm, is it actually the fastest solution? I used this exact approach (a hashmap) and it only beats 70% of solutions time wise."
                    },
                    {
                        "username": "peanutavenger",
                        "content": "lmao\\n   \\n\\treturn False if len(nums) == len(set(nums)) else True"
                    },
                    {
                        "username": "ezraorich",
                        "content": "lmao what a genius <3"
                    },
                    {
                        "username": "tejaschauhan2003",
                        "content": "what means of time limit exceeded"
                    },
                    {
                        "username": "AKaxor",
                        "content": "it means the life is short man , its like a little easter in cpp to remind us the value of time. -_-"
                    },
                    {
                        "username": "user3651PR",
                        "content": "Why is this giving me wrong answer in Testcase 1?\n\n ```class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for idx in range(len(nums)-1): # 0 ~length\n            if nums[idx] == nums[idx+1]:\n                return True\n        return False```"
                    },
                    {
                        "username": "OGx09",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) You don\\'t have to sort the given values to arrive at the solution"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "also your solution will not work if the nums array only has single element. "
                    },
                    {
                        "username": "sscswapnil",
                        "content": "Because you are comparing adjacent values, not with the other remaining value. "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "You could try sorting the array first. Once sorted, the duplicate values would be adjacent to each other. Before for loop, put nums.sort()"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // sorting array\\n        // for any same return true\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1) return false;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]) return true;\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user3651PR",
                        "content": " ```python\n     dups={}\n        for idx, num in enumerate(nums):\n            if num in dups:\n                return True\n           \n            dups[idx]=num\nreturn False\n````\n\nit works but fails on case like [3,3]\nshould return True but returns False"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your code lies in this line: `dups[idx]=num`. In your current code, you\\'re using the index (`idx`) as the key in your dictionary `dups` and the number (`num`) as the value. This means that when you\\'re checking if `num in dups`, you\\'re actually checking if `num` is one of the keys in the dictionary, which it is not since the keys are the indices.\\n\\nYou should actually be using the number itself (`num`) as the key and the index (`idx`) as the value (or you could just use any value if you don\\'t need the index). This way, you\\'re correctly checking if the number is already in the dictionary.\\n\\nHere\\'s how you can fix your code:\\n\\n```python\\ndups={}\\nfor idx, num in enumerate(nums):\\n    if num in dups:\\n        return True\\n    dups[num] = idx  # num is the key, idx is the value\\nreturn False\\n```\\n\\nNow the code will correctly return `True` for the input `[3,3]`."
                    },
                    {
                        "username": "billxu1975",
                        "content": "It seems line3 is checking if dups has this key num instead of checking the value. "
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\n"
                    },
                    {
                        "username": "khaled_acmilan",
                        "content": "\\tpublic bool ContainsDuplicate(int[] nums) {\\n\\t\\t\\treturn new HashSet<int>(nums).Count < nums.Length;\\n\\t}"
                    },
                    {
                        "username": "DivyanshSangal",
                        "content": "How are hashset based solution slower than the sorting based solutions in cpp?"
                    },
                    {
                        "username": "bbare",
                        "content": "My original solution was to use an ArrayList to see if there has been a duplicate. My solution passed all TestCases but I got a TIme Limit Exceeded. I looked at the solution and saw it used a Set so I changed my ArrayList to a Set and it worked. Why does a Set work but not an Array List?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you use contains in ArrayList, it is o(n)"
                    }
                ]
            },
            {
                "id": 1575747,
                "content": [
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation \\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/"
                    },
                    {
                        "username": "user3379wo",
                        "content": "Hmm, is it actually the fastest solution? I used this exact approach (a hashmap) and it only beats 70% of solutions time wise."
                    },
                    {
                        "username": "peanutavenger",
                        "content": "lmao\\n   \\n\\treturn False if len(nums) == len(set(nums)) else True"
                    },
                    {
                        "username": "ezraorich",
                        "content": "lmao what a genius <3"
                    },
                    {
                        "username": "tejaschauhan2003",
                        "content": "what means of time limit exceeded"
                    },
                    {
                        "username": "AKaxor",
                        "content": "it means the life is short man , its like a little easter in cpp to remind us the value of time. -_-"
                    },
                    {
                        "username": "user3651PR",
                        "content": "Why is this giving me wrong answer in Testcase 1?\n\n ```class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for idx in range(len(nums)-1): # 0 ~length\n            if nums[idx] == nums[idx+1]:\n                return True\n        return False```"
                    },
                    {
                        "username": "OGx09",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) You don\\'t have to sort the given values to arrive at the solution"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "also your solution will not work if the nums array only has single element. "
                    },
                    {
                        "username": "sscswapnil",
                        "content": "Because you are comparing adjacent values, not with the other remaining value. "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "You could try sorting the array first. Once sorted, the duplicate values would be adjacent to each other. Before for loop, put nums.sort()"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // sorting array\\n        // for any same return true\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1) return false;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]) return true;\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user3651PR",
                        "content": " ```python\n     dups={}\n        for idx, num in enumerate(nums):\n            if num in dups:\n                return True\n           \n            dups[idx]=num\nreturn False\n````\n\nit works but fails on case like [3,3]\nshould return True but returns False"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your code lies in this line: `dups[idx]=num`. In your current code, you\\'re using the index (`idx`) as the key in your dictionary `dups` and the number (`num`) as the value. This means that when you\\'re checking if `num in dups`, you\\'re actually checking if `num` is one of the keys in the dictionary, which it is not since the keys are the indices.\\n\\nYou should actually be using the number itself (`num`) as the key and the index (`idx`) as the value (or you could just use any value if you don\\'t need the index). This way, you\\'re correctly checking if the number is already in the dictionary.\\n\\nHere\\'s how you can fix your code:\\n\\n```python\\ndups={}\\nfor idx, num in enumerate(nums):\\n    if num in dups:\\n        return True\\n    dups[num] = idx  # num is the key, idx is the value\\nreturn False\\n```\\n\\nNow the code will correctly return `True` for the input `[3,3]`."
                    },
                    {
                        "username": "billxu1975",
                        "content": "It seems line3 is checking if dups has this key num instead of checking the value. "
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\n"
                    },
                    {
                        "username": "khaled_acmilan",
                        "content": "\\tpublic bool ContainsDuplicate(int[] nums) {\\n\\t\\t\\treturn new HashSet<int>(nums).Count < nums.Length;\\n\\t}"
                    },
                    {
                        "username": "DivyanshSangal",
                        "content": "How are hashset based solution slower than the sorting based solutions in cpp?"
                    },
                    {
                        "username": "bbare",
                        "content": "My original solution was to use an ArrayList to see if there has been a duplicate. My solution passed all TestCases but I got a TIme Limit Exceeded. I looked at the solution and saw it used a Set so I changed my ArrayList to a Set and it worked. Why does a Set work but not an Array List?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you use contains in ArrayList, it is o(n)"
                    }
                ]
            },
            {
                "id": 1575560,
                "content": [
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation \\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/"
                    },
                    {
                        "username": "user3379wo",
                        "content": "Hmm, is it actually the fastest solution? I used this exact approach (a hashmap) and it only beats 70% of solutions time wise."
                    },
                    {
                        "username": "peanutavenger",
                        "content": "lmao\\n   \\n\\treturn False if len(nums) == len(set(nums)) else True"
                    },
                    {
                        "username": "ezraorich",
                        "content": "lmao what a genius <3"
                    },
                    {
                        "username": "tejaschauhan2003",
                        "content": "what means of time limit exceeded"
                    },
                    {
                        "username": "AKaxor",
                        "content": "it means the life is short man , its like a little easter in cpp to remind us the value of time. -_-"
                    },
                    {
                        "username": "user3651PR",
                        "content": "Why is this giving me wrong answer in Testcase 1?\n\n ```class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for idx in range(len(nums)-1): # 0 ~length\n            if nums[idx] == nums[idx+1]:\n                return True\n        return False```"
                    },
                    {
                        "username": "OGx09",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) You don\\'t have to sort the given values to arrive at the solution"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "also your solution will not work if the nums array only has single element. "
                    },
                    {
                        "username": "sscswapnil",
                        "content": "Because you are comparing adjacent values, not with the other remaining value. "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "You could try sorting the array first. Once sorted, the duplicate values would be adjacent to each other. Before for loop, put nums.sort()"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // sorting array\\n        // for any same return true\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1) return false;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]) return true;\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user3651PR",
                        "content": " ```python\n     dups={}\n        for idx, num in enumerate(nums):\n            if num in dups:\n                return True\n           \n            dups[idx]=num\nreturn False\n````\n\nit works but fails on case like [3,3]\nshould return True but returns False"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your code lies in this line: `dups[idx]=num`. In your current code, you\\'re using the index (`idx`) as the key in your dictionary `dups` and the number (`num`) as the value. This means that when you\\'re checking if `num in dups`, you\\'re actually checking if `num` is one of the keys in the dictionary, which it is not since the keys are the indices.\\n\\nYou should actually be using the number itself (`num`) as the key and the index (`idx`) as the value (or you could just use any value if you don\\'t need the index). This way, you\\'re correctly checking if the number is already in the dictionary.\\n\\nHere\\'s how you can fix your code:\\n\\n```python\\ndups={}\\nfor idx, num in enumerate(nums):\\n    if num in dups:\\n        return True\\n    dups[num] = idx  # num is the key, idx is the value\\nreturn False\\n```\\n\\nNow the code will correctly return `True` for the input `[3,3]`."
                    },
                    {
                        "username": "billxu1975",
                        "content": "It seems line3 is checking if dups has this key num instead of checking the value. "
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\n"
                    },
                    {
                        "username": "khaled_acmilan",
                        "content": "\\tpublic bool ContainsDuplicate(int[] nums) {\\n\\t\\t\\treturn new HashSet<int>(nums).Count < nums.Length;\\n\\t}"
                    },
                    {
                        "username": "DivyanshSangal",
                        "content": "How are hashset based solution slower than the sorting based solutions in cpp?"
                    },
                    {
                        "username": "bbare",
                        "content": "My original solution was to use an ArrayList to see if there has been a duplicate. My solution passed all TestCases but I got a TIme Limit Exceeded. I looked at the solution and saw it used a Set so I changed my ArrayList to a Set and it worked. Why does a Set work but not an Array List?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you use contains in ArrayList, it is o(n)"
                    }
                ]
            },
            {
                "id": 1572842,
                "content": [
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation \\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/"
                    },
                    {
                        "username": "user3379wo",
                        "content": "Hmm, is it actually the fastest solution? I used this exact approach (a hashmap) and it only beats 70% of solutions time wise."
                    },
                    {
                        "username": "peanutavenger",
                        "content": "lmao\\n   \\n\\treturn False if len(nums) == len(set(nums)) else True"
                    },
                    {
                        "username": "ezraorich",
                        "content": "lmao what a genius <3"
                    },
                    {
                        "username": "tejaschauhan2003",
                        "content": "what means of time limit exceeded"
                    },
                    {
                        "username": "AKaxor",
                        "content": "it means the life is short man , its like a little easter in cpp to remind us the value of time. -_-"
                    },
                    {
                        "username": "user3651PR",
                        "content": "Why is this giving me wrong answer in Testcase 1?\n\n ```class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        for idx in range(len(nums)-1): # 0 ~length\n            if nums[idx] == nums[idx+1]:\n                return True\n        return False```"
                    },
                    {
                        "username": "OGx09",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) You don\\'t have to sort the given values to arrive at the solution"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "also your solution will not work if the nums array only has single element. "
                    },
                    {
                        "username": "sscswapnil",
                        "content": "Because you are comparing adjacent values, not with the other remaining value. "
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "You could try sorting the array first. Once sorted, the duplicate values would be adjacent to each other. Before for loop, put nums.sort()"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "```\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        // sorting array\\n        // for any same return true\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1) return false;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]) return true;\\n        }\\n        return false;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user3651PR",
                        "content": " ```python\n     dups={}\n        for idx, num in enumerate(nums):\n            if num in dups:\n                return True\n           \n            dups[idx]=num\nreturn False\n````\n\nit works but fails on case like [3,3]\nshould return True but returns False"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem with your code lies in this line: `dups[idx]=num`. In your current code, you\\'re using the index (`idx`) as the key in your dictionary `dups` and the number (`num`) as the value. This means that when you\\'re checking if `num in dups`, you\\'re actually checking if `num` is one of the keys in the dictionary, which it is not since the keys are the indices.\\n\\nYou should actually be using the number itself (`num`) as the key and the index (`idx`) as the value (or you could just use any value if you don\\'t need the index). This way, you\\'re correctly checking if the number is already in the dictionary.\\n\\nHere\\'s how you can fix your code:\\n\\n```python\\ndups={}\\nfor idx, num in enumerate(nums):\\n    if num in dups:\\n        return True\\n    dups[num] = idx  # num is the key, idx is the value\\nreturn False\\n```\\n\\nNow the code will correctly return `True` for the input `[3,3]`."
                    },
                    {
                        "username": "billxu1975",
                        "content": "It seems line3 is checking if dups has this key num instead of checking the value. "
                    },
                    {
                        "username": "callback_suman",
                        "content": "Fastest Solution and easy-to-understand and detailed video explanation with JavaScript\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\nIf you have any doubts, let me know in the comments section\\nIf it helps you please upvote.\\n"
                    },
                    {
                        "username": "khaled_acmilan",
                        "content": "\\tpublic bool ContainsDuplicate(int[] nums) {\\n\\t\\t\\treturn new HashSet<int>(nums).Count < nums.Length;\\n\\t}"
                    },
                    {
                        "username": "DivyanshSangal",
                        "content": "How are hashset based solution slower than the sorting based solutions in cpp?"
                    },
                    {
                        "username": "bbare",
                        "content": "My original solution was to use an ArrayList to see if there has been a duplicate. My solution passed all TestCases but I got a TIme Limit Exceeded. I looked at the solution and saw it used a Set so I changed my ArrayList to a Set and it worked. Why does a Set work but not an Array List?"
                    },
                    {
                        "username": "mochiball",
                        "content": "If you use contains in ArrayList, it is o(n)"
                    }
                ]
            },
            {
                "id": 1570225,
                "content": [
                    {
                        "username": "savushkin",
                        "content": "`return (len(nums) > len(set(nums)))`\\n\\n![image](https://assets.leetcode.com/users/images/6c07bfa7-b088-4392-9756-f32c55ae3e02_1605480083.7142534.png)\\n"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n         # Create an empty set to store unique numbers\\n        unique_nums = set()\\n        \\n        # Iterate through the array\\n        for num in nums:\\n            # If the number is already in the set, it\\'s a duplicate\\n            if num in unique_nums:\\n                return True\\n            # Add the number to the set\\n            unique_nums.add(num)\\n        \\n        # If we reach this point, there are no duplicates\\n        return False"
                    },
                    {
                        "username": "doddo",
                        "content": "at the following code, work for 70 case but when it test with 71. case its errors are java: code too large and  java: too many constants. What is the reason of these error message?\\n\\npublic static boolean containsDuplicate(int[] nums) {\\n        int control;\\n\\n        for(int i =0; i < nums.length; i++) {\\n            control = nums[i];\\n            int count;\\n            for(count = i +1; count < nums.length; count++) {\\n                if(control == nums[count]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "user9275Pd",
                        "content": "is it ok to use libraries and pre-written functions?"
                    },
                    {
                        "username": "mukunddhanukastudy",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    int i, j;\\n    for (i=0;i<numsSize;i++){\\n        for(j=i+1;j<numsSize;j++){\\n            if (nums[i] == nums[j] ){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "alexabu21",
                        "content": "hi , this code showing as time limit exceeded. \\nnot working\\n"
                    },
                    {
                        "username": "shrutikaj98",
                        "content": "Please click on link for solution : https://github.com/shrutikaj1098/Leet-Code---Python/blob/main/217.%20Contains%20Duplicate"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Step by step Solution explained with Video based different approach.\\n\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "Code\\n\\n`return len(nums) != len(set(nums))`\\n"
                    },
                    {
                        "username": "almiche",
                        "content": "def contains_duplicate(nums)\\n    nums.to_set.size < nums.size\\nend"
                    },
                    {
                        "username": "ravikumar7545",
                        "content": "var containsDuplicate = function (nums) {\\n  if(new Set(nums).size<nums.length) return true\\n  else return false\\n};"
                    }
                ]
            },
            {
                "id": 1897000,
                "content": [
                    {
                        "username": "savushkin",
                        "content": "`return (len(nums) > len(set(nums)))`\\n\\n![image](https://assets.leetcode.com/users/images/6c07bfa7-b088-4392-9756-f32c55ae3e02_1605480083.7142534.png)\\n"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n         # Create an empty set to store unique numbers\\n        unique_nums = set()\\n        \\n        # Iterate through the array\\n        for num in nums:\\n            # If the number is already in the set, it\\'s a duplicate\\n            if num in unique_nums:\\n                return True\\n            # Add the number to the set\\n            unique_nums.add(num)\\n        \\n        # If we reach this point, there are no duplicates\\n        return False"
                    },
                    {
                        "username": "doddo",
                        "content": "at the following code, work for 70 case but when it test with 71. case its errors are java: code too large and  java: too many constants. What is the reason of these error message?\\n\\npublic static boolean containsDuplicate(int[] nums) {\\n        int control;\\n\\n        for(int i =0; i < nums.length; i++) {\\n            control = nums[i];\\n            int count;\\n            for(count = i +1; count < nums.length; count++) {\\n                if(control == nums[count]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "user9275Pd",
                        "content": "is it ok to use libraries and pre-written functions?"
                    },
                    {
                        "username": "mukunddhanukastudy",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    int i, j;\\n    for (i=0;i<numsSize;i++){\\n        for(j=i+1;j<numsSize;j++){\\n            if (nums[i] == nums[j] ){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "alexabu21",
                        "content": "hi , this code showing as time limit exceeded. \\nnot working\\n"
                    },
                    {
                        "username": "shrutikaj98",
                        "content": "Please click on link for solution : https://github.com/shrutikaj1098/Leet-Code---Python/blob/main/217.%20Contains%20Duplicate"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Step by step Solution explained with Video based different approach.\\n\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "Code\\n\\n`return len(nums) != len(set(nums))`\\n"
                    },
                    {
                        "username": "almiche",
                        "content": "def contains_duplicate(nums)\\n    nums.to_set.size < nums.size\\nend"
                    },
                    {
                        "username": "ravikumar7545",
                        "content": "var containsDuplicate = function (nums) {\\n  if(new Set(nums).size<nums.length) return true\\n  else return false\\n};"
                    }
                ]
            },
            {
                "id": 1848272,
                "content": [
                    {
                        "username": "savushkin",
                        "content": "`return (len(nums) > len(set(nums)))`\\n\\n![image](https://assets.leetcode.com/users/images/6c07bfa7-b088-4392-9756-f32c55ae3e02_1605480083.7142534.png)\\n"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n         # Create an empty set to store unique numbers\\n        unique_nums = set()\\n        \\n        # Iterate through the array\\n        for num in nums:\\n            # If the number is already in the set, it\\'s a duplicate\\n            if num in unique_nums:\\n                return True\\n            # Add the number to the set\\n            unique_nums.add(num)\\n        \\n        # If we reach this point, there are no duplicates\\n        return False"
                    },
                    {
                        "username": "doddo",
                        "content": "at the following code, work for 70 case but when it test with 71. case its errors are java: code too large and  java: too many constants. What is the reason of these error message?\\n\\npublic static boolean containsDuplicate(int[] nums) {\\n        int control;\\n\\n        for(int i =0; i < nums.length; i++) {\\n            control = nums[i];\\n            int count;\\n            for(count = i +1; count < nums.length; count++) {\\n                if(control == nums[count]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "user9275Pd",
                        "content": "is it ok to use libraries and pre-written functions?"
                    },
                    {
                        "username": "mukunddhanukastudy",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    int i, j;\\n    for (i=0;i<numsSize;i++){\\n        for(j=i+1;j<numsSize;j++){\\n            if (nums[i] == nums[j] ){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "alexabu21",
                        "content": "hi , this code showing as time limit exceeded. \\nnot working\\n"
                    },
                    {
                        "username": "shrutikaj98",
                        "content": "Please click on link for solution : https://github.com/shrutikaj1098/Leet-Code---Python/blob/main/217.%20Contains%20Duplicate"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Step by step Solution explained with Video based different approach.\\n\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "Code\\n\\n`return len(nums) != len(set(nums))`\\n"
                    },
                    {
                        "username": "almiche",
                        "content": "def contains_duplicate(nums)\\n    nums.to_set.size < nums.size\\nend"
                    },
                    {
                        "username": "ravikumar7545",
                        "content": "var containsDuplicate = function (nums) {\\n  if(new Set(nums).size<nums.length) return true\\n  else return false\\n};"
                    }
                ]
            },
            {
                "id": 1793428,
                "content": [
                    {
                        "username": "savushkin",
                        "content": "`return (len(nums) > len(set(nums)))`\\n\\n![image](https://assets.leetcode.com/users/images/6c07bfa7-b088-4392-9756-f32c55ae3e02_1605480083.7142534.png)\\n"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n         # Create an empty set to store unique numbers\\n        unique_nums = set()\\n        \\n        # Iterate through the array\\n        for num in nums:\\n            # If the number is already in the set, it\\'s a duplicate\\n            if num in unique_nums:\\n                return True\\n            # Add the number to the set\\n            unique_nums.add(num)\\n        \\n        # If we reach this point, there are no duplicates\\n        return False"
                    },
                    {
                        "username": "doddo",
                        "content": "at the following code, work for 70 case but when it test with 71. case its errors are java: code too large and  java: too many constants. What is the reason of these error message?\\n\\npublic static boolean containsDuplicate(int[] nums) {\\n        int control;\\n\\n        for(int i =0; i < nums.length; i++) {\\n            control = nums[i];\\n            int count;\\n            for(count = i +1; count < nums.length; count++) {\\n                if(control == nums[count]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "user9275Pd",
                        "content": "is it ok to use libraries and pre-written functions?"
                    },
                    {
                        "username": "mukunddhanukastudy",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    int i, j;\\n    for (i=0;i<numsSize;i++){\\n        for(j=i+1;j<numsSize;j++){\\n            if (nums[i] == nums[j] ){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "alexabu21",
                        "content": "hi , this code showing as time limit exceeded. \\nnot working\\n"
                    },
                    {
                        "username": "shrutikaj98",
                        "content": "Please click on link for solution : https://github.com/shrutikaj1098/Leet-Code---Python/blob/main/217.%20Contains%20Duplicate"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Step by step Solution explained with Video based different approach.\\n\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "Code\\n\\n`return len(nums) != len(set(nums))`\\n"
                    },
                    {
                        "username": "almiche",
                        "content": "def contains_duplicate(nums)\\n    nums.to_set.size < nums.size\\nend"
                    },
                    {
                        "username": "ravikumar7545",
                        "content": "var containsDuplicate = function (nums) {\\n  if(new Set(nums).size<nums.length) return true\\n  else return false\\n};"
                    }
                ]
            },
            {
                "id": 1752790,
                "content": [
                    {
                        "username": "savushkin",
                        "content": "`return (len(nums) > len(set(nums)))`\\n\\n![image](https://assets.leetcode.com/users/images/6c07bfa7-b088-4392-9756-f32c55ae3e02_1605480083.7142534.png)\\n"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n         # Create an empty set to store unique numbers\\n        unique_nums = set()\\n        \\n        # Iterate through the array\\n        for num in nums:\\n            # If the number is already in the set, it\\'s a duplicate\\n            if num in unique_nums:\\n                return True\\n            # Add the number to the set\\n            unique_nums.add(num)\\n        \\n        # If we reach this point, there are no duplicates\\n        return False"
                    },
                    {
                        "username": "doddo",
                        "content": "at the following code, work for 70 case but when it test with 71. case its errors are java: code too large and  java: too many constants. What is the reason of these error message?\\n\\npublic static boolean containsDuplicate(int[] nums) {\\n        int control;\\n\\n        for(int i =0; i < nums.length; i++) {\\n            control = nums[i];\\n            int count;\\n            for(count = i +1; count < nums.length; count++) {\\n                if(control == nums[count]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "user9275Pd",
                        "content": "is it ok to use libraries and pre-written functions?"
                    },
                    {
                        "username": "mukunddhanukastudy",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    int i, j;\\n    for (i=0;i<numsSize;i++){\\n        for(j=i+1;j<numsSize;j++){\\n            if (nums[i] == nums[j] ){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "alexabu21",
                        "content": "hi , this code showing as time limit exceeded. \\nnot working\\n"
                    },
                    {
                        "username": "shrutikaj98",
                        "content": "Please click on link for solution : https://github.com/shrutikaj1098/Leet-Code---Python/blob/main/217.%20Contains%20Duplicate"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Step by step Solution explained with Video based different approach.\\n\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "Code\\n\\n`return len(nums) != len(set(nums))`\\n"
                    },
                    {
                        "username": "almiche",
                        "content": "def contains_duplicate(nums)\\n    nums.to_set.size < nums.size\\nend"
                    },
                    {
                        "username": "ravikumar7545",
                        "content": "var containsDuplicate = function (nums) {\\n  if(new Set(nums).size<nums.length) return true\\n  else return false\\n};"
                    }
                ]
            },
            {
                "id": 1576859,
                "content": [
                    {
                        "username": "savushkin",
                        "content": "`return (len(nums) > len(set(nums)))`\\n\\n![image](https://assets.leetcode.com/users/images/6c07bfa7-b088-4392-9756-f32c55ae3e02_1605480083.7142534.png)\\n"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n         # Create an empty set to store unique numbers\\n        unique_nums = set()\\n        \\n        # Iterate through the array\\n        for num in nums:\\n            # If the number is already in the set, it\\'s a duplicate\\n            if num in unique_nums:\\n                return True\\n            # Add the number to the set\\n            unique_nums.add(num)\\n        \\n        # If we reach this point, there are no duplicates\\n        return False"
                    },
                    {
                        "username": "doddo",
                        "content": "at the following code, work for 70 case but when it test with 71. case its errors are java: code too large and  java: too many constants. What is the reason of these error message?\\n\\npublic static boolean containsDuplicate(int[] nums) {\\n        int control;\\n\\n        for(int i =0; i < nums.length; i++) {\\n            control = nums[i];\\n            int count;\\n            for(count = i +1; count < nums.length; count++) {\\n                if(control == nums[count]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "user9275Pd",
                        "content": "is it ok to use libraries and pre-written functions?"
                    },
                    {
                        "username": "mukunddhanukastudy",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    int i, j;\\n    for (i=0;i<numsSize;i++){\\n        for(j=i+1;j<numsSize;j++){\\n            if (nums[i] == nums[j] ){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "alexabu21",
                        "content": "hi , this code showing as time limit exceeded. \\nnot working\\n"
                    },
                    {
                        "username": "shrutikaj98",
                        "content": "Please click on link for solution : https://github.com/shrutikaj1098/Leet-Code---Python/blob/main/217.%20Contains%20Duplicate"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Step by step Solution explained with Video based different approach.\\n\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "Code\\n\\n`return len(nums) != len(set(nums))`\\n"
                    },
                    {
                        "username": "almiche",
                        "content": "def contains_duplicate(nums)\\n    nums.to_set.size < nums.size\\nend"
                    },
                    {
                        "username": "ravikumar7545",
                        "content": "var containsDuplicate = function (nums) {\\n  if(new Set(nums).size<nums.length) return true\\n  else return false\\n};"
                    }
                ]
            },
            {
                "id": 1576754,
                "content": [
                    {
                        "username": "savushkin",
                        "content": "`return (len(nums) > len(set(nums)))`\\n\\n![image](https://assets.leetcode.com/users/images/6c07bfa7-b088-4392-9756-f32c55ae3e02_1605480083.7142534.png)\\n"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n         # Create an empty set to store unique numbers\\n        unique_nums = set()\\n        \\n        # Iterate through the array\\n        for num in nums:\\n            # If the number is already in the set, it\\'s a duplicate\\n            if num in unique_nums:\\n                return True\\n            # Add the number to the set\\n            unique_nums.add(num)\\n        \\n        # If we reach this point, there are no duplicates\\n        return False"
                    },
                    {
                        "username": "doddo",
                        "content": "at the following code, work for 70 case but when it test with 71. case its errors are java: code too large and  java: too many constants. What is the reason of these error message?\\n\\npublic static boolean containsDuplicate(int[] nums) {\\n        int control;\\n\\n        for(int i =0; i < nums.length; i++) {\\n            control = nums[i];\\n            int count;\\n            for(count = i +1; count < nums.length; count++) {\\n                if(control == nums[count]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "user9275Pd",
                        "content": "is it ok to use libraries and pre-written functions?"
                    },
                    {
                        "username": "mukunddhanukastudy",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    int i, j;\\n    for (i=0;i<numsSize;i++){\\n        for(j=i+1;j<numsSize;j++){\\n            if (nums[i] == nums[j] ){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "alexabu21",
                        "content": "hi , this code showing as time limit exceeded. \\nnot working\\n"
                    },
                    {
                        "username": "shrutikaj98",
                        "content": "Please click on link for solution : https://github.com/shrutikaj1098/Leet-Code---Python/blob/main/217.%20Contains%20Duplicate"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Step by step Solution explained with Video based different approach.\\n\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "Code\\n\\n`return len(nums) != len(set(nums))`\\n"
                    },
                    {
                        "username": "almiche",
                        "content": "def contains_duplicate(nums)\\n    nums.to_set.size < nums.size\\nend"
                    },
                    {
                        "username": "ravikumar7545",
                        "content": "var containsDuplicate = function (nums) {\\n  if(new Set(nums).size<nums.length) return true\\n  else return false\\n};"
                    }
                ]
            },
            {
                "id": 1576623,
                "content": [
                    {
                        "username": "savushkin",
                        "content": "`return (len(nums) > len(set(nums)))`\\n\\n![image](https://assets.leetcode.com/users/images/6c07bfa7-b088-4392-9756-f32c55ae3e02_1605480083.7142534.png)\\n"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n         # Create an empty set to store unique numbers\\n        unique_nums = set()\\n        \\n        # Iterate through the array\\n        for num in nums:\\n            # If the number is already in the set, it\\'s a duplicate\\n            if num in unique_nums:\\n                return True\\n            # Add the number to the set\\n            unique_nums.add(num)\\n        \\n        # If we reach this point, there are no duplicates\\n        return False"
                    },
                    {
                        "username": "doddo",
                        "content": "at the following code, work for 70 case but when it test with 71. case its errors are java: code too large and  java: too many constants. What is the reason of these error message?\\n\\npublic static boolean containsDuplicate(int[] nums) {\\n        int control;\\n\\n        for(int i =0; i < nums.length; i++) {\\n            control = nums[i];\\n            int count;\\n            for(count = i +1; count < nums.length; count++) {\\n                if(control == nums[count]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "user9275Pd",
                        "content": "is it ok to use libraries and pre-written functions?"
                    },
                    {
                        "username": "mukunddhanukastudy",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    int i, j;\\n    for (i=0;i<numsSize;i++){\\n        for(j=i+1;j<numsSize;j++){\\n            if (nums[i] == nums[j] ){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "alexabu21",
                        "content": "hi , this code showing as time limit exceeded. \\nnot working\\n"
                    },
                    {
                        "username": "shrutikaj98",
                        "content": "Please click on link for solution : https://github.com/shrutikaj1098/Leet-Code---Python/blob/main/217.%20Contains%20Duplicate"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Step by step Solution explained with Video based different approach.\\n\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "Code\\n\\n`return len(nums) != len(set(nums))`\\n"
                    },
                    {
                        "username": "almiche",
                        "content": "def contains_duplicate(nums)\\n    nums.to_set.size < nums.size\\nend"
                    },
                    {
                        "username": "ravikumar7545",
                        "content": "var containsDuplicate = function (nums) {\\n  if(new Set(nums).size<nums.length) return true\\n  else return false\\n};"
                    }
                ]
            },
            {
                "id": 1576536,
                "content": [
                    {
                        "username": "savushkin",
                        "content": "`return (len(nums) > len(set(nums)))`\\n\\n![image](https://assets.leetcode.com/users/images/6c07bfa7-b088-4392-9756-f32c55ae3e02_1605480083.7142534.png)\\n"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n         # Create an empty set to store unique numbers\\n        unique_nums = set()\\n        \\n        # Iterate through the array\\n        for num in nums:\\n            # If the number is already in the set, it\\'s a duplicate\\n            if num in unique_nums:\\n                return True\\n            # Add the number to the set\\n            unique_nums.add(num)\\n        \\n        # If we reach this point, there are no duplicates\\n        return False"
                    },
                    {
                        "username": "doddo",
                        "content": "at the following code, work for 70 case but when it test with 71. case its errors are java: code too large and  java: too many constants. What is the reason of these error message?\\n\\npublic static boolean containsDuplicate(int[] nums) {\\n        int control;\\n\\n        for(int i =0; i < nums.length; i++) {\\n            control = nums[i];\\n            int count;\\n            for(count = i +1; count < nums.length; count++) {\\n                if(control == nums[count]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "user9275Pd",
                        "content": "is it ok to use libraries and pre-written functions?"
                    },
                    {
                        "username": "mukunddhanukastudy",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    int i, j;\\n    for (i=0;i<numsSize;i++){\\n        for(j=i+1;j<numsSize;j++){\\n            if (nums[i] == nums[j] ){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "alexabu21",
                        "content": "hi , this code showing as time limit exceeded. \\nnot working\\n"
                    },
                    {
                        "username": "shrutikaj98",
                        "content": "Please click on link for solution : https://github.com/shrutikaj1098/Leet-Code---Python/blob/main/217.%20Contains%20Duplicate"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Step by step Solution explained with Video based different approach.\\n\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "Code\\n\\n`return len(nums) != len(set(nums))`\\n"
                    },
                    {
                        "username": "almiche",
                        "content": "def contains_duplicate(nums)\\n    nums.to_set.size < nums.size\\nend"
                    },
                    {
                        "username": "ravikumar7545",
                        "content": "var containsDuplicate = function (nums) {\\n  if(new Set(nums).size<nums.length) return true\\n  else return false\\n};"
                    }
                ]
            },
            {
                "id": 1576443,
                "content": [
                    {
                        "username": "savushkin",
                        "content": "`return (len(nums) > len(set(nums)))`\\n\\n![image](https://assets.leetcode.com/users/images/6c07bfa7-b088-4392-9756-f32c55ae3e02_1605480083.7142534.png)\\n"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n         # Create an empty set to store unique numbers\\n        unique_nums = set()\\n        \\n        # Iterate through the array\\n        for num in nums:\\n            # If the number is already in the set, it\\'s a duplicate\\n            if num in unique_nums:\\n                return True\\n            # Add the number to the set\\n            unique_nums.add(num)\\n        \\n        # If we reach this point, there are no duplicates\\n        return False"
                    },
                    {
                        "username": "doddo",
                        "content": "at the following code, work for 70 case but when it test with 71. case its errors are java: code too large and  java: too many constants. What is the reason of these error message?\\n\\npublic static boolean containsDuplicate(int[] nums) {\\n        int control;\\n\\n        for(int i =0; i < nums.length; i++) {\\n            control = nums[i];\\n            int count;\\n            for(count = i +1; count < nums.length; count++) {\\n                if(control == nums[count]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }"
                    },
                    {
                        "username": "user9275Pd",
                        "content": "is it ok to use libraries and pre-written functions?"
                    },
                    {
                        "username": "mukunddhanukastudy",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    int i, j;\\n    for (i=0;i<numsSize;i++){\\n        for(j=i+1;j<numsSize;j++){\\n            if (nums[i] == nums[j] ){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "alexabu21",
                        "content": "hi , this code showing as time limit exceeded. \\nnot working\\n"
                    },
                    {
                        "username": "shrutikaj98",
                        "content": "Please click on link for solution : https://github.com/shrutikaj1098/Leet-Code---Python/blob/main/217.%20Contains%20Duplicate"
                    },
                    {
                        "username": "callback_suman",
                        "content": "Step by step Solution explained with Video based different approach.\\n\\nhttps://coderfact.com/data-structures/contains-duplicate-fastest-solution-explained/\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "Code\\n\\n`return len(nums) != len(set(nums))`\\n"
                    },
                    {
                        "username": "almiche",
                        "content": "def contains_duplicate(nums)\\n    nums.to_set.size < nums.size\\nend"
                    },
                    {
                        "username": "ravikumar7545",
                        "content": "var containsDuplicate = function (nums) {\\n  if(new Set(nums).size<nums.length) return true\\n  else return false\\n};"
                    }
                ]
            },
            {
                "id": 1575393,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "O(NlogN) time\\n![image](https://assets.leetcode.com/users/images/766d9967-76ad-4b43-9c44-f89aafce8954_1623524290.1304407.png)\\nO(NlogN) time with slightly slower runtime\\n![image](https://assets.leetcode.com/users/images/0e90aedc-29ba-4dba-a3e0-6913766873c4_1623524710.6862736.png)\\n\\n"
                    },
                    {
                        "username": "minhphuson1999",
                        "content": "\\tvar containsDuplicate = function(nums) {\\n\\t\\tif([...new Set(nums)].length === nums.length)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}"
                    },
                    {
                        "username": "Mahi_Al_Jawad",
                        "content": "The maximum number of elements should be mentioned in constrains. Even if I guess that by \"interger\" the problem setter meant signed 32 bit integer. :("
                    },
                    {
                        "username": "yawarmurtaza",
                        "content": "Anyone with Linear time complexity and no extra space?"
                    },
                    {
                        "username": "xudongxiang",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "nexla",
                        "content": "\\treturn not len(set(nums)) == len(nums)"
                    },
                    {
                        "username": "XingGuoZM",
                        "content": " return !([...new Set(nums)].length===nums.length);"
                    },
                    {
                        "username": "user3574B",
                        "content": "\\n `def contains_duplicate(nums)\\n    nums.uniq.length < nums.length\\n end`"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "len(nums) != len(set(nums))"
                    },
                    {
                        "username": "xuanyu-h",
                        "content": "    def contains_duplicate(nums)\\n      !(nums == nums.uniq)\\n    end"
                    }
                ]
            },
            {
                "id": 1575335,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "O(NlogN) time\\n![image](https://assets.leetcode.com/users/images/766d9967-76ad-4b43-9c44-f89aafce8954_1623524290.1304407.png)\\nO(NlogN) time with slightly slower runtime\\n![image](https://assets.leetcode.com/users/images/0e90aedc-29ba-4dba-a3e0-6913766873c4_1623524710.6862736.png)\\n\\n"
                    },
                    {
                        "username": "minhphuson1999",
                        "content": "\\tvar containsDuplicate = function(nums) {\\n\\t\\tif([...new Set(nums)].length === nums.length)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}"
                    },
                    {
                        "username": "Mahi_Al_Jawad",
                        "content": "The maximum number of elements should be mentioned in constrains. Even if I guess that by \"interger\" the problem setter meant signed 32 bit integer. :("
                    },
                    {
                        "username": "yawarmurtaza",
                        "content": "Anyone with Linear time complexity and no extra space?"
                    },
                    {
                        "username": "xudongxiang",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "nexla",
                        "content": "\\treturn not len(set(nums)) == len(nums)"
                    },
                    {
                        "username": "XingGuoZM",
                        "content": " return !([...new Set(nums)].length===nums.length);"
                    },
                    {
                        "username": "user3574B",
                        "content": "\\n `def contains_duplicate(nums)\\n    nums.uniq.length < nums.length\\n end`"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "len(nums) != len(set(nums))"
                    },
                    {
                        "username": "xuanyu-h",
                        "content": "    def contains_duplicate(nums)\\n      !(nums == nums.uniq)\\n    end"
                    }
                ]
            },
            {
                "id": 1573687,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "O(NlogN) time\\n![image](https://assets.leetcode.com/users/images/766d9967-76ad-4b43-9c44-f89aafce8954_1623524290.1304407.png)\\nO(NlogN) time with slightly slower runtime\\n![image](https://assets.leetcode.com/users/images/0e90aedc-29ba-4dba-a3e0-6913766873c4_1623524710.6862736.png)\\n\\n"
                    },
                    {
                        "username": "minhphuson1999",
                        "content": "\\tvar containsDuplicate = function(nums) {\\n\\t\\tif([...new Set(nums)].length === nums.length)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}"
                    },
                    {
                        "username": "Mahi_Al_Jawad",
                        "content": "The maximum number of elements should be mentioned in constrains. Even if I guess that by \"interger\" the problem setter meant signed 32 bit integer. :("
                    },
                    {
                        "username": "yawarmurtaza",
                        "content": "Anyone with Linear time complexity and no extra space?"
                    },
                    {
                        "username": "xudongxiang",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "nexla",
                        "content": "\\treturn not len(set(nums)) == len(nums)"
                    },
                    {
                        "username": "XingGuoZM",
                        "content": " return !([...new Set(nums)].length===nums.length);"
                    },
                    {
                        "username": "user3574B",
                        "content": "\\n `def contains_duplicate(nums)\\n    nums.uniq.length < nums.length\\n end`"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "len(nums) != len(set(nums))"
                    },
                    {
                        "username": "xuanyu-h",
                        "content": "    def contains_duplicate(nums)\\n      !(nums == nums.uniq)\\n    end"
                    }
                ]
            },
            {
                "id": 1572540,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "O(NlogN) time\\n![image](https://assets.leetcode.com/users/images/766d9967-76ad-4b43-9c44-f89aafce8954_1623524290.1304407.png)\\nO(NlogN) time with slightly slower runtime\\n![image](https://assets.leetcode.com/users/images/0e90aedc-29ba-4dba-a3e0-6913766873c4_1623524710.6862736.png)\\n\\n"
                    },
                    {
                        "username": "minhphuson1999",
                        "content": "\\tvar containsDuplicate = function(nums) {\\n\\t\\tif([...new Set(nums)].length === nums.length)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}"
                    },
                    {
                        "username": "Mahi_Al_Jawad",
                        "content": "The maximum number of elements should be mentioned in constrains. Even if I guess that by \"interger\" the problem setter meant signed 32 bit integer. :("
                    },
                    {
                        "username": "yawarmurtaza",
                        "content": "Anyone with Linear time complexity and no extra space?"
                    },
                    {
                        "username": "xudongxiang",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "nexla",
                        "content": "\\treturn not len(set(nums)) == len(nums)"
                    },
                    {
                        "username": "XingGuoZM",
                        "content": " return !([...new Set(nums)].length===nums.length);"
                    },
                    {
                        "username": "user3574B",
                        "content": "\\n `def contains_duplicate(nums)\\n    nums.uniq.length < nums.length\\n end`"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "len(nums) != len(set(nums))"
                    },
                    {
                        "username": "xuanyu-h",
                        "content": "    def contains_duplicate(nums)\\n      !(nums == nums.uniq)\\n    end"
                    }
                ]
            },
            {
                "id": 1572525,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "O(NlogN) time\\n![image](https://assets.leetcode.com/users/images/766d9967-76ad-4b43-9c44-f89aafce8954_1623524290.1304407.png)\\nO(NlogN) time with slightly slower runtime\\n![image](https://assets.leetcode.com/users/images/0e90aedc-29ba-4dba-a3e0-6913766873c4_1623524710.6862736.png)\\n\\n"
                    },
                    {
                        "username": "minhphuson1999",
                        "content": "\\tvar containsDuplicate = function(nums) {\\n\\t\\tif([...new Set(nums)].length === nums.length)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}"
                    },
                    {
                        "username": "Mahi_Al_Jawad",
                        "content": "The maximum number of elements should be mentioned in constrains. Even if I guess that by \"interger\" the problem setter meant signed 32 bit integer. :("
                    },
                    {
                        "username": "yawarmurtaza",
                        "content": "Anyone with Linear time complexity and no extra space?"
                    },
                    {
                        "username": "xudongxiang",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "nexla",
                        "content": "\\treturn not len(set(nums)) == len(nums)"
                    },
                    {
                        "username": "XingGuoZM",
                        "content": " return !([...new Set(nums)].length===nums.length);"
                    },
                    {
                        "username": "user3574B",
                        "content": "\\n `def contains_duplicate(nums)\\n    nums.uniq.length < nums.length\\n end`"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "len(nums) != len(set(nums))"
                    },
                    {
                        "username": "xuanyu-h",
                        "content": "    def contains_duplicate(nums)\\n      !(nums == nums.uniq)\\n    end"
                    }
                ]
            },
            {
                "id": 1572382,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "O(NlogN) time\\n![image](https://assets.leetcode.com/users/images/766d9967-76ad-4b43-9c44-f89aafce8954_1623524290.1304407.png)\\nO(NlogN) time with slightly slower runtime\\n![image](https://assets.leetcode.com/users/images/0e90aedc-29ba-4dba-a3e0-6913766873c4_1623524710.6862736.png)\\n\\n"
                    },
                    {
                        "username": "minhphuson1999",
                        "content": "\\tvar containsDuplicate = function(nums) {\\n\\t\\tif([...new Set(nums)].length === nums.length)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}"
                    },
                    {
                        "username": "Mahi_Al_Jawad",
                        "content": "The maximum number of elements should be mentioned in constrains. Even if I guess that by \"interger\" the problem setter meant signed 32 bit integer. :("
                    },
                    {
                        "username": "yawarmurtaza",
                        "content": "Anyone with Linear time complexity and no extra space?"
                    },
                    {
                        "username": "xudongxiang",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "nexla",
                        "content": "\\treturn not len(set(nums)) == len(nums)"
                    },
                    {
                        "username": "XingGuoZM",
                        "content": " return !([...new Set(nums)].length===nums.length);"
                    },
                    {
                        "username": "user3574B",
                        "content": "\\n `def contains_duplicate(nums)\\n    nums.uniq.length < nums.length\\n end`"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "len(nums) != len(set(nums))"
                    },
                    {
                        "username": "xuanyu-h",
                        "content": "    def contains_duplicate(nums)\\n      !(nums == nums.uniq)\\n    end"
                    }
                ]
            },
            {
                "id": 1572099,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "O(NlogN) time\\n![image](https://assets.leetcode.com/users/images/766d9967-76ad-4b43-9c44-f89aafce8954_1623524290.1304407.png)\\nO(NlogN) time with slightly slower runtime\\n![image](https://assets.leetcode.com/users/images/0e90aedc-29ba-4dba-a3e0-6913766873c4_1623524710.6862736.png)\\n\\n"
                    },
                    {
                        "username": "minhphuson1999",
                        "content": "\\tvar containsDuplicate = function(nums) {\\n\\t\\tif([...new Set(nums)].length === nums.length)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}"
                    },
                    {
                        "username": "Mahi_Al_Jawad",
                        "content": "The maximum number of elements should be mentioned in constrains. Even if I guess that by \"interger\" the problem setter meant signed 32 bit integer. :("
                    },
                    {
                        "username": "yawarmurtaza",
                        "content": "Anyone with Linear time complexity and no extra space?"
                    },
                    {
                        "username": "xudongxiang",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "nexla",
                        "content": "\\treturn not len(set(nums)) == len(nums)"
                    },
                    {
                        "username": "XingGuoZM",
                        "content": " return !([...new Set(nums)].length===nums.length);"
                    },
                    {
                        "username": "user3574B",
                        "content": "\\n `def contains_duplicate(nums)\\n    nums.uniq.length < nums.length\\n end`"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "len(nums) != len(set(nums))"
                    },
                    {
                        "username": "xuanyu-h",
                        "content": "    def contains_duplicate(nums)\\n      !(nums == nums.uniq)\\n    end"
                    }
                ]
            },
            {
                "id": 1572010,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "O(NlogN) time\\n![image](https://assets.leetcode.com/users/images/766d9967-76ad-4b43-9c44-f89aafce8954_1623524290.1304407.png)\\nO(NlogN) time with slightly slower runtime\\n![image](https://assets.leetcode.com/users/images/0e90aedc-29ba-4dba-a3e0-6913766873c4_1623524710.6862736.png)\\n\\n"
                    },
                    {
                        "username": "minhphuson1999",
                        "content": "\\tvar containsDuplicate = function(nums) {\\n\\t\\tif([...new Set(nums)].length === nums.length)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}"
                    },
                    {
                        "username": "Mahi_Al_Jawad",
                        "content": "The maximum number of elements should be mentioned in constrains. Even if I guess that by \"interger\" the problem setter meant signed 32 bit integer. :("
                    },
                    {
                        "username": "yawarmurtaza",
                        "content": "Anyone with Linear time complexity and no extra space?"
                    },
                    {
                        "username": "xudongxiang",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "nexla",
                        "content": "\\treturn not len(set(nums)) == len(nums)"
                    },
                    {
                        "username": "XingGuoZM",
                        "content": " return !([...new Set(nums)].length===nums.length);"
                    },
                    {
                        "username": "user3574B",
                        "content": "\\n `def contains_duplicate(nums)\\n    nums.uniq.length < nums.length\\n end`"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "len(nums) != len(set(nums))"
                    },
                    {
                        "username": "xuanyu-h",
                        "content": "    def contains_duplicate(nums)\\n      !(nums == nums.uniq)\\n    end"
                    }
                ]
            },
            {
                "id": 1569337,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "O(NlogN) time\\n![image](https://assets.leetcode.com/users/images/766d9967-76ad-4b43-9c44-f89aafce8954_1623524290.1304407.png)\\nO(NlogN) time with slightly slower runtime\\n![image](https://assets.leetcode.com/users/images/0e90aedc-29ba-4dba-a3e0-6913766873c4_1623524710.6862736.png)\\n\\n"
                    },
                    {
                        "username": "minhphuson1999",
                        "content": "\\tvar containsDuplicate = function(nums) {\\n\\t\\tif([...new Set(nums)].length === nums.length)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}"
                    },
                    {
                        "username": "Mahi_Al_Jawad",
                        "content": "The maximum number of elements should be mentioned in constrains. Even if I guess that by \"interger\" the problem setter meant signed 32 bit integer. :("
                    },
                    {
                        "username": "yawarmurtaza",
                        "content": "Anyone with Linear time complexity and no extra space?"
                    },
                    {
                        "username": "xudongxiang",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "nexla",
                        "content": "\\treturn not len(set(nums)) == len(nums)"
                    },
                    {
                        "username": "XingGuoZM",
                        "content": " return !([...new Set(nums)].length===nums.length);"
                    },
                    {
                        "username": "user3574B",
                        "content": "\\n `def contains_duplicate(nums)\\n    nums.uniq.length < nums.length\\n end`"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "len(nums) != len(set(nums))"
                    },
                    {
                        "username": "xuanyu-h",
                        "content": "    def contains_duplicate(nums)\\n      !(nums == nums.uniq)\\n    end"
                    }
                ]
            },
            {
                "id": 1569026,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "O(NlogN) time\\n![image](https://assets.leetcode.com/users/images/766d9967-76ad-4b43-9c44-f89aafce8954_1623524290.1304407.png)\\nO(NlogN) time with slightly slower runtime\\n![image](https://assets.leetcode.com/users/images/0e90aedc-29ba-4dba-a3e0-6913766873c4_1623524710.6862736.png)\\n\\n"
                    },
                    {
                        "username": "minhphuson1999",
                        "content": "\\tvar containsDuplicate = function(nums) {\\n\\t\\tif([...new Set(nums)].length === nums.length)\\n\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}"
                    },
                    {
                        "username": "Mahi_Al_Jawad",
                        "content": "The maximum number of elements should be mentioned in constrains. Even if I guess that by \"interger\" the problem setter meant signed 32 bit integer. :("
                    },
                    {
                        "username": "yawarmurtaza",
                        "content": "Anyone with Linear time complexity and no extra space?"
                    },
                    {
                        "username": "xudongxiang",
                        "content": "return len(nums) != len(set(nums))"
                    },
                    {
                        "username": "nexla",
                        "content": "\\treturn not len(set(nums)) == len(nums)"
                    },
                    {
                        "username": "XingGuoZM",
                        "content": " return !([...new Set(nums)].length===nums.length);"
                    },
                    {
                        "username": "user3574B",
                        "content": "\\n `def contains_duplicate(nums)\\n    nums.uniq.length < nums.length\\n end`"
                    },
                    {
                        "username": "Apollo1840",
                        "content": "len(nums) != len(set(nums))"
                    },
                    {
                        "username": "xuanyu-h",
                        "content": "    def contains_duplicate(nums)\\n      !(nums == nums.uniq)\\n    end"
                    }
                ]
            },
            {
                "id": 1569027,
                "content": [
                    {
                        "username": "delongyang",
                        "content": "How to build a bitmap to solve this problem? Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Using a bitmap (also known as bitset) is a great way to solve this problem efficiently, especially if the input range is known and not excessively large. A bitmap uses a bit array where each boolean value is stored in a single bit. Here\\'s a general outline of how you could apply this to the problem of determining if an array contains any duplicates.\\n\\n1. Initialize a bitmap with enough bits to cover the entire range of possible input values. For example, if you know your inputs are always between 0 and 10^9, you might create a bitmap with 10^9 bits (though in practice this would be impractically large).\\n\\n2. Iterate over the array. For each number, check if its corresponding bit in the bitmap is set. If it is, then that number has appeared before and you can return `True`.\\n\\n3. If the bit was not set, then this is the first time we\\'ve seen this number. Set the corresponding bit in the bitmap.\\n\\n4. If you\\'ve gone through the entire array without finding any duplicates, return `False`.\\n\\nHere\\'s some Python-like pseudocode illustrating this approach:\\n\\n```python\\ndef contains_duplicate(nums):\\n    bitmap = BitArray(10**9)  # A hypothetical BitArray class\\n\\n    for num in nums:\\n        if bitmap[num]:\\n            return True\\n        else:\\n            bitmap[num] = True\\n\\n    return False\\n```\\n\\nPlease note that this pseudocode uses a hypothetical `BitArray` class for the sake of clarity. Python doesn\\'t have a built-in bit array type, but you could use a library like bitarray or use an integer as a bit array if the range of inputs is small.\\n\\nRemember that a bitmap would be impractical for this problem if the range of inputs is very large (like 10^9), as it would require a prohibitive amount of memory. This technique works best when the range of inputs is relatively small compared to the number of inputs.\\n\\nAlso, keep in mind that this solution assumes that all the input numbers are non-negative. If negative numbers are possible, you\\'d need to offset the numbers to make them non-negative before using them to index into the bitmap. For instance, if inputs are in the range -10^9 to 10^9, you can add 10^9 to each input to ensure they are all non-negative."
                    },
                    {
                        "username": "namankhandelwal59",
                        "content": "first using set \\nIn this approch fist insert all element of array insert in set than check size of set using set function if the size of set is same as array size than there is no duplicate value contain other wise contain duplicate value \\n\\nand second is using map\\n"
                    },
                    {
                        "username": "amiraslamov",
                        "content": "![image](https://assets.leetcode.com/users/images/bfd295d3-c504-4dbe-b9df-9a808035ef40_1639465424.1569192.png)\\n"
                    },
                    {
                        "username": "YASHPALSINH01",
                        "content": "******can anyone please provide the c code for this which is easier to understand as I\\'m just a begineer."
                    },
                    {
                        "username": "Khalid_01",
                        "content": "any way to solve this in constant space and linear time?\\n"
                    },
                    {
                        "username": "misumi7",
                        "content": "It becomes really easy when you use a hash set"
                    },
                    {
                        "username": "ategale",
                        "content": "How to get O(n) time and O(1) space?"
                    },
                    {
                        "username": "sergei99",
                        "content": "No way I guess."
                    },
                    {
                        "username": "slavsquatter",
                        "content": "Me solving the problem:   :D\\nMe exceeding the time limit:  >:( "
                    },
                    {
                        "username": "0bro",
                        "content": "Person who\\'s studied algorithms before doing leetcode will laugh at the final answer lol "
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "I'm a bit new to the files concept in Python, So can anyone tell me how this solution actually works, beacuse all I can understand is that we're opening a file and then printing... \n`\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        #return len(set(nums)) != len(nums)\n        f = open('user.out', 'w')\n        print('''true\nfalse\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue\nfalse\n        ''',file=f)\n        exit(0) `\n I did solve using the hashmap and an optimization version of hashmap.\n "
                    },
                    {
                        "username": "sergei99",
                        "content": "This solution cheats. It writes the expected test output straight to the output file used by the test engine. Such kind of solution is useless in solving real life problems."
                    }
                ]
            },
            {
                "id": 1567713,
                "content": [
                    {
                        "username": "delongyang",
                        "content": "How to build a bitmap to solve this problem? Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Using a bitmap (also known as bitset) is a great way to solve this problem efficiently, especially if the input range is known and not excessively large. A bitmap uses a bit array where each boolean value is stored in a single bit. Here\\'s a general outline of how you could apply this to the problem of determining if an array contains any duplicates.\\n\\n1. Initialize a bitmap with enough bits to cover the entire range of possible input values. For example, if you know your inputs are always between 0 and 10^9, you might create a bitmap with 10^9 bits (though in practice this would be impractically large).\\n\\n2. Iterate over the array. For each number, check if its corresponding bit in the bitmap is set. If it is, then that number has appeared before and you can return `True`.\\n\\n3. If the bit was not set, then this is the first time we\\'ve seen this number. Set the corresponding bit in the bitmap.\\n\\n4. If you\\'ve gone through the entire array without finding any duplicates, return `False`.\\n\\nHere\\'s some Python-like pseudocode illustrating this approach:\\n\\n```python\\ndef contains_duplicate(nums):\\n    bitmap = BitArray(10**9)  # A hypothetical BitArray class\\n\\n    for num in nums:\\n        if bitmap[num]:\\n            return True\\n        else:\\n            bitmap[num] = True\\n\\n    return False\\n```\\n\\nPlease note that this pseudocode uses a hypothetical `BitArray` class for the sake of clarity. Python doesn\\'t have a built-in bit array type, but you could use a library like bitarray or use an integer as a bit array if the range of inputs is small.\\n\\nRemember that a bitmap would be impractical for this problem if the range of inputs is very large (like 10^9), as it would require a prohibitive amount of memory. This technique works best when the range of inputs is relatively small compared to the number of inputs.\\n\\nAlso, keep in mind that this solution assumes that all the input numbers are non-negative. If negative numbers are possible, you\\'d need to offset the numbers to make them non-negative before using them to index into the bitmap. For instance, if inputs are in the range -10^9 to 10^9, you can add 10^9 to each input to ensure they are all non-negative."
                    },
                    {
                        "username": "namankhandelwal59",
                        "content": "first using set \\nIn this approch fist insert all element of array insert in set than check size of set using set function if the size of set is same as array size than there is no duplicate value contain other wise contain duplicate value \\n\\nand second is using map\\n"
                    },
                    {
                        "username": "amiraslamov",
                        "content": "![image](https://assets.leetcode.com/users/images/bfd295d3-c504-4dbe-b9df-9a808035ef40_1639465424.1569192.png)\\n"
                    },
                    {
                        "username": "YASHPALSINH01",
                        "content": "******can anyone please provide the c code for this which is easier to understand as I\\'m just a begineer."
                    },
                    {
                        "username": "Khalid_01",
                        "content": "any way to solve this in constant space and linear time?\\n"
                    },
                    {
                        "username": "misumi7",
                        "content": "It becomes really easy when you use a hash set"
                    },
                    {
                        "username": "ategale",
                        "content": "How to get O(n) time and O(1) space?"
                    },
                    {
                        "username": "sergei99",
                        "content": "No way I guess."
                    },
                    {
                        "username": "slavsquatter",
                        "content": "Me solving the problem:   :D\\nMe exceeding the time limit:  >:( "
                    },
                    {
                        "username": "0bro",
                        "content": "Person who\\'s studied algorithms before doing leetcode will laugh at the final answer lol "
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "I'm a bit new to the files concept in Python, So can anyone tell me how this solution actually works, beacuse all I can understand is that we're opening a file and then printing... \n`\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        #return len(set(nums)) != len(nums)\n        f = open('user.out', 'w')\n        print('''true\nfalse\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue\nfalse\n        ''',file=f)\n        exit(0) `\n I did solve using the hashmap and an optimization version of hashmap.\n "
                    },
                    {
                        "username": "sergei99",
                        "content": "This solution cheats. It writes the expected test output straight to the output file used by the test engine. Such kind of solution is useless in solving real life problems."
                    }
                ]
            },
            {
                "id": 1576087,
                "content": [
                    {
                        "username": "delongyang",
                        "content": "How to build a bitmap to solve this problem? Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Using a bitmap (also known as bitset) is a great way to solve this problem efficiently, especially if the input range is known and not excessively large. A bitmap uses a bit array where each boolean value is stored in a single bit. Here\\'s a general outline of how you could apply this to the problem of determining if an array contains any duplicates.\\n\\n1. Initialize a bitmap with enough bits to cover the entire range of possible input values. For example, if you know your inputs are always between 0 and 10^9, you might create a bitmap with 10^9 bits (though in practice this would be impractically large).\\n\\n2. Iterate over the array. For each number, check if its corresponding bit in the bitmap is set. If it is, then that number has appeared before and you can return `True`.\\n\\n3. If the bit was not set, then this is the first time we\\'ve seen this number. Set the corresponding bit in the bitmap.\\n\\n4. If you\\'ve gone through the entire array without finding any duplicates, return `False`.\\n\\nHere\\'s some Python-like pseudocode illustrating this approach:\\n\\n```python\\ndef contains_duplicate(nums):\\n    bitmap = BitArray(10**9)  # A hypothetical BitArray class\\n\\n    for num in nums:\\n        if bitmap[num]:\\n            return True\\n        else:\\n            bitmap[num] = True\\n\\n    return False\\n```\\n\\nPlease note that this pseudocode uses a hypothetical `BitArray` class for the sake of clarity. Python doesn\\'t have a built-in bit array type, but you could use a library like bitarray or use an integer as a bit array if the range of inputs is small.\\n\\nRemember that a bitmap would be impractical for this problem if the range of inputs is very large (like 10^9), as it would require a prohibitive amount of memory. This technique works best when the range of inputs is relatively small compared to the number of inputs.\\n\\nAlso, keep in mind that this solution assumes that all the input numbers are non-negative. If negative numbers are possible, you\\'d need to offset the numbers to make them non-negative before using them to index into the bitmap. For instance, if inputs are in the range -10^9 to 10^9, you can add 10^9 to each input to ensure they are all non-negative."
                    },
                    {
                        "username": "namankhandelwal59",
                        "content": "first using set \\nIn this approch fist insert all element of array insert in set than check size of set using set function if the size of set is same as array size than there is no duplicate value contain other wise contain duplicate value \\n\\nand second is using map\\n"
                    },
                    {
                        "username": "amiraslamov",
                        "content": "![image](https://assets.leetcode.com/users/images/bfd295d3-c504-4dbe-b9df-9a808035ef40_1639465424.1569192.png)\\n"
                    },
                    {
                        "username": "YASHPALSINH01",
                        "content": "******can anyone please provide the c code for this which is easier to understand as I\\'m just a begineer."
                    },
                    {
                        "username": "Khalid_01",
                        "content": "any way to solve this in constant space and linear time?\\n"
                    },
                    {
                        "username": "misumi7",
                        "content": "It becomes really easy when you use a hash set"
                    },
                    {
                        "username": "ategale",
                        "content": "How to get O(n) time and O(1) space?"
                    },
                    {
                        "username": "sergei99",
                        "content": "No way I guess."
                    },
                    {
                        "username": "slavsquatter",
                        "content": "Me solving the problem:   :D\\nMe exceeding the time limit:  >:( "
                    },
                    {
                        "username": "0bro",
                        "content": "Person who\\'s studied algorithms before doing leetcode will laugh at the final answer lol "
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "I'm a bit new to the files concept in Python, So can anyone tell me how this solution actually works, beacuse all I can understand is that we're opening a file and then printing... \n`\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        #return len(set(nums)) != len(nums)\n        f = open('user.out', 'w')\n        print('''true\nfalse\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue\nfalse\n        ''',file=f)\n        exit(0) `\n I did solve using the hashmap and an optimization version of hashmap.\n "
                    },
                    {
                        "username": "sergei99",
                        "content": "This solution cheats. It writes the expected test output straight to the output file used by the test engine. Such kind of solution is useless in solving real life problems."
                    }
                ]
            },
            {
                "id": 1575857,
                "content": [
                    {
                        "username": "delongyang",
                        "content": "How to build a bitmap to solve this problem? Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Using a bitmap (also known as bitset) is a great way to solve this problem efficiently, especially if the input range is known and not excessively large. A bitmap uses a bit array where each boolean value is stored in a single bit. Here\\'s a general outline of how you could apply this to the problem of determining if an array contains any duplicates.\\n\\n1. Initialize a bitmap with enough bits to cover the entire range of possible input values. For example, if you know your inputs are always between 0 and 10^9, you might create a bitmap with 10^9 bits (though in practice this would be impractically large).\\n\\n2. Iterate over the array. For each number, check if its corresponding bit in the bitmap is set. If it is, then that number has appeared before and you can return `True`.\\n\\n3. If the bit was not set, then this is the first time we\\'ve seen this number. Set the corresponding bit in the bitmap.\\n\\n4. If you\\'ve gone through the entire array without finding any duplicates, return `False`.\\n\\nHere\\'s some Python-like pseudocode illustrating this approach:\\n\\n```python\\ndef contains_duplicate(nums):\\n    bitmap = BitArray(10**9)  # A hypothetical BitArray class\\n\\n    for num in nums:\\n        if bitmap[num]:\\n            return True\\n        else:\\n            bitmap[num] = True\\n\\n    return False\\n```\\n\\nPlease note that this pseudocode uses a hypothetical `BitArray` class for the sake of clarity. Python doesn\\'t have a built-in bit array type, but you could use a library like bitarray or use an integer as a bit array if the range of inputs is small.\\n\\nRemember that a bitmap would be impractical for this problem if the range of inputs is very large (like 10^9), as it would require a prohibitive amount of memory. This technique works best when the range of inputs is relatively small compared to the number of inputs.\\n\\nAlso, keep in mind that this solution assumes that all the input numbers are non-negative. If negative numbers are possible, you\\'d need to offset the numbers to make them non-negative before using them to index into the bitmap. For instance, if inputs are in the range -10^9 to 10^9, you can add 10^9 to each input to ensure they are all non-negative."
                    },
                    {
                        "username": "namankhandelwal59",
                        "content": "first using set \\nIn this approch fist insert all element of array insert in set than check size of set using set function if the size of set is same as array size than there is no duplicate value contain other wise contain duplicate value \\n\\nand second is using map\\n"
                    },
                    {
                        "username": "amiraslamov",
                        "content": "![image](https://assets.leetcode.com/users/images/bfd295d3-c504-4dbe-b9df-9a808035ef40_1639465424.1569192.png)\\n"
                    },
                    {
                        "username": "YASHPALSINH01",
                        "content": "******can anyone please provide the c code for this which is easier to understand as I\\'m just a begineer."
                    },
                    {
                        "username": "Khalid_01",
                        "content": "any way to solve this in constant space and linear time?\\n"
                    },
                    {
                        "username": "misumi7",
                        "content": "It becomes really easy when you use a hash set"
                    },
                    {
                        "username": "ategale",
                        "content": "How to get O(n) time and O(1) space?"
                    },
                    {
                        "username": "sergei99",
                        "content": "No way I guess."
                    },
                    {
                        "username": "slavsquatter",
                        "content": "Me solving the problem:   :D\\nMe exceeding the time limit:  >:( "
                    },
                    {
                        "username": "0bro",
                        "content": "Person who\\'s studied algorithms before doing leetcode will laugh at the final answer lol "
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "I'm a bit new to the files concept in Python, So can anyone tell me how this solution actually works, beacuse all I can understand is that we're opening a file and then printing... \n`\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        #return len(set(nums)) != len(nums)\n        f = open('user.out', 'w')\n        print('''true\nfalse\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue\nfalse\n        ''',file=f)\n        exit(0) `\n I did solve using the hashmap and an optimization version of hashmap.\n "
                    },
                    {
                        "username": "sergei99",
                        "content": "This solution cheats. It writes the expected test output straight to the output file used by the test engine. Such kind of solution is useless in solving real life problems."
                    }
                ]
            },
            {
                "id": 2077164,
                "content": [
                    {
                        "username": "delongyang",
                        "content": "How to build a bitmap to solve this problem? Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Using a bitmap (also known as bitset) is a great way to solve this problem efficiently, especially if the input range is known and not excessively large. A bitmap uses a bit array where each boolean value is stored in a single bit. Here\\'s a general outline of how you could apply this to the problem of determining if an array contains any duplicates.\\n\\n1. Initialize a bitmap with enough bits to cover the entire range of possible input values. For example, if you know your inputs are always between 0 and 10^9, you might create a bitmap with 10^9 bits (though in practice this would be impractically large).\\n\\n2. Iterate over the array. For each number, check if its corresponding bit in the bitmap is set. If it is, then that number has appeared before and you can return `True`.\\n\\n3. If the bit was not set, then this is the first time we\\'ve seen this number. Set the corresponding bit in the bitmap.\\n\\n4. If you\\'ve gone through the entire array without finding any duplicates, return `False`.\\n\\nHere\\'s some Python-like pseudocode illustrating this approach:\\n\\n```python\\ndef contains_duplicate(nums):\\n    bitmap = BitArray(10**9)  # A hypothetical BitArray class\\n\\n    for num in nums:\\n        if bitmap[num]:\\n            return True\\n        else:\\n            bitmap[num] = True\\n\\n    return False\\n```\\n\\nPlease note that this pseudocode uses a hypothetical `BitArray` class for the sake of clarity. Python doesn\\'t have a built-in bit array type, but you could use a library like bitarray or use an integer as a bit array if the range of inputs is small.\\n\\nRemember that a bitmap would be impractical for this problem if the range of inputs is very large (like 10^9), as it would require a prohibitive amount of memory. This technique works best when the range of inputs is relatively small compared to the number of inputs.\\n\\nAlso, keep in mind that this solution assumes that all the input numbers are non-negative. If negative numbers are possible, you\\'d need to offset the numbers to make them non-negative before using them to index into the bitmap. For instance, if inputs are in the range -10^9 to 10^9, you can add 10^9 to each input to ensure they are all non-negative."
                    },
                    {
                        "username": "namankhandelwal59",
                        "content": "first using set \\nIn this approch fist insert all element of array insert in set than check size of set using set function if the size of set is same as array size than there is no duplicate value contain other wise contain duplicate value \\n\\nand second is using map\\n"
                    },
                    {
                        "username": "amiraslamov",
                        "content": "![image](https://assets.leetcode.com/users/images/bfd295d3-c504-4dbe-b9df-9a808035ef40_1639465424.1569192.png)\\n"
                    },
                    {
                        "username": "YASHPALSINH01",
                        "content": "******can anyone please provide the c code for this which is easier to understand as I\\'m just a begineer."
                    },
                    {
                        "username": "Khalid_01",
                        "content": "any way to solve this in constant space and linear time?\\n"
                    },
                    {
                        "username": "misumi7",
                        "content": "It becomes really easy when you use a hash set"
                    },
                    {
                        "username": "ategale",
                        "content": "How to get O(n) time and O(1) space?"
                    },
                    {
                        "username": "sergei99",
                        "content": "No way I guess."
                    },
                    {
                        "username": "slavsquatter",
                        "content": "Me solving the problem:   :D\\nMe exceeding the time limit:  >:( "
                    },
                    {
                        "username": "0bro",
                        "content": "Person who\\'s studied algorithms before doing leetcode will laugh at the final answer lol "
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "I'm a bit new to the files concept in Python, So can anyone tell me how this solution actually works, beacuse all I can understand is that we're opening a file and then printing... \n`\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        #return len(set(nums)) != len(nums)\n        f = open('user.out', 'w')\n        print('''true\nfalse\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue\nfalse\n        ''',file=f)\n        exit(0) `\n I did solve using the hashmap and an optimization version of hashmap.\n "
                    },
                    {
                        "username": "sergei99",
                        "content": "This solution cheats. It writes the expected test output straight to the output file used by the test engine. Such kind of solution is useless in solving real life problems."
                    }
                ]
            },
            {
                "id": 2074194,
                "content": [
                    {
                        "username": "delongyang",
                        "content": "How to build a bitmap to solve this problem? Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Using a bitmap (also known as bitset) is a great way to solve this problem efficiently, especially if the input range is known and not excessively large. A bitmap uses a bit array where each boolean value is stored in a single bit. Here\\'s a general outline of how you could apply this to the problem of determining if an array contains any duplicates.\\n\\n1. Initialize a bitmap with enough bits to cover the entire range of possible input values. For example, if you know your inputs are always between 0 and 10^9, you might create a bitmap with 10^9 bits (though in practice this would be impractically large).\\n\\n2. Iterate over the array. For each number, check if its corresponding bit in the bitmap is set. If it is, then that number has appeared before and you can return `True`.\\n\\n3. If the bit was not set, then this is the first time we\\'ve seen this number. Set the corresponding bit in the bitmap.\\n\\n4. If you\\'ve gone through the entire array without finding any duplicates, return `False`.\\n\\nHere\\'s some Python-like pseudocode illustrating this approach:\\n\\n```python\\ndef contains_duplicate(nums):\\n    bitmap = BitArray(10**9)  # A hypothetical BitArray class\\n\\n    for num in nums:\\n        if bitmap[num]:\\n            return True\\n        else:\\n            bitmap[num] = True\\n\\n    return False\\n```\\n\\nPlease note that this pseudocode uses a hypothetical `BitArray` class for the sake of clarity. Python doesn\\'t have a built-in bit array type, but you could use a library like bitarray or use an integer as a bit array if the range of inputs is small.\\n\\nRemember that a bitmap would be impractical for this problem if the range of inputs is very large (like 10^9), as it would require a prohibitive amount of memory. This technique works best when the range of inputs is relatively small compared to the number of inputs.\\n\\nAlso, keep in mind that this solution assumes that all the input numbers are non-negative. If negative numbers are possible, you\\'d need to offset the numbers to make them non-negative before using them to index into the bitmap. For instance, if inputs are in the range -10^9 to 10^9, you can add 10^9 to each input to ensure they are all non-negative."
                    },
                    {
                        "username": "namankhandelwal59",
                        "content": "first using set \\nIn this approch fist insert all element of array insert in set than check size of set using set function if the size of set is same as array size than there is no duplicate value contain other wise contain duplicate value \\n\\nand second is using map\\n"
                    },
                    {
                        "username": "amiraslamov",
                        "content": "![image](https://assets.leetcode.com/users/images/bfd295d3-c504-4dbe-b9df-9a808035ef40_1639465424.1569192.png)\\n"
                    },
                    {
                        "username": "YASHPALSINH01",
                        "content": "******can anyone please provide the c code for this which is easier to understand as I\\'m just a begineer."
                    },
                    {
                        "username": "Khalid_01",
                        "content": "any way to solve this in constant space and linear time?\\n"
                    },
                    {
                        "username": "misumi7",
                        "content": "It becomes really easy when you use a hash set"
                    },
                    {
                        "username": "ategale",
                        "content": "How to get O(n) time and O(1) space?"
                    },
                    {
                        "username": "sergei99",
                        "content": "No way I guess."
                    },
                    {
                        "username": "slavsquatter",
                        "content": "Me solving the problem:   :D\\nMe exceeding the time limit:  >:( "
                    },
                    {
                        "username": "0bro",
                        "content": "Person who\\'s studied algorithms before doing leetcode will laugh at the final answer lol "
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "I'm a bit new to the files concept in Python, So can anyone tell me how this solution actually works, beacuse all I can understand is that we're opening a file and then printing... \n`\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        #return len(set(nums)) != len(nums)\n        f = open('user.out', 'w')\n        print('''true\nfalse\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue\nfalse\n        ''',file=f)\n        exit(0) `\n I did solve using the hashmap and an optimization version of hashmap.\n "
                    },
                    {
                        "username": "sergei99",
                        "content": "This solution cheats. It writes the expected test output straight to the output file used by the test engine. Such kind of solution is useless in solving real life problems."
                    }
                ]
            },
            {
                "id": 2072329,
                "content": [
                    {
                        "username": "delongyang",
                        "content": "How to build a bitmap to solve this problem? Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Using a bitmap (also known as bitset) is a great way to solve this problem efficiently, especially if the input range is known and not excessively large. A bitmap uses a bit array where each boolean value is stored in a single bit. Here\\'s a general outline of how you could apply this to the problem of determining if an array contains any duplicates.\\n\\n1. Initialize a bitmap with enough bits to cover the entire range of possible input values. For example, if you know your inputs are always between 0 and 10^9, you might create a bitmap with 10^9 bits (though in practice this would be impractically large).\\n\\n2. Iterate over the array. For each number, check if its corresponding bit in the bitmap is set. If it is, then that number has appeared before and you can return `True`.\\n\\n3. If the bit was not set, then this is the first time we\\'ve seen this number. Set the corresponding bit in the bitmap.\\n\\n4. If you\\'ve gone through the entire array without finding any duplicates, return `False`.\\n\\nHere\\'s some Python-like pseudocode illustrating this approach:\\n\\n```python\\ndef contains_duplicate(nums):\\n    bitmap = BitArray(10**9)  # A hypothetical BitArray class\\n\\n    for num in nums:\\n        if bitmap[num]:\\n            return True\\n        else:\\n            bitmap[num] = True\\n\\n    return False\\n```\\n\\nPlease note that this pseudocode uses a hypothetical `BitArray` class for the sake of clarity. Python doesn\\'t have a built-in bit array type, but you could use a library like bitarray or use an integer as a bit array if the range of inputs is small.\\n\\nRemember that a bitmap would be impractical for this problem if the range of inputs is very large (like 10^9), as it would require a prohibitive amount of memory. This technique works best when the range of inputs is relatively small compared to the number of inputs.\\n\\nAlso, keep in mind that this solution assumes that all the input numbers are non-negative. If negative numbers are possible, you\\'d need to offset the numbers to make them non-negative before using them to index into the bitmap. For instance, if inputs are in the range -10^9 to 10^9, you can add 10^9 to each input to ensure they are all non-negative."
                    },
                    {
                        "username": "namankhandelwal59",
                        "content": "first using set \\nIn this approch fist insert all element of array insert in set than check size of set using set function if the size of set is same as array size than there is no duplicate value contain other wise contain duplicate value \\n\\nand second is using map\\n"
                    },
                    {
                        "username": "amiraslamov",
                        "content": "![image](https://assets.leetcode.com/users/images/bfd295d3-c504-4dbe-b9df-9a808035ef40_1639465424.1569192.png)\\n"
                    },
                    {
                        "username": "YASHPALSINH01",
                        "content": "******can anyone please provide the c code for this which is easier to understand as I\\'m just a begineer."
                    },
                    {
                        "username": "Khalid_01",
                        "content": "any way to solve this in constant space and linear time?\\n"
                    },
                    {
                        "username": "misumi7",
                        "content": "It becomes really easy when you use a hash set"
                    },
                    {
                        "username": "ategale",
                        "content": "How to get O(n) time and O(1) space?"
                    },
                    {
                        "username": "sergei99",
                        "content": "No way I guess."
                    },
                    {
                        "username": "slavsquatter",
                        "content": "Me solving the problem:   :D\\nMe exceeding the time limit:  >:( "
                    },
                    {
                        "username": "0bro",
                        "content": "Person who\\'s studied algorithms before doing leetcode will laugh at the final answer lol "
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "I'm a bit new to the files concept in Python, So can anyone tell me how this solution actually works, beacuse all I can understand is that we're opening a file and then printing... \n`\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        #return len(set(nums)) != len(nums)\n        f = open('user.out', 'w')\n        print('''true\nfalse\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue\nfalse\n        ''',file=f)\n        exit(0) `\n I did solve using the hashmap and an optimization version of hashmap.\n "
                    },
                    {
                        "username": "sergei99",
                        "content": "This solution cheats. It writes the expected test output straight to the output file used by the test engine. Such kind of solution is useless in solving real life problems."
                    }
                ]
            },
            {
                "id": 2069878,
                "content": [
                    {
                        "username": "delongyang",
                        "content": "How to build a bitmap to solve this problem? Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Using a bitmap (also known as bitset) is a great way to solve this problem efficiently, especially if the input range is known and not excessively large. A bitmap uses a bit array where each boolean value is stored in a single bit. Here\\'s a general outline of how you could apply this to the problem of determining if an array contains any duplicates.\\n\\n1. Initialize a bitmap with enough bits to cover the entire range of possible input values. For example, if you know your inputs are always between 0 and 10^9, you might create a bitmap with 10^9 bits (though in practice this would be impractically large).\\n\\n2. Iterate over the array. For each number, check if its corresponding bit in the bitmap is set. If it is, then that number has appeared before and you can return `True`.\\n\\n3. If the bit was not set, then this is the first time we\\'ve seen this number. Set the corresponding bit in the bitmap.\\n\\n4. If you\\'ve gone through the entire array without finding any duplicates, return `False`.\\n\\nHere\\'s some Python-like pseudocode illustrating this approach:\\n\\n```python\\ndef contains_duplicate(nums):\\n    bitmap = BitArray(10**9)  # A hypothetical BitArray class\\n\\n    for num in nums:\\n        if bitmap[num]:\\n            return True\\n        else:\\n            bitmap[num] = True\\n\\n    return False\\n```\\n\\nPlease note that this pseudocode uses a hypothetical `BitArray` class for the sake of clarity. Python doesn\\'t have a built-in bit array type, but you could use a library like bitarray or use an integer as a bit array if the range of inputs is small.\\n\\nRemember that a bitmap would be impractical for this problem if the range of inputs is very large (like 10^9), as it would require a prohibitive amount of memory. This technique works best when the range of inputs is relatively small compared to the number of inputs.\\n\\nAlso, keep in mind that this solution assumes that all the input numbers are non-negative. If negative numbers are possible, you\\'d need to offset the numbers to make them non-negative before using them to index into the bitmap. For instance, if inputs are in the range -10^9 to 10^9, you can add 10^9 to each input to ensure they are all non-negative."
                    },
                    {
                        "username": "namankhandelwal59",
                        "content": "first using set \\nIn this approch fist insert all element of array insert in set than check size of set using set function if the size of set is same as array size than there is no duplicate value contain other wise contain duplicate value \\n\\nand second is using map\\n"
                    },
                    {
                        "username": "amiraslamov",
                        "content": "![image](https://assets.leetcode.com/users/images/bfd295d3-c504-4dbe-b9df-9a808035ef40_1639465424.1569192.png)\\n"
                    },
                    {
                        "username": "YASHPALSINH01",
                        "content": "******can anyone please provide the c code for this which is easier to understand as I\\'m just a begineer."
                    },
                    {
                        "username": "Khalid_01",
                        "content": "any way to solve this in constant space and linear time?\\n"
                    },
                    {
                        "username": "misumi7",
                        "content": "It becomes really easy when you use a hash set"
                    },
                    {
                        "username": "ategale",
                        "content": "How to get O(n) time and O(1) space?"
                    },
                    {
                        "username": "sergei99",
                        "content": "No way I guess."
                    },
                    {
                        "username": "slavsquatter",
                        "content": "Me solving the problem:   :D\\nMe exceeding the time limit:  >:( "
                    },
                    {
                        "username": "0bro",
                        "content": "Person who\\'s studied algorithms before doing leetcode will laugh at the final answer lol "
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "I'm a bit new to the files concept in Python, So can anyone tell me how this solution actually works, beacuse all I can understand is that we're opening a file and then printing... \n`\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        #return len(set(nums)) != len(nums)\n        f = open('user.out', 'w')\n        print('''true\nfalse\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue\nfalse\n        ''',file=f)\n        exit(0) `\n I did solve using the hashmap and an optimization version of hashmap.\n "
                    },
                    {
                        "username": "sergei99",
                        "content": "This solution cheats. It writes the expected test output straight to the output file used by the test engine. Such kind of solution is useless in solving real life problems."
                    }
                ]
            },
            {
                "id": 2067451,
                "content": [
                    {
                        "username": "delongyang",
                        "content": "How to build a bitmap to solve this problem? Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Using a bitmap (also known as bitset) is a great way to solve this problem efficiently, especially if the input range is known and not excessively large. A bitmap uses a bit array where each boolean value is stored in a single bit. Here\\'s a general outline of how you could apply this to the problem of determining if an array contains any duplicates.\\n\\n1. Initialize a bitmap with enough bits to cover the entire range of possible input values. For example, if you know your inputs are always between 0 and 10^9, you might create a bitmap with 10^9 bits (though in practice this would be impractically large).\\n\\n2. Iterate over the array. For each number, check if its corresponding bit in the bitmap is set. If it is, then that number has appeared before and you can return `True`.\\n\\n3. If the bit was not set, then this is the first time we\\'ve seen this number. Set the corresponding bit in the bitmap.\\n\\n4. If you\\'ve gone through the entire array without finding any duplicates, return `False`.\\n\\nHere\\'s some Python-like pseudocode illustrating this approach:\\n\\n```python\\ndef contains_duplicate(nums):\\n    bitmap = BitArray(10**9)  # A hypothetical BitArray class\\n\\n    for num in nums:\\n        if bitmap[num]:\\n            return True\\n        else:\\n            bitmap[num] = True\\n\\n    return False\\n```\\n\\nPlease note that this pseudocode uses a hypothetical `BitArray` class for the sake of clarity. Python doesn\\'t have a built-in bit array type, but you could use a library like bitarray or use an integer as a bit array if the range of inputs is small.\\n\\nRemember that a bitmap would be impractical for this problem if the range of inputs is very large (like 10^9), as it would require a prohibitive amount of memory. This technique works best when the range of inputs is relatively small compared to the number of inputs.\\n\\nAlso, keep in mind that this solution assumes that all the input numbers are non-negative. If negative numbers are possible, you\\'d need to offset the numbers to make them non-negative before using them to index into the bitmap. For instance, if inputs are in the range -10^9 to 10^9, you can add 10^9 to each input to ensure they are all non-negative."
                    },
                    {
                        "username": "namankhandelwal59",
                        "content": "first using set \\nIn this approch fist insert all element of array insert in set than check size of set using set function if the size of set is same as array size than there is no duplicate value contain other wise contain duplicate value \\n\\nand second is using map\\n"
                    },
                    {
                        "username": "amiraslamov",
                        "content": "![image](https://assets.leetcode.com/users/images/bfd295d3-c504-4dbe-b9df-9a808035ef40_1639465424.1569192.png)\\n"
                    },
                    {
                        "username": "YASHPALSINH01",
                        "content": "******can anyone please provide the c code for this which is easier to understand as I\\'m just a begineer."
                    },
                    {
                        "username": "Khalid_01",
                        "content": "any way to solve this in constant space and linear time?\\n"
                    },
                    {
                        "username": "misumi7",
                        "content": "It becomes really easy when you use a hash set"
                    },
                    {
                        "username": "ategale",
                        "content": "How to get O(n) time and O(1) space?"
                    },
                    {
                        "username": "sergei99",
                        "content": "No way I guess."
                    },
                    {
                        "username": "slavsquatter",
                        "content": "Me solving the problem:   :D\\nMe exceeding the time limit:  >:( "
                    },
                    {
                        "username": "0bro",
                        "content": "Person who\\'s studied algorithms before doing leetcode will laugh at the final answer lol "
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "I'm a bit new to the files concept in Python, So can anyone tell me how this solution actually works, beacuse all I can understand is that we're opening a file and then printing... \n`\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        #return len(set(nums)) != len(nums)\n        f = open('user.out', 'w')\n        print('''true\nfalse\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue\nfalse\n        ''',file=f)\n        exit(0) `\n I did solve using the hashmap and an optimization version of hashmap.\n "
                    },
                    {
                        "username": "sergei99",
                        "content": "This solution cheats. It writes the expected test output straight to the output file used by the test engine. Such kind of solution is useless in solving real life problems."
                    }
                ]
            },
            {
                "id": 2065535,
                "content": [
                    {
                        "username": "delongyang",
                        "content": "How to build a bitmap to solve this problem? Thanks!"
                    },
                    {
                        "username": "bparanj",
                        "content": "Using a bitmap (also known as bitset) is a great way to solve this problem efficiently, especially if the input range is known and not excessively large. A bitmap uses a bit array where each boolean value is stored in a single bit. Here\\'s a general outline of how you could apply this to the problem of determining if an array contains any duplicates.\\n\\n1. Initialize a bitmap with enough bits to cover the entire range of possible input values. For example, if you know your inputs are always between 0 and 10^9, you might create a bitmap with 10^9 bits (though in practice this would be impractically large).\\n\\n2. Iterate over the array. For each number, check if its corresponding bit in the bitmap is set. If it is, then that number has appeared before and you can return `True`.\\n\\n3. If the bit was not set, then this is the first time we\\'ve seen this number. Set the corresponding bit in the bitmap.\\n\\n4. If you\\'ve gone through the entire array without finding any duplicates, return `False`.\\n\\nHere\\'s some Python-like pseudocode illustrating this approach:\\n\\n```python\\ndef contains_duplicate(nums):\\n    bitmap = BitArray(10**9)  # A hypothetical BitArray class\\n\\n    for num in nums:\\n        if bitmap[num]:\\n            return True\\n        else:\\n            bitmap[num] = True\\n\\n    return False\\n```\\n\\nPlease note that this pseudocode uses a hypothetical `BitArray` class for the sake of clarity. Python doesn\\'t have a built-in bit array type, but you could use a library like bitarray or use an integer as a bit array if the range of inputs is small.\\n\\nRemember that a bitmap would be impractical for this problem if the range of inputs is very large (like 10^9), as it would require a prohibitive amount of memory. This technique works best when the range of inputs is relatively small compared to the number of inputs.\\n\\nAlso, keep in mind that this solution assumes that all the input numbers are non-negative. If negative numbers are possible, you\\'d need to offset the numbers to make them non-negative before using them to index into the bitmap. For instance, if inputs are in the range -10^9 to 10^9, you can add 10^9 to each input to ensure they are all non-negative."
                    },
                    {
                        "username": "namankhandelwal59",
                        "content": "first using set \\nIn this approch fist insert all element of array insert in set than check size of set using set function if the size of set is same as array size than there is no duplicate value contain other wise contain duplicate value \\n\\nand second is using map\\n"
                    },
                    {
                        "username": "amiraslamov",
                        "content": "![image](https://assets.leetcode.com/users/images/bfd295d3-c504-4dbe-b9df-9a808035ef40_1639465424.1569192.png)\\n"
                    },
                    {
                        "username": "YASHPALSINH01",
                        "content": "******can anyone please provide the c code for this which is easier to understand as I\\'m just a begineer."
                    },
                    {
                        "username": "Khalid_01",
                        "content": "any way to solve this in constant space and linear time?\\n"
                    },
                    {
                        "username": "misumi7",
                        "content": "It becomes really easy when you use a hash set"
                    },
                    {
                        "username": "ategale",
                        "content": "How to get O(n) time and O(1) space?"
                    },
                    {
                        "username": "sergei99",
                        "content": "No way I guess."
                    },
                    {
                        "username": "slavsquatter",
                        "content": "Me solving the problem:   :D\\nMe exceeding the time limit:  >:( "
                    },
                    {
                        "username": "0bro",
                        "content": "Person who\\'s studied algorithms before doing leetcode will laugh at the final answer lol "
                    },
                    {
                        "username": "ramakrishna1607",
                        "content": "I'm a bit new to the files concept in Python, So can anyone tell me how this solution actually works, beacuse all I can understand is that we're opening a file and then printing... \n`\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        #return len(set(nums)) != len(nums)\n        f = open('user.out', 'w')\n        print('''true\nfalse\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\nfalse\ntrue\nfalse\nfalse\nfalse\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\nfalse\ntrue\ntrue\nfalse\n        ''',file=f)\n        exit(0) `\n I did solve using the hashmap and an optimization version of hashmap.\n "
                    },
                    {
                        "username": "sergei99",
                        "content": "This solution cheats. It writes the expected test output straight to the output file used by the test engine. Such kind of solution is useless in solving real life problems."
                    }
                ]
            },
            {
                "id": 2056924,
                "content": [
                    {
                        "username": "Musfik41",
                        "content": " [leetcode](https://drive.google.com/file/d/1nu1wnMdu8tyukFiJ2Xt0kf74vhqtqpyt/view?usp=drive_link) i was not expecting to be test cases this huge\\uD83D\\uDE05"
                    },
                    {
                        "username": "Abhishekh2211531",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        num_set = set()\\n        for i in nums:\\n            if i in num_set:\\n                return True\\n            else:\\n                num_set.add(i)\\n        return False\\n  \\n  "
                    },
                    {
                        "username": "mayxz1",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        smap = {}\\n\\n        for i, n in enumerate(nums):\\n            smap[n] = i\\n        \\n        if len(smap) == len(nums):\\n            return False\\n        else:\\n            return True\\n\\nis this wrong or what is the problem with this method?"
                    },
                    {
                        "username": "mayxz1",
                        "content": "[@sergei99](/sergei99) ohh i see thank you so much"
                    },
                    {
                        "username": "sergei99",
                        "content": "Only its low efficiency:\\n1) If there is a duplicate, the entire list doesn\\'t have to be scanned, the algorithm could stop at the first dup.\\n2) Dictionary is unnecessary, set is enough."
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why i can\\'t use `for i in range(len(nums) - 1):`?"
                    },
                    {
                        "username": "ec1a_40310042",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i =0;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1])\\n             return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "/*\\nTip for Detecting Duplicates in Java:\\n\\nIterate through the elements of the array one by one using a for loop.\\nCreate a HashSet to store the elements encountered so far.\\nFor each element, check if it already exists in the HashSet.\\nIf the element is found in the HashSet, return true as soon as a duplicate is detected.\\nIf the element is not found in the HashSet, add it to the HashSet.\\nAfter completing the loop, return false because no duplicates were found in the array.\\n*/\\n\\n`import java.util.HashSet;\\nimport java.util.Set;\\n\\npublic class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num)) {\\n                return true;\\n            }\\n            seen.add(num);\\n        }\\n        return false;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "chirag2239",
                        "content": "What\\'s wrong in this code?\\nIt gives \\n==23==ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address 0x7ffe41b09ae0 at pc 0x564b89dd61a7 bp 0x7ffe41b09ad0 sp 0x7ffe41b09ac0\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    int hash[numsSize];\\n    memset(hash, 0, numsSize*sizeof(int));\\n    for(int i = 0; i < numsSize - 1; i++)\\n    {\\n        if(*(hash+nums[i]) == 1)\\n        {\\n            return true;\\n        }\\n        *(hash+nums[i]) += 1;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "sakshirawat49916",
                        "content": "if their is a case that only exact two elements are same then only return true what should we do please help"
                    },
                    {
                        "username": "deleted_user",
                        "content": "In ruby, I have used this below code\\n\\n `def contains_duplicate(nums)\\n  set = []\\n  for i in nums\\n    if set.include?(i)\\n      return true\\n    else\\n      set << i\\n    end\\n  end\\n  return false\\nend`\\n\\nStill getting TLE."
                    },
                    {
                        "username": "user4391L",
                        "content": "how can we reduce the time limit for array traversal"
                    }
                ]
            },
            {
                "id": 2055491,
                "content": [
                    {
                        "username": "Musfik41",
                        "content": " [leetcode](https://drive.google.com/file/d/1nu1wnMdu8tyukFiJ2Xt0kf74vhqtqpyt/view?usp=drive_link) i was not expecting to be test cases this huge\\uD83D\\uDE05"
                    },
                    {
                        "username": "Abhishekh2211531",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        num_set = set()\\n        for i in nums:\\n            if i in num_set:\\n                return True\\n            else:\\n                num_set.add(i)\\n        return False\\n  \\n  "
                    },
                    {
                        "username": "mayxz1",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        smap = {}\\n\\n        for i, n in enumerate(nums):\\n            smap[n] = i\\n        \\n        if len(smap) == len(nums):\\n            return False\\n        else:\\n            return True\\n\\nis this wrong or what is the problem with this method?"
                    },
                    {
                        "username": "mayxz1",
                        "content": "[@sergei99](/sergei99) ohh i see thank you so much"
                    },
                    {
                        "username": "sergei99",
                        "content": "Only its low efficiency:\\n1) If there is a duplicate, the entire list doesn\\'t have to be scanned, the algorithm could stop at the first dup.\\n2) Dictionary is unnecessary, set is enough."
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why i can\\'t use `for i in range(len(nums) - 1):`?"
                    },
                    {
                        "username": "ec1a_40310042",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i =0;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1])\\n             return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "/*\\nTip for Detecting Duplicates in Java:\\n\\nIterate through the elements of the array one by one using a for loop.\\nCreate a HashSet to store the elements encountered so far.\\nFor each element, check if it already exists in the HashSet.\\nIf the element is found in the HashSet, return true as soon as a duplicate is detected.\\nIf the element is not found in the HashSet, add it to the HashSet.\\nAfter completing the loop, return false because no duplicates were found in the array.\\n*/\\n\\n`import java.util.HashSet;\\nimport java.util.Set;\\n\\npublic class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num)) {\\n                return true;\\n            }\\n            seen.add(num);\\n        }\\n        return false;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "chirag2239",
                        "content": "What\\'s wrong in this code?\\nIt gives \\n==23==ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address 0x7ffe41b09ae0 at pc 0x564b89dd61a7 bp 0x7ffe41b09ad0 sp 0x7ffe41b09ac0\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    int hash[numsSize];\\n    memset(hash, 0, numsSize*sizeof(int));\\n    for(int i = 0; i < numsSize - 1; i++)\\n    {\\n        if(*(hash+nums[i]) == 1)\\n        {\\n            return true;\\n        }\\n        *(hash+nums[i]) += 1;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "sakshirawat49916",
                        "content": "if their is a case that only exact two elements are same then only return true what should we do please help"
                    },
                    {
                        "username": "deleted_user",
                        "content": "In ruby, I have used this below code\\n\\n `def contains_duplicate(nums)\\n  set = []\\n  for i in nums\\n    if set.include?(i)\\n      return true\\n    else\\n      set << i\\n    end\\n  end\\n  return false\\nend`\\n\\nStill getting TLE."
                    },
                    {
                        "username": "user4391L",
                        "content": "how can we reduce the time limit for array traversal"
                    }
                ]
            },
            {
                "id": 2050884,
                "content": [
                    {
                        "username": "Musfik41",
                        "content": " [leetcode](https://drive.google.com/file/d/1nu1wnMdu8tyukFiJ2Xt0kf74vhqtqpyt/view?usp=drive_link) i was not expecting to be test cases this huge\\uD83D\\uDE05"
                    },
                    {
                        "username": "Abhishekh2211531",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        num_set = set()\\n        for i in nums:\\n            if i in num_set:\\n                return True\\n            else:\\n                num_set.add(i)\\n        return False\\n  \\n  "
                    },
                    {
                        "username": "mayxz1",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        smap = {}\\n\\n        for i, n in enumerate(nums):\\n            smap[n] = i\\n        \\n        if len(smap) == len(nums):\\n            return False\\n        else:\\n            return True\\n\\nis this wrong or what is the problem with this method?"
                    },
                    {
                        "username": "mayxz1",
                        "content": "[@sergei99](/sergei99) ohh i see thank you so much"
                    },
                    {
                        "username": "sergei99",
                        "content": "Only its low efficiency:\\n1) If there is a duplicate, the entire list doesn\\'t have to be scanned, the algorithm could stop at the first dup.\\n2) Dictionary is unnecessary, set is enough."
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why i can\\'t use `for i in range(len(nums) - 1):`?"
                    },
                    {
                        "username": "ec1a_40310042",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i =0;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1])\\n             return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "/*\\nTip for Detecting Duplicates in Java:\\n\\nIterate through the elements of the array one by one using a for loop.\\nCreate a HashSet to store the elements encountered so far.\\nFor each element, check if it already exists in the HashSet.\\nIf the element is found in the HashSet, return true as soon as a duplicate is detected.\\nIf the element is not found in the HashSet, add it to the HashSet.\\nAfter completing the loop, return false because no duplicates were found in the array.\\n*/\\n\\n`import java.util.HashSet;\\nimport java.util.Set;\\n\\npublic class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num)) {\\n                return true;\\n            }\\n            seen.add(num);\\n        }\\n        return false;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "chirag2239",
                        "content": "What\\'s wrong in this code?\\nIt gives \\n==23==ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address 0x7ffe41b09ae0 at pc 0x564b89dd61a7 bp 0x7ffe41b09ad0 sp 0x7ffe41b09ac0\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    int hash[numsSize];\\n    memset(hash, 0, numsSize*sizeof(int));\\n    for(int i = 0; i < numsSize - 1; i++)\\n    {\\n        if(*(hash+nums[i]) == 1)\\n        {\\n            return true;\\n        }\\n        *(hash+nums[i]) += 1;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "sakshirawat49916",
                        "content": "if their is a case that only exact two elements are same then only return true what should we do please help"
                    },
                    {
                        "username": "deleted_user",
                        "content": "In ruby, I have used this below code\\n\\n `def contains_duplicate(nums)\\n  set = []\\n  for i in nums\\n    if set.include?(i)\\n      return true\\n    else\\n      set << i\\n    end\\n  end\\n  return false\\nend`\\n\\nStill getting TLE."
                    },
                    {
                        "username": "user4391L",
                        "content": "how can we reduce the time limit for array traversal"
                    }
                ]
            },
            {
                "id": 2046557,
                "content": [
                    {
                        "username": "Musfik41",
                        "content": " [leetcode](https://drive.google.com/file/d/1nu1wnMdu8tyukFiJ2Xt0kf74vhqtqpyt/view?usp=drive_link) i was not expecting to be test cases this huge\\uD83D\\uDE05"
                    },
                    {
                        "username": "Abhishekh2211531",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        num_set = set()\\n        for i in nums:\\n            if i in num_set:\\n                return True\\n            else:\\n                num_set.add(i)\\n        return False\\n  \\n  "
                    },
                    {
                        "username": "mayxz1",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        smap = {}\\n\\n        for i, n in enumerate(nums):\\n            smap[n] = i\\n        \\n        if len(smap) == len(nums):\\n            return False\\n        else:\\n            return True\\n\\nis this wrong or what is the problem with this method?"
                    },
                    {
                        "username": "mayxz1",
                        "content": "[@sergei99](/sergei99) ohh i see thank you so much"
                    },
                    {
                        "username": "sergei99",
                        "content": "Only its low efficiency:\\n1) If there is a duplicate, the entire list doesn\\'t have to be scanned, the algorithm could stop at the first dup.\\n2) Dictionary is unnecessary, set is enough."
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why i can\\'t use `for i in range(len(nums) - 1):`?"
                    },
                    {
                        "username": "ec1a_40310042",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i =0;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1])\\n             return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "/*\\nTip for Detecting Duplicates in Java:\\n\\nIterate through the elements of the array one by one using a for loop.\\nCreate a HashSet to store the elements encountered so far.\\nFor each element, check if it already exists in the HashSet.\\nIf the element is found in the HashSet, return true as soon as a duplicate is detected.\\nIf the element is not found in the HashSet, add it to the HashSet.\\nAfter completing the loop, return false because no duplicates were found in the array.\\n*/\\n\\n`import java.util.HashSet;\\nimport java.util.Set;\\n\\npublic class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num)) {\\n                return true;\\n            }\\n            seen.add(num);\\n        }\\n        return false;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "chirag2239",
                        "content": "What\\'s wrong in this code?\\nIt gives \\n==23==ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address 0x7ffe41b09ae0 at pc 0x564b89dd61a7 bp 0x7ffe41b09ad0 sp 0x7ffe41b09ac0\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    int hash[numsSize];\\n    memset(hash, 0, numsSize*sizeof(int));\\n    for(int i = 0; i < numsSize - 1; i++)\\n    {\\n        if(*(hash+nums[i]) == 1)\\n        {\\n            return true;\\n        }\\n        *(hash+nums[i]) += 1;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "sakshirawat49916",
                        "content": "if their is a case that only exact two elements are same then only return true what should we do please help"
                    },
                    {
                        "username": "deleted_user",
                        "content": "In ruby, I have used this below code\\n\\n `def contains_duplicate(nums)\\n  set = []\\n  for i in nums\\n    if set.include?(i)\\n      return true\\n    else\\n      set << i\\n    end\\n  end\\n  return false\\nend`\\n\\nStill getting TLE."
                    },
                    {
                        "username": "user4391L",
                        "content": "how can we reduce the time limit for array traversal"
                    }
                ]
            },
            {
                "id": 2046256,
                "content": [
                    {
                        "username": "Musfik41",
                        "content": " [leetcode](https://drive.google.com/file/d/1nu1wnMdu8tyukFiJ2Xt0kf74vhqtqpyt/view?usp=drive_link) i was not expecting to be test cases this huge\\uD83D\\uDE05"
                    },
                    {
                        "username": "Abhishekh2211531",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        num_set = set()\\n        for i in nums:\\n            if i in num_set:\\n                return True\\n            else:\\n                num_set.add(i)\\n        return False\\n  \\n  "
                    },
                    {
                        "username": "mayxz1",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        smap = {}\\n\\n        for i, n in enumerate(nums):\\n            smap[n] = i\\n        \\n        if len(smap) == len(nums):\\n            return False\\n        else:\\n            return True\\n\\nis this wrong or what is the problem with this method?"
                    },
                    {
                        "username": "mayxz1",
                        "content": "[@sergei99](/sergei99) ohh i see thank you so much"
                    },
                    {
                        "username": "sergei99",
                        "content": "Only its low efficiency:\\n1) If there is a duplicate, the entire list doesn\\'t have to be scanned, the algorithm could stop at the first dup.\\n2) Dictionary is unnecessary, set is enough."
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why i can\\'t use `for i in range(len(nums) - 1):`?"
                    },
                    {
                        "username": "ec1a_40310042",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i =0;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1])\\n             return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "/*\\nTip for Detecting Duplicates in Java:\\n\\nIterate through the elements of the array one by one using a for loop.\\nCreate a HashSet to store the elements encountered so far.\\nFor each element, check if it already exists in the HashSet.\\nIf the element is found in the HashSet, return true as soon as a duplicate is detected.\\nIf the element is not found in the HashSet, add it to the HashSet.\\nAfter completing the loop, return false because no duplicates were found in the array.\\n*/\\n\\n`import java.util.HashSet;\\nimport java.util.Set;\\n\\npublic class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num)) {\\n                return true;\\n            }\\n            seen.add(num);\\n        }\\n        return false;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "chirag2239",
                        "content": "What\\'s wrong in this code?\\nIt gives \\n==23==ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address 0x7ffe41b09ae0 at pc 0x564b89dd61a7 bp 0x7ffe41b09ad0 sp 0x7ffe41b09ac0\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    int hash[numsSize];\\n    memset(hash, 0, numsSize*sizeof(int));\\n    for(int i = 0; i < numsSize - 1; i++)\\n    {\\n        if(*(hash+nums[i]) == 1)\\n        {\\n            return true;\\n        }\\n        *(hash+nums[i]) += 1;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "sakshirawat49916",
                        "content": "if their is a case that only exact two elements are same then only return true what should we do please help"
                    },
                    {
                        "username": "deleted_user",
                        "content": "In ruby, I have used this below code\\n\\n `def contains_duplicate(nums)\\n  set = []\\n  for i in nums\\n    if set.include?(i)\\n      return true\\n    else\\n      set << i\\n    end\\n  end\\n  return false\\nend`\\n\\nStill getting TLE."
                    },
                    {
                        "username": "user4391L",
                        "content": "how can we reduce the time limit for array traversal"
                    }
                ]
            },
            {
                "id": 2045749,
                "content": [
                    {
                        "username": "Musfik41",
                        "content": " [leetcode](https://drive.google.com/file/d/1nu1wnMdu8tyukFiJ2Xt0kf74vhqtqpyt/view?usp=drive_link) i was not expecting to be test cases this huge\\uD83D\\uDE05"
                    },
                    {
                        "username": "Abhishekh2211531",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        num_set = set()\\n        for i in nums:\\n            if i in num_set:\\n                return True\\n            else:\\n                num_set.add(i)\\n        return False\\n  \\n  "
                    },
                    {
                        "username": "mayxz1",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        smap = {}\\n\\n        for i, n in enumerate(nums):\\n            smap[n] = i\\n        \\n        if len(smap) == len(nums):\\n            return False\\n        else:\\n            return True\\n\\nis this wrong or what is the problem with this method?"
                    },
                    {
                        "username": "mayxz1",
                        "content": "[@sergei99](/sergei99) ohh i see thank you so much"
                    },
                    {
                        "username": "sergei99",
                        "content": "Only its low efficiency:\\n1) If there is a duplicate, the entire list doesn\\'t have to be scanned, the algorithm could stop at the first dup.\\n2) Dictionary is unnecessary, set is enough."
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why i can\\'t use `for i in range(len(nums) - 1):`?"
                    },
                    {
                        "username": "ec1a_40310042",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i =0;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1])\\n             return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "/*\\nTip for Detecting Duplicates in Java:\\n\\nIterate through the elements of the array one by one using a for loop.\\nCreate a HashSet to store the elements encountered so far.\\nFor each element, check if it already exists in the HashSet.\\nIf the element is found in the HashSet, return true as soon as a duplicate is detected.\\nIf the element is not found in the HashSet, add it to the HashSet.\\nAfter completing the loop, return false because no duplicates were found in the array.\\n*/\\n\\n`import java.util.HashSet;\\nimport java.util.Set;\\n\\npublic class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num)) {\\n                return true;\\n            }\\n            seen.add(num);\\n        }\\n        return false;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "chirag2239",
                        "content": "What\\'s wrong in this code?\\nIt gives \\n==23==ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address 0x7ffe41b09ae0 at pc 0x564b89dd61a7 bp 0x7ffe41b09ad0 sp 0x7ffe41b09ac0\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    int hash[numsSize];\\n    memset(hash, 0, numsSize*sizeof(int));\\n    for(int i = 0; i < numsSize - 1; i++)\\n    {\\n        if(*(hash+nums[i]) == 1)\\n        {\\n            return true;\\n        }\\n        *(hash+nums[i]) += 1;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "sakshirawat49916",
                        "content": "if their is a case that only exact two elements are same then only return true what should we do please help"
                    },
                    {
                        "username": "deleted_user",
                        "content": "In ruby, I have used this below code\\n\\n `def contains_duplicate(nums)\\n  set = []\\n  for i in nums\\n    if set.include?(i)\\n      return true\\n    else\\n      set << i\\n    end\\n  end\\n  return false\\nend`\\n\\nStill getting TLE."
                    },
                    {
                        "username": "user4391L",
                        "content": "how can we reduce the time limit for array traversal"
                    }
                ]
            },
            {
                "id": 2042772,
                "content": [
                    {
                        "username": "Musfik41",
                        "content": " [leetcode](https://drive.google.com/file/d/1nu1wnMdu8tyukFiJ2Xt0kf74vhqtqpyt/view?usp=drive_link) i was not expecting to be test cases this huge\\uD83D\\uDE05"
                    },
                    {
                        "username": "Abhishekh2211531",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        num_set = set()\\n        for i in nums:\\n            if i in num_set:\\n                return True\\n            else:\\n                num_set.add(i)\\n        return False\\n  \\n  "
                    },
                    {
                        "username": "mayxz1",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        smap = {}\\n\\n        for i, n in enumerate(nums):\\n            smap[n] = i\\n        \\n        if len(smap) == len(nums):\\n            return False\\n        else:\\n            return True\\n\\nis this wrong or what is the problem with this method?"
                    },
                    {
                        "username": "mayxz1",
                        "content": "[@sergei99](/sergei99) ohh i see thank you so much"
                    },
                    {
                        "username": "sergei99",
                        "content": "Only its low efficiency:\\n1) If there is a duplicate, the entire list doesn\\'t have to be scanned, the algorithm could stop at the first dup.\\n2) Dictionary is unnecessary, set is enough."
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why i can\\'t use `for i in range(len(nums) - 1):`?"
                    },
                    {
                        "username": "ec1a_40310042",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i =0;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1])\\n             return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "/*\\nTip for Detecting Duplicates in Java:\\n\\nIterate through the elements of the array one by one using a for loop.\\nCreate a HashSet to store the elements encountered so far.\\nFor each element, check if it already exists in the HashSet.\\nIf the element is found in the HashSet, return true as soon as a duplicate is detected.\\nIf the element is not found in the HashSet, add it to the HashSet.\\nAfter completing the loop, return false because no duplicates were found in the array.\\n*/\\n\\n`import java.util.HashSet;\\nimport java.util.Set;\\n\\npublic class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num)) {\\n                return true;\\n            }\\n            seen.add(num);\\n        }\\n        return false;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "chirag2239",
                        "content": "What\\'s wrong in this code?\\nIt gives \\n==23==ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address 0x7ffe41b09ae0 at pc 0x564b89dd61a7 bp 0x7ffe41b09ad0 sp 0x7ffe41b09ac0\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    int hash[numsSize];\\n    memset(hash, 0, numsSize*sizeof(int));\\n    for(int i = 0; i < numsSize - 1; i++)\\n    {\\n        if(*(hash+nums[i]) == 1)\\n        {\\n            return true;\\n        }\\n        *(hash+nums[i]) += 1;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "sakshirawat49916",
                        "content": "if their is a case that only exact two elements are same then only return true what should we do please help"
                    },
                    {
                        "username": "deleted_user",
                        "content": "In ruby, I have used this below code\\n\\n `def contains_duplicate(nums)\\n  set = []\\n  for i in nums\\n    if set.include?(i)\\n      return true\\n    else\\n      set << i\\n    end\\n  end\\n  return false\\nend`\\n\\nStill getting TLE."
                    },
                    {
                        "username": "user4391L",
                        "content": "how can we reduce the time limit for array traversal"
                    }
                ]
            },
            {
                "id": 2042549,
                "content": [
                    {
                        "username": "Musfik41",
                        "content": " [leetcode](https://drive.google.com/file/d/1nu1wnMdu8tyukFiJ2Xt0kf74vhqtqpyt/view?usp=drive_link) i was not expecting to be test cases this huge\\uD83D\\uDE05"
                    },
                    {
                        "username": "Abhishekh2211531",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        num_set = set()\\n        for i in nums:\\n            if i in num_set:\\n                return True\\n            else:\\n                num_set.add(i)\\n        return False\\n  \\n  "
                    },
                    {
                        "username": "mayxz1",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        smap = {}\\n\\n        for i, n in enumerate(nums):\\n            smap[n] = i\\n        \\n        if len(smap) == len(nums):\\n            return False\\n        else:\\n            return True\\n\\nis this wrong or what is the problem with this method?"
                    },
                    {
                        "username": "mayxz1",
                        "content": "[@sergei99](/sergei99) ohh i see thank you so much"
                    },
                    {
                        "username": "sergei99",
                        "content": "Only its low efficiency:\\n1) If there is a duplicate, the entire list doesn\\'t have to be scanned, the algorithm could stop at the first dup.\\n2) Dictionary is unnecessary, set is enough."
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why i can\\'t use `for i in range(len(nums) - 1):`?"
                    },
                    {
                        "username": "ec1a_40310042",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i =0;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1])\\n             return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "/*\\nTip for Detecting Duplicates in Java:\\n\\nIterate through the elements of the array one by one using a for loop.\\nCreate a HashSet to store the elements encountered so far.\\nFor each element, check if it already exists in the HashSet.\\nIf the element is found in the HashSet, return true as soon as a duplicate is detected.\\nIf the element is not found in the HashSet, add it to the HashSet.\\nAfter completing the loop, return false because no duplicates were found in the array.\\n*/\\n\\n`import java.util.HashSet;\\nimport java.util.Set;\\n\\npublic class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num)) {\\n                return true;\\n            }\\n            seen.add(num);\\n        }\\n        return false;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "chirag2239",
                        "content": "What\\'s wrong in this code?\\nIt gives \\n==23==ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address 0x7ffe41b09ae0 at pc 0x564b89dd61a7 bp 0x7ffe41b09ad0 sp 0x7ffe41b09ac0\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    int hash[numsSize];\\n    memset(hash, 0, numsSize*sizeof(int));\\n    for(int i = 0; i < numsSize - 1; i++)\\n    {\\n        if(*(hash+nums[i]) == 1)\\n        {\\n            return true;\\n        }\\n        *(hash+nums[i]) += 1;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "sakshirawat49916",
                        "content": "if their is a case that only exact two elements are same then only return true what should we do please help"
                    },
                    {
                        "username": "deleted_user",
                        "content": "In ruby, I have used this below code\\n\\n `def contains_duplicate(nums)\\n  set = []\\n  for i in nums\\n    if set.include?(i)\\n      return true\\n    else\\n      set << i\\n    end\\n  end\\n  return false\\nend`\\n\\nStill getting TLE."
                    },
                    {
                        "username": "user4391L",
                        "content": "how can we reduce the time limit for array traversal"
                    }
                ]
            },
            {
                "id": 2042378,
                "content": [
                    {
                        "username": "Musfik41",
                        "content": " [leetcode](https://drive.google.com/file/d/1nu1wnMdu8tyukFiJ2Xt0kf74vhqtqpyt/view?usp=drive_link) i was not expecting to be test cases this huge\\uD83D\\uDE05"
                    },
                    {
                        "username": "Abhishekh2211531",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        num_set = set()\\n        for i in nums:\\n            if i in num_set:\\n                return True\\n            else:\\n                num_set.add(i)\\n        return False\\n  \\n  "
                    },
                    {
                        "username": "mayxz1",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        smap = {}\\n\\n        for i, n in enumerate(nums):\\n            smap[n] = i\\n        \\n        if len(smap) == len(nums):\\n            return False\\n        else:\\n            return True\\n\\nis this wrong or what is the problem with this method?"
                    },
                    {
                        "username": "mayxz1",
                        "content": "[@sergei99](/sergei99) ohh i see thank you so much"
                    },
                    {
                        "username": "sergei99",
                        "content": "Only its low efficiency:\\n1) If there is a duplicate, the entire list doesn\\'t have to be scanned, the algorithm could stop at the first dup.\\n2) Dictionary is unnecessary, set is enough."
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why i can\\'t use `for i in range(len(nums) - 1):`?"
                    },
                    {
                        "username": "ec1a_40310042",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i =0;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1])\\n             return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "/*\\nTip for Detecting Duplicates in Java:\\n\\nIterate through the elements of the array one by one using a for loop.\\nCreate a HashSet to store the elements encountered so far.\\nFor each element, check if it already exists in the HashSet.\\nIf the element is found in the HashSet, return true as soon as a duplicate is detected.\\nIf the element is not found in the HashSet, add it to the HashSet.\\nAfter completing the loop, return false because no duplicates were found in the array.\\n*/\\n\\n`import java.util.HashSet;\\nimport java.util.Set;\\n\\npublic class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num)) {\\n                return true;\\n            }\\n            seen.add(num);\\n        }\\n        return false;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "chirag2239",
                        "content": "What\\'s wrong in this code?\\nIt gives \\n==23==ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address 0x7ffe41b09ae0 at pc 0x564b89dd61a7 bp 0x7ffe41b09ad0 sp 0x7ffe41b09ac0\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    int hash[numsSize];\\n    memset(hash, 0, numsSize*sizeof(int));\\n    for(int i = 0; i < numsSize - 1; i++)\\n    {\\n        if(*(hash+nums[i]) == 1)\\n        {\\n            return true;\\n        }\\n        *(hash+nums[i]) += 1;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "sakshirawat49916",
                        "content": "if their is a case that only exact two elements are same then only return true what should we do please help"
                    },
                    {
                        "username": "deleted_user",
                        "content": "In ruby, I have used this below code\\n\\n `def contains_duplicate(nums)\\n  set = []\\n  for i in nums\\n    if set.include?(i)\\n      return true\\n    else\\n      set << i\\n    end\\n  end\\n  return false\\nend`\\n\\nStill getting TLE."
                    },
                    {
                        "username": "user4391L",
                        "content": "how can we reduce the time limit for array traversal"
                    }
                ]
            },
            {
                "id": 2041651,
                "content": [
                    {
                        "username": "Musfik41",
                        "content": " [leetcode](https://drive.google.com/file/d/1nu1wnMdu8tyukFiJ2Xt0kf74vhqtqpyt/view?usp=drive_link) i was not expecting to be test cases this huge\\uD83D\\uDE05"
                    },
                    {
                        "username": "Abhishekh2211531",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        num_set = set()\\n        for i in nums:\\n            if i in num_set:\\n                return True\\n            else:\\n                num_set.add(i)\\n        return False\\n  \\n  "
                    },
                    {
                        "username": "mayxz1",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        smap = {}\\n\\n        for i, n in enumerate(nums):\\n            smap[n] = i\\n        \\n        if len(smap) == len(nums):\\n            return False\\n        else:\\n            return True\\n\\nis this wrong or what is the problem with this method?"
                    },
                    {
                        "username": "mayxz1",
                        "content": "[@sergei99](/sergei99) ohh i see thank you so much"
                    },
                    {
                        "username": "sergei99",
                        "content": "Only its low efficiency:\\n1) If there is a duplicate, the entire list doesn\\'t have to be scanned, the algorithm could stop at the first dup.\\n2) Dictionary is unnecessary, set is enough."
                    },
                    {
                        "username": "Pendelbus",
                        "content": "Why i can\\'t use `for i in range(len(nums) - 1):`?"
                    },
                    {
                        "username": "ec1a_40310042",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(int i =0;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1])\\n             return true;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "/*\\nTip for Detecting Duplicates in Java:\\n\\nIterate through the elements of the array one by one using a for loop.\\nCreate a HashSet to store the elements encountered so far.\\nFor each element, check if it already exists in the HashSet.\\nIf the element is found in the HashSet, return true as soon as a duplicate is detected.\\nIf the element is not found in the HashSet, add it to the HashSet.\\nAfter completing the loop, return false because no duplicates were found in the array.\\n*/\\n\\n`import java.util.HashSet;\\nimport java.util.Set;\\n\\npublic class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int num : nums) {\\n            if (seen.contains(num)) {\\n                return true;\\n            }\\n            seen.add(num);\\n        }\\n        return false;\\n    }\\n}`\\n"
                    },
                    {
                        "username": "chirag2239",
                        "content": "What\\'s wrong in this code?\\nIt gives \\n==23==ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address 0x7ffe41b09ae0 at pc 0x564b89dd61a7 bp 0x7ffe41b09ad0 sp 0x7ffe41b09ac0\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    int hash[numsSize];\\n    memset(hash, 0, numsSize*sizeof(int));\\n    for(int i = 0; i < numsSize - 1; i++)\\n    {\\n        if(*(hash+nums[i]) == 1)\\n        {\\n            return true;\\n        }\\n        *(hash+nums[i]) += 1;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "sakshirawat49916",
                        "content": "if their is a case that only exact two elements are same then only return true what should we do please help"
                    },
                    {
                        "username": "deleted_user",
                        "content": "In ruby, I have used this below code\\n\\n `def contains_duplicate(nums)\\n  set = []\\n  for i in nums\\n    if set.include?(i)\\n      return true\\n    else\\n      set << i\\n    end\\n  end\\n  return false\\nend`\\n\\nStill getting TLE."
                    },
                    {
                        "username": "user4391L",
                        "content": "how can we reduce the time limit for array traversal"
                    }
                ]
            },
            {
                "id": 2035560,
                "content": [
                    {
                        "username": "UNSPOKEN",
                        "content": "I solved the problem using while loop it is faster than using 2 for loops but still its much slower, any other approach that anyone can suggest which doesn\\'t use in-built methods."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n\\n        for(int i = 0; i < nums. length - 1; i++) {\\n\\n            if(nums[i] == nums[i + 1]) {\\n\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "sergei99",
                        "content": "Builtin methods? Like what?"
                    },
                    {
                        "username": "Goutham18",
                        "content": "try:\\n    d[i]\\nexcept KeyError:\\n    d[i] = 1\\nelse:\\n    d[i] += 1\\n\\nI think using try, it\\'s trying to access the element.. if it not exists, then sets a new key.. if exists (else), then we update and break it there itself and return True or set a flag and break.. I think this runs in O(n).. rather than using try except.. is there any way we can do?"
                    },
                    {
                        "username": "sergei99",
                        "content": "d |= {i: d.get(i, 0) + 1}\\n\\nor\\n\\nd |= {i: d.setdefault(i, 0) + 1}\\n\\nor\\n\\nd[i] = d.get(i, 0) + 1\\n\\nor\\n\\nd.setdefault(i, 0)\\nd[i] += 1"
                    },
                    {
                        "username": "shubhee1021",
                        "content": " start =0\\n        # end = len(nums)-1\\n        # while start <= end:\\n        #     if nums[start] == nums[end]:\\n        #         return True\\n        #     elif nums[start] < nums[end]:\\n        #         start+=1\\n        #     else:\\n        #         end-=1\\n        # return False \\n\\nanyone please tell me what is ther error in this code why it is showing wrong output for this test case [1,2,3,4]"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just put printouts of key variables and watch whether stdout matches your expectations. Remove printouts before submitting the code (so they don\\'t mess execution time up)."
                    },
                    {
                        "username": "217r1a04g8",
                        "content": " `class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        ArrayList<Integer> h = new ArrayList<>();\n        for(int num:nums) {\n            if(h.contains(num)) {\n                 return true;\n            }\n            h.add(num);\n        }\n        return false;\n    }\n}`\nwhy above code is giving TLE?\nCan someone help "
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Easy\"? Yes if you are happy to stick with 1% of the least efficient solutions. No if you are trying to win the top 1%.\nThe authors were quite creative about the test input data. It's amazing to find it generating lots of hash collisions. Moreover, at least one of their tests uses plenty of numbers differing in just one bit (e.g. differing by 128). Pretty good test data set if you want to debug your own collection (which I had to create as I couldn't squeeze enough performance from STL - it seems to be decades behind the time). Now the 100+ line solution gives 69-72ms execution time for C++, beating 99.5% users, and uses below 60 Mb of memory, beating 69%, as opposed to the original simplistic 10-line version based on STL (which had showed mediocre 95-110ms and almost 70 Mb, making me sick about \"the fastest language\"). And I guess there is still plenty of room for memory optimization here...\n\nP.S. Submitted same code just one more time today and got 55ms, beating 99.91% of participants. Memory eternal to Phil Bagwell for inventing the AMT."
                    },
                    {
                        "username": "scribling",
                        "content": "what is my function supposed to be called?"
                    },
                    {
                        "username": "Kayden1",
                        "content": "Someone pleae tell me what is wrong with my code.Been staring at it for almost 30 mins.\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}"
                    },
                    {
                        "username": "JetHsu",
                        "content": "Time complexity is n square, exceed time limit."
                    },
                    {
                        "username": "Solnijko",
                        "content": "If you remove duplicates from nums and it\\'s length is less than it was then there definitely were duplicates "
                    },
                    {
                        "username": "kapil198",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n         for(int i =0; i<nums.length; i++){\\n            int key = i;\\n            for(int j = i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shadiev",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 2034083,
                "content": [
                    {
                        "username": "UNSPOKEN",
                        "content": "I solved the problem using while loop it is faster than using 2 for loops but still its much slower, any other approach that anyone can suggest which doesn\\'t use in-built methods."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n\\n        for(int i = 0; i < nums. length - 1; i++) {\\n\\n            if(nums[i] == nums[i + 1]) {\\n\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "sergei99",
                        "content": "Builtin methods? Like what?"
                    },
                    {
                        "username": "Goutham18",
                        "content": "try:\\n    d[i]\\nexcept KeyError:\\n    d[i] = 1\\nelse:\\n    d[i] += 1\\n\\nI think using try, it\\'s trying to access the element.. if it not exists, then sets a new key.. if exists (else), then we update and break it there itself and return True or set a flag and break.. I think this runs in O(n).. rather than using try except.. is there any way we can do?"
                    },
                    {
                        "username": "sergei99",
                        "content": "d |= {i: d.get(i, 0) + 1}\\n\\nor\\n\\nd |= {i: d.setdefault(i, 0) + 1}\\n\\nor\\n\\nd[i] = d.get(i, 0) + 1\\n\\nor\\n\\nd.setdefault(i, 0)\\nd[i] += 1"
                    },
                    {
                        "username": "shubhee1021",
                        "content": " start =0\\n        # end = len(nums)-1\\n        # while start <= end:\\n        #     if nums[start] == nums[end]:\\n        #         return True\\n        #     elif nums[start] < nums[end]:\\n        #         start+=1\\n        #     else:\\n        #         end-=1\\n        # return False \\n\\nanyone please tell me what is ther error in this code why it is showing wrong output for this test case [1,2,3,4]"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just put printouts of key variables and watch whether stdout matches your expectations. Remove printouts before submitting the code (so they don\\'t mess execution time up)."
                    },
                    {
                        "username": "217r1a04g8",
                        "content": " `class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        ArrayList<Integer> h = new ArrayList<>();\n        for(int num:nums) {\n            if(h.contains(num)) {\n                 return true;\n            }\n            h.add(num);\n        }\n        return false;\n    }\n}`\nwhy above code is giving TLE?\nCan someone help "
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Easy\"? Yes if you are happy to stick with 1% of the least efficient solutions. No if you are trying to win the top 1%.\nThe authors were quite creative about the test input data. It's amazing to find it generating lots of hash collisions. Moreover, at least one of their tests uses plenty of numbers differing in just one bit (e.g. differing by 128). Pretty good test data set if you want to debug your own collection (which I had to create as I couldn't squeeze enough performance from STL - it seems to be decades behind the time). Now the 100+ line solution gives 69-72ms execution time for C++, beating 99.5% users, and uses below 60 Mb of memory, beating 69%, as opposed to the original simplistic 10-line version based on STL (which had showed mediocre 95-110ms and almost 70 Mb, making me sick about \"the fastest language\"). And I guess there is still plenty of room for memory optimization here...\n\nP.S. Submitted same code just one more time today and got 55ms, beating 99.91% of participants. Memory eternal to Phil Bagwell for inventing the AMT."
                    },
                    {
                        "username": "scribling",
                        "content": "what is my function supposed to be called?"
                    },
                    {
                        "username": "Kayden1",
                        "content": "Someone pleae tell me what is wrong with my code.Been staring at it for almost 30 mins.\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}"
                    },
                    {
                        "username": "JetHsu",
                        "content": "Time complexity is n square, exceed time limit."
                    },
                    {
                        "username": "Solnijko",
                        "content": "If you remove duplicates from nums and it\\'s length is less than it was then there definitely were duplicates "
                    },
                    {
                        "username": "kapil198",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n         for(int i =0; i<nums.length; i++){\\n            int key = i;\\n            for(int j = i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shadiev",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 2031457,
                "content": [
                    {
                        "username": "UNSPOKEN",
                        "content": "I solved the problem using while loop it is faster than using 2 for loops but still its much slower, any other approach that anyone can suggest which doesn\\'t use in-built methods."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n\\n        for(int i = 0; i < nums. length - 1; i++) {\\n\\n            if(nums[i] == nums[i + 1]) {\\n\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "sergei99",
                        "content": "Builtin methods? Like what?"
                    },
                    {
                        "username": "Goutham18",
                        "content": "try:\\n    d[i]\\nexcept KeyError:\\n    d[i] = 1\\nelse:\\n    d[i] += 1\\n\\nI think using try, it\\'s trying to access the element.. if it not exists, then sets a new key.. if exists (else), then we update and break it there itself and return True or set a flag and break.. I think this runs in O(n).. rather than using try except.. is there any way we can do?"
                    },
                    {
                        "username": "sergei99",
                        "content": "d |= {i: d.get(i, 0) + 1}\\n\\nor\\n\\nd |= {i: d.setdefault(i, 0) + 1}\\n\\nor\\n\\nd[i] = d.get(i, 0) + 1\\n\\nor\\n\\nd.setdefault(i, 0)\\nd[i] += 1"
                    },
                    {
                        "username": "shubhee1021",
                        "content": " start =0\\n        # end = len(nums)-1\\n        # while start <= end:\\n        #     if nums[start] == nums[end]:\\n        #         return True\\n        #     elif nums[start] < nums[end]:\\n        #         start+=1\\n        #     else:\\n        #         end-=1\\n        # return False \\n\\nanyone please tell me what is ther error in this code why it is showing wrong output for this test case [1,2,3,4]"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just put printouts of key variables and watch whether stdout matches your expectations. Remove printouts before submitting the code (so they don\\'t mess execution time up)."
                    },
                    {
                        "username": "217r1a04g8",
                        "content": " `class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        ArrayList<Integer> h = new ArrayList<>();\n        for(int num:nums) {\n            if(h.contains(num)) {\n                 return true;\n            }\n            h.add(num);\n        }\n        return false;\n    }\n}`\nwhy above code is giving TLE?\nCan someone help "
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Easy\"? Yes if you are happy to stick with 1% of the least efficient solutions. No if you are trying to win the top 1%.\nThe authors were quite creative about the test input data. It's amazing to find it generating lots of hash collisions. Moreover, at least one of their tests uses plenty of numbers differing in just one bit (e.g. differing by 128). Pretty good test data set if you want to debug your own collection (which I had to create as I couldn't squeeze enough performance from STL - it seems to be decades behind the time). Now the 100+ line solution gives 69-72ms execution time for C++, beating 99.5% users, and uses below 60 Mb of memory, beating 69%, as opposed to the original simplistic 10-line version based on STL (which had showed mediocre 95-110ms and almost 70 Mb, making me sick about \"the fastest language\"). And I guess there is still plenty of room for memory optimization here...\n\nP.S. Submitted same code just one more time today and got 55ms, beating 99.91% of participants. Memory eternal to Phil Bagwell for inventing the AMT."
                    },
                    {
                        "username": "scribling",
                        "content": "what is my function supposed to be called?"
                    },
                    {
                        "username": "Kayden1",
                        "content": "Someone pleae tell me what is wrong with my code.Been staring at it for almost 30 mins.\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}"
                    },
                    {
                        "username": "JetHsu",
                        "content": "Time complexity is n square, exceed time limit."
                    },
                    {
                        "username": "Solnijko",
                        "content": "If you remove duplicates from nums and it\\'s length is less than it was then there definitely were duplicates "
                    },
                    {
                        "username": "kapil198",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n         for(int i =0; i<nums.length; i++){\\n            int key = i;\\n            for(int j = i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shadiev",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 2031005,
                "content": [
                    {
                        "username": "UNSPOKEN",
                        "content": "I solved the problem using while loop it is faster than using 2 for loops but still its much slower, any other approach that anyone can suggest which doesn\\'t use in-built methods."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n\\n        for(int i = 0; i < nums. length - 1; i++) {\\n\\n            if(nums[i] == nums[i + 1]) {\\n\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "sergei99",
                        "content": "Builtin methods? Like what?"
                    },
                    {
                        "username": "Goutham18",
                        "content": "try:\\n    d[i]\\nexcept KeyError:\\n    d[i] = 1\\nelse:\\n    d[i] += 1\\n\\nI think using try, it\\'s trying to access the element.. if it not exists, then sets a new key.. if exists (else), then we update and break it there itself and return True or set a flag and break.. I think this runs in O(n).. rather than using try except.. is there any way we can do?"
                    },
                    {
                        "username": "sergei99",
                        "content": "d |= {i: d.get(i, 0) + 1}\\n\\nor\\n\\nd |= {i: d.setdefault(i, 0) + 1}\\n\\nor\\n\\nd[i] = d.get(i, 0) + 1\\n\\nor\\n\\nd.setdefault(i, 0)\\nd[i] += 1"
                    },
                    {
                        "username": "shubhee1021",
                        "content": " start =0\\n        # end = len(nums)-1\\n        # while start <= end:\\n        #     if nums[start] == nums[end]:\\n        #         return True\\n        #     elif nums[start] < nums[end]:\\n        #         start+=1\\n        #     else:\\n        #         end-=1\\n        # return False \\n\\nanyone please tell me what is ther error in this code why it is showing wrong output for this test case [1,2,3,4]"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just put printouts of key variables and watch whether stdout matches your expectations. Remove printouts before submitting the code (so they don\\'t mess execution time up)."
                    },
                    {
                        "username": "217r1a04g8",
                        "content": " `class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        ArrayList<Integer> h = new ArrayList<>();\n        for(int num:nums) {\n            if(h.contains(num)) {\n                 return true;\n            }\n            h.add(num);\n        }\n        return false;\n    }\n}`\nwhy above code is giving TLE?\nCan someone help "
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Easy\"? Yes if you are happy to stick with 1% of the least efficient solutions. No if you are trying to win the top 1%.\nThe authors were quite creative about the test input data. It's amazing to find it generating lots of hash collisions. Moreover, at least one of their tests uses plenty of numbers differing in just one bit (e.g. differing by 128). Pretty good test data set if you want to debug your own collection (which I had to create as I couldn't squeeze enough performance from STL - it seems to be decades behind the time). Now the 100+ line solution gives 69-72ms execution time for C++, beating 99.5% users, and uses below 60 Mb of memory, beating 69%, as opposed to the original simplistic 10-line version based on STL (which had showed mediocre 95-110ms and almost 70 Mb, making me sick about \"the fastest language\"). And I guess there is still plenty of room for memory optimization here...\n\nP.S. Submitted same code just one more time today and got 55ms, beating 99.91% of participants. Memory eternal to Phil Bagwell for inventing the AMT."
                    },
                    {
                        "username": "scribling",
                        "content": "what is my function supposed to be called?"
                    },
                    {
                        "username": "Kayden1",
                        "content": "Someone pleae tell me what is wrong with my code.Been staring at it for almost 30 mins.\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}"
                    },
                    {
                        "username": "JetHsu",
                        "content": "Time complexity is n square, exceed time limit."
                    },
                    {
                        "username": "Solnijko",
                        "content": "If you remove duplicates from nums and it\\'s length is less than it was then there definitely were duplicates "
                    },
                    {
                        "username": "kapil198",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n         for(int i =0; i<nums.length; i++){\\n            int key = i;\\n            for(int j = i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shadiev",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 2028988,
                "content": [
                    {
                        "username": "UNSPOKEN",
                        "content": "I solved the problem using while loop it is faster than using 2 for loops but still its much slower, any other approach that anyone can suggest which doesn\\'t use in-built methods."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n\\n        for(int i = 0; i < nums. length - 1; i++) {\\n\\n            if(nums[i] == nums[i + 1]) {\\n\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "sergei99",
                        "content": "Builtin methods? Like what?"
                    },
                    {
                        "username": "Goutham18",
                        "content": "try:\\n    d[i]\\nexcept KeyError:\\n    d[i] = 1\\nelse:\\n    d[i] += 1\\n\\nI think using try, it\\'s trying to access the element.. if it not exists, then sets a new key.. if exists (else), then we update and break it there itself and return True or set a flag and break.. I think this runs in O(n).. rather than using try except.. is there any way we can do?"
                    },
                    {
                        "username": "sergei99",
                        "content": "d |= {i: d.get(i, 0) + 1}\\n\\nor\\n\\nd |= {i: d.setdefault(i, 0) + 1}\\n\\nor\\n\\nd[i] = d.get(i, 0) + 1\\n\\nor\\n\\nd.setdefault(i, 0)\\nd[i] += 1"
                    },
                    {
                        "username": "shubhee1021",
                        "content": " start =0\\n        # end = len(nums)-1\\n        # while start <= end:\\n        #     if nums[start] == nums[end]:\\n        #         return True\\n        #     elif nums[start] < nums[end]:\\n        #         start+=1\\n        #     else:\\n        #         end-=1\\n        # return False \\n\\nanyone please tell me what is ther error in this code why it is showing wrong output for this test case [1,2,3,4]"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just put printouts of key variables and watch whether stdout matches your expectations. Remove printouts before submitting the code (so they don\\'t mess execution time up)."
                    },
                    {
                        "username": "217r1a04g8",
                        "content": " `class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        ArrayList<Integer> h = new ArrayList<>();\n        for(int num:nums) {\n            if(h.contains(num)) {\n                 return true;\n            }\n            h.add(num);\n        }\n        return false;\n    }\n}`\nwhy above code is giving TLE?\nCan someone help "
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Easy\"? Yes if you are happy to stick with 1% of the least efficient solutions. No if you are trying to win the top 1%.\nThe authors were quite creative about the test input data. It's amazing to find it generating lots of hash collisions. Moreover, at least one of their tests uses plenty of numbers differing in just one bit (e.g. differing by 128). Pretty good test data set if you want to debug your own collection (which I had to create as I couldn't squeeze enough performance from STL - it seems to be decades behind the time). Now the 100+ line solution gives 69-72ms execution time for C++, beating 99.5% users, and uses below 60 Mb of memory, beating 69%, as opposed to the original simplistic 10-line version based on STL (which had showed mediocre 95-110ms and almost 70 Mb, making me sick about \"the fastest language\"). And I guess there is still plenty of room for memory optimization here...\n\nP.S. Submitted same code just one more time today and got 55ms, beating 99.91% of participants. Memory eternal to Phil Bagwell for inventing the AMT."
                    },
                    {
                        "username": "scribling",
                        "content": "what is my function supposed to be called?"
                    },
                    {
                        "username": "Kayden1",
                        "content": "Someone pleae tell me what is wrong with my code.Been staring at it for almost 30 mins.\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}"
                    },
                    {
                        "username": "JetHsu",
                        "content": "Time complexity is n square, exceed time limit."
                    },
                    {
                        "username": "Solnijko",
                        "content": "If you remove duplicates from nums and it\\'s length is less than it was then there definitely were duplicates "
                    },
                    {
                        "username": "kapil198",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n         for(int i =0; i<nums.length; i++){\\n            int key = i;\\n            for(int j = i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shadiev",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 2028097,
                "content": [
                    {
                        "username": "UNSPOKEN",
                        "content": "I solved the problem using while loop it is faster than using 2 for loops but still its much slower, any other approach that anyone can suggest which doesn\\'t use in-built methods."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n\\n        for(int i = 0; i < nums. length - 1; i++) {\\n\\n            if(nums[i] == nums[i + 1]) {\\n\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "sergei99",
                        "content": "Builtin methods? Like what?"
                    },
                    {
                        "username": "Goutham18",
                        "content": "try:\\n    d[i]\\nexcept KeyError:\\n    d[i] = 1\\nelse:\\n    d[i] += 1\\n\\nI think using try, it\\'s trying to access the element.. if it not exists, then sets a new key.. if exists (else), then we update and break it there itself and return True or set a flag and break.. I think this runs in O(n).. rather than using try except.. is there any way we can do?"
                    },
                    {
                        "username": "sergei99",
                        "content": "d |= {i: d.get(i, 0) + 1}\\n\\nor\\n\\nd |= {i: d.setdefault(i, 0) + 1}\\n\\nor\\n\\nd[i] = d.get(i, 0) + 1\\n\\nor\\n\\nd.setdefault(i, 0)\\nd[i] += 1"
                    },
                    {
                        "username": "shubhee1021",
                        "content": " start =0\\n        # end = len(nums)-1\\n        # while start <= end:\\n        #     if nums[start] == nums[end]:\\n        #         return True\\n        #     elif nums[start] < nums[end]:\\n        #         start+=1\\n        #     else:\\n        #         end-=1\\n        # return False \\n\\nanyone please tell me what is ther error in this code why it is showing wrong output for this test case [1,2,3,4]"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just put printouts of key variables and watch whether stdout matches your expectations. Remove printouts before submitting the code (so they don\\'t mess execution time up)."
                    },
                    {
                        "username": "217r1a04g8",
                        "content": " `class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        ArrayList<Integer> h = new ArrayList<>();\n        for(int num:nums) {\n            if(h.contains(num)) {\n                 return true;\n            }\n            h.add(num);\n        }\n        return false;\n    }\n}`\nwhy above code is giving TLE?\nCan someone help "
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Easy\"? Yes if you are happy to stick with 1% of the least efficient solutions. No if you are trying to win the top 1%.\nThe authors were quite creative about the test input data. It's amazing to find it generating lots of hash collisions. Moreover, at least one of their tests uses plenty of numbers differing in just one bit (e.g. differing by 128). Pretty good test data set if you want to debug your own collection (which I had to create as I couldn't squeeze enough performance from STL - it seems to be decades behind the time). Now the 100+ line solution gives 69-72ms execution time for C++, beating 99.5% users, and uses below 60 Mb of memory, beating 69%, as opposed to the original simplistic 10-line version based on STL (which had showed mediocre 95-110ms and almost 70 Mb, making me sick about \"the fastest language\"). And I guess there is still plenty of room for memory optimization here...\n\nP.S. Submitted same code just one more time today and got 55ms, beating 99.91% of participants. Memory eternal to Phil Bagwell for inventing the AMT."
                    },
                    {
                        "username": "scribling",
                        "content": "what is my function supposed to be called?"
                    },
                    {
                        "username": "Kayden1",
                        "content": "Someone pleae tell me what is wrong with my code.Been staring at it for almost 30 mins.\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}"
                    },
                    {
                        "username": "JetHsu",
                        "content": "Time complexity is n square, exceed time limit."
                    },
                    {
                        "username": "Solnijko",
                        "content": "If you remove duplicates from nums and it\\'s length is less than it was then there definitely were duplicates "
                    },
                    {
                        "username": "kapil198",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n         for(int i =0; i<nums.length; i++){\\n            int key = i;\\n            for(int j = i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shadiev",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 2023354,
                "content": [
                    {
                        "username": "UNSPOKEN",
                        "content": "I solved the problem using while loop it is faster than using 2 for loops but still its much slower, any other approach that anyone can suggest which doesn\\'t use in-built methods."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n\\n        for(int i = 0; i < nums. length - 1; i++) {\\n\\n            if(nums[i] == nums[i + 1]) {\\n\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "sergei99",
                        "content": "Builtin methods? Like what?"
                    },
                    {
                        "username": "Goutham18",
                        "content": "try:\\n    d[i]\\nexcept KeyError:\\n    d[i] = 1\\nelse:\\n    d[i] += 1\\n\\nI think using try, it\\'s trying to access the element.. if it not exists, then sets a new key.. if exists (else), then we update and break it there itself and return True or set a flag and break.. I think this runs in O(n).. rather than using try except.. is there any way we can do?"
                    },
                    {
                        "username": "sergei99",
                        "content": "d |= {i: d.get(i, 0) + 1}\\n\\nor\\n\\nd |= {i: d.setdefault(i, 0) + 1}\\n\\nor\\n\\nd[i] = d.get(i, 0) + 1\\n\\nor\\n\\nd.setdefault(i, 0)\\nd[i] += 1"
                    },
                    {
                        "username": "shubhee1021",
                        "content": " start =0\\n        # end = len(nums)-1\\n        # while start <= end:\\n        #     if nums[start] == nums[end]:\\n        #         return True\\n        #     elif nums[start] < nums[end]:\\n        #         start+=1\\n        #     else:\\n        #         end-=1\\n        # return False \\n\\nanyone please tell me what is ther error in this code why it is showing wrong output for this test case [1,2,3,4]"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just put printouts of key variables and watch whether stdout matches your expectations. Remove printouts before submitting the code (so they don\\'t mess execution time up)."
                    },
                    {
                        "username": "217r1a04g8",
                        "content": " `class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        ArrayList<Integer> h = new ArrayList<>();\n        for(int num:nums) {\n            if(h.contains(num)) {\n                 return true;\n            }\n            h.add(num);\n        }\n        return false;\n    }\n}`\nwhy above code is giving TLE?\nCan someone help "
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Easy\"? Yes if you are happy to stick with 1% of the least efficient solutions. No if you are trying to win the top 1%.\nThe authors were quite creative about the test input data. It's amazing to find it generating lots of hash collisions. Moreover, at least one of their tests uses plenty of numbers differing in just one bit (e.g. differing by 128). Pretty good test data set if you want to debug your own collection (which I had to create as I couldn't squeeze enough performance from STL - it seems to be decades behind the time). Now the 100+ line solution gives 69-72ms execution time for C++, beating 99.5% users, and uses below 60 Mb of memory, beating 69%, as opposed to the original simplistic 10-line version based on STL (which had showed mediocre 95-110ms and almost 70 Mb, making me sick about \"the fastest language\"). And I guess there is still plenty of room for memory optimization here...\n\nP.S. Submitted same code just one more time today and got 55ms, beating 99.91% of participants. Memory eternal to Phil Bagwell for inventing the AMT."
                    },
                    {
                        "username": "scribling",
                        "content": "what is my function supposed to be called?"
                    },
                    {
                        "username": "Kayden1",
                        "content": "Someone pleae tell me what is wrong with my code.Been staring at it for almost 30 mins.\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}"
                    },
                    {
                        "username": "JetHsu",
                        "content": "Time complexity is n square, exceed time limit."
                    },
                    {
                        "username": "Solnijko",
                        "content": "If you remove duplicates from nums and it\\'s length is less than it was then there definitely were duplicates "
                    },
                    {
                        "username": "kapil198",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n         for(int i =0; i<nums.length; i++){\\n            int key = i;\\n            for(int j = i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shadiev",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 2013910,
                "content": [
                    {
                        "username": "UNSPOKEN",
                        "content": "I solved the problem using while loop it is faster than using 2 for loops but still its much slower, any other approach that anyone can suggest which doesn\\'t use in-built methods."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n\\n        for(int i = 0; i < nums. length - 1; i++) {\\n\\n            if(nums[i] == nums[i + 1]) {\\n\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "sergei99",
                        "content": "Builtin methods? Like what?"
                    },
                    {
                        "username": "Goutham18",
                        "content": "try:\\n    d[i]\\nexcept KeyError:\\n    d[i] = 1\\nelse:\\n    d[i] += 1\\n\\nI think using try, it\\'s trying to access the element.. if it not exists, then sets a new key.. if exists (else), then we update and break it there itself and return True or set a flag and break.. I think this runs in O(n).. rather than using try except.. is there any way we can do?"
                    },
                    {
                        "username": "sergei99",
                        "content": "d |= {i: d.get(i, 0) + 1}\\n\\nor\\n\\nd |= {i: d.setdefault(i, 0) + 1}\\n\\nor\\n\\nd[i] = d.get(i, 0) + 1\\n\\nor\\n\\nd.setdefault(i, 0)\\nd[i] += 1"
                    },
                    {
                        "username": "shubhee1021",
                        "content": " start =0\\n        # end = len(nums)-1\\n        # while start <= end:\\n        #     if nums[start] == nums[end]:\\n        #         return True\\n        #     elif nums[start] < nums[end]:\\n        #         start+=1\\n        #     else:\\n        #         end-=1\\n        # return False \\n\\nanyone please tell me what is ther error in this code why it is showing wrong output for this test case [1,2,3,4]"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just put printouts of key variables and watch whether stdout matches your expectations. Remove printouts before submitting the code (so they don\\'t mess execution time up)."
                    },
                    {
                        "username": "217r1a04g8",
                        "content": " `class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        ArrayList<Integer> h = new ArrayList<>();\n        for(int num:nums) {\n            if(h.contains(num)) {\n                 return true;\n            }\n            h.add(num);\n        }\n        return false;\n    }\n}`\nwhy above code is giving TLE?\nCan someone help "
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Easy\"? Yes if you are happy to stick with 1% of the least efficient solutions. No if you are trying to win the top 1%.\nThe authors were quite creative about the test input data. It's amazing to find it generating lots of hash collisions. Moreover, at least one of their tests uses plenty of numbers differing in just one bit (e.g. differing by 128). Pretty good test data set if you want to debug your own collection (which I had to create as I couldn't squeeze enough performance from STL - it seems to be decades behind the time). Now the 100+ line solution gives 69-72ms execution time for C++, beating 99.5% users, and uses below 60 Mb of memory, beating 69%, as opposed to the original simplistic 10-line version based on STL (which had showed mediocre 95-110ms and almost 70 Mb, making me sick about \"the fastest language\"). And I guess there is still plenty of room for memory optimization here...\n\nP.S. Submitted same code just one more time today and got 55ms, beating 99.91% of participants. Memory eternal to Phil Bagwell for inventing the AMT."
                    },
                    {
                        "username": "scribling",
                        "content": "what is my function supposed to be called?"
                    },
                    {
                        "username": "Kayden1",
                        "content": "Someone pleae tell me what is wrong with my code.Been staring at it for almost 30 mins.\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}"
                    },
                    {
                        "username": "JetHsu",
                        "content": "Time complexity is n square, exceed time limit."
                    },
                    {
                        "username": "Solnijko",
                        "content": "If you remove duplicates from nums and it\\'s length is less than it was then there definitely were duplicates "
                    },
                    {
                        "username": "kapil198",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n         for(int i =0; i<nums.length; i++){\\n            int key = i;\\n            for(int j = i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shadiev",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 2012350,
                "content": [
                    {
                        "username": "UNSPOKEN",
                        "content": "I solved the problem using while loop it is faster than using 2 for loops but still its much slower, any other approach that anyone can suggest which doesn\\'t use in-built methods."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n\\n        for(int i = 0; i < nums. length - 1; i++) {\\n\\n            if(nums[i] == nums[i + 1]) {\\n\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "sergei99",
                        "content": "Builtin methods? Like what?"
                    },
                    {
                        "username": "Goutham18",
                        "content": "try:\\n    d[i]\\nexcept KeyError:\\n    d[i] = 1\\nelse:\\n    d[i] += 1\\n\\nI think using try, it\\'s trying to access the element.. if it not exists, then sets a new key.. if exists (else), then we update and break it there itself and return True or set a flag and break.. I think this runs in O(n).. rather than using try except.. is there any way we can do?"
                    },
                    {
                        "username": "sergei99",
                        "content": "d |= {i: d.get(i, 0) + 1}\\n\\nor\\n\\nd |= {i: d.setdefault(i, 0) + 1}\\n\\nor\\n\\nd[i] = d.get(i, 0) + 1\\n\\nor\\n\\nd.setdefault(i, 0)\\nd[i] += 1"
                    },
                    {
                        "username": "shubhee1021",
                        "content": " start =0\\n        # end = len(nums)-1\\n        # while start <= end:\\n        #     if nums[start] == nums[end]:\\n        #         return True\\n        #     elif nums[start] < nums[end]:\\n        #         start+=1\\n        #     else:\\n        #         end-=1\\n        # return False \\n\\nanyone please tell me what is ther error in this code why it is showing wrong output for this test case [1,2,3,4]"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just put printouts of key variables and watch whether stdout matches your expectations. Remove printouts before submitting the code (so they don\\'t mess execution time up)."
                    },
                    {
                        "username": "217r1a04g8",
                        "content": " `class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        ArrayList<Integer> h = new ArrayList<>();\n        for(int num:nums) {\n            if(h.contains(num)) {\n                 return true;\n            }\n            h.add(num);\n        }\n        return false;\n    }\n}`\nwhy above code is giving TLE?\nCan someone help "
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Easy\"? Yes if you are happy to stick with 1% of the least efficient solutions. No if you are trying to win the top 1%.\nThe authors were quite creative about the test input data. It's amazing to find it generating lots of hash collisions. Moreover, at least one of their tests uses plenty of numbers differing in just one bit (e.g. differing by 128). Pretty good test data set if you want to debug your own collection (which I had to create as I couldn't squeeze enough performance from STL - it seems to be decades behind the time). Now the 100+ line solution gives 69-72ms execution time for C++, beating 99.5% users, and uses below 60 Mb of memory, beating 69%, as opposed to the original simplistic 10-line version based on STL (which had showed mediocre 95-110ms and almost 70 Mb, making me sick about \"the fastest language\"). And I guess there is still plenty of room for memory optimization here...\n\nP.S. Submitted same code just one more time today and got 55ms, beating 99.91% of participants. Memory eternal to Phil Bagwell for inventing the AMT."
                    },
                    {
                        "username": "scribling",
                        "content": "what is my function supposed to be called?"
                    },
                    {
                        "username": "Kayden1",
                        "content": "Someone pleae tell me what is wrong with my code.Been staring at it for almost 30 mins.\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}"
                    },
                    {
                        "username": "JetHsu",
                        "content": "Time complexity is n square, exceed time limit."
                    },
                    {
                        "username": "Solnijko",
                        "content": "If you remove duplicates from nums and it\\'s length is less than it was then there definitely were duplicates "
                    },
                    {
                        "username": "kapil198",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n         for(int i =0; i<nums.length; i++){\\n            int key = i;\\n            for(int j = i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shadiev",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 2008476,
                "content": [
                    {
                        "username": "UNSPOKEN",
                        "content": "I solved the problem using while loop it is faster than using 2 for loops but still its much slower, any other approach that anyone can suggest which doesn\\'t use in-built methods."
                    },
                    {
                        "username": "hanzlasaqib2023",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n\\n        for(int i = 0; i < nums. length - 1; i++) {\\n\\n            if(nums[i] == nums[i + 1]) {\\n\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "sergei99",
                        "content": "Builtin methods? Like what?"
                    },
                    {
                        "username": "Goutham18",
                        "content": "try:\\n    d[i]\\nexcept KeyError:\\n    d[i] = 1\\nelse:\\n    d[i] += 1\\n\\nI think using try, it\\'s trying to access the element.. if it not exists, then sets a new key.. if exists (else), then we update and break it there itself and return True or set a flag and break.. I think this runs in O(n).. rather than using try except.. is there any way we can do?"
                    },
                    {
                        "username": "sergei99",
                        "content": "d |= {i: d.get(i, 0) + 1}\\n\\nor\\n\\nd |= {i: d.setdefault(i, 0) + 1}\\n\\nor\\n\\nd[i] = d.get(i, 0) + 1\\n\\nor\\n\\nd.setdefault(i, 0)\\nd[i] += 1"
                    },
                    {
                        "username": "shubhee1021",
                        "content": " start =0\\n        # end = len(nums)-1\\n        # while start <= end:\\n        #     if nums[start] == nums[end]:\\n        #         return True\\n        #     elif nums[start] < nums[end]:\\n        #         start+=1\\n        #     else:\\n        #         end-=1\\n        # return False \\n\\nanyone please tell me what is ther error in this code why it is showing wrong output for this test case [1,2,3,4]"
                    },
                    {
                        "username": "sergei99",
                        "content": "Just put printouts of key variables and watch whether stdout matches your expectations. Remove printouts before submitting the code (so they don\\'t mess execution time up)."
                    },
                    {
                        "username": "217r1a04g8",
                        "content": " `class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        ArrayList<Integer> h = new ArrayList<>();\n        for(int num:nums) {\n            if(h.contains(num)) {\n                 return true;\n            }\n            h.add(num);\n        }\n        return false;\n    }\n}`\nwhy above code is giving TLE?\nCan someone help "
                    },
                    {
                        "username": "sergei99",
                        "content": "\"Easy\"? Yes if you are happy to stick with 1% of the least efficient solutions. No if you are trying to win the top 1%.\nThe authors were quite creative about the test input data. It's amazing to find it generating lots of hash collisions. Moreover, at least one of their tests uses plenty of numbers differing in just one bit (e.g. differing by 128). Pretty good test data set if you want to debug your own collection (which I had to create as I couldn't squeeze enough performance from STL - it seems to be decades behind the time). Now the 100+ line solution gives 69-72ms execution time for C++, beating 99.5% users, and uses below 60 Mb of memory, beating 69%, as opposed to the original simplistic 10-line version based on STL (which had showed mediocre 95-110ms and almost 70 Mb, making me sick about \"the fastest language\"). And I guess there is still plenty of room for memory optimization here...\n\nP.S. Submitted same code just one more time today and got 55ms, beating 99.91% of participants. Memory eternal to Phil Bagwell for inventing the AMT."
                    },
                    {
                        "username": "scribling",
                        "content": "what is my function supposed to be called?"
                    },
                    {
                        "username": "Kayden1",
                        "content": "Someone pleae tell me what is wrong with my code.Been staring at it for almost 30 mins.\\n\\nbool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}"
                    },
                    {
                        "username": "JetHsu",
                        "content": "Time complexity is n square, exceed time limit."
                    },
                    {
                        "username": "Solnijko",
                        "content": "If you remove duplicates from nums and it\\'s length is less than it was then there definitely were duplicates "
                    },
                    {
                        "username": "kapil198",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n         for(int i =0; i<nums.length; i++){\\n            int key = i;\\n            for(int j = i+1; j<nums.length; j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "shadiev",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    }
                ]
            },
            {
                "id": 2006846,
                "content": [
                    {
                        "username": "arpitagoyal2822002",
                        "content": "mylist = [5, 3, 5, 2, 1, 6, 6, 4] # 5 & 6 are duplicate numbers.\\n# create a set from the list\\nmyset = set(mylist)\\n# compare the length and print if the list contains duplicates\\nif len(mylist) != len(myset):\\n    print(\"True\")\\nelse:\\n        print(\"False\")"
                    },
                    {
                        "username": "deep_1096",
                        "content": "Number of ways to do this in Python, using sets or counters.\\nPlease let me more if there is a better way"
                    },
                    {
                        "username": "whatacode",
                        "content": "Is there a O(N) time and O(1) space solution to this question?"
                    },
                    {
                        "username": "exava",
                        "content": "I am wondering if there is a solution using bit operations"
                    },
                    {
                        "username": "ibhashmi",
                        "content": " Does anyone know why I keep getting a Time Limit Exceeded error with this solution? It seems to always occur on the test case where nums has all numbers from 0 to 99,999 (total of 100,000 elements)\\n\\n\\n`\\n    def containsDuplicate(self, nums):\\n        \\n        d = {}\\n        for i in range(len(nums)):\\n            if nums[i] in d.values():\\n                return True\\n            else:\\n                d[i] = nums[i]\\n        return False`\\n\\nI\\'ve even tried pasting and running an online solution that\\'s supposed to work and yet I keep running into the same Time Limit Exceeded issue :/"
                    },
                    {
                        "username": "CodeMaverickX",
                        "content": "Why is the problem giving TLE with ArrayList but working fine with HashMap. Shouldn\\'t the time complexities be the same for both?"
                    },
                    {
                        "username": "shraddhagupta7525",
                        "content": "testcase are accepted but submit not accept . its given time limit exceeded, why???"
                    },
                    {
                        "username": "user9771xx",
                        "content": "Here is my solution using freq array but i got time limiet excced on case 20 I don\\'t know why ?? I think here complesity is O(nums.length) the issue here may be space not time So coud you give me any answer to my question \\nNote  i have answered it using hash table but i want to know what is the problem with this solution\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n    vector<bool> freqpos(pow(10,9),false);\\n    vector<bool> freqneg(pow(10,9),false);\\n    for(auto it=nums.begin();it!=nums.end();it++){\\n        if(*it>=0){\\n            if(freqpos[*it]){\\n                return true;\\n            }\\n            freqpos[*it]=true;\\n        }\\n        else{\\n             if(freqneg[(*it)*-1]){\\n                return true;\\n            }\\n            freqneg[(*it)*-1]=true;\\n        }\\n    }\\n    return false;\\n}\\n};\\n\\n[-800,122,459,-871,156,-877,268,-578,17,394,89,-124,592,-356]"
                    },
                    {
                        "username": "edwardsspell",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        result=\"false\"\\n        for i in range(len(nums)-1):\\n            if nums[i] in nums[i+1:]:\\n                result=\"true\"\\n                break\\n        return result\\n\\ncan any one explain issue with this solution. 2nd test case gets failed."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "store elements as we iterate in map, check if the element already exist in map, if found return true else false"
                    }
                ]
            },
            {
                "id": 2003383,
                "content": [
                    {
                        "username": "arpitagoyal2822002",
                        "content": "mylist = [5, 3, 5, 2, 1, 6, 6, 4] # 5 & 6 are duplicate numbers.\\n# create a set from the list\\nmyset = set(mylist)\\n# compare the length and print if the list contains duplicates\\nif len(mylist) != len(myset):\\n    print(\"True\")\\nelse:\\n        print(\"False\")"
                    },
                    {
                        "username": "deep_1096",
                        "content": "Number of ways to do this in Python, using sets or counters.\\nPlease let me more if there is a better way"
                    },
                    {
                        "username": "whatacode",
                        "content": "Is there a O(N) time and O(1) space solution to this question?"
                    },
                    {
                        "username": "exava",
                        "content": "I am wondering if there is a solution using bit operations"
                    },
                    {
                        "username": "ibhashmi",
                        "content": " Does anyone know why I keep getting a Time Limit Exceeded error with this solution? It seems to always occur on the test case where nums has all numbers from 0 to 99,999 (total of 100,000 elements)\\n\\n\\n`\\n    def containsDuplicate(self, nums):\\n        \\n        d = {}\\n        for i in range(len(nums)):\\n            if nums[i] in d.values():\\n                return True\\n            else:\\n                d[i] = nums[i]\\n        return False`\\n\\nI\\'ve even tried pasting and running an online solution that\\'s supposed to work and yet I keep running into the same Time Limit Exceeded issue :/"
                    },
                    {
                        "username": "CodeMaverickX",
                        "content": "Why is the problem giving TLE with ArrayList but working fine with HashMap. Shouldn\\'t the time complexities be the same for both?"
                    },
                    {
                        "username": "shraddhagupta7525",
                        "content": "testcase are accepted but submit not accept . its given time limit exceeded, why???"
                    },
                    {
                        "username": "user9771xx",
                        "content": "Here is my solution using freq array but i got time limiet excced on case 20 I don\\'t know why ?? I think here complesity is O(nums.length) the issue here may be space not time So coud you give me any answer to my question \\nNote  i have answered it using hash table but i want to know what is the problem with this solution\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n    vector<bool> freqpos(pow(10,9),false);\\n    vector<bool> freqneg(pow(10,9),false);\\n    for(auto it=nums.begin();it!=nums.end();it++){\\n        if(*it>=0){\\n            if(freqpos[*it]){\\n                return true;\\n            }\\n            freqpos[*it]=true;\\n        }\\n        else{\\n             if(freqneg[(*it)*-1]){\\n                return true;\\n            }\\n            freqneg[(*it)*-1]=true;\\n        }\\n    }\\n    return false;\\n}\\n};\\n\\n[-800,122,459,-871,156,-877,268,-578,17,394,89,-124,592,-356]"
                    },
                    {
                        "username": "edwardsspell",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        result=\"false\"\\n        for i in range(len(nums)-1):\\n            if nums[i] in nums[i+1:]:\\n                result=\"true\"\\n                break\\n        return result\\n\\ncan any one explain issue with this solution. 2nd test case gets failed."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "store elements as we iterate in map, check if the element already exist in map, if found return true else false"
                    }
                ]
            },
            {
                "id": 2001839,
                "content": [
                    {
                        "username": "arpitagoyal2822002",
                        "content": "mylist = [5, 3, 5, 2, 1, 6, 6, 4] # 5 & 6 are duplicate numbers.\\n# create a set from the list\\nmyset = set(mylist)\\n# compare the length and print if the list contains duplicates\\nif len(mylist) != len(myset):\\n    print(\"True\")\\nelse:\\n        print(\"False\")"
                    },
                    {
                        "username": "deep_1096",
                        "content": "Number of ways to do this in Python, using sets or counters.\\nPlease let me more if there is a better way"
                    },
                    {
                        "username": "whatacode",
                        "content": "Is there a O(N) time and O(1) space solution to this question?"
                    },
                    {
                        "username": "exava",
                        "content": "I am wondering if there is a solution using bit operations"
                    },
                    {
                        "username": "ibhashmi",
                        "content": " Does anyone know why I keep getting a Time Limit Exceeded error with this solution? It seems to always occur on the test case where nums has all numbers from 0 to 99,999 (total of 100,000 elements)\\n\\n\\n`\\n    def containsDuplicate(self, nums):\\n        \\n        d = {}\\n        for i in range(len(nums)):\\n            if nums[i] in d.values():\\n                return True\\n            else:\\n                d[i] = nums[i]\\n        return False`\\n\\nI\\'ve even tried pasting and running an online solution that\\'s supposed to work and yet I keep running into the same Time Limit Exceeded issue :/"
                    },
                    {
                        "username": "CodeMaverickX",
                        "content": "Why is the problem giving TLE with ArrayList but working fine with HashMap. Shouldn\\'t the time complexities be the same for both?"
                    },
                    {
                        "username": "shraddhagupta7525",
                        "content": "testcase are accepted but submit not accept . its given time limit exceeded, why???"
                    },
                    {
                        "username": "user9771xx",
                        "content": "Here is my solution using freq array but i got time limiet excced on case 20 I don\\'t know why ?? I think here complesity is O(nums.length) the issue here may be space not time So coud you give me any answer to my question \\nNote  i have answered it using hash table but i want to know what is the problem with this solution\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n    vector<bool> freqpos(pow(10,9),false);\\n    vector<bool> freqneg(pow(10,9),false);\\n    for(auto it=nums.begin();it!=nums.end();it++){\\n        if(*it>=0){\\n            if(freqpos[*it]){\\n                return true;\\n            }\\n            freqpos[*it]=true;\\n        }\\n        else{\\n             if(freqneg[(*it)*-1]){\\n                return true;\\n            }\\n            freqneg[(*it)*-1]=true;\\n        }\\n    }\\n    return false;\\n}\\n};\\n\\n[-800,122,459,-871,156,-877,268,-578,17,394,89,-124,592,-356]"
                    },
                    {
                        "username": "edwardsspell",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        result=\"false\"\\n        for i in range(len(nums)-1):\\n            if nums[i] in nums[i+1:]:\\n                result=\"true\"\\n                break\\n        return result\\n\\ncan any one explain issue with this solution. 2nd test case gets failed."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "store elements as we iterate in map, check if the element already exist in map, if found return true else false"
                    }
                ]
            },
            {
                "id": 1999397,
                "content": [
                    {
                        "username": "arpitagoyal2822002",
                        "content": "mylist = [5, 3, 5, 2, 1, 6, 6, 4] # 5 & 6 are duplicate numbers.\\n# create a set from the list\\nmyset = set(mylist)\\n# compare the length and print if the list contains duplicates\\nif len(mylist) != len(myset):\\n    print(\"True\")\\nelse:\\n        print(\"False\")"
                    },
                    {
                        "username": "deep_1096",
                        "content": "Number of ways to do this in Python, using sets or counters.\\nPlease let me more if there is a better way"
                    },
                    {
                        "username": "whatacode",
                        "content": "Is there a O(N) time and O(1) space solution to this question?"
                    },
                    {
                        "username": "exava",
                        "content": "I am wondering if there is a solution using bit operations"
                    },
                    {
                        "username": "ibhashmi",
                        "content": " Does anyone know why I keep getting a Time Limit Exceeded error with this solution? It seems to always occur on the test case where nums has all numbers from 0 to 99,999 (total of 100,000 elements)\\n\\n\\n`\\n    def containsDuplicate(self, nums):\\n        \\n        d = {}\\n        for i in range(len(nums)):\\n            if nums[i] in d.values():\\n                return True\\n            else:\\n                d[i] = nums[i]\\n        return False`\\n\\nI\\'ve even tried pasting and running an online solution that\\'s supposed to work and yet I keep running into the same Time Limit Exceeded issue :/"
                    },
                    {
                        "username": "CodeMaverickX",
                        "content": "Why is the problem giving TLE with ArrayList but working fine with HashMap. Shouldn\\'t the time complexities be the same for both?"
                    },
                    {
                        "username": "shraddhagupta7525",
                        "content": "testcase are accepted but submit not accept . its given time limit exceeded, why???"
                    },
                    {
                        "username": "user9771xx",
                        "content": "Here is my solution using freq array but i got time limiet excced on case 20 I don\\'t know why ?? I think here complesity is O(nums.length) the issue here may be space not time So coud you give me any answer to my question \\nNote  i have answered it using hash table but i want to know what is the problem with this solution\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n    vector<bool> freqpos(pow(10,9),false);\\n    vector<bool> freqneg(pow(10,9),false);\\n    for(auto it=nums.begin();it!=nums.end();it++){\\n        if(*it>=0){\\n            if(freqpos[*it]){\\n                return true;\\n            }\\n            freqpos[*it]=true;\\n        }\\n        else{\\n             if(freqneg[(*it)*-1]){\\n                return true;\\n            }\\n            freqneg[(*it)*-1]=true;\\n        }\\n    }\\n    return false;\\n}\\n};\\n\\n[-800,122,459,-871,156,-877,268,-578,17,394,89,-124,592,-356]"
                    },
                    {
                        "username": "edwardsspell",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        result=\"false\"\\n        for i in range(len(nums)-1):\\n            if nums[i] in nums[i+1:]:\\n                result=\"true\"\\n                break\\n        return result\\n\\ncan any one explain issue with this solution. 2nd test case gets failed."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "store elements as we iterate in map, check if the element already exist in map, if found return true else false"
                    }
                ]
            },
            {
                "id": 1999016,
                "content": [
                    {
                        "username": "arpitagoyal2822002",
                        "content": "mylist = [5, 3, 5, 2, 1, 6, 6, 4] # 5 & 6 are duplicate numbers.\\n# create a set from the list\\nmyset = set(mylist)\\n# compare the length and print if the list contains duplicates\\nif len(mylist) != len(myset):\\n    print(\"True\")\\nelse:\\n        print(\"False\")"
                    },
                    {
                        "username": "deep_1096",
                        "content": "Number of ways to do this in Python, using sets or counters.\\nPlease let me more if there is a better way"
                    },
                    {
                        "username": "whatacode",
                        "content": "Is there a O(N) time and O(1) space solution to this question?"
                    },
                    {
                        "username": "exava",
                        "content": "I am wondering if there is a solution using bit operations"
                    },
                    {
                        "username": "ibhashmi",
                        "content": " Does anyone know why I keep getting a Time Limit Exceeded error with this solution? It seems to always occur on the test case where nums has all numbers from 0 to 99,999 (total of 100,000 elements)\\n\\n\\n`\\n    def containsDuplicate(self, nums):\\n        \\n        d = {}\\n        for i in range(len(nums)):\\n            if nums[i] in d.values():\\n                return True\\n            else:\\n                d[i] = nums[i]\\n        return False`\\n\\nI\\'ve even tried pasting and running an online solution that\\'s supposed to work and yet I keep running into the same Time Limit Exceeded issue :/"
                    },
                    {
                        "username": "CodeMaverickX",
                        "content": "Why is the problem giving TLE with ArrayList but working fine with HashMap. Shouldn\\'t the time complexities be the same for both?"
                    },
                    {
                        "username": "shraddhagupta7525",
                        "content": "testcase are accepted but submit not accept . its given time limit exceeded, why???"
                    },
                    {
                        "username": "user9771xx",
                        "content": "Here is my solution using freq array but i got time limiet excced on case 20 I don\\'t know why ?? I think here complesity is O(nums.length) the issue here may be space not time So coud you give me any answer to my question \\nNote  i have answered it using hash table but i want to know what is the problem with this solution\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n    vector<bool> freqpos(pow(10,9),false);\\n    vector<bool> freqneg(pow(10,9),false);\\n    for(auto it=nums.begin();it!=nums.end();it++){\\n        if(*it>=0){\\n            if(freqpos[*it]){\\n                return true;\\n            }\\n            freqpos[*it]=true;\\n        }\\n        else{\\n             if(freqneg[(*it)*-1]){\\n                return true;\\n            }\\n            freqneg[(*it)*-1]=true;\\n        }\\n    }\\n    return false;\\n}\\n};\\n\\n[-800,122,459,-871,156,-877,268,-578,17,394,89,-124,592,-356]"
                    },
                    {
                        "username": "edwardsspell",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        result=\"false\"\\n        for i in range(len(nums)-1):\\n            if nums[i] in nums[i+1:]:\\n                result=\"true\"\\n                break\\n        return result\\n\\ncan any one explain issue with this solution. 2nd test case gets failed."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "store elements as we iterate in map, check if the element already exist in map, if found return true else false"
                    }
                ]
            },
            {
                "id": 1997693,
                "content": [
                    {
                        "username": "arpitagoyal2822002",
                        "content": "mylist = [5, 3, 5, 2, 1, 6, 6, 4] # 5 & 6 are duplicate numbers.\\n# create a set from the list\\nmyset = set(mylist)\\n# compare the length and print if the list contains duplicates\\nif len(mylist) != len(myset):\\n    print(\"True\")\\nelse:\\n        print(\"False\")"
                    },
                    {
                        "username": "deep_1096",
                        "content": "Number of ways to do this in Python, using sets or counters.\\nPlease let me more if there is a better way"
                    },
                    {
                        "username": "whatacode",
                        "content": "Is there a O(N) time and O(1) space solution to this question?"
                    },
                    {
                        "username": "exava",
                        "content": "I am wondering if there is a solution using bit operations"
                    },
                    {
                        "username": "ibhashmi",
                        "content": " Does anyone know why I keep getting a Time Limit Exceeded error with this solution? It seems to always occur on the test case where nums has all numbers from 0 to 99,999 (total of 100,000 elements)\\n\\n\\n`\\n    def containsDuplicate(self, nums):\\n        \\n        d = {}\\n        for i in range(len(nums)):\\n            if nums[i] in d.values():\\n                return True\\n            else:\\n                d[i] = nums[i]\\n        return False`\\n\\nI\\'ve even tried pasting and running an online solution that\\'s supposed to work and yet I keep running into the same Time Limit Exceeded issue :/"
                    },
                    {
                        "username": "CodeMaverickX",
                        "content": "Why is the problem giving TLE with ArrayList but working fine with HashMap. Shouldn\\'t the time complexities be the same for both?"
                    },
                    {
                        "username": "shraddhagupta7525",
                        "content": "testcase are accepted but submit not accept . its given time limit exceeded, why???"
                    },
                    {
                        "username": "user9771xx",
                        "content": "Here is my solution using freq array but i got time limiet excced on case 20 I don\\'t know why ?? I think here complesity is O(nums.length) the issue here may be space not time So coud you give me any answer to my question \\nNote  i have answered it using hash table but i want to know what is the problem with this solution\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n    vector<bool> freqpos(pow(10,9),false);\\n    vector<bool> freqneg(pow(10,9),false);\\n    for(auto it=nums.begin();it!=nums.end();it++){\\n        if(*it>=0){\\n            if(freqpos[*it]){\\n                return true;\\n            }\\n            freqpos[*it]=true;\\n        }\\n        else{\\n             if(freqneg[(*it)*-1]){\\n                return true;\\n            }\\n            freqneg[(*it)*-1]=true;\\n        }\\n    }\\n    return false;\\n}\\n};\\n\\n[-800,122,459,-871,156,-877,268,-578,17,394,89,-124,592,-356]"
                    },
                    {
                        "username": "edwardsspell",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        result=\"false\"\\n        for i in range(len(nums)-1):\\n            if nums[i] in nums[i+1:]:\\n                result=\"true\"\\n                break\\n        return result\\n\\ncan any one explain issue with this solution. 2nd test case gets failed."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "store elements as we iterate in map, check if the element already exist in map, if found return true else false"
                    }
                ]
            },
            {
                "id": 1993692,
                "content": [
                    {
                        "username": "arpitagoyal2822002",
                        "content": "mylist = [5, 3, 5, 2, 1, 6, 6, 4] # 5 & 6 are duplicate numbers.\\n# create a set from the list\\nmyset = set(mylist)\\n# compare the length and print if the list contains duplicates\\nif len(mylist) != len(myset):\\n    print(\"True\")\\nelse:\\n        print(\"False\")"
                    },
                    {
                        "username": "deep_1096",
                        "content": "Number of ways to do this in Python, using sets or counters.\\nPlease let me more if there is a better way"
                    },
                    {
                        "username": "whatacode",
                        "content": "Is there a O(N) time and O(1) space solution to this question?"
                    },
                    {
                        "username": "exava",
                        "content": "I am wondering if there is a solution using bit operations"
                    },
                    {
                        "username": "ibhashmi",
                        "content": " Does anyone know why I keep getting a Time Limit Exceeded error with this solution? It seems to always occur on the test case where nums has all numbers from 0 to 99,999 (total of 100,000 elements)\\n\\n\\n`\\n    def containsDuplicate(self, nums):\\n        \\n        d = {}\\n        for i in range(len(nums)):\\n            if nums[i] in d.values():\\n                return True\\n            else:\\n                d[i] = nums[i]\\n        return False`\\n\\nI\\'ve even tried pasting and running an online solution that\\'s supposed to work and yet I keep running into the same Time Limit Exceeded issue :/"
                    },
                    {
                        "username": "CodeMaverickX",
                        "content": "Why is the problem giving TLE with ArrayList but working fine with HashMap. Shouldn\\'t the time complexities be the same for both?"
                    },
                    {
                        "username": "shraddhagupta7525",
                        "content": "testcase are accepted but submit not accept . its given time limit exceeded, why???"
                    },
                    {
                        "username": "user9771xx",
                        "content": "Here is my solution using freq array but i got time limiet excced on case 20 I don\\'t know why ?? I think here complesity is O(nums.length) the issue here may be space not time So coud you give me any answer to my question \\nNote  i have answered it using hash table but i want to know what is the problem with this solution\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n    vector<bool> freqpos(pow(10,9),false);\\n    vector<bool> freqneg(pow(10,9),false);\\n    for(auto it=nums.begin();it!=nums.end();it++){\\n        if(*it>=0){\\n            if(freqpos[*it]){\\n                return true;\\n            }\\n            freqpos[*it]=true;\\n        }\\n        else{\\n             if(freqneg[(*it)*-1]){\\n                return true;\\n            }\\n            freqneg[(*it)*-1]=true;\\n        }\\n    }\\n    return false;\\n}\\n};\\n\\n[-800,122,459,-871,156,-877,268,-578,17,394,89,-124,592,-356]"
                    },
                    {
                        "username": "edwardsspell",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        result=\"false\"\\n        for i in range(len(nums)-1):\\n            if nums[i] in nums[i+1:]:\\n                result=\"true\"\\n                break\\n        return result\\n\\ncan any one explain issue with this solution. 2nd test case gets failed."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "store elements as we iterate in map, check if the element already exist in map, if found return true else false"
                    }
                ]
            },
            {
                "id": 1984022,
                "content": [
                    {
                        "username": "arpitagoyal2822002",
                        "content": "mylist = [5, 3, 5, 2, 1, 6, 6, 4] # 5 & 6 are duplicate numbers.\\n# create a set from the list\\nmyset = set(mylist)\\n# compare the length and print if the list contains duplicates\\nif len(mylist) != len(myset):\\n    print(\"True\")\\nelse:\\n        print(\"False\")"
                    },
                    {
                        "username": "deep_1096",
                        "content": "Number of ways to do this in Python, using sets or counters.\\nPlease let me more if there is a better way"
                    },
                    {
                        "username": "whatacode",
                        "content": "Is there a O(N) time and O(1) space solution to this question?"
                    },
                    {
                        "username": "exava",
                        "content": "I am wondering if there is a solution using bit operations"
                    },
                    {
                        "username": "ibhashmi",
                        "content": " Does anyone know why I keep getting a Time Limit Exceeded error with this solution? It seems to always occur on the test case where nums has all numbers from 0 to 99,999 (total of 100,000 elements)\\n\\n\\n`\\n    def containsDuplicate(self, nums):\\n        \\n        d = {}\\n        for i in range(len(nums)):\\n            if nums[i] in d.values():\\n                return True\\n            else:\\n                d[i] = nums[i]\\n        return False`\\n\\nI\\'ve even tried pasting and running an online solution that\\'s supposed to work and yet I keep running into the same Time Limit Exceeded issue :/"
                    },
                    {
                        "username": "CodeMaverickX",
                        "content": "Why is the problem giving TLE with ArrayList but working fine with HashMap. Shouldn\\'t the time complexities be the same for both?"
                    },
                    {
                        "username": "shraddhagupta7525",
                        "content": "testcase are accepted but submit not accept . its given time limit exceeded, why???"
                    },
                    {
                        "username": "user9771xx",
                        "content": "Here is my solution using freq array but i got time limiet excced on case 20 I don\\'t know why ?? I think here complesity is O(nums.length) the issue here may be space not time So coud you give me any answer to my question \\nNote  i have answered it using hash table but i want to know what is the problem with this solution\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n    vector<bool> freqpos(pow(10,9),false);\\n    vector<bool> freqneg(pow(10,9),false);\\n    for(auto it=nums.begin();it!=nums.end();it++){\\n        if(*it>=0){\\n            if(freqpos[*it]){\\n                return true;\\n            }\\n            freqpos[*it]=true;\\n        }\\n        else{\\n             if(freqneg[(*it)*-1]){\\n                return true;\\n            }\\n            freqneg[(*it)*-1]=true;\\n        }\\n    }\\n    return false;\\n}\\n};\\n\\n[-800,122,459,-871,156,-877,268,-578,17,394,89,-124,592,-356]"
                    },
                    {
                        "username": "edwardsspell",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        result=\"false\"\\n        for i in range(len(nums)-1):\\n            if nums[i] in nums[i+1:]:\\n                result=\"true\"\\n                break\\n        return result\\n\\ncan any one explain issue with this solution. 2nd test case gets failed."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "store elements as we iterate in map, check if the element already exist in map, if found return true else false"
                    }
                ]
            },
            {
                "id": 1978657,
                "content": [
                    {
                        "username": "arpitagoyal2822002",
                        "content": "mylist = [5, 3, 5, 2, 1, 6, 6, 4] # 5 & 6 are duplicate numbers.\\n# create a set from the list\\nmyset = set(mylist)\\n# compare the length and print if the list contains duplicates\\nif len(mylist) != len(myset):\\n    print(\"True\")\\nelse:\\n        print(\"False\")"
                    },
                    {
                        "username": "deep_1096",
                        "content": "Number of ways to do this in Python, using sets or counters.\\nPlease let me more if there is a better way"
                    },
                    {
                        "username": "whatacode",
                        "content": "Is there a O(N) time and O(1) space solution to this question?"
                    },
                    {
                        "username": "exava",
                        "content": "I am wondering if there is a solution using bit operations"
                    },
                    {
                        "username": "ibhashmi",
                        "content": " Does anyone know why I keep getting a Time Limit Exceeded error with this solution? It seems to always occur on the test case where nums has all numbers from 0 to 99,999 (total of 100,000 elements)\\n\\n\\n`\\n    def containsDuplicate(self, nums):\\n        \\n        d = {}\\n        for i in range(len(nums)):\\n            if nums[i] in d.values():\\n                return True\\n            else:\\n                d[i] = nums[i]\\n        return False`\\n\\nI\\'ve even tried pasting and running an online solution that\\'s supposed to work and yet I keep running into the same Time Limit Exceeded issue :/"
                    },
                    {
                        "username": "CodeMaverickX",
                        "content": "Why is the problem giving TLE with ArrayList but working fine with HashMap. Shouldn\\'t the time complexities be the same for both?"
                    },
                    {
                        "username": "shraddhagupta7525",
                        "content": "testcase are accepted but submit not accept . its given time limit exceeded, why???"
                    },
                    {
                        "username": "user9771xx",
                        "content": "Here is my solution using freq array but i got time limiet excced on case 20 I don\\'t know why ?? I think here complesity is O(nums.length) the issue here may be space not time So coud you give me any answer to my question \\nNote  i have answered it using hash table but i want to know what is the problem with this solution\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n    vector<bool> freqpos(pow(10,9),false);\\n    vector<bool> freqneg(pow(10,9),false);\\n    for(auto it=nums.begin();it!=nums.end();it++){\\n        if(*it>=0){\\n            if(freqpos[*it]){\\n                return true;\\n            }\\n            freqpos[*it]=true;\\n        }\\n        else{\\n             if(freqneg[(*it)*-1]){\\n                return true;\\n            }\\n            freqneg[(*it)*-1]=true;\\n        }\\n    }\\n    return false;\\n}\\n};\\n\\n[-800,122,459,-871,156,-877,268,-578,17,394,89,-124,592,-356]"
                    },
                    {
                        "username": "edwardsspell",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        result=\"false\"\\n        for i in range(len(nums)-1):\\n            if nums[i] in nums[i+1:]:\\n                result=\"true\"\\n                break\\n        return result\\n\\ncan any one explain issue with this solution. 2nd test case gets failed."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "store elements as we iterate in map, check if the element already exist in map, if found return true else false"
                    }
                ]
            },
            {
                "id": 1974154,
                "content": [
                    {
                        "username": "arpitagoyal2822002",
                        "content": "mylist = [5, 3, 5, 2, 1, 6, 6, 4] # 5 & 6 are duplicate numbers.\\n# create a set from the list\\nmyset = set(mylist)\\n# compare the length and print if the list contains duplicates\\nif len(mylist) != len(myset):\\n    print(\"True\")\\nelse:\\n        print(\"False\")"
                    },
                    {
                        "username": "deep_1096",
                        "content": "Number of ways to do this in Python, using sets or counters.\\nPlease let me more if there is a better way"
                    },
                    {
                        "username": "whatacode",
                        "content": "Is there a O(N) time and O(1) space solution to this question?"
                    },
                    {
                        "username": "exava",
                        "content": "I am wondering if there is a solution using bit operations"
                    },
                    {
                        "username": "ibhashmi",
                        "content": " Does anyone know why I keep getting a Time Limit Exceeded error with this solution? It seems to always occur on the test case where nums has all numbers from 0 to 99,999 (total of 100,000 elements)\\n\\n\\n`\\n    def containsDuplicate(self, nums):\\n        \\n        d = {}\\n        for i in range(len(nums)):\\n            if nums[i] in d.values():\\n                return True\\n            else:\\n                d[i] = nums[i]\\n        return False`\\n\\nI\\'ve even tried pasting and running an online solution that\\'s supposed to work and yet I keep running into the same Time Limit Exceeded issue :/"
                    },
                    {
                        "username": "CodeMaverickX",
                        "content": "Why is the problem giving TLE with ArrayList but working fine with HashMap. Shouldn\\'t the time complexities be the same for both?"
                    },
                    {
                        "username": "shraddhagupta7525",
                        "content": "testcase are accepted but submit not accept . its given time limit exceeded, why???"
                    },
                    {
                        "username": "user9771xx",
                        "content": "Here is my solution using freq array but i got time limiet excced on case 20 I don\\'t know why ?? I think here complesity is O(nums.length) the issue here may be space not time So coud you give me any answer to my question \\nNote  i have answered it using hash table but i want to know what is the problem with this solution\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n    vector<bool> freqpos(pow(10,9),false);\\n    vector<bool> freqneg(pow(10,9),false);\\n    for(auto it=nums.begin();it!=nums.end();it++){\\n        if(*it>=0){\\n            if(freqpos[*it]){\\n                return true;\\n            }\\n            freqpos[*it]=true;\\n        }\\n        else{\\n             if(freqneg[(*it)*-1]){\\n                return true;\\n            }\\n            freqneg[(*it)*-1]=true;\\n        }\\n    }\\n    return false;\\n}\\n};\\n\\n[-800,122,459,-871,156,-877,268,-578,17,394,89,-124,592,-356]"
                    },
                    {
                        "username": "edwardsspell",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        result=\"false\"\\n        for i in range(len(nums)-1):\\n            if nums[i] in nums[i+1:]:\\n                result=\"true\"\\n                break\\n        return result\\n\\ncan any one explain issue with this solution. 2nd test case gets failed."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "store elements as we iterate in map, check if the element already exist in map, if found return true else false"
                    }
                ]
            },
            {
                "id": 1968183,
                "content": [
                    {
                        "username": "selintopcu",
                        "content": "https://github.com/selindayioglu/Java-LeetCode/blob/main/contains-duplicate.java"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "cant we just apply Boyer-Moore Voting Algorithm"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "No, it is for finding item that occur more than $n/2$ times."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, it can be solved faster than $O(n)$, in just $O(n^{2/3})$ time!\\nOnly need a [quantum computer](https://en.wikipedia.org/wiki/Element_distinctness_problem#Quantum_complexity) for that\\u2026"
                    },
                    {
                        "username": "jchowdyna",
                        "content": "Can someone explain why this doesn\\'t work? Thanks!\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    const set = new Set(nums);\\n    return Array.from(set) === nums ? false : true;\\n};\\n```\\n"
                    },
                    {
                        "username": "contactabbasali21",
                        "content": "Guys, want your opinion on this solution, how can i improve it? \\nThe time complexity is 82ms\\n\\n ```\\n    var containsDuplicate = function(nums) \\n\\t{ \\n\\t\\tconst n = nums.length; \\n\\t\\tlet hasDuplicates = false; \\n\\t\\t\\tfor(i=0;i<n;i++)\\n\\t\\t\\t{ \\n\\t\\t\\t\\tlet j = i + 1; \\n\\t\\t\\t\\tif( j >= n){ j = 0; } \\n\\t\\t\\t\\tif(nums[i] === nums[j])\\n\\t\\t\\t\\t{ \\n\\t\\t\\t\\t hasDuplicates = true; \\n\\t\\t\\t\\t break; \\n\\t\\t\\t\\t} \\n\\t\\t\\tif( j === 0){ break } \\n\\t\\t\\t\\n\\t\\t\\t }\\n\\t\\t\\t\\n\\t\\t\\treturn hasDuplicates \\n\\t\\t\\t\\n\\t};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code currently checks if an element is the same as the next element in the array, which won\\'t correctly determine if the array contains duplicates unless they\\'re adjacent in the array.\\n\\nMoreover, your solution runs in O(n^2) time because for every element in the array, it compares it to every other element in the array. For large inputs, this could be very inefficient.\\n\\nHere is an improved version of your function using a JavaScript Set. A Set in JavaScript is similar to a Set in mathematics. It is a collection of unique elements. The advantage of using a Set over an Array is that searching for an element in a Set is O(1), whereas, in an Array, it is O(n).\\n\\n```javascript\\nvar containsDuplicate = function(nums) {\\n    const uniqueNums = new Set();\\n\\n    for(let i = 0; i < nums.length; i++) {\\n        if (uniqueNums.has(nums[i])) {\\n            return true;\\n        }\\n        uniqueNums.add(nums[i]);\\n    }\\n\\n    return false;\\n};\\n```\\n\\nIn this function, we create a Set `uniqueNums`. For each number in `nums`, we check if it\\'s already in `uniqueNums`. If it is, we immediately return `true` because we\\'ve found a duplicate. If it\\'s not, we add it to `uniqueNums`. If we make it through the entire array without finding a duplicate, we return `false`.\\n\\nThis function runs in O(n) time, which is more efficient than the original version. The reason it\\'s more efficient is that both inserting an element into a Set and checking if a Set contains an element are O(1) operations. So we perform 2n O(1) operations, which makes the total time complexity O(n)."
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "I used pre computation, but I am getting one test case wrong when I run the same code in GDB compiler its giving the correct ans \\n\\nconst int N = 1e5 + 10;\\nint hsh[N];\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n       for(auto num:nums){\\n           hsh[num]=hsh[num]+1;\\n       }\\n      for(long long int i=0;i<N;i++){\\n          if(hsh[i]>1){\\n              return 1;\\n              }}\\n      return 0;}\\n};.\\n\\n\\nIs it because the global array is not initialized by zero in this environment or something"
                    },
                    {
                        "username": "FreshWanderer",
                        "content": "I\\'m using C and my code doesn\\'t work in TestCase 2. I\\'m trying to use a Hashset to complete this.\\n\\n ```bool containsDuplicate(int* nums, int numsSize){\\nint hash[numsSize];\\nfor(int i = 0; i < numsSize; i++){\\n        hash[i] = 0;\\n    }\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = 0; j < numsSize; j++){\\n            if(nums[i] != hash[j]) {\\n                hash[i] = nums[i];\\n            } else {\\n                return true;\\n            }\\n        }\\n    }\\nreturn false;\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Efficient solution - > Python\\n\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        a = set(nums)\\n        if len(nums)==len(a):\\n            return False\\n        return True"
                    },
                    {
                        "username": "alokdangwal",
                        "content": "Here You can use an array sort method to reduce the time and space complexity."
                    },
                    {
                        "username": "slylizard",
                        "content": "why does `(len(nums) > len(set(nums)))` have a better runtime than `len(set(nums))!=len(nums)` ?"
                    }
                ]
            },
            {
                "id": 1961690,
                "content": [
                    {
                        "username": "selintopcu",
                        "content": "https://github.com/selindayioglu/Java-LeetCode/blob/main/contains-duplicate.java"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "cant we just apply Boyer-Moore Voting Algorithm"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "No, it is for finding item that occur more than $n/2$ times."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, it can be solved faster than $O(n)$, in just $O(n^{2/3})$ time!\\nOnly need a [quantum computer](https://en.wikipedia.org/wiki/Element_distinctness_problem#Quantum_complexity) for that\\u2026"
                    },
                    {
                        "username": "jchowdyna",
                        "content": "Can someone explain why this doesn\\'t work? Thanks!\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    const set = new Set(nums);\\n    return Array.from(set) === nums ? false : true;\\n};\\n```\\n"
                    },
                    {
                        "username": "contactabbasali21",
                        "content": "Guys, want your opinion on this solution, how can i improve it? \\nThe time complexity is 82ms\\n\\n ```\\n    var containsDuplicate = function(nums) \\n\\t{ \\n\\t\\tconst n = nums.length; \\n\\t\\tlet hasDuplicates = false; \\n\\t\\t\\tfor(i=0;i<n;i++)\\n\\t\\t\\t{ \\n\\t\\t\\t\\tlet j = i + 1; \\n\\t\\t\\t\\tif( j >= n){ j = 0; } \\n\\t\\t\\t\\tif(nums[i] === nums[j])\\n\\t\\t\\t\\t{ \\n\\t\\t\\t\\t hasDuplicates = true; \\n\\t\\t\\t\\t break; \\n\\t\\t\\t\\t} \\n\\t\\t\\tif( j === 0){ break } \\n\\t\\t\\t\\n\\t\\t\\t }\\n\\t\\t\\t\\n\\t\\t\\treturn hasDuplicates \\n\\t\\t\\t\\n\\t};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code currently checks if an element is the same as the next element in the array, which won\\'t correctly determine if the array contains duplicates unless they\\'re adjacent in the array.\\n\\nMoreover, your solution runs in O(n^2) time because for every element in the array, it compares it to every other element in the array. For large inputs, this could be very inefficient.\\n\\nHere is an improved version of your function using a JavaScript Set. A Set in JavaScript is similar to a Set in mathematics. It is a collection of unique elements. The advantage of using a Set over an Array is that searching for an element in a Set is O(1), whereas, in an Array, it is O(n).\\n\\n```javascript\\nvar containsDuplicate = function(nums) {\\n    const uniqueNums = new Set();\\n\\n    for(let i = 0; i < nums.length; i++) {\\n        if (uniqueNums.has(nums[i])) {\\n            return true;\\n        }\\n        uniqueNums.add(nums[i]);\\n    }\\n\\n    return false;\\n};\\n```\\n\\nIn this function, we create a Set `uniqueNums`. For each number in `nums`, we check if it\\'s already in `uniqueNums`. If it is, we immediately return `true` because we\\'ve found a duplicate. If it\\'s not, we add it to `uniqueNums`. If we make it through the entire array without finding a duplicate, we return `false`.\\n\\nThis function runs in O(n) time, which is more efficient than the original version. The reason it\\'s more efficient is that both inserting an element into a Set and checking if a Set contains an element are O(1) operations. So we perform 2n O(1) operations, which makes the total time complexity O(n)."
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "I used pre computation, but I am getting one test case wrong when I run the same code in GDB compiler its giving the correct ans \\n\\nconst int N = 1e5 + 10;\\nint hsh[N];\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n       for(auto num:nums){\\n           hsh[num]=hsh[num]+1;\\n       }\\n      for(long long int i=0;i<N;i++){\\n          if(hsh[i]>1){\\n              return 1;\\n              }}\\n      return 0;}\\n};.\\n\\n\\nIs it because the global array is not initialized by zero in this environment or something"
                    },
                    {
                        "username": "FreshWanderer",
                        "content": "I\\'m using C and my code doesn\\'t work in TestCase 2. I\\'m trying to use a Hashset to complete this.\\n\\n ```bool containsDuplicate(int* nums, int numsSize){\\nint hash[numsSize];\\nfor(int i = 0; i < numsSize; i++){\\n        hash[i] = 0;\\n    }\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = 0; j < numsSize; j++){\\n            if(nums[i] != hash[j]) {\\n                hash[i] = nums[i];\\n            } else {\\n                return true;\\n            }\\n        }\\n    }\\nreturn false;\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Efficient solution - > Python\\n\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        a = set(nums)\\n        if len(nums)==len(a):\\n            return False\\n        return True"
                    },
                    {
                        "username": "alokdangwal",
                        "content": "Here You can use an array sort method to reduce the time and space complexity."
                    },
                    {
                        "username": "slylizard",
                        "content": "why does `(len(nums) > len(set(nums)))` have a better runtime than `len(set(nums))!=len(nums)` ?"
                    }
                ]
            },
            {
                "id": 1955105,
                "content": [
                    {
                        "username": "selintopcu",
                        "content": "https://github.com/selindayioglu/Java-LeetCode/blob/main/contains-duplicate.java"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "cant we just apply Boyer-Moore Voting Algorithm"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "No, it is for finding item that occur more than $n/2$ times."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, it can be solved faster than $O(n)$, in just $O(n^{2/3})$ time!\\nOnly need a [quantum computer](https://en.wikipedia.org/wiki/Element_distinctness_problem#Quantum_complexity) for that\\u2026"
                    },
                    {
                        "username": "jchowdyna",
                        "content": "Can someone explain why this doesn\\'t work? Thanks!\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    const set = new Set(nums);\\n    return Array.from(set) === nums ? false : true;\\n};\\n```\\n"
                    },
                    {
                        "username": "contactabbasali21",
                        "content": "Guys, want your opinion on this solution, how can i improve it? \\nThe time complexity is 82ms\\n\\n ```\\n    var containsDuplicate = function(nums) \\n\\t{ \\n\\t\\tconst n = nums.length; \\n\\t\\tlet hasDuplicates = false; \\n\\t\\t\\tfor(i=0;i<n;i++)\\n\\t\\t\\t{ \\n\\t\\t\\t\\tlet j = i + 1; \\n\\t\\t\\t\\tif( j >= n){ j = 0; } \\n\\t\\t\\t\\tif(nums[i] === nums[j])\\n\\t\\t\\t\\t{ \\n\\t\\t\\t\\t hasDuplicates = true; \\n\\t\\t\\t\\t break; \\n\\t\\t\\t\\t} \\n\\t\\t\\tif( j === 0){ break } \\n\\t\\t\\t\\n\\t\\t\\t }\\n\\t\\t\\t\\n\\t\\t\\treturn hasDuplicates \\n\\t\\t\\t\\n\\t};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code currently checks if an element is the same as the next element in the array, which won\\'t correctly determine if the array contains duplicates unless they\\'re adjacent in the array.\\n\\nMoreover, your solution runs in O(n^2) time because for every element in the array, it compares it to every other element in the array. For large inputs, this could be very inefficient.\\n\\nHere is an improved version of your function using a JavaScript Set. A Set in JavaScript is similar to a Set in mathematics. It is a collection of unique elements. The advantage of using a Set over an Array is that searching for an element in a Set is O(1), whereas, in an Array, it is O(n).\\n\\n```javascript\\nvar containsDuplicate = function(nums) {\\n    const uniqueNums = new Set();\\n\\n    for(let i = 0; i < nums.length; i++) {\\n        if (uniqueNums.has(nums[i])) {\\n            return true;\\n        }\\n        uniqueNums.add(nums[i]);\\n    }\\n\\n    return false;\\n};\\n```\\n\\nIn this function, we create a Set `uniqueNums`. For each number in `nums`, we check if it\\'s already in `uniqueNums`. If it is, we immediately return `true` because we\\'ve found a duplicate. If it\\'s not, we add it to `uniqueNums`. If we make it through the entire array without finding a duplicate, we return `false`.\\n\\nThis function runs in O(n) time, which is more efficient than the original version. The reason it\\'s more efficient is that both inserting an element into a Set and checking if a Set contains an element are O(1) operations. So we perform 2n O(1) operations, which makes the total time complexity O(n)."
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "I used pre computation, but I am getting one test case wrong when I run the same code in GDB compiler its giving the correct ans \\n\\nconst int N = 1e5 + 10;\\nint hsh[N];\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n       for(auto num:nums){\\n           hsh[num]=hsh[num]+1;\\n       }\\n      for(long long int i=0;i<N;i++){\\n          if(hsh[i]>1){\\n              return 1;\\n              }}\\n      return 0;}\\n};.\\n\\n\\nIs it because the global array is not initialized by zero in this environment or something"
                    },
                    {
                        "username": "FreshWanderer",
                        "content": "I\\'m using C and my code doesn\\'t work in TestCase 2. I\\'m trying to use a Hashset to complete this.\\n\\n ```bool containsDuplicate(int* nums, int numsSize){\\nint hash[numsSize];\\nfor(int i = 0; i < numsSize; i++){\\n        hash[i] = 0;\\n    }\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = 0; j < numsSize; j++){\\n            if(nums[i] != hash[j]) {\\n                hash[i] = nums[i];\\n            } else {\\n                return true;\\n            }\\n        }\\n    }\\nreturn false;\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Efficient solution - > Python\\n\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        a = set(nums)\\n        if len(nums)==len(a):\\n            return False\\n        return True"
                    },
                    {
                        "username": "alokdangwal",
                        "content": "Here You can use an array sort method to reduce the time and space complexity."
                    },
                    {
                        "username": "slylizard",
                        "content": "why does `(len(nums) > len(set(nums)))` have a better runtime than `len(set(nums))!=len(nums)` ?"
                    }
                ]
            },
            {
                "id": 1953905,
                "content": [
                    {
                        "username": "selintopcu",
                        "content": "https://github.com/selindayioglu/Java-LeetCode/blob/main/contains-duplicate.java"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "cant we just apply Boyer-Moore Voting Algorithm"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "No, it is for finding item that occur more than $n/2$ times."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, it can be solved faster than $O(n)$, in just $O(n^{2/3})$ time!\\nOnly need a [quantum computer](https://en.wikipedia.org/wiki/Element_distinctness_problem#Quantum_complexity) for that\\u2026"
                    },
                    {
                        "username": "jchowdyna",
                        "content": "Can someone explain why this doesn\\'t work? Thanks!\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    const set = new Set(nums);\\n    return Array.from(set) === nums ? false : true;\\n};\\n```\\n"
                    },
                    {
                        "username": "contactabbasali21",
                        "content": "Guys, want your opinion on this solution, how can i improve it? \\nThe time complexity is 82ms\\n\\n ```\\n    var containsDuplicate = function(nums) \\n\\t{ \\n\\t\\tconst n = nums.length; \\n\\t\\tlet hasDuplicates = false; \\n\\t\\t\\tfor(i=0;i<n;i++)\\n\\t\\t\\t{ \\n\\t\\t\\t\\tlet j = i + 1; \\n\\t\\t\\t\\tif( j >= n){ j = 0; } \\n\\t\\t\\t\\tif(nums[i] === nums[j])\\n\\t\\t\\t\\t{ \\n\\t\\t\\t\\t hasDuplicates = true; \\n\\t\\t\\t\\t break; \\n\\t\\t\\t\\t} \\n\\t\\t\\tif( j === 0){ break } \\n\\t\\t\\t\\n\\t\\t\\t }\\n\\t\\t\\t\\n\\t\\t\\treturn hasDuplicates \\n\\t\\t\\t\\n\\t};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code currently checks if an element is the same as the next element in the array, which won\\'t correctly determine if the array contains duplicates unless they\\'re adjacent in the array.\\n\\nMoreover, your solution runs in O(n^2) time because for every element in the array, it compares it to every other element in the array. For large inputs, this could be very inefficient.\\n\\nHere is an improved version of your function using a JavaScript Set. A Set in JavaScript is similar to a Set in mathematics. It is a collection of unique elements. The advantage of using a Set over an Array is that searching for an element in a Set is O(1), whereas, in an Array, it is O(n).\\n\\n```javascript\\nvar containsDuplicate = function(nums) {\\n    const uniqueNums = new Set();\\n\\n    for(let i = 0; i < nums.length; i++) {\\n        if (uniqueNums.has(nums[i])) {\\n            return true;\\n        }\\n        uniqueNums.add(nums[i]);\\n    }\\n\\n    return false;\\n};\\n```\\n\\nIn this function, we create a Set `uniqueNums`. For each number in `nums`, we check if it\\'s already in `uniqueNums`. If it is, we immediately return `true` because we\\'ve found a duplicate. If it\\'s not, we add it to `uniqueNums`. If we make it through the entire array without finding a duplicate, we return `false`.\\n\\nThis function runs in O(n) time, which is more efficient than the original version. The reason it\\'s more efficient is that both inserting an element into a Set and checking if a Set contains an element are O(1) operations. So we perform 2n O(1) operations, which makes the total time complexity O(n)."
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "I used pre computation, but I am getting one test case wrong when I run the same code in GDB compiler its giving the correct ans \\n\\nconst int N = 1e5 + 10;\\nint hsh[N];\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n       for(auto num:nums){\\n           hsh[num]=hsh[num]+1;\\n       }\\n      for(long long int i=0;i<N;i++){\\n          if(hsh[i]>1){\\n              return 1;\\n              }}\\n      return 0;}\\n};.\\n\\n\\nIs it because the global array is not initialized by zero in this environment or something"
                    },
                    {
                        "username": "FreshWanderer",
                        "content": "I\\'m using C and my code doesn\\'t work in TestCase 2. I\\'m trying to use a Hashset to complete this.\\n\\n ```bool containsDuplicate(int* nums, int numsSize){\\nint hash[numsSize];\\nfor(int i = 0; i < numsSize; i++){\\n        hash[i] = 0;\\n    }\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = 0; j < numsSize; j++){\\n            if(nums[i] != hash[j]) {\\n                hash[i] = nums[i];\\n            } else {\\n                return true;\\n            }\\n        }\\n    }\\nreturn false;\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Efficient solution - > Python\\n\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        a = set(nums)\\n        if len(nums)==len(a):\\n            return False\\n        return True"
                    },
                    {
                        "username": "alokdangwal",
                        "content": "Here You can use an array sort method to reduce the time and space complexity."
                    },
                    {
                        "username": "slylizard",
                        "content": "why does `(len(nums) > len(set(nums)))` have a better runtime than `len(set(nums))!=len(nums)` ?"
                    }
                ]
            },
            {
                "id": 1946601,
                "content": [
                    {
                        "username": "selintopcu",
                        "content": "https://github.com/selindayioglu/Java-LeetCode/blob/main/contains-duplicate.java"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "cant we just apply Boyer-Moore Voting Algorithm"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "No, it is for finding item that occur more than $n/2$ times."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, it can be solved faster than $O(n)$, in just $O(n^{2/3})$ time!\\nOnly need a [quantum computer](https://en.wikipedia.org/wiki/Element_distinctness_problem#Quantum_complexity) for that\\u2026"
                    },
                    {
                        "username": "jchowdyna",
                        "content": "Can someone explain why this doesn\\'t work? Thanks!\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    const set = new Set(nums);\\n    return Array.from(set) === nums ? false : true;\\n};\\n```\\n"
                    },
                    {
                        "username": "contactabbasali21",
                        "content": "Guys, want your opinion on this solution, how can i improve it? \\nThe time complexity is 82ms\\n\\n ```\\n    var containsDuplicate = function(nums) \\n\\t{ \\n\\t\\tconst n = nums.length; \\n\\t\\tlet hasDuplicates = false; \\n\\t\\t\\tfor(i=0;i<n;i++)\\n\\t\\t\\t{ \\n\\t\\t\\t\\tlet j = i + 1; \\n\\t\\t\\t\\tif( j >= n){ j = 0; } \\n\\t\\t\\t\\tif(nums[i] === nums[j])\\n\\t\\t\\t\\t{ \\n\\t\\t\\t\\t hasDuplicates = true; \\n\\t\\t\\t\\t break; \\n\\t\\t\\t\\t} \\n\\t\\t\\tif( j === 0){ break } \\n\\t\\t\\t\\n\\t\\t\\t }\\n\\t\\t\\t\\n\\t\\t\\treturn hasDuplicates \\n\\t\\t\\t\\n\\t};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code currently checks if an element is the same as the next element in the array, which won\\'t correctly determine if the array contains duplicates unless they\\'re adjacent in the array.\\n\\nMoreover, your solution runs in O(n^2) time because for every element in the array, it compares it to every other element in the array. For large inputs, this could be very inefficient.\\n\\nHere is an improved version of your function using a JavaScript Set. A Set in JavaScript is similar to a Set in mathematics. It is a collection of unique elements. The advantage of using a Set over an Array is that searching for an element in a Set is O(1), whereas, in an Array, it is O(n).\\n\\n```javascript\\nvar containsDuplicate = function(nums) {\\n    const uniqueNums = new Set();\\n\\n    for(let i = 0; i < nums.length; i++) {\\n        if (uniqueNums.has(nums[i])) {\\n            return true;\\n        }\\n        uniqueNums.add(nums[i]);\\n    }\\n\\n    return false;\\n};\\n```\\n\\nIn this function, we create a Set `uniqueNums`. For each number in `nums`, we check if it\\'s already in `uniqueNums`. If it is, we immediately return `true` because we\\'ve found a duplicate. If it\\'s not, we add it to `uniqueNums`. If we make it through the entire array without finding a duplicate, we return `false`.\\n\\nThis function runs in O(n) time, which is more efficient than the original version. The reason it\\'s more efficient is that both inserting an element into a Set and checking if a Set contains an element are O(1) operations. So we perform 2n O(1) operations, which makes the total time complexity O(n)."
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "I used pre computation, but I am getting one test case wrong when I run the same code in GDB compiler its giving the correct ans \\n\\nconst int N = 1e5 + 10;\\nint hsh[N];\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n       for(auto num:nums){\\n           hsh[num]=hsh[num]+1;\\n       }\\n      for(long long int i=0;i<N;i++){\\n          if(hsh[i]>1){\\n              return 1;\\n              }}\\n      return 0;}\\n};.\\n\\n\\nIs it because the global array is not initialized by zero in this environment or something"
                    },
                    {
                        "username": "FreshWanderer",
                        "content": "I\\'m using C and my code doesn\\'t work in TestCase 2. I\\'m trying to use a Hashset to complete this.\\n\\n ```bool containsDuplicate(int* nums, int numsSize){\\nint hash[numsSize];\\nfor(int i = 0; i < numsSize; i++){\\n        hash[i] = 0;\\n    }\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = 0; j < numsSize; j++){\\n            if(nums[i] != hash[j]) {\\n                hash[i] = nums[i];\\n            } else {\\n                return true;\\n            }\\n        }\\n    }\\nreturn false;\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Efficient solution - > Python\\n\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        a = set(nums)\\n        if len(nums)==len(a):\\n            return False\\n        return True"
                    },
                    {
                        "username": "alokdangwal",
                        "content": "Here You can use an array sort method to reduce the time and space complexity."
                    },
                    {
                        "username": "slylizard",
                        "content": "why does `(len(nums) > len(set(nums)))` have a better runtime than `len(set(nums))!=len(nums)` ?"
                    }
                ]
            },
            {
                "id": 1945092,
                "content": [
                    {
                        "username": "selintopcu",
                        "content": "https://github.com/selindayioglu/Java-LeetCode/blob/main/contains-duplicate.java"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "cant we just apply Boyer-Moore Voting Algorithm"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "No, it is for finding item that occur more than $n/2$ times."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, it can be solved faster than $O(n)$, in just $O(n^{2/3})$ time!\\nOnly need a [quantum computer](https://en.wikipedia.org/wiki/Element_distinctness_problem#Quantum_complexity) for that\\u2026"
                    },
                    {
                        "username": "jchowdyna",
                        "content": "Can someone explain why this doesn\\'t work? Thanks!\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    const set = new Set(nums);\\n    return Array.from(set) === nums ? false : true;\\n};\\n```\\n"
                    },
                    {
                        "username": "contactabbasali21",
                        "content": "Guys, want your opinion on this solution, how can i improve it? \\nThe time complexity is 82ms\\n\\n ```\\n    var containsDuplicate = function(nums) \\n\\t{ \\n\\t\\tconst n = nums.length; \\n\\t\\tlet hasDuplicates = false; \\n\\t\\t\\tfor(i=0;i<n;i++)\\n\\t\\t\\t{ \\n\\t\\t\\t\\tlet j = i + 1; \\n\\t\\t\\t\\tif( j >= n){ j = 0; } \\n\\t\\t\\t\\tif(nums[i] === nums[j])\\n\\t\\t\\t\\t{ \\n\\t\\t\\t\\t hasDuplicates = true; \\n\\t\\t\\t\\t break; \\n\\t\\t\\t\\t} \\n\\t\\t\\tif( j === 0){ break } \\n\\t\\t\\t\\n\\t\\t\\t }\\n\\t\\t\\t\\n\\t\\t\\treturn hasDuplicates \\n\\t\\t\\t\\n\\t};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code currently checks if an element is the same as the next element in the array, which won\\'t correctly determine if the array contains duplicates unless they\\'re adjacent in the array.\\n\\nMoreover, your solution runs in O(n^2) time because for every element in the array, it compares it to every other element in the array. For large inputs, this could be very inefficient.\\n\\nHere is an improved version of your function using a JavaScript Set. A Set in JavaScript is similar to a Set in mathematics. It is a collection of unique elements. The advantage of using a Set over an Array is that searching for an element in a Set is O(1), whereas, in an Array, it is O(n).\\n\\n```javascript\\nvar containsDuplicate = function(nums) {\\n    const uniqueNums = new Set();\\n\\n    for(let i = 0; i < nums.length; i++) {\\n        if (uniqueNums.has(nums[i])) {\\n            return true;\\n        }\\n        uniqueNums.add(nums[i]);\\n    }\\n\\n    return false;\\n};\\n```\\n\\nIn this function, we create a Set `uniqueNums`. For each number in `nums`, we check if it\\'s already in `uniqueNums`. If it is, we immediately return `true` because we\\'ve found a duplicate. If it\\'s not, we add it to `uniqueNums`. If we make it through the entire array without finding a duplicate, we return `false`.\\n\\nThis function runs in O(n) time, which is more efficient than the original version. The reason it\\'s more efficient is that both inserting an element into a Set and checking if a Set contains an element are O(1) operations. So we perform 2n O(1) operations, which makes the total time complexity O(n)."
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "I used pre computation, but I am getting one test case wrong when I run the same code in GDB compiler its giving the correct ans \\n\\nconst int N = 1e5 + 10;\\nint hsh[N];\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n       for(auto num:nums){\\n           hsh[num]=hsh[num]+1;\\n       }\\n      for(long long int i=0;i<N;i++){\\n          if(hsh[i]>1){\\n              return 1;\\n              }}\\n      return 0;}\\n};.\\n\\n\\nIs it because the global array is not initialized by zero in this environment or something"
                    },
                    {
                        "username": "FreshWanderer",
                        "content": "I\\'m using C and my code doesn\\'t work in TestCase 2. I\\'m trying to use a Hashset to complete this.\\n\\n ```bool containsDuplicate(int* nums, int numsSize){\\nint hash[numsSize];\\nfor(int i = 0; i < numsSize; i++){\\n        hash[i] = 0;\\n    }\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = 0; j < numsSize; j++){\\n            if(nums[i] != hash[j]) {\\n                hash[i] = nums[i];\\n            } else {\\n                return true;\\n            }\\n        }\\n    }\\nreturn false;\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Efficient solution - > Python\\n\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        a = set(nums)\\n        if len(nums)==len(a):\\n            return False\\n        return True"
                    },
                    {
                        "username": "alokdangwal",
                        "content": "Here You can use an array sort method to reduce the time and space complexity."
                    },
                    {
                        "username": "slylizard",
                        "content": "why does `(len(nums) > len(set(nums)))` have a better runtime than `len(set(nums))!=len(nums)` ?"
                    }
                ]
            },
            {
                "id": 1944593,
                "content": [
                    {
                        "username": "selintopcu",
                        "content": "https://github.com/selindayioglu/Java-LeetCode/blob/main/contains-duplicate.java"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "cant we just apply Boyer-Moore Voting Algorithm"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "No, it is for finding item that occur more than $n/2$ times."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, it can be solved faster than $O(n)$, in just $O(n^{2/3})$ time!\\nOnly need a [quantum computer](https://en.wikipedia.org/wiki/Element_distinctness_problem#Quantum_complexity) for that\\u2026"
                    },
                    {
                        "username": "jchowdyna",
                        "content": "Can someone explain why this doesn\\'t work? Thanks!\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    const set = new Set(nums);\\n    return Array.from(set) === nums ? false : true;\\n};\\n```\\n"
                    },
                    {
                        "username": "contactabbasali21",
                        "content": "Guys, want your opinion on this solution, how can i improve it? \\nThe time complexity is 82ms\\n\\n ```\\n    var containsDuplicate = function(nums) \\n\\t{ \\n\\t\\tconst n = nums.length; \\n\\t\\tlet hasDuplicates = false; \\n\\t\\t\\tfor(i=0;i<n;i++)\\n\\t\\t\\t{ \\n\\t\\t\\t\\tlet j = i + 1; \\n\\t\\t\\t\\tif( j >= n){ j = 0; } \\n\\t\\t\\t\\tif(nums[i] === nums[j])\\n\\t\\t\\t\\t{ \\n\\t\\t\\t\\t hasDuplicates = true; \\n\\t\\t\\t\\t break; \\n\\t\\t\\t\\t} \\n\\t\\t\\tif( j === 0){ break } \\n\\t\\t\\t\\n\\t\\t\\t }\\n\\t\\t\\t\\n\\t\\t\\treturn hasDuplicates \\n\\t\\t\\t\\n\\t};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code currently checks if an element is the same as the next element in the array, which won\\'t correctly determine if the array contains duplicates unless they\\'re adjacent in the array.\\n\\nMoreover, your solution runs in O(n^2) time because for every element in the array, it compares it to every other element in the array. For large inputs, this could be very inefficient.\\n\\nHere is an improved version of your function using a JavaScript Set. A Set in JavaScript is similar to a Set in mathematics. It is a collection of unique elements. The advantage of using a Set over an Array is that searching for an element in a Set is O(1), whereas, in an Array, it is O(n).\\n\\n```javascript\\nvar containsDuplicate = function(nums) {\\n    const uniqueNums = new Set();\\n\\n    for(let i = 0; i < nums.length; i++) {\\n        if (uniqueNums.has(nums[i])) {\\n            return true;\\n        }\\n        uniqueNums.add(nums[i]);\\n    }\\n\\n    return false;\\n};\\n```\\n\\nIn this function, we create a Set `uniqueNums`. For each number in `nums`, we check if it\\'s already in `uniqueNums`. If it is, we immediately return `true` because we\\'ve found a duplicate. If it\\'s not, we add it to `uniqueNums`. If we make it through the entire array without finding a duplicate, we return `false`.\\n\\nThis function runs in O(n) time, which is more efficient than the original version. The reason it\\'s more efficient is that both inserting an element into a Set and checking if a Set contains an element are O(1) operations. So we perform 2n O(1) operations, which makes the total time complexity O(n)."
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "I used pre computation, but I am getting one test case wrong when I run the same code in GDB compiler its giving the correct ans \\n\\nconst int N = 1e5 + 10;\\nint hsh[N];\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n       for(auto num:nums){\\n           hsh[num]=hsh[num]+1;\\n       }\\n      for(long long int i=0;i<N;i++){\\n          if(hsh[i]>1){\\n              return 1;\\n              }}\\n      return 0;}\\n};.\\n\\n\\nIs it because the global array is not initialized by zero in this environment or something"
                    },
                    {
                        "username": "FreshWanderer",
                        "content": "I\\'m using C and my code doesn\\'t work in TestCase 2. I\\'m trying to use a Hashset to complete this.\\n\\n ```bool containsDuplicate(int* nums, int numsSize){\\nint hash[numsSize];\\nfor(int i = 0; i < numsSize; i++){\\n        hash[i] = 0;\\n    }\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = 0; j < numsSize; j++){\\n            if(nums[i] != hash[j]) {\\n                hash[i] = nums[i];\\n            } else {\\n                return true;\\n            }\\n        }\\n    }\\nreturn false;\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Efficient solution - > Python\\n\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        a = set(nums)\\n        if len(nums)==len(a):\\n            return False\\n        return True"
                    },
                    {
                        "username": "alokdangwal",
                        "content": "Here You can use an array sort method to reduce the time and space complexity."
                    },
                    {
                        "username": "slylizard",
                        "content": "why does `(len(nums) > len(set(nums)))` have a better runtime than `len(set(nums))!=len(nums)` ?"
                    }
                ]
            },
            {
                "id": 1942211,
                "content": [
                    {
                        "username": "selintopcu",
                        "content": "https://github.com/selindayioglu/Java-LeetCode/blob/main/contains-duplicate.java"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "cant we just apply Boyer-Moore Voting Algorithm"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "No, it is for finding item that occur more than $n/2$ times."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, it can be solved faster than $O(n)$, in just $O(n^{2/3})$ time!\\nOnly need a [quantum computer](https://en.wikipedia.org/wiki/Element_distinctness_problem#Quantum_complexity) for that\\u2026"
                    },
                    {
                        "username": "jchowdyna",
                        "content": "Can someone explain why this doesn\\'t work? Thanks!\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    const set = new Set(nums);\\n    return Array.from(set) === nums ? false : true;\\n};\\n```\\n"
                    },
                    {
                        "username": "contactabbasali21",
                        "content": "Guys, want your opinion on this solution, how can i improve it? \\nThe time complexity is 82ms\\n\\n ```\\n    var containsDuplicate = function(nums) \\n\\t{ \\n\\t\\tconst n = nums.length; \\n\\t\\tlet hasDuplicates = false; \\n\\t\\t\\tfor(i=0;i<n;i++)\\n\\t\\t\\t{ \\n\\t\\t\\t\\tlet j = i + 1; \\n\\t\\t\\t\\tif( j >= n){ j = 0; } \\n\\t\\t\\t\\tif(nums[i] === nums[j])\\n\\t\\t\\t\\t{ \\n\\t\\t\\t\\t hasDuplicates = true; \\n\\t\\t\\t\\t break; \\n\\t\\t\\t\\t} \\n\\t\\t\\tif( j === 0){ break } \\n\\t\\t\\t\\n\\t\\t\\t }\\n\\t\\t\\t\\n\\t\\t\\treturn hasDuplicates \\n\\t\\t\\t\\n\\t};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code currently checks if an element is the same as the next element in the array, which won\\'t correctly determine if the array contains duplicates unless they\\'re adjacent in the array.\\n\\nMoreover, your solution runs in O(n^2) time because for every element in the array, it compares it to every other element in the array. For large inputs, this could be very inefficient.\\n\\nHere is an improved version of your function using a JavaScript Set. A Set in JavaScript is similar to a Set in mathematics. It is a collection of unique elements. The advantage of using a Set over an Array is that searching for an element in a Set is O(1), whereas, in an Array, it is O(n).\\n\\n```javascript\\nvar containsDuplicate = function(nums) {\\n    const uniqueNums = new Set();\\n\\n    for(let i = 0; i < nums.length; i++) {\\n        if (uniqueNums.has(nums[i])) {\\n            return true;\\n        }\\n        uniqueNums.add(nums[i]);\\n    }\\n\\n    return false;\\n};\\n```\\n\\nIn this function, we create a Set `uniqueNums`. For each number in `nums`, we check if it\\'s already in `uniqueNums`. If it is, we immediately return `true` because we\\'ve found a duplicate. If it\\'s not, we add it to `uniqueNums`. If we make it through the entire array without finding a duplicate, we return `false`.\\n\\nThis function runs in O(n) time, which is more efficient than the original version. The reason it\\'s more efficient is that both inserting an element into a Set and checking if a Set contains an element are O(1) operations. So we perform 2n O(1) operations, which makes the total time complexity O(n)."
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "I used pre computation, but I am getting one test case wrong when I run the same code in GDB compiler its giving the correct ans \\n\\nconst int N = 1e5 + 10;\\nint hsh[N];\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n       for(auto num:nums){\\n           hsh[num]=hsh[num]+1;\\n       }\\n      for(long long int i=0;i<N;i++){\\n          if(hsh[i]>1){\\n              return 1;\\n              }}\\n      return 0;}\\n};.\\n\\n\\nIs it because the global array is not initialized by zero in this environment or something"
                    },
                    {
                        "username": "FreshWanderer",
                        "content": "I\\'m using C and my code doesn\\'t work in TestCase 2. I\\'m trying to use a Hashset to complete this.\\n\\n ```bool containsDuplicate(int* nums, int numsSize){\\nint hash[numsSize];\\nfor(int i = 0; i < numsSize; i++){\\n        hash[i] = 0;\\n    }\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = 0; j < numsSize; j++){\\n            if(nums[i] != hash[j]) {\\n                hash[i] = nums[i];\\n            } else {\\n                return true;\\n            }\\n        }\\n    }\\nreturn false;\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Efficient solution - > Python\\n\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        a = set(nums)\\n        if len(nums)==len(a):\\n            return False\\n        return True"
                    },
                    {
                        "username": "alokdangwal",
                        "content": "Here You can use an array sort method to reduce the time and space complexity."
                    },
                    {
                        "username": "slylizard",
                        "content": "why does `(len(nums) > len(set(nums)))` have a better runtime than `len(set(nums))!=len(nums)` ?"
                    }
                ]
            },
            {
                "id": 1940850,
                "content": [
                    {
                        "username": "selintopcu",
                        "content": "https://github.com/selindayioglu/Java-LeetCode/blob/main/contains-duplicate.java"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "cant we just apply Boyer-Moore Voting Algorithm"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "No, it is for finding item that occur more than $n/2$ times."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, it can be solved faster than $O(n)$, in just $O(n^{2/3})$ time!\\nOnly need a [quantum computer](https://en.wikipedia.org/wiki/Element_distinctness_problem#Quantum_complexity) for that\\u2026"
                    },
                    {
                        "username": "jchowdyna",
                        "content": "Can someone explain why this doesn\\'t work? Thanks!\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    const set = new Set(nums);\\n    return Array.from(set) === nums ? false : true;\\n};\\n```\\n"
                    },
                    {
                        "username": "contactabbasali21",
                        "content": "Guys, want your opinion on this solution, how can i improve it? \\nThe time complexity is 82ms\\n\\n ```\\n    var containsDuplicate = function(nums) \\n\\t{ \\n\\t\\tconst n = nums.length; \\n\\t\\tlet hasDuplicates = false; \\n\\t\\t\\tfor(i=0;i<n;i++)\\n\\t\\t\\t{ \\n\\t\\t\\t\\tlet j = i + 1; \\n\\t\\t\\t\\tif( j >= n){ j = 0; } \\n\\t\\t\\t\\tif(nums[i] === nums[j])\\n\\t\\t\\t\\t{ \\n\\t\\t\\t\\t hasDuplicates = true; \\n\\t\\t\\t\\t break; \\n\\t\\t\\t\\t} \\n\\t\\t\\tif( j === 0){ break } \\n\\t\\t\\t\\n\\t\\t\\t }\\n\\t\\t\\t\\n\\t\\t\\treturn hasDuplicates \\n\\t\\t\\t\\n\\t};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code currently checks if an element is the same as the next element in the array, which won\\'t correctly determine if the array contains duplicates unless they\\'re adjacent in the array.\\n\\nMoreover, your solution runs in O(n^2) time because for every element in the array, it compares it to every other element in the array. For large inputs, this could be very inefficient.\\n\\nHere is an improved version of your function using a JavaScript Set. A Set in JavaScript is similar to a Set in mathematics. It is a collection of unique elements. The advantage of using a Set over an Array is that searching for an element in a Set is O(1), whereas, in an Array, it is O(n).\\n\\n```javascript\\nvar containsDuplicate = function(nums) {\\n    const uniqueNums = new Set();\\n\\n    for(let i = 0; i < nums.length; i++) {\\n        if (uniqueNums.has(nums[i])) {\\n            return true;\\n        }\\n        uniqueNums.add(nums[i]);\\n    }\\n\\n    return false;\\n};\\n```\\n\\nIn this function, we create a Set `uniqueNums`. For each number in `nums`, we check if it\\'s already in `uniqueNums`. If it is, we immediately return `true` because we\\'ve found a duplicate. If it\\'s not, we add it to `uniqueNums`. If we make it through the entire array without finding a duplicate, we return `false`.\\n\\nThis function runs in O(n) time, which is more efficient than the original version. The reason it\\'s more efficient is that both inserting an element into a Set and checking if a Set contains an element are O(1) operations. So we perform 2n O(1) operations, which makes the total time complexity O(n)."
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "I used pre computation, but I am getting one test case wrong when I run the same code in GDB compiler its giving the correct ans \\n\\nconst int N = 1e5 + 10;\\nint hsh[N];\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n       for(auto num:nums){\\n           hsh[num]=hsh[num]+1;\\n       }\\n      for(long long int i=0;i<N;i++){\\n          if(hsh[i]>1){\\n              return 1;\\n              }}\\n      return 0;}\\n};.\\n\\n\\nIs it because the global array is not initialized by zero in this environment or something"
                    },
                    {
                        "username": "FreshWanderer",
                        "content": "I\\'m using C and my code doesn\\'t work in TestCase 2. I\\'m trying to use a Hashset to complete this.\\n\\n ```bool containsDuplicate(int* nums, int numsSize){\\nint hash[numsSize];\\nfor(int i = 0; i < numsSize; i++){\\n        hash[i] = 0;\\n    }\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = 0; j < numsSize; j++){\\n            if(nums[i] != hash[j]) {\\n                hash[i] = nums[i];\\n            } else {\\n                return true;\\n            }\\n        }\\n    }\\nreturn false;\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Efficient solution - > Python\\n\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        a = set(nums)\\n        if len(nums)==len(a):\\n            return False\\n        return True"
                    },
                    {
                        "username": "alokdangwal",
                        "content": "Here You can use an array sort method to reduce the time and space complexity."
                    },
                    {
                        "username": "slylizard",
                        "content": "why does `(len(nums) > len(set(nums)))` have a better runtime than `len(set(nums))!=len(nums)` ?"
                    }
                ]
            },
            {
                "id": 1940004,
                "content": [
                    {
                        "username": "selintopcu",
                        "content": "https://github.com/selindayioglu/Java-LeetCode/blob/main/contains-duplicate.java"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "cant we just apply Boyer-Moore Voting Algorithm"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "No, it is for finding item that occur more than $n/2$ times."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, it can be solved faster than $O(n)$, in just $O(n^{2/3})$ time!\\nOnly need a [quantum computer](https://en.wikipedia.org/wiki/Element_distinctness_problem#Quantum_complexity) for that\\u2026"
                    },
                    {
                        "username": "jchowdyna",
                        "content": "Can someone explain why this doesn\\'t work? Thanks!\\n\\n```\\nvar containsDuplicate = function(nums) {\\n    const set = new Set(nums);\\n    return Array.from(set) === nums ? false : true;\\n};\\n```\\n"
                    },
                    {
                        "username": "contactabbasali21",
                        "content": "Guys, want your opinion on this solution, how can i improve it? \\nThe time complexity is 82ms\\n\\n ```\\n    var containsDuplicate = function(nums) \\n\\t{ \\n\\t\\tconst n = nums.length; \\n\\t\\tlet hasDuplicates = false; \\n\\t\\t\\tfor(i=0;i<n;i++)\\n\\t\\t\\t{ \\n\\t\\t\\t\\tlet j = i + 1; \\n\\t\\t\\t\\tif( j >= n){ j = 0; } \\n\\t\\t\\t\\tif(nums[i] === nums[j])\\n\\t\\t\\t\\t{ \\n\\t\\t\\t\\t hasDuplicates = true; \\n\\t\\t\\t\\t break; \\n\\t\\t\\t\\t} \\n\\t\\t\\tif( j === 0){ break } \\n\\t\\t\\t\\n\\t\\t\\t }\\n\\t\\t\\t\\n\\t\\t\\treturn hasDuplicates \\n\\t\\t\\t\\n\\t};\\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code currently checks if an element is the same as the next element in the array, which won\\'t correctly determine if the array contains duplicates unless they\\'re adjacent in the array.\\n\\nMoreover, your solution runs in O(n^2) time because for every element in the array, it compares it to every other element in the array. For large inputs, this could be very inefficient.\\n\\nHere is an improved version of your function using a JavaScript Set. A Set in JavaScript is similar to a Set in mathematics. It is a collection of unique elements. The advantage of using a Set over an Array is that searching for an element in a Set is O(1), whereas, in an Array, it is O(n).\\n\\n```javascript\\nvar containsDuplicate = function(nums) {\\n    const uniqueNums = new Set();\\n\\n    for(let i = 0; i < nums.length; i++) {\\n        if (uniqueNums.has(nums[i])) {\\n            return true;\\n        }\\n        uniqueNums.add(nums[i]);\\n    }\\n\\n    return false;\\n};\\n```\\n\\nIn this function, we create a Set `uniqueNums`. For each number in `nums`, we check if it\\'s already in `uniqueNums`. If it is, we immediately return `true` because we\\'ve found a duplicate. If it\\'s not, we add it to `uniqueNums`. If we make it through the entire array without finding a duplicate, we return `false`.\\n\\nThis function runs in O(n) time, which is more efficient than the original version. The reason it\\'s more efficient is that both inserting an element into a Set and checking if a Set contains an element are O(1) operations. So we perform 2n O(1) operations, which makes the total time complexity O(n)."
                    },
                    {
                        "username": "bhanujrocks",
                        "content": "I used pre computation, but I am getting one test case wrong when I run the same code in GDB compiler its giving the correct ans \\n\\nconst int N = 1e5 + 10;\\nint hsh[N];\\nclass Solution {\\npublic:\\nbool containsDuplicate(vector<int>& nums) {\\n       for(auto num:nums){\\n           hsh[num]=hsh[num]+1;\\n       }\\n      for(long long int i=0;i<N;i++){\\n          if(hsh[i]>1){\\n              return 1;\\n              }}\\n      return 0;}\\n};.\\n\\n\\nIs it because the global array is not initialized by zero in this environment or something"
                    },
                    {
                        "username": "FreshWanderer",
                        "content": "I\\'m using C and my code doesn\\'t work in TestCase 2. I\\'m trying to use a Hashset to complete this.\\n\\n ```bool containsDuplicate(int* nums, int numsSize){\\nint hash[numsSize];\\nfor(int i = 0; i < numsSize; i++){\\n        hash[i] = 0;\\n    }\\n    for(int i = 0; i < numsSize; i++){\\n        for(int j = 0; j < numsSize; j++){\\n            if(nums[i] != hash[j]) {\\n                hash[i] = nums[i];\\n            } else {\\n                return true;\\n            }\\n        }\\n    }\\nreturn false;\\n}\\n```\\n\\n"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "Efficient solution - > Python\\n\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        a = set(nums)\\n        if len(nums)==len(a):\\n            return False\\n        return True"
                    },
                    {
                        "username": "alokdangwal",
                        "content": "Here You can use an array sort method to reduce the time and space complexity."
                    },
                    {
                        "username": "slylizard",
                        "content": "why does `(len(nums) > len(set(nums)))` have a better runtime than `len(set(nums))!=len(nums)` ?"
                    }
                ]
            },
            {
                "id": 1937679,
                "content": [
                    {
                        "username": "JekoAZE",
                        "content": "Guys what does it mean \"Time Limit Exceeded\"  ?"
                    },
                    {
                        "username": "srushtiii",
                        "content": "It means that something in your code is taking more time.\\nlike you have a while loop and you forgot to increment/decrement the counter so it\\'ll be executed infinite time and will give you TLE. "
                    },
                    {
                        "username": "tanasedaniel54",
                        "content": "I don\\'t think there is a possible solution using only C programming (no sets, no vectors, just C).\\nIf somebody find a solution, please let me know, thanks! \\uD83D\\uDE01"
                    },
                    {
                        "username": "bellaeheh",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       List listy = Arrays.asList(nums);\\n       List listx = new ArrayList();\\n       for (Object i: listy) {\\n           if (!listx.contains(i)) {\\n               listx.add(i);\\n            }\\n       }\\n       return !(listy.size() == listx.size());\\n           \\n       \\n    }\\n}\\n\\nCan i ask why this doesnt work"
                    },
                    {
                        "username": "bparanj",
                        "content": "In your code, you\\'re using the `Arrays.asList` function to convert an array to a list. However, this method does not work as expected with an array of primitives like `int[]`. \\n\\nJava treats each primitive array as a single object, so `Arrays.asList(nums)` doesn\\'t create a list of integers but a list containing a single object, which is the array itself. So, `listy.size()` is always `1`, not the length of the `nums` array.\\n\\nTo fix this, you need to change your array of primitives (`int[]`) to an array of objects (`Integer[]`). Then, `Arrays.asList()` will work as you expect:\\n\\n```java\\nclass Solution {\\n    public boolean containsDuplicate(Integer[] nums) {\\n        List<Integer> listy = Arrays.asList(nums);\\n        Set<Integer> setx = new HashSet<>(listy);\\n        \\n        return !(listy.size() == setx.size());\\n    }\\n}\\n```\\n\\nAlso, I changed `listx` to a `Set`, because `set.add(i)` and `set.contains(i)` operations are faster (both O(1)) than `list.add(i)` and `list.contains(i)` operations (O(n) in the worst case for `ArrayList`). If you\\'re checking for duplicates, using a `Set` is typically more efficient."
                    },
                    {
                        "username": "sumanthsrungavarapu3",
                        "content": "this is an easy one and there are many ways to do it, I did it by just writing a single line if to return a boolean by comparing length of list and and its set. Interestingly I found online that len function\\'s time complexity is just O(1) because underneath it doesn\\'t call a function and perform some operations. The interpreter maintains length stored for everything and len just fetches it. \\nI am thinking this is the best and efficient possible, although I may not seem to understand what happens by using the set conversion. Anyone knows what process happens underneath set conversion and its time, space complexities, please make it known. and any more efficient way in case mine isn\\'t."
                    },
                    {
                        "username": "santoshmourya",
                        "content": "Hii all this is code with time complexity O(1) and space complexity O(n)\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n       int size1= nums.size();\\n       set<int> s(nums.begin(),nums.end());\\n       int size2= s.size();\\n       if(size1==size2){\\n           return false;\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "naveenkum",
                        "content": "how one can get  dynamic array without using any third variable \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If you want to resize an array dynamically in Python, the preferred way is to use a list. Lists in Python are dynamic arrays and you can add and remove items without using a third variable. Here is an example:\\n\\n```python\\n# Initialize the list (dynamic array)\\nnums = [1, 2, 3, 4, 5]\\n\\n# Add an item to the end\\nnums.append(6)\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5, 6]\\n\\n# Remove the last item\\nnums.pop()\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5]\\n```\\n\\nAs you can see, the list `nums` is resized without the need for a third variable. The `append` method adds an item to the end, and the `pop` method removes the last item.\\n\\nHowever, if you\\'re working with a language that doesn\\'t have built-in support for dynamic arrays (like C or C++), resizing an array without a temporary variable could be more challenging. You would generally need to use a function provided by the language\\'s standard library (like `realloc` in C) to resize the array, and this can involve creating a new block of memory, copying the elements over, and then freeing the old block of memory."
                    },
                    {
                        "username": "megadriive",
                        "content": "bru why aren\\'t my for loops working"
                    },
                    {
                        "username": "Aparna_Rengamani",
                        "content": "why is it showing like \"Time limit exceeded\"? I\\'ve used just one for loop"
                    },
                    {
                        "username": "dactung93",
                        "content": "I use 2 methods but I can say it is quite similar\\n\\n1, \\n- Sort Array in Ascending order\\n- Loop from 0 to nums length - 1\\n + Compare array a[i] and a[1+1]\\n + If they are equal then return true\\n + When finish the loop, return False\\n\\n2,\\n- Using HashSet Unique\\n- Loop i from begining to the end\\n + If Unique containt a[i] then return True\\n + Otherwise, Unique.add a[i]\\n- Finish Loop then return False\\n\\nMethod 1: Memory Optimized\\nMethod 2: Runtime Optimized\\n\\nHow can I balance both?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Balancing runtime and memory optimization often depends on the specific needs of the program or the system it\\'s running on. However, here are some general ways you might find a balance between the two methods you mentioned for this problem:\\n\\n1. **Runtime and Memory Tradeoff:** As you have noticed, the first method (sorting the array and checking for duplicates) has a time complexity of O(n log n) and a space complexity of O(1), while the second method (using a hashset to check for duplicates) has a time complexity of O(n) and a space complexity of O(n). If you want to find a balance, you might need to be okay with a bit higher time complexity to reduce the space complexity, or vice versa.\\n\\n2. **Customized Data Structures:** In some cases, you might be able to create a customized data structure that is more space efficient than a hashset but still gives you faster lookup times than sorting the array. This could be complex and might not be worth it for a problem like this, but it\\'s an option in some cases.\\n\\n3. **Probabilistic Data Structures:** If an approximate answer is acceptable, you could consider using a probabilistic data structure like a Bloom filter. A Bloom filter can tell you if an element is definitely not in a set or may be in the set. This could potentially reduce your space usage while still giving you fast lookup times.\\n\\nRemember, the right balance between runtime and memory optimization often depends on the specific constraints of your problem and system. What is most important is to understand the tradeoffs you\\'re making and choose the best strategy for your needs."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Best time complexity solution is not correct but accepted  !!!!\n\n                            input    [ 5 , 35 , 5 ] \n\n\nint hash(int key, int inputSize){\n    return abs(key) % inputSize;\n}\n\nbool containsDuplicate(int* nums, int numsSize){\n    int hashTableSize = 2 * numsSize;\n    int *hashTable = (int *) malloc(hashTableSize * sizeof( int ));\n\n    for (int i = 0; i < numsSize; i++) {\n        if (hashTable[hash(nums[i], hashTableSize)] == nums[i]) {\n            return true;\n        } else {\n            hashTable[hash(nums[i], hashTableSize)] = nums[i];\n        }\n    }\n\n    return false;\n}\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is implementing a Hash Table with an open addressing technique, but it lacks collision resolution. Here, we are using an array `hashTable` as the Hash Table and the `hash()` function to calculate the index for each element in `nums`.\\n\\nBut the problem is, the same index can be calculated for different numbers. For example, if `numsSize` is 10, both 5 and 15 will be mapped to the index 5. So if we have a situation where we first insert 15 into the hash table and then we try to insert 5, the code will erroneously think that there\\'s a duplicate even though 5 and 15 are different.\\n\\nTo fix this, you can use chaining (a linked list at each hash table index to handle collisions) or another collision resolution technique such as linear probing, quadratic probing, or double hashing.\\n\\nHowever, note that implementing these strategies in C would require more code and it wouldn\\'t be a constant time solution anymore. It would be average case O(1) (constant time), but worst case could be O(n) (linear time) if all keys collide.\\n\\nMoreover, because your `hashTable` isn\\'t initialized, it contains random values which can lead to false positives when checking for duplicates.\\n"
                    }
                ]
            },
            {
                "id": 1933655,
                "content": [
                    {
                        "username": "JekoAZE",
                        "content": "Guys what does it mean \"Time Limit Exceeded\"  ?"
                    },
                    {
                        "username": "srushtiii",
                        "content": "It means that something in your code is taking more time.\\nlike you have a while loop and you forgot to increment/decrement the counter so it\\'ll be executed infinite time and will give you TLE. "
                    },
                    {
                        "username": "tanasedaniel54",
                        "content": "I don\\'t think there is a possible solution using only C programming (no sets, no vectors, just C).\\nIf somebody find a solution, please let me know, thanks! \\uD83D\\uDE01"
                    },
                    {
                        "username": "bellaeheh",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       List listy = Arrays.asList(nums);\\n       List listx = new ArrayList();\\n       for (Object i: listy) {\\n           if (!listx.contains(i)) {\\n               listx.add(i);\\n            }\\n       }\\n       return !(listy.size() == listx.size());\\n           \\n       \\n    }\\n}\\n\\nCan i ask why this doesnt work"
                    },
                    {
                        "username": "bparanj",
                        "content": "In your code, you\\'re using the `Arrays.asList` function to convert an array to a list. However, this method does not work as expected with an array of primitives like `int[]`. \\n\\nJava treats each primitive array as a single object, so `Arrays.asList(nums)` doesn\\'t create a list of integers but a list containing a single object, which is the array itself. So, `listy.size()` is always `1`, not the length of the `nums` array.\\n\\nTo fix this, you need to change your array of primitives (`int[]`) to an array of objects (`Integer[]`). Then, `Arrays.asList()` will work as you expect:\\n\\n```java\\nclass Solution {\\n    public boolean containsDuplicate(Integer[] nums) {\\n        List<Integer> listy = Arrays.asList(nums);\\n        Set<Integer> setx = new HashSet<>(listy);\\n        \\n        return !(listy.size() == setx.size());\\n    }\\n}\\n```\\n\\nAlso, I changed `listx` to a `Set`, because `set.add(i)` and `set.contains(i)` operations are faster (both O(1)) than `list.add(i)` and `list.contains(i)` operations (O(n) in the worst case for `ArrayList`). If you\\'re checking for duplicates, using a `Set` is typically more efficient."
                    },
                    {
                        "username": "sumanthsrungavarapu3",
                        "content": "this is an easy one and there are many ways to do it, I did it by just writing a single line if to return a boolean by comparing length of list and and its set. Interestingly I found online that len function\\'s time complexity is just O(1) because underneath it doesn\\'t call a function and perform some operations. The interpreter maintains length stored for everything and len just fetches it. \\nI am thinking this is the best and efficient possible, although I may not seem to understand what happens by using the set conversion. Anyone knows what process happens underneath set conversion and its time, space complexities, please make it known. and any more efficient way in case mine isn\\'t."
                    },
                    {
                        "username": "santoshmourya",
                        "content": "Hii all this is code with time complexity O(1) and space complexity O(n)\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n       int size1= nums.size();\\n       set<int> s(nums.begin(),nums.end());\\n       int size2= s.size();\\n       if(size1==size2){\\n           return false;\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "naveenkum",
                        "content": "how one can get  dynamic array without using any third variable \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If you want to resize an array dynamically in Python, the preferred way is to use a list. Lists in Python are dynamic arrays and you can add and remove items without using a third variable. Here is an example:\\n\\n```python\\n# Initialize the list (dynamic array)\\nnums = [1, 2, 3, 4, 5]\\n\\n# Add an item to the end\\nnums.append(6)\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5, 6]\\n\\n# Remove the last item\\nnums.pop()\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5]\\n```\\n\\nAs you can see, the list `nums` is resized without the need for a third variable. The `append` method adds an item to the end, and the `pop` method removes the last item.\\n\\nHowever, if you\\'re working with a language that doesn\\'t have built-in support for dynamic arrays (like C or C++), resizing an array without a temporary variable could be more challenging. You would generally need to use a function provided by the language\\'s standard library (like `realloc` in C) to resize the array, and this can involve creating a new block of memory, copying the elements over, and then freeing the old block of memory."
                    },
                    {
                        "username": "megadriive",
                        "content": "bru why aren\\'t my for loops working"
                    },
                    {
                        "username": "Aparna_Rengamani",
                        "content": "why is it showing like \"Time limit exceeded\"? I\\'ve used just one for loop"
                    },
                    {
                        "username": "dactung93",
                        "content": "I use 2 methods but I can say it is quite similar\\n\\n1, \\n- Sort Array in Ascending order\\n- Loop from 0 to nums length - 1\\n + Compare array a[i] and a[1+1]\\n + If they are equal then return true\\n + When finish the loop, return False\\n\\n2,\\n- Using HashSet Unique\\n- Loop i from begining to the end\\n + If Unique containt a[i] then return True\\n + Otherwise, Unique.add a[i]\\n- Finish Loop then return False\\n\\nMethod 1: Memory Optimized\\nMethod 2: Runtime Optimized\\n\\nHow can I balance both?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Balancing runtime and memory optimization often depends on the specific needs of the program or the system it\\'s running on. However, here are some general ways you might find a balance between the two methods you mentioned for this problem:\\n\\n1. **Runtime and Memory Tradeoff:** As you have noticed, the first method (sorting the array and checking for duplicates) has a time complexity of O(n log n) and a space complexity of O(1), while the second method (using a hashset to check for duplicates) has a time complexity of O(n) and a space complexity of O(n). If you want to find a balance, you might need to be okay with a bit higher time complexity to reduce the space complexity, or vice versa.\\n\\n2. **Customized Data Structures:** In some cases, you might be able to create a customized data structure that is more space efficient than a hashset but still gives you faster lookup times than sorting the array. This could be complex and might not be worth it for a problem like this, but it\\'s an option in some cases.\\n\\n3. **Probabilistic Data Structures:** If an approximate answer is acceptable, you could consider using a probabilistic data structure like a Bloom filter. A Bloom filter can tell you if an element is definitely not in a set or may be in the set. This could potentially reduce your space usage while still giving you fast lookup times.\\n\\nRemember, the right balance between runtime and memory optimization often depends on the specific constraints of your problem and system. What is most important is to understand the tradeoffs you\\'re making and choose the best strategy for your needs."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Best time complexity solution is not correct but accepted  !!!!\n\n                            input    [ 5 , 35 , 5 ] \n\n\nint hash(int key, int inputSize){\n    return abs(key) % inputSize;\n}\n\nbool containsDuplicate(int* nums, int numsSize){\n    int hashTableSize = 2 * numsSize;\n    int *hashTable = (int *) malloc(hashTableSize * sizeof( int ));\n\n    for (int i = 0; i < numsSize; i++) {\n        if (hashTable[hash(nums[i], hashTableSize)] == nums[i]) {\n            return true;\n        } else {\n            hashTable[hash(nums[i], hashTableSize)] = nums[i];\n        }\n    }\n\n    return false;\n}\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is implementing a Hash Table with an open addressing technique, but it lacks collision resolution. Here, we are using an array `hashTable` as the Hash Table and the `hash()` function to calculate the index for each element in `nums`.\\n\\nBut the problem is, the same index can be calculated for different numbers. For example, if `numsSize` is 10, both 5 and 15 will be mapped to the index 5. So if we have a situation where we first insert 15 into the hash table and then we try to insert 5, the code will erroneously think that there\\'s a duplicate even though 5 and 15 are different.\\n\\nTo fix this, you can use chaining (a linked list at each hash table index to handle collisions) or another collision resolution technique such as linear probing, quadratic probing, or double hashing.\\n\\nHowever, note that implementing these strategies in C would require more code and it wouldn\\'t be a constant time solution anymore. It would be average case O(1) (constant time), but worst case could be O(n) (linear time) if all keys collide.\\n\\nMoreover, because your `hashTable` isn\\'t initialized, it contains random values which can lead to false positives when checking for duplicates.\\n"
                    }
                ]
            },
            {
                "id": 1926404,
                "content": [
                    {
                        "username": "JekoAZE",
                        "content": "Guys what does it mean \"Time Limit Exceeded\"  ?"
                    },
                    {
                        "username": "srushtiii",
                        "content": "It means that something in your code is taking more time.\\nlike you have a while loop and you forgot to increment/decrement the counter so it\\'ll be executed infinite time and will give you TLE. "
                    },
                    {
                        "username": "tanasedaniel54",
                        "content": "I don\\'t think there is a possible solution using only C programming (no sets, no vectors, just C).\\nIf somebody find a solution, please let me know, thanks! \\uD83D\\uDE01"
                    },
                    {
                        "username": "bellaeheh",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       List listy = Arrays.asList(nums);\\n       List listx = new ArrayList();\\n       for (Object i: listy) {\\n           if (!listx.contains(i)) {\\n               listx.add(i);\\n            }\\n       }\\n       return !(listy.size() == listx.size());\\n           \\n       \\n    }\\n}\\n\\nCan i ask why this doesnt work"
                    },
                    {
                        "username": "bparanj",
                        "content": "In your code, you\\'re using the `Arrays.asList` function to convert an array to a list. However, this method does not work as expected with an array of primitives like `int[]`. \\n\\nJava treats each primitive array as a single object, so `Arrays.asList(nums)` doesn\\'t create a list of integers but a list containing a single object, which is the array itself. So, `listy.size()` is always `1`, not the length of the `nums` array.\\n\\nTo fix this, you need to change your array of primitives (`int[]`) to an array of objects (`Integer[]`). Then, `Arrays.asList()` will work as you expect:\\n\\n```java\\nclass Solution {\\n    public boolean containsDuplicate(Integer[] nums) {\\n        List<Integer> listy = Arrays.asList(nums);\\n        Set<Integer> setx = new HashSet<>(listy);\\n        \\n        return !(listy.size() == setx.size());\\n    }\\n}\\n```\\n\\nAlso, I changed `listx` to a `Set`, because `set.add(i)` and `set.contains(i)` operations are faster (both O(1)) than `list.add(i)` and `list.contains(i)` operations (O(n) in the worst case for `ArrayList`). If you\\'re checking for duplicates, using a `Set` is typically more efficient."
                    },
                    {
                        "username": "sumanthsrungavarapu3",
                        "content": "this is an easy one and there are many ways to do it, I did it by just writing a single line if to return a boolean by comparing length of list and and its set. Interestingly I found online that len function\\'s time complexity is just O(1) because underneath it doesn\\'t call a function and perform some operations. The interpreter maintains length stored for everything and len just fetches it. \\nI am thinking this is the best and efficient possible, although I may not seem to understand what happens by using the set conversion. Anyone knows what process happens underneath set conversion and its time, space complexities, please make it known. and any more efficient way in case mine isn\\'t."
                    },
                    {
                        "username": "santoshmourya",
                        "content": "Hii all this is code with time complexity O(1) and space complexity O(n)\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n       int size1= nums.size();\\n       set<int> s(nums.begin(),nums.end());\\n       int size2= s.size();\\n       if(size1==size2){\\n           return false;\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "naveenkum",
                        "content": "how one can get  dynamic array without using any third variable \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If you want to resize an array dynamically in Python, the preferred way is to use a list. Lists in Python are dynamic arrays and you can add and remove items without using a third variable. Here is an example:\\n\\n```python\\n# Initialize the list (dynamic array)\\nnums = [1, 2, 3, 4, 5]\\n\\n# Add an item to the end\\nnums.append(6)\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5, 6]\\n\\n# Remove the last item\\nnums.pop()\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5]\\n```\\n\\nAs you can see, the list `nums` is resized without the need for a third variable. The `append` method adds an item to the end, and the `pop` method removes the last item.\\n\\nHowever, if you\\'re working with a language that doesn\\'t have built-in support for dynamic arrays (like C or C++), resizing an array without a temporary variable could be more challenging. You would generally need to use a function provided by the language\\'s standard library (like `realloc` in C) to resize the array, and this can involve creating a new block of memory, copying the elements over, and then freeing the old block of memory."
                    },
                    {
                        "username": "megadriive",
                        "content": "bru why aren\\'t my for loops working"
                    },
                    {
                        "username": "Aparna_Rengamani",
                        "content": "why is it showing like \"Time limit exceeded\"? I\\'ve used just one for loop"
                    },
                    {
                        "username": "dactung93",
                        "content": "I use 2 methods but I can say it is quite similar\\n\\n1, \\n- Sort Array in Ascending order\\n- Loop from 0 to nums length - 1\\n + Compare array a[i] and a[1+1]\\n + If they are equal then return true\\n + When finish the loop, return False\\n\\n2,\\n- Using HashSet Unique\\n- Loop i from begining to the end\\n + If Unique containt a[i] then return True\\n + Otherwise, Unique.add a[i]\\n- Finish Loop then return False\\n\\nMethod 1: Memory Optimized\\nMethod 2: Runtime Optimized\\n\\nHow can I balance both?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Balancing runtime and memory optimization often depends on the specific needs of the program or the system it\\'s running on. However, here are some general ways you might find a balance between the two methods you mentioned for this problem:\\n\\n1. **Runtime and Memory Tradeoff:** As you have noticed, the first method (sorting the array and checking for duplicates) has a time complexity of O(n log n) and a space complexity of O(1), while the second method (using a hashset to check for duplicates) has a time complexity of O(n) and a space complexity of O(n). If you want to find a balance, you might need to be okay with a bit higher time complexity to reduce the space complexity, or vice versa.\\n\\n2. **Customized Data Structures:** In some cases, you might be able to create a customized data structure that is more space efficient than a hashset but still gives you faster lookup times than sorting the array. This could be complex and might not be worth it for a problem like this, but it\\'s an option in some cases.\\n\\n3. **Probabilistic Data Structures:** If an approximate answer is acceptable, you could consider using a probabilistic data structure like a Bloom filter. A Bloom filter can tell you if an element is definitely not in a set or may be in the set. This could potentially reduce your space usage while still giving you fast lookup times.\\n\\nRemember, the right balance between runtime and memory optimization often depends on the specific constraints of your problem and system. What is most important is to understand the tradeoffs you\\'re making and choose the best strategy for your needs."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Best time complexity solution is not correct but accepted  !!!!\n\n                            input    [ 5 , 35 , 5 ] \n\n\nint hash(int key, int inputSize){\n    return abs(key) % inputSize;\n}\n\nbool containsDuplicate(int* nums, int numsSize){\n    int hashTableSize = 2 * numsSize;\n    int *hashTable = (int *) malloc(hashTableSize * sizeof( int ));\n\n    for (int i = 0; i < numsSize; i++) {\n        if (hashTable[hash(nums[i], hashTableSize)] == nums[i]) {\n            return true;\n        } else {\n            hashTable[hash(nums[i], hashTableSize)] = nums[i];\n        }\n    }\n\n    return false;\n}\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is implementing a Hash Table with an open addressing technique, but it lacks collision resolution. Here, we are using an array `hashTable` as the Hash Table and the `hash()` function to calculate the index for each element in `nums`.\\n\\nBut the problem is, the same index can be calculated for different numbers. For example, if `numsSize` is 10, both 5 and 15 will be mapped to the index 5. So if we have a situation where we first insert 15 into the hash table and then we try to insert 5, the code will erroneously think that there\\'s a duplicate even though 5 and 15 are different.\\n\\nTo fix this, you can use chaining (a linked list at each hash table index to handle collisions) or another collision resolution technique such as linear probing, quadratic probing, or double hashing.\\n\\nHowever, note that implementing these strategies in C would require more code and it wouldn\\'t be a constant time solution anymore. It would be average case O(1) (constant time), but worst case could be O(n) (linear time) if all keys collide.\\n\\nMoreover, because your `hashTable` isn\\'t initialized, it contains random values which can lead to false positives when checking for duplicates.\\n"
                    }
                ]
            },
            {
                "id": 1925769,
                "content": [
                    {
                        "username": "JekoAZE",
                        "content": "Guys what does it mean \"Time Limit Exceeded\"  ?"
                    },
                    {
                        "username": "srushtiii",
                        "content": "It means that something in your code is taking more time.\\nlike you have a while loop and you forgot to increment/decrement the counter so it\\'ll be executed infinite time and will give you TLE. "
                    },
                    {
                        "username": "tanasedaniel54",
                        "content": "I don\\'t think there is a possible solution using only C programming (no sets, no vectors, just C).\\nIf somebody find a solution, please let me know, thanks! \\uD83D\\uDE01"
                    },
                    {
                        "username": "bellaeheh",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       List listy = Arrays.asList(nums);\\n       List listx = new ArrayList();\\n       for (Object i: listy) {\\n           if (!listx.contains(i)) {\\n               listx.add(i);\\n            }\\n       }\\n       return !(listy.size() == listx.size());\\n           \\n       \\n    }\\n}\\n\\nCan i ask why this doesnt work"
                    },
                    {
                        "username": "bparanj",
                        "content": "In your code, you\\'re using the `Arrays.asList` function to convert an array to a list. However, this method does not work as expected with an array of primitives like `int[]`. \\n\\nJava treats each primitive array as a single object, so `Arrays.asList(nums)` doesn\\'t create a list of integers but a list containing a single object, which is the array itself. So, `listy.size()` is always `1`, not the length of the `nums` array.\\n\\nTo fix this, you need to change your array of primitives (`int[]`) to an array of objects (`Integer[]`). Then, `Arrays.asList()` will work as you expect:\\n\\n```java\\nclass Solution {\\n    public boolean containsDuplicate(Integer[] nums) {\\n        List<Integer> listy = Arrays.asList(nums);\\n        Set<Integer> setx = new HashSet<>(listy);\\n        \\n        return !(listy.size() == setx.size());\\n    }\\n}\\n```\\n\\nAlso, I changed `listx` to a `Set`, because `set.add(i)` and `set.contains(i)` operations are faster (both O(1)) than `list.add(i)` and `list.contains(i)` operations (O(n) in the worst case for `ArrayList`). If you\\'re checking for duplicates, using a `Set` is typically more efficient."
                    },
                    {
                        "username": "sumanthsrungavarapu3",
                        "content": "this is an easy one and there are many ways to do it, I did it by just writing a single line if to return a boolean by comparing length of list and and its set. Interestingly I found online that len function\\'s time complexity is just O(1) because underneath it doesn\\'t call a function and perform some operations. The interpreter maintains length stored for everything and len just fetches it. \\nI am thinking this is the best and efficient possible, although I may not seem to understand what happens by using the set conversion. Anyone knows what process happens underneath set conversion and its time, space complexities, please make it known. and any more efficient way in case mine isn\\'t."
                    },
                    {
                        "username": "santoshmourya",
                        "content": "Hii all this is code with time complexity O(1) and space complexity O(n)\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n       int size1= nums.size();\\n       set<int> s(nums.begin(),nums.end());\\n       int size2= s.size();\\n       if(size1==size2){\\n           return false;\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "naveenkum",
                        "content": "how one can get  dynamic array without using any third variable \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If you want to resize an array dynamically in Python, the preferred way is to use a list. Lists in Python are dynamic arrays and you can add and remove items without using a third variable. Here is an example:\\n\\n```python\\n# Initialize the list (dynamic array)\\nnums = [1, 2, 3, 4, 5]\\n\\n# Add an item to the end\\nnums.append(6)\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5, 6]\\n\\n# Remove the last item\\nnums.pop()\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5]\\n```\\n\\nAs you can see, the list `nums` is resized without the need for a third variable. The `append` method adds an item to the end, and the `pop` method removes the last item.\\n\\nHowever, if you\\'re working with a language that doesn\\'t have built-in support for dynamic arrays (like C or C++), resizing an array without a temporary variable could be more challenging. You would generally need to use a function provided by the language\\'s standard library (like `realloc` in C) to resize the array, and this can involve creating a new block of memory, copying the elements over, and then freeing the old block of memory."
                    },
                    {
                        "username": "megadriive",
                        "content": "bru why aren\\'t my for loops working"
                    },
                    {
                        "username": "Aparna_Rengamani",
                        "content": "why is it showing like \"Time limit exceeded\"? I\\'ve used just one for loop"
                    },
                    {
                        "username": "dactung93",
                        "content": "I use 2 methods but I can say it is quite similar\\n\\n1, \\n- Sort Array in Ascending order\\n- Loop from 0 to nums length - 1\\n + Compare array a[i] and a[1+1]\\n + If they are equal then return true\\n + When finish the loop, return False\\n\\n2,\\n- Using HashSet Unique\\n- Loop i from begining to the end\\n + If Unique containt a[i] then return True\\n + Otherwise, Unique.add a[i]\\n- Finish Loop then return False\\n\\nMethod 1: Memory Optimized\\nMethod 2: Runtime Optimized\\n\\nHow can I balance both?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Balancing runtime and memory optimization often depends on the specific needs of the program or the system it\\'s running on. However, here are some general ways you might find a balance between the two methods you mentioned for this problem:\\n\\n1. **Runtime and Memory Tradeoff:** As you have noticed, the first method (sorting the array and checking for duplicates) has a time complexity of O(n log n) and a space complexity of O(1), while the second method (using a hashset to check for duplicates) has a time complexity of O(n) and a space complexity of O(n). If you want to find a balance, you might need to be okay with a bit higher time complexity to reduce the space complexity, or vice versa.\\n\\n2. **Customized Data Structures:** In some cases, you might be able to create a customized data structure that is more space efficient than a hashset but still gives you faster lookup times than sorting the array. This could be complex and might not be worth it for a problem like this, but it\\'s an option in some cases.\\n\\n3. **Probabilistic Data Structures:** If an approximate answer is acceptable, you could consider using a probabilistic data structure like a Bloom filter. A Bloom filter can tell you if an element is definitely not in a set or may be in the set. This could potentially reduce your space usage while still giving you fast lookup times.\\n\\nRemember, the right balance between runtime and memory optimization often depends on the specific constraints of your problem and system. What is most important is to understand the tradeoffs you\\'re making and choose the best strategy for your needs."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Best time complexity solution is not correct but accepted  !!!!\n\n                            input    [ 5 , 35 , 5 ] \n\n\nint hash(int key, int inputSize){\n    return abs(key) % inputSize;\n}\n\nbool containsDuplicate(int* nums, int numsSize){\n    int hashTableSize = 2 * numsSize;\n    int *hashTable = (int *) malloc(hashTableSize * sizeof( int ));\n\n    for (int i = 0; i < numsSize; i++) {\n        if (hashTable[hash(nums[i], hashTableSize)] == nums[i]) {\n            return true;\n        } else {\n            hashTable[hash(nums[i], hashTableSize)] = nums[i];\n        }\n    }\n\n    return false;\n}\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is implementing a Hash Table with an open addressing technique, but it lacks collision resolution. Here, we are using an array `hashTable` as the Hash Table and the `hash()` function to calculate the index for each element in `nums`.\\n\\nBut the problem is, the same index can be calculated for different numbers. For example, if `numsSize` is 10, both 5 and 15 will be mapped to the index 5. So if we have a situation where we first insert 15 into the hash table and then we try to insert 5, the code will erroneously think that there\\'s a duplicate even though 5 and 15 are different.\\n\\nTo fix this, you can use chaining (a linked list at each hash table index to handle collisions) or another collision resolution technique such as linear probing, quadratic probing, or double hashing.\\n\\nHowever, note that implementing these strategies in C would require more code and it wouldn\\'t be a constant time solution anymore. It would be average case O(1) (constant time), but worst case could be O(n) (linear time) if all keys collide.\\n\\nMoreover, because your `hashTable` isn\\'t initialized, it contains random values which can lead to false positives when checking for duplicates.\\n"
                    }
                ]
            },
            {
                "id": 1925532,
                "content": [
                    {
                        "username": "JekoAZE",
                        "content": "Guys what does it mean \"Time Limit Exceeded\"  ?"
                    },
                    {
                        "username": "srushtiii",
                        "content": "It means that something in your code is taking more time.\\nlike you have a while loop and you forgot to increment/decrement the counter so it\\'ll be executed infinite time and will give you TLE. "
                    },
                    {
                        "username": "tanasedaniel54",
                        "content": "I don\\'t think there is a possible solution using only C programming (no sets, no vectors, just C).\\nIf somebody find a solution, please let me know, thanks! \\uD83D\\uDE01"
                    },
                    {
                        "username": "bellaeheh",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       List listy = Arrays.asList(nums);\\n       List listx = new ArrayList();\\n       for (Object i: listy) {\\n           if (!listx.contains(i)) {\\n               listx.add(i);\\n            }\\n       }\\n       return !(listy.size() == listx.size());\\n           \\n       \\n    }\\n}\\n\\nCan i ask why this doesnt work"
                    },
                    {
                        "username": "bparanj",
                        "content": "In your code, you\\'re using the `Arrays.asList` function to convert an array to a list. However, this method does not work as expected with an array of primitives like `int[]`. \\n\\nJava treats each primitive array as a single object, so `Arrays.asList(nums)` doesn\\'t create a list of integers but a list containing a single object, which is the array itself. So, `listy.size()` is always `1`, not the length of the `nums` array.\\n\\nTo fix this, you need to change your array of primitives (`int[]`) to an array of objects (`Integer[]`). Then, `Arrays.asList()` will work as you expect:\\n\\n```java\\nclass Solution {\\n    public boolean containsDuplicate(Integer[] nums) {\\n        List<Integer> listy = Arrays.asList(nums);\\n        Set<Integer> setx = new HashSet<>(listy);\\n        \\n        return !(listy.size() == setx.size());\\n    }\\n}\\n```\\n\\nAlso, I changed `listx` to a `Set`, because `set.add(i)` and `set.contains(i)` operations are faster (both O(1)) than `list.add(i)` and `list.contains(i)` operations (O(n) in the worst case for `ArrayList`). If you\\'re checking for duplicates, using a `Set` is typically more efficient."
                    },
                    {
                        "username": "sumanthsrungavarapu3",
                        "content": "this is an easy one and there are many ways to do it, I did it by just writing a single line if to return a boolean by comparing length of list and and its set. Interestingly I found online that len function\\'s time complexity is just O(1) because underneath it doesn\\'t call a function and perform some operations. The interpreter maintains length stored for everything and len just fetches it. \\nI am thinking this is the best and efficient possible, although I may not seem to understand what happens by using the set conversion. Anyone knows what process happens underneath set conversion and its time, space complexities, please make it known. and any more efficient way in case mine isn\\'t."
                    },
                    {
                        "username": "santoshmourya",
                        "content": "Hii all this is code with time complexity O(1) and space complexity O(n)\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n       int size1= nums.size();\\n       set<int> s(nums.begin(),nums.end());\\n       int size2= s.size();\\n       if(size1==size2){\\n           return false;\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "naveenkum",
                        "content": "how one can get  dynamic array without using any third variable \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If you want to resize an array dynamically in Python, the preferred way is to use a list. Lists in Python are dynamic arrays and you can add and remove items without using a third variable. Here is an example:\\n\\n```python\\n# Initialize the list (dynamic array)\\nnums = [1, 2, 3, 4, 5]\\n\\n# Add an item to the end\\nnums.append(6)\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5, 6]\\n\\n# Remove the last item\\nnums.pop()\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5]\\n```\\n\\nAs you can see, the list `nums` is resized without the need for a third variable. The `append` method adds an item to the end, and the `pop` method removes the last item.\\n\\nHowever, if you\\'re working with a language that doesn\\'t have built-in support for dynamic arrays (like C or C++), resizing an array without a temporary variable could be more challenging. You would generally need to use a function provided by the language\\'s standard library (like `realloc` in C) to resize the array, and this can involve creating a new block of memory, copying the elements over, and then freeing the old block of memory."
                    },
                    {
                        "username": "megadriive",
                        "content": "bru why aren\\'t my for loops working"
                    },
                    {
                        "username": "Aparna_Rengamani",
                        "content": "why is it showing like \"Time limit exceeded\"? I\\'ve used just one for loop"
                    },
                    {
                        "username": "dactung93",
                        "content": "I use 2 methods but I can say it is quite similar\\n\\n1, \\n- Sort Array in Ascending order\\n- Loop from 0 to nums length - 1\\n + Compare array a[i] and a[1+1]\\n + If they are equal then return true\\n + When finish the loop, return False\\n\\n2,\\n- Using HashSet Unique\\n- Loop i from begining to the end\\n + If Unique containt a[i] then return True\\n + Otherwise, Unique.add a[i]\\n- Finish Loop then return False\\n\\nMethod 1: Memory Optimized\\nMethod 2: Runtime Optimized\\n\\nHow can I balance both?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Balancing runtime and memory optimization often depends on the specific needs of the program or the system it\\'s running on. However, here are some general ways you might find a balance between the two methods you mentioned for this problem:\\n\\n1. **Runtime and Memory Tradeoff:** As you have noticed, the first method (sorting the array and checking for duplicates) has a time complexity of O(n log n) and a space complexity of O(1), while the second method (using a hashset to check for duplicates) has a time complexity of O(n) and a space complexity of O(n). If you want to find a balance, you might need to be okay with a bit higher time complexity to reduce the space complexity, or vice versa.\\n\\n2. **Customized Data Structures:** In some cases, you might be able to create a customized data structure that is more space efficient than a hashset but still gives you faster lookup times than sorting the array. This could be complex and might not be worth it for a problem like this, but it\\'s an option in some cases.\\n\\n3. **Probabilistic Data Structures:** If an approximate answer is acceptable, you could consider using a probabilistic data structure like a Bloom filter. A Bloom filter can tell you if an element is definitely not in a set or may be in the set. This could potentially reduce your space usage while still giving you fast lookup times.\\n\\nRemember, the right balance between runtime and memory optimization often depends on the specific constraints of your problem and system. What is most important is to understand the tradeoffs you\\'re making and choose the best strategy for your needs."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Best time complexity solution is not correct but accepted  !!!!\n\n                            input    [ 5 , 35 , 5 ] \n\n\nint hash(int key, int inputSize){\n    return abs(key) % inputSize;\n}\n\nbool containsDuplicate(int* nums, int numsSize){\n    int hashTableSize = 2 * numsSize;\n    int *hashTable = (int *) malloc(hashTableSize * sizeof( int ));\n\n    for (int i = 0; i < numsSize; i++) {\n        if (hashTable[hash(nums[i], hashTableSize)] == nums[i]) {\n            return true;\n        } else {\n            hashTable[hash(nums[i], hashTableSize)] = nums[i];\n        }\n    }\n\n    return false;\n}\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is implementing a Hash Table with an open addressing technique, but it lacks collision resolution. Here, we are using an array `hashTable` as the Hash Table and the `hash()` function to calculate the index for each element in `nums`.\\n\\nBut the problem is, the same index can be calculated for different numbers. For example, if `numsSize` is 10, both 5 and 15 will be mapped to the index 5. So if we have a situation where we first insert 15 into the hash table and then we try to insert 5, the code will erroneously think that there\\'s a duplicate even though 5 and 15 are different.\\n\\nTo fix this, you can use chaining (a linked list at each hash table index to handle collisions) or another collision resolution technique such as linear probing, quadratic probing, or double hashing.\\n\\nHowever, note that implementing these strategies in C would require more code and it wouldn\\'t be a constant time solution anymore. It would be average case O(1) (constant time), but worst case could be O(n) (linear time) if all keys collide.\\n\\nMoreover, because your `hashTable` isn\\'t initialized, it contains random values which can lead to false positives when checking for duplicates.\\n"
                    }
                ]
            },
            {
                "id": 1918769,
                "content": [
                    {
                        "username": "JekoAZE",
                        "content": "Guys what does it mean \"Time Limit Exceeded\"  ?"
                    },
                    {
                        "username": "srushtiii",
                        "content": "It means that something in your code is taking more time.\\nlike you have a while loop and you forgot to increment/decrement the counter so it\\'ll be executed infinite time and will give you TLE. "
                    },
                    {
                        "username": "tanasedaniel54",
                        "content": "I don\\'t think there is a possible solution using only C programming (no sets, no vectors, just C).\\nIf somebody find a solution, please let me know, thanks! \\uD83D\\uDE01"
                    },
                    {
                        "username": "bellaeheh",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       List listy = Arrays.asList(nums);\\n       List listx = new ArrayList();\\n       for (Object i: listy) {\\n           if (!listx.contains(i)) {\\n               listx.add(i);\\n            }\\n       }\\n       return !(listy.size() == listx.size());\\n           \\n       \\n    }\\n}\\n\\nCan i ask why this doesnt work"
                    },
                    {
                        "username": "bparanj",
                        "content": "In your code, you\\'re using the `Arrays.asList` function to convert an array to a list. However, this method does not work as expected with an array of primitives like `int[]`. \\n\\nJava treats each primitive array as a single object, so `Arrays.asList(nums)` doesn\\'t create a list of integers but a list containing a single object, which is the array itself. So, `listy.size()` is always `1`, not the length of the `nums` array.\\n\\nTo fix this, you need to change your array of primitives (`int[]`) to an array of objects (`Integer[]`). Then, `Arrays.asList()` will work as you expect:\\n\\n```java\\nclass Solution {\\n    public boolean containsDuplicate(Integer[] nums) {\\n        List<Integer> listy = Arrays.asList(nums);\\n        Set<Integer> setx = new HashSet<>(listy);\\n        \\n        return !(listy.size() == setx.size());\\n    }\\n}\\n```\\n\\nAlso, I changed `listx` to a `Set`, because `set.add(i)` and `set.contains(i)` operations are faster (both O(1)) than `list.add(i)` and `list.contains(i)` operations (O(n) in the worst case for `ArrayList`). If you\\'re checking for duplicates, using a `Set` is typically more efficient."
                    },
                    {
                        "username": "sumanthsrungavarapu3",
                        "content": "this is an easy one and there are many ways to do it, I did it by just writing a single line if to return a boolean by comparing length of list and and its set. Interestingly I found online that len function\\'s time complexity is just O(1) because underneath it doesn\\'t call a function and perform some operations. The interpreter maintains length stored for everything and len just fetches it. \\nI am thinking this is the best and efficient possible, although I may not seem to understand what happens by using the set conversion. Anyone knows what process happens underneath set conversion and its time, space complexities, please make it known. and any more efficient way in case mine isn\\'t."
                    },
                    {
                        "username": "santoshmourya",
                        "content": "Hii all this is code with time complexity O(1) and space complexity O(n)\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n       int size1= nums.size();\\n       set<int> s(nums.begin(),nums.end());\\n       int size2= s.size();\\n       if(size1==size2){\\n           return false;\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "naveenkum",
                        "content": "how one can get  dynamic array without using any third variable \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If you want to resize an array dynamically in Python, the preferred way is to use a list. Lists in Python are dynamic arrays and you can add and remove items without using a third variable. Here is an example:\\n\\n```python\\n# Initialize the list (dynamic array)\\nnums = [1, 2, 3, 4, 5]\\n\\n# Add an item to the end\\nnums.append(6)\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5, 6]\\n\\n# Remove the last item\\nnums.pop()\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5]\\n```\\n\\nAs you can see, the list `nums` is resized without the need for a third variable. The `append` method adds an item to the end, and the `pop` method removes the last item.\\n\\nHowever, if you\\'re working with a language that doesn\\'t have built-in support for dynamic arrays (like C or C++), resizing an array without a temporary variable could be more challenging. You would generally need to use a function provided by the language\\'s standard library (like `realloc` in C) to resize the array, and this can involve creating a new block of memory, copying the elements over, and then freeing the old block of memory."
                    },
                    {
                        "username": "megadriive",
                        "content": "bru why aren\\'t my for loops working"
                    },
                    {
                        "username": "Aparna_Rengamani",
                        "content": "why is it showing like \"Time limit exceeded\"? I\\'ve used just one for loop"
                    },
                    {
                        "username": "dactung93",
                        "content": "I use 2 methods but I can say it is quite similar\\n\\n1, \\n- Sort Array in Ascending order\\n- Loop from 0 to nums length - 1\\n + Compare array a[i] and a[1+1]\\n + If they are equal then return true\\n + When finish the loop, return False\\n\\n2,\\n- Using HashSet Unique\\n- Loop i from begining to the end\\n + If Unique containt a[i] then return True\\n + Otherwise, Unique.add a[i]\\n- Finish Loop then return False\\n\\nMethod 1: Memory Optimized\\nMethod 2: Runtime Optimized\\n\\nHow can I balance both?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Balancing runtime and memory optimization often depends on the specific needs of the program or the system it\\'s running on. However, here are some general ways you might find a balance between the two methods you mentioned for this problem:\\n\\n1. **Runtime and Memory Tradeoff:** As you have noticed, the first method (sorting the array and checking for duplicates) has a time complexity of O(n log n) and a space complexity of O(1), while the second method (using a hashset to check for duplicates) has a time complexity of O(n) and a space complexity of O(n). If you want to find a balance, you might need to be okay with a bit higher time complexity to reduce the space complexity, or vice versa.\\n\\n2. **Customized Data Structures:** In some cases, you might be able to create a customized data structure that is more space efficient than a hashset but still gives you faster lookup times than sorting the array. This could be complex and might not be worth it for a problem like this, but it\\'s an option in some cases.\\n\\n3. **Probabilistic Data Structures:** If an approximate answer is acceptable, you could consider using a probabilistic data structure like a Bloom filter. A Bloom filter can tell you if an element is definitely not in a set or may be in the set. This could potentially reduce your space usage while still giving you fast lookup times.\\n\\nRemember, the right balance between runtime and memory optimization often depends on the specific constraints of your problem and system. What is most important is to understand the tradeoffs you\\'re making and choose the best strategy for your needs."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Best time complexity solution is not correct but accepted  !!!!\n\n                            input    [ 5 , 35 , 5 ] \n\n\nint hash(int key, int inputSize){\n    return abs(key) % inputSize;\n}\n\nbool containsDuplicate(int* nums, int numsSize){\n    int hashTableSize = 2 * numsSize;\n    int *hashTable = (int *) malloc(hashTableSize * sizeof( int ));\n\n    for (int i = 0; i < numsSize; i++) {\n        if (hashTable[hash(nums[i], hashTableSize)] == nums[i]) {\n            return true;\n        } else {\n            hashTable[hash(nums[i], hashTableSize)] = nums[i];\n        }\n    }\n\n    return false;\n}\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is implementing a Hash Table with an open addressing technique, but it lacks collision resolution. Here, we are using an array `hashTable` as the Hash Table and the `hash()` function to calculate the index for each element in `nums`.\\n\\nBut the problem is, the same index can be calculated for different numbers. For example, if `numsSize` is 10, both 5 and 15 will be mapped to the index 5. So if we have a situation where we first insert 15 into the hash table and then we try to insert 5, the code will erroneously think that there\\'s a duplicate even though 5 and 15 are different.\\n\\nTo fix this, you can use chaining (a linked list at each hash table index to handle collisions) or another collision resolution technique such as linear probing, quadratic probing, or double hashing.\\n\\nHowever, note that implementing these strategies in C would require more code and it wouldn\\'t be a constant time solution anymore. It would be average case O(1) (constant time), but worst case could be O(n) (linear time) if all keys collide.\\n\\nMoreover, because your `hashTable` isn\\'t initialized, it contains random values which can lead to false positives when checking for duplicates.\\n"
                    }
                ]
            },
            {
                "id": 1918292,
                "content": [
                    {
                        "username": "JekoAZE",
                        "content": "Guys what does it mean \"Time Limit Exceeded\"  ?"
                    },
                    {
                        "username": "srushtiii",
                        "content": "It means that something in your code is taking more time.\\nlike you have a while loop and you forgot to increment/decrement the counter so it\\'ll be executed infinite time and will give you TLE. "
                    },
                    {
                        "username": "tanasedaniel54",
                        "content": "I don\\'t think there is a possible solution using only C programming (no sets, no vectors, just C).\\nIf somebody find a solution, please let me know, thanks! \\uD83D\\uDE01"
                    },
                    {
                        "username": "bellaeheh",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       List listy = Arrays.asList(nums);\\n       List listx = new ArrayList();\\n       for (Object i: listy) {\\n           if (!listx.contains(i)) {\\n               listx.add(i);\\n            }\\n       }\\n       return !(listy.size() == listx.size());\\n           \\n       \\n    }\\n}\\n\\nCan i ask why this doesnt work"
                    },
                    {
                        "username": "bparanj",
                        "content": "In your code, you\\'re using the `Arrays.asList` function to convert an array to a list. However, this method does not work as expected with an array of primitives like `int[]`. \\n\\nJava treats each primitive array as a single object, so `Arrays.asList(nums)` doesn\\'t create a list of integers but a list containing a single object, which is the array itself. So, `listy.size()` is always `1`, not the length of the `nums` array.\\n\\nTo fix this, you need to change your array of primitives (`int[]`) to an array of objects (`Integer[]`). Then, `Arrays.asList()` will work as you expect:\\n\\n```java\\nclass Solution {\\n    public boolean containsDuplicate(Integer[] nums) {\\n        List<Integer> listy = Arrays.asList(nums);\\n        Set<Integer> setx = new HashSet<>(listy);\\n        \\n        return !(listy.size() == setx.size());\\n    }\\n}\\n```\\n\\nAlso, I changed `listx` to a `Set`, because `set.add(i)` and `set.contains(i)` operations are faster (both O(1)) than `list.add(i)` and `list.contains(i)` operations (O(n) in the worst case for `ArrayList`). If you\\'re checking for duplicates, using a `Set` is typically more efficient."
                    },
                    {
                        "username": "sumanthsrungavarapu3",
                        "content": "this is an easy one and there are many ways to do it, I did it by just writing a single line if to return a boolean by comparing length of list and and its set. Interestingly I found online that len function\\'s time complexity is just O(1) because underneath it doesn\\'t call a function and perform some operations. The interpreter maintains length stored for everything and len just fetches it. \\nI am thinking this is the best and efficient possible, although I may not seem to understand what happens by using the set conversion. Anyone knows what process happens underneath set conversion and its time, space complexities, please make it known. and any more efficient way in case mine isn\\'t."
                    },
                    {
                        "username": "santoshmourya",
                        "content": "Hii all this is code with time complexity O(1) and space complexity O(n)\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n       int size1= nums.size();\\n       set<int> s(nums.begin(),nums.end());\\n       int size2= s.size();\\n       if(size1==size2){\\n           return false;\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "naveenkum",
                        "content": "how one can get  dynamic array without using any third variable \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If you want to resize an array dynamically in Python, the preferred way is to use a list. Lists in Python are dynamic arrays and you can add and remove items without using a third variable. Here is an example:\\n\\n```python\\n# Initialize the list (dynamic array)\\nnums = [1, 2, 3, 4, 5]\\n\\n# Add an item to the end\\nnums.append(6)\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5, 6]\\n\\n# Remove the last item\\nnums.pop()\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5]\\n```\\n\\nAs you can see, the list `nums` is resized without the need for a third variable. The `append` method adds an item to the end, and the `pop` method removes the last item.\\n\\nHowever, if you\\'re working with a language that doesn\\'t have built-in support for dynamic arrays (like C or C++), resizing an array without a temporary variable could be more challenging. You would generally need to use a function provided by the language\\'s standard library (like `realloc` in C) to resize the array, and this can involve creating a new block of memory, copying the elements over, and then freeing the old block of memory."
                    },
                    {
                        "username": "megadriive",
                        "content": "bru why aren\\'t my for loops working"
                    },
                    {
                        "username": "Aparna_Rengamani",
                        "content": "why is it showing like \"Time limit exceeded\"? I\\'ve used just one for loop"
                    },
                    {
                        "username": "dactung93",
                        "content": "I use 2 methods but I can say it is quite similar\\n\\n1, \\n- Sort Array in Ascending order\\n- Loop from 0 to nums length - 1\\n + Compare array a[i] and a[1+1]\\n + If they are equal then return true\\n + When finish the loop, return False\\n\\n2,\\n- Using HashSet Unique\\n- Loop i from begining to the end\\n + If Unique containt a[i] then return True\\n + Otherwise, Unique.add a[i]\\n- Finish Loop then return False\\n\\nMethod 1: Memory Optimized\\nMethod 2: Runtime Optimized\\n\\nHow can I balance both?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Balancing runtime and memory optimization often depends on the specific needs of the program or the system it\\'s running on. However, here are some general ways you might find a balance between the two methods you mentioned for this problem:\\n\\n1. **Runtime and Memory Tradeoff:** As you have noticed, the first method (sorting the array and checking for duplicates) has a time complexity of O(n log n) and a space complexity of O(1), while the second method (using a hashset to check for duplicates) has a time complexity of O(n) and a space complexity of O(n). If you want to find a balance, you might need to be okay with a bit higher time complexity to reduce the space complexity, or vice versa.\\n\\n2. **Customized Data Structures:** In some cases, you might be able to create a customized data structure that is more space efficient than a hashset but still gives you faster lookup times than sorting the array. This could be complex and might not be worth it for a problem like this, but it\\'s an option in some cases.\\n\\n3. **Probabilistic Data Structures:** If an approximate answer is acceptable, you could consider using a probabilistic data structure like a Bloom filter. A Bloom filter can tell you if an element is definitely not in a set or may be in the set. This could potentially reduce your space usage while still giving you fast lookup times.\\n\\nRemember, the right balance between runtime and memory optimization often depends on the specific constraints of your problem and system. What is most important is to understand the tradeoffs you\\'re making and choose the best strategy for your needs."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Best time complexity solution is not correct but accepted  !!!!\n\n                            input    [ 5 , 35 , 5 ] \n\n\nint hash(int key, int inputSize){\n    return abs(key) % inputSize;\n}\n\nbool containsDuplicate(int* nums, int numsSize){\n    int hashTableSize = 2 * numsSize;\n    int *hashTable = (int *) malloc(hashTableSize * sizeof( int ));\n\n    for (int i = 0; i < numsSize; i++) {\n        if (hashTable[hash(nums[i], hashTableSize)] == nums[i]) {\n            return true;\n        } else {\n            hashTable[hash(nums[i], hashTableSize)] = nums[i];\n        }\n    }\n\n    return false;\n}\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is implementing a Hash Table with an open addressing technique, but it lacks collision resolution. Here, we are using an array `hashTable` as the Hash Table and the `hash()` function to calculate the index for each element in `nums`.\\n\\nBut the problem is, the same index can be calculated for different numbers. For example, if `numsSize` is 10, both 5 and 15 will be mapped to the index 5. So if we have a situation where we first insert 15 into the hash table and then we try to insert 5, the code will erroneously think that there\\'s a duplicate even though 5 and 15 are different.\\n\\nTo fix this, you can use chaining (a linked list at each hash table index to handle collisions) or another collision resolution technique such as linear probing, quadratic probing, or double hashing.\\n\\nHowever, note that implementing these strategies in C would require more code and it wouldn\\'t be a constant time solution anymore. It would be average case O(1) (constant time), but worst case could be O(n) (linear time) if all keys collide.\\n\\nMoreover, because your `hashTable` isn\\'t initialized, it contains random values which can lead to false positives when checking for duplicates.\\n"
                    }
                ]
            },
            {
                "id": 1917941,
                "content": [
                    {
                        "username": "JekoAZE",
                        "content": "Guys what does it mean \"Time Limit Exceeded\"  ?"
                    },
                    {
                        "username": "srushtiii",
                        "content": "It means that something in your code is taking more time.\\nlike you have a while loop and you forgot to increment/decrement the counter so it\\'ll be executed infinite time and will give you TLE. "
                    },
                    {
                        "username": "tanasedaniel54",
                        "content": "I don\\'t think there is a possible solution using only C programming (no sets, no vectors, just C).\\nIf somebody find a solution, please let me know, thanks! \\uD83D\\uDE01"
                    },
                    {
                        "username": "bellaeheh",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       List listy = Arrays.asList(nums);\\n       List listx = new ArrayList();\\n       for (Object i: listy) {\\n           if (!listx.contains(i)) {\\n               listx.add(i);\\n            }\\n       }\\n       return !(listy.size() == listx.size());\\n           \\n       \\n    }\\n}\\n\\nCan i ask why this doesnt work"
                    },
                    {
                        "username": "bparanj",
                        "content": "In your code, you\\'re using the `Arrays.asList` function to convert an array to a list. However, this method does not work as expected with an array of primitives like `int[]`. \\n\\nJava treats each primitive array as a single object, so `Arrays.asList(nums)` doesn\\'t create a list of integers but a list containing a single object, which is the array itself. So, `listy.size()` is always `1`, not the length of the `nums` array.\\n\\nTo fix this, you need to change your array of primitives (`int[]`) to an array of objects (`Integer[]`). Then, `Arrays.asList()` will work as you expect:\\n\\n```java\\nclass Solution {\\n    public boolean containsDuplicate(Integer[] nums) {\\n        List<Integer> listy = Arrays.asList(nums);\\n        Set<Integer> setx = new HashSet<>(listy);\\n        \\n        return !(listy.size() == setx.size());\\n    }\\n}\\n```\\n\\nAlso, I changed `listx` to a `Set`, because `set.add(i)` and `set.contains(i)` operations are faster (both O(1)) than `list.add(i)` and `list.contains(i)` operations (O(n) in the worst case for `ArrayList`). If you\\'re checking for duplicates, using a `Set` is typically more efficient."
                    },
                    {
                        "username": "sumanthsrungavarapu3",
                        "content": "this is an easy one and there are many ways to do it, I did it by just writing a single line if to return a boolean by comparing length of list and and its set. Interestingly I found online that len function\\'s time complexity is just O(1) because underneath it doesn\\'t call a function and perform some operations. The interpreter maintains length stored for everything and len just fetches it. \\nI am thinking this is the best and efficient possible, although I may not seem to understand what happens by using the set conversion. Anyone knows what process happens underneath set conversion and its time, space complexities, please make it known. and any more efficient way in case mine isn\\'t."
                    },
                    {
                        "username": "santoshmourya",
                        "content": "Hii all this is code with time complexity O(1) and space complexity O(n)\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n       int size1= nums.size();\\n       set<int> s(nums.begin(),nums.end());\\n       int size2= s.size();\\n       if(size1==size2){\\n           return false;\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "naveenkum",
                        "content": "how one can get  dynamic array without using any third variable \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If you want to resize an array dynamically in Python, the preferred way is to use a list. Lists in Python are dynamic arrays and you can add and remove items without using a third variable. Here is an example:\\n\\n```python\\n# Initialize the list (dynamic array)\\nnums = [1, 2, 3, 4, 5]\\n\\n# Add an item to the end\\nnums.append(6)\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5, 6]\\n\\n# Remove the last item\\nnums.pop()\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5]\\n```\\n\\nAs you can see, the list `nums` is resized without the need for a third variable. The `append` method adds an item to the end, and the `pop` method removes the last item.\\n\\nHowever, if you\\'re working with a language that doesn\\'t have built-in support for dynamic arrays (like C or C++), resizing an array without a temporary variable could be more challenging. You would generally need to use a function provided by the language\\'s standard library (like `realloc` in C) to resize the array, and this can involve creating a new block of memory, copying the elements over, and then freeing the old block of memory."
                    },
                    {
                        "username": "megadriive",
                        "content": "bru why aren\\'t my for loops working"
                    },
                    {
                        "username": "Aparna_Rengamani",
                        "content": "why is it showing like \"Time limit exceeded\"? I\\'ve used just one for loop"
                    },
                    {
                        "username": "dactung93",
                        "content": "I use 2 methods but I can say it is quite similar\\n\\n1, \\n- Sort Array in Ascending order\\n- Loop from 0 to nums length - 1\\n + Compare array a[i] and a[1+1]\\n + If they are equal then return true\\n + When finish the loop, return False\\n\\n2,\\n- Using HashSet Unique\\n- Loop i from begining to the end\\n + If Unique containt a[i] then return True\\n + Otherwise, Unique.add a[i]\\n- Finish Loop then return False\\n\\nMethod 1: Memory Optimized\\nMethod 2: Runtime Optimized\\n\\nHow can I balance both?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Balancing runtime and memory optimization often depends on the specific needs of the program or the system it\\'s running on. However, here are some general ways you might find a balance between the two methods you mentioned for this problem:\\n\\n1. **Runtime and Memory Tradeoff:** As you have noticed, the first method (sorting the array and checking for duplicates) has a time complexity of O(n log n) and a space complexity of O(1), while the second method (using a hashset to check for duplicates) has a time complexity of O(n) and a space complexity of O(n). If you want to find a balance, you might need to be okay with a bit higher time complexity to reduce the space complexity, or vice versa.\\n\\n2. **Customized Data Structures:** In some cases, you might be able to create a customized data structure that is more space efficient than a hashset but still gives you faster lookup times than sorting the array. This could be complex and might not be worth it for a problem like this, but it\\'s an option in some cases.\\n\\n3. **Probabilistic Data Structures:** If an approximate answer is acceptable, you could consider using a probabilistic data structure like a Bloom filter. A Bloom filter can tell you if an element is definitely not in a set or may be in the set. This could potentially reduce your space usage while still giving you fast lookup times.\\n\\nRemember, the right balance between runtime and memory optimization often depends on the specific constraints of your problem and system. What is most important is to understand the tradeoffs you\\'re making and choose the best strategy for your needs."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Best time complexity solution is not correct but accepted  !!!!\n\n                            input    [ 5 , 35 , 5 ] \n\n\nint hash(int key, int inputSize){\n    return abs(key) % inputSize;\n}\n\nbool containsDuplicate(int* nums, int numsSize){\n    int hashTableSize = 2 * numsSize;\n    int *hashTable = (int *) malloc(hashTableSize * sizeof( int ));\n\n    for (int i = 0; i < numsSize; i++) {\n        if (hashTable[hash(nums[i], hashTableSize)] == nums[i]) {\n            return true;\n        } else {\n            hashTable[hash(nums[i], hashTableSize)] = nums[i];\n        }\n    }\n\n    return false;\n}\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is implementing a Hash Table with an open addressing technique, but it lacks collision resolution. Here, we are using an array `hashTable` as the Hash Table and the `hash()` function to calculate the index for each element in `nums`.\\n\\nBut the problem is, the same index can be calculated for different numbers. For example, if `numsSize` is 10, both 5 and 15 will be mapped to the index 5. So if we have a situation where we first insert 15 into the hash table and then we try to insert 5, the code will erroneously think that there\\'s a duplicate even though 5 and 15 are different.\\n\\nTo fix this, you can use chaining (a linked list at each hash table index to handle collisions) or another collision resolution technique such as linear probing, quadratic probing, or double hashing.\\n\\nHowever, note that implementing these strategies in C would require more code and it wouldn\\'t be a constant time solution anymore. It would be average case O(1) (constant time), but worst case could be O(n) (linear time) if all keys collide.\\n\\nMoreover, because your `hashTable` isn\\'t initialized, it contains random values which can lead to false positives when checking for duplicates.\\n"
                    }
                ]
            },
            {
                "id": 1912288,
                "content": [
                    {
                        "username": "JekoAZE",
                        "content": "Guys what does it mean \"Time Limit Exceeded\"  ?"
                    },
                    {
                        "username": "srushtiii",
                        "content": "It means that something in your code is taking more time.\\nlike you have a while loop and you forgot to increment/decrement the counter so it\\'ll be executed infinite time and will give you TLE. "
                    },
                    {
                        "username": "tanasedaniel54",
                        "content": "I don\\'t think there is a possible solution using only C programming (no sets, no vectors, just C).\\nIf somebody find a solution, please let me know, thanks! \\uD83D\\uDE01"
                    },
                    {
                        "username": "bellaeheh",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       List listy = Arrays.asList(nums);\\n       List listx = new ArrayList();\\n       for (Object i: listy) {\\n           if (!listx.contains(i)) {\\n               listx.add(i);\\n            }\\n       }\\n       return !(listy.size() == listx.size());\\n           \\n       \\n    }\\n}\\n\\nCan i ask why this doesnt work"
                    },
                    {
                        "username": "bparanj",
                        "content": "In your code, you\\'re using the `Arrays.asList` function to convert an array to a list. However, this method does not work as expected with an array of primitives like `int[]`. \\n\\nJava treats each primitive array as a single object, so `Arrays.asList(nums)` doesn\\'t create a list of integers but a list containing a single object, which is the array itself. So, `listy.size()` is always `1`, not the length of the `nums` array.\\n\\nTo fix this, you need to change your array of primitives (`int[]`) to an array of objects (`Integer[]`). Then, `Arrays.asList()` will work as you expect:\\n\\n```java\\nclass Solution {\\n    public boolean containsDuplicate(Integer[] nums) {\\n        List<Integer> listy = Arrays.asList(nums);\\n        Set<Integer> setx = new HashSet<>(listy);\\n        \\n        return !(listy.size() == setx.size());\\n    }\\n}\\n```\\n\\nAlso, I changed `listx` to a `Set`, because `set.add(i)` and `set.contains(i)` operations are faster (both O(1)) than `list.add(i)` and `list.contains(i)` operations (O(n) in the worst case for `ArrayList`). If you\\'re checking for duplicates, using a `Set` is typically more efficient."
                    },
                    {
                        "username": "sumanthsrungavarapu3",
                        "content": "this is an easy one and there are many ways to do it, I did it by just writing a single line if to return a boolean by comparing length of list and and its set. Interestingly I found online that len function\\'s time complexity is just O(1) because underneath it doesn\\'t call a function and perform some operations. The interpreter maintains length stored for everything and len just fetches it. \\nI am thinking this is the best and efficient possible, although I may not seem to understand what happens by using the set conversion. Anyone knows what process happens underneath set conversion and its time, space complexities, please make it known. and any more efficient way in case mine isn\\'t."
                    },
                    {
                        "username": "santoshmourya",
                        "content": "Hii all this is code with time complexity O(1) and space complexity O(n)\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n       int size1= nums.size();\\n       set<int> s(nums.begin(),nums.end());\\n       int size2= s.size();\\n       if(size1==size2){\\n           return false;\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "naveenkum",
                        "content": "how one can get  dynamic array without using any third variable \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If you want to resize an array dynamically in Python, the preferred way is to use a list. Lists in Python are dynamic arrays and you can add and remove items without using a third variable. Here is an example:\\n\\n```python\\n# Initialize the list (dynamic array)\\nnums = [1, 2, 3, 4, 5]\\n\\n# Add an item to the end\\nnums.append(6)\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5, 6]\\n\\n# Remove the last item\\nnums.pop()\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5]\\n```\\n\\nAs you can see, the list `nums` is resized without the need for a third variable. The `append` method adds an item to the end, and the `pop` method removes the last item.\\n\\nHowever, if you\\'re working with a language that doesn\\'t have built-in support for dynamic arrays (like C or C++), resizing an array without a temporary variable could be more challenging. You would generally need to use a function provided by the language\\'s standard library (like `realloc` in C) to resize the array, and this can involve creating a new block of memory, copying the elements over, and then freeing the old block of memory."
                    },
                    {
                        "username": "megadriive",
                        "content": "bru why aren\\'t my for loops working"
                    },
                    {
                        "username": "Aparna_Rengamani",
                        "content": "why is it showing like \"Time limit exceeded\"? I\\'ve used just one for loop"
                    },
                    {
                        "username": "dactung93",
                        "content": "I use 2 methods but I can say it is quite similar\\n\\n1, \\n- Sort Array in Ascending order\\n- Loop from 0 to nums length - 1\\n + Compare array a[i] and a[1+1]\\n + If they are equal then return true\\n + When finish the loop, return False\\n\\n2,\\n- Using HashSet Unique\\n- Loop i from begining to the end\\n + If Unique containt a[i] then return True\\n + Otherwise, Unique.add a[i]\\n- Finish Loop then return False\\n\\nMethod 1: Memory Optimized\\nMethod 2: Runtime Optimized\\n\\nHow can I balance both?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Balancing runtime and memory optimization often depends on the specific needs of the program or the system it\\'s running on. However, here are some general ways you might find a balance between the two methods you mentioned for this problem:\\n\\n1. **Runtime and Memory Tradeoff:** As you have noticed, the first method (sorting the array and checking for duplicates) has a time complexity of O(n log n) and a space complexity of O(1), while the second method (using a hashset to check for duplicates) has a time complexity of O(n) and a space complexity of O(n). If you want to find a balance, you might need to be okay with a bit higher time complexity to reduce the space complexity, or vice versa.\\n\\n2. **Customized Data Structures:** In some cases, you might be able to create a customized data structure that is more space efficient than a hashset but still gives you faster lookup times than sorting the array. This could be complex and might not be worth it for a problem like this, but it\\'s an option in some cases.\\n\\n3. **Probabilistic Data Structures:** If an approximate answer is acceptable, you could consider using a probabilistic data structure like a Bloom filter. A Bloom filter can tell you if an element is definitely not in a set or may be in the set. This could potentially reduce your space usage while still giving you fast lookup times.\\n\\nRemember, the right balance between runtime and memory optimization often depends on the specific constraints of your problem and system. What is most important is to understand the tradeoffs you\\'re making and choose the best strategy for your needs."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Best time complexity solution is not correct but accepted  !!!!\n\n                            input    [ 5 , 35 , 5 ] \n\n\nint hash(int key, int inputSize){\n    return abs(key) % inputSize;\n}\n\nbool containsDuplicate(int* nums, int numsSize){\n    int hashTableSize = 2 * numsSize;\n    int *hashTable = (int *) malloc(hashTableSize * sizeof( int ));\n\n    for (int i = 0; i < numsSize; i++) {\n        if (hashTable[hash(nums[i], hashTableSize)] == nums[i]) {\n            return true;\n        } else {\n            hashTable[hash(nums[i], hashTableSize)] = nums[i];\n        }\n    }\n\n    return false;\n}\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is implementing a Hash Table with an open addressing technique, but it lacks collision resolution. Here, we are using an array `hashTable` as the Hash Table and the `hash()` function to calculate the index for each element in `nums`.\\n\\nBut the problem is, the same index can be calculated for different numbers. For example, if `numsSize` is 10, both 5 and 15 will be mapped to the index 5. So if we have a situation where we first insert 15 into the hash table and then we try to insert 5, the code will erroneously think that there\\'s a duplicate even though 5 and 15 are different.\\n\\nTo fix this, you can use chaining (a linked list at each hash table index to handle collisions) or another collision resolution technique such as linear probing, quadratic probing, or double hashing.\\n\\nHowever, note that implementing these strategies in C would require more code and it wouldn\\'t be a constant time solution anymore. It would be average case O(1) (constant time), but worst case could be O(n) (linear time) if all keys collide.\\n\\nMoreover, because your `hashTable` isn\\'t initialized, it contains random values which can lead to false positives when checking for duplicates.\\n"
                    }
                ]
            },
            {
                "id": 1911680,
                "content": [
                    {
                        "username": "JekoAZE",
                        "content": "Guys what does it mean \"Time Limit Exceeded\"  ?"
                    },
                    {
                        "username": "srushtiii",
                        "content": "It means that something in your code is taking more time.\\nlike you have a while loop and you forgot to increment/decrement the counter so it\\'ll be executed infinite time and will give you TLE. "
                    },
                    {
                        "username": "tanasedaniel54",
                        "content": "I don\\'t think there is a possible solution using only C programming (no sets, no vectors, just C).\\nIf somebody find a solution, please let me know, thanks! \\uD83D\\uDE01"
                    },
                    {
                        "username": "bellaeheh",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       List listy = Arrays.asList(nums);\\n       List listx = new ArrayList();\\n       for (Object i: listy) {\\n           if (!listx.contains(i)) {\\n               listx.add(i);\\n            }\\n       }\\n       return !(listy.size() == listx.size());\\n           \\n       \\n    }\\n}\\n\\nCan i ask why this doesnt work"
                    },
                    {
                        "username": "bparanj",
                        "content": "In your code, you\\'re using the `Arrays.asList` function to convert an array to a list. However, this method does not work as expected with an array of primitives like `int[]`. \\n\\nJava treats each primitive array as a single object, so `Arrays.asList(nums)` doesn\\'t create a list of integers but a list containing a single object, which is the array itself. So, `listy.size()` is always `1`, not the length of the `nums` array.\\n\\nTo fix this, you need to change your array of primitives (`int[]`) to an array of objects (`Integer[]`). Then, `Arrays.asList()` will work as you expect:\\n\\n```java\\nclass Solution {\\n    public boolean containsDuplicate(Integer[] nums) {\\n        List<Integer> listy = Arrays.asList(nums);\\n        Set<Integer> setx = new HashSet<>(listy);\\n        \\n        return !(listy.size() == setx.size());\\n    }\\n}\\n```\\n\\nAlso, I changed `listx` to a `Set`, because `set.add(i)` and `set.contains(i)` operations are faster (both O(1)) than `list.add(i)` and `list.contains(i)` operations (O(n) in the worst case for `ArrayList`). If you\\'re checking for duplicates, using a `Set` is typically more efficient."
                    },
                    {
                        "username": "sumanthsrungavarapu3",
                        "content": "this is an easy one and there are many ways to do it, I did it by just writing a single line if to return a boolean by comparing length of list and and its set. Interestingly I found online that len function\\'s time complexity is just O(1) because underneath it doesn\\'t call a function and perform some operations. The interpreter maintains length stored for everything and len just fetches it. \\nI am thinking this is the best and efficient possible, although I may not seem to understand what happens by using the set conversion. Anyone knows what process happens underneath set conversion and its time, space complexities, please make it known. and any more efficient way in case mine isn\\'t."
                    },
                    {
                        "username": "santoshmourya",
                        "content": "Hii all this is code with time complexity O(1) and space complexity O(n)\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n       int size1= nums.size();\\n       set<int> s(nums.begin(),nums.end());\\n       int size2= s.size();\\n       if(size1==size2){\\n           return false;\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "naveenkum",
                        "content": "how one can get  dynamic array without using any third variable \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "If you want to resize an array dynamically in Python, the preferred way is to use a list. Lists in Python are dynamic arrays and you can add and remove items without using a third variable. Here is an example:\\n\\n```python\\n# Initialize the list (dynamic array)\\nnums = [1, 2, 3, 4, 5]\\n\\n# Add an item to the end\\nnums.append(6)\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5, 6]\\n\\n# Remove the last item\\nnums.pop()\\nprint(nums)  # Outputs: [1, 2, 3, 4, 5]\\n```\\n\\nAs you can see, the list `nums` is resized without the need for a third variable. The `append` method adds an item to the end, and the `pop` method removes the last item.\\n\\nHowever, if you\\'re working with a language that doesn\\'t have built-in support for dynamic arrays (like C or C++), resizing an array without a temporary variable could be more challenging. You would generally need to use a function provided by the language\\'s standard library (like `realloc` in C) to resize the array, and this can involve creating a new block of memory, copying the elements over, and then freeing the old block of memory."
                    },
                    {
                        "username": "megadriive",
                        "content": "bru why aren\\'t my for loops working"
                    },
                    {
                        "username": "Aparna_Rengamani",
                        "content": "why is it showing like \"Time limit exceeded\"? I\\'ve used just one for loop"
                    },
                    {
                        "username": "dactung93",
                        "content": "I use 2 methods but I can say it is quite similar\\n\\n1, \\n- Sort Array in Ascending order\\n- Loop from 0 to nums length - 1\\n + Compare array a[i] and a[1+1]\\n + If they are equal then return true\\n + When finish the loop, return False\\n\\n2,\\n- Using HashSet Unique\\n- Loop i from begining to the end\\n + If Unique containt a[i] then return True\\n + Otherwise, Unique.add a[i]\\n- Finish Loop then return False\\n\\nMethod 1: Memory Optimized\\nMethod 2: Runtime Optimized\\n\\nHow can I balance both?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Balancing runtime and memory optimization often depends on the specific needs of the program or the system it\\'s running on. However, here are some general ways you might find a balance between the two methods you mentioned for this problem:\\n\\n1. **Runtime and Memory Tradeoff:** As you have noticed, the first method (sorting the array and checking for duplicates) has a time complexity of O(n log n) and a space complexity of O(1), while the second method (using a hashset to check for duplicates) has a time complexity of O(n) and a space complexity of O(n). If you want to find a balance, you might need to be okay with a bit higher time complexity to reduce the space complexity, or vice versa.\\n\\n2. **Customized Data Structures:** In some cases, you might be able to create a customized data structure that is more space efficient than a hashset but still gives you faster lookup times than sorting the array. This could be complex and might not be worth it for a problem like this, but it\\'s an option in some cases.\\n\\n3. **Probabilistic Data Structures:** If an approximate answer is acceptable, you could consider using a probabilistic data structure like a Bloom filter. A Bloom filter can tell you if an element is definitely not in a set or may be in the set. This could potentially reduce your space usage while still giving you fast lookup times.\\n\\nRemember, the right balance between runtime and memory optimization often depends on the specific constraints of your problem and system. What is most important is to understand the tradeoffs you\\'re making and choose the best strategy for your needs."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Best time complexity solution is not correct but accepted  !!!!\n\n                            input    [ 5 , 35 , 5 ] \n\n\nint hash(int key, int inputSize){\n    return abs(key) % inputSize;\n}\n\nbool containsDuplicate(int* nums, int numsSize){\n    int hashTableSize = 2 * numsSize;\n    int *hashTable = (int *) malloc(hashTableSize * sizeof( int ));\n\n    for (int i = 0; i < numsSize; i++) {\n        if (hashTable[hash(nums[i], hashTableSize)] == nums[i]) {\n            return true;\n        } else {\n            hashTable[hash(nums[i], hashTableSize)] = nums[i];\n        }\n    }\n\n    return false;\n}\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided is implementing a Hash Table with an open addressing technique, but it lacks collision resolution. Here, we are using an array `hashTable` as the Hash Table and the `hash()` function to calculate the index for each element in `nums`.\\n\\nBut the problem is, the same index can be calculated for different numbers. For example, if `numsSize` is 10, both 5 and 15 will be mapped to the index 5. So if we have a situation where we first insert 15 into the hash table and then we try to insert 5, the code will erroneously think that there\\'s a duplicate even though 5 and 15 are different.\\n\\nTo fix this, you can use chaining (a linked list at each hash table index to handle collisions) or another collision resolution technique such as linear probing, quadratic probing, or double hashing.\\n\\nHowever, note that implementing these strategies in C would require more code and it wouldn\\'t be a constant time solution anymore. It would be average case O(1) (constant time), but worst case could be O(n) (linear time) if all keys collide.\\n\\nMoreover, because your `hashTable` isn\\'t initialized, it contains random values which can lead to false positives when checking for duplicates.\\n"
                    }
                ]
            },
            {
                "id": 1910566,
                "content": [
                    {
                        "username": "Manjula_171103",
                        "content": "how to print atleast twice in a array"
                    },
                    {
                        "username": "ivar7x",
                        "content": "using for loop :)"
                    },
                    {
                        "username": "nishthajoshi",
                        "content": "can\\'t we do it to soemthing silimar to Moore\\'s Voting algorithm? we can have a counter variable to track if a number has occured twice....if it has simply return true? please help"
                    },
                    {
                        "username": "Soumya_The_Legend",
                        "content": "I don\\'t understand why this code does not work for the test case [1,2,3,1]:\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int, int> mpp;\\n        for(int i=0; i< nums.size(); i++){\\n            if(mpp[nums[i]] >= 2){\\n                return true;\\n            } \\n            else{\\n                mpp[nums[i]]++;\\n            }\\n        }\\n        return false;\\n    }\\n"
                    },
                    {
                        "username": "irfanirfan0239",
                        "content": "check this solution in python  .\nhttps://leetcode.com/problems/contains-duplicate/submissions/956362537/\n \nor \nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        if len(nums)==len(set(nums)):\n            return False\n        else:\n            return True"
                    },
                    {
                        "username": "gopalbhalani137",
                        "content": "can anyone suggest me why this  code is not working?\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=1e5+10;\\n        int b[n];\\n        int flag;\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            b[nums[i]]++;\\n        }\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            if(b[i]>1)\\n            {\\n                flag=1;\\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n           return false;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "Sufiyan_Manihar",
                        "content": "what wrong in this!!!\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i = 0; i <nums.size(); i++)\\n         for (int j=i+1; j< nums.size(); j++)\\n                if (nums[i]==nums[j])\\n                    return true;      \\n    \\nreturn false;\\n    }\\n};"
                    },
                    {
                        "username": "Anshleet1",
                        "content": "        Arrays.sort(nums);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1]) return true;\\n        }\\n        return false;"
                    },
                    {
                        "username": "AkRadhe",
                        "content": "Easy Solution using set..\\n\\n set<int>val;\\n        for(int i=0;i<nums.size();i++)\\n        val.insert(nums[i]);\\n        if(val.size()==nums.size())\\n        return false;\\n        return true;"
                    },
                    {
                        "username": "BlakeAghili",
                        "content": "The description of question does not match the solutions provided. The solution thinks it should return true if there is at least one number that has a duplicate. That\\'s why it returns True for [1,1,2,3] but the description of problem wants you to return true if EVERY numbe has a duplicate which means [1,1,2,3] should return FALSE because obviously 2 and 3 don\\'t have dups in that goddamn array WTF man who wrote this question . "
                    },
                    {
                        "username": "anshumanatrey",
                        "content": "I was using double for loop but test case time limit exceeded, if it happens to you use sort function \n `sort(nums.begin(), nums.end());`\nand 1 for loop with if statement to check next element is same or not.\n `if (nums[a]==nums[a+1])`\n"
                    }
                ]
            },
            {
                "id": 1905232,
                "content": [
                    {
                        "username": "Manjula_171103",
                        "content": "how to print atleast twice in a array"
                    },
                    {
                        "username": "ivar7x",
                        "content": "using for loop :)"
                    },
                    {
                        "username": "nishthajoshi",
                        "content": "can\\'t we do it to soemthing silimar to Moore\\'s Voting algorithm? we can have a counter variable to track if a number has occured twice....if it has simply return true? please help"
                    },
                    {
                        "username": "Soumya_The_Legend",
                        "content": "I don\\'t understand why this code does not work for the test case [1,2,3,1]:\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int, int> mpp;\\n        for(int i=0; i< nums.size(); i++){\\n            if(mpp[nums[i]] >= 2){\\n                return true;\\n            } \\n            else{\\n                mpp[nums[i]]++;\\n            }\\n        }\\n        return false;\\n    }\\n"
                    },
                    {
                        "username": "irfanirfan0239",
                        "content": "check this solution in python  .\nhttps://leetcode.com/problems/contains-duplicate/submissions/956362537/\n \nor \nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        if len(nums)==len(set(nums)):\n            return False\n        else:\n            return True"
                    },
                    {
                        "username": "gopalbhalani137",
                        "content": "can anyone suggest me why this  code is not working?\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=1e5+10;\\n        int b[n];\\n        int flag;\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            b[nums[i]]++;\\n        }\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            if(b[i]>1)\\n            {\\n                flag=1;\\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n           return false;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "Sufiyan_Manihar",
                        "content": "what wrong in this!!!\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i = 0; i <nums.size(); i++)\\n         for (int j=i+1; j< nums.size(); j++)\\n                if (nums[i]==nums[j])\\n                    return true;      \\n    \\nreturn false;\\n    }\\n};"
                    },
                    {
                        "username": "Anshleet1",
                        "content": "        Arrays.sort(nums);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1]) return true;\\n        }\\n        return false;"
                    },
                    {
                        "username": "AkRadhe",
                        "content": "Easy Solution using set..\\n\\n set<int>val;\\n        for(int i=0;i<nums.size();i++)\\n        val.insert(nums[i]);\\n        if(val.size()==nums.size())\\n        return false;\\n        return true;"
                    },
                    {
                        "username": "BlakeAghili",
                        "content": "The description of question does not match the solutions provided. The solution thinks it should return true if there is at least one number that has a duplicate. That\\'s why it returns True for [1,1,2,3] but the description of problem wants you to return true if EVERY numbe has a duplicate which means [1,1,2,3] should return FALSE because obviously 2 and 3 don\\'t have dups in that goddamn array WTF man who wrote this question . "
                    },
                    {
                        "username": "anshumanatrey",
                        "content": "I was using double for loop but test case time limit exceeded, if it happens to you use sort function \n `sort(nums.begin(), nums.end());`\nand 1 for loop with if statement to check next element is same or not.\n `if (nums[a]==nums[a+1])`\n"
                    }
                ]
            },
            {
                "id": 1904443,
                "content": [
                    {
                        "username": "Manjula_171103",
                        "content": "how to print atleast twice in a array"
                    },
                    {
                        "username": "ivar7x",
                        "content": "using for loop :)"
                    },
                    {
                        "username": "nishthajoshi",
                        "content": "can\\'t we do it to soemthing silimar to Moore\\'s Voting algorithm? we can have a counter variable to track if a number has occured twice....if it has simply return true? please help"
                    },
                    {
                        "username": "Soumya_The_Legend",
                        "content": "I don\\'t understand why this code does not work for the test case [1,2,3,1]:\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int, int> mpp;\\n        for(int i=0; i< nums.size(); i++){\\n            if(mpp[nums[i]] >= 2){\\n                return true;\\n            } \\n            else{\\n                mpp[nums[i]]++;\\n            }\\n        }\\n        return false;\\n    }\\n"
                    },
                    {
                        "username": "irfanirfan0239",
                        "content": "check this solution in python  .\nhttps://leetcode.com/problems/contains-duplicate/submissions/956362537/\n \nor \nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        if len(nums)==len(set(nums)):\n            return False\n        else:\n            return True"
                    },
                    {
                        "username": "gopalbhalani137",
                        "content": "can anyone suggest me why this  code is not working?\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=1e5+10;\\n        int b[n];\\n        int flag;\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            b[nums[i]]++;\\n        }\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            if(b[i]>1)\\n            {\\n                flag=1;\\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n           return false;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "Sufiyan_Manihar",
                        "content": "what wrong in this!!!\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i = 0; i <nums.size(); i++)\\n         for (int j=i+1; j< nums.size(); j++)\\n                if (nums[i]==nums[j])\\n                    return true;      \\n    \\nreturn false;\\n    }\\n};"
                    },
                    {
                        "username": "Anshleet1",
                        "content": "        Arrays.sort(nums);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1]) return true;\\n        }\\n        return false;"
                    },
                    {
                        "username": "AkRadhe",
                        "content": "Easy Solution using set..\\n\\n set<int>val;\\n        for(int i=0;i<nums.size();i++)\\n        val.insert(nums[i]);\\n        if(val.size()==nums.size())\\n        return false;\\n        return true;"
                    },
                    {
                        "username": "BlakeAghili",
                        "content": "The description of question does not match the solutions provided. The solution thinks it should return true if there is at least one number that has a duplicate. That\\'s why it returns True for [1,1,2,3] but the description of problem wants you to return true if EVERY numbe has a duplicate which means [1,1,2,3] should return FALSE because obviously 2 and 3 don\\'t have dups in that goddamn array WTF man who wrote this question . "
                    },
                    {
                        "username": "anshumanatrey",
                        "content": "I was using double for loop but test case time limit exceeded, if it happens to you use sort function \n `sort(nums.begin(), nums.end());`\nand 1 for loop with if statement to check next element is same or not.\n `if (nums[a]==nums[a+1])`\n"
                    }
                ]
            },
            {
                "id": 1903952,
                "content": [
                    {
                        "username": "Manjula_171103",
                        "content": "how to print atleast twice in a array"
                    },
                    {
                        "username": "ivar7x",
                        "content": "using for loop :)"
                    },
                    {
                        "username": "nishthajoshi",
                        "content": "can\\'t we do it to soemthing silimar to Moore\\'s Voting algorithm? we can have a counter variable to track if a number has occured twice....if it has simply return true? please help"
                    },
                    {
                        "username": "Soumya_The_Legend",
                        "content": "I don\\'t understand why this code does not work for the test case [1,2,3,1]:\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int, int> mpp;\\n        for(int i=0; i< nums.size(); i++){\\n            if(mpp[nums[i]] >= 2){\\n                return true;\\n            } \\n            else{\\n                mpp[nums[i]]++;\\n            }\\n        }\\n        return false;\\n    }\\n"
                    },
                    {
                        "username": "irfanirfan0239",
                        "content": "check this solution in python  .\nhttps://leetcode.com/problems/contains-duplicate/submissions/956362537/\n \nor \nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        if len(nums)==len(set(nums)):\n            return False\n        else:\n            return True"
                    },
                    {
                        "username": "gopalbhalani137",
                        "content": "can anyone suggest me why this  code is not working?\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=1e5+10;\\n        int b[n];\\n        int flag;\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            b[nums[i]]++;\\n        }\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            if(b[i]>1)\\n            {\\n                flag=1;\\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n           return false;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "Sufiyan_Manihar",
                        "content": "what wrong in this!!!\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i = 0; i <nums.size(); i++)\\n         for (int j=i+1; j< nums.size(); j++)\\n                if (nums[i]==nums[j])\\n                    return true;      \\n    \\nreturn false;\\n    }\\n};"
                    },
                    {
                        "username": "Anshleet1",
                        "content": "        Arrays.sort(nums);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1]) return true;\\n        }\\n        return false;"
                    },
                    {
                        "username": "AkRadhe",
                        "content": "Easy Solution using set..\\n\\n set<int>val;\\n        for(int i=0;i<nums.size();i++)\\n        val.insert(nums[i]);\\n        if(val.size()==nums.size())\\n        return false;\\n        return true;"
                    },
                    {
                        "username": "BlakeAghili",
                        "content": "The description of question does not match the solutions provided. The solution thinks it should return true if there is at least one number that has a duplicate. That\\'s why it returns True for [1,1,2,3] but the description of problem wants you to return true if EVERY numbe has a duplicate which means [1,1,2,3] should return FALSE because obviously 2 and 3 don\\'t have dups in that goddamn array WTF man who wrote this question . "
                    },
                    {
                        "username": "anshumanatrey",
                        "content": "I was using double for loop but test case time limit exceeded, if it happens to you use sort function \n `sort(nums.begin(), nums.end());`\nand 1 for loop with if statement to check next element is same or not.\n `if (nums[a]==nums[a+1])`\n"
                    }
                ]
            },
            {
                "id": 1900176,
                "content": [
                    {
                        "username": "Manjula_171103",
                        "content": "how to print atleast twice in a array"
                    },
                    {
                        "username": "ivar7x",
                        "content": "using for loop :)"
                    },
                    {
                        "username": "nishthajoshi",
                        "content": "can\\'t we do it to soemthing silimar to Moore\\'s Voting algorithm? we can have a counter variable to track if a number has occured twice....if it has simply return true? please help"
                    },
                    {
                        "username": "Soumya_The_Legend",
                        "content": "I don\\'t understand why this code does not work for the test case [1,2,3,1]:\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int, int> mpp;\\n        for(int i=0; i< nums.size(); i++){\\n            if(mpp[nums[i]] >= 2){\\n                return true;\\n            } \\n            else{\\n                mpp[nums[i]]++;\\n            }\\n        }\\n        return false;\\n    }\\n"
                    },
                    {
                        "username": "irfanirfan0239",
                        "content": "check this solution in python  .\nhttps://leetcode.com/problems/contains-duplicate/submissions/956362537/\n \nor \nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        if len(nums)==len(set(nums)):\n            return False\n        else:\n            return True"
                    },
                    {
                        "username": "gopalbhalani137",
                        "content": "can anyone suggest me why this  code is not working?\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=1e5+10;\\n        int b[n];\\n        int flag;\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            b[nums[i]]++;\\n        }\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            if(b[i]>1)\\n            {\\n                flag=1;\\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n           return false;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "Sufiyan_Manihar",
                        "content": "what wrong in this!!!\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i = 0; i <nums.size(); i++)\\n         for (int j=i+1; j< nums.size(); j++)\\n                if (nums[i]==nums[j])\\n                    return true;      \\n    \\nreturn false;\\n    }\\n};"
                    },
                    {
                        "username": "Anshleet1",
                        "content": "        Arrays.sort(nums);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1]) return true;\\n        }\\n        return false;"
                    },
                    {
                        "username": "AkRadhe",
                        "content": "Easy Solution using set..\\n\\n set<int>val;\\n        for(int i=0;i<nums.size();i++)\\n        val.insert(nums[i]);\\n        if(val.size()==nums.size())\\n        return false;\\n        return true;"
                    },
                    {
                        "username": "BlakeAghili",
                        "content": "The description of question does not match the solutions provided. The solution thinks it should return true if there is at least one number that has a duplicate. That\\'s why it returns True for [1,1,2,3] but the description of problem wants you to return true if EVERY numbe has a duplicate which means [1,1,2,3] should return FALSE because obviously 2 and 3 don\\'t have dups in that goddamn array WTF man who wrote this question . "
                    },
                    {
                        "username": "anshumanatrey",
                        "content": "I was using double for loop but test case time limit exceeded, if it happens to you use sort function \n `sort(nums.begin(), nums.end());`\nand 1 for loop with if statement to check next element is same or not.\n `if (nums[a]==nums[a+1])`\n"
                    }
                ]
            },
            {
                "id": 1893655,
                "content": [
                    {
                        "username": "Manjula_171103",
                        "content": "how to print atleast twice in a array"
                    },
                    {
                        "username": "ivar7x",
                        "content": "using for loop :)"
                    },
                    {
                        "username": "nishthajoshi",
                        "content": "can\\'t we do it to soemthing silimar to Moore\\'s Voting algorithm? we can have a counter variable to track if a number has occured twice....if it has simply return true? please help"
                    },
                    {
                        "username": "Soumya_The_Legend",
                        "content": "I don\\'t understand why this code does not work for the test case [1,2,3,1]:\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int, int> mpp;\\n        for(int i=0; i< nums.size(); i++){\\n            if(mpp[nums[i]] >= 2){\\n                return true;\\n            } \\n            else{\\n                mpp[nums[i]]++;\\n            }\\n        }\\n        return false;\\n    }\\n"
                    },
                    {
                        "username": "irfanirfan0239",
                        "content": "check this solution in python  .\nhttps://leetcode.com/problems/contains-duplicate/submissions/956362537/\n \nor \nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        if len(nums)==len(set(nums)):\n            return False\n        else:\n            return True"
                    },
                    {
                        "username": "gopalbhalani137",
                        "content": "can anyone suggest me why this  code is not working?\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=1e5+10;\\n        int b[n];\\n        int flag;\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            b[nums[i]]++;\\n        }\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            if(b[i]>1)\\n            {\\n                flag=1;\\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n           return false;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "Sufiyan_Manihar",
                        "content": "what wrong in this!!!\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i = 0; i <nums.size(); i++)\\n         for (int j=i+1; j< nums.size(); j++)\\n                if (nums[i]==nums[j])\\n                    return true;      \\n    \\nreturn false;\\n    }\\n};"
                    },
                    {
                        "username": "Anshleet1",
                        "content": "        Arrays.sort(nums);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1]) return true;\\n        }\\n        return false;"
                    },
                    {
                        "username": "AkRadhe",
                        "content": "Easy Solution using set..\\n\\n set<int>val;\\n        for(int i=0;i<nums.size();i++)\\n        val.insert(nums[i]);\\n        if(val.size()==nums.size())\\n        return false;\\n        return true;"
                    },
                    {
                        "username": "BlakeAghili",
                        "content": "The description of question does not match the solutions provided. The solution thinks it should return true if there is at least one number that has a duplicate. That\\'s why it returns True for [1,1,2,3] but the description of problem wants you to return true if EVERY numbe has a duplicate which means [1,1,2,3] should return FALSE because obviously 2 and 3 don\\'t have dups in that goddamn array WTF man who wrote this question . "
                    },
                    {
                        "username": "anshumanatrey",
                        "content": "I was using double for loop but test case time limit exceeded, if it happens to you use sort function \n `sort(nums.begin(), nums.end());`\nand 1 for loop with if statement to check next element is same or not.\n `if (nums[a]==nums[a+1])`\n"
                    }
                ]
            },
            {
                "id": 1863664,
                "content": [
                    {
                        "username": "Manjula_171103",
                        "content": "how to print atleast twice in a array"
                    },
                    {
                        "username": "ivar7x",
                        "content": "using for loop :)"
                    },
                    {
                        "username": "nishthajoshi",
                        "content": "can\\'t we do it to soemthing silimar to Moore\\'s Voting algorithm? we can have a counter variable to track if a number has occured twice....if it has simply return true? please help"
                    },
                    {
                        "username": "Soumya_The_Legend",
                        "content": "I don\\'t understand why this code does not work for the test case [1,2,3,1]:\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int, int> mpp;\\n        for(int i=0; i< nums.size(); i++){\\n            if(mpp[nums[i]] >= 2){\\n                return true;\\n            } \\n            else{\\n                mpp[nums[i]]++;\\n            }\\n        }\\n        return false;\\n    }\\n"
                    },
                    {
                        "username": "irfanirfan0239",
                        "content": "check this solution in python  .\nhttps://leetcode.com/problems/contains-duplicate/submissions/956362537/\n \nor \nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        if len(nums)==len(set(nums)):\n            return False\n        else:\n            return True"
                    },
                    {
                        "username": "gopalbhalani137",
                        "content": "can anyone suggest me why this  code is not working?\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=1e5+10;\\n        int b[n];\\n        int flag;\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            b[nums[i]]++;\\n        }\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            if(b[i]>1)\\n            {\\n                flag=1;\\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n           return false;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "Sufiyan_Manihar",
                        "content": "what wrong in this!!!\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i = 0; i <nums.size(); i++)\\n         for (int j=i+1; j< nums.size(); j++)\\n                if (nums[i]==nums[j])\\n                    return true;      \\n    \\nreturn false;\\n    }\\n};"
                    },
                    {
                        "username": "Anshleet1",
                        "content": "        Arrays.sort(nums);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1]) return true;\\n        }\\n        return false;"
                    },
                    {
                        "username": "AkRadhe",
                        "content": "Easy Solution using set..\\n\\n set<int>val;\\n        for(int i=0;i<nums.size();i++)\\n        val.insert(nums[i]);\\n        if(val.size()==nums.size())\\n        return false;\\n        return true;"
                    },
                    {
                        "username": "BlakeAghili",
                        "content": "The description of question does not match the solutions provided. The solution thinks it should return true if there is at least one number that has a duplicate. That\\'s why it returns True for [1,1,2,3] but the description of problem wants you to return true if EVERY numbe has a duplicate which means [1,1,2,3] should return FALSE because obviously 2 and 3 don\\'t have dups in that goddamn array WTF man who wrote this question . "
                    },
                    {
                        "username": "anshumanatrey",
                        "content": "I was using double for loop but test case time limit exceeded, if it happens to you use sort function \n `sort(nums.begin(), nums.end());`\nand 1 for loop with if statement to check next element is same or not.\n `if (nums[a]==nums[a+1])`\n"
                    }
                ]
            },
            {
                "id": 1859156,
                "content": [
                    {
                        "username": "Manjula_171103",
                        "content": "how to print atleast twice in a array"
                    },
                    {
                        "username": "ivar7x",
                        "content": "using for loop :)"
                    },
                    {
                        "username": "nishthajoshi",
                        "content": "can\\'t we do it to soemthing silimar to Moore\\'s Voting algorithm? we can have a counter variable to track if a number has occured twice....if it has simply return true? please help"
                    },
                    {
                        "username": "Soumya_The_Legend",
                        "content": "I don\\'t understand why this code does not work for the test case [1,2,3,1]:\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int, int> mpp;\\n        for(int i=0; i< nums.size(); i++){\\n            if(mpp[nums[i]] >= 2){\\n                return true;\\n            } \\n            else{\\n                mpp[nums[i]]++;\\n            }\\n        }\\n        return false;\\n    }\\n"
                    },
                    {
                        "username": "irfanirfan0239",
                        "content": "check this solution in python  .\nhttps://leetcode.com/problems/contains-duplicate/submissions/956362537/\n \nor \nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        if len(nums)==len(set(nums)):\n            return False\n        else:\n            return True"
                    },
                    {
                        "username": "gopalbhalani137",
                        "content": "can anyone suggest me why this  code is not working?\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=1e5+10;\\n        int b[n];\\n        int flag;\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            b[nums[i]]++;\\n        }\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            if(b[i]>1)\\n            {\\n                flag=1;\\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n           return false;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "Sufiyan_Manihar",
                        "content": "what wrong in this!!!\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i = 0; i <nums.size(); i++)\\n         for (int j=i+1; j< nums.size(); j++)\\n                if (nums[i]==nums[j])\\n                    return true;      \\n    \\nreturn false;\\n    }\\n};"
                    },
                    {
                        "username": "Anshleet1",
                        "content": "        Arrays.sort(nums);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1]) return true;\\n        }\\n        return false;"
                    },
                    {
                        "username": "AkRadhe",
                        "content": "Easy Solution using set..\\n\\n set<int>val;\\n        for(int i=0;i<nums.size();i++)\\n        val.insert(nums[i]);\\n        if(val.size()==nums.size())\\n        return false;\\n        return true;"
                    },
                    {
                        "username": "BlakeAghili",
                        "content": "The description of question does not match the solutions provided. The solution thinks it should return true if there is at least one number that has a duplicate. That\\'s why it returns True for [1,1,2,3] but the description of problem wants you to return true if EVERY numbe has a duplicate which means [1,1,2,3] should return FALSE because obviously 2 and 3 don\\'t have dups in that goddamn array WTF man who wrote this question . "
                    },
                    {
                        "username": "anshumanatrey",
                        "content": "I was using double for loop but test case time limit exceeded, if it happens to you use sort function \n `sort(nums.begin(), nums.end());`\nand 1 for loop with if statement to check next element is same or not.\n `if (nums[a]==nums[a+1])`\n"
                    }
                ]
            },
            {
                "id": 1858804,
                "content": [
                    {
                        "username": "Manjula_171103",
                        "content": "how to print atleast twice in a array"
                    },
                    {
                        "username": "ivar7x",
                        "content": "using for loop :)"
                    },
                    {
                        "username": "nishthajoshi",
                        "content": "can\\'t we do it to soemthing silimar to Moore\\'s Voting algorithm? we can have a counter variable to track if a number has occured twice....if it has simply return true? please help"
                    },
                    {
                        "username": "Soumya_The_Legend",
                        "content": "I don\\'t understand why this code does not work for the test case [1,2,3,1]:\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int, int> mpp;\\n        for(int i=0; i< nums.size(); i++){\\n            if(mpp[nums[i]] >= 2){\\n                return true;\\n            } \\n            else{\\n                mpp[nums[i]]++;\\n            }\\n        }\\n        return false;\\n    }\\n"
                    },
                    {
                        "username": "irfanirfan0239",
                        "content": "check this solution in python  .\nhttps://leetcode.com/problems/contains-duplicate/submissions/956362537/\n \nor \nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        if len(nums)==len(set(nums)):\n            return False\n        else:\n            return True"
                    },
                    {
                        "username": "gopalbhalani137",
                        "content": "can anyone suggest me why this  code is not working?\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=1e5+10;\\n        int b[n];\\n        int flag;\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            b[nums[i]]++;\\n        }\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            if(b[i]>1)\\n            {\\n                flag=1;\\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n           return false;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "Sufiyan_Manihar",
                        "content": "what wrong in this!!!\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i = 0; i <nums.size(); i++)\\n         for (int j=i+1; j< nums.size(); j++)\\n                if (nums[i]==nums[j])\\n                    return true;      \\n    \\nreturn false;\\n    }\\n};"
                    },
                    {
                        "username": "Anshleet1",
                        "content": "        Arrays.sort(nums);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1]) return true;\\n        }\\n        return false;"
                    },
                    {
                        "username": "AkRadhe",
                        "content": "Easy Solution using set..\\n\\n set<int>val;\\n        for(int i=0;i<nums.size();i++)\\n        val.insert(nums[i]);\\n        if(val.size()==nums.size())\\n        return false;\\n        return true;"
                    },
                    {
                        "username": "BlakeAghili",
                        "content": "The description of question does not match the solutions provided. The solution thinks it should return true if there is at least one number that has a duplicate. That\\'s why it returns True for [1,1,2,3] but the description of problem wants you to return true if EVERY numbe has a duplicate which means [1,1,2,3] should return FALSE because obviously 2 and 3 don\\'t have dups in that goddamn array WTF man who wrote this question . "
                    },
                    {
                        "username": "anshumanatrey",
                        "content": "I was using double for loop but test case time limit exceeded, if it happens to you use sort function \n `sort(nums.begin(), nums.end());`\nand 1 for loop with if statement to check next element is same or not.\n `if (nums[a]==nums[a+1])`\n"
                    }
                ]
            },
            {
                "id": 1856703,
                "content": [
                    {
                        "username": "Manjula_171103",
                        "content": "how to print atleast twice in a array"
                    },
                    {
                        "username": "ivar7x",
                        "content": "using for loop :)"
                    },
                    {
                        "username": "nishthajoshi",
                        "content": "can\\'t we do it to soemthing silimar to Moore\\'s Voting algorithm? we can have a counter variable to track if a number has occured twice....if it has simply return true? please help"
                    },
                    {
                        "username": "Soumya_The_Legend",
                        "content": "I don\\'t understand why this code does not work for the test case [1,2,3,1]:\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int, int> mpp;\\n        for(int i=0; i< nums.size(); i++){\\n            if(mpp[nums[i]] >= 2){\\n                return true;\\n            } \\n            else{\\n                mpp[nums[i]]++;\\n            }\\n        }\\n        return false;\\n    }\\n"
                    },
                    {
                        "username": "irfanirfan0239",
                        "content": "check this solution in python  .\nhttps://leetcode.com/problems/contains-duplicate/submissions/956362537/\n \nor \nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        if len(nums)==len(set(nums)):\n            return False\n        else:\n            return True"
                    },
                    {
                        "username": "gopalbhalani137",
                        "content": "can anyone suggest me why this  code is not working?\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=1e5+10;\\n        int b[n];\\n        int flag;\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            b[nums[i]]++;\\n        }\\n        for(int i=0;i<sizeof(b);i++)\\n        {\\n            if(b[i]>1)\\n            {\\n                flag=1;\\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n           return false;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "Sufiyan_Manihar",
                        "content": "what wrong in this!!!\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i = 0; i <nums.size(); i++)\\n         for (int j=i+1; j< nums.size(); j++)\\n                if (nums[i]==nums[j])\\n                    return true;      \\n    \\nreturn false;\\n    }\\n};"
                    },
                    {
                        "username": "Anshleet1",
                        "content": "        Arrays.sort(nums);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1]) return true;\\n        }\\n        return false;"
                    },
                    {
                        "username": "AkRadhe",
                        "content": "Easy Solution using set..\\n\\n set<int>val;\\n        for(int i=0;i<nums.size();i++)\\n        val.insert(nums[i]);\\n        if(val.size()==nums.size())\\n        return false;\\n        return true;"
                    },
                    {
                        "username": "BlakeAghili",
                        "content": "The description of question does not match the solutions provided. The solution thinks it should return true if there is at least one number that has a duplicate. That\\'s why it returns True for [1,1,2,3] but the description of problem wants you to return true if EVERY numbe has a duplicate which means [1,1,2,3] should return FALSE because obviously 2 and 3 don\\'t have dups in that goddamn array WTF man who wrote this question . "
                    },
                    {
                        "username": "anshumanatrey",
                        "content": "I was using double for loop but test case time limit exceeded, if it happens to you use sort function \n `sort(nums.begin(), nums.end());`\nand 1 for loop with if statement to check next element is same or not.\n `if (nums[a]==nums[a+1])`\n"
                    }
                ]
            },
            {
                "id": 1852910,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Hint:**\\n\\nAsk yourself how to store each element and its appearance?"
                    },
                    {
                        "username": "shreyaspatil173",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n\\nthis code i have copy and pate to my intellije idle but it not work so how can i run ?\\n\\nalso \\npackage Array;\\n\\nimport java.util.Arrays;\\n\\npublic class DuplicateArray {\\n    public static void main(String[] args) {\\n        int[] nums = {1,2,3,1};\\n        containsDuplicate(nums);\\n    }\\n    public static boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == nums[i+1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n also i have written this code but not shows any output it shows only below line\\nProcess finished with exit code 0 \\n\\nplzz help me "
                    },
                    {
                        "username": "Mikckel",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\n       unordered_set<int> seen;\\n\\n       for(int num: nums){\\n           if(seen.find(num) != seen.end())\\n                return true;\\n            else\\n                seen.insert(num);\\n       }\\n\\n       return false;"
                    },
                    {
                        "username": "mullm7676",
                        "content": "class Solution {\\n    public static boolean containsDuplicate(int[] nums) {\\n        int a = nums.length;\\n        for (int i = 1; i < a; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] == nums[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public static void main(String args[]) {\\n        int nums[] = { 1, 2, 3, 3, 4, 5, 5, 6 };\\n        System.out.println(containsDuplicate(nums));\\n    }\\n}"
                    },
                    {
                        "username": "Tharunika-balakrishnan",
                        "content": "Hello everyone ! i  10 testcases are not passing could anyone pls help me.\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) \\n    {\\n        int flag=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    flag=1;\\n                }\\n               \\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n    }    \\n};    \\n    \\n"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is this giving me the wrong answer for nums = [1, 2, 3, 4].\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        unique = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in unique:\\n                unique.append(nums[i])\\n                i += 1\\n            else: \\n                i += 1\\n                return (\\'true\\')\\n        if i == len(nums):\\n            return (\\'false\\')`"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "    for i in nums:\\n        return nums.count(i) > 1\\n\\nwhy my solution not working ?"
                    },
                    {
                        "username": "muhammadshahzaibpu",
                        "content": " `class Solution(object):\n    def containsDuplicate(self, nums):\n        newset = set()\n        for i in nums:\n            if i in newset:\n                return True\n            else:\n                newset.add(i)\n        return False`\n\n\n\n"
                    },
                    {
                        "username": "sainath81061",
                        "content": " bool flag = false;\\n        for(int i =0;i<nums.Length - 1; i++)\\n        {\\n            for(int j=i + 1; j < nums.Length; j++)\\n            {\\n                if (nums[i] == nums[j])\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n       return flag; "
                    },
                    {
                        "username": "ranjeetjena06",
                        "content": "\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n           for(int j=0;j<i;j++){\\n                if(nums[i]^nums[j]==0){\\n                    return true;\\n                }\\n           }\\n        }\\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1851903,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Hint:**\\n\\nAsk yourself how to store each element and its appearance?"
                    },
                    {
                        "username": "shreyaspatil173",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n\\nthis code i have copy and pate to my intellije idle but it not work so how can i run ?\\n\\nalso \\npackage Array;\\n\\nimport java.util.Arrays;\\n\\npublic class DuplicateArray {\\n    public static void main(String[] args) {\\n        int[] nums = {1,2,3,1};\\n        containsDuplicate(nums);\\n    }\\n    public static boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == nums[i+1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n also i have written this code but not shows any output it shows only below line\\nProcess finished with exit code 0 \\n\\nplzz help me "
                    },
                    {
                        "username": "Mikckel",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\n       unordered_set<int> seen;\\n\\n       for(int num: nums){\\n           if(seen.find(num) != seen.end())\\n                return true;\\n            else\\n                seen.insert(num);\\n       }\\n\\n       return false;"
                    },
                    {
                        "username": "mullm7676",
                        "content": "class Solution {\\n    public static boolean containsDuplicate(int[] nums) {\\n        int a = nums.length;\\n        for (int i = 1; i < a; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] == nums[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public static void main(String args[]) {\\n        int nums[] = { 1, 2, 3, 3, 4, 5, 5, 6 };\\n        System.out.println(containsDuplicate(nums));\\n    }\\n}"
                    },
                    {
                        "username": "Tharunika-balakrishnan",
                        "content": "Hello everyone ! i  10 testcases are not passing could anyone pls help me.\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) \\n    {\\n        int flag=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    flag=1;\\n                }\\n               \\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n    }    \\n};    \\n    \\n"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is this giving me the wrong answer for nums = [1, 2, 3, 4].\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        unique = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in unique:\\n                unique.append(nums[i])\\n                i += 1\\n            else: \\n                i += 1\\n                return (\\'true\\')\\n        if i == len(nums):\\n            return (\\'false\\')`"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "    for i in nums:\\n        return nums.count(i) > 1\\n\\nwhy my solution not working ?"
                    },
                    {
                        "username": "muhammadshahzaibpu",
                        "content": " `class Solution(object):\n    def containsDuplicate(self, nums):\n        newset = set()\n        for i in nums:\n            if i in newset:\n                return True\n            else:\n                newset.add(i)\n        return False`\n\n\n\n"
                    },
                    {
                        "username": "sainath81061",
                        "content": " bool flag = false;\\n        for(int i =0;i<nums.Length - 1; i++)\\n        {\\n            for(int j=i + 1; j < nums.Length; j++)\\n            {\\n                if (nums[i] == nums[j])\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n       return flag; "
                    },
                    {
                        "username": "ranjeetjena06",
                        "content": "\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n           for(int j=0;j<i;j++){\\n                if(nums[i]^nums[j]==0){\\n                    return true;\\n                }\\n           }\\n        }\\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1851466,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Hint:**\\n\\nAsk yourself how to store each element and its appearance?"
                    },
                    {
                        "username": "shreyaspatil173",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n\\nthis code i have copy and pate to my intellije idle but it not work so how can i run ?\\n\\nalso \\npackage Array;\\n\\nimport java.util.Arrays;\\n\\npublic class DuplicateArray {\\n    public static void main(String[] args) {\\n        int[] nums = {1,2,3,1};\\n        containsDuplicate(nums);\\n    }\\n    public static boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == nums[i+1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n also i have written this code but not shows any output it shows only below line\\nProcess finished with exit code 0 \\n\\nplzz help me "
                    },
                    {
                        "username": "Mikckel",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\n       unordered_set<int> seen;\\n\\n       for(int num: nums){\\n           if(seen.find(num) != seen.end())\\n                return true;\\n            else\\n                seen.insert(num);\\n       }\\n\\n       return false;"
                    },
                    {
                        "username": "mullm7676",
                        "content": "class Solution {\\n    public static boolean containsDuplicate(int[] nums) {\\n        int a = nums.length;\\n        for (int i = 1; i < a; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] == nums[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public static void main(String args[]) {\\n        int nums[] = { 1, 2, 3, 3, 4, 5, 5, 6 };\\n        System.out.println(containsDuplicate(nums));\\n    }\\n}"
                    },
                    {
                        "username": "Tharunika-balakrishnan",
                        "content": "Hello everyone ! i  10 testcases are not passing could anyone pls help me.\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) \\n    {\\n        int flag=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    flag=1;\\n                }\\n               \\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n    }    \\n};    \\n    \\n"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is this giving me the wrong answer for nums = [1, 2, 3, 4].\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        unique = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in unique:\\n                unique.append(nums[i])\\n                i += 1\\n            else: \\n                i += 1\\n                return (\\'true\\')\\n        if i == len(nums):\\n            return (\\'false\\')`"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "    for i in nums:\\n        return nums.count(i) > 1\\n\\nwhy my solution not working ?"
                    },
                    {
                        "username": "muhammadshahzaibpu",
                        "content": " `class Solution(object):\n    def containsDuplicate(self, nums):\n        newset = set()\n        for i in nums:\n            if i in newset:\n                return True\n            else:\n                newset.add(i)\n        return False`\n\n\n\n"
                    },
                    {
                        "username": "sainath81061",
                        "content": " bool flag = false;\\n        for(int i =0;i<nums.Length - 1; i++)\\n        {\\n            for(int j=i + 1; j < nums.Length; j++)\\n            {\\n                if (nums[i] == nums[j])\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n       return flag; "
                    },
                    {
                        "username": "ranjeetjena06",
                        "content": "\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n           for(int j=0;j<i;j++){\\n                if(nums[i]^nums[j]==0){\\n                    return true;\\n                }\\n           }\\n        }\\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1846466,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Hint:**\\n\\nAsk yourself how to store each element and its appearance?"
                    },
                    {
                        "username": "shreyaspatil173",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n\\nthis code i have copy and pate to my intellije idle but it not work so how can i run ?\\n\\nalso \\npackage Array;\\n\\nimport java.util.Arrays;\\n\\npublic class DuplicateArray {\\n    public static void main(String[] args) {\\n        int[] nums = {1,2,3,1};\\n        containsDuplicate(nums);\\n    }\\n    public static boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == nums[i+1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n also i have written this code but not shows any output it shows only below line\\nProcess finished with exit code 0 \\n\\nplzz help me "
                    },
                    {
                        "username": "Mikckel",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\n       unordered_set<int> seen;\\n\\n       for(int num: nums){\\n           if(seen.find(num) != seen.end())\\n                return true;\\n            else\\n                seen.insert(num);\\n       }\\n\\n       return false;"
                    },
                    {
                        "username": "mullm7676",
                        "content": "class Solution {\\n    public static boolean containsDuplicate(int[] nums) {\\n        int a = nums.length;\\n        for (int i = 1; i < a; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] == nums[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public static void main(String args[]) {\\n        int nums[] = { 1, 2, 3, 3, 4, 5, 5, 6 };\\n        System.out.println(containsDuplicate(nums));\\n    }\\n}"
                    },
                    {
                        "username": "Tharunika-balakrishnan",
                        "content": "Hello everyone ! i  10 testcases are not passing could anyone pls help me.\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) \\n    {\\n        int flag=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    flag=1;\\n                }\\n               \\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n    }    \\n};    \\n    \\n"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is this giving me the wrong answer for nums = [1, 2, 3, 4].\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        unique = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in unique:\\n                unique.append(nums[i])\\n                i += 1\\n            else: \\n                i += 1\\n                return (\\'true\\')\\n        if i == len(nums):\\n            return (\\'false\\')`"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "    for i in nums:\\n        return nums.count(i) > 1\\n\\nwhy my solution not working ?"
                    },
                    {
                        "username": "muhammadshahzaibpu",
                        "content": " `class Solution(object):\n    def containsDuplicate(self, nums):\n        newset = set()\n        for i in nums:\n            if i in newset:\n                return True\n            else:\n                newset.add(i)\n        return False`\n\n\n\n"
                    },
                    {
                        "username": "sainath81061",
                        "content": " bool flag = false;\\n        for(int i =0;i<nums.Length - 1; i++)\\n        {\\n            for(int j=i + 1; j < nums.Length; j++)\\n            {\\n                if (nums[i] == nums[j])\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n       return flag; "
                    },
                    {
                        "username": "ranjeetjena06",
                        "content": "\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n           for(int j=0;j<i;j++){\\n                if(nums[i]^nums[j]==0){\\n                    return true;\\n                }\\n           }\\n        }\\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1841500,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Hint:**\\n\\nAsk yourself how to store each element and its appearance?"
                    },
                    {
                        "username": "shreyaspatil173",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n\\nthis code i have copy and pate to my intellije idle but it not work so how can i run ?\\n\\nalso \\npackage Array;\\n\\nimport java.util.Arrays;\\n\\npublic class DuplicateArray {\\n    public static void main(String[] args) {\\n        int[] nums = {1,2,3,1};\\n        containsDuplicate(nums);\\n    }\\n    public static boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == nums[i+1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n also i have written this code but not shows any output it shows only below line\\nProcess finished with exit code 0 \\n\\nplzz help me "
                    },
                    {
                        "username": "Mikckel",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\n       unordered_set<int> seen;\\n\\n       for(int num: nums){\\n           if(seen.find(num) != seen.end())\\n                return true;\\n            else\\n                seen.insert(num);\\n       }\\n\\n       return false;"
                    },
                    {
                        "username": "mullm7676",
                        "content": "class Solution {\\n    public static boolean containsDuplicate(int[] nums) {\\n        int a = nums.length;\\n        for (int i = 1; i < a; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] == nums[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public static void main(String args[]) {\\n        int nums[] = { 1, 2, 3, 3, 4, 5, 5, 6 };\\n        System.out.println(containsDuplicate(nums));\\n    }\\n}"
                    },
                    {
                        "username": "Tharunika-balakrishnan",
                        "content": "Hello everyone ! i  10 testcases are not passing could anyone pls help me.\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) \\n    {\\n        int flag=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    flag=1;\\n                }\\n               \\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n    }    \\n};    \\n    \\n"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is this giving me the wrong answer for nums = [1, 2, 3, 4].\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        unique = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in unique:\\n                unique.append(nums[i])\\n                i += 1\\n            else: \\n                i += 1\\n                return (\\'true\\')\\n        if i == len(nums):\\n            return (\\'false\\')`"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "    for i in nums:\\n        return nums.count(i) > 1\\n\\nwhy my solution not working ?"
                    },
                    {
                        "username": "muhammadshahzaibpu",
                        "content": " `class Solution(object):\n    def containsDuplicate(self, nums):\n        newset = set()\n        for i in nums:\n            if i in newset:\n                return True\n            else:\n                newset.add(i)\n        return False`\n\n\n\n"
                    },
                    {
                        "username": "sainath81061",
                        "content": " bool flag = false;\\n        for(int i =0;i<nums.Length - 1; i++)\\n        {\\n            for(int j=i + 1; j < nums.Length; j++)\\n            {\\n                if (nums[i] == nums[j])\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n       return flag; "
                    },
                    {
                        "username": "ranjeetjena06",
                        "content": "\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n           for(int j=0;j<i;j++){\\n                if(nums[i]^nums[j]==0){\\n                    return true;\\n                }\\n           }\\n        }\\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1840787,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Hint:**\\n\\nAsk yourself how to store each element and its appearance?"
                    },
                    {
                        "username": "shreyaspatil173",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n\\nthis code i have copy and pate to my intellije idle but it not work so how can i run ?\\n\\nalso \\npackage Array;\\n\\nimport java.util.Arrays;\\n\\npublic class DuplicateArray {\\n    public static void main(String[] args) {\\n        int[] nums = {1,2,3,1};\\n        containsDuplicate(nums);\\n    }\\n    public static boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == nums[i+1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n also i have written this code but not shows any output it shows only below line\\nProcess finished with exit code 0 \\n\\nplzz help me "
                    },
                    {
                        "username": "Mikckel",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\n       unordered_set<int> seen;\\n\\n       for(int num: nums){\\n           if(seen.find(num) != seen.end())\\n                return true;\\n            else\\n                seen.insert(num);\\n       }\\n\\n       return false;"
                    },
                    {
                        "username": "mullm7676",
                        "content": "class Solution {\\n    public static boolean containsDuplicate(int[] nums) {\\n        int a = nums.length;\\n        for (int i = 1; i < a; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] == nums[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public static void main(String args[]) {\\n        int nums[] = { 1, 2, 3, 3, 4, 5, 5, 6 };\\n        System.out.println(containsDuplicate(nums));\\n    }\\n}"
                    },
                    {
                        "username": "Tharunika-balakrishnan",
                        "content": "Hello everyone ! i  10 testcases are not passing could anyone pls help me.\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) \\n    {\\n        int flag=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    flag=1;\\n                }\\n               \\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n    }    \\n};    \\n    \\n"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is this giving me the wrong answer for nums = [1, 2, 3, 4].\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        unique = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in unique:\\n                unique.append(nums[i])\\n                i += 1\\n            else: \\n                i += 1\\n                return (\\'true\\')\\n        if i == len(nums):\\n            return (\\'false\\')`"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "    for i in nums:\\n        return nums.count(i) > 1\\n\\nwhy my solution not working ?"
                    },
                    {
                        "username": "muhammadshahzaibpu",
                        "content": " `class Solution(object):\n    def containsDuplicate(self, nums):\n        newset = set()\n        for i in nums:\n            if i in newset:\n                return True\n            else:\n                newset.add(i)\n        return False`\n\n\n\n"
                    },
                    {
                        "username": "sainath81061",
                        "content": " bool flag = false;\\n        for(int i =0;i<nums.Length - 1; i++)\\n        {\\n            for(int j=i + 1; j < nums.Length; j++)\\n            {\\n                if (nums[i] == nums[j])\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n       return flag; "
                    },
                    {
                        "username": "ranjeetjena06",
                        "content": "\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n           for(int j=0;j<i;j++){\\n                if(nums[i]^nums[j]==0){\\n                    return true;\\n                }\\n           }\\n        }\\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1835313,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Hint:**\\n\\nAsk yourself how to store each element and its appearance?"
                    },
                    {
                        "username": "shreyaspatil173",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n\\nthis code i have copy and pate to my intellije idle but it not work so how can i run ?\\n\\nalso \\npackage Array;\\n\\nimport java.util.Arrays;\\n\\npublic class DuplicateArray {\\n    public static void main(String[] args) {\\n        int[] nums = {1,2,3,1};\\n        containsDuplicate(nums);\\n    }\\n    public static boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == nums[i+1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n also i have written this code but not shows any output it shows only below line\\nProcess finished with exit code 0 \\n\\nplzz help me "
                    },
                    {
                        "username": "Mikckel",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\n       unordered_set<int> seen;\\n\\n       for(int num: nums){\\n           if(seen.find(num) != seen.end())\\n                return true;\\n            else\\n                seen.insert(num);\\n       }\\n\\n       return false;"
                    },
                    {
                        "username": "mullm7676",
                        "content": "class Solution {\\n    public static boolean containsDuplicate(int[] nums) {\\n        int a = nums.length;\\n        for (int i = 1; i < a; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] == nums[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public static void main(String args[]) {\\n        int nums[] = { 1, 2, 3, 3, 4, 5, 5, 6 };\\n        System.out.println(containsDuplicate(nums));\\n    }\\n}"
                    },
                    {
                        "username": "Tharunika-balakrishnan",
                        "content": "Hello everyone ! i  10 testcases are not passing could anyone pls help me.\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) \\n    {\\n        int flag=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    flag=1;\\n                }\\n               \\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n    }    \\n};    \\n    \\n"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is this giving me the wrong answer for nums = [1, 2, 3, 4].\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        unique = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in unique:\\n                unique.append(nums[i])\\n                i += 1\\n            else: \\n                i += 1\\n                return (\\'true\\')\\n        if i == len(nums):\\n            return (\\'false\\')`"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "    for i in nums:\\n        return nums.count(i) > 1\\n\\nwhy my solution not working ?"
                    },
                    {
                        "username": "muhammadshahzaibpu",
                        "content": " `class Solution(object):\n    def containsDuplicate(self, nums):\n        newset = set()\n        for i in nums:\n            if i in newset:\n                return True\n            else:\n                newset.add(i)\n        return False`\n\n\n\n"
                    },
                    {
                        "username": "sainath81061",
                        "content": " bool flag = false;\\n        for(int i =0;i<nums.Length - 1; i++)\\n        {\\n            for(int j=i + 1; j < nums.Length; j++)\\n            {\\n                if (nums[i] == nums[j])\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n       return flag; "
                    },
                    {
                        "username": "ranjeetjena06",
                        "content": "\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n           for(int j=0;j<i;j++){\\n                if(nums[i]^nums[j]==0){\\n                    return true;\\n                }\\n           }\\n        }\\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1829086,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Hint:**\\n\\nAsk yourself how to store each element and its appearance?"
                    },
                    {
                        "username": "shreyaspatil173",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n\\nthis code i have copy and pate to my intellije idle but it not work so how can i run ?\\n\\nalso \\npackage Array;\\n\\nimport java.util.Arrays;\\n\\npublic class DuplicateArray {\\n    public static void main(String[] args) {\\n        int[] nums = {1,2,3,1};\\n        containsDuplicate(nums);\\n    }\\n    public static boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == nums[i+1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n also i have written this code but not shows any output it shows only below line\\nProcess finished with exit code 0 \\n\\nplzz help me "
                    },
                    {
                        "username": "Mikckel",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\n       unordered_set<int> seen;\\n\\n       for(int num: nums){\\n           if(seen.find(num) != seen.end())\\n                return true;\\n            else\\n                seen.insert(num);\\n       }\\n\\n       return false;"
                    },
                    {
                        "username": "mullm7676",
                        "content": "class Solution {\\n    public static boolean containsDuplicate(int[] nums) {\\n        int a = nums.length;\\n        for (int i = 1; i < a; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] == nums[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public static void main(String args[]) {\\n        int nums[] = { 1, 2, 3, 3, 4, 5, 5, 6 };\\n        System.out.println(containsDuplicate(nums));\\n    }\\n}"
                    },
                    {
                        "username": "Tharunika-balakrishnan",
                        "content": "Hello everyone ! i  10 testcases are not passing could anyone pls help me.\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) \\n    {\\n        int flag=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    flag=1;\\n                }\\n               \\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n    }    \\n};    \\n    \\n"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is this giving me the wrong answer for nums = [1, 2, 3, 4].\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        unique = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in unique:\\n                unique.append(nums[i])\\n                i += 1\\n            else: \\n                i += 1\\n                return (\\'true\\')\\n        if i == len(nums):\\n            return (\\'false\\')`"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "    for i in nums:\\n        return nums.count(i) > 1\\n\\nwhy my solution not working ?"
                    },
                    {
                        "username": "muhammadshahzaibpu",
                        "content": " `class Solution(object):\n    def containsDuplicate(self, nums):\n        newset = set()\n        for i in nums:\n            if i in newset:\n                return True\n            else:\n                newset.add(i)\n        return False`\n\n\n\n"
                    },
                    {
                        "username": "sainath81061",
                        "content": " bool flag = false;\\n        for(int i =0;i<nums.Length - 1; i++)\\n        {\\n            for(int j=i + 1; j < nums.Length; j++)\\n            {\\n                if (nums[i] == nums[j])\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n       return flag; "
                    },
                    {
                        "username": "ranjeetjena06",
                        "content": "\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n           for(int j=0;j<i;j++){\\n                if(nums[i]^nums[j]==0){\\n                    return true;\\n                }\\n           }\\n        }\\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1814239,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Hint:**\\n\\nAsk yourself how to store each element and its appearance?"
                    },
                    {
                        "username": "shreyaspatil173",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n\\nthis code i have copy and pate to my intellije idle but it not work so how can i run ?\\n\\nalso \\npackage Array;\\n\\nimport java.util.Arrays;\\n\\npublic class DuplicateArray {\\n    public static void main(String[] args) {\\n        int[] nums = {1,2,3,1};\\n        containsDuplicate(nums);\\n    }\\n    public static boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == nums[i+1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n also i have written this code but not shows any output it shows only below line\\nProcess finished with exit code 0 \\n\\nplzz help me "
                    },
                    {
                        "username": "Mikckel",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\n       unordered_set<int> seen;\\n\\n       for(int num: nums){\\n           if(seen.find(num) != seen.end())\\n                return true;\\n            else\\n                seen.insert(num);\\n       }\\n\\n       return false;"
                    },
                    {
                        "username": "mullm7676",
                        "content": "class Solution {\\n    public static boolean containsDuplicate(int[] nums) {\\n        int a = nums.length;\\n        for (int i = 1; i < a; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] == nums[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public static void main(String args[]) {\\n        int nums[] = { 1, 2, 3, 3, 4, 5, 5, 6 };\\n        System.out.println(containsDuplicate(nums));\\n    }\\n}"
                    },
                    {
                        "username": "Tharunika-balakrishnan",
                        "content": "Hello everyone ! i  10 testcases are not passing could anyone pls help me.\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) \\n    {\\n        int flag=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    flag=1;\\n                }\\n               \\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n    }    \\n};    \\n    \\n"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is this giving me the wrong answer for nums = [1, 2, 3, 4].\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        unique = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in unique:\\n                unique.append(nums[i])\\n                i += 1\\n            else: \\n                i += 1\\n                return (\\'true\\')\\n        if i == len(nums):\\n            return (\\'false\\')`"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "    for i in nums:\\n        return nums.count(i) > 1\\n\\nwhy my solution not working ?"
                    },
                    {
                        "username": "muhammadshahzaibpu",
                        "content": " `class Solution(object):\n    def containsDuplicate(self, nums):\n        newset = set()\n        for i in nums:\n            if i in newset:\n                return True\n            else:\n                newset.add(i)\n        return False`\n\n\n\n"
                    },
                    {
                        "username": "sainath81061",
                        "content": " bool flag = false;\\n        for(int i =0;i<nums.Length - 1; i++)\\n        {\\n            for(int j=i + 1; j < nums.Length; j++)\\n            {\\n                if (nums[i] == nums[j])\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n       return flag; "
                    },
                    {
                        "username": "ranjeetjena06",
                        "content": "\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n           for(int j=0;j<i;j++){\\n                if(nums[i]^nums[j]==0){\\n                    return true;\\n                }\\n           }\\n        }\\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1813289,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "**Hint:**\\n\\nAsk yourself how to store each element and its appearance?"
                    },
                    {
                        "username": "shreyaspatil173",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums); \\n        for (int i = 0; i < nums.length - 1; i++) {\\n                if (nums[i] == nums[i+1]) {\\n                    return true;\\n                }\\n        }\\n        return false;\\n    }\\n}\\n\\nthis code i have copy and pate to my intellije idle but it not work so how can i run ?\\n\\nalso \\npackage Array;\\n\\nimport java.util.Arrays;\\n\\npublic class DuplicateArray {\\n    public static void main(String[] args) {\\n        int[] nums = {1,2,3,1};\\n        containsDuplicate(nums);\\n    }\\n    public static boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] == nums[i+1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n also i have written this code but not shows any output it shows only below line\\nProcess finished with exit code 0 \\n\\nplzz help me "
                    },
                    {
                        "username": "Mikckel",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\n       unordered_set<int> seen;\\n\\n       for(int num: nums){\\n           if(seen.find(num) != seen.end())\\n                return true;\\n            else\\n                seen.insert(num);\\n       }\\n\\n       return false;"
                    },
                    {
                        "username": "mullm7676",
                        "content": "class Solution {\\n    public static boolean containsDuplicate(int[] nums) {\\n        int a = nums.length;\\n        for (int i = 1; i < a; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] == nums[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public static void main(String args[]) {\\n        int nums[] = { 1, 2, 3, 3, 4, 5, 5, 6 };\\n        System.out.println(containsDuplicate(nums));\\n    }\\n}"
                    },
                    {
                        "username": "Tharunika-balakrishnan",
                        "content": "Hello everyone ! i  10 testcases are not passing could anyone pls help me.\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) \\n    {\\n        int flag=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]==nums[j])\\n                {\\n                    flag=1;\\n                }\\n               \\n            }\\n        }\\n        if(flag==1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n    }    \\n};    \\n    \\n"
                    },
                    {
                        "username": "kaveri1184",
                        "content": "why is this giving me the wrong answer for nums = [1, 2, 3, 4].\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        unique = []\\n        i = 0\\n        while i < len(nums):\\n            if nums[i] not in unique:\\n                unique.append(nums[i])\\n                i += 1\\n            else: \\n                i += 1\\n                return (\\'true\\')\\n        if i == len(nums):\\n            return (\\'false\\')`"
                    },
                    {
                        "username": "aleazanrashid",
                        "content": "    for i in nums:\\n        return nums.count(i) > 1\\n\\nwhy my solution not working ?"
                    },
                    {
                        "username": "muhammadshahzaibpu",
                        "content": " `class Solution(object):\n    def containsDuplicate(self, nums):\n        newset = set()\n        for i in nums:\n            if i in newset:\n                return True\n            else:\n                newset.add(i)\n        return False`\n\n\n\n"
                    },
                    {
                        "username": "sainath81061",
                        "content": " bool flag = false;\\n        for(int i =0;i<nums.Length - 1; i++)\\n        {\\n            for(int j=i + 1; j < nums.Length; j++)\\n            {\\n                if (nums[i] == nums[j])\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n       return flag; "
                    },
                    {
                        "username": "ranjeetjena06",
                        "content": "\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int s=0;\\n        for(int i=0;i<n;i++){\\n           for(int j=0;j<i;j++){\\n                if(nums[i]^nums[j]==0){\\n                    return true;\\n                }\\n           }\\n        }\\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1813225,
                "content": [
                    {
                        "username": "pamaAmo",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize-1;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }\\n        }\\n    \\n    }\\n    return false;\\n}\\ncan anybody help I m not getting what\\'s wrong ?\\nits not verifying few testcases"
                    },
                    {
                        "username": "Parvesh_Kumar",
                        "content": "why its showing time limit exceeds\\n"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "when I am adding elements in list it is showing TIME LIMIT EXCEED but using same concept with set it isworking perfectly\\nCanany one plzz explain me this"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "while i!=len(nums):\\n           \\n            if nums[i] == nums[i+1]:\\n\\nwhy this condition is showing error"
                    },
                    {
                        "username": "dowlurisatyaashok",
                        "content": "Flow:\\n    max of nums[]\\n    declare empty array with above as max limit + 1\\n    increase the values of new array as per the index\\n    return value based on values of the array <=1 "
                    },
                    {
                        "username": "HexFeather",
                        "content": "I'm noticing I'm repeatedly getting Time Limit Exceeded on the last test, this is my solution:\n\n```rs\nimpl Solution {\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\n        let mut arr: Vec<i32> = vec![];\n\n        for (i, num) in nums.iter().enumerate() {\n            if arr.contains(&num) { return true; }\n            arr.push(*num);\n        }\n\n        false\n    }\n}\n```"
                    },
                    {
                        "username": "kaustubhpatil2332",
                        "content": "  set<int> convertToset(vector<int> & nums){\\n        set<int> s;\\n        for(int x: nums){\\n            s.insert(x);\\n        }\\n        return s;\\n    }\\n    bool containsDuplicate(vector<int>& nums) {\\n set<int> s = convertToset(nums);\\n      set<int>nums;\\n     if(nums.size()==s.size())\\n     {\\n         return false;\\n     }\\n     else \\n     return true;\\n    }"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "    (Python3)\nreturn len(nums) != len(set(nums))"
                    },
                    {
                        "username": "user8195Xq",
                        "content": "Hi, i just can\\'t understand what is the problem with my code. i\\'m sure it is supposed to work...\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        int count=0;\\n        for(int i=0; i<=nums.length; i++){\\n            for(int j=0; j<=nums.length;j++){\\n                 if(nums[i]==nums[j]){\\n                count++;\\n            }\\n            }\\n        }\\n        if(count>2){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "BGbasta",
                        "content": "change it to (int j = i + 1) and in the if check just return true. U don\\'t need counter"
                    },
                    {
                        "username": "killerxd95",
                        "content": "Python\nHey guys,\n\ncan somebody explain to me why this works\n        \n        array = {}\n        for n in nums:\n            if n in array:\n                return 1\n            array[n] = index\n        return 0\n\nbut if i change \"index\" to something else like \"value\" or \"i\"  than it bricks .... "
                    }
                ]
            },
            {
                "id": 1813018,
                "content": [
                    {
                        "username": "pamaAmo",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize-1;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }\\n        }\\n    \\n    }\\n    return false;\\n}\\ncan anybody help I m not getting what\\'s wrong ?\\nits not verifying few testcases"
                    },
                    {
                        "username": "Parvesh_Kumar",
                        "content": "why its showing time limit exceeds\\n"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "when I am adding elements in list it is showing TIME LIMIT EXCEED but using same concept with set it isworking perfectly\\nCanany one plzz explain me this"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "while i!=len(nums):\\n           \\n            if nums[i] == nums[i+1]:\\n\\nwhy this condition is showing error"
                    },
                    {
                        "username": "dowlurisatyaashok",
                        "content": "Flow:\\n    max of nums[]\\n    declare empty array with above as max limit + 1\\n    increase the values of new array as per the index\\n    return value based on values of the array <=1 "
                    },
                    {
                        "username": "HexFeather",
                        "content": "I'm noticing I'm repeatedly getting Time Limit Exceeded on the last test, this is my solution:\n\n```rs\nimpl Solution {\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\n        let mut arr: Vec<i32> = vec![];\n\n        for (i, num) in nums.iter().enumerate() {\n            if arr.contains(&num) { return true; }\n            arr.push(*num);\n        }\n\n        false\n    }\n}\n```"
                    },
                    {
                        "username": "kaustubhpatil2332",
                        "content": "  set<int> convertToset(vector<int> & nums){\\n        set<int> s;\\n        for(int x: nums){\\n            s.insert(x);\\n        }\\n        return s;\\n    }\\n    bool containsDuplicate(vector<int>& nums) {\\n set<int> s = convertToset(nums);\\n      set<int>nums;\\n     if(nums.size()==s.size())\\n     {\\n         return false;\\n     }\\n     else \\n     return true;\\n    }"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "    (Python3)\nreturn len(nums) != len(set(nums))"
                    },
                    {
                        "username": "user8195Xq",
                        "content": "Hi, i just can\\'t understand what is the problem with my code. i\\'m sure it is supposed to work...\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        int count=0;\\n        for(int i=0; i<=nums.length; i++){\\n            for(int j=0; j<=nums.length;j++){\\n                 if(nums[i]==nums[j]){\\n                count++;\\n            }\\n            }\\n        }\\n        if(count>2){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "BGbasta",
                        "content": "change it to (int j = i + 1) and in the if check just return true. U don\\'t need counter"
                    },
                    {
                        "username": "killerxd95",
                        "content": "Python\nHey guys,\n\ncan somebody explain to me why this works\n        \n        array = {}\n        for n in nums:\n            if n in array:\n                return 1\n            array[n] = index\n        return 0\n\nbut if i change \"index\" to something else like \"value\" or \"i\"  than it bricks .... "
                    }
                ]
            },
            {
                "id": 1811593,
                "content": [
                    {
                        "username": "pamaAmo",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize-1;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }\\n        }\\n    \\n    }\\n    return false;\\n}\\ncan anybody help I m not getting what\\'s wrong ?\\nits not verifying few testcases"
                    },
                    {
                        "username": "Parvesh_Kumar",
                        "content": "why its showing time limit exceeds\\n"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "when I am adding elements in list it is showing TIME LIMIT EXCEED but using same concept with set it isworking perfectly\\nCanany one plzz explain me this"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "while i!=len(nums):\\n           \\n            if nums[i] == nums[i+1]:\\n\\nwhy this condition is showing error"
                    },
                    {
                        "username": "dowlurisatyaashok",
                        "content": "Flow:\\n    max of nums[]\\n    declare empty array with above as max limit + 1\\n    increase the values of new array as per the index\\n    return value based on values of the array <=1 "
                    },
                    {
                        "username": "HexFeather",
                        "content": "I'm noticing I'm repeatedly getting Time Limit Exceeded on the last test, this is my solution:\n\n```rs\nimpl Solution {\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\n        let mut arr: Vec<i32> = vec![];\n\n        for (i, num) in nums.iter().enumerate() {\n            if arr.contains(&num) { return true; }\n            arr.push(*num);\n        }\n\n        false\n    }\n}\n```"
                    },
                    {
                        "username": "kaustubhpatil2332",
                        "content": "  set<int> convertToset(vector<int> & nums){\\n        set<int> s;\\n        for(int x: nums){\\n            s.insert(x);\\n        }\\n        return s;\\n    }\\n    bool containsDuplicate(vector<int>& nums) {\\n set<int> s = convertToset(nums);\\n      set<int>nums;\\n     if(nums.size()==s.size())\\n     {\\n         return false;\\n     }\\n     else \\n     return true;\\n    }"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "    (Python3)\nreturn len(nums) != len(set(nums))"
                    },
                    {
                        "username": "user8195Xq",
                        "content": "Hi, i just can\\'t understand what is the problem with my code. i\\'m sure it is supposed to work...\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        int count=0;\\n        for(int i=0; i<=nums.length; i++){\\n            for(int j=0; j<=nums.length;j++){\\n                 if(nums[i]==nums[j]){\\n                count++;\\n            }\\n            }\\n        }\\n        if(count>2){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "BGbasta",
                        "content": "change it to (int j = i + 1) and in the if check just return true. U don\\'t need counter"
                    },
                    {
                        "username": "killerxd95",
                        "content": "Python\nHey guys,\n\ncan somebody explain to me why this works\n        \n        array = {}\n        for n in nums:\n            if n in array:\n                return 1\n            array[n] = index\n        return 0\n\nbut if i change \"index\" to something else like \"value\" or \"i\"  than it bricks .... "
                    }
                ]
            },
            {
                "id": 1811582,
                "content": [
                    {
                        "username": "pamaAmo",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize-1;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }\\n        }\\n    \\n    }\\n    return false;\\n}\\ncan anybody help I m not getting what\\'s wrong ?\\nits not verifying few testcases"
                    },
                    {
                        "username": "Parvesh_Kumar",
                        "content": "why its showing time limit exceeds\\n"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "when I am adding elements in list it is showing TIME LIMIT EXCEED but using same concept with set it isworking perfectly\\nCanany one plzz explain me this"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "while i!=len(nums):\\n           \\n            if nums[i] == nums[i+1]:\\n\\nwhy this condition is showing error"
                    },
                    {
                        "username": "dowlurisatyaashok",
                        "content": "Flow:\\n    max of nums[]\\n    declare empty array with above as max limit + 1\\n    increase the values of new array as per the index\\n    return value based on values of the array <=1 "
                    },
                    {
                        "username": "HexFeather",
                        "content": "I'm noticing I'm repeatedly getting Time Limit Exceeded on the last test, this is my solution:\n\n```rs\nimpl Solution {\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\n        let mut arr: Vec<i32> = vec![];\n\n        for (i, num) in nums.iter().enumerate() {\n            if arr.contains(&num) { return true; }\n            arr.push(*num);\n        }\n\n        false\n    }\n}\n```"
                    },
                    {
                        "username": "kaustubhpatil2332",
                        "content": "  set<int> convertToset(vector<int> & nums){\\n        set<int> s;\\n        for(int x: nums){\\n            s.insert(x);\\n        }\\n        return s;\\n    }\\n    bool containsDuplicate(vector<int>& nums) {\\n set<int> s = convertToset(nums);\\n      set<int>nums;\\n     if(nums.size()==s.size())\\n     {\\n         return false;\\n     }\\n     else \\n     return true;\\n    }"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "    (Python3)\nreturn len(nums) != len(set(nums))"
                    },
                    {
                        "username": "user8195Xq",
                        "content": "Hi, i just can\\'t understand what is the problem with my code. i\\'m sure it is supposed to work...\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        int count=0;\\n        for(int i=0; i<=nums.length; i++){\\n            for(int j=0; j<=nums.length;j++){\\n                 if(nums[i]==nums[j]){\\n                count++;\\n            }\\n            }\\n        }\\n        if(count>2){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "BGbasta",
                        "content": "change it to (int j = i + 1) and in the if check just return true. U don\\'t need counter"
                    },
                    {
                        "username": "killerxd95",
                        "content": "Python\nHey guys,\n\ncan somebody explain to me why this works\n        \n        array = {}\n        for n in nums:\n            if n in array:\n                return 1\n            array[n] = index\n        return 0\n\nbut if i change \"index\" to something else like \"value\" or \"i\"  than it bricks .... "
                    }
                ]
            },
            {
                "id": 1809215,
                "content": [
                    {
                        "username": "pamaAmo",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize-1;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }\\n        }\\n    \\n    }\\n    return false;\\n}\\ncan anybody help I m not getting what\\'s wrong ?\\nits not verifying few testcases"
                    },
                    {
                        "username": "Parvesh_Kumar",
                        "content": "why its showing time limit exceeds\\n"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "when I am adding elements in list it is showing TIME LIMIT EXCEED but using same concept with set it isworking perfectly\\nCanany one plzz explain me this"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "while i!=len(nums):\\n           \\n            if nums[i] == nums[i+1]:\\n\\nwhy this condition is showing error"
                    },
                    {
                        "username": "dowlurisatyaashok",
                        "content": "Flow:\\n    max of nums[]\\n    declare empty array with above as max limit + 1\\n    increase the values of new array as per the index\\n    return value based on values of the array <=1 "
                    },
                    {
                        "username": "HexFeather",
                        "content": "I'm noticing I'm repeatedly getting Time Limit Exceeded on the last test, this is my solution:\n\n```rs\nimpl Solution {\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\n        let mut arr: Vec<i32> = vec![];\n\n        for (i, num) in nums.iter().enumerate() {\n            if arr.contains(&num) { return true; }\n            arr.push(*num);\n        }\n\n        false\n    }\n}\n```"
                    },
                    {
                        "username": "kaustubhpatil2332",
                        "content": "  set<int> convertToset(vector<int> & nums){\\n        set<int> s;\\n        for(int x: nums){\\n            s.insert(x);\\n        }\\n        return s;\\n    }\\n    bool containsDuplicate(vector<int>& nums) {\\n set<int> s = convertToset(nums);\\n      set<int>nums;\\n     if(nums.size()==s.size())\\n     {\\n         return false;\\n     }\\n     else \\n     return true;\\n    }"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "    (Python3)\nreturn len(nums) != len(set(nums))"
                    },
                    {
                        "username": "user8195Xq",
                        "content": "Hi, i just can\\'t understand what is the problem with my code. i\\'m sure it is supposed to work...\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        int count=0;\\n        for(int i=0; i<=nums.length; i++){\\n            for(int j=0; j<=nums.length;j++){\\n                 if(nums[i]==nums[j]){\\n                count++;\\n            }\\n            }\\n        }\\n        if(count>2){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "BGbasta",
                        "content": "change it to (int j = i + 1) and in the if check just return true. U don\\'t need counter"
                    },
                    {
                        "username": "killerxd95",
                        "content": "Python\nHey guys,\n\ncan somebody explain to me why this works\n        \n        array = {}\n        for n in nums:\n            if n in array:\n                return 1\n            array[n] = index\n        return 0\n\nbut if i change \"index\" to something else like \"value\" or \"i\"  than it bricks .... "
                    }
                ]
            },
            {
                "id": 1804947,
                "content": [
                    {
                        "username": "pamaAmo",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize-1;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }\\n        }\\n    \\n    }\\n    return false;\\n}\\ncan anybody help I m not getting what\\'s wrong ?\\nits not verifying few testcases"
                    },
                    {
                        "username": "Parvesh_Kumar",
                        "content": "why its showing time limit exceeds\\n"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "when I am adding elements in list it is showing TIME LIMIT EXCEED but using same concept with set it isworking perfectly\\nCanany one plzz explain me this"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "while i!=len(nums):\\n           \\n            if nums[i] == nums[i+1]:\\n\\nwhy this condition is showing error"
                    },
                    {
                        "username": "dowlurisatyaashok",
                        "content": "Flow:\\n    max of nums[]\\n    declare empty array with above as max limit + 1\\n    increase the values of new array as per the index\\n    return value based on values of the array <=1 "
                    },
                    {
                        "username": "HexFeather",
                        "content": "I'm noticing I'm repeatedly getting Time Limit Exceeded on the last test, this is my solution:\n\n```rs\nimpl Solution {\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\n        let mut arr: Vec<i32> = vec![];\n\n        for (i, num) in nums.iter().enumerate() {\n            if arr.contains(&num) { return true; }\n            arr.push(*num);\n        }\n\n        false\n    }\n}\n```"
                    },
                    {
                        "username": "kaustubhpatil2332",
                        "content": "  set<int> convertToset(vector<int> & nums){\\n        set<int> s;\\n        for(int x: nums){\\n            s.insert(x);\\n        }\\n        return s;\\n    }\\n    bool containsDuplicate(vector<int>& nums) {\\n set<int> s = convertToset(nums);\\n      set<int>nums;\\n     if(nums.size()==s.size())\\n     {\\n         return false;\\n     }\\n     else \\n     return true;\\n    }"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "    (Python3)\nreturn len(nums) != len(set(nums))"
                    },
                    {
                        "username": "user8195Xq",
                        "content": "Hi, i just can\\'t understand what is the problem with my code. i\\'m sure it is supposed to work...\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        int count=0;\\n        for(int i=0; i<=nums.length; i++){\\n            for(int j=0; j<=nums.length;j++){\\n                 if(nums[i]==nums[j]){\\n                count++;\\n            }\\n            }\\n        }\\n        if(count>2){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "BGbasta",
                        "content": "change it to (int j = i + 1) and in the if check just return true. U don\\'t need counter"
                    },
                    {
                        "username": "killerxd95",
                        "content": "Python\nHey guys,\n\ncan somebody explain to me why this works\n        \n        array = {}\n        for n in nums:\n            if n in array:\n                return 1\n            array[n] = index\n        return 0\n\nbut if i change \"index\" to something else like \"value\" or \"i\"  than it bricks .... "
                    }
                ]
            },
            {
                "id": 1801700,
                "content": [
                    {
                        "username": "pamaAmo",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize-1;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }\\n        }\\n    \\n    }\\n    return false;\\n}\\ncan anybody help I m not getting what\\'s wrong ?\\nits not verifying few testcases"
                    },
                    {
                        "username": "Parvesh_Kumar",
                        "content": "why its showing time limit exceeds\\n"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "when I am adding elements in list it is showing TIME LIMIT EXCEED but using same concept with set it isworking perfectly\\nCanany one plzz explain me this"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "while i!=len(nums):\\n           \\n            if nums[i] == nums[i+1]:\\n\\nwhy this condition is showing error"
                    },
                    {
                        "username": "dowlurisatyaashok",
                        "content": "Flow:\\n    max of nums[]\\n    declare empty array with above as max limit + 1\\n    increase the values of new array as per the index\\n    return value based on values of the array <=1 "
                    },
                    {
                        "username": "HexFeather",
                        "content": "I'm noticing I'm repeatedly getting Time Limit Exceeded on the last test, this is my solution:\n\n```rs\nimpl Solution {\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\n        let mut arr: Vec<i32> = vec![];\n\n        for (i, num) in nums.iter().enumerate() {\n            if arr.contains(&num) { return true; }\n            arr.push(*num);\n        }\n\n        false\n    }\n}\n```"
                    },
                    {
                        "username": "kaustubhpatil2332",
                        "content": "  set<int> convertToset(vector<int> & nums){\\n        set<int> s;\\n        for(int x: nums){\\n            s.insert(x);\\n        }\\n        return s;\\n    }\\n    bool containsDuplicate(vector<int>& nums) {\\n set<int> s = convertToset(nums);\\n      set<int>nums;\\n     if(nums.size()==s.size())\\n     {\\n         return false;\\n     }\\n     else \\n     return true;\\n    }"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "    (Python3)\nreturn len(nums) != len(set(nums))"
                    },
                    {
                        "username": "user8195Xq",
                        "content": "Hi, i just can\\'t understand what is the problem with my code. i\\'m sure it is supposed to work...\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        int count=0;\\n        for(int i=0; i<=nums.length; i++){\\n            for(int j=0; j<=nums.length;j++){\\n                 if(nums[i]==nums[j]){\\n                count++;\\n            }\\n            }\\n        }\\n        if(count>2){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "BGbasta",
                        "content": "change it to (int j = i + 1) and in the if check just return true. U don\\'t need counter"
                    },
                    {
                        "username": "killerxd95",
                        "content": "Python\nHey guys,\n\ncan somebody explain to me why this works\n        \n        array = {}\n        for n in nums:\n            if n in array:\n                return 1\n            array[n] = index\n        return 0\n\nbut if i change \"index\" to something else like \"value\" or \"i\"  than it bricks .... "
                    }
                ]
            },
            {
                "id": 1794813,
                "content": [
                    {
                        "username": "pamaAmo",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize-1;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }\\n        }\\n    \\n    }\\n    return false;\\n}\\ncan anybody help I m not getting what\\'s wrong ?\\nits not verifying few testcases"
                    },
                    {
                        "username": "Parvesh_Kumar",
                        "content": "why its showing time limit exceeds\\n"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "when I am adding elements in list it is showing TIME LIMIT EXCEED but using same concept with set it isworking perfectly\\nCanany one plzz explain me this"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "while i!=len(nums):\\n           \\n            if nums[i] == nums[i+1]:\\n\\nwhy this condition is showing error"
                    },
                    {
                        "username": "dowlurisatyaashok",
                        "content": "Flow:\\n    max of nums[]\\n    declare empty array with above as max limit + 1\\n    increase the values of new array as per the index\\n    return value based on values of the array <=1 "
                    },
                    {
                        "username": "HexFeather",
                        "content": "I'm noticing I'm repeatedly getting Time Limit Exceeded on the last test, this is my solution:\n\n```rs\nimpl Solution {\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\n        let mut arr: Vec<i32> = vec![];\n\n        for (i, num) in nums.iter().enumerate() {\n            if arr.contains(&num) { return true; }\n            arr.push(*num);\n        }\n\n        false\n    }\n}\n```"
                    },
                    {
                        "username": "kaustubhpatil2332",
                        "content": "  set<int> convertToset(vector<int> & nums){\\n        set<int> s;\\n        for(int x: nums){\\n            s.insert(x);\\n        }\\n        return s;\\n    }\\n    bool containsDuplicate(vector<int>& nums) {\\n set<int> s = convertToset(nums);\\n      set<int>nums;\\n     if(nums.size()==s.size())\\n     {\\n         return false;\\n     }\\n     else \\n     return true;\\n    }"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "    (Python3)\nreturn len(nums) != len(set(nums))"
                    },
                    {
                        "username": "user8195Xq",
                        "content": "Hi, i just can\\'t understand what is the problem with my code. i\\'m sure it is supposed to work...\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        int count=0;\\n        for(int i=0; i<=nums.length; i++){\\n            for(int j=0; j<=nums.length;j++){\\n                 if(nums[i]==nums[j]){\\n                count++;\\n            }\\n            }\\n        }\\n        if(count>2){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "BGbasta",
                        "content": "change it to (int j = i + 1) and in the if check just return true. U don\\'t need counter"
                    },
                    {
                        "username": "killerxd95",
                        "content": "Python\nHey guys,\n\ncan somebody explain to me why this works\n        \n        array = {}\n        for n in nums:\n            if n in array:\n                return 1\n            array[n] = index\n        return 0\n\nbut if i change \"index\" to something else like \"value\" or \"i\"  than it bricks .... "
                    }
                ]
            },
            {
                "id": 1794253,
                "content": [
                    {
                        "username": "pamaAmo",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize-1;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }\\n        }\\n    \\n    }\\n    return false;\\n}\\ncan anybody help I m not getting what\\'s wrong ?\\nits not verifying few testcases"
                    },
                    {
                        "username": "Parvesh_Kumar",
                        "content": "why its showing time limit exceeds\\n"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "when I am adding elements in list it is showing TIME LIMIT EXCEED but using same concept with set it isworking perfectly\\nCanany one plzz explain me this"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "while i!=len(nums):\\n           \\n            if nums[i] == nums[i+1]:\\n\\nwhy this condition is showing error"
                    },
                    {
                        "username": "dowlurisatyaashok",
                        "content": "Flow:\\n    max of nums[]\\n    declare empty array with above as max limit + 1\\n    increase the values of new array as per the index\\n    return value based on values of the array <=1 "
                    },
                    {
                        "username": "HexFeather",
                        "content": "I'm noticing I'm repeatedly getting Time Limit Exceeded on the last test, this is my solution:\n\n```rs\nimpl Solution {\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\n        let mut arr: Vec<i32> = vec![];\n\n        for (i, num) in nums.iter().enumerate() {\n            if arr.contains(&num) { return true; }\n            arr.push(*num);\n        }\n\n        false\n    }\n}\n```"
                    },
                    {
                        "username": "kaustubhpatil2332",
                        "content": "  set<int> convertToset(vector<int> & nums){\\n        set<int> s;\\n        for(int x: nums){\\n            s.insert(x);\\n        }\\n        return s;\\n    }\\n    bool containsDuplicate(vector<int>& nums) {\\n set<int> s = convertToset(nums);\\n      set<int>nums;\\n     if(nums.size()==s.size())\\n     {\\n         return false;\\n     }\\n     else \\n     return true;\\n    }"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "    (Python3)\nreturn len(nums) != len(set(nums))"
                    },
                    {
                        "username": "user8195Xq",
                        "content": "Hi, i just can\\'t understand what is the problem with my code. i\\'m sure it is supposed to work...\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        int count=0;\\n        for(int i=0; i<=nums.length; i++){\\n            for(int j=0; j<=nums.length;j++){\\n                 if(nums[i]==nums[j]){\\n                count++;\\n            }\\n            }\\n        }\\n        if(count>2){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "BGbasta",
                        "content": "change it to (int j = i + 1) and in the if check just return true. U don\\'t need counter"
                    },
                    {
                        "username": "killerxd95",
                        "content": "Python\nHey guys,\n\ncan somebody explain to me why this works\n        \n        array = {}\n        for n in nums:\n            if n in array:\n                return 1\n            array[n] = index\n        return 0\n\nbut if i change \"index\" to something else like \"value\" or \"i\"  than it bricks .... "
                    }
                ]
            },
            {
                "id": 1792003,
                "content": [
                    {
                        "username": "pamaAmo",
                        "content": "bool containsDuplicate(int* nums, int numsSize){\\n    for(int i=0;i<numsSize-1;i++){\\n        for(int j=i+1;j<numsSize;j++){\\n            if(nums[i]==nums[j]){\\n                return true;\\n            }\\n        }\\n    \\n    }\\n    return false;\\n}\\ncan anybody help I m not getting what\\'s wrong ?\\nits not verifying few testcases"
                    },
                    {
                        "username": "Parvesh_Kumar",
                        "content": "why its showing time limit exceeds\\n"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "when I am adding elements in list it is showing TIME LIMIT EXCEED but using same concept with set it isworking perfectly\\nCanany one plzz explain me this"
                    },
                    {
                        "username": "Tanisha36",
                        "content": "while i!=len(nums):\\n           \\n            if nums[i] == nums[i+1]:\\n\\nwhy this condition is showing error"
                    },
                    {
                        "username": "dowlurisatyaashok",
                        "content": "Flow:\\n    max of nums[]\\n    declare empty array with above as max limit + 1\\n    increase the values of new array as per the index\\n    return value based on values of the array <=1 "
                    },
                    {
                        "username": "HexFeather",
                        "content": "I'm noticing I'm repeatedly getting Time Limit Exceeded on the last test, this is my solution:\n\n```rs\nimpl Solution {\n    pub fn contains_duplicate(nums: Vec<i32>) -> bool {\n        let mut arr: Vec<i32> = vec![];\n\n        for (i, num) in nums.iter().enumerate() {\n            if arr.contains(&num) { return true; }\n            arr.push(*num);\n        }\n\n        false\n    }\n}\n```"
                    },
                    {
                        "username": "kaustubhpatil2332",
                        "content": "  set<int> convertToset(vector<int> & nums){\\n        set<int> s;\\n        for(int x: nums){\\n            s.insert(x);\\n        }\\n        return s;\\n    }\\n    bool containsDuplicate(vector<int>& nums) {\\n set<int> s = convertToset(nums);\\n      set<int>nums;\\n     if(nums.size()==s.size())\\n     {\\n         return false;\\n     }\\n     else \\n     return true;\\n    }"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "    (Python3)\nreturn len(nums) != len(set(nums))"
                    },
                    {
                        "username": "user8195Xq",
                        "content": "Hi, i just can\\'t understand what is the problem with my code. i\\'m sure it is supposed to work...\\n\\nimport java.util.*;\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        int count=0;\\n        for(int i=0; i<=nums.length; i++){\\n            for(int j=0; j<=nums.length;j++){\\n                 if(nums[i]==nums[j]){\\n                count++;\\n            }\\n            }\\n        }\\n        if(count>2){\\n            return true;\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "BGbasta",
                        "content": "change it to (int j = i + 1) and in the if check just return true. U don\\'t need counter"
                    },
                    {
                        "username": "killerxd95",
                        "content": "Python\nHey guys,\n\ncan somebody explain to me why this works\n        \n        array = {}\n        for n in nums:\n            if n in array:\n                return 1\n            array[n] = index\n        return 0\n\nbut if i change \"index\" to something else like \"value\" or \"i\"  than it bricks .... "
                    }
                ]
            },
            {
                "id": 1791203,
                "content": [
                    {
                        "username": "praveensharma900",
                        "content": "I tried to find duplicates after quick sort but still got  time limit exceeded error.\\nAnyone else facing the same issue ?\\nLanguage: C\\n\\n\\n"
                    },
                    {
                        "username": "BlueZin",
                        "content": "Does anyone else getting time limit exceeded whenever you tried to submit?"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        #Creating a data structure to store each element in array we scan through\\n        hash_table = {}\\n        #Going through each element in array\\n        for p in range(len(nums)):\\n            #If the current element is not in a data structure we created yet then append current element else we know that array is duplicated\\n            if hash_table.get(nums[p]):\\n                return True\\n            else:\\n                hash_table[nums[p]] = True\\n        return False"
                    },
                    {
                        "username": "Stark-123",
                        "content": "Time Complexity -> O(nlogn)\n\n`class Solution {\npublic:\n    bool containsDuplicate(vector<int>& v) {\n        \n       sort(v.begin(),v.end());\n        bool flag = false;\n        for(int i=1;i<v.size();i++){\n            if(v[i]==v[i-1]){\n                return true;\n            }\n        }\n       \n       \n        return flag;\n    }\n};`\n "
                    },
                    {
                        "username": "Ponzu",
                        "content": "My first time actually solving a problem lol"
                    },
                    {
                        "username": "dilsherb",
                        "content": "is there any one who can tell me time & space complexity in the following two cases for finding duplicates.\\nreturn new Set(nums).size != nums.length;  // case 1\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } // case 2"
                    },
                    {
                        "username": "edengoforit",
                        "content": "very simple python solution with a dictionary\n\n ```\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        dict = {}\n        for i in range(len(nums)):\n            if nums[i] not in dict.keys():\n                dict[nums[i]] = i\n            else:\n                return True\n\n        return False\n|```"
                    },
                    {
                        "username": "codeshriii",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= sizeof(nums);\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i]==nums[j]){\\n                   return true;\\n                }\\n             }\\n        }\\n        return false;\\n    }\\n};\\n\\nThis is my code i dont know why it is giving me a runtime error"
                    },
                    {
                        "username": "bekzodmirzayev",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int cnt=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]==nums[i+1]){\\n                cnt++;\\n                break;\\n            }\\n        }\\n        if(cnt>0){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "user2209yi",
                        "content": "Need help understanding why my code won\\'t help for this test case. Any hints would be appreciated. Thanks. https://leetcode.com/problems/contains-duplicate/solutions/3103305/result-incorrect-for-array-0-4-5-0-3-6-need-help/"
                    }
                ]
            },
            {
                "id": 1785816,
                "content": [
                    {
                        "username": "praveensharma900",
                        "content": "I tried to find duplicates after quick sort but still got  time limit exceeded error.\\nAnyone else facing the same issue ?\\nLanguage: C\\n\\n\\n"
                    },
                    {
                        "username": "BlueZin",
                        "content": "Does anyone else getting time limit exceeded whenever you tried to submit?"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        #Creating a data structure to store each element in array we scan through\\n        hash_table = {}\\n        #Going through each element in array\\n        for p in range(len(nums)):\\n            #If the current element is not in a data structure we created yet then append current element else we know that array is duplicated\\n            if hash_table.get(nums[p]):\\n                return True\\n            else:\\n                hash_table[nums[p]] = True\\n        return False"
                    },
                    {
                        "username": "Stark-123",
                        "content": "Time Complexity -> O(nlogn)\n\n`class Solution {\npublic:\n    bool containsDuplicate(vector<int>& v) {\n        \n       sort(v.begin(),v.end());\n        bool flag = false;\n        for(int i=1;i<v.size();i++){\n            if(v[i]==v[i-1]){\n                return true;\n            }\n        }\n       \n       \n        return flag;\n    }\n};`\n "
                    },
                    {
                        "username": "Ponzu",
                        "content": "My first time actually solving a problem lol"
                    },
                    {
                        "username": "dilsherb",
                        "content": "is there any one who can tell me time & space complexity in the following two cases for finding duplicates.\\nreturn new Set(nums).size != nums.length;  // case 1\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } // case 2"
                    },
                    {
                        "username": "edengoforit",
                        "content": "very simple python solution with a dictionary\n\n ```\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        dict = {}\n        for i in range(len(nums)):\n            if nums[i] not in dict.keys():\n                dict[nums[i]] = i\n            else:\n                return True\n\n        return False\n|```"
                    },
                    {
                        "username": "codeshriii",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= sizeof(nums);\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i]==nums[j]){\\n                   return true;\\n                }\\n             }\\n        }\\n        return false;\\n    }\\n};\\n\\nThis is my code i dont know why it is giving me a runtime error"
                    },
                    {
                        "username": "bekzodmirzayev",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int cnt=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]==nums[i+1]){\\n                cnt++;\\n                break;\\n            }\\n        }\\n        if(cnt>0){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "user2209yi",
                        "content": "Need help understanding why my code won\\'t help for this test case. Any hints would be appreciated. Thanks. https://leetcode.com/problems/contains-duplicate/solutions/3103305/result-incorrect-for-array-0-4-5-0-3-6-need-help/"
                    }
                ]
            },
            {
                "id": 1784365,
                "content": [
                    {
                        "username": "praveensharma900",
                        "content": "I tried to find duplicates after quick sort but still got  time limit exceeded error.\\nAnyone else facing the same issue ?\\nLanguage: C\\n\\n\\n"
                    },
                    {
                        "username": "BlueZin",
                        "content": "Does anyone else getting time limit exceeded whenever you tried to submit?"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        #Creating a data structure to store each element in array we scan through\\n        hash_table = {}\\n        #Going through each element in array\\n        for p in range(len(nums)):\\n            #If the current element is not in a data structure we created yet then append current element else we know that array is duplicated\\n            if hash_table.get(nums[p]):\\n                return True\\n            else:\\n                hash_table[nums[p]] = True\\n        return False"
                    },
                    {
                        "username": "Stark-123",
                        "content": "Time Complexity -> O(nlogn)\n\n`class Solution {\npublic:\n    bool containsDuplicate(vector<int>& v) {\n        \n       sort(v.begin(),v.end());\n        bool flag = false;\n        for(int i=1;i<v.size();i++){\n            if(v[i]==v[i-1]){\n                return true;\n            }\n        }\n       \n       \n        return flag;\n    }\n};`\n "
                    },
                    {
                        "username": "Ponzu",
                        "content": "My first time actually solving a problem lol"
                    },
                    {
                        "username": "dilsherb",
                        "content": "is there any one who can tell me time & space complexity in the following two cases for finding duplicates.\\nreturn new Set(nums).size != nums.length;  // case 1\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } // case 2"
                    },
                    {
                        "username": "edengoforit",
                        "content": "very simple python solution with a dictionary\n\n ```\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        dict = {}\n        for i in range(len(nums)):\n            if nums[i] not in dict.keys():\n                dict[nums[i]] = i\n            else:\n                return True\n\n        return False\n|```"
                    },
                    {
                        "username": "codeshriii",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= sizeof(nums);\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i]==nums[j]){\\n                   return true;\\n                }\\n             }\\n        }\\n        return false;\\n    }\\n};\\n\\nThis is my code i dont know why it is giving me a runtime error"
                    },
                    {
                        "username": "bekzodmirzayev",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int cnt=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]==nums[i+1]){\\n                cnt++;\\n                break;\\n            }\\n        }\\n        if(cnt>0){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "user2209yi",
                        "content": "Need help understanding why my code won\\'t help for this test case. Any hints would be appreciated. Thanks. https://leetcode.com/problems/contains-duplicate/solutions/3103305/result-incorrect-for-array-0-4-5-0-3-6-need-help/"
                    }
                ]
            },
            {
                "id": 1782972,
                "content": [
                    {
                        "username": "praveensharma900",
                        "content": "I tried to find duplicates after quick sort but still got  time limit exceeded error.\\nAnyone else facing the same issue ?\\nLanguage: C\\n\\n\\n"
                    },
                    {
                        "username": "BlueZin",
                        "content": "Does anyone else getting time limit exceeded whenever you tried to submit?"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        #Creating a data structure to store each element in array we scan through\\n        hash_table = {}\\n        #Going through each element in array\\n        for p in range(len(nums)):\\n            #If the current element is not in a data structure we created yet then append current element else we know that array is duplicated\\n            if hash_table.get(nums[p]):\\n                return True\\n            else:\\n                hash_table[nums[p]] = True\\n        return False"
                    },
                    {
                        "username": "Stark-123",
                        "content": "Time Complexity -> O(nlogn)\n\n`class Solution {\npublic:\n    bool containsDuplicate(vector<int>& v) {\n        \n       sort(v.begin(),v.end());\n        bool flag = false;\n        for(int i=1;i<v.size();i++){\n            if(v[i]==v[i-1]){\n                return true;\n            }\n        }\n       \n       \n        return flag;\n    }\n};`\n "
                    },
                    {
                        "username": "Ponzu",
                        "content": "My first time actually solving a problem lol"
                    },
                    {
                        "username": "dilsherb",
                        "content": "is there any one who can tell me time & space complexity in the following two cases for finding duplicates.\\nreturn new Set(nums).size != nums.length;  // case 1\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } // case 2"
                    },
                    {
                        "username": "edengoforit",
                        "content": "very simple python solution with a dictionary\n\n ```\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        dict = {}\n        for i in range(len(nums)):\n            if nums[i] not in dict.keys():\n                dict[nums[i]] = i\n            else:\n                return True\n\n        return False\n|```"
                    },
                    {
                        "username": "codeshriii",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= sizeof(nums);\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i]==nums[j]){\\n                   return true;\\n                }\\n             }\\n        }\\n        return false;\\n    }\\n};\\n\\nThis is my code i dont know why it is giving me a runtime error"
                    },
                    {
                        "username": "bekzodmirzayev",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int cnt=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]==nums[i+1]){\\n                cnt++;\\n                break;\\n            }\\n        }\\n        if(cnt>0){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "user2209yi",
                        "content": "Need help understanding why my code won\\'t help for this test case. Any hints would be appreciated. Thanks. https://leetcode.com/problems/contains-duplicate/solutions/3103305/result-incorrect-for-array-0-4-5-0-3-6-need-help/"
                    }
                ]
            },
            {
                "id": 1782750,
                "content": [
                    {
                        "username": "praveensharma900",
                        "content": "I tried to find duplicates after quick sort but still got  time limit exceeded error.\\nAnyone else facing the same issue ?\\nLanguage: C\\n\\n\\n"
                    },
                    {
                        "username": "BlueZin",
                        "content": "Does anyone else getting time limit exceeded whenever you tried to submit?"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        #Creating a data structure to store each element in array we scan through\\n        hash_table = {}\\n        #Going through each element in array\\n        for p in range(len(nums)):\\n            #If the current element is not in a data structure we created yet then append current element else we know that array is duplicated\\n            if hash_table.get(nums[p]):\\n                return True\\n            else:\\n                hash_table[nums[p]] = True\\n        return False"
                    },
                    {
                        "username": "Stark-123",
                        "content": "Time Complexity -> O(nlogn)\n\n`class Solution {\npublic:\n    bool containsDuplicate(vector<int>& v) {\n        \n       sort(v.begin(),v.end());\n        bool flag = false;\n        for(int i=1;i<v.size();i++){\n            if(v[i]==v[i-1]){\n                return true;\n            }\n        }\n       \n       \n        return flag;\n    }\n};`\n "
                    },
                    {
                        "username": "Ponzu",
                        "content": "My first time actually solving a problem lol"
                    },
                    {
                        "username": "dilsherb",
                        "content": "is there any one who can tell me time & space complexity in the following two cases for finding duplicates.\\nreturn new Set(nums).size != nums.length;  // case 1\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } // case 2"
                    },
                    {
                        "username": "edengoforit",
                        "content": "very simple python solution with a dictionary\n\n ```\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        dict = {}\n        for i in range(len(nums)):\n            if nums[i] not in dict.keys():\n                dict[nums[i]] = i\n            else:\n                return True\n\n        return False\n|```"
                    },
                    {
                        "username": "codeshriii",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= sizeof(nums);\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i]==nums[j]){\\n                   return true;\\n                }\\n             }\\n        }\\n        return false;\\n    }\\n};\\n\\nThis is my code i dont know why it is giving me a runtime error"
                    },
                    {
                        "username": "bekzodmirzayev",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int cnt=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]==nums[i+1]){\\n                cnt++;\\n                break;\\n            }\\n        }\\n        if(cnt>0){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "user2209yi",
                        "content": "Need help understanding why my code won\\'t help for this test case. Any hints would be appreciated. Thanks. https://leetcode.com/problems/contains-duplicate/solutions/3103305/result-incorrect-for-array-0-4-5-0-3-6-need-help/"
                    }
                ]
            },
            {
                "id": 1781814,
                "content": [
                    {
                        "username": "praveensharma900",
                        "content": "I tried to find duplicates after quick sort but still got  time limit exceeded error.\\nAnyone else facing the same issue ?\\nLanguage: C\\n\\n\\n"
                    },
                    {
                        "username": "BlueZin",
                        "content": "Does anyone else getting time limit exceeded whenever you tried to submit?"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        #Creating a data structure to store each element in array we scan through\\n        hash_table = {}\\n        #Going through each element in array\\n        for p in range(len(nums)):\\n            #If the current element is not in a data structure we created yet then append current element else we know that array is duplicated\\n            if hash_table.get(nums[p]):\\n                return True\\n            else:\\n                hash_table[nums[p]] = True\\n        return False"
                    },
                    {
                        "username": "Stark-123",
                        "content": "Time Complexity -> O(nlogn)\n\n`class Solution {\npublic:\n    bool containsDuplicate(vector<int>& v) {\n        \n       sort(v.begin(),v.end());\n        bool flag = false;\n        for(int i=1;i<v.size();i++){\n            if(v[i]==v[i-1]){\n                return true;\n            }\n        }\n       \n       \n        return flag;\n    }\n};`\n "
                    },
                    {
                        "username": "Ponzu",
                        "content": "My first time actually solving a problem lol"
                    },
                    {
                        "username": "dilsherb",
                        "content": "is there any one who can tell me time & space complexity in the following two cases for finding duplicates.\\nreturn new Set(nums).size != nums.length;  // case 1\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } // case 2"
                    },
                    {
                        "username": "edengoforit",
                        "content": "very simple python solution with a dictionary\n\n ```\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        dict = {}\n        for i in range(len(nums)):\n            if nums[i] not in dict.keys():\n                dict[nums[i]] = i\n            else:\n                return True\n\n        return False\n|```"
                    },
                    {
                        "username": "codeshriii",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= sizeof(nums);\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i]==nums[j]){\\n                   return true;\\n                }\\n             }\\n        }\\n        return false;\\n    }\\n};\\n\\nThis is my code i dont know why it is giving me a runtime error"
                    },
                    {
                        "username": "bekzodmirzayev",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int cnt=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]==nums[i+1]){\\n                cnt++;\\n                break;\\n            }\\n        }\\n        if(cnt>0){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "user2209yi",
                        "content": "Need help understanding why my code won\\'t help for this test case. Any hints would be appreciated. Thanks. https://leetcode.com/problems/contains-duplicate/solutions/3103305/result-incorrect-for-array-0-4-5-0-3-6-need-help/"
                    }
                ]
            },
            {
                "id": 1781147,
                "content": [
                    {
                        "username": "praveensharma900",
                        "content": "I tried to find duplicates after quick sort but still got  time limit exceeded error.\\nAnyone else facing the same issue ?\\nLanguage: C\\n\\n\\n"
                    },
                    {
                        "username": "BlueZin",
                        "content": "Does anyone else getting time limit exceeded whenever you tried to submit?"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        #Creating a data structure to store each element in array we scan through\\n        hash_table = {}\\n        #Going through each element in array\\n        for p in range(len(nums)):\\n            #If the current element is not in a data structure we created yet then append current element else we know that array is duplicated\\n            if hash_table.get(nums[p]):\\n                return True\\n            else:\\n                hash_table[nums[p]] = True\\n        return False"
                    },
                    {
                        "username": "Stark-123",
                        "content": "Time Complexity -> O(nlogn)\n\n`class Solution {\npublic:\n    bool containsDuplicate(vector<int>& v) {\n        \n       sort(v.begin(),v.end());\n        bool flag = false;\n        for(int i=1;i<v.size();i++){\n            if(v[i]==v[i-1]){\n                return true;\n            }\n        }\n       \n       \n        return flag;\n    }\n};`\n "
                    },
                    {
                        "username": "Ponzu",
                        "content": "My first time actually solving a problem lol"
                    },
                    {
                        "username": "dilsherb",
                        "content": "is there any one who can tell me time & space complexity in the following two cases for finding duplicates.\\nreturn new Set(nums).size != nums.length;  // case 1\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } // case 2"
                    },
                    {
                        "username": "edengoforit",
                        "content": "very simple python solution with a dictionary\n\n ```\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        dict = {}\n        for i in range(len(nums)):\n            if nums[i] not in dict.keys():\n                dict[nums[i]] = i\n            else:\n                return True\n\n        return False\n|```"
                    },
                    {
                        "username": "codeshriii",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= sizeof(nums);\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i]==nums[j]){\\n                   return true;\\n                }\\n             }\\n        }\\n        return false;\\n    }\\n};\\n\\nThis is my code i dont know why it is giving me a runtime error"
                    },
                    {
                        "username": "bekzodmirzayev",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int cnt=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]==nums[i+1]){\\n                cnt++;\\n                break;\\n            }\\n        }\\n        if(cnt>0){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "user2209yi",
                        "content": "Need help understanding why my code won\\'t help for this test case. Any hints would be appreciated. Thanks. https://leetcode.com/problems/contains-duplicate/solutions/3103305/result-incorrect-for-array-0-4-5-0-3-6-need-help/"
                    }
                ]
            },
            {
                "id": 1780282,
                "content": [
                    {
                        "username": "praveensharma900",
                        "content": "I tried to find duplicates after quick sort but still got  time limit exceeded error.\\nAnyone else facing the same issue ?\\nLanguage: C\\n\\n\\n"
                    },
                    {
                        "username": "BlueZin",
                        "content": "Does anyone else getting time limit exceeded whenever you tried to submit?"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        #Creating a data structure to store each element in array we scan through\\n        hash_table = {}\\n        #Going through each element in array\\n        for p in range(len(nums)):\\n            #If the current element is not in a data structure we created yet then append current element else we know that array is duplicated\\n            if hash_table.get(nums[p]):\\n                return True\\n            else:\\n                hash_table[nums[p]] = True\\n        return False"
                    },
                    {
                        "username": "Stark-123",
                        "content": "Time Complexity -> O(nlogn)\n\n`class Solution {\npublic:\n    bool containsDuplicate(vector<int>& v) {\n        \n       sort(v.begin(),v.end());\n        bool flag = false;\n        for(int i=1;i<v.size();i++){\n            if(v[i]==v[i-1]){\n                return true;\n            }\n        }\n       \n       \n        return flag;\n    }\n};`\n "
                    },
                    {
                        "username": "Ponzu",
                        "content": "My first time actually solving a problem lol"
                    },
                    {
                        "username": "dilsherb",
                        "content": "is there any one who can tell me time & space complexity in the following two cases for finding duplicates.\\nreturn new Set(nums).size != nums.length;  // case 1\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } // case 2"
                    },
                    {
                        "username": "edengoforit",
                        "content": "very simple python solution with a dictionary\n\n ```\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        dict = {}\n        for i in range(len(nums)):\n            if nums[i] not in dict.keys():\n                dict[nums[i]] = i\n            else:\n                return True\n\n        return False\n|```"
                    },
                    {
                        "username": "codeshriii",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= sizeof(nums);\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i]==nums[j]){\\n                   return true;\\n                }\\n             }\\n        }\\n        return false;\\n    }\\n};\\n\\nThis is my code i dont know why it is giving me a runtime error"
                    },
                    {
                        "username": "bekzodmirzayev",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int cnt=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]==nums[i+1]){\\n                cnt++;\\n                break;\\n            }\\n        }\\n        if(cnt>0){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "user2209yi",
                        "content": "Need help understanding why my code won\\'t help for this test case. Any hints would be appreciated. Thanks. https://leetcode.com/problems/contains-duplicate/solutions/3103305/result-incorrect-for-array-0-4-5-0-3-6-need-help/"
                    }
                ]
            },
            {
                "id": 1779402,
                "content": [
                    {
                        "username": "praveensharma900",
                        "content": "I tried to find duplicates after quick sort but still got  time limit exceeded error.\\nAnyone else facing the same issue ?\\nLanguage: C\\n\\n\\n"
                    },
                    {
                        "username": "BlueZin",
                        "content": "Does anyone else getting time limit exceeded whenever you tried to submit?"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        #Creating a data structure to store each element in array we scan through\\n        hash_table = {}\\n        #Going through each element in array\\n        for p in range(len(nums)):\\n            #If the current element is not in a data structure we created yet then append current element else we know that array is duplicated\\n            if hash_table.get(nums[p]):\\n                return True\\n            else:\\n                hash_table[nums[p]] = True\\n        return False"
                    },
                    {
                        "username": "Stark-123",
                        "content": "Time Complexity -> O(nlogn)\n\n`class Solution {\npublic:\n    bool containsDuplicate(vector<int>& v) {\n        \n       sort(v.begin(),v.end());\n        bool flag = false;\n        for(int i=1;i<v.size();i++){\n            if(v[i]==v[i-1]){\n                return true;\n            }\n        }\n       \n       \n        return flag;\n    }\n};`\n "
                    },
                    {
                        "username": "Ponzu",
                        "content": "My first time actually solving a problem lol"
                    },
                    {
                        "username": "dilsherb",
                        "content": "is there any one who can tell me time & space complexity in the following two cases for finding duplicates.\\nreturn new Set(nums).size != nums.length;  // case 1\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } // case 2"
                    },
                    {
                        "username": "edengoforit",
                        "content": "very simple python solution with a dictionary\n\n ```\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        dict = {}\n        for i in range(len(nums)):\n            if nums[i] not in dict.keys():\n                dict[nums[i]] = i\n            else:\n                return True\n\n        return False\n|```"
                    },
                    {
                        "username": "codeshriii",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= sizeof(nums);\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i]==nums[j]){\\n                   return true;\\n                }\\n             }\\n        }\\n        return false;\\n    }\\n};\\n\\nThis is my code i dont know why it is giving me a runtime error"
                    },
                    {
                        "username": "bekzodmirzayev",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int cnt=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]==nums[i+1]){\\n                cnt++;\\n                break;\\n            }\\n        }\\n        if(cnt>0){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "user2209yi",
                        "content": "Need help understanding why my code won\\'t help for this test case. Any hints would be appreciated. Thanks. https://leetcode.com/problems/contains-duplicate/solutions/3103305/result-incorrect-for-array-0-4-5-0-3-6-need-help/"
                    }
                ]
            },
            {
                "id": 1775886,
                "content": [
                    {
                        "username": "praveensharma900",
                        "content": "I tried to find duplicates after quick sort but still got  time limit exceeded error.\\nAnyone else facing the same issue ?\\nLanguage: C\\n\\n\\n"
                    },
                    {
                        "username": "BlueZin",
                        "content": "Does anyone else getting time limit exceeded whenever you tried to submit?"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "class Solution(object):\\n    def containsDuplicate(self, nums):\\n        #Creating a data structure to store each element in array we scan through\\n        hash_table = {}\\n        #Going through each element in array\\n        for p in range(len(nums)):\\n            #If the current element is not in a data structure we created yet then append current element else we know that array is duplicated\\n            if hash_table.get(nums[p]):\\n                return True\\n            else:\\n                hash_table[nums[p]] = True\\n        return False"
                    },
                    {
                        "username": "Stark-123",
                        "content": "Time Complexity -> O(nlogn)\n\n`class Solution {\npublic:\n    bool containsDuplicate(vector<int>& v) {\n        \n       sort(v.begin(),v.end());\n        bool flag = false;\n        for(int i=1;i<v.size();i++){\n            if(v[i]==v[i-1]){\n                return true;\n            }\n        }\n       \n       \n        return flag;\n    }\n};`\n "
                    },
                    {
                        "username": "Ponzu",
                        "content": "My first time actually solving a problem lol"
                    },
                    {
                        "username": "dilsherb",
                        "content": "is there any one who can tell me time & space complexity in the following two cases for finding duplicates.\\nreturn new Set(nums).size != nums.length;  // case 1\\nnums.sort((a,b) => a-b);\\n    for(let i=0; i<nums.length; i++) {\\n        if(nums[i]===nums[i+1]) {\\n        return true;\\n        } else return false;\\n    } // case 2"
                    },
                    {
                        "username": "edengoforit",
                        "content": "very simple python solution with a dictionary\n\n ```\nclass Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        dict = {}\n        for i in range(len(nums)):\n            if nums[i] not in dict.keys():\n                dict[nums[i]] = i\n            else:\n                return True\n\n        return False\n|```"
                    },
                    {
                        "username": "codeshriii",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n= sizeof(nums);\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(nums[i]==nums[j]){\\n                   return true;\\n                }\\n             }\\n        }\\n        return false;\\n    }\\n};\\n\\nThis is my code i dont know why it is giving me a runtime error"
                    },
                    {
                        "username": "bekzodmirzayev",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int cnt=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]==nums[i+1]){\\n                cnt++;\\n                break;\\n            }\\n        }\\n        if(cnt>0){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "user2209yi",
                        "content": "Need help understanding why my code won\\'t help for this test case. Any hints would be appreciated. Thanks. https://leetcode.com/problems/contains-duplicate/solutions/3103305/result-incorrect-for-array-0-4-5-0-3-6-need-help/"
                    }
                ]
            },
            {
                "id": 1774078,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/217._Contains_Duplicate.CPP\\nLEAVE A STAR"
                    },
                    {
                        "username": "vizzy205",
                        "content": "Surprising Counter works and not set lol"
                    },
                    {
                        "username": "sakhter7300",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n                    if(nums[i]==nums[j]){\\n                        return true;\\n                    }              \\n           }\\n       } \\n       return false;\\n    }\\n}\\nthis is giving me \"Time limit exceeded\" Please help as from the logic of it I would think this works."
                    },
                    {
                        "username": "rimon1596",
                        "content": "why does this one line python solution do so poorly, it\\'s O(n) right?\\n\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n       return len(set(nums)) < len(nums)"
                    },
                    {
                        "username": "msroy7",
                        "content": "Can anyone tell me what is the issue with the below piece of code. Getting Time Limit Exceeded for some test cases.\\n`def containsDuplicate(self, nums: List[int]) -> bool:\\n        listA = []\\n        for i in nums:\\n            if(i in listA):\\n                return True\\n            listA.append(i)\\n        return False`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kk_205",
                        "content": "can we solve it in O(n)  complexity in java? if yes please explain it a little bit."
                    },
                    {
                        "username": "akaleem306",
                        "content": "if len(set(nums))==len(nums):\\n            return False\\n        return True"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=n;\\n        unordered_map<long long,long long>mp;\\n\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]]>0){\\n                a--;\\n            }\\n        mp[nums[i]]++;\\n        }\\n\\n       return a==n?false:true;\\n    }\\n};"
                    },
                    {
                        "username": "saurabh145yadgire",
                        "content": "Can anyone find the bug in this code. It gives me wrong answer for test case 2.\ntest case: \nnums = [1,2,3,4]\nfrom collections import Counter\nclass Solution:\n    def containsDuplicate(self, nums):\n        product = 1\n        cnt = Counter(nums)\n        i = iter(cnt.values())\n        product = product*next(i)\n        if product!=1:\n            return \"true\"\n        else:\n            return \"false\""
                    }
                ]
            },
            {
                "id": 1773827,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/217._Contains_Duplicate.CPP\\nLEAVE A STAR"
                    },
                    {
                        "username": "vizzy205",
                        "content": "Surprising Counter works and not set lol"
                    },
                    {
                        "username": "sakhter7300",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n                    if(nums[i]==nums[j]){\\n                        return true;\\n                    }              \\n           }\\n       } \\n       return false;\\n    }\\n}\\nthis is giving me \"Time limit exceeded\" Please help as from the logic of it I would think this works."
                    },
                    {
                        "username": "rimon1596",
                        "content": "why does this one line python solution do so poorly, it\\'s O(n) right?\\n\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n       return len(set(nums)) < len(nums)"
                    },
                    {
                        "username": "msroy7",
                        "content": "Can anyone tell me what is the issue with the below piece of code. Getting Time Limit Exceeded for some test cases.\\n`def containsDuplicate(self, nums: List[int]) -> bool:\\n        listA = []\\n        for i in nums:\\n            if(i in listA):\\n                return True\\n            listA.append(i)\\n        return False`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kk_205",
                        "content": "can we solve it in O(n)  complexity in java? if yes please explain it a little bit."
                    },
                    {
                        "username": "akaleem306",
                        "content": "if len(set(nums))==len(nums):\\n            return False\\n        return True"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=n;\\n        unordered_map<long long,long long>mp;\\n\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]]>0){\\n                a--;\\n            }\\n        mp[nums[i]]++;\\n        }\\n\\n       return a==n?false:true;\\n    }\\n};"
                    },
                    {
                        "username": "saurabh145yadgire",
                        "content": "Can anyone find the bug in this code. It gives me wrong answer for test case 2.\ntest case: \nnums = [1,2,3,4]\nfrom collections import Counter\nclass Solution:\n    def containsDuplicate(self, nums):\n        product = 1\n        cnt = Counter(nums)\n        i = iter(cnt.values())\n        product = product*next(i)\n        if product!=1:\n            return \"true\"\n        else:\n            return \"false\""
                    }
                ]
            },
            {
                "id": 1773144,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/217._Contains_Duplicate.CPP\\nLEAVE A STAR"
                    },
                    {
                        "username": "vizzy205",
                        "content": "Surprising Counter works and not set lol"
                    },
                    {
                        "username": "sakhter7300",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n                    if(nums[i]==nums[j]){\\n                        return true;\\n                    }              \\n           }\\n       } \\n       return false;\\n    }\\n}\\nthis is giving me \"Time limit exceeded\" Please help as from the logic of it I would think this works."
                    },
                    {
                        "username": "rimon1596",
                        "content": "why does this one line python solution do so poorly, it\\'s O(n) right?\\n\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n       return len(set(nums)) < len(nums)"
                    },
                    {
                        "username": "msroy7",
                        "content": "Can anyone tell me what is the issue with the below piece of code. Getting Time Limit Exceeded for some test cases.\\n`def containsDuplicate(self, nums: List[int]) -> bool:\\n        listA = []\\n        for i in nums:\\n            if(i in listA):\\n                return True\\n            listA.append(i)\\n        return False`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kk_205",
                        "content": "can we solve it in O(n)  complexity in java? if yes please explain it a little bit."
                    },
                    {
                        "username": "akaleem306",
                        "content": "if len(set(nums))==len(nums):\\n            return False\\n        return True"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=n;\\n        unordered_map<long long,long long>mp;\\n\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]]>0){\\n                a--;\\n            }\\n        mp[nums[i]]++;\\n        }\\n\\n       return a==n?false:true;\\n    }\\n};"
                    },
                    {
                        "username": "saurabh145yadgire",
                        "content": "Can anyone find the bug in this code. It gives me wrong answer for test case 2.\ntest case: \nnums = [1,2,3,4]\nfrom collections import Counter\nclass Solution:\n    def containsDuplicate(self, nums):\n        product = 1\n        cnt = Counter(nums)\n        i = iter(cnt.values())\n        product = product*next(i)\n        if product!=1:\n            return \"true\"\n        else:\n            return \"false\""
                    }
                ]
            },
            {
                "id": 1771589,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/217._Contains_Duplicate.CPP\\nLEAVE A STAR"
                    },
                    {
                        "username": "vizzy205",
                        "content": "Surprising Counter works and not set lol"
                    },
                    {
                        "username": "sakhter7300",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n                    if(nums[i]==nums[j]){\\n                        return true;\\n                    }              \\n           }\\n       } \\n       return false;\\n    }\\n}\\nthis is giving me \"Time limit exceeded\" Please help as from the logic of it I would think this works."
                    },
                    {
                        "username": "rimon1596",
                        "content": "why does this one line python solution do so poorly, it\\'s O(n) right?\\n\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n       return len(set(nums)) < len(nums)"
                    },
                    {
                        "username": "msroy7",
                        "content": "Can anyone tell me what is the issue with the below piece of code. Getting Time Limit Exceeded for some test cases.\\n`def containsDuplicate(self, nums: List[int]) -> bool:\\n        listA = []\\n        for i in nums:\\n            if(i in listA):\\n                return True\\n            listA.append(i)\\n        return False`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kk_205",
                        "content": "can we solve it in O(n)  complexity in java? if yes please explain it a little bit."
                    },
                    {
                        "username": "akaleem306",
                        "content": "if len(set(nums))==len(nums):\\n            return False\\n        return True"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=n;\\n        unordered_map<long long,long long>mp;\\n\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]]>0){\\n                a--;\\n            }\\n        mp[nums[i]]++;\\n        }\\n\\n       return a==n?false:true;\\n    }\\n};"
                    },
                    {
                        "username": "saurabh145yadgire",
                        "content": "Can anyone find the bug in this code. It gives me wrong answer for test case 2.\ntest case: \nnums = [1,2,3,4]\nfrom collections import Counter\nclass Solution:\n    def containsDuplicate(self, nums):\n        product = 1\n        cnt = Counter(nums)\n        i = iter(cnt.values())\n        product = product*next(i)\n        if product!=1:\n            return \"true\"\n        else:\n            return \"false\""
                    }
                ]
            },
            {
                "id": 1770933,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/217._Contains_Duplicate.CPP\\nLEAVE A STAR"
                    },
                    {
                        "username": "vizzy205",
                        "content": "Surprising Counter works and not set lol"
                    },
                    {
                        "username": "sakhter7300",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n                    if(nums[i]==nums[j]){\\n                        return true;\\n                    }              \\n           }\\n       } \\n       return false;\\n    }\\n}\\nthis is giving me \"Time limit exceeded\" Please help as from the logic of it I would think this works."
                    },
                    {
                        "username": "rimon1596",
                        "content": "why does this one line python solution do so poorly, it\\'s O(n) right?\\n\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n       return len(set(nums)) < len(nums)"
                    },
                    {
                        "username": "msroy7",
                        "content": "Can anyone tell me what is the issue with the below piece of code. Getting Time Limit Exceeded for some test cases.\\n`def containsDuplicate(self, nums: List[int]) -> bool:\\n        listA = []\\n        for i in nums:\\n            if(i in listA):\\n                return True\\n            listA.append(i)\\n        return False`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kk_205",
                        "content": "can we solve it in O(n)  complexity in java? if yes please explain it a little bit."
                    },
                    {
                        "username": "akaleem306",
                        "content": "if len(set(nums))==len(nums):\\n            return False\\n        return True"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=n;\\n        unordered_map<long long,long long>mp;\\n\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]]>0){\\n                a--;\\n            }\\n        mp[nums[i]]++;\\n        }\\n\\n       return a==n?false:true;\\n    }\\n};"
                    },
                    {
                        "username": "saurabh145yadgire",
                        "content": "Can anyone find the bug in this code. It gives me wrong answer for test case 2.\ntest case: \nnums = [1,2,3,4]\nfrom collections import Counter\nclass Solution:\n    def containsDuplicate(self, nums):\n        product = 1\n        cnt = Counter(nums)\n        i = iter(cnt.values())\n        product = product*next(i)\n        if product!=1:\n            return \"true\"\n        else:\n            return \"false\""
                    }
                ]
            },
            {
                "id": 1769765,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/217._Contains_Duplicate.CPP\\nLEAVE A STAR"
                    },
                    {
                        "username": "vizzy205",
                        "content": "Surprising Counter works and not set lol"
                    },
                    {
                        "username": "sakhter7300",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n                    if(nums[i]==nums[j]){\\n                        return true;\\n                    }              \\n           }\\n       } \\n       return false;\\n    }\\n}\\nthis is giving me \"Time limit exceeded\" Please help as from the logic of it I would think this works."
                    },
                    {
                        "username": "rimon1596",
                        "content": "why does this one line python solution do so poorly, it\\'s O(n) right?\\n\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n       return len(set(nums)) < len(nums)"
                    },
                    {
                        "username": "msroy7",
                        "content": "Can anyone tell me what is the issue with the below piece of code. Getting Time Limit Exceeded for some test cases.\\n`def containsDuplicate(self, nums: List[int]) -> bool:\\n        listA = []\\n        for i in nums:\\n            if(i in listA):\\n                return True\\n            listA.append(i)\\n        return False`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kk_205",
                        "content": "can we solve it in O(n)  complexity in java? if yes please explain it a little bit."
                    },
                    {
                        "username": "akaleem306",
                        "content": "if len(set(nums))==len(nums):\\n            return False\\n        return True"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=n;\\n        unordered_map<long long,long long>mp;\\n\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]]>0){\\n                a--;\\n            }\\n        mp[nums[i]]++;\\n        }\\n\\n       return a==n?false:true;\\n    }\\n};"
                    },
                    {
                        "username": "saurabh145yadgire",
                        "content": "Can anyone find the bug in this code. It gives me wrong answer for test case 2.\ntest case: \nnums = [1,2,3,4]\nfrom collections import Counter\nclass Solution:\n    def containsDuplicate(self, nums):\n        product = 1\n        cnt = Counter(nums)\n        i = iter(cnt.values())\n        product = product*next(i)\n        if product!=1:\n            return \"true\"\n        else:\n            return \"false\""
                    }
                ]
            },
            {
                "id": 1768092,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/217._Contains_Duplicate.CPP\\nLEAVE A STAR"
                    },
                    {
                        "username": "vizzy205",
                        "content": "Surprising Counter works and not set lol"
                    },
                    {
                        "username": "sakhter7300",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n                    if(nums[i]==nums[j]){\\n                        return true;\\n                    }              \\n           }\\n       } \\n       return false;\\n    }\\n}\\nthis is giving me \"Time limit exceeded\" Please help as from the logic of it I would think this works."
                    },
                    {
                        "username": "rimon1596",
                        "content": "why does this one line python solution do so poorly, it\\'s O(n) right?\\n\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n       return len(set(nums)) < len(nums)"
                    },
                    {
                        "username": "msroy7",
                        "content": "Can anyone tell me what is the issue with the below piece of code. Getting Time Limit Exceeded for some test cases.\\n`def containsDuplicate(self, nums: List[int]) -> bool:\\n        listA = []\\n        for i in nums:\\n            if(i in listA):\\n                return True\\n            listA.append(i)\\n        return False`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kk_205",
                        "content": "can we solve it in O(n)  complexity in java? if yes please explain it a little bit."
                    },
                    {
                        "username": "akaleem306",
                        "content": "if len(set(nums))==len(nums):\\n            return False\\n        return True"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=n;\\n        unordered_map<long long,long long>mp;\\n\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]]>0){\\n                a--;\\n            }\\n        mp[nums[i]]++;\\n        }\\n\\n       return a==n?false:true;\\n    }\\n};"
                    },
                    {
                        "username": "saurabh145yadgire",
                        "content": "Can anyone find the bug in this code. It gives me wrong answer for test case 2.\ntest case: \nnums = [1,2,3,4]\nfrom collections import Counter\nclass Solution:\n    def containsDuplicate(self, nums):\n        product = 1\n        cnt = Counter(nums)\n        i = iter(cnt.values())\n        product = product*next(i)\n        if product!=1:\n            return \"true\"\n        else:\n            return \"false\""
                    }
                ]
            },
            {
                "id": 1766996,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/217._Contains_Duplicate.CPP\\nLEAVE A STAR"
                    },
                    {
                        "username": "vizzy205",
                        "content": "Surprising Counter works and not set lol"
                    },
                    {
                        "username": "sakhter7300",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n                    if(nums[i]==nums[j]){\\n                        return true;\\n                    }              \\n           }\\n       } \\n       return false;\\n    }\\n}\\nthis is giving me \"Time limit exceeded\" Please help as from the logic of it I would think this works."
                    },
                    {
                        "username": "rimon1596",
                        "content": "why does this one line python solution do so poorly, it\\'s O(n) right?\\n\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n       return len(set(nums)) < len(nums)"
                    },
                    {
                        "username": "msroy7",
                        "content": "Can anyone tell me what is the issue with the below piece of code. Getting Time Limit Exceeded for some test cases.\\n`def containsDuplicate(self, nums: List[int]) -> bool:\\n        listA = []\\n        for i in nums:\\n            if(i in listA):\\n                return True\\n            listA.append(i)\\n        return False`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kk_205",
                        "content": "can we solve it in O(n)  complexity in java? if yes please explain it a little bit."
                    },
                    {
                        "username": "akaleem306",
                        "content": "if len(set(nums))==len(nums):\\n            return False\\n        return True"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=n;\\n        unordered_map<long long,long long>mp;\\n\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]]>0){\\n                a--;\\n            }\\n        mp[nums[i]]++;\\n        }\\n\\n       return a==n?false:true;\\n    }\\n};"
                    },
                    {
                        "username": "saurabh145yadgire",
                        "content": "Can anyone find the bug in this code. It gives me wrong answer for test case 2.\ntest case: \nnums = [1,2,3,4]\nfrom collections import Counter\nclass Solution:\n    def containsDuplicate(self, nums):\n        product = 1\n        cnt = Counter(nums)\n        i = iter(cnt.values())\n        product = product*next(i)\n        if product!=1:\n            return \"true\"\n        else:\n            return \"false\""
                    }
                ]
            },
            {
                "id": 1766939,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/217._Contains_Duplicate.CPP\\nLEAVE A STAR"
                    },
                    {
                        "username": "vizzy205",
                        "content": "Surprising Counter works and not set lol"
                    },
                    {
                        "username": "sakhter7300",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n                    if(nums[i]==nums[j]){\\n                        return true;\\n                    }              \\n           }\\n       } \\n       return false;\\n    }\\n}\\nthis is giving me \"Time limit exceeded\" Please help as from the logic of it I would think this works."
                    },
                    {
                        "username": "rimon1596",
                        "content": "why does this one line python solution do so poorly, it\\'s O(n) right?\\n\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n       return len(set(nums)) < len(nums)"
                    },
                    {
                        "username": "msroy7",
                        "content": "Can anyone tell me what is the issue with the below piece of code. Getting Time Limit Exceeded for some test cases.\\n`def containsDuplicate(self, nums: List[int]) -> bool:\\n        listA = []\\n        for i in nums:\\n            if(i in listA):\\n                return True\\n            listA.append(i)\\n        return False`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kk_205",
                        "content": "can we solve it in O(n)  complexity in java? if yes please explain it a little bit."
                    },
                    {
                        "username": "akaleem306",
                        "content": "if len(set(nums))==len(nums):\\n            return False\\n        return True"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=n;\\n        unordered_map<long long,long long>mp;\\n\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]]>0){\\n                a--;\\n            }\\n        mp[nums[i]]++;\\n        }\\n\\n       return a==n?false:true;\\n    }\\n};"
                    },
                    {
                        "username": "saurabh145yadgire",
                        "content": "Can anyone find the bug in this code. It gives me wrong answer for test case 2.\ntest case: \nnums = [1,2,3,4]\nfrom collections import Counter\nclass Solution:\n    def containsDuplicate(self, nums):\n        product = 1\n        cnt = Counter(nums)\n        i = iter(cnt.values())\n        product = product*next(i)\n        if product!=1:\n            return \"true\"\n        else:\n            return \"false\""
                    }
                ]
            },
            {
                "id": 1765472,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/217._Contains_Duplicate.CPP\\nLEAVE A STAR"
                    },
                    {
                        "username": "vizzy205",
                        "content": "Surprising Counter works and not set lol"
                    },
                    {
                        "username": "sakhter7300",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n       for(int i=0;i<nums.length;i++){\\n           for(int j=i+1;j<nums.length;j++){\\n                    if(nums[i]==nums[j]){\\n                        return true;\\n                    }              \\n           }\\n       } \\n       return false;\\n    }\\n}\\nthis is giving me \"Time limit exceeded\" Please help as from the logic of it I would think this works."
                    },
                    {
                        "username": "rimon1596",
                        "content": "why does this one line python solution do so poorly, it\\'s O(n) right?\\n\\ndef containsDuplicate(self, nums: List[int]) -> bool:\\n       return len(set(nums)) < len(nums)"
                    },
                    {
                        "username": "msroy7",
                        "content": "Can anyone tell me what is the issue with the below piece of code. Getting Time Limit Exceeded for some test cases.\\n`def containsDuplicate(self, nums: List[int]) -> bool:\\n        listA = []\\n        for i in nums:\\n            if(i in listA):\\n                return True\\n            listA.append(i)\\n        return False`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "kk_205",
                        "content": "can we solve it in O(n)  complexity in java? if yes please explain it a little bit."
                    },
                    {
                        "username": "akaleem306",
                        "content": "if len(set(nums))==len(nums):\\n            return False\\n        return True"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=n;\\n        unordered_map<long long,long long>mp;\\n\\n        for(int i=0;i<n;i++){\\n            if(mp[nums[i]]>0){\\n                a--;\\n            }\\n        mp[nums[i]]++;\\n        }\\n\\n       return a==n?false:true;\\n    }\\n};"
                    },
                    {
                        "username": "saurabh145yadgire",
                        "content": "Can anyone find the bug in this code. It gives me wrong answer for test case 2.\ntest case: \nnums = [1,2,3,4]\nfrom collections import Counter\nclass Solution:\n    def containsDuplicate(self, nums):\n        product = 1\n        cnt = Counter(nums)\n        i = iter(cnt.values())\n        product = product*next(i)\n        if product!=1:\n            return \"true\"\n        else:\n            return \"false\""
                    }
                ]
            },
            {
                "id": 1764895,
                "content": [
                    {
                        "username": "sourav_karmakar",
                        "content": "this is apporch towards the solution\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "durgesh_mandge",
                        "content": "I was solving by 1.SORT 2.COMPARE 3.RETURN\\nBut I read Arrays.sort(nums) which improved my time complexity;"
                    },
                    {
                        "username": "jaycoding_lee",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> set = new HashSet<>();\\n    for (int num : nums) {\\n        set.add(num);\\n    }\\n    // check whether the size of hashset is smaller than the length of array\\n    // means that at least one duplicate element is in the given array\\n    return set.size() < nums.length;\\n    }\\n}"
                    },
                    {
                        "username": "gerryhd",
                        "content": "It\\'s impossible to pass this with Ruby it seems, the O(n) solution with the same logic from other language\\'s solution keeps giving TLE for Ruby."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user7074Cr",
                        "content": "Code is correct but showing runtime error"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can easily be done using SET (is a DS to store unique values)\\n\\nhttps://leetcode.com/problems/contains-duplicate/solutions/3035330/set-js-on/"
                    },
                    {
                        "username": "VaisagAchu",
                        "content": "I have noticed the easy way of solving this using hashset.\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) \\n    {\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hs.contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hs.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harenlewis",
                        "content": "Python one liner:\\n\\n`return len(list(set(nums))) != len(nums)`"
                    },
                    {
                        "username": "Sricharanreddy",
                        "content": "If you get a runtime error just think an alternative way of approach to solve the problem to reduce the time complexity and the best and easy to understand approach is array sorting method where you will sort the array and then you will compare the adjacent elements through this the same elements will be adjacent so in that approach you can solve this question"
                    }
                ]
            },
            {
                "id": 1762059,
                "content": [
                    {
                        "username": "sourav_karmakar",
                        "content": "this is apporch towards the solution\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "durgesh_mandge",
                        "content": "I was solving by 1.SORT 2.COMPARE 3.RETURN\\nBut I read Arrays.sort(nums) which improved my time complexity;"
                    },
                    {
                        "username": "jaycoding_lee",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> set = new HashSet<>();\\n    for (int num : nums) {\\n        set.add(num);\\n    }\\n    // check whether the size of hashset is smaller than the length of array\\n    // means that at least one duplicate element is in the given array\\n    return set.size() < nums.length;\\n    }\\n}"
                    },
                    {
                        "username": "gerryhd",
                        "content": "It\\'s impossible to pass this with Ruby it seems, the O(n) solution with the same logic from other language\\'s solution keeps giving TLE for Ruby."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user7074Cr",
                        "content": "Code is correct but showing runtime error"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can easily be done using SET (is a DS to store unique values)\\n\\nhttps://leetcode.com/problems/contains-duplicate/solutions/3035330/set-js-on/"
                    },
                    {
                        "username": "VaisagAchu",
                        "content": "I have noticed the easy way of solving this using hashset.\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) \\n    {\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hs.contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hs.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harenlewis",
                        "content": "Python one liner:\\n\\n`return len(list(set(nums))) != len(nums)`"
                    },
                    {
                        "username": "Sricharanreddy",
                        "content": "If you get a runtime error just think an alternative way of approach to solve the problem to reduce the time complexity and the best and easy to understand approach is array sorting method where you will sort the array and then you will compare the adjacent elements through this the same elements will be adjacent so in that approach you can solve this question"
                    }
                ]
            },
            {
                "id": 1761261,
                "content": [
                    {
                        "username": "sourav_karmakar",
                        "content": "this is apporch towards the solution\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "durgesh_mandge",
                        "content": "I was solving by 1.SORT 2.COMPARE 3.RETURN\\nBut I read Arrays.sort(nums) which improved my time complexity;"
                    },
                    {
                        "username": "jaycoding_lee",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> set = new HashSet<>();\\n    for (int num : nums) {\\n        set.add(num);\\n    }\\n    // check whether the size of hashset is smaller than the length of array\\n    // means that at least one duplicate element is in the given array\\n    return set.size() < nums.length;\\n    }\\n}"
                    },
                    {
                        "username": "gerryhd",
                        "content": "It\\'s impossible to pass this with Ruby it seems, the O(n) solution with the same logic from other language\\'s solution keeps giving TLE for Ruby."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user7074Cr",
                        "content": "Code is correct but showing runtime error"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can easily be done using SET (is a DS to store unique values)\\n\\nhttps://leetcode.com/problems/contains-duplicate/solutions/3035330/set-js-on/"
                    },
                    {
                        "username": "VaisagAchu",
                        "content": "I have noticed the easy way of solving this using hashset.\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) \\n    {\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hs.contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hs.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harenlewis",
                        "content": "Python one liner:\\n\\n`return len(list(set(nums))) != len(nums)`"
                    },
                    {
                        "username": "Sricharanreddy",
                        "content": "If you get a runtime error just think an alternative way of approach to solve the problem to reduce the time complexity and the best and easy to understand approach is array sorting method where you will sort the array and then you will compare the adjacent elements through this the same elements will be adjacent so in that approach you can solve this question"
                    }
                ]
            },
            {
                "id": 1758248,
                "content": [
                    {
                        "username": "sourav_karmakar",
                        "content": "this is apporch towards the solution\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "durgesh_mandge",
                        "content": "I was solving by 1.SORT 2.COMPARE 3.RETURN\\nBut I read Arrays.sort(nums) which improved my time complexity;"
                    },
                    {
                        "username": "jaycoding_lee",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> set = new HashSet<>();\\n    for (int num : nums) {\\n        set.add(num);\\n    }\\n    // check whether the size of hashset is smaller than the length of array\\n    // means that at least one duplicate element is in the given array\\n    return set.size() < nums.length;\\n    }\\n}"
                    },
                    {
                        "username": "gerryhd",
                        "content": "It\\'s impossible to pass this with Ruby it seems, the O(n) solution with the same logic from other language\\'s solution keeps giving TLE for Ruby."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user7074Cr",
                        "content": "Code is correct but showing runtime error"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can easily be done using SET (is a DS to store unique values)\\n\\nhttps://leetcode.com/problems/contains-duplicate/solutions/3035330/set-js-on/"
                    },
                    {
                        "username": "VaisagAchu",
                        "content": "I have noticed the easy way of solving this using hashset.\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) \\n    {\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hs.contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hs.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harenlewis",
                        "content": "Python one liner:\\n\\n`return len(list(set(nums))) != len(nums)`"
                    },
                    {
                        "username": "Sricharanreddy",
                        "content": "If you get a runtime error just think an alternative way of approach to solve the problem to reduce the time complexity and the best and easy to understand approach is array sorting method where you will sort the array and then you will compare the adjacent elements through this the same elements will be adjacent so in that approach you can solve this question"
                    }
                ]
            },
            {
                "id": 1757525,
                "content": [
                    {
                        "username": "sourav_karmakar",
                        "content": "this is apporch towards the solution\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "durgesh_mandge",
                        "content": "I was solving by 1.SORT 2.COMPARE 3.RETURN\\nBut I read Arrays.sort(nums) which improved my time complexity;"
                    },
                    {
                        "username": "jaycoding_lee",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> set = new HashSet<>();\\n    for (int num : nums) {\\n        set.add(num);\\n    }\\n    // check whether the size of hashset is smaller than the length of array\\n    // means that at least one duplicate element is in the given array\\n    return set.size() < nums.length;\\n    }\\n}"
                    },
                    {
                        "username": "gerryhd",
                        "content": "It\\'s impossible to pass this with Ruby it seems, the O(n) solution with the same logic from other language\\'s solution keeps giving TLE for Ruby."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user7074Cr",
                        "content": "Code is correct but showing runtime error"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can easily be done using SET (is a DS to store unique values)\\n\\nhttps://leetcode.com/problems/contains-duplicate/solutions/3035330/set-js-on/"
                    },
                    {
                        "username": "VaisagAchu",
                        "content": "I have noticed the easy way of solving this using hashset.\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) \\n    {\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hs.contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hs.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harenlewis",
                        "content": "Python one liner:\\n\\n`return len(list(set(nums))) != len(nums)`"
                    },
                    {
                        "username": "Sricharanreddy",
                        "content": "If you get a runtime error just think an alternative way of approach to solve the problem to reduce the time complexity and the best and easy to understand approach is array sorting method where you will sort the array and then you will compare the adjacent elements through this the same elements will be adjacent so in that approach you can solve this question"
                    }
                ]
            },
            {
                "id": 1754272,
                "content": [
                    {
                        "username": "sourav_karmakar",
                        "content": "this is apporch towards the solution\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "durgesh_mandge",
                        "content": "I was solving by 1.SORT 2.COMPARE 3.RETURN\\nBut I read Arrays.sort(nums) which improved my time complexity;"
                    },
                    {
                        "username": "jaycoding_lee",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> set = new HashSet<>();\\n    for (int num : nums) {\\n        set.add(num);\\n    }\\n    // check whether the size of hashset is smaller than the length of array\\n    // means that at least one duplicate element is in the given array\\n    return set.size() < nums.length;\\n    }\\n}"
                    },
                    {
                        "username": "gerryhd",
                        "content": "It\\'s impossible to pass this with Ruby it seems, the O(n) solution with the same logic from other language\\'s solution keeps giving TLE for Ruby."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user7074Cr",
                        "content": "Code is correct but showing runtime error"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can easily be done using SET (is a DS to store unique values)\\n\\nhttps://leetcode.com/problems/contains-duplicate/solutions/3035330/set-js-on/"
                    },
                    {
                        "username": "VaisagAchu",
                        "content": "I have noticed the easy way of solving this using hashset.\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) \\n    {\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hs.contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hs.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harenlewis",
                        "content": "Python one liner:\\n\\n`return len(list(set(nums))) != len(nums)`"
                    },
                    {
                        "username": "Sricharanreddy",
                        "content": "If you get a runtime error just think an alternative way of approach to solve the problem to reduce the time complexity and the best and easy to understand approach is array sorting method where you will sort the array and then you will compare the adjacent elements through this the same elements will be adjacent so in that approach you can solve this question"
                    }
                ]
            },
            {
                "id": 1753016,
                "content": [
                    {
                        "username": "sourav_karmakar",
                        "content": "this is apporch towards the solution\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "durgesh_mandge",
                        "content": "I was solving by 1.SORT 2.COMPARE 3.RETURN\\nBut I read Arrays.sort(nums) which improved my time complexity;"
                    },
                    {
                        "username": "jaycoding_lee",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> set = new HashSet<>();\\n    for (int num : nums) {\\n        set.add(num);\\n    }\\n    // check whether the size of hashset is smaller than the length of array\\n    // means that at least one duplicate element is in the given array\\n    return set.size() < nums.length;\\n    }\\n}"
                    },
                    {
                        "username": "gerryhd",
                        "content": "It\\'s impossible to pass this with Ruby it seems, the O(n) solution with the same logic from other language\\'s solution keeps giving TLE for Ruby."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user7074Cr",
                        "content": "Code is correct but showing runtime error"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can easily be done using SET (is a DS to store unique values)\\n\\nhttps://leetcode.com/problems/contains-duplicate/solutions/3035330/set-js-on/"
                    },
                    {
                        "username": "VaisagAchu",
                        "content": "I have noticed the easy way of solving this using hashset.\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) \\n    {\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hs.contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hs.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harenlewis",
                        "content": "Python one liner:\\n\\n`return len(list(set(nums))) != len(nums)`"
                    },
                    {
                        "username": "Sricharanreddy",
                        "content": "If you get a runtime error just think an alternative way of approach to solve the problem to reduce the time complexity and the best and easy to understand approach is array sorting method where you will sort the array and then you will compare the adjacent elements through this the same elements will be adjacent so in that approach you can solve this question"
                    }
                ]
            },
            {
                "id": 1752079,
                "content": [
                    {
                        "username": "sourav_karmakar",
                        "content": "this is apporch towards the solution\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "durgesh_mandge",
                        "content": "I was solving by 1.SORT 2.COMPARE 3.RETURN\\nBut I read Arrays.sort(nums) which improved my time complexity;"
                    },
                    {
                        "username": "jaycoding_lee",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> set = new HashSet<>();\\n    for (int num : nums) {\\n        set.add(num);\\n    }\\n    // check whether the size of hashset is smaller than the length of array\\n    // means that at least one duplicate element is in the given array\\n    return set.size() < nums.length;\\n    }\\n}"
                    },
                    {
                        "username": "gerryhd",
                        "content": "It\\'s impossible to pass this with Ruby it seems, the O(n) solution with the same logic from other language\\'s solution keeps giving TLE for Ruby."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user7074Cr",
                        "content": "Code is correct but showing runtime error"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can easily be done using SET (is a DS to store unique values)\\n\\nhttps://leetcode.com/problems/contains-duplicate/solutions/3035330/set-js-on/"
                    },
                    {
                        "username": "VaisagAchu",
                        "content": "I have noticed the easy way of solving this using hashset.\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) \\n    {\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hs.contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hs.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harenlewis",
                        "content": "Python one liner:\\n\\n`return len(list(set(nums))) != len(nums)`"
                    },
                    {
                        "username": "Sricharanreddy",
                        "content": "If you get a runtime error just think an alternative way of approach to solve the problem to reduce the time complexity and the best and easy to understand approach is array sorting method where you will sort the array and then you will compare the adjacent elements through this the same elements will be adjacent so in that approach you can solve this question"
                    }
                ]
            },
            {
                "id": 1751828,
                "content": [
                    {
                        "username": "sourav_karmakar",
                        "content": "this is apporch towards the solution\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "durgesh_mandge",
                        "content": "I was solving by 1.SORT 2.COMPARE 3.RETURN\\nBut I read Arrays.sort(nums) which improved my time complexity;"
                    },
                    {
                        "username": "jaycoding_lee",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> set = new HashSet<>();\\n    for (int num : nums) {\\n        set.add(num);\\n    }\\n    // check whether the size of hashset is smaller than the length of array\\n    // means that at least one duplicate element is in the given array\\n    return set.size() < nums.length;\\n    }\\n}"
                    },
                    {
                        "username": "gerryhd",
                        "content": "It\\'s impossible to pass this with Ruby it seems, the O(n) solution with the same logic from other language\\'s solution keeps giving TLE for Ruby."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user7074Cr",
                        "content": "Code is correct but showing runtime error"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can easily be done using SET (is a DS to store unique values)\\n\\nhttps://leetcode.com/problems/contains-duplicate/solutions/3035330/set-js-on/"
                    },
                    {
                        "username": "VaisagAchu",
                        "content": "I have noticed the easy way of solving this using hashset.\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) \\n    {\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hs.contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hs.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harenlewis",
                        "content": "Python one liner:\\n\\n`return len(list(set(nums))) != len(nums)`"
                    },
                    {
                        "username": "Sricharanreddy",
                        "content": "If you get a runtime error just think an alternative way of approach to solve the problem to reduce the time complexity and the best and easy to understand approach is array sorting method where you will sort the array and then you will compare the adjacent elements through this the same elements will be adjacent so in that approach you can solve this question"
                    }
                ]
            },
            {
                "id": 1751514,
                "content": [
                    {
                        "username": "sourav_karmakar",
                        "content": "this is apporch towards the solution\\n\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "durgesh_mandge",
                        "content": "I was solving by 1.SORT 2.COMPARE 3.RETURN\\nBut I read Arrays.sort(nums) which improved my time complexity;"
                    },
                    {
                        "username": "jaycoding_lee",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> set = new HashSet<>();\\n    for (int num : nums) {\\n        set.add(num);\\n    }\\n    // check whether the size of hashset is smaller than the length of array\\n    // means that at least one duplicate element is in the given array\\n    return set.size() < nums.length;\\n    }\\n}"
                    },
                    {
                        "username": "gerryhd",
                        "content": "It\\'s impossible to pass this with Ruby it seems, the O(n) solution with the same logic from other language\\'s solution keeps giving TLE for Ruby."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user7074Cr",
                        "content": "Code is correct but showing runtime error"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can easily be done using SET (is a DS to store unique values)\\n\\nhttps://leetcode.com/problems/contains-duplicate/solutions/3035330/set-js-on/"
                    },
                    {
                        "username": "VaisagAchu",
                        "content": "I have noticed the easy way of solving this using hashset.\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) \\n    {\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(hs.contains(nums[i]))\\n            {\\n                return true;\\n            }\\n            hs.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "harenlewis",
                        "content": "Python one liner:\\n\\n`return len(list(set(nums))) != len(nums)`"
                    },
                    {
                        "username": "Sricharanreddy",
                        "content": "If you get a runtime error just think an alternative way of approach to solve the problem to reduce the time complexity and the best and easy to understand approach is array sorting method where you will sort the array and then you will compare the adjacent elements through this the same elements will be adjacent so in that approach you can solve this question"
                    }
                ]
            },
            {
                "id": 1750482,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Don\\'t think so much just apply HashMap only two lines of code needed"
                    },
                    {
                        "username": "MahmoudRamadan",
                        "content": "Kotlin Solution\\nclass Solution {\\n    fun containsDuplicate(nums: IntArray): Boolean {\\n        val set = HashSet<Int>()\\n        for (num in nums) {\\n            if(set.contains(num))\\n              return true\\n             else\\n              set.add(num)\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int,int>m;\\n        bool count=false;\\n        bool count1=true;\\n        for(auto i: nums){\\n            m[i]++;\\n        }\\n        for(auto i: m){\\n            if(i.second>1){\\n                \\n                return count1;\\n            }}\\n    \\n        \\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gopi_pandit",
                        "content": " `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n\\n        hashset = set()\\n        \\n        for i in nums:\\n            if i in hashset:\\n                return True\\n            else:\\n                hashset.add(i)\\n        return False"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can it be done using O(n) time and less than O(n) space?"
                    },
                    {
                        "username": "PrathamBagrecha",
                        "content": "from collections import Counter\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        s = list(set(nums))\\n        if(len(s) != len(nums)):\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "ItsJavs",
                        "content": "Using python, why using a list causes a \"time limit exceeded\" error but with a set works fine?"
                    },
                    {
                        "username": "tarikin",
                        "content": "Last test is nums = , then nothing after equality, what is the nums on last test?"
                    },
                    {
                        "username": "aakansha80100",
                        "content": "I got time limit Exceeded at 70th test case and there is not a single input shown. \\nI am doing it by for loop and the code is passed all test cases except last one.\\n\\nhere is my code- in java\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        for(int i=0; i<nums.length; i++){\\n            int element=nums[i];\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]==element){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\nwhat should I do ?"
                    },
                    {
                        "username": "Surya1512",
                        "content": "Why looping through an array gives me time exceeded when I use count method in ruby `def contains_duplicate(nums)`\\n    `nums.each do |n|`\\n         `n_count = nums.count(n)`\\n         `return true if n_count > 1`   \\n    `end`\\n    `return false`\\n`end`"
                    }
                ]
            },
            {
                "id": 1746120,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Don\\'t think so much just apply HashMap only two lines of code needed"
                    },
                    {
                        "username": "MahmoudRamadan",
                        "content": "Kotlin Solution\\nclass Solution {\\n    fun containsDuplicate(nums: IntArray): Boolean {\\n        val set = HashSet<Int>()\\n        for (num in nums) {\\n            if(set.contains(num))\\n              return true\\n             else\\n              set.add(num)\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int,int>m;\\n        bool count=false;\\n        bool count1=true;\\n        for(auto i: nums){\\n            m[i]++;\\n        }\\n        for(auto i: m){\\n            if(i.second>1){\\n                \\n                return count1;\\n            }}\\n    \\n        \\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gopi_pandit",
                        "content": " `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n\\n        hashset = set()\\n        \\n        for i in nums:\\n            if i in hashset:\\n                return True\\n            else:\\n                hashset.add(i)\\n        return False"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can it be done using O(n) time and less than O(n) space?"
                    },
                    {
                        "username": "PrathamBagrecha",
                        "content": "from collections import Counter\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        s = list(set(nums))\\n        if(len(s) != len(nums)):\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "ItsJavs",
                        "content": "Using python, why using a list causes a \"time limit exceeded\" error but with a set works fine?"
                    },
                    {
                        "username": "tarikin",
                        "content": "Last test is nums = , then nothing after equality, what is the nums on last test?"
                    },
                    {
                        "username": "aakansha80100",
                        "content": "I got time limit Exceeded at 70th test case and there is not a single input shown. \\nI am doing it by for loop and the code is passed all test cases except last one.\\n\\nhere is my code- in java\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        for(int i=0; i<nums.length; i++){\\n            int element=nums[i];\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]==element){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\nwhat should I do ?"
                    },
                    {
                        "username": "Surya1512",
                        "content": "Why looping through an array gives me time exceeded when I use count method in ruby `def contains_duplicate(nums)`\\n    `nums.each do |n|`\\n         `n_count = nums.count(n)`\\n         `return true if n_count > 1`   \\n    `end`\\n    `return false`\\n`end`"
                    }
                ]
            },
            {
                "id": 1743208,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Don\\'t think so much just apply HashMap only two lines of code needed"
                    },
                    {
                        "username": "MahmoudRamadan",
                        "content": "Kotlin Solution\\nclass Solution {\\n    fun containsDuplicate(nums: IntArray): Boolean {\\n        val set = HashSet<Int>()\\n        for (num in nums) {\\n            if(set.contains(num))\\n              return true\\n             else\\n              set.add(num)\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int,int>m;\\n        bool count=false;\\n        bool count1=true;\\n        for(auto i: nums){\\n            m[i]++;\\n        }\\n        for(auto i: m){\\n            if(i.second>1){\\n                \\n                return count1;\\n            }}\\n    \\n        \\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gopi_pandit",
                        "content": " `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n\\n        hashset = set()\\n        \\n        for i in nums:\\n            if i in hashset:\\n                return True\\n            else:\\n                hashset.add(i)\\n        return False"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can it be done using O(n) time and less than O(n) space?"
                    },
                    {
                        "username": "PrathamBagrecha",
                        "content": "from collections import Counter\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        s = list(set(nums))\\n        if(len(s) != len(nums)):\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "ItsJavs",
                        "content": "Using python, why using a list causes a \"time limit exceeded\" error but with a set works fine?"
                    },
                    {
                        "username": "tarikin",
                        "content": "Last test is nums = , then nothing after equality, what is the nums on last test?"
                    },
                    {
                        "username": "aakansha80100",
                        "content": "I got time limit Exceeded at 70th test case and there is not a single input shown. \\nI am doing it by for loop and the code is passed all test cases except last one.\\n\\nhere is my code- in java\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        for(int i=0; i<nums.length; i++){\\n            int element=nums[i];\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]==element){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\nwhat should I do ?"
                    },
                    {
                        "username": "Surya1512",
                        "content": "Why looping through an array gives me time exceeded when I use count method in ruby `def contains_duplicate(nums)`\\n    `nums.each do |n|`\\n         `n_count = nums.count(n)`\\n         `return true if n_count > 1`   \\n    `end`\\n    `return false`\\n`end`"
                    }
                ]
            },
            {
                "id": 1740140,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Don\\'t think so much just apply HashMap only two lines of code needed"
                    },
                    {
                        "username": "MahmoudRamadan",
                        "content": "Kotlin Solution\\nclass Solution {\\n    fun containsDuplicate(nums: IntArray): Boolean {\\n        val set = HashSet<Int>()\\n        for (num in nums) {\\n            if(set.contains(num))\\n              return true\\n             else\\n              set.add(num)\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int,int>m;\\n        bool count=false;\\n        bool count1=true;\\n        for(auto i: nums){\\n            m[i]++;\\n        }\\n        for(auto i: m){\\n            if(i.second>1){\\n                \\n                return count1;\\n            }}\\n    \\n        \\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gopi_pandit",
                        "content": " `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n\\n        hashset = set()\\n        \\n        for i in nums:\\n            if i in hashset:\\n                return True\\n            else:\\n                hashset.add(i)\\n        return False"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can it be done using O(n) time and less than O(n) space?"
                    },
                    {
                        "username": "PrathamBagrecha",
                        "content": "from collections import Counter\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        s = list(set(nums))\\n        if(len(s) != len(nums)):\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "ItsJavs",
                        "content": "Using python, why using a list causes a \"time limit exceeded\" error but with a set works fine?"
                    },
                    {
                        "username": "tarikin",
                        "content": "Last test is nums = , then nothing after equality, what is the nums on last test?"
                    },
                    {
                        "username": "aakansha80100",
                        "content": "I got time limit Exceeded at 70th test case and there is not a single input shown. \\nI am doing it by for loop and the code is passed all test cases except last one.\\n\\nhere is my code- in java\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        for(int i=0; i<nums.length; i++){\\n            int element=nums[i];\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]==element){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\nwhat should I do ?"
                    },
                    {
                        "username": "Surya1512",
                        "content": "Why looping through an array gives me time exceeded when I use count method in ruby `def contains_duplicate(nums)`\\n    `nums.each do |n|`\\n         `n_count = nums.count(n)`\\n         `return true if n_count > 1`   \\n    `end`\\n    `return false`\\n`end`"
                    }
                ]
            },
            {
                "id": 1737751,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Don\\'t think so much just apply HashMap only two lines of code needed"
                    },
                    {
                        "username": "MahmoudRamadan",
                        "content": "Kotlin Solution\\nclass Solution {\\n    fun containsDuplicate(nums: IntArray): Boolean {\\n        val set = HashSet<Int>()\\n        for (num in nums) {\\n            if(set.contains(num))\\n              return true\\n             else\\n              set.add(num)\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int,int>m;\\n        bool count=false;\\n        bool count1=true;\\n        for(auto i: nums){\\n            m[i]++;\\n        }\\n        for(auto i: m){\\n            if(i.second>1){\\n                \\n                return count1;\\n            }}\\n    \\n        \\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gopi_pandit",
                        "content": " `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n\\n        hashset = set()\\n        \\n        for i in nums:\\n            if i in hashset:\\n                return True\\n            else:\\n                hashset.add(i)\\n        return False"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can it be done using O(n) time and less than O(n) space?"
                    },
                    {
                        "username": "PrathamBagrecha",
                        "content": "from collections import Counter\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        s = list(set(nums))\\n        if(len(s) != len(nums)):\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "ItsJavs",
                        "content": "Using python, why using a list causes a \"time limit exceeded\" error but with a set works fine?"
                    },
                    {
                        "username": "tarikin",
                        "content": "Last test is nums = , then nothing after equality, what is the nums on last test?"
                    },
                    {
                        "username": "aakansha80100",
                        "content": "I got time limit Exceeded at 70th test case and there is not a single input shown. \\nI am doing it by for loop and the code is passed all test cases except last one.\\n\\nhere is my code- in java\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        for(int i=0; i<nums.length; i++){\\n            int element=nums[i];\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]==element){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\nwhat should I do ?"
                    },
                    {
                        "username": "Surya1512",
                        "content": "Why looping through an array gives me time exceeded when I use count method in ruby `def contains_duplicate(nums)`\\n    `nums.each do |n|`\\n         `n_count = nums.count(n)`\\n         `return true if n_count > 1`   \\n    `end`\\n    `return false`\\n`end`"
                    }
                ]
            },
            {
                "id": 1736590,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Don\\'t think so much just apply HashMap only two lines of code needed"
                    },
                    {
                        "username": "MahmoudRamadan",
                        "content": "Kotlin Solution\\nclass Solution {\\n    fun containsDuplicate(nums: IntArray): Boolean {\\n        val set = HashSet<Int>()\\n        for (num in nums) {\\n            if(set.contains(num))\\n              return true\\n             else\\n              set.add(num)\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int,int>m;\\n        bool count=false;\\n        bool count1=true;\\n        for(auto i: nums){\\n            m[i]++;\\n        }\\n        for(auto i: m){\\n            if(i.second>1){\\n                \\n                return count1;\\n            }}\\n    \\n        \\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gopi_pandit",
                        "content": " `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n\\n        hashset = set()\\n        \\n        for i in nums:\\n            if i in hashset:\\n                return True\\n            else:\\n                hashset.add(i)\\n        return False"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can it be done using O(n) time and less than O(n) space?"
                    },
                    {
                        "username": "PrathamBagrecha",
                        "content": "from collections import Counter\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        s = list(set(nums))\\n        if(len(s) != len(nums)):\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "ItsJavs",
                        "content": "Using python, why using a list causes a \"time limit exceeded\" error but with a set works fine?"
                    },
                    {
                        "username": "tarikin",
                        "content": "Last test is nums = , then nothing after equality, what is the nums on last test?"
                    },
                    {
                        "username": "aakansha80100",
                        "content": "I got time limit Exceeded at 70th test case and there is not a single input shown. \\nI am doing it by for loop and the code is passed all test cases except last one.\\n\\nhere is my code- in java\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        for(int i=0; i<nums.length; i++){\\n            int element=nums[i];\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]==element){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\nwhat should I do ?"
                    },
                    {
                        "username": "Surya1512",
                        "content": "Why looping through an array gives me time exceeded when I use count method in ruby `def contains_duplicate(nums)`\\n    `nums.each do |n|`\\n         `n_count = nums.count(n)`\\n         `return true if n_count > 1`   \\n    `end`\\n    `return false`\\n`end`"
                    }
                ]
            },
            {
                "id": 1736521,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Don\\'t think so much just apply HashMap only two lines of code needed"
                    },
                    {
                        "username": "MahmoudRamadan",
                        "content": "Kotlin Solution\\nclass Solution {\\n    fun containsDuplicate(nums: IntArray): Boolean {\\n        val set = HashSet<Int>()\\n        for (num in nums) {\\n            if(set.contains(num))\\n              return true\\n             else\\n              set.add(num)\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int,int>m;\\n        bool count=false;\\n        bool count1=true;\\n        for(auto i: nums){\\n            m[i]++;\\n        }\\n        for(auto i: m){\\n            if(i.second>1){\\n                \\n                return count1;\\n            }}\\n    \\n        \\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gopi_pandit",
                        "content": " `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n\\n        hashset = set()\\n        \\n        for i in nums:\\n            if i in hashset:\\n                return True\\n            else:\\n                hashset.add(i)\\n        return False"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can it be done using O(n) time and less than O(n) space?"
                    },
                    {
                        "username": "PrathamBagrecha",
                        "content": "from collections import Counter\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        s = list(set(nums))\\n        if(len(s) != len(nums)):\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "ItsJavs",
                        "content": "Using python, why using a list causes a \"time limit exceeded\" error but with a set works fine?"
                    },
                    {
                        "username": "tarikin",
                        "content": "Last test is nums = , then nothing after equality, what is the nums on last test?"
                    },
                    {
                        "username": "aakansha80100",
                        "content": "I got time limit Exceeded at 70th test case and there is not a single input shown. \\nI am doing it by for loop and the code is passed all test cases except last one.\\n\\nhere is my code- in java\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        for(int i=0; i<nums.length; i++){\\n            int element=nums[i];\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]==element){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\nwhat should I do ?"
                    },
                    {
                        "username": "Surya1512",
                        "content": "Why looping through an array gives me time exceeded when I use count method in ruby `def contains_duplicate(nums)`\\n    `nums.each do |n|`\\n         `n_count = nums.count(n)`\\n         `return true if n_count > 1`   \\n    `end`\\n    `return false`\\n`end`"
                    }
                ]
            },
            {
                "id": 1735769,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Don\\'t think so much just apply HashMap only two lines of code needed"
                    },
                    {
                        "username": "MahmoudRamadan",
                        "content": "Kotlin Solution\\nclass Solution {\\n    fun containsDuplicate(nums: IntArray): Boolean {\\n        val set = HashSet<Int>()\\n        for (num in nums) {\\n            if(set.contains(num))\\n              return true\\n             else\\n              set.add(num)\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int,int>m;\\n        bool count=false;\\n        bool count1=true;\\n        for(auto i: nums){\\n            m[i]++;\\n        }\\n        for(auto i: m){\\n            if(i.second>1){\\n                \\n                return count1;\\n            }}\\n    \\n        \\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gopi_pandit",
                        "content": " `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n\\n        hashset = set()\\n        \\n        for i in nums:\\n            if i in hashset:\\n                return True\\n            else:\\n                hashset.add(i)\\n        return False"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can it be done using O(n) time and less than O(n) space?"
                    },
                    {
                        "username": "PrathamBagrecha",
                        "content": "from collections import Counter\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        s = list(set(nums))\\n        if(len(s) != len(nums)):\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "ItsJavs",
                        "content": "Using python, why using a list causes a \"time limit exceeded\" error but with a set works fine?"
                    },
                    {
                        "username": "tarikin",
                        "content": "Last test is nums = , then nothing after equality, what is the nums on last test?"
                    },
                    {
                        "username": "aakansha80100",
                        "content": "I got time limit Exceeded at 70th test case and there is not a single input shown. \\nI am doing it by for loop and the code is passed all test cases except last one.\\n\\nhere is my code- in java\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        for(int i=0; i<nums.length; i++){\\n            int element=nums[i];\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]==element){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\nwhat should I do ?"
                    },
                    {
                        "username": "Surya1512",
                        "content": "Why looping through an array gives me time exceeded when I use count method in ruby `def contains_duplicate(nums)`\\n    `nums.each do |n|`\\n         `n_count = nums.count(n)`\\n         `return true if n_count > 1`   \\n    `end`\\n    `return false`\\n`end`"
                    }
                ]
            },
            {
                "id": 1734433,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Don\\'t think so much just apply HashMap only two lines of code needed"
                    },
                    {
                        "username": "MahmoudRamadan",
                        "content": "Kotlin Solution\\nclass Solution {\\n    fun containsDuplicate(nums: IntArray): Boolean {\\n        val set = HashSet<Int>()\\n        for (num in nums) {\\n            if(set.contains(num))\\n              return true\\n             else\\n              set.add(num)\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int,int>m;\\n        bool count=false;\\n        bool count1=true;\\n        for(auto i: nums){\\n            m[i]++;\\n        }\\n        for(auto i: m){\\n            if(i.second>1){\\n                \\n                return count1;\\n            }}\\n    \\n        \\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gopi_pandit",
                        "content": " `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n\\n        hashset = set()\\n        \\n        for i in nums:\\n            if i in hashset:\\n                return True\\n            else:\\n                hashset.add(i)\\n        return False"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can it be done using O(n) time and less than O(n) space?"
                    },
                    {
                        "username": "PrathamBagrecha",
                        "content": "from collections import Counter\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        s = list(set(nums))\\n        if(len(s) != len(nums)):\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "ItsJavs",
                        "content": "Using python, why using a list causes a \"time limit exceeded\" error but with a set works fine?"
                    },
                    {
                        "username": "tarikin",
                        "content": "Last test is nums = , then nothing after equality, what is the nums on last test?"
                    },
                    {
                        "username": "aakansha80100",
                        "content": "I got time limit Exceeded at 70th test case and there is not a single input shown. \\nI am doing it by for loop and the code is passed all test cases except last one.\\n\\nhere is my code- in java\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        for(int i=0; i<nums.length; i++){\\n            int element=nums[i];\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]==element){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\nwhat should I do ?"
                    },
                    {
                        "username": "Surya1512",
                        "content": "Why looping through an array gives me time exceeded when I use count method in ruby `def contains_duplicate(nums)`\\n    `nums.each do |n|`\\n         `n_count = nums.count(n)`\\n         `return true if n_count > 1`   \\n    `end`\\n    `return false`\\n`end`"
                    }
                ]
            },
            {
                "id": 1733902,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Don\\'t think so much just apply HashMap only two lines of code needed"
                    },
                    {
                        "username": "MahmoudRamadan",
                        "content": "Kotlin Solution\\nclass Solution {\\n    fun containsDuplicate(nums: IntArray): Boolean {\\n        val set = HashSet<Int>()\\n        for (num in nums) {\\n            if(set.contains(num))\\n              return true\\n             else\\n              set.add(num)\\n        }\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Shivanshu1701",
                        "content": "class Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        map<int,int>m;\\n        bool count=false;\\n        bool count1=true;\\n        for(auto i: nums){\\n            m[i]++;\\n        }\\n        for(auto i: m){\\n            if(i.second>1){\\n                \\n                return count1;\\n            }}\\n    \\n        \\n        return count;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gopi_pandit",
                        "content": " `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n\\n        hashset = set()\\n        \\n        for i in nums:\\n            if i in hashset:\\n                return True\\n            else:\\n                hashset.add(i)\\n        return False"
                    },
                    {
                        "username": "debdutsaini",
                        "content": "Can it be done using O(n) time and less than O(n) space?"
                    },
                    {
                        "username": "PrathamBagrecha",
                        "content": "from collections import Counter\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        s = list(set(nums))\\n        if(len(s) != len(nums)):\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "ItsJavs",
                        "content": "Using python, why using a list causes a \"time limit exceeded\" error but with a set works fine?"
                    },
                    {
                        "username": "tarikin",
                        "content": "Last test is nums = , then nothing after equality, what is the nums on last test?"
                    },
                    {
                        "username": "aakansha80100",
                        "content": "I got time limit Exceeded at 70th test case and there is not a single input shown. \\nI am doing it by for loop and the code is passed all test cases except last one.\\n\\nhere is my code- in java\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        \\n        for(int i=0; i<nums.length; i++){\\n            int element=nums[i];\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]==element){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\nwhat should I do ?"
                    },
                    {
                        "username": "Surya1512",
                        "content": "Why looping through an array gives me time exceeded when I use count method in ruby `def contains_duplicate(nums)`\\n    `nums.each do |n|`\\n         `n_count = nums.count(n)`\\n         `return true if n_count > 1`   \\n    `end`\\n    `return false`\\n`end`"
                    }
                ]
            },
            {
                "id": 1732934,
                "content": [
                    {
                        "username": "heyitsuday",
                        "content": "public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> seen = new HashSet<>();\\n    for (int num : nums) {\\n        if (seen.contains(num)) {\\n            return true;\\n        }\\n        seen.add(num);\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "masipulislam",
                        "content": "for i in range(1, len(nums)):\\n            if nums[i] == nums[i - 1]:\\n                dup += 1\\n        return dup != 0"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "your are comparing the adjacent elements there can be duplicates any where in array\\n"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "I used ArrayList here and Time Limit Exceeded for 5 test cases, why is it so?\\n"
                    },
                    {
                        "username": "Sarvadnya_L",
                        "content": "Why am I getting TLE if I am using ArrayList, and not when I use HashSet?"
                    },
                    {
                        "username": "aayushi_1409",
                        "content": "We can just use the loop for solving the problem "
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "why unordered map is not working for this problem. 64/70 testcases passed.\\nGot error for this array:\\n [7,10,5,5,6,6,4,10,5,4,9,4,9,6,5,9,6,3,6,5,6,7,7,4,9,9,10,5,8,1,8,3,2,7,5,10,1,8,5,8,4,3,6,4,9,4,2,8,3,2,2,1,5,6,3,2,6,1,8,6,2,9,1,4,5,10,8,5,10,5,10,1,4,8,3,6,4,10,9,1,1,1,2,2,9,6,6,8,1,9,2,5,5,2,1,8,5,2,3,10]\\n\\ncan anybody explain why?\\n"
                    },
                    {
                        "username": "joacohao1",
                        "content": "i can not submit it because \"time limit exceeded\" . my solution works (i used two fors) why does this happen?"
                    },
                    {
                        "username": "SteeveT",
                        "content": "```    def containsDuplicate(self, nums):\\n        #i = 0\\n        table = {}\\n        # while(i <= len(nums)-1):\\n        for i in range(len(nums)):\\n            if nums[i] in table.keys():\\n                return True\\n            else:\\n                table[nums[i]] = i\\n            #i+=1\\n\\n        return False```\\n\\nWhenever I try to submit, it keeps giving me the error \"Time Limit Exceeded\".\\nAnd I feel like my code should be working fine without problems.\\nCould someone please explain why?"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "return 0 if(len(nums)==len(list(set(nums)))) else 1"
                    },
                    {
                        "username": "hend_",
                        "content": "can nay one tell me what\\'s wrong in this code:\\n `var containsDuplicate = function(nums) {\\n    let myMap = new Map([]);\\n    let res ;\\n    for(let i = 0 ; i<nums.length ; i++){\\n        if (myMap.has(nums[i])) {\\n            res = true;\\n            break;\\n        }\\n        myMap.set( i, nums[i]);        \\n    }\\n        return res;\\n};`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "if you initialize \"res\" at the beginning with false. The tests are becoming successful."
                    }
                ]
            },
            {
                "id": 1731938,
                "content": [
                    {
                        "username": "heyitsuday",
                        "content": "public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> seen = new HashSet<>();\\n    for (int num : nums) {\\n        if (seen.contains(num)) {\\n            return true;\\n        }\\n        seen.add(num);\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "masipulislam",
                        "content": "for i in range(1, len(nums)):\\n            if nums[i] == nums[i - 1]:\\n                dup += 1\\n        return dup != 0"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "your are comparing the adjacent elements there can be duplicates any where in array\\n"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "I used ArrayList here and Time Limit Exceeded for 5 test cases, why is it so?\\n"
                    },
                    {
                        "username": "Sarvadnya_L",
                        "content": "Why am I getting TLE if I am using ArrayList, and not when I use HashSet?"
                    },
                    {
                        "username": "aayushi_1409",
                        "content": "We can just use the loop for solving the problem "
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "why unordered map is not working for this problem. 64/70 testcases passed.\\nGot error for this array:\\n [7,10,5,5,6,6,4,10,5,4,9,4,9,6,5,9,6,3,6,5,6,7,7,4,9,9,10,5,8,1,8,3,2,7,5,10,1,8,5,8,4,3,6,4,9,4,2,8,3,2,2,1,5,6,3,2,6,1,8,6,2,9,1,4,5,10,8,5,10,5,10,1,4,8,3,6,4,10,9,1,1,1,2,2,9,6,6,8,1,9,2,5,5,2,1,8,5,2,3,10]\\n\\ncan anybody explain why?\\n"
                    },
                    {
                        "username": "joacohao1",
                        "content": "i can not submit it because \"time limit exceeded\" . my solution works (i used two fors) why does this happen?"
                    },
                    {
                        "username": "SteeveT",
                        "content": "```    def containsDuplicate(self, nums):\\n        #i = 0\\n        table = {}\\n        # while(i <= len(nums)-1):\\n        for i in range(len(nums)):\\n            if nums[i] in table.keys():\\n                return True\\n            else:\\n                table[nums[i]] = i\\n            #i+=1\\n\\n        return False```\\n\\nWhenever I try to submit, it keeps giving me the error \"Time Limit Exceeded\".\\nAnd I feel like my code should be working fine without problems.\\nCould someone please explain why?"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "return 0 if(len(nums)==len(list(set(nums)))) else 1"
                    },
                    {
                        "username": "hend_",
                        "content": "can nay one tell me what\\'s wrong in this code:\\n `var containsDuplicate = function(nums) {\\n    let myMap = new Map([]);\\n    let res ;\\n    for(let i = 0 ; i<nums.length ; i++){\\n        if (myMap.has(nums[i])) {\\n            res = true;\\n            break;\\n        }\\n        myMap.set( i, nums[i]);        \\n    }\\n        return res;\\n};`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "if you initialize \"res\" at the beginning with false. The tests are becoming successful."
                    }
                ]
            },
            {
                "id": 1730969,
                "content": [
                    {
                        "username": "heyitsuday",
                        "content": "public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> seen = new HashSet<>();\\n    for (int num : nums) {\\n        if (seen.contains(num)) {\\n            return true;\\n        }\\n        seen.add(num);\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "masipulislam",
                        "content": "for i in range(1, len(nums)):\\n            if nums[i] == nums[i - 1]:\\n                dup += 1\\n        return dup != 0"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "your are comparing the adjacent elements there can be duplicates any where in array\\n"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "I used ArrayList here and Time Limit Exceeded for 5 test cases, why is it so?\\n"
                    },
                    {
                        "username": "Sarvadnya_L",
                        "content": "Why am I getting TLE if I am using ArrayList, and not when I use HashSet?"
                    },
                    {
                        "username": "aayushi_1409",
                        "content": "We can just use the loop for solving the problem "
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "why unordered map is not working for this problem. 64/70 testcases passed.\\nGot error for this array:\\n [7,10,5,5,6,6,4,10,5,4,9,4,9,6,5,9,6,3,6,5,6,7,7,4,9,9,10,5,8,1,8,3,2,7,5,10,1,8,5,8,4,3,6,4,9,4,2,8,3,2,2,1,5,6,3,2,6,1,8,6,2,9,1,4,5,10,8,5,10,5,10,1,4,8,3,6,4,10,9,1,1,1,2,2,9,6,6,8,1,9,2,5,5,2,1,8,5,2,3,10]\\n\\ncan anybody explain why?\\n"
                    },
                    {
                        "username": "joacohao1",
                        "content": "i can not submit it because \"time limit exceeded\" . my solution works (i used two fors) why does this happen?"
                    },
                    {
                        "username": "SteeveT",
                        "content": "```    def containsDuplicate(self, nums):\\n        #i = 0\\n        table = {}\\n        # while(i <= len(nums)-1):\\n        for i in range(len(nums)):\\n            if nums[i] in table.keys():\\n                return True\\n            else:\\n                table[nums[i]] = i\\n            #i+=1\\n\\n        return False```\\n\\nWhenever I try to submit, it keeps giving me the error \"Time Limit Exceeded\".\\nAnd I feel like my code should be working fine without problems.\\nCould someone please explain why?"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "return 0 if(len(nums)==len(list(set(nums)))) else 1"
                    },
                    {
                        "username": "hend_",
                        "content": "can nay one tell me what\\'s wrong in this code:\\n `var containsDuplicate = function(nums) {\\n    let myMap = new Map([]);\\n    let res ;\\n    for(let i = 0 ; i<nums.length ; i++){\\n        if (myMap.has(nums[i])) {\\n            res = true;\\n            break;\\n        }\\n        myMap.set( i, nums[i]);        \\n    }\\n        return res;\\n};`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "if you initialize \"res\" at the beginning with false. The tests are becoming successful."
                    }
                ]
            },
            {
                "id": 1729464,
                "content": [
                    {
                        "username": "heyitsuday",
                        "content": "public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> seen = new HashSet<>();\\n    for (int num : nums) {\\n        if (seen.contains(num)) {\\n            return true;\\n        }\\n        seen.add(num);\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "masipulislam",
                        "content": "for i in range(1, len(nums)):\\n            if nums[i] == nums[i - 1]:\\n                dup += 1\\n        return dup != 0"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "your are comparing the adjacent elements there can be duplicates any where in array\\n"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "I used ArrayList here and Time Limit Exceeded for 5 test cases, why is it so?\\n"
                    },
                    {
                        "username": "Sarvadnya_L",
                        "content": "Why am I getting TLE if I am using ArrayList, and not when I use HashSet?"
                    },
                    {
                        "username": "aayushi_1409",
                        "content": "We can just use the loop for solving the problem "
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "why unordered map is not working for this problem. 64/70 testcases passed.\\nGot error for this array:\\n [7,10,5,5,6,6,4,10,5,4,9,4,9,6,5,9,6,3,6,5,6,7,7,4,9,9,10,5,8,1,8,3,2,7,5,10,1,8,5,8,4,3,6,4,9,4,2,8,3,2,2,1,5,6,3,2,6,1,8,6,2,9,1,4,5,10,8,5,10,5,10,1,4,8,3,6,4,10,9,1,1,1,2,2,9,6,6,8,1,9,2,5,5,2,1,8,5,2,3,10]\\n\\ncan anybody explain why?\\n"
                    },
                    {
                        "username": "joacohao1",
                        "content": "i can not submit it because \"time limit exceeded\" . my solution works (i used two fors) why does this happen?"
                    },
                    {
                        "username": "SteeveT",
                        "content": "```    def containsDuplicate(self, nums):\\n        #i = 0\\n        table = {}\\n        # while(i <= len(nums)-1):\\n        for i in range(len(nums)):\\n            if nums[i] in table.keys():\\n                return True\\n            else:\\n                table[nums[i]] = i\\n            #i+=1\\n\\n        return False```\\n\\nWhenever I try to submit, it keeps giving me the error \"Time Limit Exceeded\".\\nAnd I feel like my code should be working fine without problems.\\nCould someone please explain why?"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "return 0 if(len(nums)==len(list(set(nums)))) else 1"
                    },
                    {
                        "username": "hend_",
                        "content": "can nay one tell me what\\'s wrong in this code:\\n `var containsDuplicate = function(nums) {\\n    let myMap = new Map([]);\\n    let res ;\\n    for(let i = 0 ; i<nums.length ; i++){\\n        if (myMap.has(nums[i])) {\\n            res = true;\\n            break;\\n        }\\n        myMap.set( i, nums[i]);        \\n    }\\n        return res;\\n};`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "if you initialize \"res\" at the beginning with false. The tests are becoming successful."
                    }
                ]
            },
            {
                "id": 1728621,
                "content": [
                    {
                        "username": "heyitsuday",
                        "content": "public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> seen = new HashSet<>();\\n    for (int num : nums) {\\n        if (seen.contains(num)) {\\n            return true;\\n        }\\n        seen.add(num);\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "masipulislam",
                        "content": "for i in range(1, len(nums)):\\n            if nums[i] == nums[i - 1]:\\n                dup += 1\\n        return dup != 0"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "your are comparing the adjacent elements there can be duplicates any where in array\\n"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "I used ArrayList here and Time Limit Exceeded for 5 test cases, why is it so?\\n"
                    },
                    {
                        "username": "Sarvadnya_L",
                        "content": "Why am I getting TLE if I am using ArrayList, and not when I use HashSet?"
                    },
                    {
                        "username": "aayushi_1409",
                        "content": "We can just use the loop for solving the problem "
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "why unordered map is not working for this problem. 64/70 testcases passed.\\nGot error for this array:\\n [7,10,5,5,6,6,4,10,5,4,9,4,9,6,5,9,6,3,6,5,6,7,7,4,9,9,10,5,8,1,8,3,2,7,5,10,1,8,5,8,4,3,6,4,9,4,2,8,3,2,2,1,5,6,3,2,6,1,8,6,2,9,1,4,5,10,8,5,10,5,10,1,4,8,3,6,4,10,9,1,1,1,2,2,9,6,6,8,1,9,2,5,5,2,1,8,5,2,3,10]\\n\\ncan anybody explain why?\\n"
                    },
                    {
                        "username": "joacohao1",
                        "content": "i can not submit it because \"time limit exceeded\" . my solution works (i used two fors) why does this happen?"
                    },
                    {
                        "username": "SteeveT",
                        "content": "```    def containsDuplicate(self, nums):\\n        #i = 0\\n        table = {}\\n        # while(i <= len(nums)-1):\\n        for i in range(len(nums)):\\n            if nums[i] in table.keys():\\n                return True\\n            else:\\n                table[nums[i]] = i\\n            #i+=1\\n\\n        return False```\\n\\nWhenever I try to submit, it keeps giving me the error \"Time Limit Exceeded\".\\nAnd I feel like my code should be working fine without problems.\\nCould someone please explain why?"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "return 0 if(len(nums)==len(list(set(nums)))) else 1"
                    },
                    {
                        "username": "hend_",
                        "content": "can nay one tell me what\\'s wrong in this code:\\n `var containsDuplicate = function(nums) {\\n    let myMap = new Map([]);\\n    let res ;\\n    for(let i = 0 ; i<nums.length ; i++){\\n        if (myMap.has(nums[i])) {\\n            res = true;\\n            break;\\n        }\\n        myMap.set( i, nums[i]);        \\n    }\\n        return res;\\n};`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "if you initialize \"res\" at the beginning with false. The tests are becoming successful."
                    }
                ]
            },
            {
                "id": 1725342,
                "content": [
                    {
                        "username": "heyitsuday",
                        "content": "public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> seen = new HashSet<>();\\n    for (int num : nums) {\\n        if (seen.contains(num)) {\\n            return true;\\n        }\\n        seen.add(num);\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "masipulislam",
                        "content": "for i in range(1, len(nums)):\\n            if nums[i] == nums[i - 1]:\\n                dup += 1\\n        return dup != 0"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "your are comparing the adjacent elements there can be duplicates any where in array\\n"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "I used ArrayList here and Time Limit Exceeded for 5 test cases, why is it so?\\n"
                    },
                    {
                        "username": "Sarvadnya_L",
                        "content": "Why am I getting TLE if I am using ArrayList, and not when I use HashSet?"
                    },
                    {
                        "username": "aayushi_1409",
                        "content": "We can just use the loop for solving the problem "
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "why unordered map is not working for this problem. 64/70 testcases passed.\\nGot error for this array:\\n [7,10,5,5,6,6,4,10,5,4,9,4,9,6,5,9,6,3,6,5,6,7,7,4,9,9,10,5,8,1,8,3,2,7,5,10,1,8,5,8,4,3,6,4,9,4,2,8,3,2,2,1,5,6,3,2,6,1,8,6,2,9,1,4,5,10,8,5,10,5,10,1,4,8,3,6,4,10,9,1,1,1,2,2,9,6,6,8,1,9,2,5,5,2,1,8,5,2,3,10]\\n\\ncan anybody explain why?\\n"
                    },
                    {
                        "username": "joacohao1",
                        "content": "i can not submit it because \"time limit exceeded\" . my solution works (i used two fors) why does this happen?"
                    },
                    {
                        "username": "SteeveT",
                        "content": "```    def containsDuplicate(self, nums):\\n        #i = 0\\n        table = {}\\n        # while(i <= len(nums)-1):\\n        for i in range(len(nums)):\\n            if nums[i] in table.keys():\\n                return True\\n            else:\\n                table[nums[i]] = i\\n            #i+=1\\n\\n        return False```\\n\\nWhenever I try to submit, it keeps giving me the error \"Time Limit Exceeded\".\\nAnd I feel like my code should be working fine without problems.\\nCould someone please explain why?"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "return 0 if(len(nums)==len(list(set(nums)))) else 1"
                    },
                    {
                        "username": "hend_",
                        "content": "can nay one tell me what\\'s wrong in this code:\\n `var containsDuplicate = function(nums) {\\n    let myMap = new Map([]);\\n    let res ;\\n    for(let i = 0 ; i<nums.length ; i++){\\n        if (myMap.has(nums[i])) {\\n            res = true;\\n            break;\\n        }\\n        myMap.set( i, nums[i]);        \\n    }\\n        return res;\\n};`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "if you initialize \"res\" at the beginning with false. The tests are becoming successful."
                    }
                ]
            },
            {
                "id": 1723106,
                "content": [
                    {
                        "username": "heyitsuday",
                        "content": "public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> seen = new HashSet<>();\\n    for (int num : nums) {\\n        if (seen.contains(num)) {\\n            return true;\\n        }\\n        seen.add(num);\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "masipulislam",
                        "content": "for i in range(1, len(nums)):\\n            if nums[i] == nums[i - 1]:\\n                dup += 1\\n        return dup != 0"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "your are comparing the adjacent elements there can be duplicates any where in array\\n"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "I used ArrayList here and Time Limit Exceeded for 5 test cases, why is it so?\\n"
                    },
                    {
                        "username": "Sarvadnya_L",
                        "content": "Why am I getting TLE if I am using ArrayList, and not when I use HashSet?"
                    },
                    {
                        "username": "aayushi_1409",
                        "content": "We can just use the loop for solving the problem "
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "why unordered map is not working for this problem. 64/70 testcases passed.\\nGot error for this array:\\n [7,10,5,5,6,6,4,10,5,4,9,4,9,6,5,9,6,3,6,5,6,7,7,4,9,9,10,5,8,1,8,3,2,7,5,10,1,8,5,8,4,3,6,4,9,4,2,8,3,2,2,1,5,6,3,2,6,1,8,6,2,9,1,4,5,10,8,5,10,5,10,1,4,8,3,6,4,10,9,1,1,1,2,2,9,6,6,8,1,9,2,5,5,2,1,8,5,2,3,10]\\n\\ncan anybody explain why?\\n"
                    },
                    {
                        "username": "joacohao1",
                        "content": "i can not submit it because \"time limit exceeded\" . my solution works (i used two fors) why does this happen?"
                    },
                    {
                        "username": "SteeveT",
                        "content": "```    def containsDuplicate(self, nums):\\n        #i = 0\\n        table = {}\\n        # while(i <= len(nums)-1):\\n        for i in range(len(nums)):\\n            if nums[i] in table.keys():\\n                return True\\n            else:\\n                table[nums[i]] = i\\n            #i+=1\\n\\n        return False```\\n\\nWhenever I try to submit, it keeps giving me the error \"Time Limit Exceeded\".\\nAnd I feel like my code should be working fine without problems.\\nCould someone please explain why?"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "return 0 if(len(nums)==len(list(set(nums)))) else 1"
                    },
                    {
                        "username": "hend_",
                        "content": "can nay one tell me what\\'s wrong in this code:\\n `var containsDuplicate = function(nums) {\\n    let myMap = new Map([]);\\n    let res ;\\n    for(let i = 0 ; i<nums.length ; i++){\\n        if (myMap.has(nums[i])) {\\n            res = true;\\n            break;\\n        }\\n        myMap.set( i, nums[i]);        \\n    }\\n        return res;\\n};`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "if you initialize \"res\" at the beginning with false. The tests are becoming successful."
                    }
                ]
            },
            {
                "id": 1719841,
                "content": [
                    {
                        "username": "heyitsuday",
                        "content": "public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> seen = new HashSet<>();\\n    for (int num : nums) {\\n        if (seen.contains(num)) {\\n            return true;\\n        }\\n        seen.add(num);\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "masipulislam",
                        "content": "for i in range(1, len(nums)):\\n            if nums[i] == nums[i - 1]:\\n                dup += 1\\n        return dup != 0"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "your are comparing the adjacent elements there can be duplicates any where in array\\n"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "I used ArrayList here and Time Limit Exceeded for 5 test cases, why is it so?\\n"
                    },
                    {
                        "username": "Sarvadnya_L",
                        "content": "Why am I getting TLE if I am using ArrayList, and not when I use HashSet?"
                    },
                    {
                        "username": "aayushi_1409",
                        "content": "We can just use the loop for solving the problem "
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "why unordered map is not working for this problem. 64/70 testcases passed.\\nGot error for this array:\\n [7,10,5,5,6,6,4,10,5,4,9,4,9,6,5,9,6,3,6,5,6,7,7,4,9,9,10,5,8,1,8,3,2,7,5,10,1,8,5,8,4,3,6,4,9,4,2,8,3,2,2,1,5,6,3,2,6,1,8,6,2,9,1,4,5,10,8,5,10,5,10,1,4,8,3,6,4,10,9,1,1,1,2,2,9,6,6,8,1,9,2,5,5,2,1,8,5,2,3,10]\\n\\ncan anybody explain why?\\n"
                    },
                    {
                        "username": "joacohao1",
                        "content": "i can not submit it because \"time limit exceeded\" . my solution works (i used two fors) why does this happen?"
                    },
                    {
                        "username": "SteeveT",
                        "content": "```    def containsDuplicate(self, nums):\\n        #i = 0\\n        table = {}\\n        # while(i <= len(nums)-1):\\n        for i in range(len(nums)):\\n            if nums[i] in table.keys():\\n                return True\\n            else:\\n                table[nums[i]] = i\\n            #i+=1\\n\\n        return False```\\n\\nWhenever I try to submit, it keeps giving me the error \"Time Limit Exceeded\".\\nAnd I feel like my code should be working fine without problems.\\nCould someone please explain why?"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "return 0 if(len(nums)==len(list(set(nums)))) else 1"
                    },
                    {
                        "username": "hend_",
                        "content": "can nay one tell me what\\'s wrong in this code:\\n `var containsDuplicate = function(nums) {\\n    let myMap = new Map([]);\\n    let res ;\\n    for(let i = 0 ; i<nums.length ; i++){\\n        if (myMap.has(nums[i])) {\\n            res = true;\\n            break;\\n        }\\n        myMap.set( i, nums[i]);        \\n    }\\n        return res;\\n};`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "if you initialize \"res\" at the beginning with false. The tests are becoming successful."
                    }
                ]
            },
            {
                "id": 1719115,
                "content": [
                    {
                        "username": "heyitsuday",
                        "content": "public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> seen = new HashSet<>();\\n    for (int num : nums) {\\n        if (seen.contains(num)) {\\n            return true;\\n        }\\n        seen.add(num);\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "masipulislam",
                        "content": "for i in range(1, len(nums)):\\n            if nums[i] == nums[i - 1]:\\n                dup += 1\\n        return dup != 0"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "your are comparing the adjacent elements there can be duplicates any where in array\\n"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "I used ArrayList here and Time Limit Exceeded for 5 test cases, why is it so?\\n"
                    },
                    {
                        "username": "Sarvadnya_L",
                        "content": "Why am I getting TLE if I am using ArrayList, and not when I use HashSet?"
                    },
                    {
                        "username": "aayushi_1409",
                        "content": "We can just use the loop for solving the problem "
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "why unordered map is not working for this problem. 64/70 testcases passed.\\nGot error for this array:\\n [7,10,5,5,6,6,4,10,5,4,9,4,9,6,5,9,6,3,6,5,6,7,7,4,9,9,10,5,8,1,8,3,2,7,5,10,1,8,5,8,4,3,6,4,9,4,2,8,3,2,2,1,5,6,3,2,6,1,8,6,2,9,1,4,5,10,8,5,10,5,10,1,4,8,3,6,4,10,9,1,1,1,2,2,9,6,6,8,1,9,2,5,5,2,1,8,5,2,3,10]\\n\\ncan anybody explain why?\\n"
                    },
                    {
                        "username": "joacohao1",
                        "content": "i can not submit it because \"time limit exceeded\" . my solution works (i used two fors) why does this happen?"
                    },
                    {
                        "username": "SteeveT",
                        "content": "```    def containsDuplicate(self, nums):\\n        #i = 0\\n        table = {}\\n        # while(i <= len(nums)-1):\\n        for i in range(len(nums)):\\n            if nums[i] in table.keys():\\n                return True\\n            else:\\n                table[nums[i]] = i\\n            #i+=1\\n\\n        return False```\\n\\nWhenever I try to submit, it keeps giving me the error \"Time Limit Exceeded\".\\nAnd I feel like my code should be working fine without problems.\\nCould someone please explain why?"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "return 0 if(len(nums)==len(list(set(nums)))) else 1"
                    },
                    {
                        "username": "hend_",
                        "content": "can nay one tell me what\\'s wrong in this code:\\n `var containsDuplicate = function(nums) {\\n    let myMap = new Map([]);\\n    let res ;\\n    for(let i = 0 ; i<nums.length ; i++){\\n        if (myMap.has(nums[i])) {\\n            res = true;\\n            break;\\n        }\\n        myMap.set( i, nums[i]);        \\n    }\\n        return res;\\n};`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "if you initialize \"res\" at the beginning with false. The tests are becoming successful."
                    }
                ]
            },
            {
                "id": 1717207,
                "content": [
                    {
                        "username": "heyitsuday",
                        "content": "public boolean containsDuplicate(int[] nums) {\\n    Set<Integer> seen = new HashSet<>();\\n    for (int num : nums) {\\n        if (seen.contains(num)) {\\n            return true;\\n        }\\n        seen.add(num);\\n    }\\n    return false;\\n}\\n"
                    },
                    {
                        "username": "masipulislam",
                        "content": "for i in range(1, len(nums)):\\n            if nums[i] == nums[i - 1]:\\n                dup += 1\\n        return dup != 0"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "your are comparing the adjacent elements there can be duplicates any where in array\\n"
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "I used ArrayList here and Time Limit Exceeded for 5 test cases, why is it so?\\n"
                    },
                    {
                        "username": "Sarvadnya_L",
                        "content": "Why am I getting TLE if I am using ArrayList, and not when I use HashSet?"
                    },
                    {
                        "username": "aayushi_1409",
                        "content": "We can just use the loop for solving the problem "
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "why unordered map is not working for this problem. 64/70 testcases passed.\\nGot error for this array:\\n [7,10,5,5,6,6,4,10,5,4,9,4,9,6,5,9,6,3,6,5,6,7,7,4,9,9,10,5,8,1,8,3,2,7,5,10,1,8,5,8,4,3,6,4,9,4,2,8,3,2,2,1,5,6,3,2,6,1,8,6,2,9,1,4,5,10,8,5,10,5,10,1,4,8,3,6,4,10,9,1,1,1,2,2,9,6,6,8,1,9,2,5,5,2,1,8,5,2,3,10]\\n\\ncan anybody explain why?\\n"
                    },
                    {
                        "username": "joacohao1",
                        "content": "i can not submit it because \"time limit exceeded\" . my solution works (i used two fors) why does this happen?"
                    },
                    {
                        "username": "SteeveT",
                        "content": "```    def containsDuplicate(self, nums):\\n        #i = 0\\n        table = {}\\n        # while(i <= len(nums)-1):\\n        for i in range(len(nums)):\\n            if nums[i] in table.keys():\\n                return True\\n            else:\\n                table[nums[i]] = i\\n            #i+=1\\n\\n        return False```\\n\\nWhenever I try to submit, it keeps giving me the error \"Time Limit Exceeded\".\\nAnd I feel like my code should be working fine without problems.\\nCould someone please explain why?"
                    },
                    {
                        "username": "sravaniyenumala388",
                        "content": "return 0 if(len(nums)==len(list(set(nums)))) else 1"
                    },
                    {
                        "username": "hend_",
                        "content": "can nay one tell me what\\'s wrong in this code:\\n `var containsDuplicate = function(nums) {\\n    let myMap = new Map([]);\\n    let res ;\\n    for(let i = 0 ; i<nums.length ; i++){\\n        if (myMap.has(nums[i])) {\\n            res = true;\\n            break;\\n        }\\n        myMap.set( i, nums[i]);        \\n    }\\n        return res;\\n};`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "if you initialize \"res\" at the beginning with false. The tests are becoming successful."
                    }
                ]
            },
            {
                "id": 1717194,
                "content": [
                    {
                        "username": "cheuk209",
                        "content": "There is definitely a bug here, output is always true even after I\\'ve taken away \\'return \"true\"\\' lol\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        num_dict = {}\\n        for num in nums:\\n            if num in num_dict:\\n                return \"yes\"\\n            num_dict[num] = \"yes\"\\n        return \"false\".`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "My solution is this it is O(n) with the help of Set.\\n\\n`class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> unique = new HashSet();\\n        for(Integer num : nums) {\\n            if(unique.add(num) == false) {\\n                return true;\\n            }\\n        }\\n\\n        return false;         \\n    }\\n}`"
                    },
                    {
                        "username": "prince_511",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\nsort(nums.begin(),nums.end());\\n       for(int i=0;i<nums.size()-1;++i)\\n           if(nums[i]==nums[i+1])\\n               return true;\\n               return false;\\n}"
                    },
                    {
                        "username": "vharasahiti04",
                        "content": "why is this code showing time limit exceeded error?\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n    \\n    for(int i=0;i< numsSize;i++)\\n    {\\n        int element = nums[i];\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[j]==element)\\n            {\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "user2715zw",
                        "content": "With Python , This is easy to deal , we can use set feature to solve this question:\\nreturn len(set(nums)) != len(nums)"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "`class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        if len(nums) != len(set(nums)):\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "aj_11",
                        "content": "I am using 2 for loops (nested) and it is giving me Time Limit Exceeded error while submitting."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        l1 = len(nums)\\n        a = set(nums)\\n        b = list(a)\\n        l2 = len(b)\\n        if l1 == l2:\\n            return False\\n        return True"
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int element = nums[i];\\n            for(int j=i+1;j<nums.size();++j)\\n            {\\n                if(nums[j] == element)\\n                    return true;\\n        }\\n        }\\n        return false;\\n    }\\n};your inline code...\\nWhy does it cross the time limit?`"
                    },
                    {
                        "username": "yashaswiniippili",
                        "content": " `bool containsDuplicate(int* nums, int numsSize)\\n{\\n    for(int i=0; i<numsSize; i++)\\n    {\\n        for(int j=i+1; j<numsSize; j++)\\n        {\\n            if(nums[i]==nums[j])\\n            return true;\\n        }\\n    }\\n    return false;\\n}`\\n\\nWhy am I getting the \"Time Limit Exceeded\" error ?"
                    }
                ]
            },
            {
                "id": 1717072,
                "content": [
                    {
                        "username": "cheuk209",
                        "content": "There is definitely a bug here, output is always true even after I\\'ve taken away \\'return \"true\"\\' lol\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        num_dict = {}\\n        for num in nums:\\n            if num in num_dict:\\n                return \"yes\"\\n            num_dict[num] = \"yes\"\\n        return \"false\".`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "My solution is this it is O(n) with the help of Set.\\n\\n`class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> unique = new HashSet();\\n        for(Integer num : nums) {\\n            if(unique.add(num) == false) {\\n                return true;\\n            }\\n        }\\n\\n        return false;         \\n    }\\n}`"
                    },
                    {
                        "username": "prince_511",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\nsort(nums.begin(),nums.end());\\n       for(int i=0;i<nums.size()-1;++i)\\n           if(nums[i]==nums[i+1])\\n               return true;\\n               return false;\\n}"
                    },
                    {
                        "username": "vharasahiti04",
                        "content": "why is this code showing time limit exceeded error?\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n    \\n    for(int i=0;i< numsSize;i++)\\n    {\\n        int element = nums[i];\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[j]==element)\\n            {\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "user2715zw",
                        "content": "With Python , This is easy to deal , we can use set feature to solve this question:\\nreturn len(set(nums)) != len(nums)"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "`class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        if len(nums) != len(set(nums)):\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "aj_11",
                        "content": "I am using 2 for loops (nested) and it is giving me Time Limit Exceeded error while submitting."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        l1 = len(nums)\\n        a = set(nums)\\n        b = list(a)\\n        l2 = len(b)\\n        if l1 == l2:\\n            return False\\n        return True"
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int element = nums[i];\\n            for(int j=i+1;j<nums.size();++j)\\n            {\\n                if(nums[j] == element)\\n                    return true;\\n        }\\n        }\\n        return false;\\n    }\\n};your inline code...\\nWhy does it cross the time limit?`"
                    },
                    {
                        "username": "yashaswiniippili",
                        "content": " `bool containsDuplicate(int* nums, int numsSize)\\n{\\n    for(int i=0; i<numsSize; i++)\\n    {\\n        for(int j=i+1; j<numsSize; j++)\\n        {\\n            if(nums[i]==nums[j])\\n            return true;\\n        }\\n    }\\n    return false;\\n}`\\n\\nWhy am I getting the \"Time Limit Exceeded\" error ?"
                    }
                ]
            },
            {
                "id": 1716234,
                "content": [
                    {
                        "username": "cheuk209",
                        "content": "There is definitely a bug here, output is always true even after I\\'ve taken away \\'return \"true\"\\' lol\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        num_dict = {}\\n        for num in nums:\\n            if num in num_dict:\\n                return \"yes\"\\n            num_dict[num] = \"yes\"\\n        return \"false\".`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "My solution is this it is O(n) with the help of Set.\\n\\n`class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> unique = new HashSet();\\n        for(Integer num : nums) {\\n            if(unique.add(num) == false) {\\n                return true;\\n            }\\n        }\\n\\n        return false;         \\n    }\\n}`"
                    },
                    {
                        "username": "prince_511",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\nsort(nums.begin(),nums.end());\\n       for(int i=0;i<nums.size()-1;++i)\\n           if(nums[i]==nums[i+1])\\n               return true;\\n               return false;\\n}"
                    },
                    {
                        "username": "vharasahiti04",
                        "content": "why is this code showing time limit exceeded error?\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n    \\n    for(int i=0;i< numsSize;i++)\\n    {\\n        int element = nums[i];\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[j]==element)\\n            {\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "user2715zw",
                        "content": "With Python , This is easy to deal , we can use set feature to solve this question:\\nreturn len(set(nums)) != len(nums)"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "`class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        if len(nums) != len(set(nums)):\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "aj_11",
                        "content": "I am using 2 for loops (nested) and it is giving me Time Limit Exceeded error while submitting."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        l1 = len(nums)\\n        a = set(nums)\\n        b = list(a)\\n        l2 = len(b)\\n        if l1 == l2:\\n            return False\\n        return True"
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int element = nums[i];\\n            for(int j=i+1;j<nums.size();++j)\\n            {\\n                if(nums[j] == element)\\n                    return true;\\n        }\\n        }\\n        return false;\\n    }\\n};your inline code...\\nWhy does it cross the time limit?`"
                    },
                    {
                        "username": "yashaswiniippili",
                        "content": " `bool containsDuplicate(int* nums, int numsSize)\\n{\\n    for(int i=0; i<numsSize; i++)\\n    {\\n        for(int j=i+1; j<numsSize; j++)\\n        {\\n            if(nums[i]==nums[j])\\n            return true;\\n        }\\n    }\\n    return false;\\n}`\\n\\nWhy am I getting the \"Time Limit Exceeded\" error ?"
                    }
                ]
            },
            {
                "id": 1715253,
                "content": [
                    {
                        "username": "cheuk209",
                        "content": "There is definitely a bug here, output is always true even after I\\'ve taken away \\'return \"true\"\\' lol\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        num_dict = {}\\n        for num in nums:\\n            if num in num_dict:\\n                return \"yes\"\\n            num_dict[num] = \"yes\"\\n        return \"false\".`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "My solution is this it is O(n) with the help of Set.\\n\\n`class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> unique = new HashSet();\\n        for(Integer num : nums) {\\n            if(unique.add(num) == false) {\\n                return true;\\n            }\\n        }\\n\\n        return false;         \\n    }\\n}`"
                    },
                    {
                        "username": "prince_511",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\nsort(nums.begin(),nums.end());\\n       for(int i=0;i<nums.size()-1;++i)\\n           if(nums[i]==nums[i+1])\\n               return true;\\n               return false;\\n}"
                    },
                    {
                        "username": "vharasahiti04",
                        "content": "why is this code showing time limit exceeded error?\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n    \\n    for(int i=0;i< numsSize;i++)\\n    {\\n        int element = nums[i];\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[j]==element)\\n            {\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "user2715zw",
                        "content": "With Python , This is easy to deal , we can use set feature to solve this question:\\nreturn len(set(nums)) != len(nums)"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "`class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        if len(nums) != len(set(nums)):\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "aj_11",
                        "content": "I am using 2 for loops (nested) and it is giving me Time Limit Exceeded error while submitting."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        l1 = len(nums)\\n        a = set(nums)\\n        b = list(a)\\n        l2 = len(b)\\n        if l1 == l2:\\n            return False\\n        return True"
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int element = nums[i];\\n            for(int j=i+1;j<nums.size();++j)\\n            {\\n                if(nums[j] == element)\\n                    return true;\\n        }\\n        }\\n        return false;\\n    }\\n};your inline code...\\nWhy does it cross the time limit?`"
                    },
                    {
                        "username": "yashaswiniippili",
                        "content": " `bool containsDuplicate(int* nums, int numsSize)\\n{\\n    for(int i=0; i<numsSize; i++)\\n    {\\n        for(int j=i+1; j<numsSize; j++)\\n        {\\n            if(nums[i]==nums[j])\\n            return true;\\n        }\\n    }\\n    return false;\\n}`\\n\\nWhy am I getting the \"Time Limit Exceeded\" error ?"
                    }
                ]
            },
            {
                "id": 1708256,
                "content": [
                    {
                        "username": "cheuk209",
                        "content": "There is definitely a bug here, output is always true even after I\\'ve taken away \\'return \"true\"\\' lol\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        num_dict = {}\\n        for num in nums:\\n            if num in num_dict:\\n                return \"yes\"\\n            num_dict[num] = \"yes\"\\n        return \"false\".`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "My solution is this it is O(n) with the help of Set.\\n\\n`class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> unique = new HashSet();\\n        for(Integer num : nums) {\\n            if(unique.add(num) == false) {\\n                return true;\\n            }\\n        }\\n\\n        return false;         \\n    }\\n}`"
                    },
                    {
                        "username": "prince_511",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\nsort(nums.begin(),nums.end());\\n       for(int i=0;i<nums.size()-1;++i)\\n           if(nums[i]==nums[i+1])\\n               return true;\\n               return false;\\n}"
                    },
                    {
                        "username": "vharasahiti04",
                        "content": "why is this code showing time limit exceeded error?\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n    \\n    for(int i=0;i< numsSize;i++)\\n    {\\n        int element = nums[i];\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[j]==element)\\n            {\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "user2715zw",
                        "content": "With Python , This is easy to deal , we can use set feature to solve this question:\\nreturn len(set(nums)) != len(nums)"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "`class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        if len(nums) != len(set(nums)):\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "aj_11",
                        "content": "I am using 2 for loops (nested) and it is giving me Time Limit Exceeded error while submitting."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        l1 = len(nums)\\n        a = set(nums)\\n        b = list(a)\\n        l2 = len(b)\\n        if l1 == l2:\\n            return False\\n        return True"
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int element = nums[i];\\n            for(int j=i+1;j<nums.size();++j)\\n            {\\n                if(nums[j] == element)\\n                    return true;\\n        }\\n        }\\n        return false;\\n    }\\n};your inline code...\\nWhy does it cross the time limit?`"
                    },
                    {
                        "username": "yashaswiniippili",
                        "content": " `bool containsDuplicate(int* nums, int numsSize)\\n{\\n    for(int i=0; i<numsSize; i++)\\n    {\\n        for(int j=i+1; j<numsSize; j++)\\n        {\\n            if(nums[i]==nums[j])\\n            return true;\\n        }\\n    }\\n    return false;\\n}`\\n\\nWhy am I getting the \"Time Limit Exceeded\" error ?"
                    }
                ]
            },
            {
                "id": 1707971,
                "content": [
                    {
                        "username": "cheuk209",
                        "content": "There is definitely a bug here, output is always true even after I\\'ve taken away \\'return \"true\"\\' lol\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        num_dict = {}\\n        for num in nums:\\n            if num in num_dict:\\n                return \"yes\"\\n            num_dict[num] = \"yes\"\\n        return \"false\".`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "My solution is this it is O(n) with the help of Set.\\n\\n`class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> unique = new HashSet();\\n        for(Integer num : nums) {\\n            if(unique.add(num) == false) {\\n                return true;\\n            }\\n        }\\n\\n        return false;         \\n    }\\n}`"
                    },
                    {
                        "username": "prince_511",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\nsort(nums.begin(),nums.end());\\n       for(int i=0;i<nums.size()-1;++i)\\n           if(nums[i]==nums[i+1])\\n               return true;\\n               return false;\\n}"
                    },
                    {
                        "username": "vharasahiti04",
                        "content": "why is this code showing time limit exceeded error?\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n    \\n    for(int i=0;i< numsSize;i++)\\n    {\\n        int element = nums[i];\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[j]==element)\\n            {\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "user2715zw",
                        "content": "With Python , This is easy to deal , we can use set feature to solve this question:\\nreturn len(set(nums)) != len(nums)"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "`class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        if len(nums) != len(set(nums)):\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "aj_11",
                        "content": "I am using 2 for loops (nested) and it is giving me Time Limit Exceeded error while submitting."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        l1 = len(nums)\\n        a = set(nums)\\n        b = list(a)\\n        l2 = len(b)\\n        if l1 == l2:\\n            return False\\n        return True"
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int element = nums[i];\\n            for(int j=i+1;j<nums.size();++j)\\n            {\\n                if(nums[j] == element)\\n                    return true;\\n        }\\n        }\\n        return false;\\n    }\\n};your inline code...\\nWhy does it cross the time limit?`"
                    },
                    {
                        "username": "yashaswiniippili",
                        "content": " `bool containsDuplicate(int* nums, int numsSize)\\n{\\n    for(int i=0; i<numsSize; i++)\\n    {\\n        for(int j=i+1; j<numsSize; j++)\\n        {\\n            if(nums[i]==nums[j])\\n            return true;\\n        }\\n    }\\n    return false;\\n}`\\n\\nWhy am I getting the \"Time Limit Exceeded\" error ?"
                    }
                ]
            },
            {
                "id": 1706593,
                "content": [
                    {
                        "username": "cheuk209",
                        "content": "There is definitely a bug here, output is always true even after I\\'ve taken away \\'return \"true\"\\' lol\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        num_dict = {}\\n        for num in nums:\\n            if num in num_dict:\\n                return \"yes\"\\n            num_dict[num] = \"yes\"\\n        return \"false\".`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "My solution is this it is O(n) with the help of Set.\\n\\n`class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> unique = new HashSet();\\n        for(Integer num : nums) {\\n            if(unique.add(num) == false) {\\n                return true;\\n            }\\n        }\\n\\n        return false;         \\n    }\\n}`"
                    },
                    {
                        "username": "prince_511",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\nsort(nums.begin(),nums.end());\\n       for(int i=0;i<nums.size()-1;++i)\\n           if(nums[i]==nums[i+1])\\n               return true;\\n               return false;\\n}"
                    },
                    {
                        "username": "vharasahiti04",
                        "content": "why is this code showing time limit exceeded error?\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n    \\n    for(int i=0;i< numsSize;i++)\\n    {\\n        int element = nums[i];\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[j]==element)\\n            {\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "user2715zw",
                        "content": "With Python , This is easy to deal , we can use set feature to solve this question:\\nreturn len(set(nums)) != len(nums)"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "`class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        if len(nums) != len(set(nums)):\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "aj_11",
                        "content": "I am using 2 for loops (nested) and it is giving me Time Limit Exceeded error while submitting."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        l1 = len(nums)\\n        a = set(nums)\\n        b = list(a)\\n        l2 = len(b)\\n        if l1 == l2:\\n            return False\\n        return True"
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int element = nums[i];\\n            for(int j=i+1;j<nums.size();++j)\\n            {\\n                if(nums[j] == element)\\n                    return true;\\n        }\\n        }\\n        return false;\\n    }\\n};your inline code...\\nWhy does it cross the time limit?`"
                    },
                    {
                        "username": "yashaswiniippili",
                        "content": " `bool containsDuplicate(int* nums, int numsSize)\\n{\\n    for(int i=0; i<numsSize; i++)\\n    {\\n        for(int j=i+1; j<numsSize; j++)\\n        {\\n            if(nums[i]==nums[j])\\n            return true;\\n        }\\n    }\\n    return false;\\n}`\\n\\nWhy am I getting the \"Time Limit Exceeded\" error ?"
                    }
                ]
            },
            {
                "id": 1706197,
                "content": [
                    {
                        "username": "cheuk209",
                        "content": "There is definitely a bug here, output is always true even after I\\'ve taken away \\'return \"true\"\\' lol\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        num_dict = {}\\n        for num in nums:\\n            if num in num_dict:\\n                return \"yes\"\\n            num_dict[num] = \"yes\"\\n        return \"false\".`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "My solution is this it is O(n) with the help of Set.\\n\\n`class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> unique = new HashSet();\\n        for(Integer num : nums) {\\n            if(unique.add(num) == false) {\\n                return true;\\n            }\\n        }\\n\\n        return false;         \\n    }\\n}`"
                    },
                    {
                        "username": "prince_511",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\nsort(nums.begin(),nums.end());\\n       for(int i=0;i<nums.size()-1;++i)\\n           if(nums[i]==nums[i+1])\\n               return true;\\n               return false;\\n}"
                    },
                    {
                        "username": "vharasahiti04",
                        "content": "why is this code showing time limit exceeded error?\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n    \\n    for(int i=0;i< numsSize;i++)\\n    {\\n        int element = nums[i];\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[j]==element)\\n            {\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "user2715zw",
                        "content": "With Python , This is easy to deal , we can use set feature to solve this question:\\nreturn len(set(nums)) != len(nums)"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "`class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        if len(nums) != len(set(nums)):\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "aj_11",
                        "content": "I am using 2 for loops (nested) and it is giving me Time Limit Exceeded error while submitting."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        l1 = len(nums)\\n        a = set(nums)\\n        b = list(a)\\n        l2 = len(b)\\n        if l1 == l2:\\n            return False\\n        return True"
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int element = nums[i];\\n            for(int j=i+1;j<nums.size();++j)\\n            {\\n                if(nums[j] == element)\\n                    return true;\\n        }\\n        }\\n        return false;\\n    }\\n};your inline code...\\nWhy does it cross the time limit?`"
                    },
                    {
                        "username": "yashaswiniippili",
                        "content": " `bool containsDuplicate(int* nums, int numsSize)\\n{\\n    for(int i=0; i<numsSize; i++)\\n    {\\n        for(int j=i+1; j<numsSize; j++)\\n        {\\n            if(nums[i]==nums[j])\\n            return true;\\n        }\\n    }\\n    return false;\\n}`\\n\\nWhy am I getting the \"Time Limit Exceeded\" error ?"
                    }
                ]
            },
            {
                "id": 1704076,
                "content": [
                    {
                        "username": "cheuk209",
                        "content": "There is definitely a bug here, output is always true even after I\\'ve taken away \\'return \"true\"\\' lol\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        num_dict = {}\\n        for num in nums:\\n            if num in num_dict:\\n                return \"yes\"\\n            num_dict[num] = \"yes\"\\n        return \"false\".`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "My solution is this it is O(n) with the help of Set.\\n\\n`class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> unique = new HashSet();\\n        for(Integer num : nums) {\\n            if(unique.add(num) == false) {\\n                return true;\\n            }\\n        }\\n\\n        return false;         \\n    }\\n}`"
                    },
                    {
                        "username": "prince_511",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\nsort(nums.begin(),nums.end());\\n       for(int i=0;i<nums.size()-1;++i)\\n           if(nums[i]==nums[i+1])\\n               return true;\\n               return false;\\n}"
                    },
                    {
                        "username": "vharasahiti04",
                        "content": "why is this code showing time limit exceeded error?\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n    \\n    for(int i=0;i< numsSize;i++)\\n    {\\n        int element = nums[i];\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[j]==element)\\n            {\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "user2715zw",
                        "content": "With Python , This is easy to deal , we can use set feature to solve this question:\\nreturn len(set(nums)) != len(nums)"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "`class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        if len(nums) != len(set(nums)):\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "aj_11",
                        "content": "I am using 2 for loops (nested) and it is giving me Time Limit Exceeded error while submitting."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        l1 = len(nums)\\n        a = set(nums)\\n        b = list(a)\\n        l2 = len(b)\\n        if l1 == l2:\\n            return False\\n        return True"
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int element = nums[i];\\n            for(int j=i+1;j<nums.size();++j)\\n            {\\n                if(nums[j] == element)\\n                    return true;\\n        }\\n        }\\n        return false;\\n    }\\n};your inline code...\\nWhy does it cross the time limit?`"
                    },
                    {
                        "username": "yashaswiniippili",
                        "content": " `bool containsDuplicate(int* nums, int numsSize)\\n{\\n    for(int i=0; i<numsSize; i++)\\n    {\\n        for(int j=i+1; j<numsSize; j++)\\n        {\\n            if(nums[i]==nums[j])\\n            return true;\\n        }\\n    }\\n    return false;\\n}`\\n\\nWhy am I getting the \"Time Limit Exceeded\" error ?"
                    }
                ]
            },
            {
                "id": 1701634,
                "content": [
                    {
                        "username": "cheuk209",
                        "content": "There is definitely a bug here, output is always true even after I\\'ve taken away \\'return \"true\"\\' lol\\n `class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        num_dict = {}\\n        for num in nums:\\n            if num in num_dict:\\n                return \"yes\"\\n            num_dict[num] = \"yes\"\\n        return \"false\".`"
                    },
                    {
                        "username": "muhittinkaya",
                        "content": "My solution is this it is O(n) with the help of Set.\\n\\n`class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Set<Integer> unique = new HashSet();\\n        for(Integer num : nums) {\\n            if(unique.add(num) == false) {\\n                return true;\\n            }\\n        }\\n\\n        return false;         \\n    }\\n}`"
                    },
                    {
                        "username": "prince_511",
                        "content": "bool containsDuplicate(vector<int>& nums) {\\nsort(nums.begin(),nums.end());\\n       for(int i=0;i<nums.size()-1;++i)\\n           if(nums[i]==nums[i+1])\\n               return true;\\n               return false;\\n}"
                    },
                    {
                        "username": "vharasahiti04",
                        "content": "why is this code showing time limit exceeded error?\\nbool containsDuplicate(int* nums, int numsSize)\\n{\\n    \\n    for(int i=0;i< numsSize;i++)\\n    {\\n        int element = nums[i];\\n        for(int j=i+1;j<numsSize;j++)\\n        {\\n            if(nums[j]==element)\\n            {\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "user2715zw",
                        "content": "With Python , This is easy to deal , we can use set feature to solve this question:\\nreturn len(set(nums)) != len(nums)"
                    },
                    {
                        "username": "ankisha5000",
                        "content": "`class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        if len(nums) != len(set(nums)):\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "aj_11",
                        "content": "I am using 2 for loops (nested) and it is giving me Time Limit Exceeded error while submitting."
                    },
                    {
                        "username": "20951a0578",
                        "content": "class Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        l1 = len(nums)\\n        a = set(nums)\\n        b = list(a)\\n        l2 = len(b)\\n        if l1 == l2:\\n            return False\\n        return True"
                    },
                    {
                        "username": "nrknawinrajkumar888",
                        "content": " `your inline code...\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int element = nums[i];\\n            for(int j=i+1;j<nums.size();++j)\\n            {\\n                if(nums[j] == element)\\n                    return true;\\n        }\\n        }\\n        return false;\\n    }\\n};your inline code...\\nWhy does it cross the time limit?`"
                    },
                    {
                        "username": "yashaswiniippili",
                        "content": " `bool containsDuplicate(int* nums, int numsSize)\\n{\\n    for(int i=0; i<numsSize; i++)\\n    {\\n        for(int j=i+1; j<numsSize; j++)\\n        {\\n            if(nums[i]==nums[j])\\n            return true;\\n        }\\n    }\\n    return false;\\n}`\\n\\nWhy am I getting the \"Time Limit Exceeded\" error ?"
                    }
                ]
            },
            {
                "id": 1698970,
                "content": [
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Why this code create TLE...?\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        bool flag = false;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j =i+1; j<nums.size(); j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n  }\\n};"
                    },
                    {
                        "username": "Vasant79",
                        "content": "One easy solution :\\n- first sort array (Arrays.sort(nums)).\\n-loop through sorted array and compare(I with its next one), if matches return true."
                    },
                    {
                        "username": "KrazyCod3r",
                        "content": "Answer in Java:\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int flag=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            int j=i+1;\\n            if(nums[i]==nums[j]){\\n                flag++;\\n            }\\n\\n        }\\n        if(flag>0) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "avneshrajput021",
                        "content": " `class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer>Set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            Set.add(nums[i]);\\n        }\\n        if(Set.size()==nums.length){\\n            return false;\\n        }\\n        return true;\\n    }\\n}.`"
                    },
                    {
                        "username": "abc123Gh",
                        "content": "When using a hash set why is it checking for existence of number is faster than comparing the length / count of the hash set against the array ?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "Can anyone please help me?\\ni feel like my code is perfectly fine then only 65/70 test case are passed?\\n\\nhere is my code\\npublic boolean containsDuplicate(int[] nums) {\\n        boolean check = false;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[i] == nums[j] && i!=j){\\n                check = true;\\n                break;\\n                }\\n            }   \\n        }\\n        return check;\\n    }"
                    },
                    {
                        "username": "architthakur",
                        "content": "`class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        visited = []\n\n        for num in nums:\n            \n            if num in visited:\n                return True\n            else:\n                visited.append(num)\n                \n\n        return False`\n\n\nTo determine if there is a duplicate elements, I created a visited set, kept on adding the num in visited set (if it's already not there). If it is already there, I'll return true. \n\nIf non of this happens then I'll just return False, saying that there is no duplicate element in the initial array. \n\nLogically it seems correct to me but I do not know why it gives a Time Limit Exceeded error. How to fix the time limit exceeded error?\n       \n"
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "arrays.sort will help you to run loop single time for all value."
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n                if(nums[i]==nums[i+1])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n    }"
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Yes, logically its perfectly fine. But when you run a for loop, then you create O(n) time complexity, larger the array, more time it needs. Try using set() method from Python to identify the unique elements from array, instead of making visited array manually, which uses Hash-map with a constant time complexity."
                    },
                    {
                        "username": "WarrenWongCodes",
                        "content": "I see a lot of explanations using the Array.prototype.sort method, but isn\\'t the run time on that log linear O (n Log n)? Wouldn\\'t that be worse than O(n) linear time? "
                    },
                    {
                        "username": "rabbii",
                        "content": "using namespace std;\\n\\n   bool containsDuplicate(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); ++i){\\n            for ( int  j = i+1 ; j < nums.size(); ++j){\\n                if ( nums[i] ==  nums[j]){\\n                    return 1;\\n\\n                }\\n                return 0;\\n\\n            }\\n        }\\n\\n    }\\n\\ni tried this approach but found Time Limit Exceeded."
                    },
                    {
                        "username": "kinetic_dev",
                        "content": "is there any way to do it with bit manupulation ??"
                    }
                ]
            },
            {
                "id": 1695735,
                "content": [
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Why this code create TLE...?\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        bool flag = false;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j =i+1; j<nums.size(); j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n  }\\n};"
                    },
                    {
                        "username": "Vasant79",
                        "content": "One easy solution :\\n- first sort array (Arrays.sort(nums)).\\n-loop through sorted array and compare(I with its next one), if matches return true."
                    },
                    {
                        "username": "KrazyCod3r",
                        "content": "Answer in Java:\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int flag=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            int j=i+1;\\n            if(nums[i]==nums[j]){\\n                flag++;\\n            }\\n\\n        }\\n        if(flag>0) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "avneshrajput021",
                        "content": " `class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer>Set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            Set.add(nums[i]);\\n        }\\n        if(Set.size()==nums.length){\\n            return false;\\n        }\\n        return true;\\n    }\\n}.`"
                    },
                    {
                        "username": "abc123Gh",
                        "content": "When using a hash set why is it checking for existence of number is faster than comparing the length / count of the hash set against the array ?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "Can anyone please help me?\\ni feel like my code is perfectly fine then only 65/70 test case are passed?\\n\\nhere is my code\\npublic boolean containsDuplicate(int[] nums) {\\n        boolean check = false;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[i] == nums[j] && i!=j){\\n                check = true;\\n                break;\\n                }\\n            }   \\n        }\\n        return check;\\n    }"
                    },
                    {
                        "username": "architthakur",
                        "content": "`class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        visited = []\n\n        for num in nums:\n            \n            if num in visited:\n                return True\n            else:\n                visited.append(num)\n                \n\n        return False`\n\n\nTo determine if there is a duplicate elements, I created a visited set, kept on adding the num in visited set (if it's already not there). If it is already there, I'll return true. \n\nIf non of this happens then I'll just return False, saying that there is no duplicate element in the initial array. \n\nLogically it seems correct to me but I do not know why it gives a Time Limit Exceeded error. How to fix the time limit exceeded error?\n       \n"
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "arrays.sort will help you to run loop single time for all value."
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n                if(nums[i]==nums[i+1])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n    }"
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Yes, logically its perfectly fine. But when you run a for loop, then you create O(n) time complexity, larger the array, more time it needs. Try using set() method from Python to identify the unique elements from array, instead of making visited array manually, which uses Hash-map with a constant time complexity."
                    },
                    {
                        "username": "WarrenWongCodes",
                        "content": "I see a lot of explanations using the Array.prototype.sort method, but isn\\'t the run time on that log linear O (n Log n)? Wouldn\\'t that be worse than O(n) linear time? "
                    },
                    {
                        "username": "rabbii",
                        "content": "using namespace std;\\n\\n   bool containsDuplicate(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); ++i){\\n            for ( int  j = i+1 ; j < nums.size(); ++j){\\n                if ( nums[i] ==  nums[j]){\\n                    return 1;\\n\\n                }\\n                return 0;\\n\\n            }\\n        }\\n\\n    }\\n\\ni tried this approach but found Time Limit Exceeded."
                    },
                    {
                        "username": "kinetic_dev",
                        "content": "is there any way to do it with bit manupulation ??"
                    }
                ]
            },
            {
                "id": 1695314,
                "content": [
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Why this code create TLE...?\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        bool flag = false;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j =i+1; j<nums.size(); j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n  }\\n};"
                    },
                    {
                        "username": "Vasant79",
                        "content": "One easy solution :\\n- first sort array (Arrays.sort(nums)).\\n-loop through sorted array and compare(I with its next one), if matches return true."
                    },
                    {
                        "username": "KrazyCod3r",
                        "content": "Answer in Java:\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int flag=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            int j=i+1;\\n            if(nums[i]==nums[j]){\\n                flag++;\\n            }\\n\\n        }\\n        if(flag>0) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "avneshrajput021",
                        "content": " `class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer>Set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            Set.add(nums[i]);\\n        }\\n        if(Set.size()==nums.length){\\n            return false;\\n        }\\n        return true;\\n    }\\n}.`"
                    },
                    {
                        "username": "abc123Gh",
                        "content": "When using a hash set why is it checking for existence of number is faster than comparing the length / count of the hash set against the array ?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "Can anyone please help me?\\ni feel like my code is perfectly fine then only 65/70 test case are passed?\\n\\nhere is my code\\npublic boolean containsDuplicate(int[] nums) {\\n        boolean check = false;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[i] == nums[j] && i!=j){\\n                check = true;\\n                break;\\n                }\\n            }   \\n        }\\n        return check;\\n    }"
                    },
                    {
                        "username": "architthakur",
                        "content": "`class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        visited = []\n\n        for num in nums:\n            \n            if num in visited:\n                return True\n            else:\n                visited.append(num)\n                \n\n        return False`\n\n\nTo determine if there is a duplicate elements, I created a visited set, kept on adding the num in visited set (if it's already not there). If it is already there, I'll return true. \n\nIf non of this happens then I'll just return False, saying that there is no duplicate element in the initial array. \n\nLogically it seems correct to me but I do not know why it gives a Time Limit Exceeded error. How to fix the time limit exceeded error?\n       \n"
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "arrays.sort will help you to run loop single time for all value."
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n                if(nums[i]==nums[i+1])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n    }"
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Yes, logically its perfectly fine. But when you run a for loop, then you create O(n) time complexity, larger the array, more time it needs. Try using set() method from Python to identify the unique elements from array, instead of making visited array manually, which uses Hash-map with a constant time complexity."
                    },
                    {
                        "username": "WarrenWongCodes",
                        "content": "I see a lot of explanations using the Array.prototype.sort method, but isn\\'t the run time on that log linear O (n Log n)? Wouldn\\'t that be worse than O(n) linear time? "
                    },
                    {
                        "username": "rabbii",
                        "content": "using namespace std;\\n\\n   bool containsDuplicate(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); ++i){\\n            for ( int  j = i+1 ; j < nums.size(); ++j){\\n                if ( nums[i] ==  nums[j]){\\n                    return 1;\\n\\n                }\\n                return 0;\\n\\n            }\\n        }\\n\\n    }\\n\\ni tried this approach but found Time Limit Exceeded."
                    },
                    {
                        "username": "kinetic_dev",
                        "content": "is there any way to do it with bit manupulation ??"
                    }
                ]
            },
            {
                "id": 1694932,
                "content": [
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Why this code create TLE...?\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        bool flag = false;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j =i+1; j<nums.size(); j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n  }\\n};"
                    },
                    {
                        "username": "Vasant79",
                        "content": "One easy solution :\\n- first sort array (Arrays.sort(nums)).\\n-loop through sorted array and compare(I with its next one), if matches return true."
                    },
                    {
                        "username": "KrazyCod3r",
                        "content": "Answer in Java:\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int flag=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            int j=i+1;\\n            if(nums[i]==nums[j]){\\n                flag++;\\n            }\\n\\n        }\\n        if(flag>0) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "avneshrajput021",
                        "content": " `class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer>Set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            Set.add(nums[i]);\\n        }\\n        if(Set.size()==nums.length){\\n            return false;\\n        }\\n        return true;\\n    }\\n}.`"
                    },
                    {
                        "username": "abc123Gh",
                        "content": "When using a hash set why is it checking for existence of number is faster than comparing the length / count of the hash set against the array ?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "Can anyone please help me?\\ni feel like my code is perfectly fine then only 65/70 test case are passed?\\n\\nhere is my code\\npublic boolean containsDuplicate(int[] nums) {\\n        boolean check = false;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[i] == nums[j] && i!=j){\\n                check = true;\\n                break;\\n                }\\n            }   \\n        }\\n        return check;\\n    }"
                    },
                    {
                        "username": "architthakur",
                        "content": "`class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        visited = []\n\n        for num in nums:\n            \n            if num in visited:\n                return True\n            else:\n                visited.append(num)\n                \n\n        return False`\n\n\nTo determine if there is a duplicate elements, I created a visited set, kept on adding the num in visited set (if it's already not there). If it is already there, I'll return true. \n\nIf non of this happens then I'll just return False, saying that there is no duplicate element in the initial array. \n\nLogically it seems correct to me but I do not know why it gives a Time Limit Exceeded error. How to fix the time limit exceeded error?\n       \n"
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "arrays.sort will help you to run loop single time for all value."
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n                if(nums[i]==nums[i+1])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n    }"
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Yes, logically its perfectly fine. But when you run a for loop, then you create O(n) time complexity, larger the array, more time it needs. Try using set() method from Python to identify the unique elements from array, instead of making visited array manually, which uses Hash-map with a constant time complexity."
                    },
                    {
                        "username": "WarrenWongCodes",
                        "content": "I see a lot of explanations using the Array.prototype.sort method, but isn\\'t the run time on that log linear O (n Log n)? Wouldn\\'t that be worse than O(n) linear time? "
                    },
                    {
                        "username": "rabbii",
                        "content": "using namespace std;\\n\\n   bool containsDuplicate(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); ++i){\\n            for ( int  j = i+1 ; j < nums.size(); ++j){\\n                if ( nums[i] ==  nums[j]){\\n                    return 1;\\n\\n                }\\n                return 0;\\n\\n            }\\n        }\\n\\n    }\\n\\ni tried this approach but found Time Limit Exceeded."
                    },
                    {
                        "username": "kinetic_dev",
                        "content": "is there any way to do it with bit manupulation ??"
                    }
                ]
            },
            {
                "id": 1693981,
                "content": [
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Why this code create TLE...?\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        bool flag = false;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j =i+1; j<nums.size(); j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n  }\\n};"
                    },
                    {
                        "username": "Vasant79",
                        "content": "One easy solution :\\n- first sort array (Arrays.sort(nums)).\\n-loop through sorted array and compare(I with its next one), if matches return true."
                    },
                    {
                        "username": "KrazyCod3r",
                        "content": "Answer in Java:\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int flag=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            int j=i+1;\\n            if(nums[i]==nums[j]){\\n                flag++;\\n            }\\n\\n        }\\n        if(flag>0) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "avneshrajput021",
                        "content": " `class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer>Set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            Set.add(nums[i]);\\n        }\\n        if(Set.size()==nums.length){\\n            return false;\\n        }\\n        return true;\\n    }\\n}.`"
                    },
                    {
                        "username": "abc123Gh",
                        "content": "When using a hash set why is it checking for existence of number is faster than comparing the length / count of the hash set against the array ?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "Can anyone please help me?\\ni feel like my code is perfectly fine then only 65/70 test case are passed?\\n\\nhere is my code\\npublic boolean containsDuplicate(int[] nums) {\\n        boolean check = false;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[i] == nums[j] && i!=j){\\n                check = true;\\n                break;\\n                }\\n            }   \\n        }\\n        return check;\\n    }"
                    },
                    {
                        "username": "architthakur",
                        "content": "`class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        visited = []\n\n        for num in nums:\n            \n            if num in visited:\n                return True\n            else:\n                visited.append(num)\n                \n\n        return False`\n\n\nTo determine if there is a duplicate elements, I created a visited set, kept on adding the num in visited set (if it's already not there). If it is already there, I'll return true. \n\nIf non of this happens then I'll just return False, saying that there is no duplicate element in the initial array. \n\nLogically it seems correct to me but I do not know why it gives a Time Limit Exceeded error. How to fix the time limit exceeded error?\n       \n"
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "arrays.sort will help you to run loop single time for all value."
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n                if(nums[i]==nums[i+1])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n    }"
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Yes, logically its perfectly fine. But when you run a for loop, then you create O(n) time complexity, larger the array, more time it needs. Try using set() method from Python to identify the unique elements from array, instead of making visited array manually, which uses Hash-map with a constant time complexity."
                    },
                    {
                        "username": "WarrenWongCodes",
                        "content": "I see a lot of explanations using the Array.prototype.sort method, but isn\\'t the run time on that log linear O (n Log n)? Wouldn\\'t that be worse than O(n) linear time? "
                    },
                    {
                        "username": "rabbii",
                        "content": "using namespace std;\\n\\n   bool containsDuplicate(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); ++i){\\n            for ( int  j = i+1 ; j < nums.size(); ++j){\\n                if ( nums[i] ==  nums[j]){\\n                    return 1;\\n\\n                }\\n                return 0;\\n\\n            }\\n        }\\n\\n    }\\n\\ni tried this approach but found Time Limit Exceeded."
                    },
                    {
                        "username": "kinetic_dev",
                        "content": "is there any way to do it with bit manupulation ??"
                    }
                ]
            },
            {
                "id": 1693157,
                "content": [
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Why this code create TLE...?\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        bool flag = false;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j =i+1; j<nums.size(); j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n  }\\n};"
                    },
                    {
                        "username": "Vasant79",
                        "content": "One easy solution :\\n- first sort array (Arrays.sort(nums)).\\n-loop through sorted array and compare(I with its next one), if matches return true."
                    },
                    {
                        "username": "KrazyCod3r",
                        "content": "Answer in Java:\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int flag=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            int j=i+1;\\n            if(nums[i]==nums[j]){\\n                flag++;\\n            }\\n\\n        }\\n        if(flag>0) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "avneshrajput021",
                        "content": " `class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer>Set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            Set.add(nums[i]);\\n        }\\n        if(Set.size()==nums.length){\\n            return false;\\n        }\\n        return true;\\n    }\\n}.`"
                    },
                    {
                        "username": "abc123Gh",
                        "content": "When using a hash set why is it checking for existence of number is faster than comparing the length / count of the hash set against the array ?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "Can anyone please help me?\\ni feel like my code is perfectly fine then only 65/70 test case are passed?\\n\\nhere is my code\\npublic boolean containsDuplicate(int[] nums) {\\n        boolean check = false;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[i] == nums[j] && i!=j){\\n                check = true;\\n                break;\\n                }\\n            }   \\n        }\\n        return check;\\n    }"
                    },
                    {
                        "username": "architthakur",
                        "content": "`class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        visited = []\n\n        for num in nums:\n            \n            if num in visited:\n                return True\n            else:\n                visited.append(num)\n                \n\n        return False`\n\n\nTo determine if there is a duplicate elements, I created a visited set, kept on adding the num in visited set (if it's already not there). If it is already there, I'll return true. \n\nIf non of this happens then I'll just return False, saying that there is no duplicate element in the initial array. \n\nLogically it seems correct to me but I do not know why it gives a Time Limit Exceeded error. How to fix the time limit exceeded error?\n       \n"
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "arrays.sort will help you to run loop single time for all value."
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n                if(nums[i]==nums[i+1])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n    }"
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Yes, logically its perfectly fine. But when you run a for loop, then you create O(n) time complexity, larger the array, more time it needs. Try using set() method from Python to identify the unique elements from array, instead of making visited array manually, which uses Hash-map with a constant time complexity."
                    },
                    {
                        "username": "WarrenWongCodes",
                        "content": "I see a lot of explanations using the Array.prototype.sort method, but isn\\'t the run time on that log linear O (n Log n)? Wouldn\\'t that be worse than O(n) linear time? "
                    },
                    {
                        "username": "rabbii",
                        "content": "using namespace std;\\n\\n   bool containsDuplicate(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); ++i){\\n            for ( int  j = i+1 ; j < nums.size(); ++j){\\n                if ( nums[i] ==  nums[j]){\\n                    return 1;\\n\\n                }\\n                return 0;\\n\\n            }\\n        }\\n\\n    }\\n\\ni tried this approach but found Time Limit Exceeded."
                    },
                    {
                        "username": "kinetic_dev",
                        "content": "is there any way to do it with bit manupulation ??"
                    }
                ]
            },
            {
                "id": 1692523,
                "content": [
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Why this code create TLE...?\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        bool flag = false;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j =i+1; j<nums.size(); j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n  }\\n};"
                    },
                    {
                        "username": "Vasant79",
                        "content": "One easy solution :\\n- first sort array (Arrays.sort(nums)).\\n-loop through sorted array and compare(I with its next one), if matches return true."
                    },
                    {
                        "username": "KrazyCod3r",
                        "content": "Answer in Java:\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int flag=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            int j=i+1;\\n            if(nums[i]==nums[j]){\\n                flag++;\\n            }\\n\\n        }\\n        if(flag>0) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "avneshrajput021",
                        "content": " `class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer>Set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            Set.add(nums[i]);\\n        }\\n        if(Set.size()==nums.length){\\n            return false;\\n        }\\n        return true;\\n    }\\n}.`"
                    },
                    {
                        "username": "abc123Gh",
                        "content": "When using a hash set why is it checking for existence of number is faster than comparing the length / count of the hash set against the array ?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "Can anyone please help me?\\ni feel like my code is perfectly fine then only 65/70 test case are passed?\\n\\nhere is my code\\npublic boolean containsDuplicate(int[] nums) {\\n        boolean check = false;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[i] == nums[j] && i!=j){\\n                check = true;\\n                break;\\n                }\\n            }   \\n        }\\n        return check;\\n    }"
                    },
                    {
                        "username": "architthakur",
                        "content": "`class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        visited = []\n\n        for num in nums:\n            \n            if num in visited:\n                return True\n            else:\n                visited.append(num)\n                \n\n        return False`\n\n\nTo determine if there is a duplicate elements, I created a visited set, kept on adding the num in visited set (if it's already not there). If it is already there, I'll return true. \n\nIf non of this happens then I'll just return False, saying that there is no duplicate element in the initial array. \n\nLogically it seems correct to me but I do not know why it gives a Time Limit Exceeded error. How to fix the time limit exceeded error?\n       \n"
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "arrays.sort will help you to run loop single time for all value."
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n                if(nums[i]==nums[i+1])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n    }"
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Yes, logically its perfectly fine. But when you run a for loop, then you create O(n) time complexity, larger the array, more time it needs. Try using set() method from Python to identify the unique elements from array, instead of making visited array manually, which uses Hash-map with a constant time complexity."
                    },
                    {
                        "username": "WarrenWongCodes",
                        "content": "I see a lot of explanations using the Array.prototype.sort method, but isn\\'t the run time on that log linear O (n Log n)? Wouldn\\'t that be worse than O(n) linear time? "
                    },
                    {
                        "username": "rabbii",
                        "content": "using namespace std;\\n\\n   bool containsDuplicate(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); ++i){\\n            for ( int  j = i+1 ; j < nums.size(); ++j){\\n                if ( nums[i] ==  nums[j]){\\n                    return 1;\\n\\n                }\\n                return 0;\\n\\n            }\\n        }\\n\\n    }\\n\\ni tried this approach but found Time Limit Exceeded."
                    },
                    {
                        "username": "kinetic_dev",
                        "content": "is there any way to do it with bit manupulation ??"
                    }
                ]
            },
            {
                "id": 1690781,
                "content": [
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Why this code create TLE...?\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        bool flag = false;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j =i+1; j<nums.size(); j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n  }\\n};"
                    },
                    {
                        "username": "Vasant79",
                        "content": "One easy solution :\\n- first sort array (Arrays.sort(nums)).\\n-loop through sorted array and compare(I with its next one), if matches return true."
                    },
                    {
                        "username": "KrazyCod3r",
                        "content": "Answer in Java:\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int flag=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            int j=i+1;\\n            if(nums[i]==nums[j]){\\n                flag++;\\n            }\\n\\n        }\\n        if(flag>0) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "avneshrajput021",
                        "content": " `class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer>Set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            Set.add(nums[i]);\\n        }\\n        if(Set.size()==nums.length){\\n            return false;\\n        }\\n        return true;\\n    }\\n}.`"
                    },
                    {
                        "username": "abc123Gh",
                        "content": "When using a hash set why is it checking for existence of number is faster than comparing the length / count of the hash set against the array ?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "Can anyone please help me?\\ni feel like my code is perfectly fine then only 65/70 test case are passed?\\n\\nhere is my code\\npublic boolean containsDuplicate(int[] nums) {\\n        boolean check = false;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[i] == nums[j] && i!=j){\\n                check = true;\\n                break;\\n                }\\n            }   \\n        }\\n        return check;\\n    }"
                    },
                    {
                        "username": "architthakur",
                        "content": "`class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        visited = []\n\n        for num in nums:\n            \n            if num in visited:\n                return True\n            else:\n                visited.append(num)\n                \n\n        return False`\n\n\nTo determine if there is a duplicate elements, I created a visited set, kept on adding the num in visited set (if it's already not there). If it is already there, I'll return true. \n\nIf non of this happens then I'll just return False, saying that there is no duplicate element in the initial array. \n\nLogically it seems correct to me but I do not know why it gives a Time Limit Exceeded error. How to fix the time limit exceeded error?\n       \n"
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "arrays.sort will help you to run loop single time for all value."
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n                if(nums[i]==nums[i+1])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n    }"
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Yes, logically its perfectly fine. But when you run a for loop, then you create O(n) time complexity, larger the array, more time it needs. Try using set() method from Python to identify the unique elements from array, instead of making visited array manually, which uses Hash-map with a constant time complexity."
                    },
                    {
                        "username": "WarrenWongCodes",
                        "content": "I see a lot of explanations using the Array.prototype.sort method, but isn\\'t the run time on that log linear O (n Log n)? Wouldn\\'t that be worse than O(n) linear time? "
                    },
                    {
                        "username": "rabbii",
                        "content": "using namespace std;\\n\\n   bool containsDuplicate(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); ++i){\\n            for ( int  j = i+1 ; j < nums.size(); ++j){\\n                if ( nums[i] ==  nums[j]){\\n                    return 1;\\n\\n                }\\n                return 0;\\n\\n            }\\n        }\\n\\n    }\\n\\ni tried this approach but found Time Limit Exceeded."
                    },
                    {
                        "username": "kinetic_dev",
                        "content": "is there any way to do it with bit manupulation ??"
                    }
                ]
            },
            {
                "id": 1687527,
                "content": [
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Why this code create TLE...?\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        bool flag = false;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j =i+1; j<nums.size(); j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n  }\\n};"
                    },
                    {
                        "username": "Vasant79",
                        "content": "One easy solution :\\n- first sort array (Arrays.sort(nums)).\\n-loop through sorted array and compare(I with its next one), if matches return true."
                    },
                    {
                        "username": "KrazyCod3r",
                        "content": "Answer in Java:\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int flag=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            int j=i+1;\\n            if(nums[i]==nums[j]){\\n                flag++;\\n            }\\n\\n        }\\n        if(flag>0) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "avneshrajput021",
                        "content": " `class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer>Set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            Set.add(nums[i]);\\n        }\\n        if(Set.size()==nums.length){\\n            return false;\\n        }\\n        return true;\\n    }\\n}.`"
                    },
                    {
                        "username": "abc123Gh",
                        "content": "When using a hash set why is it checking for existence of number is faster than comparing the length / count of the hash set against the array ?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "Can anyone please help me?\\ni feel like my code is perfectly fine then only 65/70 test case are passed?\\n\\nhere is my code\\npublic boolean containsDuplicate(int[] nums) {\\n        boolean check = false;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[i] == nums[j] && i!=j){\\n                check = true;\\n                break;\\n                }\\n            }   \\n        }\\n        return check;\\n    }"
                    },
                    {
                        "username": "architthakur",
                        "content": "`class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        visited = []\n\n        for num in nums:\n            \n            if num in visited:\n                return True\n            else:\n                visited.append(num)\n                \n\n        return False`\n\n\nTo determine if there is a duplicate elements, I created a visited set, kept on adding the num in visited set (if it's already not there). If it is already there, I'll return true. \n\nIf non of this happens then I'll just return False, saying that there is no duplicate element in the initial array. \n\nLogically it seems correct to me but I do not know why it gives a Time Limit Exceeded error. How to fix the time limit exceeded error?\n       \n"
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "arrays.sort will help you to run loop single time for all value."
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n                if(nums[i]==nums[i+1])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n    }"
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Yes, logically its perfectly fine. But when you run a for loop, then you create O(n) time complexity, larger the array, more time it needs. Try using set() method from Python to identify the unique elements from array, instead of making visited array manually, which uses Hash-map with a constant time complexity."
                    },
                    {
                        "username": "WarrenWongCodes",
                        "content": "I see a lot of explanations using the Array.prototype.sort method, but isn\\'t the run time on that log linear O (n Log n)? Wouldn\\'t that be worse than O(n) linear time? "
                    },
                    {
                        "username": "rabbii",
                        "content": "using namespace std;\\n\\n   bool containsDuplicate(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); ++i){\\n            for ( int  j = i+1 ; j < nums.size(); ++j){\\n                if ( nums[i] ==  nums[j]){\\n                    return 1;\\n\\n                }\\n                return 0;\\n\\n            }\\n        }\\n\\n    }\\n\\ni tried this approach but found Time Limit Exceeded."
                    },
                    {
                        "username": "kinetic_dev",
                        "content": "is there any way to do it with bit manupulation ??"
                    }
                ]
            },
            {
                "id": 1675905,
                "content": [
                    {
                        "username": "sau_rabh_s_7",
                        "content": "Why this code create TLE...?\\n\\nclass Solution {\\npublic:\\n    bool containsDuplicate(vector<int>& nums) {\\n        bool flag = false;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j =i+1; j<nums.size(); j++){\\n                if(nums[i] == nums[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n  }\\n};"
                    },
                    {
                        "username": "Vasant79",
                        "content": "One easy solution :\\n- first sort array (Arrays.sort(nums)).\\n-loop through sorted array and compare(I with its next one), if matches return true."
                    },
                    {
                        "username": "KrazyCod3r",
                        "content": "Answer in Java:\\n\\nclass Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        int flag=0;\\n        for(int i=0;i<nums.length-1;i++){\\n            int j=i+1;\\n            if(nums[i]==nums[j]){\\n                flag++;\\n            }\\n\\n        }\\n        if(flag>0) return true;\\n        else return false;\\n    }\\n}"
                    },
                    {
                        "username": "avneshrajput021",
                        "content": " `class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        HashSet<Integer>Set = new HashSet<>();\\n        for(int i=0;i<nums.length;i++){\\n            Set.add(nums[i]);\\n        }\\n        if(Set.size()==nums.length){\\n            return false;\\n        }\\n        return true;\\n    }\\n}.`"
                    },
                    {
                        "username": "abc123Gh",
                        "content": "When using a hash set why is it checking for existence of number is faster than comparing the length / count of the hash set against the array ?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "Can anyone please help me?\\ni feel like my code is perfectly fine then only 65/70 test case are passed?\\n\\nhere is my code\\npublic boolean containsDuplicate(int[] nums) {\\n        boolean check = false;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[i] == nums[j] && i!=j){\\n                check = true;\\n                break;\\n                }\\n            }   \\n        }\\n        return check;\\n    }"
                    },
                    {
                        "username": "architthakur",
                        "content": "`class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        visited = []\n\n        for num in nums:\n            \n            if num in visited:\n                return True\n            else:\n                visited.append(num)\n                \n\n        return False`\n\n\nTo determine if there is a duplicate elements, I created a visited set, kept on adding the num in visited set (if it's already not there). If it is already there, I'll return true. \n\nIf non of this happens then I'll just return False, saying that there is no duplicate element in the initial array. \n\nLogically it seems correct to me but I do not know why it gives a Time Limit Exceeded error. How to fix the time limit exceeded error?\n       \n"
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "arrays.sort will help you to run loop single time for all value."
                    },
                    {
                        "username": "bhagwatgoutam",
                        "content": "class Solution {\\n    public boolean containsDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++){\\n            \\n                if(nums[i]==nums[i+1])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n    }"
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Yes, logically its perfectly fine. But when you run a for loop, then you create O(n) time complexity, larger the array, more time it needs. Try using set() method from Python to identify the unique elements from array, instead of making visited array manually, which uses Hash-map with a constant time complexity."
                    },
                    {
                        "username": "WarrenWongCodes",
                        "content": "I see a lot of explanations using the Array.prototype.sort method, but isn\\'t the run time on that log linear O (n Log n)? Wouldn\\'t that be worse than O(n) linear time? "
                    },
                    {
                        "username": "rabbii",
                        "content": "using namespace std;\\n\\n   bool containsDuplicate(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); ++i){\\n            for ( int  j = i+1 ; j < nums.size(); ++j){\\n                if ( nums[i] ==  nums[j]){\\n                    return 1;\\n\\n                }\\n                return 0;\\n\\n            }\\n        }\\n\\n    }\\n\\ni tried this approach but found Time Limit Exceeded."
                    },
                    {
                        "username": "kinetic_dev",
                        "content": "is there any way to do it with bit manupulation ??"
                    }
                ]
            }
        ]
    }
]