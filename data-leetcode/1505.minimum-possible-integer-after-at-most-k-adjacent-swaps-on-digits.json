[
    {
        "title": "Coloring A Border",
        "question_content": "You are given an m x n integer matrix grid, and three integers row, col, and color. Each value in the grid represents the color of the grid square at that location.\nTwo squares are called adjacent if they are next to each other in any of the 4 directions.\nTwo squares belong to the same connected component if they have the same color and they are adjacent.\nThe border of a connected component is all the squares in the connected component that are either adjacent to (at least) a square not in the component, or on the boundary of the grid (the first or last row or column).\nYou should color the border of the connected component that contains the square grid[row][col] with color.\nReturn the final grid.\n&nbsp;\nExample 1:\nInput: grid = [[1,1],[1,2]], row = 0, col = 0, color = 3\nOutput: [[3,3],[3,2]]\nExample 2:\nInput: grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3\nOutput: [[1,3,3],[2,3,3]]\nExample 3:\nInput: grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2\nOutput: [[2,2,2],[2,1,2],[2,2,2]]\n&nbsp;\nConstraints:\n\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 50\n\t1 <= grid[i][j], color <= 1000\n\t0 <= row < m\n\t0 <= col < n",
        "solutions": [
            {
                "id": 282847,
                "title": "c-with-picture-dfs",
                "content": "From an initial point, perform DFS and flip the cell color to negative to track visited cells.\\n\\nAfter DFS is complete for the cell, check if this cell is inside. If so, flip its color back to the positive.\\n\\nIn the end, cells with the negative color are on the border. Change their color to the target color.\\n![image](https://assets.leetcode.com/users/votrubac/image_1556425139.png)\\n```\\nvoid dfs(vector<vector<int>>& g, int r, int c, int cl) {\\n  if (r < 0 || c < 0 || r >= g.size() || c >= g[r].size() || g[r][c] != cl) return;\\n  g[r][c] = -cl;\\n  dfs(g, r - 1, c, cl), dfs(g, r + 1, c, cl), dfs(g, r, c - 1, cl), dfs(g, r, c + 1, cl);\\n  if (r > 0 && r < g.size() - 1 && c > 0 && c < g[r].size() - 1 && cl == abs(g[r - 1][c]) &&\\n    cl == abs(g[r + 1][c]) && cl == abs(g[r][c - 1]) && cl == abs(g[r][c + 1]))\\n    g[r][c] = cl;\\n}\\nvector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n  dfs(grid, r0, c0, grid[r0][c0]);\\n  for (auto i = 0; i < grid.size(); ++i)\\n    for (auto j = 0; j < grid[i].size(); ++j) grid[i][j] = grid[i][j] < 0 ? color : grid[i][j];\\n  return grid;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid dfs(vector<vector<int>>& g, int r, int c, int cl) {\\n  if (r < 0 || c < 0 || r >= g.size() || c >= g[r].size() || g[r][c] != cl) return;\\n  g[r][c] = -cl;\\n  dfs(g, r - 1, c, cl), dfs(g, r + 1, c, cl), dfs(g, r, c - 1, cl), dfs(g, r, c + 1, cl);\\n  if (r > 0 && r < g.size() - 1 && c > 0 && c < g[r].size() - 1 && cl == abs(g[r - 1][c]) &&\\n    cl == abs(g[r + 1][c]) && cl == abs(g[r][c - 1]) && cl == abs(g[r][c + 1]))\\n    g[r][c] = cl;\\n}\\nvector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n  dfs(grid, r0, c0, grid[r0][c0]);\\n  for (auto i = 0; i < grid.size(); ++i)\\n    for (auto j = 0; j < grid[i].size(); ++j) grid[i][j] = grid[i][j] < 0 ? color : grid[i][j];\\n  return grid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282839,
                "title": "python-bfs-and-dfs",
                "content": "**Python, DFS:**\\n\\nSuggested by @IvanaGyro, we can color the border inside the DFS.\\n```\\n    def colorBorder(self, grid, r0, c0, color):\\n        seen, m, n = set(), len(grid), len(grid[0])\\n\\n        def dfs(x, y):\\n            if (x, y) in seen: return True\\n            if not (0 <= x < m and 0 <= y < n and grid[x][y] == grid[r0][c0]):\\n                return False\\n            seen.add((x, y))\\n            if dfs(x + 1, y) + dfs(x - 1, y) + dfs(x, y + 1) + dfs(x, y - 1) < 4:\\n                grid[x][y] = color\\n            return True\\n        dfs(r0, c0)\\n        return grid\\n```\\n\\n**Python, BFS:**\\n```\\n    def colorBorder(self, grid, r0, c0, color):\\n        m, n = len(grid), len(grid[0])\\n        bfs, component, border = [[r0, c0]], set([(r0, c0)]), set()\\n        for r0, c0 in bfs:\\n            for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n                r, c = r0 + i, c0 + j\\n                if 0 <= r < m and 0 <= c < n and grid[r][c] == grid[r0][c0]:\\n                    if (r, c) not in component:\\n                        bfs.append([r, c])\\n                        component.add((r, c))\\n                else:\\n                    border.add((r0, c0))\\n        for x, y in border: grid[x][y] = color\\n        return grid\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def colorBorder(self, grid, r0, c0, color):\\n        seen, m, n = set(), len(grid), len(grid[0])\\n\\n        def dfs(x, y):\\n            if (x, y) in seen: return True\\n            if not (0 <= x < m and 0 <= y < n and grid[x][y] == grid[r0][c0]):\\n                return False\\n            seen.add((x, y))\\n            if dfs(x + 1, y) + dfs(x - 1, y) + dfs(x, y + 1) + dfs(x, y - 1) < 4:\\n                grid[x][y] = color\\n            return True\\n        dfs(r0, c0)\\n        return grid\\n```\n```\\n    def colorBorder(self, grid, r0, c0, color):\\n        m, n = len(grid), len(grid[0])\\n        bfs, component, border = [[r0, c0]], set([(r0, c0)]), set()\\n        for r0, c0 in bfs:\\n            for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n                r, c = r0 + i, c0 + j\\n                if 0 <= r < m and 0 <= c < n and grid[r][c] == grid[r0][c0]:\\n                    if (r, c) not in component:\\n                        bfs.append([r, c])\\n                        component.add((r, c))\\n                else:\\n                    border.add((r0, c0))\\n        for x, y in border: grid[x][y] = color\\n        return grid\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 284935,
                "title": "java-dfs-easy-to-understand",
                "content": "The primary intuition is to do a DFS from the starting cell and find all the cells of the oldColor that needs to be changed. We mark these cells with a negative value of the oldColor. Once this is done, we need to find out which among those cells lies interior and which lies exterior. Interior cells have all 4 neighboring cells(top, bottom, left and right) to have either the oldColor value or -oldColor value. Make these interior cells positive again. Once we have processed this for all necessary nodes from the starting cell, we will get a grid containing negative cells that denote the boundary. We need to sweep through the entire grid and change these negative values to the new color.\\n\\n* Check for existence of null or empty grid and return null if so.\\n* Store the color of starting cell grid[r0][c0] in oldColor.\\n* Initiate a DFS from starting cell.\\n* Check if the current cell lies out of bounds off the grid or if current cell does not have the same color as starting cell and return if so.\\n* Otherwise, change the current cell\\'s color to a negative value for us to remember that we have processed this cell.\\n* Do a DFS for all neighboring points that are up, down, left and right from current cell.\\n* Once DFS returns back for the current cell after processing all directions from it, change the current cell\\'s color back to positive value if you find that the current cell lies within adjacent cells top, bottom, left and right with the same value.\\n* Once the entire DFS has been processed, we now have a grid containing negative values representing the border which needs to be recolored to the new color.\\n\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        if(grid == null || grid.length == 0)\\n            return null;\\n        int oldColor = grid[r0][c0];\\n        dfs(grid, r0, c0, oldColor);\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n    public void dfs(int[][] grid, int i, int j, int oldColor) {\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] != oldColor) \\n            return;\\n        grid[i][j] = -oldColor;\\n        dfs(grid, i+1, j, oldColor);\\n        dfs(grid, i-1, j, oldColor);\\n        dfs(grid, i, j+1, oldColor);\\n        dfs(grid, i, j-1, oldColor);\\n        if(i > 0 && j > 0 && i < grid.length-1 && j < grid[0].length-1\\n           && oldColor == Math.abs(grid[i+1][j])\\n           && oldColor == Math.abs(grid[i-1][j])\\n           && oldColor == Math.abs(grid[i][j+1])\\n           && oldColor == Math.abs(grid[i][j-1]))\\n            grid[i][j] = oldColor;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        if(grid == null || grid.length == 0)\\n            return null;\\n        int oldColor = grid[r0][c0];\\n        dfs(grid, r0, c0, oldColor);\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n    public void dfs(int[][] grid, int i, int j, int oldColor) {\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] != oldColor) \\n            return;\\n        grid[i][j] = -oldColor;\\n        dfs(grid, i+1, j, oldColor);\\n        dfs(grid, i-1, j, oldColor);\\n        dfs(grid, i, j+1, oldColor);\\n        dfs(grid, i, j-1, oldColor);\\n        if(i > 0 && j > 0 && i < grid.length-1 && j < grid[0].length-1\\n           && oldColor == Math.abs(grid[i+1][j])\\n           && oldColor == Math.abs(grid[i-1][j])\\n           && oldColor == Math.abs(grid[i][j+1])\\n           && oldColor == Math.abs(grid[i][j-1]))\\n            grid[i][j] = oldColor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693958,
                "title": "java-recursive-dfs-beats-100-time-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        if (grid[r0][c0]==color)\\n            return grid;\\n        \\n        boolean[][] visited = new boolean[n][m];\\n        dfs(grid, r0, c0, grid[r0][c0], visited, color, n, m);\\n        \\n        return grid;\\n        \\n    }\\n    \\n    public void dfs(int[][] grid, int i, int j, int col, boolean[][] visited, int target, int n, int m){\\n        \\n        if (i>n-1 || i<0 || j>m-1 || j<0 || grid[i][j]!=col || visited[i][j])\\n            return;\\n        \\n        visited[i][j] = true;\\n        boolean border = false;\\n        \\n        if (i==0 || j==0 || j==m-1 || i==n-1 || grid[i+1][j]!=col || grid[i-1][j]!=col || grid[i][j-1]!=col || grid[i][j+1]!=col)\\n            border = true;\\n        \\n        dfs(grid, i+1, j, col, visited, target, n, m);\\n        dfs(grid, i-1, j, col, visited, target, n, m);\\n        dfs(grid, i, j+1, col, visited, target, n, m);\\n        dfs(grid, i, j-1, col, visited, target, n, m);\\n        \\n        if (border)\\n            grid[i][j] = target;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        if (grid[r0][c0]==color)\\n            return grid;\\n        \\n        boolean[][] visited = new boolean[n][m];\\n        dfs(grid, r0, c0, grid[r0][c0], visited, color, n, m);\\n        \\n        return grid;\\n        \\n    }\\n    \\n    public void dfs(int[][] grid, int i, int j, int col, boolean[][] visited, int target, int n, int m){\\n        \\n        if (i>n-1 || i<0 || j>m-1 || j<0 || grid[i][j]!=col || visited[i][j])\\n            return;\\n        \\n        visited[i][j] = true;\\n        boolean border = false;\\n        \\n        if (i==0 || j==0 || j==m-1 || i==n-1 || grid[i+1][j]!=col || grid[i-1][j]!=col || grid[i][j-1]!=col || grid[i][j+1]!=col)\\n            border = true;\\n        \\n        dfs(grid, i+1, j, col, visited, target, n, m);\\n        dfs(grid, i-1, j, col, visited, target, n, m);\\n        dfs(grid, i, j+1, col, visited, target, n, m);\\n        dfs(grid, i, j-1, col, visited, target, n, m);\\n        \\n        if (border)\\n            grid[i][j] = target;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283262,
                "title": "java-python-3-bfs-and-dfs-codes-w-brief-explanation-and-analysis",
                "content": "**Method 1**:\\n\\n**BFS**\\n\\n1. Let m = grid.length, n = grid[0].length, use the number \\nfrom 0 to m * n - 1 to identify the cells to avoid duplicates;\\ne.g., grid[x][y]\\'s cell number is x * n + y; \\n2. put the initial cell [r0, c0] into the Queue then poll it out,\\nthen check if it is on the grid bounday; If yes, color the cell;\\n3. Traverse the cell\\'s 4 neighbors: \\na) if its neighbor is of different color, the cell is on the \\ncomponent border; \\nb) if same color, put the neighbor into Queue;\\n4. repeat the above 2 and 3 till Queue is empty.\\n\\n```java\\n    private static final int[] d = { 0, 1, 0, -1, 0 }; // neighbors\\' relative displacements.\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int clr = grid[r0][c0], m = grid.length, n = grid[0].length;\\n        Set<Integer> component = new HashSet<>(); // put the cell number into Set to avoid visiting again.\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[]{ r0, c0 }); // add initial cell.\\n        component.add(r0 * n + c0); // add initial cell number.\\n        while (!q.isEmpty()) { // BFS starts.\\n            int r = q.peek()[0], c = q.poll()[1];\\n            if (r == 0 || r == m - 1 || c == 0 || c == n - 1) { grid[r][c] = color; } // on grid boundary.\\n            for (int k = 0; k < 4; ++k) { // travers its 4 neighbors.\\n                int i = r + d[k], j = c + d[k + 1]; // neighbor coordinates.\\n                if (i >= 0 && i < m && j >= 0 && j < n && !component.contains(i * n + j)) { // not visited before.\\n                    if (grid[i][j] == clr) { // its neighbor is of same color, put it into Queue. \\n                        component.add(i * n + j); // avoid visiting again.\\n                        q.offer(new int[]{ i, j }); // put it into Queue. \\n                    }else { // its neighbor is of different color, hence it is on component boundary.\\n                        grid[r][c] = color; \\n                    }\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n```\\n```python\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n         m, n, clr = len(grid), len(grid[0]), grid[r0][c0]\\n        bfs, component = collections.deque([(r0, c0)]), {(r0, c0)}\\n        while bfs:\\n            r, c = bfs.popleft()\\n            if r * c * (r - m + 1) * (c - n + 1) == 0:\\n                grid[r][c] = color\\n            for i, j in (r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c):\\n                if m > i >= 0 <= j < n and (i, j) not in component:\\n                    if grid[i][j] == clr:\\n                        component.add((i, j))\\n                        bfs.append((i, j))\\n                    else:    \\n                        grid[r][c] = color\\n        return grid\\n```\\n\\n----\\n\\n**Method 2**: \\n\\n**DFS**\\n\\nUse DFS to explore the cell (r0, c0)\\'s component, and negate the visited cell, traverse its 4 neighbors. After the traversal, change back from the negative if the component cell belongs to inner part.\\n\\n```java\\n    private static final int[] d = { 0, 1, 0, -1, 0 }; // neighbors\\' relative displacements.\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        negateBorder(grid, r0, c0, grid[r0][c0]);\\n        for (int[] g : grid) {\\n            for (int i = 0; i < g.length; ++i) {\\n                if (g[i] < 0) { g[i] = color; }\\n            }\\n        }\\n        return grid;\\n    }\\n    private void negateBorder(int[][] grid, int r, int c, int clr) {\\n        grid[r][c] = -clr; // mark as visited.\\n        int cnt = 0; // use to count grid[r][c]\\'s component neighbors (same color as it).\\n        for (int k = 0; k < 4; ++k) { // traverse 4 neighbors.\\n            int i = r + d[k], j = c + d[k + 1]; // neighbor\\'s coordinates.\\n            if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || Math.abs(grid[i][j]) != clr) { continue; } // out of grid or not same component.\\n            ++cnt; // only if the 4 neighbors of grid[r][c] are all have same color as it, it belongs to inner part.\\n            if (grid[i][j] == clr) { negateBorder(grid, i, j, clr); } // recurse with respect to unvisited component neighbor.\\n        }\\n        if (cnt == 4) { grid[r][c] = clr; } // inner part, change back.\\n    }\\n```\\n```python\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n        m, n, clr = len(grid), len(grid[0]), grid[r0][c0]\\n\\n        def negateBorder(r, c):\\n            grid[r][c], cnt = -clr, 0\\n            for i, j in (r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c):\\n                if m > i >= 0 <= j < n:\\n                    cnt +=  abs(grid[i][j]) == clr\\n                    if grid[i][j] == clr:\\n                        negateBorder(i, j)\\n            if cnt == 4:\\n                grid[r][c] = clr\\n                \\n        negateBorder(r0, c0)\\n        for r, row in enumerate(grid):\\n            for c, cell in enumerate(row):\\n                if cell < 0:\\n                    grid[r][c] = color\\n        return grid\\n```\\n\\n**Analysis for both BFS and DFS:**\\nEach cell at most visited `4` times, therefore\\n\\nTime & space: `O(m * n)`, where `m = grid.length, n = grid[0].length.`",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```java\\n    private static final int[] d = { 0, 1, 0, -1, 0 }; // neighbors\\' relative displacements.\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int clr = grid[r0][c0], m = grid.length, n = grid[0].length;\\n        Set<Integer> component = new HashSet<>(); // put the cell number into Set to avoid visiting again.\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[]{ r0, c0 }); // add initial cell.\\n        component.add(r0 * n + c0); // add initial cell number.\\n        while (!q.isEmpty()) { // BFS starts.\\n            int r = q.peek()[0], c = q.poll()[1];\\n            if (r == 0 || r == m - 1 || c == 0 || c == n - 1) { grid[r][c] = color; } // on grid boundary.\\n            for (int k = 0; k < 4; ++k) { // travers its 4 neighbors.\\n                int i = r + d[k], j = c + d[k + 1]; // neighbor coordinates.\\n                if (i >= 0 && i < m && j >= 0 && j < n && !component.contains(i * n + j)) { // not visited before.\\n                    if (grid[i][j] == clr) { // its neighbor is of same color, put it into Queue. \\n                        component.add(i * n + j); // avoid visiting again.\\n                        q.offer(new int[]{ i, j }); // put it into Queue. \\n                    }else { // its neighbor is of different color, hence it is on component boundary.\\n                        grid[r][c] = color; \\n                    }\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n```\n```python\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n         m, n, clr = len(grid), len(grid[0]), grid[r0][c0]\\n        bfs, component = collections.deque([(r0, c0)]), {(r0, c0)}\\n        while bfs:\\n            r, c = bfs.popleft()\\n            if r * c * (r - m + 1) * (c - n + 1) == 0:\\n                grid[r][c] = color\\n            for i, j in (r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c):\\n                if m > i >= 0 <= j < n and (i, j) not in component:\\n                    if grid[i][j] == clr:\\n                        component.add((i, j))\\n                        bfs.append((i, j))\\n                    else:    \\n                        grid[r][c] = color\\n        return grid\\n```\n```java\\n    private static final int[] d = { 0, 1, 0, -1, 0 }; // neighbors\\' relative displacements.\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        negateBorder(grid, r0, c0, grid[r0][c0]);\\n        for (int[] g : grid) {\\n            for (int i = 0; i < g.length; ++i) {\\n                if (g[i] < 0) { g[i] = color; }\\n            }\\n        }\\n        return grid;\\n    }\\n    private void negateBorder(int[][] grid, int r, int c, int clr) {\\n        grid[r][c] = -clr; // mark as visited.\\n        int cnt = 0; // use to count grid[r][c]\\'s component neighbors (same color as it).\\n        for (int k = 0; k < 4; ++k) { // traverse 4 neighbors.\\n            int i = r + d[k], j = c + d[k + 1]; // neighbor\\'s coordinates.\\n            if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || Math.abs(grid[i][j]) != clr) { continue; } // out of grid or not same component.\\n            ++cnt; // only if the 4 neighbors of grid[r][c] are all have same color as it, it belongs to inner part.\\n            if (grid[i][j] == clr) { negateBorder(grid, i, j, clr); } // recurse with respect to unvisited component neighbor.\\n        }\\n        if (cnt == 4) { grid[r][c] = clr; } // inner part, change back.\\n    }\\n```\n```python\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n        m, n, clr = len(grid), len(grid[0]), grid[r0][c0]\\n\\n        def negateBorder(r, c):\\n            grid[r][c], cnt = -clr, 0\\n            for i, j in (r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c):\\n                if m > i >= 0 <= j < n:\\n                    cnt +=  abs(grid[i][j]) == clr\\n                    if grid[i][j] == clr:\\n                        negateBorder(i, j)\\n            if cnt == 4:\\n                grid[r][c] = clr\\n                \\n        negateBorder(r0, c0)\\n        for r, row in enumerate(grid):\\n            for c, cell in enumerate(row):\\n                if cell < 0:\\n                    grid[r][c] = color\\n        return grid\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 283084,
                "title": "confusing-problem-statement-resolved",
                "content": "What does this mean? \\n\\n> The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\n\\nAlso, I did not get how the `2` on the bottom left in the below example did not change? \\n\\n> [1,2,2]\\n[2,3,2]\\n\\nExpected Output:\\n\\n> [1, 3, 3]\\n[2, 3, 3]\\n\\nIn the above picture, `2` is on the bottom left which was untouched but it does satisfy `or on the boundary of the grid (the first or last row or column).` requirement. Why was it not changed to `3`?\\n\\n**CONFUSION RESOLVED:**\\n\\n* Basically, connected component means all the cells which have the same color as `(r0,c0)` whom you can reach with a `single` DFS or BFS starting from `(r0,c0)`. \\n\\n* You color a cell(**when reached from DFS or BFS**) which have the same color who is either at the border, meaning, first row or last row or first column or last column **OR** if that cell has `at least ` 1 different neighbour(meaning having different color).\\n\\n* **Note that**  I could have used `-1` as one of the ways of marking cells in my below code, but I rather find it silly because what if negative number coloring was allowed(LeetCode should add this as a follow up,lol) ? Best way I found was to use a boolean array for marking cells and safely coloring them. \\n\\nMy Solution:\\n\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        dfs(grid,r0,c0,grid[r0][c0],color,grid.length,grid[0].length,visited);        \\n        return grid;\\n    }\\n    \\n    private void dfs(int[][] grid,int row,int col,int color,int new_color,int rows,int cols,boolean[][] visited){\\n       if(!isValid(row,col,rows,cols) || visited[row][col] || grid[row][col] != color){\\n            return;\\n       }\\n     \\n        visited[row][col] = true;\\n        \\n        if(row == 0 || col == 0 || row == rows-1 || col == cols-1 || differentComponentNeighbours(grid,row,col,rows,cols,visited,color)){\\n            grid[row][col] = new_color;\\n        }\\n        \\n        dfs(grid,row-1,col,color,new_color,rows,cols,visited);\\n        dfs(grid,row+1,col,color,new_color,rows,cols,visited);\\n        dfs(grid,row,col-1,color,new_color,rows,cols,visited);\\n        dfs(grid,row,col+1,color,new_color,rows,cols,visited);\\n    }\\n    \\n    private boolean differentComponentNeighbours(int[][] grid,int row,int col,int rows,int cols,boolean[][] visited,int color){\\n        if(isValid(row-1,col,rows,cols) && !visited[row-1][col] && grid[row-1][col] != color) return true;\\n        if(isValid(row+1,col,rows,cols) && !visited[row+1][col] && grid[row+1][col] != color) return true;\\n        if(isValid(row,col-1,rows,cols) && !visited[row][col-1] && grid[row][col-1] != color) return true;\\n        if(isValid(row,col+1,rows,cols) && !visited[row][col+1] && grid[row][col+1] != color) return true;\\n        return false;\\n    }\\n    \\n    private boolean isValid(int row,int col,int rows,int cols){\\n        return row >= 0 && row < rows && col >= 0 && col < cols;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        dfs(grid,r0,c0,grid[r0][c0],color,grid.length,grid[0].length,visited);        \\n        return grid;\\n    }\\n    \\n    private void dfs(int[][] grid,int row,int col,int color,int new_color,int rows,int cols,boolean[][] visited){\\n       if(!isValid(row,col,rows,cols) || visited[row][col] || grid[row][col] != color){\\n            return;\\n       }\\n     \\n        visited[row][col] = true;\\n        \\n        if(row == 0 || col == 0 || row == rows-1 || col == cols-1 || differentComponentNeighbours(grid,row,col,rows,cols,visited,color)){\\n            grid[row][col] = new_color;\\n        }\\n        \\n        dfs(grid,row-1,col,color,new_color,rows,cols,visited);\\n        dfs(grid,row+1,col,color,new_color,rows,cols,visited);\\n        dfs(grid,row,col-1,color,new_color,rows,cols,visited);\\n        dfs(grid,row,col+1,color,new_color,rows,cols,visited);\\n    }\\n    \\n    private boolean differentComponentNeighbours(int[][] grid,int row,int col,int rows,int cols,boolean[][] visited,int color){\\n        if(isValid(row-1,col,rows,cols) && !visited[row-1][col] && grid[row-1][col] != color) return true;\\n        if(isValid(row+1,col,rows,cols) && !visited[row+1][col] && grid[row+1][col] != color) return true;\\n        if(isValid(row,col-1,rows,cols) && !visited[row][col-1] && grid[row][col-1] != color) return true;\\n        if(isValid(row,col+1,rows,cols) && !visited[row][col+1] && grid[row][col+1] != color) return true;\\n        return false;\\n    }\\n    \\n    private boolean isValid(int row,int col,int rows,int cols){\\n        return row >= 0 && row < rows && col >= 0 && col < cols;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783380,
                "title": "expalanation-of-the-problem-statement",
                "content": "consider the 2nd example: ```grid = [[1,2,2],[2,3,2]], r0 = 0, c0 = 1, color = 3```\\nthe grid would look like this:\\n![image](https://assets.leetcode.com/users/images/b81e1f42-f919-4a54-9507-9ff6077c2e25_1597042429.4147203.png)\\nNow, the given location is ``` r0 = 0, c0 = 1``` which is the 2nd cell in first row. So, the component would be:\\n![image](https://assets.leetcode.com/users/images/4a571c93-2af4-4f7f-8768-363158557ab9_1597042643.770675.png)\\nNow, coming to the color changing part\\n**change the color of the cell at ```(0, 1)```** because  by the definition of the border\\n```The border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component```\\n1.  it is part of the component\\n2.  it is 4-directionally adjacent to a square not in the component (below it there a cell with color 3, and on the left there is cell with color 1, so, it meets the criteria)\\n![image](https://assets.leetcode.com/users/images/796bde1c-f034-40f1-a463-8b3421543db5_1597045011.3280766.png)\\n\\n\\nNow, **change the color of the cell at ```(0, 2)```**.\\nIt is not 4-directionally adjacent to a square not in the component (it does not have neighbour whose color is different from itself) **but it is on the border of the grid** (i.e., the first or last row or column of the grid). So, we have to change its color.\\n![image](https://assets.leetcode.com/users/images/f3449341-bf34-4ef5-b30d-d54e0d838a39_1597045067.3039854.png)\\n\\nNow, coming to last cell of our component ```(1,2)```, it follows both the criteria\\n1. it is on the border\\n2. it has a neighbour which does not belong to the component and different from itself.\\nSo, we have to change its color.\\n![image](https://assets.leetcode.com/users/images/6ec7d7f8-3fd3-49bf-819e-9ee13a64c31d_1597045304.0051892.png)\\n\\nTherefore, the output is: ```[[1, 3, 3], [2, 3, 3]]```\\n**Why didnt we change the color of cell at ```(1,0)```?**\\nit follows both the criteria, but **it doesnt belong to the component**\\nThis is my understanding of the problem. I stuggled quite a bit to understand the problem statement and I just want to make it simple to understand for others too.\\ncorrect me if I did mistake.",
                "solutionTags": [],
                "code": "```grid = [[1,2,2],[2,3,2]], r0 = 0, c0 = 1, color = 3```\n``` r0 = 0, c0 = 1```\n```(0, 1)```\n```The border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component```\n```(0, 2)```\n```(1,2)```\n```[[1, 3, 3], [2, 3, 3]]```\n```(1,0)```",
                "codeTag": "Unknown"
            },
            {
                "id": 282876,
                "title": "concise-dfs-c",
                "content": "\\tclass Solution {\\n\\t\\tvoid dfs(vector<vector<int>>& grid, int r, int c, int color) {\\n\\t\\t\\tif(r < 0 || r >= grid.size() || c < 0 || c >= grid[0].size() || grid[r][c] != color)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tgrid[r][c] = INT_MAX;\\n\\n\\t\\t\\tdfs(grid, r + 1, c, color);\\n\\t\\t\\tdfs(grid, r - 1, c, color);\\n\\t\\t\\tdfs(grid, r, c + 1, color);\\n\\t\\t\\tdfs(grid, r, c - 1, color);\\n\\t\\t}\\n\\tpublic:\\n\\t\\tvector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n\\t\\t\\tint rows, cols;\\n\\n\\t\\t\\tif((rows = grid.size()) == 0 || (cols = grid[0].size()) == 0)\\n\\t\\t\\t\\treturn {};\\n\\n\\t\\t\\tvector<vector<int>> temp = grid;\\n\\t\\t\\tdfs(temp, r0, c0, grid[r0][c0]);\\n\\n\\t\\t\\tfor(int i = 0; i < rows; i++) {\\n\\t\\t\\t\\tfor(int j = 0; j < cols; j++) {\\n\\t\\t\\t\\t\\tif(i == 0 || j == 0 || i == rows - 1 || j == cols - 1) {\\n\\t\\t\\t\\t\\t\\tif(temp[i][j] == INT_MAX)\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = color;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tif((temp[i][j]) == INT_MAX and \\n\\t\\t\\t\\t\\t\\t   ((temp[i - 1][j] != INT_MAX) || (temp[i + 1][j] != INT_MAX) ||\\n\\t\\t\\t\\t\\t\\t\\t(temp[i][j - 1] != INT_MAX) || (temp[i][j + 1] != INT_MAX)))\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = color;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn grid;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tvoid dfs(vector<vector<int>>& grid, int r, int c, int color) {\\n\\t\\t\\tif(r < 0 || r >= grid.size() || c < 0 || c >= grid[0].size() || grid[r][c] != color)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tgrid[r][c] = INT_MAX;\\n\\n\\t\\t\\tdfs(grid, r + 1, c, color);\\n\\t\\t\\tdfs(grid, r - 1, c, color);\\n\\t\\t\\tdfs(grid, r, c + 1, color);\\n\\t\\t\\tdfs(grid, r, c - 1, color);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1372161,
                "title": "beginner-friendly-c-dfs-16ms-78-22",
                "content": "* Easy to understand? must upvote! \\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    bool isVisited[51][51];\\n    vector<vector<int>> result;\\n    int ROW, COL, COLOR;\\n    \\n    bool isValid(vector<vector<int>>& grid, int i, int j){\\n        if((i>=0 and i<ROW) and (j>=0 and j<COL) and (grid[i][j] == COLOR) and (!isVisited[i][j]))\\n            return true;\\n        return false;\\n    }\\n    \\n    bool isBorder(vector<vector<int>>& grid, int i, int j){\\n        if(i == 0 || i == ROW-1 || j == 0 || j == COL-1)\\n            return true;\\n        if(grid[i][j+1] != COLOR || grid[i][j-1] != COLOR || grid[i+1][j] != COLOR || grid[i-1][j] != COLOR)\\n            return true;\\n        return false;\\n    }\\n    \\n    void DFS(vector<vector<int>>& grid, int i, int j, int color){\\n        isVisited[i][j] = true;\\n        if(isBorder(grid, i, j))\\n            result[i][j] = color;\\n        if(isValid(grid, i, j+1)){\\n            DFS(grid, i, j+1, color);\\n        }\\n        if(isValid(grid, i, j-1)){\\n            DFS(grid, i, j-1, color);\\n        }\\n        if(isValid(grid, i+1, j)){\\n            DFS(grid, i+1, j, color);\\n        }\\n        if(isValid(grid, i-1, j)){\\n            DFS(grid, i-1, j, color);\\n        }\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        memset(isVisited, false, sizeof isVisited);\\n        ROW = grid.size(); COL = grid[0].size(); COLOR = grid[r0][c0];\\n        result.resize(ROW, vector<int>(COL));\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++)\\n                result[i][j] = grid[i][j];\\n        }\\n        DFS(grid, r0, c0, color);\\n        return result;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVisited[51][51];\\n    vector<vector<int>> result;\\n    int ROW, COL, COLOR;\\n    \\n    bool isValid(vector<vector<int>>& grid, int i, int j){\\n        if((i>=0 and i<ROW) and (j>=0 and j<COL) and (grid[i][j] == COLOR) and (!isVisited[i][j]))\\n            return true;\\n        return false;\\n    }\\n    \\n    bool isBorder(vector<vector<int>>& grid, int i, int j){\\n        if(i == 0 || i == ROW-1 || j == 0 || j == COL-1)\\n            return true;\\n        if(grid[i][j+1] != COLOR || grid[i][j-1] != COLOR || grid[i+1][j] != COLOR || grid[i-1][j] != COLOR)\\n            return true;\\n        return false;\\n    }\\n    \\n    void DFS(vector<vector<int>>& grid, int i, int j, int color){\\n        isVisited[i][j] = true;\\n        if(isBorder(grid, i, j))\\n            result[i][j] = color;\\n        if(isValid(grid, i, j+1)){\\n            DFS(grid, i, j+1, color);\\n        }\\n        if(isValid(grid, i, j-1)){\\n            DFS(grid, i, j-1, color);\\n        }\\n        if(isValid(grid, i+1, j)){\\n            DFS(grid, i+1, j, color);\\n        }\\n        if(isValid(grid, i-1, j)){\\n            DFS(grid, i-1, j, color);\\n        }\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        memset(isVisited, false, sizeof isVisited);\\n        ROW = grid.size(); COL = grid[0].size(); COLOR = grid[r0][c0];\\n        result.resize(ROW, vector<int>(COL));\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++)\\n                result[i][j] = grid[i][j];\\n        }\\n        DFS(grid, r0, c0, color);\\n        return result;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282884,
                "title": "java-dfs-simple-easy-to-understand-solution-used-more-space-to-make-it-simple",
                "content": "First copying the input grid (`grid`) to output grid(`result`). After this do DFS on `grid` from start point, after visiting all neighbours, mark current point with given color(on `result` grid, input `grid` is not modified at all) if and only if it is in border of the grid OR border of the component (`isBorder`)\\n\\n```\\nprivate int[][] grid;\\n\\n    private int[][] result;\\n\\n    private int R;\\n\\n    private int C;\\n\\n    private boolean[][] visited;\\n\\n    private int finalColor;\\n\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        this.grid = grid;\\n        this.R = grid.length;\\n        this.C = grid[0].length;\\n\\n        visited = new boolean[R][C];\\n        finalColor = color;\\n\\n        result = new int[R][C];\\n        for (int r=0; r<R;r++) {\\n            for (int c=0;c<C;c++) {\\n                result[r][c] = grid[r][c];\\n            }\\n        }\\n        dfs(r0,c0, grid[r0][c0]);\\n        return result;\\n    }\\n\\n    private void dfs(int r, int c, int targetColor) {\\n        if (r >= R || r < 0 || c >= C || c < 0)\\n            return;\\n        if (grid[r][c] != targetColor)\\n            return;\\n        if (visited[r][c])\\n            return;\\n\\n        visited[r][c] = true;\\n        dfs(r, c-1, targetColor);\\n        dfs(r, c+1, targetColor);\\n        dfs(r-1, c, targetColor);\\n        dfs(r+1, c, targetColor);\\n\\n        if (isBorder(r,c, targetColor))\\n            result[r][c] = finalColor;\\n    }\\n\\n    private boolean isBorder(int r, int c, int targetColor) {\\n        if (r == R - 1 || c == C - 1 || r == 0 || c == 0)\\n            return true;\\n        int left = grid[r][c-1];\\n        int right = grid[r][c+1];\\n        int top = grid[r-1][c];\\n        int bottom = grid[r+1][c];\\n\\n        if (left != targetColor || right != targetColor || top != targetColor || bottom != targetColor)\\n            return true;\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nprivate int[][] grid;\\n\\n    private int[][] result;\\n\\n    private int R;\\n\\n    private int C;\\n\\n    private boolean[][] visited;\\n\\n    private int finalColor;\\n\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        this.grid = grid;\\n        this.R = grid.length;\\n        this.C = grid[0].length;\\n\\n        visited = new boolean[R][C];\\n        finalColor = color;\\n\\n        result = new int[R][C];\\n        for (int r=0; r<R;r++) {\\n            for (int c=0;c<C;c++) {\\n                result[r][c] = grid[r][c];\\n            }\\n        }\\n        dfs(r0,c0, grid[r0][c0]);\\n        return result;\\n    }\\n\\n    private void dfs(int r, int c, int targetColor) {\\n        if (r >= R || r < 0 || c >= C || c < 0)\\n            return;\\n        if (grid[r][c] != targetColor)\\n            return;\\n        if (visited[r][c])\\n            return;\\n\\n        visited[r][c] = true;\\n        dfs(r, c-1, targetColor);\\n        dfs(r, c+1, targetColor);\\n        dfs(r-1, c, targetColor);\\n        dfs(r+1, c, targetColor);\\n\\n        if (isBorder(r,c, targetColor))\\n            result[r][c] = finalColor;\\n    }\\n\\n    private boolean isBorder(int r, int c, int targetColor) {\\n        if (r == R - 1 || c == C - 1 || r == 0 || c == 0)\\n            return true;\\n        int left = grid[r][c-1];\\n        int right = grid[r][c+1];\\n        int top = grid[r-1][c];\\n        int bottom = grid[r+1][c];\\n\\n        if (left != targetColor || right != targetColor || top != targetColor || bottom != targetColor)\\n            return true;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 406166,
                "title": "java-neat-easy-dfs-solution",
                "content": "Just save the border in an additional list and then update the grid. Very simple idea.\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        List<int[]> border = new ArrayList<int[]>();\\n        dfs(grid, r0, c0, grid[r0][c0], border, new boolean[grid.length][grid[0].length]);\\n        \\n        for (int[] coord : border) {\\n            int i = coord[0], j = coord[1];\\n            grid[i][j] = color;\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    private void dfs(int[][] grid, int i, int j, int targetColor, List<int[]> border, boolean[][] visited) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || visited[i][j] || grid[i][j] != targetColor) return;\\n        \\n        visited[i][j] = true;\\n        if (isBorder(grid, i, j, targetColor)) { border.add(new int[]{i, j}); }\\n        \\n        dfs(grid, i+1, j, targetColor, border, visited);\\n        dfs(grid, i-1, j, targetColor, border, visited);\\n        dfs(grid, i, j+1, targetColor, border, visited);\\n        dfs(grid, i, j-1, targetColor, border, visited);\\n    }\\n    \\n    private boolean isBorder(int[][] grid, int i, int j, int targetColor) {\\n        if (i == 0 || j == 0 || i == grid.length - 1 || j == grid[0].length - 1) return true;\\n        return grid[i-1][j] != targetColor || grid[i+1][j] != targetColor || grid[i][j-1] != targetColor || grid[i][j+1] != targetColor;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        List<int[]> border = new ArrayList<int[]>();\\n        dfs(grid, r0, c0, grid[r0][c0], border, new boolean[grid.length][grid[0].length]);\\n        \\n        for (int[] coord : border) {\\n            int i = coord[0], j = coord[1];\\n            grid[i][j] = color;\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    private void dfs(int[][] grid, int i, int j, int targetColor, List<int[]> border, boolean[][] visited) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || visited[i][j] || grid[i][j] != targetColor) return;\\n        \\n        visited[i][j] = true;\\n        if (isBorder(grid, i, j, targetColor)) { border.add(new int[]{i, j}); }\\n        \\n        dfs(grid, i+1, j, targetColor, border, visited);\\n        dfs(grid, i-1, j, targetColor, border, visited);\\n        dfs(grid, i, j+1, targetColor, border, visited);\\n        dfs(grid, i, j-1, targetColor, border, visited);\\n    }\\n    \\n    private boolean isBorder(int[][] grid, int i, int j, int targetColor) {\\n        if (i == 0 || j == 0 || i == grid.length - 1 || j == grid[0].length - 1) return true;\\n        return grid[i-1][j] != targetColor || grid[i+1][j] != targetColor || grid[i][j-1] != targetColor || grid[i][j+1] != targetColor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274806,
                "title": "java-0ms-dfs-faster-than-100",
                "content": "class Solution {\\n    \\n    \\n    boolean visited[][];\\n    int col;\\n    int colorr;\\n    \\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        //basically we will to the given node and appy dfs\\n        //while applying dfs we will count the number of calls \\n        //jis bhi node se 4 calls lagi hongi usse change nhi krna hai\\n        //baki sab ko color se paint krdo\\n        col=grid[r0][c0];\\n        colorr=color;\\n        visited=new boolean[grid.length][grid[0].length];\\n        dfs(r0,c0,grid);\\n        return grid;\\n    }\\n    \\n    \\n    public void dfs(int i,int j,int[][]grid){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length){\\n            return;\\n        }\\n        int count=0;\\n        visited[i][j]=true;\\n        grid[i][j]=colorr;\\n        \\n        if(i+1<grid.length && (grid[i+1][j]==col || visited[i+1][j])){\\n            count++;\\n            if(!visited[i+1][j])\\n            dfs(i+1,j,grid);\\n        }\\n        if(i-1>=0 && (grid[i-1][j]==col || visited[i-1][j])){\\n            count++;\\n            if(!visited[i-1][j])\\n            dfs(i-1,j,grid);\\n        }\\n        if(j+1<grid[0].length && (grid[i][j+1]==col || visited[i][j+1])){\\n            count++;\\n            if(!visited[i][j+1])\\n            dfs(i,j+1,grid);\\n        }\\n        if(j-1>=0 && (grid[i][j-1]==col || visited[i][j-1])){\\n            count++;\\n            if(!visited[i][j-1])\\n            dfs(i,j-1,grid);\\n        }\\n        if(count==4){\\n            grid[i][j]=col;\\n        }\\n\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n    \\n    \\n    boolean visited[][];\\n    int col;\\n    int colorr;\\n    \\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        //basically we will to the given node and appy dfs\\n        //while applying dfs we will count the number of calls \\n        //jis bhi node se 4 calls lagi hongi usse change nhi krna hai\\n        //baki sab ko color se paint krdo\\n        col=grid[r0][c0];\\n        colorr=color;\\n        visited=new boolean[grid.length][grid[0].length];\\n        dfs(r0,c0,grid);\\n        return grid;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 700750,
                "title": "easy-understandable-using-flip-coloring-beats-100-in-both-space-and-time",
                "content": "Approach : Flip the colors by making it negative check if the given square satisfy the condition of boundary element or not, All the flipped squares will give connected components\\n```\\nclass Solution {\\n    int color_;\\n    public boolean isValid(int i,int j,int row,int col){\\n        return i>=0 && i<row && j>=0 && j<col;\\n    }\\n    public boolean nonBoundary(int [][]grid,int i,int j,int color){\\n        return color == Math.abs(grid[i-1][j]) && color == Math.abs(grid[i][j-1]) && color == Math.abs(grid[i+1][j]) && color == Math.abs(grid[i][j+1]);\\n    }\\n    public void dfs(int [][]grid,int startcolor,int i,int j){\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(!isValid(i,j,m,n) || grid[i][j]!=startcolor) return;\\n        grid[i][j] = -startcolor;\\n        dfs(grid,startcolor,i+1,j);\\n        dfs(grid,startcolor,i,j+1);\\n        dfs(grid,startcolor,i,j-1);\\n        dfs(grid,startcolor,i-1,j);\\n        if(i>0 && i<m-1 && j>0 && j<n-1){\\n            if(nonBoundary(grid,i,j,startcolor)){\\n                grid[i][j] = startcolor;\\n            }\\n        }\\n        \\n    }\\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int startcolor = grid[r0][c0];\\n        color_ = color;\\n        dfs(grid,startcolor,r0,c0);\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]<0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int color_;\\n    public boolean isValid(int i,int j,int row,int col){\\n        return i>=0 && i<row && j>=0 && j<col;\\n    }\\n    public boolean nonBoundary(int [][]grid,int i,int j,int color){\\n        return color == Math.abs(grid[i-1][j]) && color == Math.abs(grid[i][j-1]) && color == Math.abs(grid[i+1][j]) && color == Math.abs(grid[i][j+1]);\\n    }\\n    public void dfs(int [][]grid,int startcolor,int i,int j){\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(!isValid(i,j,m,n) || grid[i][j]!=startcolor) return;\\n        grid[i][j] = -startcolor;\\n        dfs(grid,startcolor,i+1,j);\\n        dfs(grid,startcolor,i,j+1);\\n        dfs(grid,startcolor,i,j-1);\\n        dfs(grid,startcolor,i-1,j);\\n        if(i>0 && i<m-1 && j>0 && j<n-1){\\n            if(nonBoundary(grid,i,j,startcolor)){\\n                grid[i][j] = startcolor;\\n            }\\n        }\\n        \\n    }\\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int startcolor = grid[r0][c0];\\n        color_ = color;\\n        dfs(grid,startcolor,r0,c0);\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]<0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478469,
                "title": "is-this-test-case-correct",
                "content": "When I submitted my code, it said that the following case did not work. How is the expected solution correct according to the problem description?\\n\\n```\\nInput:\\n[[1,2,1,2,1,2],[2,2,2,2,1,2],[1,2,2,2,1,2]]\\n1\\n3\\n1\\nOutput:\\n[[1,1,1,1,1,2],[1,1,1,1,1,2],[1,1,1,1,1,2]]\\nExpected:\\n[[1,1,1,1,1,2],[1,2,1,1,1,2],[1,1,1,1,1,2]]\\n```\\n```\\n                  ^\\n```\\n\\nThat \"2\" is my problem.",
                "solutionTags": [],
                "code": "```\\nInput:\\n[[1,2,1,2,1,2],[2,2,2,2,1,2],[1,2,2,2,1,2]]\\n1\\n3\\n1\\nOutput:\\n[[1,1,1,1,1,2],[1,1,1,1,1,2],[1,1,1,1,1,2]]\\nExpected:\\n[[1,1,1,1,1,2],[1,2,1,1,1,2],[1,1,1,1,1,2]]\\n```\n```\\n                  ^\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282844,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool dfs(vector<vector<int>> &grid, vector<vector<bool>> &colored, int r0, int c0, int color, int connected_col, vector<vector<bool>> &visit) {\\n        if(r0 < 0 or r0 >= grid.size() or c0 < 0 or c0 >= grid[0].size() or grid[r0][c0] != connected_col)\\n            return true;\\n        \\n        if(visit[r0][c0])\\n            return false;\\n        \\n        visit[r0][c0] = true;\\n        if(dfs(grid, colored, r0-1, c0, color, connected_col, visit))\\n            colored[r0][c0] = true;\\n        \\n        if(dfs(grid, colored, r0+1, c0, color, connected_col, visit))\\n            colored[r0][c0] = true;\\n        \\n        if(dfs(grid, colored, r0, c0-1, color, connected_col, visit))\\n            colored[r0][c0] = true;\\n        \\n        if(dfs(grid, colored, r0, c0+1, color, connected_col, visit))\\n            colored[r0][c0] = true;\\n        return false;\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        if(grid.size() == 0)\\n            return {};\\n        \\n        vector<vector<bool>> colored(grid.size(), vector<bool>(grid[0].size(), false));\\n        vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size(), false));\\n        \\n        dfs(grid, colored, r0, c0, color, grid[r0][c0], visited);\\n        \\n        for(int i = 0; i < colored.size(); i++) {\\n            for(int j = 0; j < colored[0].size(); j++)\\n                if(colored[i][j])\\n                    grid[i][j] = color;\\n        }\\n        \\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool dfs(vector<vector<int>> &grid, vector<vector<bool>> &colored, int r0, int c0, int color, int connected_col, vector<vector<bool>> &visit) {\\n        if(r0 < 0 or r0 >= grid.size() or c0 < 0 or c0 >= grid[0].size() or grid[r0][c0] != connected_col)\\n            return true;\\n        \\n        if(visit[r0][c0])\\n            return false;\\n        \\n        visit[r0][c0] = true;\\n        if(dfs(grid, colored, r0-1, c0, color, connected_col, visit))\\n            colored[r0][c0] = true;\\n        \\n        if(dfs(grid, colored, r0+1, c0, color, connected_col, visit))\\n            colored[r0][c0] = true;\\n        \\n        if(dfs(grid, colored, r0, c0-1, color, connected_col, visit))\\n            colored[r0][c0] = true;\\n        \\n        if(dfs(grid, colored, r0, c0+1, color, connected_col, visit))\\n            colored[r0][c0] = true;\\n        return false;\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        if(grid.size() == 0)\\n            return {};\\n        \\n        vector<vector<bool>> colored(grid.size(), vector<bool>(grid[0].size(), false));\\n        vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size(), false));\\n        \\n        dfs(grid, colored, r0, c0, color, grid[r0][c0], visited);\\n        \\n        for(int i = 0; i < colored.size(); i++) {\\n            for(int j = 0; j < colored[0].size(); j++)\\n                if(colored[i][j])\\n                    grid[i][j] = color;\\n        }\\n        \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686098,
                "title": "detailed-explanation-with-pictures",
                "content": "` Suppose given `\\n![paint1.png](https://assets.leetcode.com/users/images/81a9c04e-3300-4a5b-aec8-23d2d6fd965d_1687797247.1981645.png)\\n\\n``` \\nAll the neighbour(4 directions) of grid[1][3] including neighbours of the neighbours of \\ngrid[1][3]\\n```\\n![paint1.png](https://assets.leetcode.com/users/images/d6939f0f-dce2-4b2b-b292-e4f49b5e8ef0_1687797844.4885716.png)\\n\\n```\\nNow you have to go through the all of those grid[1][3]\\'s neighbours and change the color of \\nthose cells which are on the border(cell whose 4 direction cells values are not equal to\\n that cell value)\\n```\\n```\\nLet\\'s look at the cell grid[1][2].\\n```\\n![mainnnnnn.png](https://assets.leetcode.com/users/images/06cc3008-5f1c-4c29-bfc1-e346b3f523fc_1687799040.5686803.png)\\n\\n```\\nHere only the upper neighbour(green marked) is not same as grid[1][2] (purple marked).\\nSo grid[1][2] is on the border and thus we color it to 1.\\n```\\n```\\nFor grid[1][1] : \\n```\\n![main2.png](https://assets.leetcode.com/users/images/d6da1151-583a-4811-968a-a1bd0bbf4aa5_1687799443.3790708.png)\\n\\n```\\nFor grid[1][1](purple marked) all it\\'s neighbour has the same value as grid[1][1] has, means\\nthis cell is not on the border and that\\'s why we won\\'t color it to 1.\\n```\\n```\\nFinal Output : (red = previous color, blue = new color)\\n```\\n![soll.png](https://assets.leetcode.com/users/images/f6b3551f-c996-4945-bbb8-348d2fe8ed1d_1687800180.4796717.png)\\n\\n\\n### My Solution Explanation :\\n```\\nIf you want to run the dfs and change the border cell to new color in the dfs it would\\nbe huge messy : \\n```\\n![leo.png](https://assets.leetcode.com/users/images/880985b8-14b1-4027-bb6a-04631a3d1743_1687804434.6937025.png)\\n\\n```\\nIf I change the color of grid[1][3] and grid[1][2] at the same time in dfs function, then \\nfor grid[1][1] (purple marked) it\\'s right neighbour(grid[1][2]) is 1 and grid[1][1] will be \\ncolored to 1 as it\\'s all neighbours value are not same as grid[1][1] BUT grid[1][1] can\\'t be\\ncolored to 1 as in the Q it\\'s all neighbour has the same value as its.\\n```\\n```\\nInstead I made a boolean array of the same size as grid and marked all the neighbours of \\ngrid[row][col] as 1 in dfs(). Now I can easily traverse the \\'visited\\' array and change the \\nborder cells of \\'grid\\' to \\'color\\'.\\n```\\n![OPP.png](https://assets.leetcode.com/users/images/c52babc0-2983-4496-860b-21f4ac018440_1687806180.8875253.png)\\n\\n```\\nTo check if the current cell (grid[r][c]) is on the border or not :\\n\\n1. If the cell is on the first or the last row as \\'CELLS ON THE FIRST ROW MISSING UPPER \\n   NEIGHBOUR\\' AND \\'LAST ROW BOTTOM NEIGHBOUR\\'.\\n2. If the cell is on the first colomn(missing left neighbour) or the last colomn(missing right \\n   neighbour)\\n3. If the cell in the middle, then check if all the neighbour has 1 in the \\'visited\\' array, \\n   because if one of them is 0 means it\\'s a border cell. \\n\\n   NO NEED TO CHECK IF THE CELL (WHOSE NEIGHBOURS HAS 1 OR NOT) HAS ALSO 1 BECAUSE UNLESS THAT \\n   CELL HAD NOT 1 WE WOULDN\\'T BE CHECKING IF ALL ITS NEIGHBOURS AS 1 OR NOT.    \\n```\\n\\n```CPP []\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> diff = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}}; // left up right down\\n    \\n    bool on_border_or_neighbours_not_equal(vector<vector<bool>>& visited, int r, int c){\\n        if(r == 0 || r == visited.size()-1 || c == 0 || c == visited[0].size()-1) // on border conditions\\n            return true;\\n        int left = visited[r][c-1], up = visited[r-1][c], right = visited[r][c+1], down = visited[r+1][c];\\n        return left != 1 || up != 1 || right != 1 || down != 1; // at least one neighbour is different conditions\\n    }\\n    \\n    void create_border(vector<vector<int>>& grid, vector<vector<bool>> &visited, int newcolor)\\n    {\\n        for(int r=0; r<visited.size(); r++)\\n        {\\n            for(int c=0; c<visited[0].size(); c++)\\n                if(visited[r][c] == 1 && on_border_or_neighbours_not_equal(visited, r, c))\\n                    grid[r][c] = newcolor;\\n        }\\n    }\\n\\n    void dfs(vector<vector<int>>& grid, int r, int c, int oldcolor, vector<vector<bool>> &visited)\\n    {\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size() || visited[r][c] == 1 || grid[r][c] != oldcolor)\\n            return;\\n        visited[r][c] = 1;\\n        for(const auto &d : diff)\\n            dfs(grid, r+d[0], c+d[1], oldcolor, visited);\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color)\\n    {\\n        vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size()));\\n        dfs(grid, row, col, grid[row][col], visited);\\n        create_border(grid, visited, color);\\n        return grid;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        ROW, COL, oldcolor = len(grid), len(grid[0]), grid[row][col]\\n        visited = [ [0 for _ in range(COL)] for _ in range(ROW) ]\\n\\n        def dfs(r:int, c:int):\\n            if r<0 or r>=ROW or c<0 or c>=COL or visited[r][c] == 1 or grid[r][c] != oldcolor :\\n                return\\n            visited[r][c] = 1\\n            [ dfs(r+x, c+y) for (x,y) in ((0, -1), (-1, 0), (0, 1), (1, 0)) ]\\n        \\n        def on_border_or_neighbours_not_equal(r:int, c:int) -> bool:\\n            if r == 0 or r == ROW-1 or c == 0 or c == COL-1 : # on border\\n                return True\\n            left, up, right, down = visited[r][c-1], visited[r-1][c], visited[r][c+1], visited[r+1][c]\\n            return left != 1 or up != 1 or right != 1 or down != 1 # min 1 neighbour is different or not\\n        \\n        def create_border():\\n            for r in range(ROW):\\n                for c in range(COL):\\n                    if visited[r][c] == 1 and on_border_or_neighbours_not_equal(r, c):\\n                        grid[r][c] = color\\n\\n        dfs(row, col)\\n        create_border()\\n        return grid\\n```\\n```\\nTime  complexity : O(m*n)\\nSpace complexity : O(m*n)\\n```\\n### It took me plenty time to explain everything. If the post was useful to you, an upvote will really make me happy. Thank you for reading it till the end.",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "``` \\nAll the neighbour(4 directions) of grid[1][3] including neighbours of the neighbours of \\ngrid[1][3]\\n```\n```\\nNow you have to go through the all of those grid[1][3]\\'s neighbours and change the color of \\nthose cells which are on the border(cell whose 4 direction cells values are not equal to\\n that cell value)\\n```\n```\\nLet\\'s look at the cell grid[1][2].\\n```\n```\\nHere only the upper neighbour(green marked) is not same as grid[1][2] (purple marked).\\nSo grid[1][2] is on the border and thus we color it to 1.\\n```\n```\\nFor grid[1][1] : \\n```\n```\\nFor grid[1][1](purple marked) all it\\'s neighbour has the same value as grid[1][1] has, means\\nthis cell is not on the border and that\\'s why we won\\'t color it to 1.\\n```\n```\\nFinal Output : (red = previous color, blue = new color)\\n```\n```\\nIf you want to run the dfs and change the border cell to new color in the dfs it would\\nbe huge messy : \\n```\n```\\nIf I change the color of grid[1][3] and grid[1][2] at the same time in dfs function, then \\nfor grid[1][1] (purple marked) it\\'s right neighbour(grid[1][2]) is 1 and grid[1][1] will be \\ncolored to 1 as it\\'s all neighbours value are not same as grid[1][1] BUT grid[1][1] can\\'t be\\ncolored to 1 as in the Q it\\'s all neighbour has the same value as its.\\n```\n```\\nInstead I made a boolean array of the same size as grid and marked all the neighbours of \\ngrid[row][col] as 1 in dfs(). Now I can easily traverse the \\'visited\\' array and change the \\nborder cells of \\'grid\\' to \\'color\\'.\\n```\n```\\nTo check if the current cell (grid[r][c]) is on the border or not :\\n\\n1. If the cell is on the first or the last row as \\'CELLS ON THE FIRST ROW MISSING UPPER \\n   NEIGHBOUR\\' AND \\'LAST ROW BOTTOM NEIGHBOUR\\'.\\n2. If the cell is on the first colomn(missing left neighbour) or the last colomn(missing right \\n   neighbour)\\n3. If the cell in the middle, then check if all the neighbour has 1 in the \\'visited\\' array, \\n   because if one of them is 0 means it\\'s a border cell. \\n\\n   NO NEED TO CHECK IF THE CELL (WHOSE NEIGHBOURS HAS 1 OR NOT) HAS ALSO 1 BECAUSE UNLESS THAT \\n   CELL HAD NOT 1 WE WOULDN\\'T BE CHECKING IF ALL ITS NEIGHBOURS AS 1 OR NOT.    \\n```\n```CPP []\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> diff = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}}; // left up right down\\n    \\n    bool on_border_or_neighbours_not_equal(vector<vector<bool>>& visited, int r, int c){\\n        if(r == 0 || r == visited.size()-1 || c == 0 || c == visited[0].size()-1) // on border conditions\\n            return true;\\n        int left = visited[r][c-1], up = visited[r-1][c], right = visited[r][c+1], down = visited[r+1][c];\\n        return left != 1 || up != 1 || right != 1 || down != 1; // at least one neighbour is different conditions\\n    }\\n    \\n    void create_border(vector<vector<int>>& grid, vector<vector<bool>> &visited, int newcolor)\\n    {\\n        for(int r=0; r<visited.size(); r++)\\n        {\\n            for(int c=0; c<visited[0].size(); c++)\\n                if(visited[r][c] == 1 && on_border_or_neighbours_not_equal(visited, r, c))\\n                    grid[r][c] = newcolor;\\n        }\\n    }\\n\\n    void dfs(vector<vector<int>>& grid, int r, int c, int oldcolor, vector<vector<bool>> &visited)\\n    {\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size() || visited[r][c] == 1 || grid[r][c] != oldcolor)\\n            return;\\n        visited[r][c] = 1;\\n        for(const auto &d : diff)\\n            dfs(grid, r+d[0], c+d[1], oldcolor, visited);\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color)\\n    {\\n        vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size()));\\n        dfs(grid, row, col, grid[row][col], visited);\\n        create_border(grid, visited, color);\\n        return grid;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        ROW, COL, oldcolor = len(grid), len(grid[0]), grid[row][col]\\n        visited = [ [0 for _ in range(COL)] for _ in range(ROW) ]\\n\\n        def dfs(r:int, c:int):\\n            if r<0 or r>=ROW or c<0 or c>=COL or visited[r][c] == 1 or grid[r][c] != oldcolor :\\n                return\\n            visited[r][c] = 1\\n            [ dfs(r+x, c+y) for (x,y) in ((0, -1), (-1, 0), (0, 1), (1, 0)) ]\\n        \\n        def on_border_or_neighbours_not_equal(r:int, c:int) -> bool:\\n            if r == 0 or r == ROW-1 or c == 0 or c == COL-1 : # on border\\n                return True\\n            left, up, right, down = visited[r][c-1], visited[r-1][c], visited[r][c+1], visited[r+1][c]\\n            return left != 1 or up != 1 or right != 1 or down != 1 # min 1 neighbour is different or not\\n        \\n        def create_border():\\n            for r in range(ROW):\\n                for c in range(COL):\\n                    if visited[r][c] == 1 and on_border_or_neighbours_not_equal(r, c):\\n                        grid[r][c] = color\\n\\n        dfs(row, col)\\n        create_border()\\n        return grid\\n```\n```\\nTime  complexity : O(m*n)\\nSpace complexity : O(m*n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1595163,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {0,1,0,-1};\\n    int dy[4] = {1,0,-1,0};\\n    void dfs(vector<vector<int>>& grid, int x, int y, int num){\\n        grid[x][y]= -num;\\n        int cnt=0;\\n        for(int i=0; i<4; ++i){\\n            int x1 = x+dx[i], y1=y+dy[i];\\n            if(x1<0 || x1>=grid.size() || y1<0 || y1>=grid[0].size() || abs(grid[x1][y1]) != num) continue;\\n            cnt+=1;\\n            if(grid[x1][y1] != -num)dfs(grid,x1,y1,num);\\n        }\\n        if(cnt==4) grid[x][y] = num;\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int num = grid[row][col];\\n        dfs(grid,row,col,num);\\n        for(int i=0; i<grid.size(); ++i){\\n            for(int j=0; j<grid[0].size(); ++j){\\n                if(grid[i][j] == -num) grid[i][j]=color;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {0,1,0,-1};\\n    int dy[4] = {1,0,-1,0};\\n    void dfs(vector<vector<int>>& grid, int x, int y, int num){\\n        grid[x][y]= -num;\\n        int cnt=0;\\n        for(int i=0; i<4; ++i){\\n            int x1 = x+dx[i], y1=y+dy[i];\\n            if(x1<0 || x1>=grid.size() || y1<0 || y1>=grid[0].size() || abs(grid[x1][y1]) != num) continue;\\n            cnt+=1;\\n            if(grid[x1][y1] != -num)dfs(grid,x1,y1,num);\\n        }\\n        if(cnt==4) grid[x][y] = num;\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int num = grid[row][col];\\n        dfs(grid,row,col,num);\\n        for(int i=0; i<grid.size(); ++i){\\n            for(int j=0; j<grid[0].size(); ++j){\\n                if(grid[i][j] == -num) grid[i][j]=color;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283803,
                "title": "java-dfs-based-solution-with-explanation-simple-to-understand",
                "content": "\\n# Thought process:\\n\\nRun Depth First Search algorithm to find the connected component where (r0, c0) is part of that connected component.\\nOutput of DFS run is visited[][] array where elements that are part of connected component are marked as 1. Rest of the elements are 0.\\n\\n# Only boundary logic is left:\\n\\nTraverse through visited[][] array:\\n\\nIf visited element (visited[][] == 1) is surrounded by all visited nodes (if all neighbors are visited), then keep its color as old. This is case of an internal element.\\n\\nElse give new color since it\\'s a boundary element.\\n    \\n    private boolean isSafe(int[][] grid, int x, int y, int initialColor, int[][] visited)\\n    {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n    \\n        if(x<0 || x>n-1 || y<0 || y>m-1)\\n            return false;\\n        \\n        return ((visited[x][y] == 0) && (grid[x][y] == initialColor));\\n    }\\n\\t\\n    private void DFS(int[][] grid, int r, int c, int initialColor, int color, int[][] visited)\\n    {\\n        visited[r][c] = 1;\\n        \\n        int[] row = {0, -1, 0, 1};\\n        int[] column = {-1, 0, 1, 0};\\n        \\n        int x;\\n        int y;\\n        \\n        for(int k = 0; k<4; k++)\\n        {\\n            x = r + row[k];\\n            y = c + column[k];\\n            \\n            if(isSafe(grid, x, y, initialColor, visited))\\n            {\\n                DFS(grid, x, y, initialColor, color, visited);\\n            }\\n        }\\n        \\n    }\\n    \\n    private boolean isVisitedAndSafe(int x, int y, int[][] visited)\\n    {\\n        int n = visited.length;\\n        int m = visited[0].length;\\n        \\n        if(x<0 || x>n-1 || y<0 || y>m-1)\\n            return false;\\n        \\n        return visited[x][y] == 1;\\n    }\\n    \\n    private boolean isBorder(int i, int j, int[][] visited)\\n    {\\n        int[] row = {0, -1, 0, 1};\\n        int[] column = {-1, 0, 1, 0};\\n        \\n        int count = 0;\\n        \\n        int x;\\n        int y;\\n        \\n        for(int k = 0; k<4; k++)\\n        {\\n            x = i + row[k];\\n            y = j + column[k];\\n            \\n            if(isVisitedAndSafe(x, y, visited))\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        if(count == 4)\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    private int[][] DFSUtil(int[][] grid, int r, int c, int color)\\n    {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int[][] visited = new int[n][m]; //initialized as 0\\n        int initialColor = grid[r][c];\\n        \\n        DFS(grid, r, c, initialColor, color, visited);\\n        \\n        for(int i = 0; i<n; i++)\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(visited[i][j] == 1)\\n                {\\n                    if(isBorder(i, j, visited))\\n                        grid[i][j] = color;\\n                }\\n            }\\n        \\n        return grid;\\n        \\n    }\\n\\t\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        \\n        return DFSUtil(grid, r0,c0,color);\\n    }",
                "solutionTags": [],
                "code": "\\n# Thought process:\\n\\nRun Depth First Search algorithm to find the connected component where (r0, c0) is part of that connected component.\\nOutput of DFS run is visited[][] array where elements that are part of connected component are marked as 1. Rest of the elements are 0.\\n\\n# Only boundary logic is left:\\n\\nTraverse through visited[][] array:\\n\\nIf visited element (visited[][] == 1) is surrounded by all visited nodes (if all neighbors are visited), then keep its color as old. This is case of an internal element.\\n\\nElse give new color since it\\'s a boundary element.\\n    \\n    private boolean isSafe(int[][] grid, int x, int y, int initialColor, int[][] visited)\\n    {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n    \\n        if(x<0 || x>n-1 || y<0 || y>m-1)\\n            return false;\\n        \\n        return ((visited[x][y] == 0) && (grid[x][y] == initialColor));\\n    }\\n\\t\\n    private void DFS(int[][] grid, int r, int c, int initialColor, int color, int[][] visited)\\n    {\\n        visited[r][c] = 1;\\n        \\n        int[] row = {0, -1, 0, 1};\\n        int[] column = {-1, 0, 1, 0};\\n        \\n        int x;\\n        int y;\\n        \\n        for(int k = 0; k<4; k++)\\n        {\\n            x = r + row[k];\\n            y = c + column[k];\\n            \\n            if(isSafe(grid, x, y, initialColor, visited))\\n            {\\n                DFS(grid, x, y, initialColor, color, visited);\\n            }\\n        }\\n        \\n    }\\n    \\n    private boolean isVisitedAndSafe(int x, int y, int[][] visited)\\n    {\\n        int n = visited.length;\\n        int m = visited[0].length;\\n        \\n        if(x<0 || x>n-1 || y<0 || y>m-1)\\n            return false;\\n        \\n        return visited[x][y] == 1;\\n    }\\n    \\n    private boolean isBorder(int i, int j, int[][] visited)\\n    {\\n        int[] row = {0, -1, 0, 1};\\n        int[] column = {-1, 0, 1, 0};\\n        \\n        int count = 0;\\n        \\n        int x;\\n        int y;\\n        \\n        for(int k = 0; k<4; k++)\\n        {\\n            x = i + row[k];\\n            y = j + column[k];\\n            \\n            if(isVisitedAndSafe(x, y, visited))\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        if(count == 4)\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    private int[][] DFSUtil(int[][] grid, int r, int c, int color)\\n    {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int[][] visited = new int[n][m]; //initialized as 0\\n        int initialColor = grid[r][c];\\n        \\n        DFS(grid, r, c, initialColor, color, visited);\\n        \\n        for(int i = 0; i<n; i++)\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(visited[i][j] == 1)\\n                {\\n                    if(isBorder(i, j, visited))\\n                        grid[i][j] = color;\\n                }\\n            }\\n        \\n        return grid;\\n        \\n    }\\n\\t\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        \\n        return DFSUtil(grid, r0,c0,color);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 282960,
                "title": "easy-java-iterative-solution-using-stack",
                "content": "```class Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Stack<int[]> stack = new Stack<>();\\n        stack.push(new int[]{r0, c0});\\n        int origin = grid[r0][c0];\\n        boolean[][] visited = new boolean[m][n];\\n        while (!stack.isEmpty()) {\\n            int[] t = stack.pop();\\n            int r = t[0];\\n            int c = t[1];\\n            if (!visited[r][c]) {\\n                if (r == 0 || r == m-1 || c == 0 || c == n-1 || (grid[r-1][c] != origin && grid[r-1][c] != -1) || \\n                   (grid[r+1][c] != origin && grid[r+1][c] != -1) || (grid[r][c-1] != origin && grid[r][c-1] != -1) || \\n                    (grid[r][c+1] != origin && grid[r][c+1] != -1)) \\n                    grid[r][c] = -1; \\n                \\n                visited[r][c] = true;\\n                if (r - 1 >= 0 && origin == grid[r-1][c]) {\\n                    stack.push(new int[]{r-1, c});\\n                }\\n                \\n                if (r + 1 < m && origin == grid[r+1][c]) {\\n                    stack.push(new int[]{r+1, c});\\n                }\\n                \\n                if (c - 1 >= 0 && origin == grid[r][c-1]) {\\n                    stack.push(new int[]{r, c-1});\\n                }\\n                \\n                if (c + 1 < n && origin == grid[r][c+1]) {\\n                    stack.push(new int[]{r, c+1});\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == -1) {\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Stack<int[]> stack = new Stack<>();\\n        stack.push(new int[]{r0, c0}",
                "codeTag": "Java"
            },
            {
                "id": 282871,
                "title": "java-dfs-for-2-times-kinda-long-but-easy-to-understand",
                "content": "First DFS to paint the connect component to -1, then the second DFS to paint the inside square to -2, and the border square to -3. Return the grid by changing -3 squre to color and -2 squre to original color\\n\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int originalColor = grid[r0][c0];\\n        dfs(r0, c0, grid, originalColor);\\n        dfs2(r0, c0, grid);\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == -3) {\\n                    grid[i][j] = color;\\n                }\\n                if (grid[i][j] == -2) {\\n                    grid[i][j] = originalColor;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    void dfs(int r, int c, int[][] grid, int color) {\\n        if (r >= grid.length || c >= grid[0].length || r<0 || c<0 || grid[r][c] != color) {\\n            return;\\n        }\\n        grid[r][c] = -1;\\n        dfs(r-1, c, grid, color);\\n        dfs(r+1, c, grid, color);\\n        dfs(r, c-1, grid, color);\\n        dfs(r, c+1, grid, color);\\n    }\\n    \\n    void dfs2(int r, int c, int[][] grid) {\\n        if (r >= grid.length || c >= grid[0].length || r<0 || c<0 || grid[r][c] != -1) {\\n            return;\\n        }\\n        grid[r][c] = -3;\\n        if (r-1<0 || r+1==grid.length || c-1<0 || c+1==grid[0].length) {\\n            // do nothing\\n        } else if ((grid[r-1][c] == -1 || grid[r-1][c] == -3 || grid[r-1][c] == -2) \\n                   && (grid[r+1][c] == -1 || grid[r+1][c] == -3 || grid[r+1][c] == -2)\\n                   && (grid[r][c-1] == -1 || grid[r][c-1] == -3 || grid[r][c-1] == -2)\\n                   && (grid[r][c+1] == -1 || grid[r][c+1] == -3 || grid[r][c+1] == -2)) {\\n            grid[r][c] = -2;\\n        }\\n        dfs2(r-1, c, grid);\\n        dfs2(r+1, c, grid);\\n        dfs2(r, c-1, grid);\\n        dfs2(r, c+1, grid);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int originalColor = grid[r0][c0];\\n        dfs(r0, c0, grid, originalColor);\\n        dfs2(r0, c0, grid);\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == -3) {\\n                    grid[i][j] = color;\\n                }\\n                if (grid[i][j] == -2) {\\n                    grid[i][j] = originalColor;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    void dfs(int r, int c, int[][] grid, int color) {\\n        if (r >= grid.length || c >= grid[0].length || r<0 || c<0 || grid[r][c] != color) {\\n            return;\\n        }\\n        grid[r][c] = -1;\\n        dfs(r-1, c, grid, color);\\n        dfs(r+1, c, grid, color);\\n        dfs(r, c-1, grid, color);\\n        dfs(r, c+1, grid, color);\\n    }\\n    \\n    void dfs2(int r, int c, int[][] grid) {\\n        if (r >= grid.length || c >= grid[0].length || r<0 || c<0 || grid[r][c] != -1) {\\n            return;\\n        }\\n        grid[r][c] = -3;\\n        if (r-1<0 || r+1==grid.length || c-1<0 || c+1==grid[0].length) {\\n            // do nothing\\n        } else if ((grid[r-1][c] == -1 || grid[r-1][c] == -3 || grid[r-1][c] == -2) \\n                   && (grid[r+1][c] == -1 || grid[r+1][c] == -3 || grid[r+1][c] == -2)\\n                   && (grid[r][c-1] == -1 || grid[r][c-1] == -3 || grid[r][c-1] == -2)\\n                   && (grid[r][c+1] == -1 || grid[r][c+1] == -3 || grid[r][c+1] == -2)) {\\n            grid[r][c] = -2;\\n        }\\n        dfs2(r-1, c, grid);\\n        dfs2(r+1, c, grid);\\n        dfs2(r, c-1, grid);\\n        dfs2(r, c+1, grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373784,
                "title": "c-bfs-beats-86-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to get the connected component and then identify the border cells of the connected component.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Run BFS two times\\n- First BFS : Get all the cells which have the same color as the [row, col] given. This will be the connected component of interest\\n- Second BFS : Identify which cells from the first BFS are on the border of the connected component. If the color of the child is different than parent, it means parent is a border cell. Similarly, if the parent itself is on the border of the grid, it is a border cell. Change the color of these border cells\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(r*c)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(r*c)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        queue<pair<int, int>> q;\\n        queue<pair<int, int>> v;\\n        vector<vector<bool>> vis(r, vector<bool>(c, false));\\n        vector<vector<int>> move{{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n        q.push(make_pair(row, col));\\n        int og = grid[row][col];\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            v.push(node);\\n            vis[node.first][node.second] = true;\\n            for(auto mv : move){\\n                int rn = mv[0] + node.first;\\n                int rc = mv[1] + node.second;\\n\\n                if(rn < 0 || rc < 0 || rn>= r || rc>= c)\\n                    continue;\\n                \\n                if(vis[rn][rc])\\n                    continue;\\n                \\n                vis[rn][rc] = true;\\n\\n                if(grid[rn][rc]== og)\\n                    q.push(make_pair(rn, rc));\\n\\n            }\\n        }\\n\\n        vis.clear();\\n        vis.resize(r, vector<bool>(c, false));\\n        while(!v.empty()){\\n            auto node = v.front();\\n            v.pop();\\n\\n            vis[node.first][node.second] = true;\\n            if(node.first == 0 || node.second == 0 || node.first == r -1 || node.second == c-1){\\n                grid[node.first][node.second] = color;\\n                continue;\\n            }\\n\\n            bool border = false;\\n            for(auto mv : move){\\n                int rn = mv[0] + node.first;\\n                int rc = mv[1] + node.second;\\n\\n                if(rn < 0 || rc < 0 || rn>= r || rc>= c)\\n                    continue;\\n                \\n                if(vis[rn][rc])\\n                    continue;\\n                \\n                if(grid[rn][rc] != og){\\n                    border = true;\\n                    break;\\n                }\\n            }\\n            if(border){\\n                grid[node.first][node.second] = color;\\n            }\\n                \\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        queue<pair<int, int>> q;\\n        queue<pair<int, int>> v;\\n        vector<vector<bool>> vis(r, vector<bool>(c, false));\\n        vector<vector<int>> move{{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n        q.push(make_pair(row, col));\\n        int og = grid[row][col];\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            v.push(node);\\n            vis[node.first][node.second] = true;\\n            for(auto mv : move){\\n                int rn = mv[0] + node.first;\\n                int rc = mv[1] + node.second;\\n\\n                if(rn < 0 || rc < 0 || rn>= r || rc>= c)\\n                    continue;\\n                \\n                if(vis[rn][rc])\\n                    continue;\\n                \\n                vis[rn][rc] = true;\\n\\n                if(grid[rn][rc]== og)\\n                    q.push(make_pair(rn, rc));\\n\\n            }\\n        }\\n\\n        vis.clear();\\n        vis.resize(r, vector<bool>(c, false));\\n        while(!v.empty()){\\n            auto node = v.front();\\n            v.pop();\\n\\n            vis[node.first][node.second] = true;\\n            if(node.first == 0 || node.second == 0 || node.first == r -1 || node.second == c-1){\\n                grid[node.first][node.second] = color;\\n                continue;\\n            }\\n\\n            bool border = false;\\n            for(auto mv : move){\\n                int rn = mv[0] + node.first;\\n                int rc = mv[1] + node.second;\\n\\n                if(rn < 0 || rc < 0 || rn>= r || rc>= c)\\n                    continue;\\n                \\n                if(vis[rn][rc])\\n                    continue;\\n                \\n                if(grid[rn][rc] != og){\\n                    border = true;\\n                    break;\\n                }\\n            }\\n            if(border){\\n                grid[node.first][node.second] = color;\\n            }\\n                \\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039802,
                "title": "bfs-beats-99-easy-to-understand",
                "content": "Question is poorly articulated so I\\'ll try to explain a bit.\\nAdjacency - Two squares are adjacent id they are in one of the four (up, down, left, right) directions of each other.\\nConnected Component - A connected component is a set of squares which are adjacent to at least one of the squares in the connected component and carry the same color\\nBoundary - A square is said to be a boundary square of a connected component if it\\'s either adjacent to a square of different color or is a boundary square of our grid i.e a square of first or last row or column.\\n\\nNow the question asks us to paint the boundary of the said connected component with a particular given color.\\n\\n**Solution-**\\nNow the solution to it is pretty easy, you traverse the whole conncted component and change the color of each square whose all 4 adjacent sides does not contain the original color.\\n\\n**Simple readable code with the said logic-**\\n\\n\\n\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        change = []\\n        \\n        queue = [[row, col]]\\n        q = 1 \\n        \\n        ori = grid[row][col]\\n        \\n        vis = [[0]*n for i in range(m)]\\n        vis[row][col] = 1 \\n        \\n        while q > 0:\\n            r, c = queue.pop(0)\\n            q -= 1\\n            \\n            sides = 0\\n            \\n            if r-1 >= 0:\\n                if grid[r-1][c] == ori:\\n                    sides += 1\\n                if not vis[r-1][c]:\\n                    vis[r-1][c] = 1 \\n                    if grid[r-1][c] == ori:\\n                        queue.append([r-1, c])\\n                        q += 1        \\n                    \\n            if c-1 >= 0:\\n                if grid[r][c-1] == ori:\\n                    sides += 1\\n                if not vis[r][c-1]:\\n                    vis[r][c-1] = 1 \\n                    if grid[r][c-1] == ori:\\n                        queue.append([r, c-1])\\n                        q += 1       \\n            \\n            if r+1 < m:\\n                if grid[r+1][c] == ori:\\n                    sides += 1\\n                if not vis[r+1][c]:\\n                    vis[r+1][c] = 1 \\n                    if grid[r+1][c] == ori:\\n                        queue.append([r+1, c])\\n                        q += 1 \\n          \\n            if c+1 < n:\\n                if grid[r][c+1] == ori:\\n                    sides += 1\\n                if not vis[r][c+1]:\\n                    vis[r][c+1] = 1 \\n                    if grid[r][c+1] == ori:\\n                        queue.append([r, c+1])\\n                        q += 1 \\n                             \\n            if sides != 4:\\n                change.append([r, c])\\n                \\n        for r, c in change:\\n            grid[r][c] = color \\n            \\n        return grid",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "Question is poorly articulated so I\\'ll try to explain a bit.\\nAdjacency - Two squares are adjacent id they are in one of the four (up, down, left, right) directions of each other.\\nConnected Component - A connected component is a set of squares which are adjacent to at least one of the squares in the connected component and carry the same color\\nBoundary - A square is said to be a boundary square of a connected component if it\\'s either adjacent to a square of different color or is a boundary square of our grid i.e a square of first or last row or column.\\n\\nNow the question asks us to paint the boundary of the said connected component with a particular given color.\\n\\n**Solution-**\\nNow the solution to it is pretty easy, you traverse the whole conncted component and change the color of each square whose all 4 adjacent sides does not contain the original color.\\n\\n**Simple readable code with the said logic-**\\n\\n\\n\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        change = []\\n        \\n        queue = [[row, col]]\\n        q = 1 \\n        \\n        ori = grid[row][col]\\n        \\n        vis = [[0]*n for i in range(m)]\\n        vis[row][col] = 1 \\n        \\n        while q > 0:\\n            r, c = queue.pop(0)\\n            q -= 1\\n            \\n            sides = 0\\n            \\n            if r-1 >= 0:\\n                if grid[r-1][c] == ori:\\n                    sides += 1\\n                if not vis[r-1][c]:\\n                    vis[r-1][c] = 1 \\n                    if grid[r-1][c] == ori:\\n                        queue.append([r-1, c])\\n                        q += 1        \\n                    \\n            if c-1 >= 0:\\n                if grid[r][c-1] == ori:\\n                    sides += 1\\n                if not vis[r][c-1]:\\n                    vis[r][c-1] = 1 \\n                    if grid[r][c-1] == ori:\\n                        queue.append([r, c-1])\\n                        q += 1       \\n            \\n            if r+1 < m:\\n                if grid[r+1][c] == ori:\\n                    sides += 1\\n                if not vis[r+1][c]:\\n                    vis[r+1][c] = 1 \\n                    if grid[r+1][c] == ori:\\n                        queue.append([r+1, c])\\n                        q += 1 \\n          \\n            if c+1 < n:\\n                if grid[r][c+1] == ori:\\n                    sides += 1\\n                if not vis[r][c+1]:\\n                    vis[r][c+1] = 1 \\n                    if grid[r][c+1] == ori:\\n                        queue.append([r, c+1])\\n                        q += 1 \\n                             \\n            if sides != 4:\\n                change.append([r, c])\\n                \\n        for r, c in change:\\n            grid[r][c] = color \\n            \\n        return grid",
                "codeTag": "Java"
            },
            {
                "id": 2769023,
                "title": "c-easy-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   void dfs(vector<vector<int>>& g, int r, int c, int cl) {\\n  if (r < 0 || c < 0 || r >= g.size() || c >= g[r].size() || g[r][c] != cl) return;\\n  g[r][c] = -cl;\\n  dfs(g, r - 1, c, cl), dfs(g, r + 1, c, cl), dfs(g, r, c - 1, cl), dfs(g, r, c + 1, cl);\\n  if (r > 0 && r < g.size() - 1 && c > 0 && c < g[r].size() - 1 && cl == abs(g[r - 1][c]) &&\\n    cl == abs(g[r + 1][c]) && cl == abs(g[r][c - 1]) && cl == abs(g[r][c + 1]))\\n    g[r][c] = cl;\\n}\\nvector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n  dfs(grid, r0, c0, grid[r0][c0]);\\n  for (auto i = 0; i < grid.size(); ++i)\\n    for (auto j = 0; j < grid[i].size(); ++j) grid[i][j] = grid[i][j] < 0 ? color : grid[i][j];\\n  return grid;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   void dfs(vector<vector<int>>& g, int r, int c, int cl) {\\n  if (r < 0 || c < 0 || r >= g.size() || c >= g[r].size() || g[r][c] != cl) return;\\n  g[r][c] = -cl;\\n  dfs(g, r - 1, c, cl), dfs(g, r + 1, c, cl), dfs(g, r, c - 1, cl), dfs(g, r, c + 1, cl);\\n  if (r > 0 && r < g.size() - 1 && c > 0 && c < g[r].size() - 1 && cl == abs(g[r - 1][c]) &&\\n    cl == abs(g[r + 1][c]) && cl == abs(g[r][c - 1]) && cl == abs(g[r][c + 1]))\\n    g[r][c] = cl;\\n}\\nvector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n  dfs(grid, r0, c0, grid[r0][c0]);\\n  for (auto i = 0; i < grid.size(); ++i)\\n    for (auto j = 0; j < grid[i].size(); ++j) grid[i][j] = grid[i][j] < 0 ? color : grid[i][j];\\n  return grid;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1972116,
                "title": "java-dfs-faster-than-100-do-checkout-for-explanation",
                "content": "**Do vote up if you like it :)**\\n \\nMake a DFS call on all connected rcColor (given rowColColor), check all your nbrs, if \"all of them\" is rcColor then you are not a boundary cell and you are not supposed to be colored with color, so keep a mark of that cell(say 1e9), and if \"all of the nbrs is not\" rcColor then you are a boundary Cell.\\n\\nNow, after you come out of DFS call, your boundary cells are all marked with -rcColor and withinBoundary cells are marked with 1e9, so change them accordingly.\\n```\\nclass Solution {\\n    \\n    public int n, m;\\n    \\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        n = grid.length;\\n        m = grid[0].length;\\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        int rcColor = grid[row][col];\\n        dfs(row, col, rcColor, grid, dir);\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == -rcColor) grid[i][j] = color; // Boundary cell, so mark with color\\n                else if(grid[i][j] == (int)1e9) grid[i][j] = rcColor; // Within boundary cell, so mark with rcColor(original)\\n            }\\n        }\\n        return grid;\\n    }\\n    \\n    public void dfs(int x, int y, int rcColor, int[][] grid, int[][] dir) {\\n        \\n        grid[x][y] = -rcColor; // visited\\n        int count = 0;\\n        for(int d = 0; d < dir.length; d++) {\\n            int r = x + dir[d][0];\\n            int c = y + dir[d][1];\\n            \\n            if(r >= 0 && r < n && c >= 0 && c < m) {\\n                if(Math.abs(grid[r][c]) == rcColor || grid[r][c] == (int)1e9) count++; // -rcColor, rcColor, 1e9 are same nbrs \\n                if(grid[r][c] == rcColor) { // call on unvisited nbr which is of rcColor\\n                    dfs(r, c, rcColor, grid, dir);\\n                }\\n            }\\n        }\\n        \\n        // Acc. to question if all 4 direction is rcColor, then it is not a boundary cell\\n        // So, mark yourself as 1e9 because if you mark it with rcColor then,\\n        // when you return from this cell, then another cell can call on this cell, considering it unvisited,\\n        // since we are making calls on all connected rcColor cell\\n        if(count == 4) grid[x][y] = (int)1e9; // to keep it visited && a mark for within boundary cell\\n    }\\n    \\n}\\n```\\n-------------------------------------------------------------",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int n, m;\\n    \\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        n = grid.length;\\n        m = grid[0].length;\\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        int rcColor = grid[row][col];\\n        dfs(row, col, rcColor, grid, dir);\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == -rcColor) grid[i][j] = color; // Boundary cell, so mark with color\\n                else if(grid[i][j] == (int)1e9) grid[i][j] = rcColor; // Within boundary cell, so mark with rcColor(original)\\n            }\\n        }\\n        return grid;\\n    }\\n    \\n    public void dfs(int x, int y, int rcColor, int[][] grid, int[][] dir) {\\n        \\n        grid[x][y] = -rcColor; // visited\\n        int count = 0;\\n        for(int d = 0; d < dir.length; d++) {\\n            int r = x + dir[d][0];\\n            int c = y + dir[d][1];\\n            \\n            if(r >= 0 && r < n && c >= 0 && c < m) {\\n                if(Math.abs(grid[r][c]) == rcColor || grid[r][c] == (int)1e9) count++; // -rcColor, rcColor, 1e9 are same nbrs \\n                if(grid[r][c] == rcColor) { // call on unvisited nbr which is of rcColor\\n                    dfs(r, c, rcColor, grid, dir);\\n                }\\n            }\\n        }\\n        \\n        // Acc. to question if all 4 direction is rcColor, then it is not a boundary cell\\n        // So, mark yourself as 1e9 because if you mark it with rcColor then,\\n        // when you return from this cell, then another cell can call on this cell, considering it unvisited,\\n        // since we are making calls on all connected rcColor cell\\n        if(count == 4) grid[x][y] = (int)1e9; // to keep it visited && a mark for within boundary cell\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418437,
                "title": "javascript-solution-w-comments",
                "content": "```\\n/**\\n * Color the cells which belong to same connected component of the starting cell\\n * that doesn\\'t have 4 valid adjacent cells with the same value as that of grid[row][col].\\n * *Time: O(N x M)\\n * *Space: O(N x M)\\n */\\n// Runtime: 96 ms, faster than 66.67% of JavaScript online submissions for Coloring A Border.\\n// Memory Usage: 41.9 MB, less than 100.00% of JavaScript online submissions for Coloring A Border.\\nconst colorBorder1 = function (grid, row, col, color) {\\n\\tconst directions = [\\n\\t\\t[1, 0],\\n\\t\\t[-1, 0],\\n\\t\\t[0, 1],\\n\\t\\t[0, -1],\\n\\t];\\n\\tconst visited = new Set();\\n\\tconst pixel = grid[row][col];\\n\\n\\tconst traverse = (x, y) => {\\n\\t\\tconst key = `${x}, ${y}`;\\n\\n\\t\\tif (visited.has(key)) return 1;\\n\\n\\t\\tif (x < 0 || x === grid.length) return 0;\\n\\t\\tif (y < 0 || y === grid[0].length) return 0;\\n\\t\\tif (grid[x][y] !== pixel) return 0;\\n\\n\\t\\tvisited.add(key);\\n\\n\\t\\tlet invalid = 1;\\n\\t\\tdirections.forEach(([dx, dy]) => {\\n\\t\\t\\tinvalid *= traverse(x + dx, y + dy);\\n\\t\\t});\\n\\n\\t\\t// if all 4 adjacents are the same, don\\'t change\\n\\t\\t// if any of the adjacent are different, change color\\n\\t\\tif (invalid) return 1;\\n\\t\\telse grid[x][y] = color;\\n\\n\\t\\treturn 1;\\n\\t};\\n\\n\\ttraverse(row, col);\\n\\treturn grid;\\n};\\n\\n/**\\n * *Time: O(N x M)\\n * *Space: O(N x M)\\n */\\n// Runtime: 73 ms, faster than 100.00% of JavaScript online submissions for Coloring A Border.\\n// Memory Usage: 46.5 MB, less than 45.83% of JavaScript online submissions for Coloring A Border.\\nconst colorBorder = (grid, row, col, color) => {\\n\\tconst directions = [\\n\\t\\t[1, 0],\\n\\t\\t[-1, 0],\\n\\t\\t[0, 1],\\n\\t\\t[0, -1],\\n\\t];\\n\\tconst pixel = grid[row][col];\\n\\n\\t// find borders and mark visited: -pixel\\n\\tconst traverse = (x, y) => {\\n\\t\\tif (x < 0 || x >= grid.length) return;\\n\\t\\tif (y < 0 || y >= grid[0].length) return;\\n\\t\\tif (grid[x][y] !== pixel) return;\\n\\n\\t\\tgrid[x][y] = -pixel; // mark visited\\n\\n\\t\\tdirections.forEach(([dx, dy]) => {\\n\\t\\t\\ttraverse(x + dx, y + dy);\\n\\t\\t});\\n\\n\\t\\t// check if all adjacents have same color\\n\\t\\tconst invalid = directions.every(([dx, dy]) => {\\n\\t\\t\\t// check if valid x AND y boundary\\n\\t\\t\\tconst validX = x > 0 && x < grid.length - 1;\\n\\t\\t\\tconst validY = y > 0 && y < grid[0].length - 1;\\n\\n\\t\\t\\tif (validX && validY) {\\n\\t\\t\\t\\tconst adjacent = grid[x + dx][y + dy];\\n\\n\\t\\t\\t\\treturn pixel === Math.abs(adjacent);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\t// revert color if all adjacents are same color\\n\\t\\tif (invalid) grid[x][y] = pixel;\\n\\t};\\n\\n\\ttraverse(row, col);\\n\\n\\t// find marked borders and overwrite with new color\\n\\tfor (let r = 0; r < grid.length; ++r)\\n\\t\\tfor (let c = 0; c < grid[r].length; ++c) {\\n\\t\\t\\tconst cv = grid[r][c];\\n\\n\\t\\t\\tif (cv < 0) grid[r][c] = color;\\n\\t\\t}\\n\\n\\treturn grid;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Color the cells which belong to same connected component of the starting cell\\n * that doesn\\'t have 4 valid adjacent cells with the same value as that of grid[row][col].\\n * *Time: O(N x M)\\n * *Space: O(N x M)\\n */\\n// Runtime: 96 ms, faster than 66.67% of JavaScript online submissions for Coloring A Border.\\n// Memory Usage: 41.9 MB, less than 100.00% of JavaScript online submissions for Coloring A Border.\\nconst colorBorder1 = function (grid, row, col, color) {\\n\\tconst directions = [\\n\\t\\t[1, 0],\\n\\t\\t[-1, 0],\\n\\t\\t[0, 1],\\n\\t\\t[0, -1],\\n\\t];\\n\\tconst visited = new Set();\\n\\tconst pixel = grid[row][col];\\n\\n\\tconst traverse = (x, y) => {\\n\\t\\tconst key = `${x}, ${y}`;\\n\\n\\t\\tif (visited.has(key)) return 1;\\n\\n\\t\\tif (x < 0 || x === grid.length) return 0;\\n\\t\\tif (y < 0 || y === grid[0].length) return 0;\\n\\t\\tif (grid[x][y] !== pixel) return 0;\\n\\n\\t\\tvisited.add(key);\\n\\n\\t\\tlet invalid = 1;\\n\\t\\tdirections.forEach(([dx, dy]) => {\\n\\t\\t\\tinvalid *= traverse(x + dx, y + dy);\\n\\t\\t});\\n\\n\\t\\t// if all 4 adjacents are the same, don\\'t change\\n\\t\\t// if any of the adjacent are different, change color\\n\\t\\tif (invalid) return 1;\\n\\t\\telse grid[x][y] = color;\\n\\n\\t\\treturn 1;\\n\\t};\\n\\n\\ttraverse(row, col);\\n\\treturn grid;\\n};\\n\\n/**\\n * *Time: O(N x M)\\n * *Space: O(N x M)\\n */\\n// Runtime: 73 ms, faster than 100.00% of JavaScript online submissions for Coloring A Border.\\n// Memory Usage: 46.5 MB, less than 45.83% of JavaScript online submissions for Coloring A Border.\\nconst colorBorder = (grid, row, col, color) => {\\n\\tconst directions = [\\n\\t\\t[1, 0],\\n\\t\\t[-1, 0],\\n\\t\\t[0, 1],\\n\\t\\t[0, -1],\\n\\t];\\n\\tconst pixel = grid[row][col];\\n\\n\\t// find borders and mark visited: -pixel\\n\\tconst traverse = (x, y) => {\\n\\t\\tif (x < 0 || x >= grid.length) return;\\n\\t\\tif (y < 0 || y >= grid[0].length) return;\\n\\t\\tif (grid[x][y] !== pixel) return;\\n\\n\\t\\tgrid[x][y] = -pixel; // mark visited\\n\\n\\t\\tdirections.forEach(([dx, dy]) => {\\n\\t\\t\\ttraverse(x + dx, y + dy);\\n\\t\\t});\\n\\n\\t\\t// check if all adjacents have same color\\n\\t\\tconst invalid = directions.every(([dx, dy]) => {\\n\\t\\t\\t// check if valid x AND y boundary\\n\\t\\t\\tconst validX = x > 0 && x < grid.length - 1;\\n\\t\\t\\tconst validY = y > 0 && y < grid[0].length - 1;\\n\\n\\t\\t\\tif (validX && validY) {\\n\\t\\t\\t\\tconst adjacent = grid[x + dx][y + dy];\\n\\n\\t\\t\\t\\treturn pixel === Math.abs(adjacent);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\t// revert color if all adjacents are same color\\n\\t\\tif (invalid) grid[x][y] = pixel;\\n\\t};\\n\\n\\ttraverse(row, col);\\n\\n\\t// find marked borders and overwrite with new color\\n\\tfor (let r = 0; r < grid.length; ++r)\\n\\t\\tfor (let c = 0; c < grid[r].length; ++c) {\\n\\t\\t\\tconst cv = grid[r][c];\\n\\n\\t\\t\\tif (cv < 0) grid[r][c] = color;\\n\\t\\t}\\n\\n\\treturn grid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1352828,
                "title": "simple-c-solution-explained-with-comments-and-picture",
                "content": "**This may help to understand the question in more better way**\\n\\n![image](https://assets.leetcode.com/users/images/07c3479b-f0e0-464b-adda-e45f2aaada92_1626872351.374051.png)\\n\\nThanks to @votrubac for the above [image](https://leetcode.com/problems/coloring-a-border/discuss/282847/C%2B%2B-with-picture-DFS)\\n\\n**CODE : **\\n\\n```\\n//all 4 directions\\nint dr[4] = {1,0,0,-1};\\nint dc[4] = {0,1,-1,0};\\n\\nclass Solution {\\n\\t//function to check if the element is inside the grid or not\\n    bool isValid(int i,int j,int r,int c)\\n    {\\n        if(i<0 or j<0 or i>=r or j>=c)\\n            return false;\\n        return true;\\n    }\\n    \\n    void dfs(vector<vector<int>> &grid,int r,int c,int i,int j,int col)\\n    {\\n\\t\\t// if (i,j) lies out of the grid or the current square has different color we return\\n        if(!isValid(i,j,r,c) or grid[i][j] != col) \\n            return;\\n        \\n\\t\\t//replace the color of components by -1\\n        grid[i][j] = -1;\\n\\t\\t\\n\\t\\t//calling dfs in all 4 directions\\n        for(int x=0;x<4;x++)\\n            dfs(grid,r,c,i+dr[x],j+dc[x],col);\\n    }\\n    \\n\\t//function to check if a component is surrounded by components from all 4 sides\\n    bool surrounded(vector<vector<int>> &grid,int i,int j,int r,int c)\\n    {   \\n\\t\\t//only non-boundary elements\\n        if(i>0 and j>0 and i<r-1 and j<c-1)\\n        {\\n            if(grid[i-1][j] == -1 and grid[i+1][j] == -1\\n              and grid[i][j-1] == -1 and grid[i][j+1] == -1) \\n                return true; \\n            \\n            else return false;\\n        }\\n        \\n        return false;\\n    }\\n    \\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        int col = grid[r0][c0];\\n        \\n        int r = grid.size() , c = grid[0].size();\\n        \\n        dfs(grid,r,c,r0,c0,col);\\n        \\n\\t\\t//hashmap to store positions of the surrounded components\\n        map<pair<int,int>,int> mp;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n\\t\\t\\t\\t//storing all the surrouned coordinates\\n                if(grid[i][j] == -1 and surrounded(grid,i,j,r,c))\\n                {\\n                   mp[{i,j}] = 1;\\n                }\\n            }\\n        }\\n        \\n\\t\\t//now coloring all -1 to desired colors \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(grid[i][j] == -1)\\n                {\\n\\t\\t\\t\\t\\t//if surroudned then revert back to original color\\n                    if(mp.find({i,j}) != mp.end()) grid[i][j] = col;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//else color with new color\\n                   else grid[i][j] = color;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n};\\n```\\n\\n**Time Complexity :** O(r * c)\\n\\n**Space Complexity :** O(r-2 * c-2) ~ O(r * c) [HASHMAP]",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n//all 4 directions\\nint dr[4] = {1,0,0,-1};\\nint dc[4] = {0,1,-1,0};\\n\\nclass Solution {\\n\\t//function to check if the element is inside the grid or not\\n    bool isValid(int i,int j,int r,int c)\\n    {\\n        if(i<0 or j<0 or i>=r or j>=c)\\n            return false;\\n        return true;\\n    }\\n    \\n    void dfs(vector<vector<int>> &grid,int r,int c,int i,int j,int col)\\n    {\\n\\t\\t// if (i,j) lies out of the grid or the current square has different color we return\\n        if(!isValid(i,j,r,c) or grid[i][j] != col) \\n            return;\\n        \\n\\t\\t//replace the color of components by -1\\n        grid[i][j] = -1;\\n\\t\\t\\n\\t\\t//calling dfs in all 4 directions\\n        for(int x=0;x<4;x++)\\n            dfs(grid,r,c,i+dr[x],j+dc[x],col);\\n    }\\n    \\n\\t//function to check if a component is surrounded by components from all 4 sides\\n    bool surrounded(vector<vector<int>> &grid,int i,int j,int r,int c)\\n    {   \\n\\t\\t//only non-boundary elements\\n        if(i>0 and j>0 and i<r-1 and j<c-1)\\n        {\\n            if(grid[i-1][j] == -1 and grid[i+1][j] == -1\\n              and grid[i][j-1] == -1 and grid[i][j+1] == -1) \\n                return true; \\n            \\n            else return false;\\n        }\\n        \\n        return false;\\n    }\\n    \\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        int col = grid[r0][c0];\\n        \\n        int r = grid.size() , c = grid[0].size();\\n        \\n        dfs(grid,r,c,r0,c0,col);\\n        \\n\\t\\t//hashmap to store positions of the surrounded components\\n        map<pair<int,int>,int> mp;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n\\t\\t\\t\\t//storing all the surrouned coordinates\\n                if(grid[i][j] == -1 and surrounded(grid,i,j,r,c))\\n                {\\n                   mp[{i,j}] = 1;\\n                }\\n            }\\n        }\\n        \\n\\t\\t//now coloring all -1 to desired colors \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(grid[i][j] == -1)\\n                {\\n\\t\\t\\t\\t\\t//if surroudned then revert back to original color\\n                    if(mp.find({i,j}) != mp.end()) grid[i][j] = col;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//else color with new color\\n                   else grid[i][j] = color;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227062,
                "title": "c-bfs-95",
                "content": "```\\nclass Solution {\\n    int dirx[4] = {0,1,0,-1};\\n    int diry[4] = {1,0,-1,0};\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        int m = grid.size(), n = grid[0].size();\\n        queue<pair<int, int>> q;\\n        vector<vector<int>> ans = grid;\\n        \\n        int sc = grid[r0][c0];\\n        q.push({r0,c0});\\n        grid[r0][c0] = 2000;\\n        \\n        while(q.size()) {\\n            pair<int, int> p = q.front(); q.pop();\\n            int x = p.first, y = p.second;\\n            bool isBoundary = false;\\n            \\n            for(int k=0; k<4; k++) {\\n                int nx = x + dirx[k];\\n                int ny = y + diry[k];\\n                \\n                if(nx==-1 or nx==m or ny==-1 or ny==n or (grid[nx][ny]!=2000 and grid[nx][ny]!=sc)) {\\n                    isBoundary = true;\\n                }\\n                \\n                if(nx>=0 and nx<m and ny>=0 and ny<n and grid[nx][ny] == sc) {\\n                    grid[nx][ny] = 2000;\\n                    q.push({nx, ny});\\n                }\\n            }\\n            \\n            if(isBoundary) ans[x][y] = color;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    int dirx[4] = {0,1,0,-1}",
                "codeTag": "Java"
            },
            {
                "id": 1112872,
                "title": "c-dfs-0-extra-space-and-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid, int r, int c,int initial_color)\\n    {\\n        \\n        \\n        // Get size of the gird\\n        int n=grid.size(),m=grid[0].size(),check=0;\\n        \\n        // Check if the given row and column are valid and if the element hasnt already been visited\\n        if(r>=n || r<0 || c>=m || c<0 || grid[r][c]!=initial_color) return;\\n        \\n        // Check if the given element is at the border or not(checking if it is adjacent to a square not in the connected component)\\n        if(r+1<n && (grid[r+1][c]!=initial_color && grid[r+1][c]!=1001 && grid[r+1][c]!=1002)) check=1;\\n        if(r-1>=0 && (grid[r-1][c]!=initial_color && grid[r-1][c]!=1001 && grid[r-1][c]!=1002)) check=1;\\n        if(c+1<m && (grid[r][c+1]!=initial_color && grid[r][c+1]!=1001 && grid[r][c+1]!=1002)) check=1;\\n        if(c-1>=0 && (grid[r][c-1]!=initial_color && grid[r][c-1]!=1001 && grid[r][c-1]!=1002)) check=1;\\n        \\n        // Checking if the element is on the boundry and hence a border element\\n        if(c==m-1 || c==0 || r==0 || r==n-1) check=1;\\n        \\n        // Marking it with 1001 if its a border element\\n        if(check)\\n            grid[r][c]=1001;\\n        \\n        // Marking it with 1002 if its a central element(non border)\\n        else\\n            grid[r][c]=1002;\\n        \\n        // checking and visiting all its immediate neighbours\\n        dfs(grid,r+1,c,initial_color);\\n        dfs(grid,r-1,c,initial_color);\\n        dfs(grid,r,c+1,initial_color);\\n        dfs(grid,r,c-1,initial_color);\\n        \\n        // Changing the central element to its original value hence marking it unvisited \\n        if(grid[r][c]==1002) grid[r][c]=initial_color;\\n        return ;\\n        \\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        int initial_color=grid[r0][c0];\\n        dfs(grid,r0,c0,initial_color);\\n        \\n        // Changing 1001 to the desired color \\n        for(int i=0;i<grid.size();i++)\\n            for(int j=0;j<grid[0].size();j++)\\n                if(grid[i][j]==1001) grid[i][j]=color;         \\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid, int r, int c,int initial_color)\\n    {\\n        \\n        \\n        // Get size of the gird\\n        int n=grid.size(),m=grid[0].size(),check=0;\\n        \\n        // Check if the given row and column are valid and if the element hasnt already been visited\\n        if(r>=n || r<0 || c>=m || c<0 || grid[r][c]!=initial_color) return;\\n        \\n        // Check if the given element is at the border or not(checking if it is adjacent to a square not in the connected component)\\n        if(r+1<n && (grid[r+1][c]!=initial_color && grid[r+1][c]!=1001 && grid[r+1][c]!=1002)) check=1;\\n        if(r-1>=0 && (grid[r-1][c]!=initial_color && grid[r-1][c]!=1001 && grid[r-1][c]!=1002)) check=1;\\n        if(c+1<m && (grid[r][c+1]!=initial_color && grid[r][c+1]!=1001 && grid[r][c+1]!=1002)) check=1;\\n        if(c-1>=0 && (grid[r][c-1]!=initial_color && grid[r][c-1]!=1001 && grid[r][c-1]!=1002)) check=1;\\n        \\n        // Checking if the element is on the boundry and hence a border element\\n        if(c==m-1 || c==0 || r==0 || r==n-1) check=1;\\n        \\n        // Marking it with 1001 if its a border element\\n        if(check)\\n            grid[r][c]=1001;\\n        \\n        // Marking it with 1002 if its a central element(non border)\\n        else\\n            grid[r][c]=1002;\\n        \\n        // checking and visiting all its immediate neighbours\\n        dfs(grid,r+1,c,initial_color);\\n        dfs(grid,r-1,c,initial_color);\\n        dfs(grid,r,c+1,initial_color);\\n        dfs(grid,r,c-1,initial_color);\\n        \\n        // Changing the central element to its original value hence marking it unvisited \\n        if(grid[r][c]==1002) grid[r][c]=initial_color;\\n        return ;\\n        \\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        int initial_color=grid[r0][c0];\\n        dfs(grid,r0,c0,initial_color);\\n        \\n        // Changing 1001 to the desired color \\n        for(int i=0;i<grid.size();i++)\\n            for(int j=0;j<grid[0].size();j++)\\n                if(grid[i][j]==1001) grid[i][j]=color;         \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 986426,
                "title": "java-easy-solution-beats-100",
                "content": "So, basically we need to color the border of the given cells(r0, c0) connected component.\\nWe can color a cell if \\n\\t(i). It is the cell at the boundary of our matrix or any element from 0th and last row or column.\\n\\t(ii). If one of the adjacent cell is not of the same color as the color of the given cell(r0, c0).\\n\\n\\n    boolean call(int[][] grid, boolean[][] visited, int row, int col, int color, int component)\\n    {\\n        if(row>= grid.length || row<0 || col>= grid[0].length || col<0)\\n            return true;\\n        else if(visited[row][col])\\n            return false;\\n        else if(grid[row][col]!= component)\\n            return true;\\n\\n        visited[row][col]= true;\\n        boolean should_i_color= call(grid, visited, row+1, col, color, component);\\n        should_i_color|= call(grid, visited, row-1, col, color, component);\\n        should_i_color|= call(grid, visited, row, col+1, color, component);\\n        should_i_color|= call(grid, visited, row, col-1, color, component);\\n\\n        if(should_i_color)\\n            grid[row][col]= color;\\n        return false;\\n    }\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) \\n    {\\n        boolean[][] visited= new boolean[grid.length][grid[0].length];\\n        call(grid, visited, r0, c0, color, grid[r0][c0]);\\n\\n        return grid;\\n    }",
                "solutionTags": [],
                "code": "So, basically we need to color the border of the given cells(r0, c0) connected component.\\nWe can color a cell if \\n\\t(i). It is the cell at the boundary of our matrix or any element from 0th and last row or column.\\n\\t(ii). If one of the adjacent cell is not of the same color as the color of the given cell(r0, c0).\\n\\n\\n    boolean call(int[][] grid, boolean[][] visited, int row, int col, int color, int component)\\n    {\\n        if(row>= grid.length || row<0 || col>= grid[0].length || col<0)\\n            return true;\\n        else if(visited[row][col])\\n            return false;\\n        else if(grid[row][col]!= component)\\n            return true;\\n\\n        visited[row][col]= true;\\n        boolean should_i_color= call(grid, visited, row+1, col, color, component);\\n        should_i_color|= call(grid, visited, row-1, col, color, component);\\n        should_i_color|= call(grid, visited, row, col+1, color, component);\\n        should_i_color|= call(grid, visited, row, col-1, color, component);\\n\\n        if(should_i_color)\\n            grid[row][col]= color;\\n        return false;\\n    }\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) \\n    {\\n        boolean[][] visited= new boolean[grid.length][grid[0].length];\\n        call(grid, visited, r0, c0, color, grid[r0][c0]);\\n\\n        return grid;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 906205,
                "title": "c-bfs-solution-explained",
                "content": "Runtime: 32 ms, faster than 74.70% of C++ online submissions for Coloring A Border.\\nMemory Usage: 14.4 MB, less than 13.99% of C++ online submissions for Coloring A Border.\\n\\nColor the border of the connected component. Nodes of connected component has same color and adjacent\\nin any 4 direction. Border of connected component are part of connected component means they have same\\ncolor as the color of the component except -\\na) border node has at least one neighbor node with different color\\nb) border node is in the border of the grid (first or last row or col)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // return true if node position is a border node of connected component\\n    bool isBorder(int &m, int &n, int &tx, int &ty, vector<vector<int>>& grid)\\n    {\\n        int rowOffset[] = {0,0,1,-1};\\n        int colOffset[] = {1,-1,0,0};\\n        \\n        int px,py;\\n        for(int i=0;i<4;i++)\\n        {\\n            px = tx + rowOffset[i];\\n            py = ty + colOffset[i];\\n            \\n            // node is border node if it has at least one neighbor with different color and so return true\\n            if(px>=0 && px<m && py>=0 && py<n && grid[tx][ty]!=grid[px][py]) return true;\\n        }\\n        \\n        // node is border node if it is border of the grid\\n        return (tx==0 || ty==0 || tx==m-1 || ty==n-1);\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // track if the square is visited or a border node of connected component\\n        vector<vector<int>>visited(m,vector<int>(n,0));\\n        \\n        // push source node (r0, c0) in to queue and also mark visited \\n        queue<pair<int,int>>Q;\\n        Q.push({r0,c0});\\n        visited[r0][c0] = 1;\\n        \\n        int tx,ty,px,py;\\n        int rowOffset[] = {0,0,1,-1};\\n        int colOffset[] = {1,-1,0,0};\\n        \\n        // run BFS until queue is empty\\n        while(!Q.empty())\\n        {\\n            tx = Q.front().first;\\n            ty = Q.front().second;\\n            Q.pop();\\n            \\n            // check if the current node is a border node, if then mark it as border node\\n            if(isBorder(m,n,tx,ty,grid))visited[tx][ty] = 2;            \\n\\n            // check the neighbor nodes\\n            for(int i=0;i<4;i++)\\n            {\\n                px = tx + rowOffset[i];\\n                py = ty + colOffset[i];\\n\\n                // push unvisited neighbor nodes with same color (connected component node) of the current node\\n                if(px>=0 && px<m && py>=0 && py<n && grid[tx][ty]==grid[px][py] && visited[px][py]==0)\\n                    visited[px][py] = 1,Q.push({px,py}); \\n            }\\n        }\\n        \\n        // check node positions marked as border node and color them\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(visited[i][j]==2) grid[i][j] = color;\\n        \\n        return grid;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // return true if node position is a border node of connected component\\n    bool isBorder(int &m, int &n, int &tx, int &ty, vector<vector<int>>& grid)\\n    {\\n        int rowOffset[] = {0,0,1,-1};\\n        int colOffset[] = {1,-1,0,0};\\n        \\n        int px,py;\\n        for(int i=0;i<4;i++)\\n        {\\n            px = tx + rowOffset[i];\\n            py = ty + colOffset[i];\\n            \\n            // node is border node if it has at least one neighbor with different color and so return true\\n            if(px>=0 && px<m && py>=0 && py<n && grid[tx][ty]!=grid[px][py]) return true;\\n        }\\n        \\n        // node is border node if it is border of the grid\\n        return (tx==0 || ty==0 || tx==m-1 || ty==n-1);\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // track if the square is visited or a border node of connected component\\n        vector<vector<int>>visited(m,vector<int>(n,0));\\n        \\n        // push source node (r0, c0) in to queue and also mark visited \\n        queue<pair<int,int>>Q;\\n        Q.push({r0,c0});\\n        visited[r0][c0] = 1;\\n        \\n        int tx,ty,px,py;\\n        int rowOffset[] = {0,0,1,-1};\\n        int colOffset[] = {1,-1,0,0};\\n        \\n        // run BFS until queue is empty\\n        while(!Q.empty())\\n        {\\n            tx = Q.front().first;\\n            ty = Q.front().second;\\n            Q.pop();\\n            \\n            // check if the current node is a border node, if then mark it as border node\\n            if(isBorder(m,n,tx,ty,grid))visited[tx][ty] = 2;            \\n\\n            // check the neighbor nodes\\n            for(int i=0;i<4;i++)\\n            {\\n                px = tx + rowOffset[i];\\n                py = ty + colOffset[i];\\n\\n                // push unvisited neighbor nodes with same color (connected component node) of the current node\\n                if(px>=0 && px<m && py>=0 && py<n && grid[tx][ty]==grid[px][py] && visited[px][py]==0)\\n                    visited[px][py] = 1,Q.push({px,py}); \\n            }\\n        }\\n        \\n        // check node positions marked as border node and color them\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(visited[i][j]==2) grid[i][j] = color;\\n        \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873995,
                "title": "python-dfs-faster-than-100-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n        \\n        def dfs(r, c, current, border, seen):\\n            \\n            # if out of range or seen\\n            if r<0 or c<0 or r >= len(grid) or c >= len(grid[0]) or grid[r][c] != current or (r,c) in seen:\\n                return\\n            \\n            seen.add((r,c))\\n            \\n            # if it is a border\\n            if (r==0 or c==0 or r==len(grid)-1 or c==len(grid[0])-1 or grid[r-1][c] != current or grid[r+1][c] != current or grid[r][c-1] != current or grid[r][c+1] != current):\\n                border.add((r,c))\\n                \\n                \\n            dfs(r-1, c, current, border, seen)\\n            dfs(r+1, c, current, border, seen)\\n            dfs(r, c-1, current, border, seen)\\n            dfs(r, c+1, current, border, seen)\\n                \\n            return\\n        \\n        if not grid:\\n            return grid\\n        \\n        current = grid[r0][c0]\\n        border = set()\\n        seen = set()\\n        dfs(r0, c0, current, border, seen)\\n        \\n        for elem in border:\\n            grid[elem[0]][elem[1]] = color\\n        \\n        return grid\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n        \\n        def dfs(r, c, current, border, seen):\\n            \\n            # if out of range or seen\\n            if r<0 or c<0 or r >= len(grid) or c >= len(grid[0]) or grid[r][c] != current or (r,c) in seen:\\n                return\\n            \\n            seen.add((r,c))\\n            \\n            # if it is a border\\n            if (r==0 or c==0 or r==len(grid)-1 or c==len(grid[0])-1 or grid[r-1][c] != current or grid[r+1][c] != current or grid[r][c-1] != current or grid[r][c+1] != current):\\n                border.add((r,c))\\n                \\n                \\n            dfs(r-1, c, current, border, seen)\\n            dfs(r+1, c, current, border, seen)\\n            dfs(r, c-1, current, border, seen)\\n            dfs(r, c+1, current, border, seen)\\n                \\n            return\\n        \\n        if not grid:\\n            return grid\\n        \\n        current = grid[r0][c0]\\n        border = set()\\n        seen = set()\\n        dfs(r0, c0, current, border, seen)\\n        \\n        for elem in border:\\n            grid[elem[0]][elem[1]] = color\\n        \\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853190,
                "title": "java-dfs-simple-solution-beats-100-runtime",
                "content": "\\nLogic is an application of *Flood Fill* algorithm. Here, there are two additional conditions to be checked: \\n\\n1. bordering cell of the input grid is always a border of the connected component, hence change the color to ncolor. \\n2. current cell bordering a cell (in the four direction) with a different color is also a border of the connected component. \\n\\t\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r, int c, int color) {\\n        dfs(grid,r,c,color,grid[r][c],new boolean[grid.length][grid[0].length]);\\n        return grid;\\n    }\\n    \\n    public void dfs(int[][] grid, int r, int c, int ncolor, int ocolor, boolean[][] visited){\\n        \\n        visited[r][c]=true;\\n        \\n\\t\\t//1. grid bordering cell is always a border of the connected component\\n        if( r==grid.length-1 || r==0 || c==0 || c==grid[0].length-1 )\\n                grid[r][c]=ncolor;\\n        \\n\\t\\t//2. if the next cell in the four directions is not of the same color, then the current cell is on border of the connected component\\n        if(r+1<grid.length && !visited[r+1][c]){\\n            if(grid[r+1][c]==ocolor)\\n                dfs(grid,r+1,c,ncolor,ocolor,visited);\\n            else\\n                grid[r][c]=ncolor;\\n        }\\n        \\n\\t\\tif(r-1>=0 && !visited[r-1][c]){\\n            if(grid[r-1][c]==ocolor)\\n                dfs(grid,r-1,c,ncolor,ocolor,visited);\\n            else\\n                grid[r][c]=ncolor;\\n        }\\n\\t\\t\\n        if(c+1<grid[0].length && !visited[r][c+1]){\\n            if(grid[r][c+1]==ocolor)\\n                dfs(grid,r,c+1,ncolor,ocolor,visited);  \\n            else\\n                grid[r][c]=ncolor;\\n        }\\n            \\n        if(c-1>=0 && !visited[r][c-1]){\\n            if(grid[r][c-1]==ocolor)\\n                dfs(grid,r,c-1,ncolor,ocolor,visited);\\n            else\\n                grid[r][c]=ncolor;\\n        }      \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r, int c, int color) {\\n        dfs(grid,r,c,color,grid[r][c],new boolean[grid.length][grid[0].length]);\\n        return grid;\\n    }\\n    \\n    public void dfs(int[][] grid, int r, int c, int ncolor, int ocolor, boolean[][] visited){\\n        \\n        visited[r][c]=true;\\n        \\n\\t\\t//1. grid bordering cell is always a border of the connected component\\n        if( r==grid.length-1 || r==0 || c==0 || c==grid[0].length-1 )\\n                grid[r][c]=ncolor;\\n        \\n\\t\\t//2. if the next cell in the four directions is not of the same color, then the current cell is on border of the connected component\\n        if(r+1<grid.length && !visited[r+1][c]){\\n            if(grid[r+1][c]==ocolor)\\n                dfs(grid,r+1,c,ncolor,ocolor,visited);\\n            else\\n                grid[r][c]=ncolor;\\n        }\\n        \\n\\t\\tif(r-1>=0 && !visited[r-1][c]){\\n            if(grid[r-1][c]==ocolor)\\n                dfs(grid,r-1,c,ncolor,ocolor,visited);\\n            else\\n                grid[r][c]=ncolor;\\n        }\\n\\t\\t\\n        if(c+1<grid[0].length && !visited[r][c+1]){\\n            if(grid[r][c+1]==ocolor)\\n                dfs(grid,r,c+1,ncolor,ocolor,visited);  \\n            else\\n                grid[r][c]=ncolor;\\n        }\\n            \\n        if(c-1>=0 && !visited[r][c-1]){\\n            if(grid[r][c-1]==ocolor)\\n                dfs(grid,r,c-1,ncolor,ocolor,visited);\\n            else\\n                grid[r][c]=ncolor;\\n        }      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700798,
                "title": "easy-c-code-using-dfs-with-explanation-easier-to-understand-xd",
                "content": "Temporary visited array is made\\n\\n\\t\\t\\tvis[i][j]=1     -->     point is visited before\\n\\t\\t\\tvis[i][j]=2     -->     point needs to be colored as given color\\n2 conditions to color a point:\\n1) If current point is boundary itself\\n2) if any point adjacent does not have the same color as connected component color\\nIn both these cases... the current point will be coloured\\n```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,0,1,0};\\n    int dy[4]={0,1,0,-1};\\n    void dfs(int u,int v,vector<vector<int>>& A,vector<vector<int>>& vis,int c){\\n        bool ans=false;// denotes weather the color of curent point needs to be changed\\n        vis[u][v]=1;\\n        int n=A.size();\\n        int m=A[0].size();\\n        for(int i=0;i<4;i++){\\n            int x=u+dx[i];\\n            int y=v+dy[i];\\n            if(x>=0 && x<=n-1 && y>=0 && y<=m-1 && !vis[x][y] && A[x][y]==c){\\n                dfs(x,y,A,vis,c);//If same color node(unvisited) is found then do the dfs.\\n            }\\n            if(x>=0 && x<=n-1 && y>=0 && y<=m-1 && A[x][y]!=c){\\n                ans=true;// If another color adjacent point is found then current point\\'s color needs to be changed\\n            }\\n        }\\n        if(u==0 || v==0 || u==n-1 || v==m-1 || ans){\\n            vis[u][v]=2;\\n        }\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& A, int r0, int c0, int color) {\\n        int n=A.size();\\n        int m=A[0].size();\\n        int c=A[r0][c0];\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        dfs(r0,c0,A,vis,c);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==2){\\n                    A[i][j]=color;\\n                }\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,0,1,0};\\n    int dy[4]={0,1,0,-1};\\n    void dfs(int u,int v,vector<vector<int>>& A,vector<vector<int>>& vis,int c){\\n        bool ans=false;// denotes weather the color of curent point needs to be changed\\n        vis[u][v]=1;\\n        int n=A.size();\\n        int m=A[0].size();\\n        for(int i=0;i<4;i++){\\n            int x=u+dx[i];\\n            int y=v+dy[i];\\n            if(x>=0 && x<=n-1 && y>=0 && y<=m-1 && !vis[x][y] && A[x][y]==c){\\n                dfs(x,y,A,vis,c);//If same color node(unvisited) is found then do the dfs.\\n            }\\n            if(x>=0 && x<=n-1 && y>=0 && y<=m-1 && A[x][y]!=c){\\n                ans=true;// If another color adjacent point is found then current point\\'s color needs to be changed\\n            }\\n        }\\n        if(u==0 || v==0 || u==n-1 || v==m-1 || ans){\\n            vis[u][v]=2;\\n        }\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& A, int r0, int c0, int color) {\\n        int n=A.size();\\n        int m=A[0].size();\\n        int c=A[r0][c0];\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        dfs(r0,c0,A,vis,c);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==2){\\n                    A[i][j]=color;\\n                }\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 481841,
                "title": "simple-c-dsu-solution",
                "content": "```\\n    public class Solution\\n    {\\n        private class Unions\\n        {\\n            private readonly int[] _parents;\\n            private readonly int[] _ranks;\\n\\n            public Unions(int n)\\n            {\\n                _parents = new int[n];\\n                _ranks = new int[n];\\n                for (int i = 0; i < n; i++)\\n                {\\n                    _parents[i] = i;\\n                }\\n            }\\n\\n            public int Find(int x)\\n            {\\n                if (x != _parents[x])\\n                {\\n                    x = Find(_parents[x]);\\n                }\\n                return _parents[x];\\n            }\\n\\n            public bool Union(int x, int y)\\n            {\\n                int px = Find(x);\\n                int py = Find(y);\\n                if (px == py)\\n                {\\n                    return false;\\n                }\\n                if (_ranks[px] > _ranks[py])\\n                {\\n                    _parents[py] = px;\\n                    _ranks[px]++;\\n                }\\n                else\\n                {\\n                    _parents[px] = py;\\n                    _ranks[py]++;\\n                }\\n                return true;\\n            }\\n        }\\n\\n        private static readonly (int, int)[] _directions = { (0,1), (0,-1), (1,0), (-1,0) };\\n\\n        public int[][] ColorBorder(int[][] grid, int r0, int c0, int color)\\n        {\\n            int n = grid.Length;\\n            int m = grid[0].Length;\\n\\n            Unions dsu = new Unions(n * m);\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    int ij = i * m + j;\\n\\n                    foreach (var dir in _directions)\\n                    {\\n                        int newI = i + dir.Item1;\\n                        int newJ = j + dir.Item2;\\n\\n                        if (newI >= 0 && newI < n && newJ >= 0 && newJ < m && grid[i][j] == grid[newI][newJ])\\n                        {\\n                            dsu.Union(ij, newI * m + newJ);\\n                        }\\n                    }\\n                }\\n            }\\n\\n            var targetRoot = dsu.Find(r0 * m + c0);\\n            ISet<(int,int)> border = new HashSet<(int, int)>();\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    int ij = i * m + j;\\n\\n                    if (dsu.Find(ij) != targetRoot)\\n                    {\\n                        continue;\\n                    }\\n\\n                    foreach (var dir in _directions)\\n                    {\\n                        int newI = i + dir.Item1;\\n                        int newJ = j + dir.Item2;\\n\\n                        if (newI < 0 || newI >= n || newJ < 0 || newJ >= m || dsu.Find(newI * m + newJ) != targetRoot)\\n                        {\\n                            border.Add((i, j));\\n                        }\\n                    }\\n                }\\n            }\\n\\n            foreach (var cell in border)\\n            {\\n                grid[cell.Item1][cell.Item2] = color;\\n            }\\n\\n            return grid;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        private class Unions\\n        {\\n            private readonly int[] _parents;\\n            private readonly int[] _ranks;\\n\\n            public Unions(int n)\\n            {\\n                _parents = new int[n];\\n                _ranks = new int[n];\\n                for (int i = 0; i < n; i++)\\n                {\\n                    _parents[i] = i;\\n                }\\n            }\\n\\n            public int Find(int x)\\n            {\\n                if (x != _parents[x])\\n                {\\n                    x = Find(_parents[x]);\\n                }\\n                return _parents[x];\\n            }\\n\\n            public bool Union(int x, int y)\\n            {\\n                int px = Find(x);\\n                int py = Find(y);\\n                if (px == py)\\n                {\\n                    return false;\\n                }\\n                if (_ranks[px] > _ranks[py])\\n                {\\n                    _parents[py] = px;\\n                    _ranks[px]++;\\n                }\\n                else\\n                {\\n                    _parents[px] = py;\\n                    _ranks[py]++;\\n                }\\n                return true;\\n            }\\n        }\\n\\n        private static readonly (int, int)[] _directions = { (0,1), (0,-1), (1,0), (-1,0) };\\n\\n        public int[][] ColorBorder(int[][] grid, int r0, int c0, int color)\\n        {\\n            int n = grid.Length;\\n            int m = grid[0].Length;\\n\\n            Unions dsu = new Unions(n * m);\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    int ij = i * m + j;\\n\\n                    foreach (var dir in _directions)\\n                    {\\n                        int newI = i + dir.Item1;\\n                        int newJ = j + dir.Item2;\\n\\n                        if (newI >= 0 && newI < n && newJ >= 0 && newJ < m && grid[i][j] == grid[newI][newJ])\\n                        {\\n                            dsu.Union(ij, newI * m + newJ);\\n                        }\\n                    }\\n                }\\n            }\\n\\n            var targetRoot = dsu.Find(r0 * m + c0);\\n            ISet<(int,int)> border = new HashSet<(int, int)>();\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    int ij = i * m + j;\\n\\n                    if (dsu.Find(ij) != targetRoot)\\n                    {\\n                        continue;\\n                    }\\n\\n                    foreach (var dir in _directions)\\n                    {\\n                        int newI = i + dir.Item1;\\n                        int newJ = j + dir.Item2;\\n\\n                        if (newI < 0 || newI >= n || newJ < 0 || newJ >= m || dsu.Find(newI * m + newJ) != targetRoot)\\n                        {\\n                            border.Add((i, j));\\n                        }\\n                    }\\n                }\\n            }\\n\\n            foreach (var cell in border)\\n            {\\n                grid[cell.Item1][cell.Item2] = color;\\n            }\\n\\n            return grid;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294725,
                "title": "java-clean-short-only-one-pass-dfs-with-details-explanation",
                "content": "```\\n private static final int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        if (grid == null || grid.length == 0) return grid;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        visited[r0][c0] = true;\\n        dfs(grid, r0, c0, grid[r0][c0], color, visited);\\n        return grid;\\n    }\\n    \\n    private void dfs(int[][] grid, int r, int c, int targetColor, int color, boolean[][] visited) {\\n        int count = 0; // the number of neighbors is connected\\n        for (int[] dir : dirs) {\\n            int x = r + dir[0];\\n            int y = c + dir[1];\\n            if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length) continue;\\n            if (grid[x][y] == targetColor || visited[x][y]) count++; // If the neighbor is our target, Or if we\\'ve already visited it, which means its connected \\n            if (grid[x][y] == targetColor && !visited[x][y]) { // We only visit the neighbor whose color is our target.\\n                visited[x][y] = true; \\n                dfs(grid, x, y, targetColor, color, visited);\\n            }\\n        }\\n        \\n        if (count != 4) { // if the count < 4, which means its a border, we need to change the color\\n            grid[r][c] = color;\\n        }\\n        return;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n private static final int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        if (grid == null || grid.length == 0) return grid;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        visited[r0][c0] = true;\\n        dfs(grid, r0, c0, grid[r0][c0], color, visited);\\n        return grid;\\n    }\\n    \\n    private void dfs(int[][] grid, int r, int c, int targetColor, int color, boolean[][] visited) {\\n        int count = 0; // the number of neighbors is connected\\n        for (int[] dir : dirs) {\\n            int x = r + dir[0];\\n            int y = c + dir[1];\\n            if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length) continue;\\n            if (grid[x][y] == targetColor || visited[x][y]) count++; // If the neighbor is our target, Or if we\\'ve already visited it, which means its connected \\n            if (grid[x][y] == targetColor && !visited[x][y]) { // We only visit the neighbor whose color is our target.\\n                visited[x][y] = true; \\n                dfs(grid, x, y, targetColor, color, visited);\\n            }\\n        }\\n        \\n        if (count != 4) { // if the count < 4, which means its a border, we need to change the color\\n            grid[r][c] = color;\\n        }\\n        return;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3991984,
                "title": "dfs-c-clean-and-concise-code-killer-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint m,n;\\n    vector<vector<int>> colorBorder(vector<vector<int>>& image, int sr, int sc, int color) \\n    {\\n        m=image.size();\\n        n=image[0].size();\\n        vector<vector<bool>>vis(m,vector<bool>(n,false));\\n        int hunt=image[sr][sc];\\n        dfs(sr,sc,image,vis,hunt,color);\\n        return image;\\n    }\\n    void dfs(int i,int j,vector<vector<int>>& image,vector<vector<bool>>& vis,int hunt,int color)\\n    {\\n        if(i<0||j<0||i>=m||j>=n||vis[i][j]||image[i][j]!=hunt)\\n        return;\\n        vis[i][j]=true;\\n        if(i==0||j==0||i>=m-1||j>=n-1)\\n        {\\n            image[i][j]=color;\\n        }\\n        if((i+1<=m-1 && image[i+1][j]!=hunt && !vis[i+1][j]) || (i-1>=0 && image[i-1][j]!=hunt && !vis[i-1][j]) || (j+1<=n-1 && image[i][j+1]!=hunt && !vis[i][j+1]) || (j-1>=0 && image[i][j-1]!=hunt && !vis[i][j-1]))\\n        image[i][j] = color;\\n        dfs(i+1,j,image,vis,hunt,color);\\n        dfs(i-1,j,image,vis,hunt,color);\\n        dfs(i,j+1,image,vis,hunt,color);\\n        dfs(i,j-1,image,vis,hunt,color);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint m,n;\\n    vector<vector<int>> colorBorder(vector<vector<int>>& image, int sr, int sc, int color) \\n    {\\n        m=image.size();\\n        n=image[0].size();\\n        vector<vector<bool>>vis(m,vector<bool>(n,false));\\n        int hunt=image[sr][sc];\\n        dfs(sr,sc,image,vis,hunt,color);\\n        return image;\\n    }\\n    void dfs(int i,int j,vector<vector<int>>& image,vector<vector<bool>>& vis,int hunt,int color)\\n    {\\n        if(i<0||j<0||i>=m||j>=n||vis[i][j]||image[i][j]!=hunt)\\n        return;\\n        vis[i][j]=true;\\n        if(i==0||j==0||i>=m-1||j>=n-1)\\n        {\\n            image[i][j]=color;\\n        }\\n        if((i+1<=m-1 && image[i+1][j]!=hunt && !vis[i+1][j]) || (i-1>=0 && image[i-1][j]!=hunt && !vis[i-1][j]) || (j+1<=n-1 && image[i][j+1]!=hunt && !vis[i][j+1]) || (j-1>=0 && image[i][j-1]!=hunt && !vis[i][j-1]))\\n        image[i][j] = color;\\n        dfs(i+1,j,image,vis,hunt,color);\\n        dfs(i-1,j,image,vis,hunt,color);\\n        dfs(i,j+1,image,vis,hunt,color);\\n        dfs(i,j-1,image,vis,hunt,color);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643291,
                "title": "dfs-intuitive-with-is-valid-pixel-and-is-border-helpers",
                "content": "# Intuition\\nAt first glance, the problem requires us to change the color of the border of a region in an image. Since the region is defined as all pixels with the same color that are 4-directionally connected (meaning they are connected either vertically or horizontally), the natural inclination is to solve this problem using depth-first search (DFS), a well-known algorithm used for traversing or searching tree or graph data structures. We use DFS to visit all pixels in the region. While doing this, we also check if the current pixel is on the border of the region, and if so, we color it with the new color.\\n\\n# Approach\\nThe approach to solve this problem involves three helper functions: `is_valid_pixel`, `is_border`, and `dfs`. `is_valid_pixel` checks if a pixel is inside the image and if it has the original color. `is_border` checks if a pixel is on the border of the image or is adjacent to a pixel that is not part of the region and has not yet been visited. If a pixel satisfies these conditions, it\\'s a border pixel.\\n\\nThe `dfs` function is where we perform the depth-first search. It checks if the current pixel is valid and unvisited. If it is a border pixel, we change its color to the new color. We then visit all four directions from the current pixel.\\n\\nFinally, the condition `original_color != newColor` prevents infinite loops when the new color is the same as the original color.\\n\\n# Complexity\\n- Time complexity: The time complexity of this solution is O(n), where n is the number of pixels in the image. In the worst-case scenario, every pixel in the image is visited once.\\n  \\n- Space complexity: The space complexity is also O(n), where n is the number of pixels in the image. The space complexity comes from the memory used to store the visited set and the memory used for the stack in the recursive DFS function. In the worst-case scenario, the depth of recursion could go up to n. This worst-case scenario would occur if all pixels have the same color and the starting pixel is at one corner of the image.\\n\\n# Code\\n```\\nclass Solution:\\n    def colorBorder(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        DIRECTIONS = [(0, 1), (0, -1), (-1, 0), (1, 0)]\\n        R = len(image); C = len(image[0])\\n        original_color = image[sr][sc]\\n        visited = set()\\n\\n        # return true if the pixel is in the image\\n        def is_valid_pixel(row, col):\\n            return 0 <= row < R and 0 <= col < C and image[row][col] == original_color\\n\\n        # return True if the pixel is at the border\\n        def is_border(row, col):\\n            return row == 0 or row == R-1 or col == 0 or col == C-1 or any(\\n                0 <= row + dr < R and 0 <= col + dc < C and image[row + dr][col + dc] != original_color and (row+dr, col+dc) not in visited\\n                for dr, dc in DIRECTIONS\\n            )\\n\\n        def dfs(row, col):\\n            if not is_valid_pixel(row, col) or (row, col) in visited:\\n                return\\n            if is_border(row, col):\\n                image[row][col] = newColor\\n            visited.add((row, col))\\n            for dr, dc in DIRECTIONS:\\n                dfs(row + dr, col + dc)\\n\\n        if original_color != newColor:\\n            dfs(sr, sc)\\n        return image\\n\\n```\\n\\n# is_border\\n`is_border` determines whether a given pixel, specified by its row and column indices, is on the border of a region with the same color in the image.\\n\\nHere is a detailed explanation of the logic:\\n\\n- `row == 0 or row == R-1 or col == 0 or col == C-1`: This condition checks if the pixel is on the edge of the image. If it is, it\\'s part of the border by definition.\\n\\n- `any(0 <= row + dr < R and 0 <= col + dc < C and image[row + dr][col + dc] != original_color and (row+dr, col+dc) not in visited for dr, dc in DIRECTIONS)`: This condition uses the `any` function, which returns `True` if any element in the iterable it\\'s given is `True`. It\\'s iterating over the four possible directions from the current pixel (up, down, left, right) represented by `DIRECTIONS`.\\n\\n  - `0 <= row + dr < R and 0 <= col + dc < C`: These conditions check that the pixel in the direction `(dr, dc)` is still within the image bounds.\\n\\n  - `image[row + dr][col + dc] != original_color`: This condition checks that the color of the pixel in the direction `(dr, dc)` is different from the original color. This would mean that the current pixel is next to a pixel of a different color, and is therefore on the border of its region.\\n\\n  - `(row+dr, col+dc) not in visited`: This condition checks that the pixel in the direction `(dr, dc)` has not been visited. This is to ensure that we don\\'t count pixels that have already been recolored as being different, as they might have been the same color originally. \\nIf any of these conditions is `True`, the function will return `True`, indicating that the pixel is indeed a border pixel.\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        DIRECTIONS = [(0, 1), (0, -1), (-1, 0), (1, 0)]\\n        R = len(image); C = len(image[0])\\n        original_color = image[sr][sc]\\n        visited = set()\\n\\n        # return true if the pixel is in the image\\n        def is_valid_pixel(row, col):\\n            return 0 <= row < R and 0 <= col < C and image[row][col] == original_color\\n\\n        # return True if the pixel is at the border\\n        def is_border(row, col):\\n            return row == 0 or row == R-1 or col == 0 or col == C-1 or any(\\n                0 <= row + dr < R and 0 <= col + dc < C and image[row + dr][col + dc] != original_color and (row+dr, col+dc) not in visited\\n                for dr, dc in DIRECTIONS\\n            )\\n\\n        def dfs(row, col):\\n            if not is_valid_pixel(row, col) or (row, col) in visited:\\n                return\\n            if is_border(row, col):\\n                image[row][col] = newColor\\n            visited.add((row, col))\\n            for dr, dc in DIRECTIONS:\\n                dfs(row + dr, col + dc)\\n\\n        if original_color != newColor:\\n            dfs(sr, sc)\\n        return image\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633496,
                "title": "c-bfs-onepass",
                "content": "\\n# Approach\\nmain idea is that if a node does not have similar values on all 4 sides than it is border cell. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int clr=grid[row][col];\\n\\n        vector<vector<int>> dir = {{-1,0},{1,0},{0,1},{0,-1}};\\n        vector<vector<bool>> vi(m,vector<bool>(n,0));\\n        vi[row][col]=1;\\n\\n        while(!q.empty()){\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n\\n            int cnt=0;\\n            for(int i=0;i<dir.size();i++){\\n                int nr=r+dir[i][0];\\n                int nc=c+dir[i][1];\\n                if(nr<m && nr>=0 && nc<n && nc>=0){\\n                    if(vi[nr][nc]==1) cnt++;\\n                    else if(grid[nr][nc]==clr){\\n                        cnt++;\\n                        vi[nr][nc]=1;\\n                        q.push({nr,nc});\\n                    }\\n                }\\n            }\\n            if(cnt!=4) grid[r][c]=color;\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int clr=grid[row][col];\\n\\n        vector<vector<int>> dir = {{-1,0},{1,0},{0,1},{0,-1}};\\n        vector<vector<bool>> vi(m,vector<bool>(n,0));\\n        vi[row][col]=1;\\n\\n        while(!q.empty()){\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n\\n            int cnt=0;\\n            for(int i=0;i<dir.size();i++){\\n                int nr=r+dir[i][0];\\n                int nc=c+dir[i][1];\\n                if(nr<m && nr>=0 && nc<n && nc>=0){\\n                    if(vi[nr][nc]==1) cnt++;\\n                    else if(grid[nr][nc]==clr){\\n                        cnt++;\\n                        vi[nr][nc]=1;\\n                        q.push({nr,nc});\\n                    }\\n                }\\n            }\\n            if(cnt!=4) grid[r][c]=color;\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606150,
                "title": "correct-c-solution-with-missing-testcase-so-far",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n       \\n    //my solution using visited\\n    //easy to understand\\n\\n    bool dfsHelper(vector<vector<int>>&grid, int r, int c,int &componentColor ,int &color,vector<vector<bool> >& visited){\\n        \\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size()){\\n            return true; \\n        }\\n        if(visited[r][c]){\\n            return false;\\n        }\\n        if(grid[r][c] != componentColor){\\n            //checking is color is different after checking visited because we ourselves may have had changed the color\\n            return true;\\n        }\\n        visited[r][c] = true;\\n        bool u = dfsHelper(grid,r-1,c,componentColor,color,visited);\\n        bool f = dfsHelper(grid,r,c+1,componentColor,color,visited);\\n        bool d = dfsHelper(grid,r+1,c,componentColor,color,visited);\\n        bool b = dfsHelper(grid,r,c-1,componentColor,color,visited);\\n        if(u || f || d || b){\\n            // GETTING TRUE IMPLIES THAT CURRENT VERTEX IS ON BORDER\\n            grid[r][c] = color; // changing to required color\\n        }\\n        return false;\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        vector<vector<bool>> visited(grid.size(),vector<bool> (grid[0].size(),false));\\n        dfsHelper(grid,row,col,grid[row][col],color,visited);\\n        return grid;\\n    }\\n    \\n```\\nI HAVE SUBMITTED AN VALID TESTCASE WHERE OTHER SOLUTION LIKE BELOW GIVE TLE BUT GOT ACCEPTED WHEN SUBMITTED: \\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/13932\\n\\n```\\n    /* WRONG(TLE) BUT ACCEPTED SOLUTION\\n\\n    This solution(below) got submitted successfully but it should give TLE for these testcases:\\n    1) Testcase of 10 x 10 grid with all 1\\'s, row = 0, col = 0, color = 3: https://justpaste.it/5krng\\n    2) Testcase of 50 x 50 grid with all 1\\'s, row = 0, col = 0, color = 3: https://justpaste.it/9y9si\\n    */\\n    \\n\\n    bool dfsHelper(vector<vector<int>>&grid, int r, int c,int &componentColor ,int &color){\\n        \\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size()){\\n            return true;\\n        }\\n        if(grid[r][c] == -1 * componentColor){\\n            return false;\\n        }\\n        if(grid[r][c] != componentColor){\\n            return true;\\n        }\\n\\n        grid[r][c] *= -1;\\n        bool u = dfsHelper(grid,r-1,c,componentColor,color);\\n        bool f = dfsHelper(grid,r,c+1,componentColor,color);\\n        bool d = dfsHelper(grid,r+1,c,componentColor,color);\\n        bool b = dfsHelper(grid,r,c-1,componentColor,color);\\n        if(!u && !f && !d && !b){\\n            grid[r][c] *= -1;\\n        }\\n        return false;\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int componentColor = grid[row][col];\\n        dfsHelper(grid,row,col,componentColor,color);\\n        for(int i = 0; i< grid.size(); i++){\\n            for(int j = 0; j< grid[0].size(); j++){\\n                if(grid[i][j] < 0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    \\n};\\n```\\n#UPDATED\\n1) Testcase of 10 x 10 grid with all 1\\'s, row = 0, col = 0, color = 3: https://justpaste.it/5krng\\nTHIS TESTCASE HAS BEEN ADDED NOW \\nNOW THE ABOVE WRONG(TLE) ANS WILL NOT BE ACCEPTED\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n       \\n    //my solution using visited\\n    //easy to understand\\n\\n    bool dfsHelper(vector<vector<int>>&grid, int r, int c,int &componentColor ,int &color,vector<vector<bool> >& visited){\\n        \\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size()){\\n            return true; \\n        }\\n        if(visited[r][c]){\\n            return false;\\n        }\\n        if(grid[r][c] != componentColor){\\n            //checking is color is different after checking visited because we ourselves may have had changed the color\\n            return true;\\n        }\\n        visited[r][c] = true;\\n        bool u = dfsHelper(grid,r-1,c,componentColor,color,visited);\\n        bool f = dfsHelper(grid,r,c+1,componentColor,color,visited);\\n        bool d = dfsHelper(grid,r+1,c,componentColor,color,visited);\\n        bool b = dfsHelper(grid,r,c-1,componentColor,color,visited);\\n        if(u || f || d || b){\\n            // GETTING TRUE IMPLIES THAT CURRENT VERTEX IS ON BORDER\\n            grid[r][c] = color; // changing to required color\\n        }\\n        return false;\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        vector<vector<bool>> visited(grid.size(),vector<bool> (grid[0].size(),false));\\n        dfsHelper(grid,row,col,grid[row][col],color,visited);\\n        return grid;\\n    }\\n    \\n```\n```\\n    /* WRONG(TLE) BUT ACCEPTED SOLUTION\\n\\n    This solution(below) got submitted successfully but it should give TLE for these testcases:\\n    1) Testcase of 10 x 10 grid with all 1\\'s, row = 0, col = 0, color = 3: https://justpaste.it/5krng\\n    2) Testcase of 50 x 50 grid with all 1\\'s, row = 0, col = 0, color = 3: https://justpaste.it/9y9si\\n    */\\n    \\n\\n    bool dfsHelper(vector<vector<int>>&grid, int r, int c,int &componentColor ,int &color){\\n        \\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size()){\\n            return true;\\n        }\\n        if(grid[r][c] == -1 * componentColor){\\n            return false;\\n        }\\n        if(grid[r][c] != componentColor){\\n            return true;\\n        }\\n\\n        grid[r][c] *= -1;\\n        bool u = dfsHelper(grid,r-1,c,componentColor,color);\\n        bool f = dfsHelper(grid,r,c+1,componentColor,color);\\n        bool d = dfsHelper(grid,r+1,c,componentColor,color);\\n        bool b = dfsHelper(grid,r,c-1,componentColor,color);\\n        if(!u && !f && !d && !b){\\n            grid[r][c] *= -1;\\n        }\\n        return false;\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int componentColor = grid[row][col];\\n        dfsHelper(grid,row,col,componentColor,color);\\n        for(int i = 0; i< grid.size(); i++){\\n            for(int j = 0; j< grid[0].size(); j++){\\n                if(grid[i][j] < 0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175011,
                "title": "easy-to-understand-javascript-solution-dfs",
                "content": "```\\nvar colorBorder = function(grid, row, col, color) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const visited = new Set();\\n    const isBorder = (row, col, color) => {\\n        const value = grid[row]?.[col];\\n        return value === \\'x\\' || value === color;\\n    };\\n    const coloring = (row, col, color) => {\\n        if (row < 0 || col < 0 || row >= m || col >= n) return;\\n        if (visited.has(`${row}_${col}`)) return;\\n        const value = grid[row][col];\\n        if (value !== color) return;\\n\\n        grid[row][col] = \\'x\\';\\n        coloring(row - 1, col, color);\\n        coloring(row + 1, col, color);\\n        coloring(row, col - 1, color);\\n        coloring(row, col + 1, color);\\n        const checkTop = isBorder(row - 1, col, color);\\n        const checkBottom = isBorder(row + 1, col, color);\\n        const checkLeft = isBorder(row, col - 1, color);\\n        const checkRight = isBorder(row, col + 1, color);\\n        if (checkTop && checkBottom && checkLeft && checkRight) {\\n          grid[row][col] = color;\\n          visited.add(`${row}_${col}`);\\n        }\\n    };\\n\\n    coloring(row, col, grid[row][col]);\\n    return grid.map(col => col.map(value => value === \\'x\\' ? color : value ));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar colorBorder = function(grid, row, col, color) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const visited = new Set();\\n    const isBorder = (row, col, color) => {\\n        const value = grid[row]?.[col];\\n        return value === \\'x\\' || value === color;\\n    };\\n    const coloring = (row, col, color) => {\\n        if (row < 0 || col < 0 || row >= m || col >= n) return;\\n        if (visited.has(`${row}_${col}`)) return;\\n        const value = grid[row][col];\\n        if (value !== color) return;\\n\\n        grid[row][col] = \\'x\\';\\n        coloring(row - 1, col, color);\\n        coloring(row + 1, col, color);\\n        coloring(row, col - 1, color);\\n        coloring(row, col + 1, color);\\n        const checkTop = isBorder(row - 1, col, color);\\n        const checkBottom = isBorder(row + 1, col, color);\\n        const checkLeft = isBorder(row, col - 1, color);\\n        const checkRight = isBorder(row, col + 1, color);\\n        if (checkTop && checkBottom && checkLeft && checkRight) {\\n          grid[row][col] = color;\\n          visited.add(`${row}_${col}`);\\n        }\\n    };\\n\\n    coloring(row, col, grid[row][col]);\\n    return grid.map(col => col.map(value => value === \\'x\\' ? color : value ));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3112503,
                "title": "crisp-n-clear-o-n-javascript-memory-94-72-meaningful-vars",
                "content": "# Intuition\\nFrog walk Approach\\n\\n# Approach\\ncolorTheComponent (getNeighbors) (coloring the boundary Components as well) with -1 as color\\nfind Components which aren\\'t part of boundary\\nreplace Components which aren\\'t part of boundary with original color\\nreplace all -1 components with original color\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N*N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfunction getNeighbors(grid, row, column) {\\n\\tconst totalRows = grid.length;\\n\\tconst totalColumns = grid[0].length;\\n\\tconst neighbors = [];\\n\\tif (row > 0) {\\n\\t\\tneighbors.push({ rowIndex: row - 1, columnIndex: column });\\n\\t}\\n\\tif (row < totalRows - 1) {\\n\\t\\tneighbors.push({ rowIndex: row + 1, columnIndex: column });\\n\\t}\\n\\n\\tif (column > 0) {\\n\\t\\tneighbors.push({ rowIndex: row, columnIndex: column - 1 });\\n\\t}\\n\\n\\tif (column < totalColumns - 1) {\\n\\t\\tneighbors.push({ rowIndex: row, columnIndex: column + 1 });\\n\\t}\\n\\n\\treturn neighbors;\\n}\\n\\nfunction colorTheComponent(grid, row, col, foundColor, color = -1, explored = {}) {\\n\\tconst neighbors = getNeighbors(grid, row, col);\\n\\tfor (const { rowIndex, columnIndex } of neighbors) {\\n\\t\\tconst key = `${rowIndex}_${columnIndex}`;\\n\\t\\tif (!explored[key] && grid[rowIndex][columnIndex] === foundColor) {\\n\\t\\t\\texplored[key] = true;\\n\\t\\t\\tgrid[rowIndex][columnIndex] = color;\\n\\t\\t\\tcolorTheComponent(grid, rowIndex, columnIndex, foundColor, color, explored);\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction isBoundary(grid, rowIndex, columnIndex) {\\n\\tconst response =\\n\\t\\tgrid[rowIndex - 1] &&\\n\\t\\tgrid[rowIndex - 1][columnIndex] === -1 &&\\n\\t\\tgrid[rowIndex + 1] &&\\n\\t\\tgrid[rowIndex + 1][columnIndex] === -1 &&\\n\\t\\tgrid[rowIndex] &&\\n\\t\\tgrid[rowIndex][columnIndex - 1] === -1 &&\\n\\t\\tgrid[rowIndex][columnIndex + 1] === -1\\n\\t\\t\\t? true\\n\\t\\t\\t: false;\\n\\treturn response;\\n}\\n\\nvar colorBorder = function(grid, row, col, color) {\\n\\tconst foundColor = grid[row][col];\\n\\tgrid[row][col] = -1;\\n\\tconst notInBoundary = [];\\n\\tcolorTheComponent(grid, row, col, foundColor);\\n\\tfor (let rowIndex = 0; rowIndex < grid.length; rowIndex++) {\\n\\t\\tfor (let columnIndex = 0; columnIndex < grid[rowIndex].length; columnIndex++) {\\n\\t\\t\\tif (grid[rowIndex][columnIndex] === -1) {\\n\\t\\t\\t\\tif (isBoundary(grid, rowIndex, columnIndex)) {\\n\\t\\t\\t\\t\\tnotInBoundary.push({ rowIndex, columnIndex });\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor (const { rowIndex, columnIndex } of notInBoundary) {\\n\\t\\tgrid[rowIndex][columnIndex] = foundColor;\\n\\t}\\n\\n\\tfor (let rowIndex = 0; rowIndex < grid.length; rowIndex++) {\\n\\t\\tfor (let columnIndex = 0; columnIndex < grid[rowIndex].length; columnIndex++) {\\n\\t\\t\\tif (grid[rowIndex][columnIndex] === -1) {\\n\\t\\t\\t\\tgrid[rowIndex][columnIndex] = color;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn grid;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction getNeighbors(grid, row, column) {\\n\\tconst totalRows = grid.length;\\n\\tconst totalColumns = grid[0].length;\\n\\tconst neighbors = [];\\n\\tif (row > 0) {\\n\\t\\tneighbors.push({ rowIndex: row - 1, columnIndex: column });\\n\\t}\\n\\tif (row < totalRows - 1) {\\n\\t\\tneighbors.push({ rowIndex: row + 1, columnIndex: column });\\n\\t}\\n\\n\\tif (column > 0) {\\n\\t\\tneighbors.push({ rowIndex: row, columnIndex: column - 1 });\\n\\t}\\n\\n\\tif (column < totalColumns - 1) {\\n\\t\\tneighbors.push({ rowIndex: row, columnIndex: column + 1 });\\n\\t}\\n\\n\\treturn neighbors;\\n}\\n\\nfunction colorTheComponent(grid, row, col, foundColor, color = -1, explored = {}) {\\n\\tconst neighbors = getNeighbors(grid, row, col);\\n\\tfor (const { rowIndex, columnIndex } of neighbors) {\\n\\t\\tconst key = `${rowIndex}_${columnIndex}`;\\n\\t\\tif (!explored[key] && grid[rowIndex][columnIndex] === foundColor) {\\n\\t\\t\\texplored[key] = true;\\n\\t\\t\\tgrid[rowIndex][columnIndex] = color;\\n\\t\\t\\tcolorTheComponent(grid, rowIndex, columnIndex, foundColor, color, explored);\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction isBoundary(grid, rowIndex, columnIndex) {\\n\\tconst response =\\n\\t\\tgrid[rowIndex - 1] &&\\n\\t\\tgrid[rowIndex - 1][columnIndex] === -1 &&\\n\\t\\tgrid[rowIndex + 1] &&\\n\\t\\tgrid[rowIndex + 1][columnIndex] === -1 &&\\n\\t\\tgrid[rowIndex] &&\\n\\t\\tgrid[rowIndex][columnIndex - 1] === -1 &&\\n\\t\\tgrid[rowIndex][columnIndex + 1] === -1\\n\\t\\t\\t? true\\n\\t\\t\\t: false;\\n\\treturn response;\\n}\\n\\nvar colorBorder = function(grid, row, col, color) {\\n\\tconst foundColor = grid[row][col];\\n\\tgrid[row][col] = -1;\\n\\tconst notInBoundary = [];\\n\\tcolorTheComponent(grid, row, col, foundColor);\\n\\tfor (let rowIndex = 0; rowIndex < grid.length; rowIndex++) {\\n\\t\\tfor (let columnIndex = 0; columnIndex < grid[rowIndex].length; columnIndex++) {\\n\\t\\t\\tif (grid[rowIndex][columnIndex] === -1) {\\n\\t\\t\\t\\tif (isBoundary(grid, rowIndex, columnIndex)) {\\n\\t\\t\\t\\t\\tnotInBoundary.push({ rowIndex, columnIndex });\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor (const { rowIndex, columnIndex } of notInBoundary) {\\n\\t\\tgrid[rowIndex][columnIndex] = foundColor;\\n\\t}\\n\\n\\tfor (let rowIndex = 0; rowIndex < grid.length; rowIndex++) {\\n\\t\\tfor (let columnIndex = 0; columnIndex < grid[rowIndex].length; columnIndex++) {\\n\\t\\t\\tif (grid[rowIndex][columnIndex] === -1) {\\n\\t\\t\\t\\tgrid[rowIndex][columnIndex] = color;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn grid;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2648186,
                "title": "2ms-java-ac-solution-in-o-1-space-dfs-graph-traversal",
                "content": "\\n\\t\\n\\t\\n\\tclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        \\n        int ans[][] = grid;\\n        int inCo = grid[row][col];\\n        dfs(grid,row,col,grid[row][col]);\\n        for(int i=0;i<grid.length;i++)\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        return grid;\\n    }\\n    int dirs[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void dfs(int[][] grid,int row,int col,int inCo){\\n        \\n        grid[row][col] = -inCo;\\n        int c=0;\\n        for(int i=0;i<4;i++){\\n            int rowdash = row + dirs[i][0];\\n            int coldash = col + dirs[i][1];\\n            \\n            if(rowdash<0 || coldash<0 || rowdash>=grid.length || coldash>=grid[0].length\\n               || Math.abs(grid[rowdash][coldash]) != inCo)\\n                continue;\\n            c++;\\n            if(grid[rowdash][coldash] != -inCo){\\n                dfs(grid,rowdash,coldash,inCo);\\n            }\\n           \\n        }\\n        if(c==4)\\n            grid[row][col] = inCo;\\n        \\n    }\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        \\n        int ans[][] = grid;\\n        int inCo = grid[row][col];\\n        dfs(grid,row,col,grid[row][col]);\\n        for(int i=0;i<grid.length;i++)\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2635883,
                "title": "c-python-flood-fill-with-condition-short-concise",
                "content": "# C++\\n```\\nclass Solution {\\n    void dfs(int i, int j, vector<vector<int>>& grid, int orgc, int c, vector<vector<int>> &temp) {\\n        if(i < 0 || i == grid.size() || j < 0 || j == grid[0].size() || grid[i][j] != orgc || grid[i][j] == c) return;\\n        grid[i][j] = c;\\n        \\n        dfs(i + 1, j, grid, orgc, c, temp);\\n        dfs(i - 1, j, grid, orgc, c, temp);\\n        dfs(i, j + 1, grid, orgc, c, temp);\\n        dfs(i, j - 1, grid, orgc, c, temp);\\n        \\n        if(i - 1 >= 0 && i + 1 < grid.size() && j - 1 >= 0 && j + 1 < grid[0].size()) {\\n            if(temp[i - 1][j] == orgc && temp[i + 1][j] == orgc && temp[i][j - 1] == orgc && temp[i][j + 1] == orgc) grid[i][j] = orgc;\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int i, int j, int c) {\\n        vector<vector<int>> temp = grid;\\n        dfs(i, j, grid, grid[i][j], c, temp);\\n        return grid;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def colorBorder(self, grid, row, col, color):\\n        temp = copy.deepcopy(grid)\\n        \\n        def dfs(i, j, g, orgc, c, temp):\\n            if(i < 0 or i == len(g) or j < 0 or j == len(g[0]) or g[i][j] != orgc or g[i][j] == c): return\\n            g[i][j] = c\\n            \\n            dfs(i + 1, j, g, orgc, c, temp)\\n            dfs(i - 1, j, g, orgc, c, temp)\\n            dfs(i, j + 1, g, orgc, c, temp)\\n            dfs(i, j - 1, g, orgc, c, temp)\\n            \\n            if(i - 1 >= 0 and i + 1 < len(g) and j - 1 >= 0 and j + 1 < len(g[0])):\\n                if(temp[i - 1][j] == orgc and temp[i + 1][j] == orgc and temp[i][j - 1] == orgc and temp[i][j + 1] == orgc):\\n                    g[i][j] = orgc\\n        \\n        dfs(row, col, grid, grid[row][col], color, temp)\\n        return grid\\n             \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int i, int j, vector<vector<int>>& grid, int orgc, int c, vector<vector<int>> &temp) {\\n        if(i < 0 || i == grid.size() || j < 0 || j == grid[0].size() || grid[i][j] != orgc || grid[i][j] == c) return;\\n        grid[i][j] = c;\\n        \\n        dfs(i + 1, j, grid, orgc, c, temp);\\n        dfs(i - 1, j, grid, orgc, c, temp);\\n        dfs(i, j + 1, grid, orgc, c, temp);\\n        dfs(i, j - 1, grid, orgc, c, temp);\\n        \\n        if(i - 1 >= 0 && i + 1 < grid.size() && j - 1 >= 0 && j + 1 < grid[0].size()) {\\n            if(temp[i - 1][j] == orgc && temp[i + 1][j] == orgc && temp[i][j - 1] == orgc && temp[i][j + 1] == orgc) grid[i][j] = orgc;\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int i, int j, int c) {\\n        vector<vector<int>> temp = grid;\\n        dfs(i, j, grid, grid[i][j], c, temp);\\n        return grid;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def colorBorder(self, grid, row, col, color):\\n        temp = copy.deepcopy(grid)\\n        \\n        def dfs(i, j, g, orgc, c, temp):\\n            if(i < 0 or i == len(g) or j < 0 or j == len(g[0]) or g[i][j] != orgc or g[i][j] == c): return\\n            g[i][j] = c\\n            \\n            dfs(i + 1, j, g, orgc, c, temp)\\n            dfs(i - 1, j, g, orgc, c, temp)\\n            dfs(i, j + 1, g, orgc, c, temp)\\n            dfs(i, j - 1, g, orgc, c, temp)\\n            \\n            if(i - 1 >= 0 and i + 1 < len(g) and j - 1 >= 0 and j + 1 < len(g[0])):\\n                if(temp[i - 1][j] == orgc and temp[i + 1][j] == orgc and temp[i][j - 1] == orgc and temp[i][j + 1] == orgc):\\n                    g[i][j] = orgc\\n        \\n        dfs(row, col, grid, grid[row][col], color, temp)\\n        return grid\\n             \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354488,
                "title": "dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dr[4] = {-1,0,0,1};\\n    int dc[4] = {0,-1,1,0};\\n    void dfs(int r,int c,int n,int m,vector<vector<int>>& grid){\\n  \\n        \\n        int count = 0;\\n        grid[r][c] = -grid[r][c];\\n        \\n        for(int i=0;i<4;i++){\\n            int x = r + dr[i];\\n            int y = c + dc[i];\\n            \\n            if(x<0 || x>=n || y<0 || y>=m)\\n                continue;\\n            \\n            if(grid[x][y] == grid[r][c]){\\n                count += 1;\\n            }\\n            \\n            else if(-grid[x][y] == grid[r][c]){\\n                count += 1;\\n                dfs(x,y,n,m,grid);\\n            }\\n        }\\n        \\n        if(count == 4){\\n            grid[r][c] = -grid[r][c];\\n        }\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        dfs(row,col,n,m,grid);\\n        // return grid;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int dr[4] = {-1,0,0,1}",
                "codeTag": "Java"
            },
            {
                "id": 2303112,
                "title": "80-tc-and-76-sc-easy-python-solution",
                "content": "```\\ndef colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n\\tm, n = len(grid), len(grid[0])\\n\\tdir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\tdef calc(i, j, c):\\n\\t\\tif not(0<=i<m and 0<=j<n): return 1\\n\\t\\treturn grid[i][j] != c and grid[i][j] != -1\\n\\t\\t\\n\\tdef dfs(i, j):\\n\\t\\tif not(0<=i<m and 0<=j<n):\\n\\t\\t\\treturn\\n\\t\\tvis.add((i, j))\\n\\t\\tc = grid[i][j]\\n\\t\\tfor x, y in dir:\\n\\t\\t\\tif(0<=i+x<m and 0<=j+y<n and grid[i+x][j+y] == c and (i+x, j+y) not in vis):\\n\\t\\t\\t\\tdfs(i+x, j+y)          \\n\\t\\tif(calc(i-1, j, c) or calc(i+1, j, c) or calc(i, j+1, c) or calc(i, j-1, c)):\\n\\t\\t\\tgrid[i][j] = -1\\n\\t\\t\\n\\tvis = set()\\n\\tdfs(row, col)\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif(grid[i][j] == -1):\\n\\t\\t\\t\\tgrid[i][j] = color\\n\\treturn(grid)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\ndef colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n\\tm, n = len(grid), len(grid[0])\\n\\tdir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\tdef calc(i, j, c):\\n\\t\\tif not(0<=i<m and 0<=j<n): return 1\\n\\t\\treturn grid[i][j] != c and grid[i][j] != -1\\n\\t\\t\\n\\tdef dfs(i, j):\\n\\t\\tif not(0<=i<m and 0<=j<n):\\n\\t\\t\\treturn\\n\\t\\tvis.add((i, j))\\n\\t\\tc = grid[i][j]\\n\\t\\tfor x, y in dir:\\n\\t\\t\\tif(0<=i+x<m and 0<=j+y<n and grid[i+x][j+y] == c and (i+x, j+y) not in vis):\\n\\t\\t\\t\\tdfs(i+x, j+y)          \\n\\t\\tif(calc(i-1, j, c) or calc(i+1, j, c) or calc(i, j+1, c) or calc(i, j-1, c)):\\n\\t\\t\\tgrid[i][j] = -1\\n\\t\\t\\n\\tvis = set()\\n\\tdfs(row, col)\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif(grid[i][j] == -1):\\n\\t\\t\\t\\tgrid[i][j] = color\\n\\treturn(grid)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2163778,
                "title": "dfs-and-bfs",
                "content": "**BFS SOLUTION**\\n\\n\\tclass Solution {\\n\\t\\t\\tstruct Pair{\\n\\t\\t\\t\\tint i;\\n\\t\\t\\t\\tint j;\\n\\t\\t\\t\\tbool border;\\n\\n\\t\\t\\t\\tPair(int i,int j,bool border){\\n\\t\\t\\t\\t\\tthis->i = i;\\n\\t\\t\\t\\t\\tthis->j = j;\\n\\t\\t\\t\\t\\tthis->border = border;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\tvector<vector<bool>> visited;\\n\\t\\t\\tint dir[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\\n\\t\\tpublic:\\n\\n\\t\\t\\tvector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n\\t\\t\\t\\t// dfs\\n\\t\\t\\t\\tint originalColor = grid[row][col];\\n\\n\\t\\t\\t\\tvisited = vector<vector<bool>>(grid.size(),vector<bool>(grid[0].size(),0));\\n\\t\\t\\t\\tqueue<Pair> qu;\\n\\t\\t\\t\\tqu.push(Pair(row,col, isBorder(grid,row,col)));\\n\\n\\t\\t\\t\\tvector<Pair> vp;\\n\\t\\t\\t\\twhile(!qu.empty()){\\n\\t\\t\\t\\t\\tauto top = qu.front();\\n\\t\\t\\t\\t\\tqu.pop();\\n\\t\\t\\t\\t\\tif(visited[top.i][top.j])continue;\\n\\t\\t\\t\\t\\tvisited[top.i][top.j] = true;\\n\\t\\t\\t\\t\\t// some checks\\n\\t\\t\\t\\t\\tvp.push_back(top);\\n\\n\\t\\t\\t\\t\\tfor(auto d : dir){\\n\\t\\t\\t\\t\\t\\tint i = d[0] + top.i;\\n\\t\\t\\t\\t\\t\\tint j = d[1] + top.j;\\n\\t\\t\\t\\t\\t\\tif(i>=0 and j>=0 and i<grid.size() and j<grid[0].size() and visited[i][j]==false and grid[i][j]==originalColor){\\n\\t\\t\\t\\t\\t\\t\\tqu.push(Pair(i,j, isBorder(grid,i,j)));\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(auto p : vp){\\n\\t\\t\\t\\t\\tif(p.border){\\n\\t\\t\\t\\t\\t\\tgrid[p.i][p.j] = color;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn grid;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool isBorder(vector<vector<int>> &grid,int i,int j){\\n\\t\\t\\t\\tif(i==0 || j == 0 || i==grid.size() -1 || j==grid[0].size() - 1){\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(auto d : dir){\\n\\t\\t\\t\\t\\tint x = d[0] + i;\\n\\t\\t\\t\\t\\tint y = d[1] + j;\\n\\n\\t\\t\\t\\t\\tif(grid[i][j]!=grid[x][y])return true;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\n\\t\\n**DFS SOLUTION:**\\nNot sure about some check conditions 100% but it passed all testcases \\n\\n\\n\\t\\tclass Solution {\\n\\t\\t\\tvector<vector<bool>> visited;\\n\\t\\t\\tint dir[4][2] = {{0,1},{1,0},{-1,0},{0,-1}};\\n\\t\\tpublic:\\n\\t\\t\\tvoid dfs(vector<vector<int>> &grid,int row,int col,int r,int c,int color){\\n\\t\\t\\t\\tif(visited[r][c])return;\\n\\t\\t\\t\\tif(grid[row][col] != grid[r][c])return;\\n\\t\\t\\t\\tbool current = false;\\n\\t\\t\\t\\tvisited[r][c] = true;\\n\\t\\t\\t\\tfor(auto d : dir){\\n\\t\\t\\t\\t\\tint x = d[0] + r;\\n\\t\\t\\t\\t\\tint y = d[1] + c;\\n\\n\\t\\t\\t\\t\\tif(x < 0 || y < 0 || x >= grid.size() || y >= grid[0].size() ||(visited[x][y]==false and grid[x][y]!=grid[row][col])){\\n\\t\\t\\t\\t\\t\\tcurrent = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(x >= 0 && y >= 0 && x < grid.size() && y < grid[0].size() && visited[x][y]==false){\\n\\t\\t\\t\\t\\t\\tdfs(grid,row,col,x,y,color);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(current){\\n\\t\\t\\t\\t\\tgrid[r][c] = color;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\tvector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n\\t\\t\\t\\t// dfs\\n\\n\\t\\t\\t\\tvisited = vector<vector<bool>>(grid.size(),vector<bool>(grid[0].size(),0));\\n\\n\\t\\t\\t\\tdfs(grid,row,col,row,col,color);\\n\\n\\t\\t\\t\\treturn grid;\\n\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\t\\t\\tstruct Pair{\\n\\t\\t\\t\\tint i;\\n\\t\\t\\t\\tint j;\\n\\t\\t\\t\\tbool border;\\n\\n\\t\\t\\t\\tPair(int i,int j,bool border){\\n\\t\\t\\t\\t\\tthis->i = i;\\n\\t\\t\\t\\t\\tthis->j = j;\\n\\t\\t\\t\\t\\tthis->border = border;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2133781,
                "title": "python-standard-dfs-71-faster",
                "content": "```\\nfrom queue import Queue\\nclass Solution:\\n    \"\"\"\\n    approach: the problem can be tackled using breadth first approach\\n    start the bfs from (row, col) and maintain visited and border_set\\n    \"\"\"\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        start_color = grid[row][col]\\n        visited = set()\\n        \\n        def is_valid(index):\\n            i, j = index\\n            if 0 <= i < m and 0 <= j < n:\\n                return True\\n            return False\\n        \\n        def is_boundary(index):\\n            i, j = index\\n            if i == 0 or i == m-1 or j == 0 or j == n-1:\\n                return True\\n            return False\\n        \\n        def get_neighbors(index):\\n            i, j = index\\n            return [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n        \\n        def dfs(index):\\n            visited.add(index)\\n            \\n            flag = 0\\n            if is_boundary(index):\\n                flag = 1\\n                \\n            for pos in get_neighbors(index):\\n                if is_valid(pos) and pos not in visited: \\n                    if grid[pos[0]][pos[1]] == start_color:\\n                        dfs(pos)\\n                    else:\\n                        # it\\'s a border point, index needs to be colored with color\\n                        flag = 1\\n            if flag:\\n                grid[index[0]][index[1]] = color\\n                \\n        dfs((row, col))\\n        return grid\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom queue import Queue\\nclass Solution:\\n    \"\"\"\\n    approach: the problem can be tackled using breadth first approach\\n    start the bfs from (row, col) and maintain visited and border_set\\n    \"\"\"\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        start_color = grid[row][col]\\n        visited = set()\\n        \\n        def is_valid(index):\\n            i, j = index\\n            if 0 <= i < m and 0 <= j < n:\\n                return True\\n            return False\\n        \\n        def is_boundary(index):\\n            i, j = index\\n            if i == 0 or i == m-1 or j == 0 or j == n-1:\\n                return True\\n            return False\\n        \\n        def get_neighbors(index):\\n            i, j = index\\n            return [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n        \\n        def dfs(index):\\n            visited.add(index)\\n            \\n            flag = 0\\n            if is_boundary(index):\\n                flag = 1\\n                \\n            for pos in get_neighbors(index):\\n                if is_valid(pos) and pos not in visited: \\n                    if grid[pos[0]][pos[1]] == start_color:\\n                        dfs(pos)\\n                    else:\\n                        # it\\'s a border point, index needs to be colored with color\\n                        flag = 1\\n            if flag:\\n                grid[index[0]][index[1]] = color\\n                \\n        dfs((row, col))\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918709,
                "title": "c-easy-solution-dfs-explained",
                "content": "What question has asked?\\nin the connectred component mark all the values to the colored one which are on the border of the sqaure or who has adjacently atleast one square which is not the part of connected component.\\n```\\n// m,n,co are number of row, column and color to assigned\\nint m,n,co;\\n    void dfs(vector<vector<int>>& grid , vector<vector<bool>>& vis , int i , int j ,int val)\\n    {\\n\\t// base condition to eliminate the coordinate\\n        if(i<0 || j<0 || i>=m || j>=n || vis[i][j] || grid[i][j]!=val)\\n            return;\\n        vis[i][j] = true;\\n\\t\\t// check if present on the border of the square or not\\n        if(i==0 || j==0 || i>=m-1 || j>=n-1)\\n            grid[i][j]=co;\\n\\t\\t\\t// conditon to check if their is present some differnt color square on the border of the connected component\\n        if((i+1<=m-1 && grid[i+1][j]!=val && !vis[i+1][j]) || (i-1>=0 && grid[i-1][j]!=val && !vis[i-1][j]) || (j+1<=n-1 && grid[i][j+1]!=val && !vis[i][j+1]) || (j-1>=0 && grid[i][j-1]!=val && !vis[i][j-1]))\\n            grid[i][j] = co;\\n\\t\\t\\t// do dfs in all 4 directions\\n        dfs(grid,vis,i+1,j,val);\\n        dfs(grid,vis,i,j+1,val);\\n        dfs(grid,vis,i,j-1,val);\\n        dfs(grid,vis,i-1,j,val);\\n        return;\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        co = color;\\n        vector<vector<bool>> vis(m,vector<bool>(n,false));\\n        dfs(grid,vis,row,col,grid[row][col]);\\n        return grid;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n// m,n,co are number of row, column and color to assigned\\nint m,n,co;\\n    void dfs(vector<vector<int>>& grid , vector<vector<bool>>& vis , int i , int j ,int val)\\n    {\\n\\t// base condition to eliminate the coordinate\\n        if(i<0 || j<0 || i>=m || j>=n || vis[i][j] || grid[i][j]!=val)\\n            return;\\n        vis[i][j] = true;\\n\\t\\t// check if present on the border of the square or not\\n        if(i==0 || j==0 || i>=m-1 || j>=n-1)\\n            grid[i][j]=co;\\n\\t\\t\\t// conditon to check if their is present some differnt color square on the border of the connected component\\n        if((i+1<=m-1 && grid[i+1][j]!=val && !vis[i+1][j]) || (i-1>=0 && grid[i-1][j]!=val && !vis[i-1][j]) || (j+1<=n-1 && grid[i][j+1]!=val && !vis[i][j+1]) || (j-1>=0 && grid[i][j-1]!=val && !vis[i][j-1]))\\n            grid[i][j] = co;\\n\\t\\t\\t// do dfs in all 4 directions\\n        dfs(grid,vis,i+1,j,val);\\n        dfs(grid,vis,i,j+1,val);\\n        dfs(grid,vis,i,j-1,val);\\n        dfs(grid,vis,i-1,j,val);\\n        return;\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        co = color;\\n        vector<vector<bool>> vis(m,vector<bool>(n,false));\\n        dfs(grid,vis,row,col,grid[row][col]);\\n        return grid;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1905263,
                "title": "python-solution-using-dfs",
                "content": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        \\n        \\n        def dfs(i,j,parent):\\n            if (i,j) in visited:\\n                return\\n            \\n            if i<0 or j<0 or i>=m or j>=n or grid[i][j]!=ic  :\\n                grid[parent[0]][parent[1]]=color\\n                return\\n            \\n            visited.add((i,j))\\n            \\n            dfs(i-1,j,(i,j))\\n            dfs(i+1,j,(i,j))\\n            dfs(i,j-1,(i,j))\\n            dfs(i,j+1,(i,j))\\n            \\n        ic=grid[row][col]\\n        m=len(grid)\\n        n=len(grid[0])\\n        visited=set()\\n        dfs(row,col,(-1,-1))\\n        return grid\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        \\n        \\n        def dfs(i,j,parent):\\n            if (i,j) in visited:\\n                return\\n            \\n            if i<0 or j<0 or i>=m or j>=n or grid[i][j]!=ic  :\\n                grid[parent[0]][parent[1]]=color\\n                return\\n            \\n            visited.add((i,j))\\n            \\n            dfs(i-1,j,(i,j))\\n            dfs(i+1,j,(i,j))\\n            dfs(i,j-1,(i,j))\\n            dfs(i,j+1,(i,j))\\n            \\n        ic=grid[row][col]\\n        m=len(grid)\\n        n=len(grid[0])\\n        visited=set()\\n        dfs(row,col,(-1,-1))\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850221,
                "title": "java-dfs-recursion-2-passes",
                "content": "Pretty simple solution using DFS recursion. The idea was to mark the component using negatives and then flip them back in a second pass.\\n\\nIf I didn\\'t want to mess with the initial grid I would create a second result grid. Then do a single pass writing to the result grid and use non-zero values in said grid to track visited cells. As the final step I\\'d loop through the origional grid to copy over everything missing in the result grid. \\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        markComponent(grid,row,col,grid[row][col],color);\\n        fixComponent(grid,row,col);\\n        return grid;\\n    }\\n    \\n    int markComponent(int[][] g, int r, int c, int t, int color) {\\n        if (r < 0 || c < 0 || r == g.length || c == g[0].length || (g[r][c] != t && g[r][c] > 0)) return 0;\\n        if (g[r][c] > 0) {\\n            g[r][c] = -t;\\n            if (markComponent(g,r-1,c,t,color) +\\n               markComponent(g,r+1,c,t,color) +\\n               markComponent(g,r,c-1,t,color) +\\n               markComponent(g,r,c+1,t,color) < 4)\\n                g[r][c] = -color;\\n        }\\n        return 1;\\n    }\\n    \\n    void fixComponent(int[][] g, int r, int c) {\\n        if (r < 0 || c < 0 || r == g.length || c == g[0].length || g[r][c] > 0) return;\\n        g[r][c] = -g[r][c];\\n        fixComponent(g,r-1,c);\\n        fixComponent(g,r+1,c);\\n        fixComponent(g,r,c-1);\\n        fixComponent(g,r,c+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        markComponent(grid,row,col,grid[row][col],color);\\n        fixComponent(grid,row,col);\\n        return grid;\\n    }\\n    \\n    int markComponent(int[][] g, int r, int c, int t, int color) {\\n        if (r < 0 || c < 0 || r == g.length || c == g[0].length || (g[r][c] != t && g[r][c] > 0)) return 0;\\n        if (g[r][c] > 0) {\\n            g[r][c] = -t;\\n            if (markComponent(g,r-1,c,t,color) +\\n               markComponent(g,r+1,c,t,color) +\\n               markComponent(g,r,c-1,t,color) +\\n               markComponent(g,r,c+1,t,color) < 4)\\n                g[r][c] = -color;\\n        }\\n        return 1;\\n    }\\n    \\n    void fixComponent(int[][] g, int r, int c) {\\n        if (r < 0 || c < 0 || r == g.length || c == g[0].length || g[r][c] > 0) return;\\n        g[r][c] = -g[r][c];\\n        fixComponent(g,r-1,c);\\n        fixComponent(g,r+1,c);\\n        fixComponent(g,r,c-1);\\n        fixComponent(g,r,c+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615762,
                "title": "c-bfs",
                "content": "```\\nint direction[][4] = {{1,-1,0,0}, {0,0,1,-1}};\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int colour = grid[row][col];\\n        if (colour == color) {\\n            return grid;\\n        }\\n        queue<pair<int,int>> q;\\n        q.push({row, col});\\n\\n       \\n        while (!q.empty()) {\\n            int row = q.front().first, col = q.front().second;\\n            int cnt = 0;\\n            for (int d = 0; d < 4; ++d) {\\n                int r = row + direction[0][d], c = col + direction[1][d];\\n                \\n                if (0 <= r && r < grid.size() && \\n                    0 <= c && c < grid[r].size()) {\\n                    cnt += grid[r][c] == colour || grid[r][c] < 0;\\n                    if (grid[r][c] == colour) {\\n                        q.push({r, c});\\n                    }\\n                }\\n            }\\n            if (cnt < 4) {\\n                grid[row][col] = -color;\\n            } else {\\n                grid[row][col] *= -1;\\n            }\\n            q.pop();\\n        }\\n\\n        for (int i = 0; i < grid.size(); ++i) {\\n            for (int j = 0; j < grid[i].size(); ++j) {\\n                grid[i][j] = abs(grid[i][j]);\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint direction[][4] = {{1,-1,0,0}, {0,0,1,-1}};\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int colour = grid[row][col];\\n        if (colour == color) {\\n            return grid;\\n        }\\n        queue<pair<int,int>> q;\\n        q.push({row, col});\\n\\n       \\n        while (!q.empty()) {\\n            int row = q.front().first, col = q.front().second;\\n            int cnt = 0;\\n            for (int d = 0; d < 4; ++d) {\\n                int r = row + direction[0][d], c = col + direction[1][d];\\n                \\n                if (0 <= r && r < grid.size() && \\n                    0 <= c && c < grid[r].size()) {\\n                    cnt += grid[r][c] == colour || grid[r][c] < 0;\\n                    if (grid[r][c] == colour) {\\n                        q.push({r, c});\\n                    }\\n                }\\n            }\\n            if (cnt < 4) {\\n                grid[row][col] = -color;\\n            } else {\\n                grid[row][col] *= -1;\\n            }\\n            q.pop();\\n        }\\n\\n        for (int i = 0; i < grid.size(); ++i) {\\n            for (int j = 0; j < grid[i].size(); ++j) {\\n                grid[i][j] = abs(grid[i][j]);\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613627,
                "title": "simple-java-dfs",
                "content": "```\\nclass Solution {\\n   public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        if (grid == null || grid.length == 0) {\\n            return grid;\\n        }\\n        int val = grid[row][col];\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        dfs(grid, row, col, val, visited);\\n        fillGrid(grid, color, visited);\\n        return grid;\\n    }\\n\\n    public void dfs(int[][] grid, int row, int col, int val, boolean[][] visited) {\\n\\n        if (row >= grid.length || col >= grid[0].length || row < 0 || col < 0 || grid[row][col] != val || visited[row][col]) {\\n            return;\\n        }\\n\\n        //LURD\\n        if (grid[row][col] == val) {\\n            visited[row][col] = true;\\n            dfs(grid, row, col - 1, val, visited);\\n            dfs(grid, row + 1, col, val, visited);\\n            dfs(grid, row, col + 1, val, visited);\\n            dfs(grid, row - 1, col, val, visited);\\n        }\\n    }\\n\\n    public void fillGrid(int[][] grid, int color, boolean[][] visited) {\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n\\n                if (visited[i][j]) {\\n\\n                    //color boundary elements\\n                    if (i + 1 >= grid.length || j + 1 >= grid[0].length || i - 1 < 0 || j - 1 < 0) {\\n                        grid[i][j] = color;\\n                    }\\n                    //middle element\\n                    else if ((visited[i + 1][j] && visited[i - 1][j] && visited[i][j - 1] && visited[i][j + 1])) {\\n                        continue;\\n                    }\\n                    else{\\n                        grid[i][j] = color;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n   public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        if (grid == null || grid.length == 0) {\\n            return grid;\\n        }\\n        int val = grid[row][col];\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        dfs(grid, row, col, val, visited);\\n        fillGrid(grid, color, visited);\\n        return grid;\\n    }\\n\\n    public void dfs(int[][] grid, int row, int col, int val, boolean[][] visited) {\\n\\n        if (row >= grid.length || col >= grid[0].length || row < 0 || col < 0 || grid[row][col] != val || visited[row][col]) {\\n            return;\\n        }\\n\\n        //LURD\\n        if (grid[row][col] == val) {\\n            visited[row][col] = true;\\n            dfs(grid, row, col - 1, val, visited);\\n            dfs(grid, row + 1, col, val, visited);\\n            dfs(grid, row, col + 1, val, visited);\\n            dfs(grid, row - 1, col, val, visited);\\n        }\\n    }\\n\\n    public void fillGrid(int[][] grid, int color, boolean[][] visited) {\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n\\n                if (visited[i][j]) {\\n\\n                    //color boundary elements\\n                    if (i + 1 >= grid.length || j + 1 >= grid[0].length || i - 1 < 0 || j - 1 < 0) {\\n                        grid[i][j] = color;\\n                    }\\n                    //middle element\\n                    else if ((visited[i + 1][j] && visited[i - 1][j] && visited[i][j - 1] && visited[i][j + 1])) {\\n                        continue;\\n                    }\\n                    else{\\n                        grid[i][j] = color;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602546,
                "title": "java-easy-and-clean-dfs-solution-1ms-runtime",
                "content": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        find(grid, row, col, grid[row][col]);\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n    \\n    public int[][] dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    public void find(int[][] grid, int r, int c, int toChange){\\n        grid[r][c] = -toChange;\\n        int count = 0;       \\n        for(int i = 0; i < 4; i++){\\n            int nr = r + dir[i][0];\\n            int nc = c + dir[i][1];         \\n            if(nr < 0 || nr == grid.length || nc < 0 || nc == grid[0].length || Math.abs(grid[nr][nc]) != toChange)\\n                continue;\\n            count++;\\n            if(grid[nr][nc] == toChange)\\n                find(grid, nr, nc, toChange);\\n        }        \\n        if(count == 4)\\n            grid[r][c] = toChange;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        find(grid, row, col, grid[row][col]);\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n    \\n    public int[][] dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    public void find(int[][] grid, int r, int c, int toChange){\\n        grid[r][c] = -toChange;\\n        int count = 0;       \\n        for(int i = 0; i < 4; i++){\\n            int nr = r + dir[i][0];\\n            int nc = c + dir[i][1];         \\n            if(nr < 0 || nr == grid.length || nc < 0 || nc == grid[0].length || Math.abs(grid[nr][nc]) != toChange)\\n                continue;\\n            count++;\\n            if(grid[nr][nc] == toChange)\\n                find(grid, nr, nc, toChange);\\n        }        \\n        if(count == 4)\\n            grid[r][c] = toChange;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563141,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>>&grid,int row,int col,int &s,vector<pair<int,int>>&indexes,vector<vector<bool>>&visited){\\n        if(row<0 or col<0 or row>=grid.size() or col>=grid[0].size() or grid[row][col]!=s )return false;\\n        if(visited[row][col])return true;\\n        visited[row][col]=true;\\n        bool a=dfs(grid,row+1,col,s,indexes,visited);\\n        bool b=dfs(grid,row,col+1,s,indexes,visited);\\n        bool c=dfs(grid,row-1,col,s,indexes,visited);\\n        bool d=dfs(grid,row,col-1,s,indexes,visited);\\n        if(!(a and b and c and d))v.push_back(make_pair(row,col));\\n        return true;\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int s=grid[row][col];\\n        vector<pair<int,int>>indexes;    // storing border indexes\\n        vector<vector<bool>>visited(grid.size(),vector<bool>(grid[0].size(),0)); // checking for visited nodes\\n        if(s!=color)dfs(grid,row,col,s,indexes,visited);\\n        for(int i=0;i<v.size();i++){\\n            grid[v[i].first][v[i].second]=color;\\n        }\\n        return grid;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    bool dfs(vector<vector<int>>&grid,int row,int col,int &s,vector<pair<int,int>>&indexes,vector<vector<bool>>&visited){\\n        if(row<0 or col<0 or row>=grid.size() or col>=grid[0].size() or grid[row][col]!=s )return false;\\n        if(visited[row][col])return true;\\n        visited[row][col]=true;\\n        bool a=dfs(grid,row+1,col,s,indexes,visited);\\n        bool b=dfs(grid,row,col+1,s,indexes,visited);\\n        bool c=dfs(grid,row-1,col,s,indexes,visited);\\n        bool d=dfs(grid,row,col-1,s,indexes,visited);\\n        if(!(a and b and c and d))v.push_back(make_pair(row,col));\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1501918,
                "title": "c-bfs-solution",
                "content": "\\n\\'\\'\\'\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        vector<vector<int>> res = grid;\\n        vector<pair<int, int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        set<pair<int, int>> visited;\\n        queue<pair<int, int>> q;\\n        q.push({r0, c0});\\n        visited.insert({r0, c0});\\n        int val = grid[r0][c0];\\n        \\n        while (!q.empty()) {\\n            pair<int, int> cur = q.front();\\n            q.pop();\\n            int notConnected = 0;\\n            for (auto dir : dirs) {\\n                int x = cur.first + dir.first;\\n                int y = cur.second + dir.second;\\n                // check the new point is valid\\n                if (x>=0 && x<grid.size() && y>=0 && y<grid[0].size() && visited.count({x,y})==0) {\\n                    if (grid[x][y] == val) {\\n                        q.push({x, y});\\n                        visited.insert({x, y});\\n                    } else {\\n                        ++notConnected;\\n                    }\\n                } else if (x<0 || x>=grid.size() || y<0 || y>=grid[0].size()) {\\n                    ++notConnected;\\n                }\\n            }\\n            // check if this point is a border or not, if yes, color it !\\n            if (notConnected > 0) res[cur.first][cur.second] = color;\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\n\\'\\'\\'\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        vector<vector<int>> res = grid;\\n        vector<pair<int, int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        set<pair<int, int>> visited;\\n        queue<pair<int, int>> q;\\n        q.push({r0, c0});\\n        visited.insert({r0, c0});\\n        int val = grid[r0][c0];\\n        \\n        while (!q.empty()) {\\n            pair<int, int> cur = q.front();\\n            q.pop();\\n            int notConnected = 0;\\n            for (auto dir : dirs) {\\n                int x = cur.first + dir.first;\\n                int y = cur.second + dir.second;\\n                // check the new point is valid\\n                if (x>=0 && x<grid.size() && y>=0 && y<grid[0].size() && visited.count({x,y})==0) {\\n                    if (grid[x][y] == val) {\\n                        q.push({x, y});\\n                        visited.insert({x, y});\\n                    } else {\\n                        ++notConnected;\\n                    }\\n                } else if (x<0 || x>=grid.size() || y<0 || y>=grid[0].size()) {\\n                    ++notConnected;\\n                }\\n            }\\n            // check if this point is a border or not, if yes, color it !\\n            if (notConnected > 0) res[cur.first][cur.second] = color;\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1468590,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        rows,cols=len(grid),len(grid[0])\\n        g=[x.copy() for x in grid]#Create a copy of grid\\n        def dfs(i,j,n,visit):\\n            cnt=0\\n            for nei in [(i-1,j),(i,j+1),(i+1,j),(i,j-1)]:#Iterate neighbours\\n                nx,ny=nei\\n                if 0<=nx<rows and 0<=ny<cols and grid[nx][ny]==n:\\n                    cnt+=1\\n                    if nei not in visit:\\n                        visit.append(nei)\\n                        dfs(nx,ny,n,visit)\\n            if cnt!=4:#If a neighbour is not at border cnt will be 4\\n                g[i][j]=color\\n        dfs(row,col,grid[row][col],[(row,col)])\\n        return g\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        rows,cols=len(grid),len(grid[0])\\n        g=[x.copy() for x in grid]#Create a copy of grid\\n        def dfs(i,j,n,visit):\\n            cnt=0\\n            for nei in [(i-1,j),(i,j+1),(i+1,j),(i,j-1)]:#Iterate neighbours\\n                nx,ny=nei\\n                if 0<=nx<rows and 0<=ny<cols and grid[nx][ny]==n:\\n                    cnt+=1\\n                    if nei not in visit:\\n                        visit.append(nei)\\n                        dfs(nx,ny,n,visit)\\n            if cnt!=4:#If a neighbour is not at border cnt will be 4\\n                g[i][j]=color\\n        dfs(row,col,grid[row][col],[(row,col)])\\n        return g\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375273,
                "title": "c-dfs-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&v,int i,int j,int c,int color,vector<vector<bool>>&vis)\\n    {\\n        if(i<0 || j<0 || i>=v.size() || j>=v[0].size() )\\n            return;\\n        if(v[i][j]!=color || vis[i][j])\\n            return;\\n        vis[i][j]=true;\\n        if(i==0 || j==0 || i==v.size()-1 || j==v[0].size()-1)\\n        {v[i][j]=c;}\\n        if(( i+1<v.size()&&v[i+1][j]!=color && !vis[i+1][j] ) || ( i-1>=0 &&v[i-1][j]!=color && !vis[i-1][j] ) || ( j+1<v[0].size() &&v[i][j+1]!=color && !vis[i][j+1]) || ( j-1>=0 &&v[i][j-1]!=color && !vis[i][j-1]))\\n        {v[i][j]=c;}\\n        \\n        dfs(v,i+1,j,c,color,vis);\\n         dfs(v,i-1,j,c,color,vis);\\n         dfs(v,i,j-1,c,color,vis);\\n         dfs(v,i,j+1,c,color,vis);\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<bool>>v(n,vector<bool>(m,false));\\n       \\n        dfs(grid,r0,c0,color,grid[r0][c0],v);\\n      \\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&v,int i,int j,int c,int color,vector<vector<bool>>&vis)\\n    {\\n        if(i<0 || j<0 || i>=v.size() || j>=v[0].size() )\\n            return;\\n        if(v[i][j]!=color || vis[i][j])\\n            return;\\n        vis[i][j]=true;\\n        if(i==0 || j==0 || i==v.size()-1 || j==v[0].size()-1)\\n        {v[i][j]=c;}\\n        if(( i+1<v.size()&&v[i+1][j]!=color && !vis[i+1][j] ) || ( i-1>=0 &&v[i-1][j]!=color && !vis[i-1][j] ) || ( j+1<v[0].size() &&v[i][j+1]!=color && !vis[i][j+1]) || ( j-1>=0 &&v[i][j-1]!=color && !vis[i][j-1]))\\n        {v[i][j]=c;}\\n        \\n        dfs(v,i+1,j,c,color,vis);\\n         dfs(v,i-1,j,c,color,vis);\\n         dfs(v,i,j-1,c,color,vis);\\n         dfs(v,i,j+1,c,color,vis);\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<bool>>v(n,vector<bool>(m,false));\\n       \\n        dfs(grid,r0,c0,color,grid[r0][c0],v);\\n      \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313469,
                "title": "java-dfs-simple-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    int[][] dir = {{1,0} ,{-1 , 0} , {0,1} , {0,-1}};\\n   public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int oldColor = grid[r0][c0];\\n\\n        if (oldColor == color)\\n            return grid;\\n\\n        boolean[][] vis = new boolean[n][m];\\n\\n        paint(grid, r0, c0, vis, color, oldColor);\\n\\n        return grid;\\n    }\\n    public void paint(int[][] grid, int r, int c, boolean[][] vis, int color, int oldColor) {\\n\\n        int count = 0;\\n\\n        grid[r][c] = color;\\n        vis[r][c] = true;\\n\\n        for (int d = 0; d < 4; d++) {\\n            int x = r + dir[d][0];\\n            int y = c + dir[d][1];\\n\\n            if (x >= 0 && y >= 0 && x < grid.length && y < grid[0].length) {\\n                if (grid[x][y] == oldColor) {\\n                    count++;\\n                    paint(grid, x, y, vis, color, oldColor);\\n                } else if (grid[x][y] == color) {\\n                    if (vis[x][y])\\n                        count++;\\n                }\\n            }\\n        }\\n        if (count == 4)\\n            grid[r][c] = oldColor;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dir = {{1,0} ,{-1 , 0} , {0,1} , {0,-1}};\\n   public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int oldColor = grid[r0][c0];\\n\\n        if (oldColor == color)\\n            return grid;\\n\\n        boolean[][] vis = new boolean[n][m];\\n\\n        paint(grid, r0, c0, vis, color, oldColor);\\n\\n        return grid;\\n    }\\n    public void paint(int[][] grid, int r, int c, boolean[][] vis, int color, int oldColor) {\\n\\n        int count = 0;\\n\\n        grid[r][c] = color;\\n        vis[r][c] = true;\\n\\n        for (int d = 0; d < 4; d++) {\\n            int x = r + dir[d][0];\\n            int y = c + dir[d][1];\\n\\n            if (x >= 0 && y >= 0 && x < grid.length && y < grid[0].length) {\\n                if (grid[x][y] == oldColor) {\\n                    count++;\\n                    paint(grid, x, y, vis, color, oldColor);\\n                } else if (grid[x][y] == color) {\\n                    if (vis[x][y])\\n                        count++;\\n                }\\n            }\\n        }\\n        if (count == 4)\\n            grid[r][c] = oldColor;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1305444,
                "title": "simple-dfs-java-100-faster",
                "content": "```\\nclass Solution {\\n     private int dfs(int i,int j,int[][] g,int ans,int val,int[][] v){\\n//check if it is out of boundary \\n         if(i<0||j<0||i>=g.length||j>=g[0].length){return -1;}\\n// if it is already visited(it means that it was part of same component)         \\n         if(v[i][j]==1){\\n            return 0;\\n        }\\n// if the value is not same as that of current component          \\n        if(g[i][j]!=val)return -1;\\n       \\n         v[i][j]=1;\\n        \\n        int v1=dfs(i+1,j,g,ans,val,v);\\n         int v2=dfs(i-1,j,g,ans,val,v);\\n        int v3=dfs(i,j+1,g,ans,val,v);\\n        int v4=dfs(i,j-1,g,ans,val,v);\\n        \\n         if(v1==0&&v2==0&&v3==0&&v4==0)return 0;\\n        \\n         \\n         \\n         g[i][j]=ans;\\n         return 0;\\n    }\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int[][] v=new int[grid.length][grid[0].length];\\n        dfs(r0,c0,grid,color,grid[r0][c0],v);\\n        return grid;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n     private int dfs(int i,int j,int[][] g,int ans,int val,int[][] v){\\n//check if it is out of boundary \\n         if(i<0||j<0||i>=g.length||j>=g[0].length){return -1;}",
                "codeTag": "Java"
            },
            {
                "id": 1256359,
                "title": "java-1ms-solution",
                "content": "```\\nclass Solution {\\n     int defaults = 0; \\n    int dir[][] = {{1, 0} , {-1 , 0} , {0 , 1} , { 0 , -1}}; \\n\\n    public void dfs(int[][] grid , int r ,int c , int color , boolean[][] visited)\\n    {\\n        int count = 0; \\n        visited[r][c] = true; \\n        grid[r][c] = color; \\n        for(int d = 0 ; d < 4 ; d++)\\n        {\\n            int x = r + dir[d][0]; //r =  1 + 1 = 2\\n            int y = c + dir[d][1]; //c =  1 + 0 = 1 \\n            if(x >= 0 && x < grid.length && y >= 0 && y < grid[0].length) //valid posiiton \\n            {\\n                if(visited[x][y] == true)\\n                   count++;     \\n                else\\n                {\\n                    if(grid[x][y] == defaults) //not visited and \\n                    {\\n                        count++;  \\n                        dfs(grid , x , y , color , visited); \\n                    }\\n                }\\n            }\\n            if(count == 4)\\n                grid[r][c] = defaults;  \\n        }\\n    }\\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int m = grid.length;\\n        int n = grid[0].length;  \\n        boolean[][] visited = new boolean[m][n];\\n        \\n        defaults = grid[r0][c0]; \\n        dfs(grid , r0 , c0, color , visited); \\n        return grid; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n     int defaults = 0; \\n    int dir[][] = {{1, 0} , {-1 , 0} , {0 , 1} , { 0 , -1}}; \\n\\n    public void dfs(int[][] grid , int r ,int c , int color , boolean[][] visited)\\n    {\\n        int count = 0; \\n        visited[r][c] = true; \\n        grid[r][c] = color; \\n        for(int d = 0 ; d < 4 ; d++)\\n        {\\n            int x = r + dir[d][0]; //r =  1 + 1 = 2\\n            int y = c + dir[d][1]; //c =  1 + 0 = 1 \\n            if(x >= 0 && x < grid.length && y >= 0 && y < grid[0].length) //valid posiiton \\n            {\\n                if(visited[x][y] == true)\\n                   count++;     \\n                else\\n                {\\n                    if(grid[x][y] == defaults) //not visited and \\n                    {\\n                        count++;  \\n                        dfs(grid , x , y , color , visited); \\n                    }\\n                }\\n            }\\n            if(count == 4)\\n                grid[r][c] = defaults;  \\n        }\\n    }\\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int m = grid.length;\\n        int n = grid[0].length;  \\n        boolean[][] visited = new boolean[m][n];\\n        \\n        defaults = grid[r0][c0]; \\n        dfs(grid , r0 , c0, color , visited); \\n        return grid; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238412,
                "title": "bfs-using-unordered-set-for-visited-coordinates",
                "content": "\\n        int dir[4][2] = { {-1, 0}, {0, -1}, {0, 1}, {1, 0}};\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        \\n        if(grid.size()==0 || grid[0].size()==0) return grid;\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n       \\n        int cl = grid[r0][c0];\\n       \\n        queue<int>que;\\n        que.push(r0*m+c0);\\n        unordered_set<int>vis;\\n        vis.insert(r0*m+c0);\\n          \\n        while(que.size()!=0){\\n            \\n            int t = que.front();\\n            que.pop();\\n            \\n            int r = t/m;\\n            int c = t%m;\\n                \\n           if (r == 0 || r == n - 1 || c == 0 || c == m - 1) { grid[r][c] = color; }\\n          \\n             \\n            for(int d=0;d<4;d++){\\n                int nr= r + dir[d][0];\\n                int nc= c + dir[d][1];\\n                if(nr>=0 && nr<n && nc>=0 && nc < m && !vis.count(nr*m+nc)){\\n                        if(grid[nr][nc]==cl){\\n                            vis.insert(nr*m+nc);\\n                            que.push(nr*m+nc);\\n                        }else{\\n                                grid[r][c]=color;\\n                             }\\n                        }\\n            \\n                    }\\n                \\n            }\\n        return grid;\\n    }",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "\\n        int dir[4][2] = { {-1, 0}, {0, -1}, {0, 1}, {1, 0}};\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        \\n        if(grid.size()==0 || grid[0].size()==0) return grid;\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n       \\n        int cl = grid[r0][c0];\\n       \\n        queue<int>que;\\n        que.push(r0*m+c0);\\n        unordered_set<int>vis;\\n        vis.insert(r0*m+c0);\\n          \\n        while(que.size()!=0){\\n            \\n            int t = que.front();\\n            que.pop();\\n            \\n            int r = t/m;\\n            int c = t%m;\\n                \\n           if (r == 0 || r == n - 1 || c == 0 || c == m - 1) { grid[r][c] = color; }\\n          \\n             \\n            for(int d=0;d<4;d++){\\n                int nr= r + dir[d][0];\\n                int nc= c + dir[d][1];\\n                if(nr>=0 && nr<n && nc>=0 && nc < m && !vis.count(nr*m+nc)){\\n                        if(grid[nr][nc]==cl){\\n                            vis.insert(nr*m+nc);\\n                            que.push(nr*m+nc);\\n                        }else{\\n                                grid[r][c]=color;\\n                             }\\n                        }\\n            \\n                    }\\n                \\n            }\\n        return grid;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1150961,
                "title": "java-0ms-runtime-100-faster",
                "content": "```\\nclass Solution {\\n    int[][] dir = {{0,1}, {1,0}, {0,-1}, {-1,0}};\\n    boolean[][] visited;\\n    \\n    private void dfs(int[][] grid, int r0, int c0, int origColor, int newColor, int n, int m) {       \\n\\n\\t\\tvisited[r0][c0] = true;\\n        for(int[] d: dir) {\\n            int x = r0 + d[0];\\n            int y = c0 + d[1];\\n            \\n\\t\\t\\t// if next cell is either boundary OR of diff color but not previously visited\\n            if(x>=n || x<0 || y>=m || y<0 || (!visited[x][y] && grid[x][y]!=origColor)) {\\n                grid[r0][c0] = newColor;\\n                continue;\\n            }\\n            \\n\\t\\t\\t// continue if previously visited\\n            if(visited[x][y])\\n                continue;\\n            \\n            dfs(grid, x, y, origColor, newColor, n, m);\\n        }\\n    }\\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        if(grid[r0][c0] == color)\\n            return grid;\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        visited = new boolean[n][m];\\n        \\n        dfs(grid, r0, c0, grid[r0][c0], color, n, m);\\n        return grid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dir = {{0,1}, {1,0}, {0,-1}, {-1,0}};\\n    boolean[][] visited;\\n    \\n    private void dfs(int[][] grid, int r0, int c0, int origColor, int newColor, int n, int m) {       \\n\\n\\t\\tvisited[r0][c0] = true;\\n        for(int[] d: dir) {\\n            int x = r0 + d[0];\\n            int y = c0 + d[1];\\n            \\n\\t\\t\\t// if next cell is either boundary OR of diff color but not previously visited\\n            if(x>=n || x<0 || y>=m || y<0 || (!visited[x][y] && grid[x][y]!=origColor)) {\\n                grid[r0][c0] = newColor;\\n                continue;\\n            }\\n            \\n\\t\\t\\t// continue if previously visited\\n            if(visited[x][y])\\n                continue;\\n            \\n            dfs(grid, x, y, origColor, newColor, n, m);\\n        }\\n    }\\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        if(grid[r0][c0] == color)\\n            return grid;\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        visited = new boolean[n][m];\\n        \\n        dfs(grid, r0, c0, grid[r0][c0], color, n, m);\\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791470,
                "title": "c-solution-using-dfs-faster-than-99-39-with-explanation",
                "content": "The approach is simple DFS that finds the **connected** component from *r0, c0*. In addition, we need to color the boundary of the connected component with the given *color*.\\n\\nA **boundary** of a connected component is defined as the boxes which are **surrounded 4-directonally by atleast one box that has a different color** other than that of connected component. Consider an example below to understand the boundary, *r0* = 1, *c0* = 1, *color* = 3.\\n\\n![image](https://assets.leetcode.com/users/images/eb05a688-bbbd-41e9-90c6-d4eb4c5bf3f3_1597411149.5754387.png)\\n\\n**Marking Boundary in DFS**\\nUse a variable to keep track of count of same boxes present in 4-directions. Let it be *same*. It is incremented in two cases:\\n1. If a box is already visited, then it must be a part of the connected component.\\n2. When making recursive call for unvisited part of the connected component.\\n\\nIf *same* is less than 4 for a box, change its color to the given *color* as it is the part of the boundary. \\n```\\nclass Solution {\\npublic:\\n    int xDir[4] = {1, 0, -1, 0};\\n    int yDir[4] = {0, 1, 0, -1};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, bool **visited, int color) {\\n        visited[r][c] = true;\\n        \\n\\t\\t// variable to keep track of count of same boxes in 4-directions\\n        int same = 0;\\n        \\n\\t\\t// checking 4-directionally\\n        for(int k = 0; k < 4; k++) {\\n            int i = r + xDir[k], j = c + yDir[k];\\n              \\n            if(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size())\\n                continue;\\n            \\n\\t\\t\\t// if visited, it must a part of the connected component\\n            if(visited[i][j]) {\\n                same++;\\n                continue;\\n            }\\n            \\n\\t\\t\\t// recursive call for unvisited part of the connected component\\n            if(grid[i][j] == grid[r][c]) {\\n                dfs(i, j, grid, visited, color);\\n                same++;\\n            }\\n        }\\n        \\n\\t\\t// if it is the part of the boundary\\n        if(same < 4)\\n            grid[r][c] = color;\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        bool **visited;\\n        visited = new bool*[grid.size()];\\n        \\n        for(int i = 0; i < grid.size(); i++) {\\n            visited[i] = new bool[grid[0].size()];\\n            \\n            for(int j = 0; j < grid[0].size(); j++)\\n                visited[i][j] = false;\\n        }\\n        \\n        dfs(r0, c0, grid, visited, color);\\n        \\n        return grid;\\n    }\\n};\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int xDir[4] = {1, 0, -1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 777088,
                "title": "python-dfs",
                "content": "```\\ndef colorBorder(self, grid, r0, c0, color):\\n        m, n = len(grid), len(grid[0])\\n        visited = [[False for _ in xrange(n)] for _ in xrange(m)]\\n        def check(x, y):\\n            return 0 <= x < m and 0 <= y < n\\n        def findBorder(i, j):\\n            visited[i][j] = True\\n            flag = False\\n            for x, y in (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1):\\n                if check(x, y) and not visited[x][y] and grid[x][y] == grid[i][j]:\\n                    findBorder(x, y)\\n                if check(x, y) and not visited[x][y] and grid[i][j] != grid[x][y]:\\n                    flag = True\\n            if i == 0 or j == 0 or i == m - 1 or j == n - 1 or flag:\\n                grid[i][j] = color\\n        findBorder(r0, c0)\\n        return grid\\n```",
                "solutionTags": [],
                "code": "```\\ndef colorBorder(self, grid, r0, c0, color):\\n        m, n = len(grid), len(grid[0])\\n        visited = [[False for _ in xrange(n)] for _ in xrange(m)]\\n        def check(x, y):\\n            return 0 <= x < m and 0 <= y < n\\n        def findBorder(i, j):\\n            visited[i][j] = True\\n            flag = False\\n            for x, y in (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1):\\n                if check(x, y) and not visited[x][y] and grid[x][y] == grid[i][j]:\\n                    findBorder(x, y)\\n                if check(x, y) and not visited[x][y] and grid[i][j] != grid[x][y]:\\n                    flag = True\\n            if i == 0 or j == 0 or i == m - 1 or j == n - 1 or flag:\\n                grid[i][j] = color\\n        findBorder(r0, c0)\\n        return grid\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 768427,
                "title": "intuitive-dfs-sol-python3",
                "content": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n\\n        if not grid or not grid[0]:\\n            return\\n\\n        n = len(grid)\\n        m = len(grid[0])\\n\\n        self.start_color = grid[r0][c0]\\n        self.seen = [[False] * m for i in range(n)]\\n\\n        dr = [-1, 0, 1, 0]\\n        dc = [0, 1, 0, -1]\\n\\n        def dfs(i, j):\\n            if i < 0 or j < 0 or i >= n or j >= m or self.seen[i][j]:\\n                return\\n\\n            if grid[i][j] != self.start_color:\\n                return True\\n\\t\\t\\t\\t\\n            self.seen[i][j] = True\\n\\n            if i == 0 or j == 0 or i == n - 1 or j == m - 1:\\n                grid[i][j] = color\\n\\n            for d in range(4):\\n\\n                if dfs(i + dr[d], j + dc[d]):\\n                    grid[i][j] = color\\n\\n        dfs(r0, c0)\\n\\n        return grid\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n\\n        if not grid or not grid[0]:\\n            return\\n\\n        n = len(grid)\\n        m = len(grid[0])\\n\\n        self.start_color = grid[r0][c0]\\n        self.seen = [[False] * m for i in range(n)]\\n\\n        dr = [-1, 0, 1, 0]\\n        dc = [0, 1, 0, -1]\\n\\n        def dfs(i, j):\\n            if i < 0 or j < 0 or i >= n or j >= m or self.seen[i][j]:\\n                return\\n\\n            if grid[i][j] != self.start_color:\\n                return True\\n\\t\\t\\t\\t\\n            self.seen[i][j] = True\\n\\n            if i == 0 or j == 0 or i == n - 1 or j == m - 1:\\n                grid[i][j] = color\\n\\n            for d in range(4):\\n\\n                if dfs(i + dr[d], j + dc[d]):\\n                    grid[i][j] = color\\n\\n        dfs(r0, c0)\\n\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683364,
                "title": "c-dfs-solution",
                "content": "```\\nclass Solution {\\n    int r = 0, c = 0;\\n    vector<vector<bool>>visited;\\n    vector<vector<int>>res;\\n    \\n    bool dfs(vector<vector<int>>& grid, int i, int j, int color, int color0) {\\n        if (i < 0 || j < 0 || i >= r || j >= c || grid[i][j] != color0)\\n            return true;\\n\\n        if (visited[i][j])\\n            return grid[i][j] != color0;\\n        \\n        visited[i][j] = true;\\n        if (dfs(grid, i+1, j, color, color0))\\n            res[i][j] = color;\\n        if (dfs(grid, i-1, j, color, color0))\\n            res[i][j] = color;\\n        if (dfs(grid, i, j+1, color, color0))\\n            res[i][j] = color;\\n        if (dfs(grid, i, j-1, color, color0))\\n            res[i][j] = color;\\n\\n        return false;\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        \\n        r = grid.size();\\n        c = grid[0].size();\\n        \\n        int color0 = grid[r0][c0];\\n        visited.resize(r, vector<bool>(c, false));\\n        res = grid;\\n        \\n        dfs(grid, r0, c0, color, color0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int r = 0, c = 0;\\n    vector<vector<bool>>visited;\\n    vector<vector<int>>res;\\n    \\n    bool dfs(vector<vector<int>>& grid, int i, int j, int color, int color0) {\\n        if (i < 0 || j < 0 || i >= r || j >= c || grid[i][j] != color0)\\n            return true;\\n\\n        if (visited[i][j])\\n            return grid[i][j] != color0;\\n        \\n        visited[i][j] = true;\\n        if (dfs(grid, i+1, j, color, color0))\\n            res[i][j] = color;\\n        if (dfs(grid, i-1, j, color, color0))\\n            res[i][j] = color;\\n        if (dfs(grid, i, j+1, color, color0))\\n            res[i][j] = color;\\n        if (dfs(grid, i, j-1, color, color0))\\n            res[i][j] = color;\\n\\n        return false;\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        \\n        r = grid.size();\\n        c = grid[0].size();\\n        \\n        int color0 = grid[r0][c0];\\n        visited.resize(r, vector<bool>(c, false));\\n        res = grid;\\n        \\n        dfs(grid, r0, c0, color, color0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 680918,
                "title": "c-bfs-solution",
                "content": "Space Complexity: O(min(n,m)) where m and n are the number of rows, columns on the grid\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> dirs = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n    vector<vector<int>> colorBorder(vector<vector<int>>& A, int r0, int c0, int color) {\\n        int r = A.size();\\n        if(r==0) return vector<vector<int>>();\\n        int c = A[0].size();\\n        vector<vector<int>>  visited =  vector<vector<int>> (r, vector<int> (c, 2)); // white\\n        queue<pair<int,int>> q;\\n        q.push({r0, c0});\\n        visited[r0][c0] = 1;\\n        set<pair<int,int>> border;\\n        while(!q.empty()){\\n            auto u = q.front(); q.pop();\\n            int x = u.first, y = u.second;\\n            // cout<<\"Popped: \"<<x<<\" \"<<y<<endl;\\n            for(auto d: dirs){\\n                int i = x + d.first;\\n                int j = y + d.second;\\n                if(i>=0 && i<r && j>=0 && j<c && A[i][j]==A[x][y]){\\n                    if(visited[i][j]==2){\\n                        // cout<<\"pushing \"<<i<<\" \"<<j<<\" color: \"<<A[i][j]<<endl;\\n                        q.push({i,j});\\n                        visited[i][j] = 1;\\n                    }\\n                }\\n                else{\\n                    // cout<<\"Border: \"<<x<<\" \"<<y<<endl;\\n                    border.insert({x,y});\\n                }\\n            }\\n            visited[x][y] = 0;\\n        }\\n        for(auto s: border){\\n            A[s.first][s.second] = color;\\n        }\\n        return A;\\n    }\\n};\\n\\n\\n//  1    1   1\\n//  1   (1)  1  --> this one is surrounded by elements of same color and is not on border- should not be colored\\n//  1    1   1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> dirs = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n    vector<vector<int>> colorBorder(vector<vector<int>>& A, int r0, int c0, int color) {\\n        int r = A.size();\\n        if(r==0) return vector<vector<int>>();\\n        int c = A[0].size();\\n        vector<vector<int>>  visited =  vector<vector<int>> (r, vector<int> (c, 2)); // white\\n        queue<pair<int,int>> q;\\n        q.push({r0, c0});\\n        visited[r0][c0] = 1;\\n        set<pair<int,int>> border;\\n        while(!q.empty()){\\n            auto u = q.front(); q.pop();\\n            int x = u.first, y = u.second;\\n            // cout<<\"Popped: \"<<x<<\" \"<<y<<endl;\\n            for(auto d: dirs){\\n                int i = x + d.first;\\n                int j = y + d.second;\\n                if(i>=0 && i<r && j>=0 && j<c && A[i][j]==A[x][y]){\\n                    if(visited[i][j]==2){\\n                        // cout<<\"pushing \"<<i<<\" \"<<j<<\" color: \"<<A[i][j]<<endl;\\n                        q.push({i,j});\\n                        visited[i][j] = 1;\\n                    }\\n                }\\n                else{\\n                    // cout<<\"Border: \"<<x<<\" \"<<y<<endl;\\n                    border.insert({x,y});\\n                }\\n            }\\n            visited[x][y] = 0;\\n        }\\n        for(auto s: border){\\n            A[s.first][s.second] = color;\\n        }\\n        return A;\\n    }\\n};\\n\\n\\n//  1    1   1\\n//  1   (1)  1  --> this one is surrounded by elements of same color and is not on border- should not be colored\\n//  1    1   1\\n```",
                "codeTag": "C++"
            },
            {
                "id": 645798,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<bool>> visited;\\n    vector<vector<int>> copy;\\n    int r, c, original;\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        r = grid.size();\\n        c = grid[0].size();\\n        original = grid[r0][c0];\\n        copy = grid;\\n        visited = vector<vector<bool>>(r, vector<bool>(c, false));\\n        visit(grid, color, r0, c0);\\n        return copy;\\n    }\\n    \\n    void visit(vector<vector<int>>& grid, int color, int x, int y){\\n        visited[x][y] = true;\\n        if (x==0 || grid[x-1][y]!=original){\\n            copy[x][y] = color;\\n        }else if (!visited[x-1][y]){\\n            visit(grid, color, x-1, y);\\n        }\\n        if (x==r-1 || grid[x+1][y]!=original){\\n            copy[x][y] = color;\\n        }else if (!visited[x+1][y]){\\n            visit(grid, color, x+1, y);\\n        }\\n        if (y==0 || grid[x][y-1]!=original){\\n            copy[x][y] = color;\\n        }else if (!visited[x][y-1]){\\n            visit(grid, color, x, y-1);\\n        }\\n        if (y==c-1 || grid[x][y+1]!=original){\\n            copy[x][y] = color;\\n        }else if (!visited[x][y+1]){\\n            visit(grid, color, x, y+1);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<bool>> visited;\\n    vector<vector<int>> copy;\\n    int r, c, original;\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        r = grid.size();\\n        c = grid[0].size();\\n        original = grid[r0][c0];\\n        copy = grid;\\n        visited = vector<vector<bool>>(r, vector<bool>(c, false));\\n        visit(grid, color, r0, c0);\\n        return copy;\\n    }\\n    \\n    void visit(vector<vector<int>>& grid, int color, int x, int y){\\n        visited[x][y] = true;\\n        if (x==0 || grid[x-1][y]!=original){\\n            copy[x][y] = color;\\n        }else if (!visited[x-1][y]){\\n            visit(grid, color, x-1, y);\\n        }\\n        if (x==r-1 || grid[x+1][y]!=original){\\n            copy[x][y] = color;\\n        }else if (!visited[x+1][y]){\\n            visit(grid, color, x+1, y);\\n        }\\n        if (y==0 || grid[x][y-1]!=original){\\n            copy[x][y] = color;\\n        }else if (!visited[x][y-1]){\\n            visit(grid, color, x, y-1);\\n        }\\n        if (y==c-1 || grid[x][y+1]!=original){\\n            copy[x][y] = color;\\n        }else if (!visited[x][y+1]){\\n            visit(grid, color, x, y+1);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545883,
                "title": "c-solution-simple-dfs-approach-easy-to-understand",
                "content": "class Solution {\\npublic:\\n        \\n    vector<vector<int>> borders ;\\n    void dfs(int i, int j, int color, int color_base, vector<vector<int>>& grid, vector<vector<bool>>& visited)\\n    {   \\n        if (i<0||j<0||i>=grid.size()||j>=grid[0].size())\\n            return ;\\n        if (grid[i][j]!=color_base)\\n            return ;\\n        if (visited[i][j]==true)\\n            return ;\\n                \\n        // condition (on the border)\\n        bool condition1 = (i*j==0 || i==grid.size()-1 || j==grid[0].size()-1) ;\\n                \\n        // condition (element has a 4 directional adjacent element not in the component)\\n        bool condition3 = (!condition1 && (grid[i+1][j]!=color_base||grid[i-1][j]!=color_base||grid[i][j+1]!=color_base||grid[i][j-1]!=color_base)) ; \\n                \\n        if (condition1 || condition3)\\n            borders.push_back({i,j});\\n        \\n        visited[i][j] = true ;\\n        dfs(i+1,j,color,color_base,grid,visited) ;\\n        dfs(i-1,j,color,color_base,grid,visited) ;\\n        dfs(i,j+1,color,color_base,grid,visited) ;\\n        dfs(i,j-1,color,color_base,grid,visited) ;\\n        \\n        return ;\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        \\n        int m = grid.size() ;\\n        int n = grid[0].size() ;\\n        vector<vector<bool>> visited (m, vector<bool>(n, false)) ;\\n        dfs(r0, c0, color, grid[r0][c0], grid, visited) ;\\n        \\n        for (auto x : borders)\\n            grid[x[0]][x[1]] = color ;\\n         \\n        return grid ;    \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n        \\n    vector<vector<int>> borders ;\\n    void dfs(int i, int j, int color, int color_base, vector<vector<int>>& grid, vector<vector<bool>>& visited)\\n    {   \\n        if (i<0||j<0||i>=grid.size()||j>=grid[0].size())\\n            return ;\\n        if (grid[i][j]!=color_base)\\n            return ;\\n        if (visited[i][j]==true)\\n            return ;\\n                \\n        // condition (on the border)\\n        bool condition1 = (i*j==0 || i==grid.size()-1 || j==grid[0].size()-1) ;\\n                \\n        // condition (element has a 4 directional adjacent element not in the component)\\n        bool condition3 = (!condition1 && (grid[i+1][j]!=color_base||grid[i-1][j]!=color_base||grid[i][j+1]!=color_base||grid[i][j-1]!=color_base)) ; \\n                \\n        if (condition1 || condition3)\\n            borders.push_back({i,j}",
                "codeTag": "Java"
            },
            {
                "id": 403401,
                "title": "python-dfs-inside-of-the-connected-component-checking-if-current-node-is-on-the-border",
                "content": "```python\\ndef colorBorder(self, grid, r0, c0, color):\\n\\t# True if node (i, j) is inside of the connected component.\\n\\tdef inside_cc(i, j):   \\n\\t\\t# Note: Only nodes inside of the connected component are added to \"visited\".\\n\\t\\tif (i, j) in visited: return True\\n\\t\\telif 0<=i<len(grid) and 0<=j<len(grid[0]) and grid[i][j]==cc_color:\\n\\t\\t\\tvisited.add((i, j))\\n\\t\\t\\tneighbors = [(i+1, j), (i-1, j), (i, j-1), (i, j+1)]\\n\\t\\t\\t# If one of the neighbors is not inside of cc, then node (i, j) is a border node.\\n\\t\\t\\tif any([not inside_cc(x, y) for x, y in neighbors]):\\n\\t\\t\\t\\tgrid[i][j] = color\\n\\t\\t\\treturn True\\n\\t\\telse: return False\\n\\tcc_color = grid[r0][c0]\\n\\tvisited = set()\\n\\tinside_cc(r0,c0)\\n\\treturn grid  \\n```",
                "solutionTags": [],
                "code": "```python\\ndef colorBorder(self, grid, r0, c0, color):\\n\\t# True if node (i, j) is inside of the connected component.\\n\\tdef inside_cc(i, j):   \\n\\t\\t# Note: Only nodes inside of the connected component are added to \"visited\".\\n\\t\\tif (i, j) in visited: return True\\n\\t\\telif 0<=i<len(grid) and 0<=j<len(grid[0]) and grid[i][j]==cc_color:\\n\\t\\t\\tvisited.add((i, j))\\n\\t\\t\\tneighbors = [(i+1, j), (i-1, j), (i, j-1), (i, j+1)]\\n\\t\\t\\t# If one of the neighbors is not inside of cc, then node (i, j) is a border node.\\n\\t\\t\\tif any([not inside_cc(x, y) for x, y in neighbors]):\\n\\t\\t\\t\\tgrid[i][j] = color\\n\\t\\t\\treturn True\\n\\t\\telse: return False\\n\\tcc_color = grid[r0][c0]\\n\\tvisited = set()\\n\\tinside_cc(r0,c0)\\n\\treturn grid  \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 395693,
                "title": "javascript-dfs-solution",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @param {number} r0\\n * @param {number} c0\\n * @param {number} color\\n * @return {number[][]}\\n */\\nconst colorBorder = function(grid, r0, c0, color) {\\n   if (grid[r0][c0] === color) { return grid; }\\n    \\n    const visited = new Array(grid.length).fill(0).map( row => {\\n        return new Array(grid[0].length).fill(false);\\n    })\\n    \\n    dfs(grid, visited, grid[r0][c0], r0, c0, color);\\n        \\n    return grid;\\n};\\n\\nconst dfs = function(grid, visited, prevVal, r, c, color){\\n    /*  Order here matters  */\\n    if ( r < 0 || c < 0 || r === grid.length ||  c === grid[0].length) { return -1; }\\n\\n    if (visited[r][c]) { return color; }\\n    \\n    if(grid[r][c] !== prevVal) { return -1; }\\n    \\n    \\n    visited[r][c] = true;\\n    const v1 = dfs(grid, visited, grid[r][c], r+1, c, color);\\n    const v2 = dfs(grid, visited, grid[r][c], r-1, c, color);\\n    const v3 = dfs(grid, visited, grid[r][c], r, c+1, color);\\n    const v4 = dfs(grid, visited, grid[r][c], r, c-1, color);\\n\\n    if( ![v1, v2, v3, v4].every( val => ( val === color || val === prevVal))){\\n        grid[r][c] = color;\\n    }\\n\\n    return grid[r][c];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @param {number} r0\\n * @param {number} c0\\n * @param {number} color\\n * @return {number[][]}\\n */\\nconst colorBorder = function(grid, r0, c0, color) {\\n   if (grid[r0][c0] === color) { return grid; }\\n    \\n    const visited = new Array(grid.length).fill(0).map( row => {\\n        return new Array(grid[0].length).fill(false);\\n    })\\n    \\n    dfs(grid, visited, grid[r0][c0], r0, c0, color);\\n        \\n    return grid;\\n};\\n\\nconst dfs = function(grid, visited, prevVal, r, c, color){\\n    /*  Order here matters  */\\n    if ( r < 0 || c < 0 || r === grid.length ||  c === grid[0].length) { return -1; }\\n\\n    if (visited[r][c]) { return color; }\\n    \\n    if(grid[r][c] !== prevVal) { return -1; }\\n    \\n    \\n    visited[r][c] = true;\\n    const v1 = dfs(grid, visited, grid[r][c], r+1, c, color);\\n    const v2 = dfs(grid, visited, grid[r][c], r-1, c, color);\\n    const v3 = dfs(grid, visited, grid[r][c], r, c+1, color);\\n    const v4 = dfs(grid, visited, grid[r][c], r, c-1, color);\\n\\n    if( ![v1, v2, v3, v4].every( val => ( val === color || val === prevVal))){\\n        grid[r][c] = color;\\n    }\\n\\n    return grid[r][c];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 328475,
                "title": "java-dfs-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\n    int[][] dir = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        \\n        if (grid.length == 0 || grid[0].length == 0) return grid;    \\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        dfs(grid, r0, c0, m, n, color, grid[r0][c0], new boolean[m][n]);\\n        \\n        return grid;\\n    }\\n    \\n    private void dfs(int[][] grid, int i, int j, int m, int n, int color, int ic, boolean[][] visited) {\\n        \\n        if (i < 0 || j < 0 || i == m || j == n || visited[i][j] || grid[i][j] != ic) return;\\n        \\n        if (changeColor(grid, i, j, m, n, ic, visited)) {\\n            grid[i][j] = color;    \\n        } \\n        \\n        visited[i][j] = true;\\n        \\n        for (int[] d : dir) {\\n            int x = i + d[0];\\n            int y = j + d[1];\\n            \\n            dfs(grid, x, y, m, n, color, ic, visited);\\n        }\\n    }\\n    \\n    private boolean changeColor(int[][] grid, int i, int j, int m, int n, int ic, boolean[][] visited) {\\n        \\n        if (i == 0 || j == 0 || i+1 == m || j+1 == n) return true;\\n        \\n        int borders = 4;\\n        for (int[] d : dir) {\\n            int x = i + d[0];\\n            int y = j + d[1];\\n        \\n            if (visited[x][y] || grid[x][y] == ic) {\\n                borders--;    \\n            }\\n        }\\n        \\n        return borders > 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int[][] dir = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        \\n        if (grid.length == 0 || grid[0].length == 0) return grid;    \\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        dfs(grid, r0, c0, m, n, color, grid[r0][c0], new boolean[m][n]);\\n        \\n        return grid;\\n    }\\n    \\n    private void dfs(int[][] grid, int i, int j, int m, int n, int color, int ic, boolean[][] visited) {\\n        \\n        if (i < 0 || j < 0 || i == m || j == n || visited[i][j] || grid[i][j] != ic) return;\\n        \\n        if (changeColor(grid, i, j, m, n, ic, visited)) {\\n            grid[i][j] = color;    \\n        } \\n        \\n        visited[i][j] = true;\\n        \\n        for (int[] d : dir) {\\n            int x = i + d[0];\\n            int y = j + d[1];\\n            \\n            dfs(grid, x, y, m, n, color, ic, visited);\\n        }\\n    }\\n    \\n    private boolean changeColor(int[][] grid, int i, int j, int m, int n, int ic, boolean[][] visited) {\\n        \\n        if (i == 0 || j == 0 || i+1 == m || j+1 == n) return true;\\n        \\n        int borders = 4;\\n        for (int[] d : dir) {\\n            int x = i + d[0];\\n            int y = j + d[1];\\n        \\n            if (visited[x][y] || grid[x][y] == ic) {\\n                borders--;    \\n            }\\n        }\\n        \\n        return borders > 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 284393,
                "title": "java-dfs-short-1ms-solution",
                "content": "```\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int m = grid.length, n = grid[0].length, oldColor = grid[r0][c0];\\n        boolean[][] visited = new boolean[m][n];\\n        dfs(grid, r0, c0, m, n, oldColor, color, visited);\\n        for (int i = 1; i < m - 1; i++) {\\n            for (int j = 1; j < n - 1; j++) {\\n                if (visited[i][j] && visited[i - 1][j] && visited[i + 1][j] && visited[i][j + 1] && visited[i][j - 1]) {\\n                    grid[i][j] = oldColor;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    private void dfs(int[][] grid, int i, int j, int m, int n, int oldColor, int color, boolean[][] visited) {\\n        if (i < 0 || i >= m || j < 0 || j >= n || visited[i][j] || grid[i][j] != oldColor) return;\\n        visited[i][j] = true;\\n        grid[i][j] = color;\\n        dfs(grid, i + 1, j, m, n, oldColor, color, visited);\\n        dfs(grid, i - 1, j, m, n, oldColor, color, visited);\\n        dfs(grid, i, j + 1, m, n, oldColor, color, visited);\\n        dfs(grid, i, j - 1, m, n, oldColor, color, visited);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int m = grid.length, n = grid[0].length, oldColor = grid[r0][c0];\\n        boolean[][] visited = new boolean[m][n];\\n        dfs(grid, r0, c0, m, n, oldColor, color, visited);\\n        for (int i = 1; i < m - 1; i++) {\\n            for (int j = 1; j < n - 1; j++) {\\n                if (visited[i][j] && visited[i - 1][j] && visited[i + 1][j] && visited[i][j + 1] && visited[i][j - 1]) {\\n                    grid[i][j] = oldColor;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    private void dfs(int[][] grid, int i, int j, int m, int n, int oldColor, int color, boolean[][] visited) {\\n        if (i < 0 || i >= m || j < 0 || j >= n || visited[i][j] || grid[i][j] != oldColor) return;\\n        visited[i][j] = true;\\n        grid[i][j] = color;\\n        dfs(grid, i + 1, j, m, n, oldColor, color, visited);\\n        dfs(grid, i - 1, j, m, n, oldColor, color, visited);\\n        dfs(grid, i, j + 1, m, n, oldColor, color, visited);\\n        dfs(grid, i, j - 1, m, n, oldColor, color, visited);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 283806,
                "title": "java-short-and-simple-dfs-with-explaination",
                "content": "Recursion rule: It will enter the next level of recursion only if current point is not a border. \\nEach time we check 4 directions, say next point:\\n* If current point is a border, we would change current point\\'s color and not enter the recursion with this next point, since it already reaches the border. \\n* If not, we do not change current color and enter the next level of recursion.\\n\\nSo we do not need to test the boundary in the base case, we only test whether it is visted.\\n\\nNoted, when test it is a border:\\nOther than the next point is out of boundary, it also may be an inner point.\\nIf the next point\\'s color is not the original color, we also need to test wehter we have visited before. Because it may be an inner point so that we didn\\'t change its color.\\n\\n```\\nclass Solution {\\n    private static final int[][] dir = { {-1,0}, {1,0}, {0,-1}, {0,1} };\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        colorBorder(grid, r0, c0, grid[r0][c0], color, visited);\\n        return grid;\\n    }\\n    private void colorBorder(int[][] grid, int r, int c, int orig, int color, boolean[][] visited) {\\n        if (visited[r][c]) return;\\n        visited[r][c] = true;\\n        for (int[] d : dir) {\\n            int nr = r + d[0], nc = c + d[1]; // next point\\n            if (nr < 0 || nr == grid.length || nc < 0 || nc == grid[0].length || (grid[nr][nc] != orig && !visited[nr][nc])) {\\n\\t\\t\\t// update current color since either the next point is out of boundary or the next point\\'s color is different and we did not visit it before.\\n                grid[r][c] = color; \\n                continue; // not enter the recursion and go next direction.\\n            }\\n            colorBorder(grid, nr, nc, orig, color, visited);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int[][] dir = { {-1,0}, {1,0}, {0,-1}, {0,1} };\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        colorBorder(grid, r0, c0, grid[r0][c0], color, visited);\\n        return grid;\\n    }\\n    private void colorBorder(int[][] grid, int r, int c, int orig, int color, boolean[][] visited) {\\n        if (visited[r][c]) return;\\n        visited[r][c] = true;\\n        for (int[] d : dir) {\\n            int nr = r + d[0], nc = c + d[1]; // next point\\n            if (nr < 0 || nr == grid.length || nc < 0 || nc == grid[0].length || (grid[nr][nc] != orig && !visited[nr][nc])) {\\n\\t\\t\\t// update current color since either the next point is out of boundary or the next point\\'s color is different and we did not visit it before.\\n                grid[r][c] = color; \\n                continue; // not enter the recursion and go next direction.\\n            }\\n            colorBorder(grid, nr, nc, orig, color, visited);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283054,
                "title": "python",
                "content": "\\u54CE\\u3002\\u3002\\u3002\\u6211\\u5FC5\\u987B\\u5766\\u767D\\u8FD9\\u4E2A\\u9898contest\\u7684\\u65F6\\u5019\\u6CA1\\u505A\\u51FA\\u6765\\uFF0C\\u4E0D\\u662F\\u56E0\\u4E3A\\u4E0D\\u4F1A\\uFF0C\\u800C\\u662F\\u6CA1\\u641E\\u6E05\\u695Aborder\\u7684\\u5B9A\\u4E49\\u88AB\\u5751\\u4E86\\uFF0C\\u7136\\u540E\\u5C31\\u4E00\\u76F4\\u8C03\\u4EE3\\u7801\\uFF0Cgg\\u3002\\u3002\\u3002\\n\\u8FD9\\u79CD\\u9898\\u7684\\u601D\\u8DEF\\u8FD8\\u662F\\u5F88\\u6E05\\u695A\\u7684\\uFF0C\\u5C31\\u662F\\u6F2B\\u6C34\\u7B97\\u6CD5\\uFF08floodfill\\uFF09\\uFF0C\\u6216\\u8005\\u8BF4\\u6DF1\\u5EA6\\u4F18\\u5148\\u641C\\u7D22\\u3002\\u6211\\u4EEC\\u53EF\\u4EE5\\u4ECE\\u7ED9\\u5B9A\\u7684\\u683C\\u70B9\\u5F00\\u59CBdfs\\uFF0C\\u5982\\u679C\\u53D1\\u73B0\\u5F53\\u524D\\u70B9\\u662Fborder\\uFF0C\\u5C31\\u67D3\\u8272\\u3002\\n\\u4F46\\u662F\\u8FD9\\u91CC\\u6709\\u51E0\\u4E2A\\u5751\\uFF1A\\n1. \\u9996\\u5148\\u662F\\u9898\\u76EE\\u5173\\u4E8Eborder\\u7684\\u63CF\\u8FF0\\uFF0C\\u90A3\\u4E2A```4-directionally adjacent```\\u7684\\u610F\\u601D\\u662F\\u53EA\\u8981\\u56DB\\u4E2A\\u90BB\\u5C45\\u91CC\\u9762\\u6709\\u4E00\\u4E2A\\u548C\\u5B83\\u989C\\u8272\\u4E0D\\u4E00\\u6837\\u5C31\\u662Fborder\\u4E86\\uFF0C\\u4E00\\u5F00\\u59CB\\u8FD8\\u4EE5\\u4E3A\\u662F4\\u4E2A\\u90BB\\u5C45\\u90FD\\u8981\\u548C\\u5B83\\u4E0D\\u4E00\\u6837\\u3002\\u3002\\u3002\\u545C\\u545C\\u545C\\n2. \\u5176\\u6B21\\uFF0C\\u6211\\u4EEC\\u4E0D\\u80FD\\u76F4\\u63A5\\u5BF9\\u539F\\u6570\\u7EC4\\u67D3\\u8272\\uFF0C\\u56E0\\u4E3A\\u8FB9dfs\\u8FB9\\u67D3\\u8272\\u53EF\\u80FD\\u5F71\\u54CD\\u5230\\u4E00\\u4E9B\\u8FD8\\u6CA1\\u6709\\u641C\\u7D22\\u5230\\u7684\\u683C\\u70B9\\u7684\\u6761\\u4EF6\\u5224\\u65AD\\uFF0C\\u4FDD\\u9669\\u7684\\u505A\\u6CD5\\u662F\\u7528\\u53E6\\u4E00\\u4E2A\\u4E8C\\u7EF4\\u6570\\u7EC4```should_color```\\u6765\\u6807\\u8BB0\\u67D0\\u4E2A\\u4F4D\\u7F6E\\u8981\\u4E0D\\u8981\\u67D3\\u8272\\n\\n\\u4EE3\\u7801\\uFF1A\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n        def is_border(grid, i, j):\\n\\t\\t\\t# \\u6570\\u7EC4\\u8FB9\\u754C\\n            if i == 0 or i == nr - 1 or j == 0 or j == nc - 1:\\n                return True\\n\\t\\t\\t# \\u56DB\\u4E2A\\u65B9\\u5411\\u6709\\u4E00\\u4E2A\\u4E0D\\u4E00\\u6837\\u7684\\u90BB\\u5C45\\t\\n            target = grid[i][j]\\n            left = grid[i][j-1]\\n            right = grid[i][j+1]\\n            top = grid[i-1][j]\\n            down = grid[i+1][j]\\n            if left != target or right != target or top != target or down != target:\\n                return True\\n            return False\\n            \\n        def dfs(grid, i, j, target, visited, color):\\n\\t\\t\\t# \\u641C\\u5230\\u4E86\\u8FB9\\u754C\\uFF0C\\u8FD4\\u56DE\\n            if i < 0  or i >= nr or j < 0 or j >= nc:\\n                return\\n\\t\\t\\t# \\u5DF2\\u7ECF\\u641C\\u8FC7\\uFF0C\\u8FD4\\u56DE\\n            if visited[i][j]:\\n                return\\n\\t\\t\\t# \\u5F53\\u524D\\u989C\\u8272\\u4E0D\\u662Ftarget\\u7684\\u989C\\u8272\\uFF0C\\u4E0D\\u5C5E\\u4E8E\\u8FD9\\u4E2Aconnected component\\uFF0C\\u8FD4\\u56DE\\n            if target != grid[i][j]:\\n                return\\n            visited[i][j] = 1\\n            \\n            if is_border(grid, i, j):\\n                # grid[i][j] = color  # dont do that!\\n                should_color[i][j] = 1\\n            dfs(grid, i, j+1, target, visited, color)\\n            dfs(grid, i, j-1, target, visited, color)\\n            dfs(grid, i-1, j, target, visited, color)\\n            dfs(grid, i+1, j, target, visited, color)\\n        \\n        nr = len(grid)\\n        nc = len(grid[0])\\n        visited = [[0]*nc for _ in range(nr)]\\n        should_color = [[0]*nc for _ in range(nr)]\\n        \\n        dfs(grid, r0, c0, grid[r0][c0], visited, color)\\n        \\n        for i in range(nr):\\n            for j in range(nc):\\n                if should_color[i][j]:\\n                    grid[i][j] = color\\n        \\n        return grid\\n```",
                "solutionTags": [],
                "code": "```4-directionally adjacent```\n```should_color```\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n        def is_border(grid, i, j):\\n\\t\\t\\t# \\u6570\\u7EC4\\u8FB9\\u754C\\n            if i == 0 or i == nr - 1 or j == 0 or j == nc - 1:\\n                return True\\n\\t\\t\\t# \\u56DB\\u4E2A\\u65B9\\u5411\\u6709\\u4E00\\u4E2A\\u4E0D\\u4E00\\u6837\\u7684\\u90BB\\u5C45\\t\\n            target = grid[i][j]\\n            left = grid[i][j-1]\\n            right = grid[i][j+1]\\n            top = grid[i-1][j]\\n            down = grid[i+1][j]\\n            if left != target or right != target or top != target or down != target:\\n                return True\\n            return False\\n            \\n        def dfs(grid, i, j, target, visited, color):\\n\\t\\t\\t# \\u641C\\u5230\\u4E86\\u8FB9\\u754C\\uFF0C\\u8FD4\\u56DE\\n            if i < 0  or i >= nr or j < 0 or j >= nc:\\n                return\\n\\t\\t\\t# \\u5DF2\\u7ECF\\u641C\\u8FC7\\uFF0C\\u8FD4\\u56DE\\n            if visited[i][j]:\\n                return\\n\\t\\t\\t# \\u5F53\\u524D\\u989C\\u8272\\u4E0D\\u662Ftarget\\u7684\\u989C\\u8272\\uFF0C\\u4E0D\\u5C5E\\u4E8E\\u8FD9\\u4E2Aconnected component\\uFF0C\\u8FD4\\u56DE\\n            if target != grid[i][j]:\\n                return\\n            visited[i][j] = 1\\n            \\n            if is_border(grid, i, j):\\n                # grid[i][j] = color  # dont do that!\\n                should_color[i][j] = 1\\n            dfs(grid, i, j+1, target, visited, color)\\n            dfs(grid, i, j-1, target, visited, color)\\n            dfs(grid, i-1, j, target, visited, color)\\n            dfs(grid, i+1, j, target, visited, color)\\n        \\n        nr = len(grid)\\n        nc = len(grid[0])\\n        visited = [[0]*nc for _ in range(nr)]\\n        should_color = [[0]*nc for _ in range(nr)]\\n        \\n        dfs(grid, r0, c0, grid[r0][c0], visited, color)\\n        \\n        for i in range(nr):\\n            for j in range(nc):\\n                if should_color[i][j]:\\n                    grid[i][j] = color\\n        \\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283010,
                "title": "bfs-method-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        vector<pair<int,int>> retv;\\n        queue<pair<int,int>> q;\\n        q.push(pair<int,int>(r0,c0));\\n        vector<vector<bool>> go(grid.size(),vector<bool>(grid[0].size(),false));\\n        vector<vector<int>> dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\n        go[r0][c0] = true;\\n        while(!q.empty())\\n        {\\n            auto e = q.front();q.pop();\\n            int x = e.first;\\n            int y = e.second;\\n            for(auto d : dirs)\\n            {\\n                int _x = x+d[0];\\n                int _y = y+d[1];\\n                if(_x>=0&&_x<grid.size()&&_y>=0&&_y<grid[0].size()&&grid[_x][_y] == grid[x][y])\\n                {\\n                    if(go[_x][_y] == false)\\n                    {\\n                        q.push(pair<int,int>(_x,_y));    \\n                        go[_x][_y] = true;\\n                    }\\n                }\\n                else\\n                {\\n                    retv.push_back(pair<int,int>(x,y));\\n                }\\n            }\\n        }\\n        for(auto e: retv)\\n        {\\n            grid[e.first][e.second] = color;\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        vector<pair<int,int>> retv;\\n        queue<pair<int,int>> q;\\n        q.push(pair<int,int>(r0,c0));\\n        vector<vector<bool>> go(grid.size(),vector<bool>(grid[0].size(),false));\\n        vector<vector<int>> dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\n        go[r0][c0] = true;\\n        while(!q.empty())\\n        {\\n            auto e = q.front();q.pop();\\n            int x = e.first;\\n            int y = e.second;\\n            for(auto d : dirs)\\n            {\\n                int _x = x+d[0];\\n                int _y = y+d[1];\\n                if(_x>=0&&_x<grid.size()&&_y>=0&&_y<grid[0].size()&&grid[_x][_y] == grid[x][y])\\n                {\\n                    if(go[_x][_y] == false)\\n                    {\\n                        q.push(pair<int,int>(_x,_y));    \\n                        go[_x][_y] = true;\\n                    }\\n                }\\n                else\\n                {\\n                    retv.push_back(pair<int,int>(x,y));\\n                }\\n            }\\n        }\\n        for(auto e: retv)\\n        {\\n            grid[e.first][e.second] = color;\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282948,
                "title": "dfs-solution-using-java",
                "content": "```\\nclass Solution {\\n    int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        boolean[][] check = new boolean[grid.length][grid[0].length];\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        int cur_color = grid[r0][c0];\\n        dfs(grid, check, visited, r0, c0, cur_color);\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(check[i][j]){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n        \\n    }\\n    \\n    \\n    public void dfs(int[][] grid, boolean[][] check, boolean[][] visited, int i, int j, int color){\\n        if(visited[i][j] == true){\\n            return;\\n        }\\n        visited[i][j] = true;\\n        \\n        for(int[] dir: dirs){\\n            int x = i+dir[0];\\n            int y = j+dir[1];\\n            if(x<0 || x>=grid.length || y<0 || y>=grid[0].length || grid[x][y]!=color){\\n                check[i][j] = true;\\n            }\\n            if(x>=0 && x<grid.length && y>=0 && y<grid[0].length && grid[x][y] == color){\\n                dfs(grid, check, visited, x, y, color);\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        boolean[][] check = new boolean[grid.length][grid[0].length];\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        int cur_color = grid[r0][c0];\\n        dfs(grid, check, visited, r0, c0, cur_color);\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(check[i][j]){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n        \\n    }\\n    \\n    \\n    public void dfs(int[][] grid, boolean[][] check, boolean[][] visited, int i, int j, int color){\\n        if(visited[i][j] == true){\\n            return;\\n        }\\n        visited[i][j] = true;\\n        \\n        for(int[] dir: dirs){\\n            int x = i+dir[0];\\n            int y = j+dir[1];\\n            if(x<0 || x>=grid.length || y<0 || y>=grid[0].length || grid[x][y]!=color){\\n                check[i][j] = true;\\n            }\\n            if(x>=0 && x<grid.length && y>=0 && y<grid[0].length && grid[x][y] == color){\\n                dfs(grid, check, visited, x, y, color);\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282892,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Idea**\\nPerform dfs from the start poistion and mark with `-1` to remember the visited positions and mark with `0` to cells which are border cells.\\nWe cannot paint a cell with new color yet while doing dfs because that will change the status of its neighbor cells (neighbor cells will think they are on the border).\\n\\n```\\npublic int[][] colorBorder(int[][] g, int r0, int c0, int c) {\\n        int old = g[r0][c0];\\n        dfs(g, r0, c0, old);\\n        for(int i=0; i < g.length; i++)\\n            for(int j=0; j < g[0].length; j++)\\n                if(g[i][j] == 0)\\n                    g[i][j] = c;\\n                else if(g[i][j] == -1)\\n                    g[i][j] = old;\\n        return g;\\n    }\\n    private void dfs(int[][] g, int x, int y, int c){\\n        if(x < 0 || x == g.length || y < 0 || y == g[0].length || g[x][y] != c) return;\\n        border(g, x, y, c);\\n        dfs(g, x+1, y, c);\\n        dfs(g, x-1, y, c);\\n        dfs(g, x, y+1, c);\\n        dfs(g, x, y-1, c);\\n    }\\n    private void border(int[][] g, int x, int y, int c){\\n        g[x][y] = -1;\\n        if(isBorder(g, x+1, y, c)){\\n            g[x][y] = 0;\\n            return;\\n        }\\n        if(isBorder(g, x-1, y, c)){\\n            g[x][y] = 0;\\n            return;\\n        }\\n        if(isBorder(g, x, y-1, c)){\\n            g[x][y] = 0;\\n            return;\\n        }\\n        if(isBorder(g, x, y+1, c)){\\n            g[x][y] = 0;\\n            return;\\n        }\\n    }\\n    private boolean isBorder(int[][] g, int x, int y, int c){\\n        return x < 0 || x == g.length || y < 0 || y == g[0].length || (g[x][y] != c && g[x][y] != -1 && g[x][y] != 0);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[][] colorBorder(int[][] g, int r0, int c0, int c) {\\n        int old = g[r0][c0];\\n        dfs(g, r0, c0, old);\\n        for(int i=0; i < g.length; i++)\\n            for(int j=0; j < g[0].length; j++)\\n                if(g[i][j] == 0)\\n                    g[i][j] = c;\\n                else if(g[i][j] == -1)\\n                    g[i][j] = old;\\n        return g;\\n    }\\n    private void dfs(int[][] g, int x, int y, int c){\\n        if(x < 0 || x == g.length || y < 0 || y == g[0].length || g[x][y] != c) return;\\n        border(g, x, y, c);\\n        dfs(g, x+1, y, c);\\n        dfs(g, x-1, y, c);\\n        dfs(g, x, y+1, c);\\n        dfs(g, x, y-1, c);\\n    }\\n    private void border(int[][] g, int x, int y, int c){\\n        g[x][y] = -1;\\n        if(isBorder(g, x+1, y, c)){\\n            g[x][y] = 0;\\n            return;\\n        }\\n        if(isBorder(g, x-1, y, c)){\\n            g[x][y] = 0;\\n            return;\\n        }\\n        if(isBorder(g, x, y-1, c)){\\n            g[x][y] = 0;\\n            return;\\n        }\\n        if(isBorder(g, x, y+1, c)){\\n            g[x][y] = 0;\\n            return;\\n        }\\n    }\\n    private boolean isBorder(int[][] g, int x, int y, int c){\\n        return x < 0 || x == g.length || y < 0 || y == g[0].length || (g[x][y] != c && g[x][y] != -1 && g[x][y] != 0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282852,
                "title": "java-bfs",
                "content": "though not so efficient in space\\n\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        boolean[][] visited = new boolean[row][col];\\n        boolean[][] border = new boolean[row][col];\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{r0,c0});\\n        visited[r0][c0] = true; // visited\\n        \\n        int[][] steps = {{-1,0},{1,0},{0,1},{0,-1}};\\n        //System.out.println(\"now to bfs\");\\n        \\n        while(!queue.isEmpty()) {\\n            int[] item = queue.poll();\\n            int x = item[0];\\n            int y = item[1];\\n            //System.out.println(\"x=\" + x + \", y=\" + y);\\n            for(int i = 0; i < steps.length; ++i) {\\n                int nextx = x + steps[i][0];\\n                int nexty = y + steps[i][1];\\n                if(nextx < 0 || nextx >= row || nexty < 0 || nexty >= col || grid[nextx][nexty] != grid[x][y]) {\\n                    border[x][y] = true; // is border\\n                }\\n                else { // so here, next color is the same \\n                    if(!visited[nextx][nexty]) { // not visited\\n                        queue.add(new int[]{nextx, nexty});\\n                        visited[nextx][nexty] = true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < grid.length; ++i) {\\n            for(int j = 0; j < grid[i].length; ++j) {\\n                if(border[i][j]) {\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        boolean[][] visited = new boolean[row][col];\\n        boolean[][] border = new boolean[row][col];\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{r0,c0});\\n        visited[r0][c0] = true; // visited\\n        \\n        int[][] steps = {{-1,0},{1,0},{0,1},{0,-1}};\\n        //System.out.println(\"now to bfs\");\\n        \\n        while(!queue.isEmpty()) {\\n            int[] item = queue.poll();\\n            int x = item[0];\\n            int y = item[1];\\n            //System.out.println(\"x=\" + x + \", y=\" + y);\\n            for(int i = 0; i < steps.length; ++i) {\\n                int nextx = x + steps[i][0];\\n                int nexty = y + steps[i][1];\\n                if(nextx < 0 || nextx >= row || nexty < 0 || nexty >= col || grid[nextx][nexty] != grid[x][y]) {\\n                    border[x][y] = true; // is border\\n                }\\n                else { // so here, next color is the same \\n                    if(!visited[nextx][nexty]) { // not visited\\n                        queue.add(new int[]{nextx, nexty});\\n                        visited[nextx][nexty] = true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < grid.length; ++i) {\\n            for(int j = 0; j < grid[i].length; ++j) {\\n                if(border[i][j]) {\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282840,
                "title": "python-clean-bfs-solution",
                "content": "```\\n    def colorBorder(self, grid, r0, c0, color):\\n        queue = deque()\\n\\t\\tqueue.append((r0,c0))\\n        visited = set()\\n        visited.add((r0,c0))\\n        marked = []\\n        direc = [(-1,0), (1,0), (0,1),(0,-1)]\\n        old = grid[r0][c0]\\n        while queue:\\n            r, c = queue.popleft()\\n            if r == 0 or r == len(grid)-1 or c == 0 or c == len(grid[0])-1 or grid[r-1][c] != old or grid[r+1][c] != old or grid[r][c-1] != old or grid[r][c+1] != old:\\n                marked.append((r,c))\\n            for d_x,d_y in direc:\\n                x = r+d_x\\n                y = c+d_y\\n                if x >= 0 and x < len(grid) and y >=0 and y < len(grid[0]) and grid[x][y] == old and (x,y) not in visited:\\n                    visited.add((x,y))\\n                    queue.append((x,y))\\n        for x,y in marked:\\n            grid[x][y] = color\\n        return grid\\n```",
                "solutionTags": [],
                "code": "```\\n    def colorBorder(self, grid, r0, c0, color):\\n        queue = deque()\\n\\t\\tqueue.append((r0,c0))\\n        visited = set()\\n        visited.add((r0,c0))\\n        marked = []\\n        direc = [(-1,0), (1,0), (0,1),(0,-1)]\\n        old = grid[r0][c0]\\n        while queue:\\n            r, c = queue.popleft()\\n            if r == 0 or r == len(grid)-1 or c == 0 or c == len(grid[0])-1 or grid[r-1][c] != old or grid[r+1][c] != old or grid[r][c-1] != old or grid[r][c+1] != old:\\n                marked.append((r,c))\\n            for d_x,d_y in direc:\\n                x = r+d_x\\n                y = c+d_y\\n                if x >= 0 and x < len(grid) and y >=0 and y < len(grid[0]) and grid[x][y] == old and (x,y) not in visited:\\n                    visited.add((x,y))\\n                    queue.append((x,y))\\n        for x,y in marked:\\n            grid[x][y] = color\\n        return grid\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4097638,
                "title": "python-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n+v) where v is the linear operation for checking visited list and n is for checking through n points.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) for a visited list\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n\\n        rows, cols = len(grid), len(grid[0])\\n        visited = set()\\n        prev_color = grid[row][col]\\n\\n        def dfs(row, col):\\n            # addind the node in visited\\n            visited.add((row, col))\\n\\n            # explore four adjucent node\\n            for dr, dc in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\\n                new_row, new_col = row + dr, col + dc\\n\\n                # check if the new node is already visited or not\\n                if (new_row, new_col) not in visited:\\n\\n                    # check if the new node is out of range or not\\n                    if (0 <= new_row < rows) and (0 <= new_col < cols):\\n\\n                        # check if the new node has the same color or not\\n                        if grid[new_row][new_col]==prev_color:\\n\\n                                # do dfs on new node\\n                                dfs(new_row, new_col)\\n                        \\n                        # If the node is not same color then it is a border node. Change the color        \\n                        else:\\n                            grid[row][col] = color\\n                    \\n                    # if new node out of range, then it is a border node. Change the color\\n                    else:\\n                        grid[row][col] = color\\n    \\n        # start the bfs from the given point\\n        dfs(row, col)\\n\\n        \\n        return grid\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n\\n        rows, cols = len(grid), len(grid[0])\\n        visited = set()\\n        prev_color = grid[row][col]\\n\\n        def dfs(row, col):\\n            # addind the node in visited\\n            visited.add((row, col))\\n\\n            # explore four adjucent node\\n            for dr, dc in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\\n                new_row, new_col = row + dr, col + dc\\n\\n                # check if the new node is already visited or not\\n                if (new_row, new_col) not in visited:\\n\\n                    # check if the new node is out of range or not\\n                    if (0 <= new_row < rows) and (0 <= new_col < cols):\\n\\n                        # check if the new node has the same color or not\\n                        if grid[new_row][new_col]==prev_color:\\n\\n                                # do dfs on new node\\n                                dfs(new_row, new_col)\\n                        \\n                        # If the node is not same color then it is a border node. Change the color        \\n                        else:\\n                            grid[row][col] = color\\n                    \\n                    # if new node out of range, then it is a border node. Change the color\\n                    else:\\n                        grid[row][col] = color\\n    \\n        # start the bfs from the given point\\n        dfs(row, col)\\n\\n        \\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097603,
                "title": "python-solution-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nApplying Breadth First Search. The idea is we will take a point and then we will find out if this point is our point of interest. After that, we will look points which is \\'one\\' distance from the first point. We can say this layer 1. In our case, there are total four points as such. Top, bottom, right and left points of the main point. We will check the top point and see if it is desired point or not. Then checke the bottom then right and then left. Layer 1 is complete. Then we will go for layer 2. We will check the 4 neighbors of Top point. And it continues.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain a list called components to list down the points that needs to be checked sequntially. And then apply checking on the points from the component list.\\n\\n# Complexity\\n- Time complexity: Although it looks like a $$O(n^3)$$ [while loop for components, inside for loop for neighbors, inside checking the neighbors in visited set] but really the computation is way less. because the for loop only checks four neighbour so instead of $$O(n * n * n)$$ it becomes $$O(n * 4 * n)$$ which is $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nCorrect me if I am wrong.\\n\\n# Code\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        rows, cols = len(grid), len(grid[0])\\n        # co-ordinate that we visited\\n        visited = set()\\n        # co-ordinates that we need to visit\\n        components = [(row, col)]\\n        prev_color = grid[row][col]\\n\\n        def bfs(row, col):\\n            visited.add((row, col))\\n\\n            # checking four neighbors of the point\\n            for dr, dc in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\\n                new_row, new_col = row + dr, col + dc\\n                if (new_row, new_col) not in visited:\\n                    if (0<=new_row<rows) and (0<=new_col<cols):\\n                        # add to the components if the neighboring point is not in perimeter of the matrix\\n                        components.append((new_row, new_col))\\n                        if grid[new_row][new_col] != prev_color:\\n                            # if the color doesn\\'t match, means the new point is not connected component. so we don\\'t need to visit this point anymore.\\n                            components.pop(-1)\\n                            # because colors doesn\\'t match that means this is a border\\n                            grid[row][col] = color\\n\\n                    else:\\n                        # permimeter of the matrix, border by definition\\n                        grid[row][col] = color\\n\\n        # looping through components and do bfs for each point\\n        i = 0\\n        while i < len(components):\\n            bfs(*components[i])\\n            i += 1\\n\\n        return grid\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        rows, cols = len(grid), len(grid[0])\\n        # co-ordinate that we visited\\n        visited = set()\\n        # co-ordinates that we need to visit\\n        components = [(row, col)]\\n        prev_color = grid[row][col]\\n\\n        def bfs(row, col):\\n            visited.add((row, col))\\n\\n            # checking four neighbors of the point\\n            for dr, dc in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\\n                new_row, new_col = row + dr, col + dc\\n                if (new_row, new_col) not in visited:\\n                    if (0<=new_row<rows) and (0<=new_col<cols):\\n                        # add to the components if the neighboring point is not in perimeter of the matrix\\n                        components.append((new_row, new_col))\\n                        if grid[new_row][new_col] != prev_color:\\n                            # if the color doesn\\'t match, means the new point is not connected component. so we don\\'t need to visit this point anymore.\\n                            components.pop(-1)\\n                            # because colors doesn\\'t match that means this is a border\\n                            grid[row][col] = color\\n\\n                    else:\\n                        # permimeter of the matrix, border by definition\\n                        grid[row][col] = color\\n\\n        # looping through components and do bfs for each point\\n        i = 0\\n        while i < len(components):\\n            bfs(*components[i])\\n            i += 1\\n\\n        return grid\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046648,
                "title": "c-easy-clean-code",
                "content": "=\\n\\n# Code\\n```\\nclass Solution {\\npublic:map<pair<int,int>,int> p;\\n    void t(int i,int j,vector<vector<int>> &g,int x, vector<vector<int>> &v)\\n    {\\n        if(i<0 || j<0 || i>=g.size() || j>=g[0].size() || g[i][j]!=x || v[i][j]==1) return ;\\n        v[i][j]=1;\\n        p[{i,j}]++;\\n        t(i+1,j,g,x,v); \\n        t(i-1,j,g,x,v);\\n        t(i,j+1,g,x,v);\\n        t(i,j-1,g,x,v);\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& g, int r, int c, int col) {\\n       int m=g.size(),n=g[0].size();\\n       vector<vector<int>> v(m,vector<int> (n,0));\\n       t(r,c,g,g[r][c],v);\\n\\n       for(int i=0;i<g.size();i++)\\n       for(int j=0;j<g[0].size();j++)\\n       {\\n           if(p[{i,j}]>0)\\n           {\\n               if((i-1>=0&&p[{i-1,j}]==0) || (i+1<=g.size()&&p[{i+1,j}]==0) || (j-1>=0&&p[{i,j-1}]==0) || (j+1<=g[0].size()&&p[{i,j+1}]==0))\\n               g[i][j]=col;\\n               \\n               if(i==g.size()-1 || j==g[0].size()-1 || i==0 || j==0)\\n               g[i][j]=col;\\n           }\\n       }\\n       return g;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:map<pair<int,int>,int> p;\\n    void t(int i,int j,vector<vector<int>> &g,int x, vector<vector<int>> &v)\\n    {\\n        if(i<0 || j<0 || i>=g.size() || j>=g[0].size() || g[i][j]!=x || v[i][j]==1) return ;\\n        v[i][j]=1;\\n        p[{i,j}]++;\\n        t(i+1,j,g,x,v); \\n        t(i-1,j,g,x,v);\\n        t(i,j+1,g,x,v);\\n        t(i,j-1,g,x,v);\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& g, int r, int c, int col) {\\n       int m=g.size(),n=g[0].size();\\n       vector<vector<int>> v(m,vector<int> (n,0));\\n       t(r,c,g,g[r][c],v);\\n\\n       for(int i=0;i<g.size();i++)\\n       for(int j=0;j<g[0].size();j++)\\n       {\\n           if(p[{i,j}]>0)\\n           {\\n               if((i-1>=0&&p[{i-1,j}]==0) || (i+1<=g.size()&&p[{i+1,j}]==0) || (j-1>=0&&p[{i,j-1}]==0) || (j+1<=g[0].size()&&p[{i,j+1}]==0))\\n               g[i][j]=col;\\n               \\n               if(i==g.size()-1 || j==g[0].size()-1 || i==0 || j==0)\\n               g[i][j]=col;\\n           }\\n       }\\n       return g;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031252,
                "title": "bfs-short-precise-easy-to-understand-beats-99-c",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n# BFS\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dr[4]={1,0,-1,0};\\n    int dc[4]={0,1,0,-1};\\n\\n    bool isvalid(int i ,int j,int m,int n,vector<vector<int>>& grid,int b){\\n        return (i >= 0 && j >= 0 && i < m && j < n && grid[i][j]==b);\\n\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int t = grid[row][col];\\n\\n        queue<pair<int,int>> q;\\n        vector<vector<int>> visited(m,vector<int> (n,0));\\n        vector<vector<int>> newgrid;\\n\\n        newgrid=grid;\\n        q.push({row,col});\\n        visited[row][col]=1;\\n\\n        while(!q.empty()){\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n            for(int k=0;k<4;k++){\\n                int nr = r+dr[k];\\n                int nc = c+dc[k];\\n                if(isvalid(nr,nc,m,n,grid,t)){\\n                    if(nr >= 0 && nc >= 0 && nr < m && nc < n && !visited[nr][nc]){\\n                        visited[nr][nc]=1;\\n                        q.push({nr,nc});\\n                    }\\n                }else{\\n                    newgrid[r][c]=color;\\n                }\\n            }\\n        }\\n\\n        return newgrid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dr[4]={1,0,-1,0};\\n    int dc[4]={0,1,0,-1};\\n\\n    bool isvalid(int i ,int j,int m,int n,vector<vector<int>>& grid,int b){\\n        return (i >= 0 && j >= 0 && i < m && j < n && grid[i][j]==b);\\n\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int t = grid[row][col];\\n\\n        queue<pair<int,int>> q;\\n        vector<vector<int>> visited(m,vector<int> (n,0));\\n        vector<vector<int>> newgrid;\\n\\n        newgrid=grid;\\n        q.push({row,col});\\n        visited[row][col]=1;\\n\\n        while(!q.empty()){\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n            for(int k=0;k<4;k++){\\n                int nr = r+dr[k];\\n                int nc = c+dc[k];\\n                if(isvalid(nr,nc,m,n,grid,t)){\\n                    if(nr >= 0 && nc >= 0 && nr < m && nc < n && !visited[nr][nc]){\\n                        visited[nr][nc]=1;\\n                        q.push({nr,nc});\\n                    }\\n                }else{\\n                    newgrid[r][c]=color;\\n                }\\n            }\\n        }\\n\\n        return newgrid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982702,
                "title": "color-border-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971945,
                "title": "dfs-solution-tle-resolved",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid,int i,int j,int curColor,vector<vector<bool>>& visited)\\n    {\\n        if(i<0 or i==grid.size() or j<0 or j==grid[0].size() or grid[i][j]!=curColor or visited[i][j])\\n            return;\\n        \\n        visited[i][j]=true;\\n        grid[i][j]= -curColor;\\n        dfs(grid,i+1,j,curColor,visited);\\n        dfs(grid,i-1,j,curColor,visited);\\n        dfs(grid,i,j-1,curColor,visited);\\n        dfs(grid,i,j+1,curColor,visited);\\n        if(i>0 and i<grid.size()-1 and j>0 and j<grid[0].size()-1 and abs(grid[i+1][j])==curColor and abs(grid[i-1][j])==curColor and abs(grid[i][j-1])==curColor and abs(grid[i][j+1])==curColor)\\n            grid[i][j]=curColor;\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        vector<vector<bool>> visited(grid.size(),vector<bool>(grid[0].size(),false));\\n        dfs(grid,row,col,grid[row][col],visited);\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]<0)\\n                    grid[i][j]=color;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid,int i,int j,int curColor,vector<vector<bool>>& visited)\\n    {\\n        if(i<0 or i==grid.size() or j<0 or j==grid[0].size() or grid[i][j]!=curColor or visited[i][j])\\n            return;\\n        \\n        visited[i][j]=true;\\n        grid[i][j]= -curColor;\\n        dfs(grid,i+1,j,curColor,visited);\\n        dfs(grid,i-1,j,curColor,visited);\\n        dfs(grid,i,j-1,curColor,visited);\\n        dfs(grid,i,j+1,curColor,visited);\\n        if(i>0 and i<grid.size()-1 and j>0 and j<grid[0].size()-1 and abs(grid[i+1][j])==curColor and abs(grid[i-1][j])==curColor and abs(grid[i][j-1])==curColor and abs(grid[i][j+1])==curColor)\\n            grid[i][j]=curColor;\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        vector<vector<bool>> visited(grid.size(),vector<bool>(grid[0].size(),false));\\n        dfs(grid,row,col,grid[row][col],visited);\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]<0)\\n                    grid[i][j]=color;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956361,
                "title": "bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>vis(m,vector<int>(n,0));\\n        vector<vector<int>>ans=grid;\\n        int cl=grid[row][col];\\n        queue<pair<int,int>>q;\\n        q.push({row,col});\\n        while(q.size()){\\n            int ro=q.front().first;\\n            int co=q.front().second;\\n            q.pop();\\n            vis[ro][co]=1;\\n            int r[4]={-1,0,0,1};\\n            int c[4]={0,-1,1,0};\\n            int count=0;\\n            for(int k=0;k<4;k++){\\n                int nr=ro+r[k],nc=co+c[k];\\n                if(nr>=0&&nr<m&&nc>=0&&nc<n&&grid[nr][nc]==cl){\\n                    if(vis[nr][nc]==0)q.push({nr,nc});\\n                    count++;\\n                }\\n            }\\n            if(count<4){\\n                ans[ro][co]=color;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>vis(m,vector<int>(n,0));\\n        vector<vector<int>>ans=grid;\\n        int cl=grid[row][col];\\n        queue<pair<int,int>>q;\\n        q.push({row,col});\\n        while(q.size()){\\n            int ro=q.front().first;\\n            int co=q.front().second;\\n            q.pop();\\n            vis[ro][co]=1;\\n            int r[4]={-1,0,0,1};\\n            int c[4]={0,-1,1,0};\\n            int count=0;\\n            for(int k=0;k<4;k++){\\n                int nr=ro+r[k],nc=co+c[k];\\n                if(nr>=0&&nr<m&&nc>=0&&nc<n&&grid[nr][nc]==cl){\\n                    if(vis[nr][nc]==0)q.push({nr,nc});\\n                    count++;\\n                }\\n            }\\n            if(count<4){\\n                ans[ro][co]=color;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949906,
                "title": "basic-solution-explained-in-comments-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n// we are supposewd to colour the boarder of the given compomet of the graph\\n// boared cells -> boarder cells are the cells who are not surrounded by the same color cells ( 4 way movement allowed , no diagonal movement allowed )\\n// so we just need to perform dfs on the given row and col \\n// and check if a cell is surronded by all four sides or not ( by the same color cell )\\n// if yes -> update the cell with the new color, else go to next dfs call\\n// there will be one issue when checking for the surrounding color, it\\'ll be because we are updatin the color with the new color so if we go to a new cell and see around it, even if earlier there was the source color to the left/right/up/down of it, we will see the new color and will end up making the wrong judgement, so to avoid this, we will make a copy of the given grid and look for surrounging in the copy vector not in the initailly given grid vector because we are constantly making changes in the grid vector \\n\\n    void dfs(int row, int col, vector<vector<int>>& vis, vector<vector<int>>& grid, int gRow, int gCol, int color, int src, vector<vector<int>>& copy ){\\n        \\n        vis[row][col] = 1; // marking as visited\\n\\n        int surr = 0; // this var will count how many sides our current cell is surrounded by the cell of source color\\n\\n        // checking the surrounding\\n        if( (row+1) >= 0 && (row+1) < gRow && (col+0) >= 0 && (col+0) < gCol && copy[row+1][col+0] == src ) surr += 1;\\n        if( (row-1) >= 0 && (row-1) < gRow && (col+0) >= 0 && (col+0) < gCol && copy[row-1][col+0] == src ) surr += 1;\\n        if( (row+0) >= 0 && (row+0) < gRow && (col+1) >= 0 && (col+1) < gCol && copy[row+0][col+1] == src ) surr += 1;\\n        if( (row+0) >= 0 && (row+0) < gRow && (col-1) >= 0 && (col-1) < gCol && copy[row+0][col-1] == src ) surr += 1;\\n\\n        if( surr != 4 ) grid[row][col] = color; // if .. ( you can see )\\n        \\n        // making the next dfs call\\n        if( (row+1) >= 0 && (row+1) < gRow && (col+0) >= 0 && (col+0) < gCol && vis[row+1][col+0] == 0 && grid[row+1][col+0] == src ) dfs(row+1 , col+0, vis, grid, gRow, gCol, color, src,copy);\\n        if( (row-1) >= 0 && (row-1) < gRow && (col+0) >= 0 && (col+0) < gCol && vis[row-1][col+0] == 0 && grid[row-1][col+0] == src ) dfs(row-1 , col+0, vis, grid, gRow, gCol, color, src,copy);\\n        if( (row+0) >= 0 && (row+0) < gRow && (col+1) >= 0 && (col+1) < gCol && vis[row+0][col+1] == 0 && grid[row+0][col+1] == src ) dfs(row+0 , col+1, vis, grid, gRow, gCol, color, src,copy);\\n        if( (row+0) >= 0 && (row+0) < gRow && (col-1) >= 0 && (col-1) < gCol && vis[row+0][col-1] == 0 && grid[row+0][col-1] == src ) dfs(row+0 , col-1, vis, grid, gRow, gCol, color, src,copy);\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        \\n        int gRow = grid.size();\\n        int gCol = grid[0].size();\\n\\n        vector<vector<int>> vis(gRow, vector<int> (gCol,0)); // visited array\\n        int src = grid[row][col]; // source color\\n\\n        vector<vector<int>> copy; // copy vector\\n        for( int i = 0; i<gRow; i++ ){\\n            vector<int> temp = grid[i];\\n            copy.push_back(temp);\\n        }\\n\\n        dfs(row, col, vis, grid, gRow, gCol, color, src,copy); // calling the dfs function\\n\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n// we are supposewd to colour the boarder of the given compomet of the graph\\n// boared cells -> boarder cells are the cells who are not surrounded by the same color cells ( 4 way movement allowed , no diagonal movement allowed )\\n// so we just need to perform dfs on the given row and col \\n// and check if a cell is surronded by all four sides or not ( by the same color cell )\\n// if yes -> update the cell with the new color, else go to next dfs call\\n// there will be one issue when checking for the surrounding color, it\\'ll be because we are updatin the color with the new color so if we go to a new cell and see around it, even if earlier there was the source color to the left/right/up/down of it, we will see the new color and will end up making the wrong judgement, so to avoid this, we will make a copy of the given grid and look for surrounging in the copy vector not in the initailly given grid vector because we are constantly making changes in the grid vector \\n\\n    void dfs(int row, int col, vector<vector<int>>& vis, vector<vector<int>>& grid, int gRow, int gCol, int color, int src, vector<vector<int>>& copy ){\\n        \\n        vis[row][col] = 1; // marking as visited\\n\\n        int surr = 0; // this var will count how many sides our current cell is surrounded by the cell of source color\\n\\n        // checking the surrounding\\n        if( (row+1) >= 0 && (row+1) < gRow && (col+0) >= 0 && (col+0) < gCol && copy[row+1][col+0] == src ) surr += 1;\\n        if( (row-1) >= 0 && (row-1) < gRow && (col+0) >= 0 && (col+0) < gCol && copy[row-1][col+0] == src ) surr += 1;\\n        if( (row+0) >= 0 && (row+0) < gRow && (col+1) >= 0 && (col+1) < gCol && copy[row+0][col+1] == src ) surr += 1;\\n        if( (row+0) >= 0 && (row+0) < gRow && (col-1) >= 0 && (col-1) < gCol && copy[row+0][col-1] == src ) surr += 1;\\n\\n        if( surr != 4 ) grid[row][col] = color; // if .. ( you can see )\\n        \\n        // making the next dfs call\\n        if( (row+1) >= 0 && (row+1) < gRow && (col+0) >= 0 && (col+0) < gCol && vis[row+1][col+0] == 0 && grid[row+1][col+0] == src ) dfs(row+1 , col+0, vis, grid, gRow, gCol, color, src,copy);\\n        if( (row-1) >= 0 && (row-1) < gRow && (col+0) >= 0 && (col+0) < gCol && vis[row-1][col+0] == 0 && grid[row-1][col+0] == src ) dfs(row-1 , col+0, vis, grid, gRow, gCol, color, src,copy);\\n        if( (row+0) >= 0 && (row+0) < gRow && (col+1) >= 0 && (col+1) < gCol && vis[row+0][col+1] == 0 && grid[row+0][col+1] == src ) dfs(row+0 , col+1, vis, grid, gRow, gCol, color, src,copy);\\n        if( (row+0) >= 0 && (row+0) < gRow && (col-1) >= 0 && (col-1) < gCol && vis[row+0][col-1] == 0 && grid[row+0][col-1] == src ) dfs(row+0 , col-1, vis, grid, gRow, gCol, color, src,copy);\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        \\n        int gRow = grid.size();\\n        int gCol = grid[0].size();\\n\\n        vector<vector<int>> vis(gRow, vector<int> (gCol,0)); // visited array\\n        int src = grid[row][col]; // source color\\n\\n        vector<vector<int>> copy; // copy vector\\n        for( int i = 0; i<gRow; i++ ){\\n            vector<int> temp = grid[i];\\n            copy.push_back(temp);\\n        }\\n\\n        dfs(row, col, vis, grid, gRow, gCol, color, src,copy); // calling the dfs function\\n\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948118,
                "title": "python-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        \\n        m, n = len(grid), len(grid[0])\\n        queue = [(row, col)]\\n        border = []\\n        seen = set()\\n        \\n        while queue:\\n            nq = []\\n            for r, c in queue:\\n                if (r,c) not in seen:\\n                    seen.add((r,c))\\n                    num = 0\\n                    for i, j in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\\n                        if 0 <= i < m and 0 <= j < n and grid[i][j] == grid[row][col]:\\n                            nq.append((i,j))\\n                            num += 1\\n                    if num != 4: border.append((r,c))\\n            queue = nq\\n        \\n        for r, c in border: grid[r][c] = color\\n        return grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        \\n        m, n = len(grid), len(grid[0])\\n        queue = [(row, col)]\\n        border = []\\n        seen = set()\\n        \\n        while queue:\\n            nq = []\\n            for r, c in queue:\\n                if (r,c) not in seen:\\n                    seen.add((r,c))\\n                    num = 0\\n                    for i, j in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\\n                        if 0 <= i < m and 0 <= j < n and grid[i][j] == grid[row][col]:\\n                            nq.append((i,j))\\n                            num += 1\\n                    if num != 4: border.append((r,c))\\n            queue = nq\\n        \\n        for r, c in border: grid[r][c] = color\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935835,
                "title": "simplified-solution-with-detailed-institution-99-efficient-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nProblem description is bit vague in the sense that understanding of border connected components is not very clear.\\nConected components we will all know however a connected components will be fall in the definition of boarder connected components if it has any of the following features:\\n1. Its(grid) belongs to first or last row or grid belongs to first or last columns.\\n2. Its connected components has different color.\\n\\nThen Use the same Traversing approach as that of Flood Fill Algorithm.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m * n){for calling DFS stack function this number of times} + O(m * n * 4){for Traversing in all 4 direction of a particular grid}\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m * n) for storing Visited vector  + O(m * n) {for stack memory of DFS call}\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>>& grid, vector<vector<int>>& vis, int row, int col, int startCol, int newColor, int m, int n)\\n    {\\n        //bool border = false;\\n        vis[row][col] = 1;\\n        if(row==0 || row==m-1 || col==0 ||col==n-1)\\n            grid[row][col] = newColor;\\n\\n        int rowArr[] = {0, -1, 0, 1};\\n        int colArr[] = {-1, 0, 1, 0};\\n\\n        for(int i = 0; i<4; i++)\\n        {\\n            int nRow = row + rowArr[i];\\n            int nCol = col + colArr[i];\\n\\n            if(nRow>=0 && nRow<m && nCol>=0 && nCol<n )\\n            {\\n                if(!vis[nRow][nCol])\\n                {\\n                    if(grid[nRow][nCol]==startCol)\\n                        dfs(grid, vis, nRow, nCol, startCol, newColor, m, n);\\n                    else\\n                        grid[row][col] = newColor;\\n                }\\n                \\n            }\\n            else\\n                grid[row][col] = newColor;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int>(n,0));\\n        dfs(grid, vis, row, col, grid[row][col], color, m, n);\\n        // for(int i = row; i<m ;i++)\\n        // {\\n        //     for(int j = col;j<n; j++)\\n        //     {\\n        //         if(!vis)\\n        //         dfs(grid, vis, row, col, grid[row][col], color, m, n);\\n        //     }\\n        // }\\n\\n        return grid;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>>& grid, vector<vector<int>>& vis, int row, int col, int startCol, int newColor, int m, int n)\\n    {\\n        //bool border = false;\\n        vis[row][col] = 1;\\n        if(row==0 || row==m-1 || col==0 ||col==n-1)\\n            grid[row][col] = newColor;\\n\\n        int rowArr[] = {0, -1, 0, 1};\\n        int colArr[] = {-1, 0, 1, 0};\\n\\n        for(int i = 0; i<4; i++)\\n        {\\n            int nRow = row + rowArr[i];\\n            int nCol = col + colArr[i];\\n\\n            if(nRow>=0 && nRow<m && nCol>=0 && nCol<n )\\n            {\\n                if(!vis[nRow][nCol])\\n                {\\n                    if(grid[nRow][nCol]==startCol)\\n                        dfs(grid, vis, nRow, nCol, startCol, newColor, m, n);\\n                    else\\n                        grid[row][col] = newColor;\\n                }\\n                \\n            }\\n            else\\n                grid[row][col] = newColor;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int>(n,0));\\n        dfs(grid, vis, row, col, grid[row][col], color, m, n);\\n        // for(int i = row; i<m ;i++)\\n        // {\\n        //     for(int j = col;j<n; j++)\\n        //     {\\n        //         if(!vis)\\n        //         dfs(grid, vis, row, col, grid[row][col], color, m, n);\\n        //     }\\n        // }\\n\\n        return grid;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916013,
                "title": "easy-python-solution-by-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    #\\u5728\\u6307\\u5B9A\\u4F4D\\u7F6E\\u5904\\u8FDB\\u884Cdfs, \\u6EE1\\u8DB3border\\u6761\\u4EF6\\u7684\\u8FDB\\u884Ccolor\\n    #\\u56E0\\u4E3Acolor\\u540E\\u4F1A\\u5F71\\u54CD\\u5224\\u65ADborder\\uFF0C\\u6240\\u4EE5\\u52062\\u6B65\\n    #1.\\u6EE1\\u8DB3border\\u6761\\u4EF6\\u7684\\u6DFB\\u52A0\\u5230lst\\u4E2D\\n    #2.\\u5BF9lst\\u4E2D\\u7684\\u8FDB\\u884Ccolor\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def colorBorder(self, grid, row, col, color):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type row: int\\n        :type col: int\\n        :type color: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #\\u5728\\u6307\\u5B9A\\u4F4D\\u7F6E\\u5904\\u8FDB\\u884Cdfs, \\u6EE1\\u8DB3border\\u6761\\u4EF6\\u7684\\u8FDB\\u884Ccolor\\n        #\\u56E0\\u4E3Acolor\\u540E\\u4F1A\\u5F71\\u54CD\\u5224\\u65ADborder\\uFF0C\\u6240\\u4EE5\\u52062\\u6B65\\n        #1.\\u6EE1\\u8DB3border\\u6761\\u4EF6\\u7684\\u6DFB\\u52A0\\u5230lst\\u4E2D\\n        #2.\\u5BF9lst\\u4E2D\\u7684\\u8FDB\\u884Ccolor\\n        m,n = len(grid),len(grid[0])\\n        visited = [[0 for j in range(n)] for i in range(m)]\\n        target = grid[row][col]\\n        lst = []\\n\\n        def dfs(i,j):\\n            if 0<=i<=m-1 and 0<=j<=n-1 and visited[i][j] == 0:\\n                visited[i][j] = 1\\n                if grid[i][j] == target:\\n                    #\\u4E0A\\u65B9\\u65E0\\n                    flag = False\\n                    if i-1<0 or grid[i-1][j] != target:\\n                        flag = True\\n                    if i+1>m-1 or grid[i+1][j] != target:\\n                        flag = True\\n                    if j-1<0 or grid[i][j-1] != target:\\n                        flag = True\\n                    if j+1>n-1 or grid[i][j+1] != target:\\n                        flag = True\\n                    if flag:\\n                        lst.append((i,j))\\n\\n                    dfs(i-1,j)\\n                    dfs(i+1,j)\\n                    dfs(i,j-1)\\n                    dfs(i,j+1)\\n\\n        dfs(row,col)\\n        for i,j in lst:\\n            grid[i][j] = color\\n        return grid\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def colorBorder(self, grid, row, col, color):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type row: int\\n        :type col: int\\n        :type color: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #\\u5728\\u6307\\u5B9A\\u4F4D\\u7F6E\\u5904\\u8FDB\\u884Cdfs, \\u6EE1\\u8DB3border\\u6761\\u4EF6\\u7684\\u8FDB\\u884Ccolor\\n        #\\u56E0\\u4E3Acolor\\u540E\\u4F1A\\u5F71\\u54CD\\u5224\\u65ADborder\\uFF0C\\u6240\\u4EE5\\u52062\\u6B65\\n        #1.\\u6EE1\\u8DB3border\\u6761\\u4EF6\\u7684\\u6DFB\\u52A0\\u5230lst\\u4E2D\\n        #2.\\u5BF9lst\\u4E2D\\u7684\\u8FDB\\u884Ccolor\\n        m,n = len(grid),len(grid[0])\\n        visited = [[0 for j in range(n)] for i in range(m)]\\n        target = grid[row][col]\\n        lst = []\\n\\n        def dfs(i,j):\\n            if 0<=i<=m-1 and 0<=j<=n-1 and visited[i][j] == 0:\\n                visited[i][j] = 1\\n                if grid[i][j] == target:\\n                    #\\u4E0A\\u65B9\\u65E0\\n                    flag = False\\n                    if i-1<0 or grid[i-1][j] != target:\\n                        flag = True\\n                    if i+1>m-1 or grid[i+1][j] != target:\\n                        flag = True\\n                    if j-1<0 or grid[i][j-1] != target:\\n                        flag = True\\n                    if j+1>n-1 or grid[i][j+1] != target:\\n                        flag = True\\n                    if flag:\\n                        lst.append((i,j))\\n\\n                    dfs(i-1,j)\\n                    dfs(i+1,j)\\n                    dfs(i,j-1)\\n                    dfs(i,j+1)\\n\\n        dfs(row,col)\\n        for i,j in lst:\\n            grid[i][j] = color\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811935,
                "title": "c-solution-dfs",
                "content": "# Intuition\\nDFS to find the adjecnt elements\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    int[][] dir = new int[][] {new int[]{0,1}, new int[]{0,-1}, new int[]{1, 0}, new int[]{-1, 0}};\\n    int m;\\n    int n;\\n    int toColo;\\n    int[][] visited;\\n    public int[][] ColorBorder(int[][] grid, int row, int col, int color) {\\n        m = grid.Length;\\n        n = grid[0].Length;\\n        visited = new int[m][];\\n        toColo = color;\\n\\n        for(var r=0; r<m; ++r){\\n            visited[r] = new int[n];\\n            for(var c=0; c<n; ++c){\\n                visited[r][c] = -1;\\n            }\\n        }\\n        \\n        DFS(row, col, grid[row][col], grid);\\n\\n        for(int i=0; i<m; i++)\\n        for(int j=0; j<n; j++){\\n            if(visited[i][j]==-1){\\n                visited[i][j] = grid[i][j];\\n            }\\n        }\\n\\n        return visited;\\n    }\\n\\n    public void DFS(int row, int col, int color, int[][] grid){\\n        if(visited[row][col]!=-1) return;\\n\\n        visited[row][col] = color;\\n\\n        if(row==0 || row==m-1 || col==0 || col==n-1){\\n            visited[row][col] = toColo;\\n        }\\n\\n        foreach(var coor in dir){\\n            int nx = row + coor[0];\\n            int ny = col + coor[1];\\n\\n            if(nx>=0 && nx<m && ny>=0 && ny<n){\\n                if(grid[nx][ny]==color){\\n                    DFS(nx, ny, color, grid);\\n                }\\n                else if(grid[row][col]!=toColo){\\n                    visited[row][col] = toColo;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    int[][] dir = new int[][] {new int[]{0,1}, new int[]{0,-1}, new int[]{1, 0}, new int[]{-1, 0}};\\n    int m;\\n    int n;\\n    int toColo;\\n    int[][] visited;\\n    public int[][] ColorBorder(int[][] grid, int row, int col, int color) {\\n        m = grid.Length;\\n        n = grid[0].Length;\\n        visited = new int[m][];\\n        toColo = color;\\n\\n        for(var r=0; r<m; ++r){\\n            visited[r] = new int[n];\\n            for(var c=0; c<n; ++c){\\n                visited[r][c] = -1;\\n            }\\n        }\\n        \\n        DFS(row, col, grid[row][col], grid);\\n\\n        for(int i=0; i<m; i++)\\n        for(int j=0; j<n; j++){\\n            if(visited[i][j]==-1){\\n                visited[i][j] = grid[i][j];\\n            }\\n        }\\n\\n        return visited;\\n    }\\n\\n    public void DFS(int row, int col, int color, int[][] grid){\\n        if(visited[row][col]!=-1) return;\\n\\n        visited[row][col] = color;\\n\\n        if(row==0 || row==m-1 || col==0 || col==n-1){\\n            visited[row][col] = toColo;\\n        }\\n\\n        foreach(var coor in dir){\\n            int nx = row + coor[0];\\n            int ny = col + coor[1];\\n\\n            if(nx>=0 && nx<m && ny>=0 && ny<n){\\n                if(grid[nx][ny]==color){\\n                    DFS(nx, ny, color, grid);\\n                }\\n                else if(grid[row][col]!=toColo){\\n                    visited[row][col] = toColo;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779395,
                "title": "c-dfs-solution",
                "content": "# intution\\nfind the neighbours of every cell, if valid neighbour count is 4 , then its not border \\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&grid,vector<pair<int,int>>&borders,vector<vector<int>>&visited,int row,int col,int n,int m)\\n    {\\n\\n        int flag =0;\\n        if(row ==0 or col ==0 or row==n-1 or col==m-1)flag =1;\\n\\n        int count =0;\\n        visited[row][col]=1;\\n        int del_row[] = {-1,0,1,0};\\n        int del_col[] = {0,1,0,-1};\\n        for(int i=0;i<4;i++)\\n        {\\n            int ne_row = row+del_row[i];\\n            int ne_col = col+del_col[i];\\n            if(ne_row<n && ne_col <m && ne_row>=0 && ne_col >=0 && !visited[ne_row][ne_col] && grid[ne_row][ne_col]== grid[row][col])\\n            {\\n\\n\\n                dfs(grid,borders,visited,ne_row,ne_col,n,m);\\n            }\\n            if(ne_row<n && ne_col<m && ne_row>=0 && ne_col >=0 && grid[ne_row][ne_col]== grid[row][col])\\n            {\\n                count++;\\n            }\\n\\n        }\\n        \\n        if(flag ==1 or count<4)\\n        {\\n            borders.push_back({row,col});\\n        }\\n\\n\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size();\\n        int m = grid[0].size();\\n        vector<pair<int,int>>borders;\\n        vector<vector<int>>visited(n,vector<int>(m,0));\\n        dfs(grid,borders,visited,row,col,n,m);\\n        for(int i=0;i<borders.size();i++)\\n        {\\n            grid[borders[i].first][borders[i].second]=color;\\n        }\\n        return grid;\\n\\n\\n\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&grid,vector<pair<int,int>>&borders,vector<vector<int>>&visited,int row,int col,int n,int m)\\n    {\\n\\n        int flag =0;\\n        if(row ==0 or col ==0 or row==n-1 or col==m-1)flag =1;\\n\\n        int count =0;\\n        visited[row][col]=1;\\n        int del_row[] = {-1,0,1,0};\\n        int del_col[] = {0,1,0,-1};\\n        for(int i=0;i<4;i++)\\n        {\\n            int ne_row = row+del_row[i];\\n            int ne_col = col+del_col[i];\\n            if(ne_row<n && ne_col <m && ne_row>=0 && ne_col >=0 && !visited[ne_row][ne_col] && grid[ne_row][ne_col]== grid[row][col])\\n            {\\n\\n\\n                dfs(grid,borders,visited,ne_row,ne_col,n,m);\\n            }\\n            if(ne_row<n && ne_col<m && ne_row>=0 && ne_col >=0 && grid[ne_row][ne_col]== grid[row][col])\\n            {\\n                count++;\\n            }\\n\\n        }\\n        \\n        if(flag ==1 or count<4)\\n        {\\n            borders.push_back({row,col});\\n        }\\n\\n\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size();\\n        int m = grid[0].size();\\n        vector<pair<int,int>>borders;\\n        vector<vector<int>>visited(n,vector<int>(m,0));\\n        dfs(grid,borders,visited,row,col,n,m);\\n        for(int i=0;i<borders.size();i++)\\n        {\\n            grid[borders[i].first][borders[i].second]=color;\\n        }\\n        return grid;\\n\\n\\n\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764382,
                "title": "clean-and-easy-c-bfs-solution-beats-40-of-users",
                "content": "# Intuition\\nApply BFS Algorithm in the grid and check whether the front element in the queue is a border square or not ,if yes color it with the given color.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,1,0,0};\\n    int dy[4]={0,0,1,-1};\\n\\n    bool is_valid(vector<vector<int>> &grid,int r,int c){\\n        if(r<0 || c<0 || r>=grid.size() || c>=grid[0].size()){\\n            return false;\\n        }\\n        return true;\\n    }\\n    bool is_border(vector<vector<int>> grid,int r,int c){\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int og=grid[r][c];\\n        if(r==0 || r==rows-1 || c==0 || c==cols-1){\\n            return true;\\n        }\\n\\n        if(grid[r+1][c]!=og || grid[r-1][c]!=og || grid[r][c-1]!=og || grid[r][c+1]!=og){\\n            return true;\\n        }\\n        return false;\\n\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<vector<int>> ans=grid;\\n        vector<vector<int>> visited(rows,vector<int>(cols,-1));\\n        visited[row][col]=1;\\n        int og=grid[row][col];\\n        while(!q.empty()){\\n            int size=q.size();\\n\\n            for(int i=0;i<size;i++){\\n                auto fro=q.front();\\n                q.pop();\\n                int r=fro.first;\\n                int c=fro.second;\\n\\n                if(is_border(grid,r,c)){\\n                    ans[r][c]=color;\\n                }\\n\\n                for(int j=0;j<4;j++){\\n                    int nr=r+dx[j];\\n                    int nc=c+dy[j];\\n\\nif(is_valid(grid,nr,nc) && visited[nr][nc]==-1 && grid[nr][nc]==og){\\n                visited[nr][nc]=1;\\n                q.push({nr,nc});\\n                }\\n\\n                }\\n            }\\n\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,1,0,0};\\n    int dy[4]={0,0,1,-1};\\n\\n    bool is_valid(vector<vector<int>> &grid,int r,int c){\\n        if(r<0 || c<0 || r>=grid.size() || c>=grid[0].size()){\\n            return false;\\n        }\\n        return true;\\n    }\\n    bool is_border(vector<vector<int>> grid,int r,int c){\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int og=grid[r][c];\\n        if(r==0 || r==rows-1 || c==0 || c==cols-1){\\n            return true;\\n        }\\n\\n        if(grid[r+1][c]!=og || grid[r-1][c]!=og || grid[r][c-1]!=og || grid[r][c+1]!=og){\\n            return true;\\n        }\\n        return false;\\n\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<vector<int>> ans=grid;\\n        vector<vector<int>> visited(rows,vector<int>(cols,-1));\\n        visited[row][col]=1;\\n        int og=grid[row][col];\\n        while(!q.empty()){\\n            int size=q.size();\\n\\n            for(int i=0;i<size;i++){\\n                auto fro=q.front();\\n                q.pop();\\n                int r=fro.first;\\n                int c=fro.second;\\n\\n                if(is_border(grid,r,c)){\\n                    ans[r][c]=color;\\n                }\\n\\n                for(int j=0;j<4;j++){\\n                    int nr=r+dx[j];\\n                    int nc=c+dy[j];\\n\\nif(is_valid(grid,nr,nc) && visited[nr][nc]==-1 && grid[nr][nc]==og){\\n                visited[nr][nc]=1;\\n                q.push({nr,nc});\\n                }\\n\\n                }\\n            }\\n\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755304,
                "title": "some-modifications-in-standard-dfs-c",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int r, int c, vector<vector<bool>> &vis, vector<vector<int>> &g, vector<vector<int>> &ans, int &OR_COL, int &newColor){\\n        int n=g.size(), m=g[0].size();\\n        vis[r][c]=1;\\n\\n        int delR[4] = {0,0,-1,1};\\n        int delC[4] = {1,-1,0,0};\\n\\n        for(int i=0; i<4; i++){\\n            int R = r+delR[i];\\n            int C = c+delC[i];\\n\\n            if(R<n&&R>=0&&C<m&&C>=0){\\n                if((R==0||C==m-1||R==n-1||C==0) && g[R][C]==OR_COL){\\n                    ans[R][C]=newColor;\\n                }\\n\\n                if(!vis[R][C] && g[R][C]==OR_COL) {\\n                    dfs(R,C,vis,g,ans,OR_COL,newColor);\\n                }\\n            }\\n        }\\n    }    \\n\\n    void colorRemaining(int r, int c, vector<vector<bool>> &vis, vector<vector<int>>& g, vector<vector<int>>& ans, int &newColor){\\n        int n=g.size(), m=g[0].size();\\n\\n        int delR[4] = {0,0,-1,1};\\n        int delC[4] = {1,-1,0,0};        \\n\\n        for(int i=0; i<4; i++){\\n            int R = r+delR[i];\\n            int C = c+delC[i];\\n\\n            if(R<n&&R>=0&&C<m&&C>=0 && vis[R][C]){\\n                ans[R][C]=newColor;\\n            }            \\n        }        \\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& g, int row, int col, int color) {\\n        int n=g.size(), m=g[0].size();\\n        int originalColor = g[row][col];\\n        vector<vector<int>> ans = g;\\n        vector<vector<bool>> vis(n,vector<bool>(m,0));\\n\\n        dfs(row,col,vis,g,ans,originalColor,color);\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(!vis[i][j]) colorRemaining(i,j,vis,g,ans,color);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(int r, int c, vector<vector<bool>> &vis, vector<vector<int>> &g, vector<vector<int>> &ans, int &OR_COL, int &newColor){\\n        int n=g.size(), m=g[0].size();\\n        vis[r][c]=1;\\n\\n        int delR[4] = {0,0,-1,1};\\n        int delC[4] = {1,-1,0,0};\\n\\n        for(int i=0; i<4; i++){\\n            int R = r+delR[i];\\n            int C = c+delC[i];\\n\\n            if(R<n&&R>=0&&C<m&&C>=0){\\n                if((R==0||C==m-1||R==n-1||C==0) && g[R][C]==OR_COL){\\n                    ans[R][C]=newColor;\\n                }\\n\\n                if(!vis[R][C] && g[R][C]==OR_COL) {\\n                    dfs(R,C,vis,g,ans,OR_COL,newColor);\\n                }\\n            }\\n        }\\n    }    \\n\\n    void colorRemaining(int r, int c, vector<vector<bool>> &vis, vector<vector<int>>& g, vector<vector<int>>& ans, int &newColor){\\n        int n=g.size(), m=g[0].size();\\n\\n        int delR[4] = {0,0,-1,1};\\n        int delC[4] = {1,-1,0,0};        \\n\\n        for(int i=0; i<4; i++){\\n            int R = r+delR[i];\\n            int C = c+delC[i];\\n\\n            if(R<n&&R>=0&&C<m&&C>=0 && vis[R][C]){\\n                ans[R][C]=newColor;\\n            }            \\n        }        \\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& g, int row, int col, int color) {\\n        int n=g.size(), m=g[0].size();\\n        int originalColor = g[row][col];\\n        vector<vector<int>> ans = g;\\n        vector<vector<bool>> vis(n,vector<bool>(m,0));\\n\\n        dfs(row,col,vis,g,ans,originalColor,color);\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(!vis[i][j]) colorRemaining(i,j,vis,g,ans,color);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754912,
                "title": "c-dfs-based-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int r, int c,int ol,int nc,vector<vector<int>>& grid,vector<vector<int>>& ans,vector<vector<int>> &vis)\\n    {\\n        vis[r][c]=1;\\n        int drow[4]={0,1,0,-1};\\n        int dcol[4]={1,0,-1,0};\\n        int cnt=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            int newr = r+drow[i];\\n            int newc = c+dcol[i];\\n            if(newr>=0 and newr<grid.size() and newc>=0 and newc<grid[0].size() and grid[newr][newc]==ol)\\n            {\\n                cnt++;\\n                if(vis[newr][newc]==0)\\n                dfs(newr,newc,ol,nc,grid,ans,vis);\\n            } \\n        }\\n        if(cnt<4)\\n        ans[r][c]=nc;\\n\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        vector<vector<int>> ans = grid;\\n        int p=grid[row][col];\\n        vector<vector<int>> vis(grid.size(),vector<int> (grid[0].size(),0));\\n        //if(p==color)return ans;\\n        dfs(row,col,p,color,grid,ans,vis);\\n        int n=grid.size();int m=grid[0].size();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int r, int c,int ol,int nc,vector<vector<int>>& grid,vector<vector<int>>& ans,vector<vector<int>> &vis)\\n    {\\n        vis[r][c]=1;\\n        int drow[4]={0,1,0,-1};\\n        int dcol[4]={1,0,-1,0};\\n        int cnt=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            int newr = r+drow[i];\\n            int newc = c+dcol[i];\\n            if(newr>=0 and newr<grid.size() and newc>=0 and newc<grid[0].size() and grid[newr][newc]==ol)\\n            {\\n                cnt++;\\n                if(vis[newr][newc]==0)\\n                dfs(newr,newc,ol,nc,grid,ans,vis);\\n            } \\n        }\\n        if(cnt<4)\\n        ans[r][c]=nc;\\n\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        vector<vector<int>> ans = grid;\\n        int p=grid[row][col];\\n        vector<vector<int>> vis(grid.size(),vector<int> (grid[0].size(),0));\\n        //if(p==color)return ans;\\n        dfs(row,col,p,color,grid,ans,vis);\\n        int n=grid.size();int m=grid[0].size();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752956,
                "title": "ruby-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# @param {Integer[][]} grid\\n# @param {Integer} row\\n# @param {Integer} col\\n# @param {Integer} color\\n# @return {Integer[][]}\\ndef color_border(grid, row, col, color)\\n   @main_color = grid[row][col]\\n   @output = Array.new(grid.size){Array.new(grid[0].size)}\\n   for i in 0..grid.size - 1\\n        for j in 0..grid[0].size - 1\\n            @output[i][j] = grid[i][j]\\n        end\\n    end\\n   visited = Array.new(grid.size){Array.new(grid[0].size)}\\n   dfs([row, col], grid, visited, color)\\n   @output\\nend\\n\\n\\ndef neighbours(location, row_length, col_length)\\n    nb = []\\n    nb << [location[0]+1, location[1]] if location[0] + 1 < row_length\\n    nb << [location[0]-1, location[1]] if location[0] > 0\\n    nb << [location[0], location[1]+1] if location[1] + 1 < col_length\\n    nb << [location[0], location[1]-1] if location[1] > 0\\n    nb\\nend\\n\\ndef dfs(loc, grid, visited, color)\\n    visited[loc[0]][loc[1]] = true\\n    nbrs = neighbours(loc, grid.size, grid[0].size)\\n\\n    if (loc[0] == 0 || loc[0] == grid.size - 1) || (loc[1] == 0 || loc[1] == grid[0].size - 1)\\n        @output[loc[0]][loc[1]] = color\\n    else\\n        for nb in nbrs\\n            if @main_color != grid[nb[0]][nb[1]]            \\n                @output[loc[0]][loc[1]] = color\\n                break\\n            end\\n        end\\n    end\\n\\n    for nb in nbrs\\n        if @main_color == grid[nb[0]][nb[1]] && !visited[nb[0]][nb[1]]\\n            dfs([nb[0],nb[1]], grid, visited, color)\\n        end\\n    end\\n\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[][]} grid\\n# @param {Integer} row\\n# @param {Integer} col\\n# @param {Integer} color\\n# @return {Integer[][]}\\ndef color_border(grid, row, col, color)\\n   @main_color = grid[row][col]\\n   @output = Array.new(grid.size){Array.new(grid[0].size)}\\n   for i in 0..grid.size - 1\\n        for j in 0..grid[0].size - 1\\n            @output[i][j] = grid[i][j]\\n        end\\n    end\\n   visited = Array.new(grid.size){Array.new(grid[0].size)}\\n   dfs([row, col], grid, visited, color)\\n   @output\\nend\\n\\n\\ndef neighbours(location, row_length, col_length)\\n    nb = []\\n    nb << [location[0]+1, location[1]] if location[0] + 1 < row_length\\n    nb << [location[0]-1, location[1]] if location[0] > 0\\n    nb << [location[0], location[1]+1] if location[1] + 1 < col_length\\n    nb << [location[0], location[1]-1] if location[1] > 0\\n    nb\\nend\\n\\ndef dfs(loc, grid, visited, color)\\n    visited[loc[0]][loc[1]] = true\\n    nbrs = neighbours(loc, grid.size, grid[0].size)\\n\\n    if (loc[0] == 0 || loc[0] == grid.size - 1) || (loc[1] == 0 || loc[1] == grid[0].size - 1)\\n        @output[loc[0]][loc[1]] = color\\n    else\\n        for nb in nbrs\\n            if @main_color != grid[nb[0]][nb[1]]            \\n                @output[loc[0]][loc[1]] = color\\n                break\\n            end\\n        end\\n    end\\n\\n    for nb in nbrs\\n        if @main_color == grid[nb[0]][nb[1]] && !visited[nb[0]][nb[1]]\\n            dfs([nb[0],nb[1]], grid, visited, color)\\n        end\\n    end\\n\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3729607,
                "title": "c-dfs-easy",
                "content": "simple dfs , just check for border and the given condition\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   void dfs(int row , int col , int color , vector<vector<int>>& vis , vector<vector<int>>& grid , int ogcolor){\\n       int n = grid.size();\\n       int m = grid[0].size();\\n\\n       vis[row][col] = 1;\\n\\n       int delrow[] = {1,0,-1,0};\\n       int delcol[] = {0,-1,0,1};\\n\\n       for(int i = 0 ; i < 4 ; i++){\\n           int nrow = row + delrow[i];\\n           int ncol = col + delcol[i];\\n           if(nrow < 0 || ncol < 0 || nrow >= n || ncol >= m || (grid[nrow][ncol] != ogcolor and !vis[nrow][ncol])){\\n                grid[row][col] = color;\\n           } \\n       }\\n       for(int i = 0 ; i < 4 ; i++){\\n           int nrow = row + delrow[i];\\n           int ncol = col + delcol[i];\\n           if(nrow >= 0 and ncol >= 0 and nrow < n and ncol < m and grid[nrow][ncol] == ogcolor and !vis[nrow][ncol]){\\n               vis[nrow][ncol] = 1;\\n                dfs(nrow,ncol,color,vis,grid,ogcolor);\\n           } \\n       }\\n   }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        dfs(row,col,color,vis,grid,grid[row][col]);\\n        return grid;\\n    }\\n};\\n/*\\n1 2 1 2 1 2\\n2 2 2 2 1 2\\n1 2 2 2 1 2\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   void dfs(int row , int col , int color , vector<vector<int>>& vis , vector<vector<int>>& grid , int ogcolor){\\n       int n = grid.size();\\n       int m = grid[0].size();\\n\\n       vis[row][col] = 1;\\n\\n       int delrow[] = {1,0,-1,0};\\n       int delcol[] = {0,-1,0,1};\\n\\n       for(int i = 0 ; i < 4 ; i++){\\n           int nrow = row + delrow[i];\\n           int ncol = col + delcol[i];\\n           if(nrow < 0 || ncol < 0 || nrow >= n || ncol >= m || (grid[nrow][ncol] != ogcolor and !vis[nrow][ncol])){\\n                grid[row][col] = color;\\n           } \\n       }\\n       for(int i = 0 ; i < 4 ; i++){\\n           int nrow = row + delrow[i];\\n           int ncol = col + delcol[i];\\n           if(nrow >= 0 and ncol >= 0 and nrow < n and ncol < m and grid[nrow][ncol] == ogcolor and !vis[nrow][ncol]){\\n               vis[nrow][ncol] = 1;\\n                dfs(nrow,ncol,color,vis,grid,ogcolor);\\n           } \\n       }\\n   }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        dfs(row,col,color,vis,grid,grid[row][col]);\\n        return grid;\\n    }\\n};\\n/*\\n1 2 1 2 1 2\\n2 2 2 2 1 2\\n1 2 2 2 1 2\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729232,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        queue<pair<int,int>> q;\\n        q.push({row, col});\\n        int iniCol = grid[row][col];\\n\\n        vector<int> dx = {0 , 1 , 0 , -1};\\n        vector<int> dy = {-1 , 0 , 1 , 0};\\n        vector<vector<int>> vis(m , vector<int> (n , 0));\\n        vis[row][col] = 1;\\n\\n        while (!q.empty()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            bool temp = false;\\n            if (r==m-1 || r==0 || c==n-1 || c==0)\\n                temp = true;\\n\\n            bool flag = false;\\n            for (int i=0 ; i<4 ; i++){\\n                int nr = r + dx[i];\\n                int nc = c + dy[i];\\n                if (nr>=0 && nr<m && nc>=0 && nc<n && !vis[nr][nc]){\\n                    if (grid[nr][nc]==iniCol){\\n                        vis[nr][nc] = 1;\\n                        q.push({nr,nc});\\n                    }\\n                    else{\\n                        flag = true;\\n                    }\\n                }\\n            }\\n            if (flag || temp)\\n                grid[r][c] = color;\\n        }\\n        return grid;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        queue<pair<int,int>> q;\\n        q.push({row, col});\\n        int iniCol = grid[row][col];\\n\\n        vector<int> dx = {0 , 1 , 0 , -1};\\n        vector<int> dy = {-1 , 0 , 1 , 0};\\n        vector<vector<int>> vis(m , vector<int> (n , 0));\\n        vis[row][col] = 1;\\n\\n        while (!q.empty()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            bool temp = false;\\n            if (r==m-1 || r==0 || c==n-1 || c==0)\\n                temp = true;\\n\\n            bool flag = false;\\n            for (int i=0 ; i<4 ; i++){\\n                int nr = r + dx[i];\\n                int nc = c + dy[i];\\n                if (nr>=0 && nr<m && nc>=0 && nc<n && !vis[nr][nc]){\\n                    if (grid[nr][nc]==iniCol){\\n                        vis[nr][nc] = 1;\\n                        q.push({nr,nc});\\n                    }\\n                    else{\\n                        flag = true;\\n                    }\\n                }\\n            }\\n            if (flag || temp)\\n                grid[r][c] = color;\\n        }\\n        return grid;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716069,
                "title": "c-very-simple-bfs-explained",
                "content": "# Intuition\\nThe goal is to color the border cells and cells adjacent to different colors with the target color. To achieve this, we can use Breadth-First Search (BFS) starting from the given cell.\\n\\n\\n# Approach\\nPush the starting cell coordinates into the queue, mark it as visited, and store its color as the original color.\\n\\nPerform BFS traversal:\\n\\nWhile the queue is not empty, do the following:\\nExtract the front element from the queue, representing the current cell coordinates.\\n\\nCheck if the current cell is on the border or adjacent to a different color:\\nInitialize the isBorder flag to check if the cell is on the border (first or last row/column).\\nInitialize the isAdjacentToDifferentColor flag to track if the cell is adjacent to a different color.\\n\\nIterate through the four directions:\\nCalculate the new row and column coordinates.\\nIf the new coordinates are within the grid boundaries and the cell is unvisited:\\n\\nCheck if the cell has the original color.\\nIf so, push it into the queue, mark it as visited, and continue the BFS traversal.\\n\\nOtherwise, set the isAdjacentToDifferentColor flag to true.\\nIf the current cell is on the border or adjacent to a different color, update its color to the target color.\\n\\nAfter the BFS traversal is complete, return the modified grid.\\n# Complexity\\n- Time complexity:\\n O(n * m)\\n- Space complexity:\\n O(n * m)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m,n;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        queue<pair<int, int>> q;\\n        q.push({row, col});\\n        visited[row][col] = true;\\n\\n        while (!q.empty()) {\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            //checking if the row or coloumn are border or not, initially keeping it false.\\n            bool isb=false;\\n            if(r == 0 || r == m - 1 || c == 0 || c ==n - 1)\\n            isb =true;\\n            //initially we keep adj as false, this tells us whether the cell is adjacent to some cell which is not of the same color to any side, that is the outline of the connected component.\\n            bool isad = false;\\n\\n            for (int k = 0; k < 4; k++) {\\n                //iterating on all 4 directions\\n                int nr = r + delr[k];\\n                int nc = c + delc[k];\\n\\n                if (nr >= 0 && nc >= 0 && nr < m && nc < n) {\\n                    if (!visited[nr][nc]) {\\n                        //checking if the new cell is connected component or not, if yes, we take it into consideration for the next iteration and push in the queue.\\n                        if (grid[nr][nc] == originalColor) {\\n                            q.push({nr, nc});\\n                            visited[nr][nc] = true;\\n                        } else {\\n                            //if not connected then we have found one cell which is the outline of the connected component.\\n                            isad = true;\\n                        }\\n                    }\\n                }\\n            }\\n            //at last we are just coloring all the cells are which are either border cells or the outline of the connected component.\\n            if (isb || isad) {\\n                grid[r][c] = color;\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m,n;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        queue<pair<int, int>> q;\\n        q.push({row, col});\\n        visited[row][col] = true;\\n\\n        while (!q.empty()) {\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            //checking if the row or coloumn are border or not, initially keeping it false.\\n            bool isb=false;\\n            if(r == 0 || r == m - 1 || c == 0 || c ==n - 1)\\n            isb =true;\\n            //initially we keep adj as false, this tells us whether the cell is adjacent to some cell which is not of the same color to any side, that is the outline of the connected component.\\n            bool isad = false;\\n\\n            for (int k = 0; k < 4; k++) {\\n                //iterating on all 4 directions\\n                int nr = r + delr[k];\\n                int nc = c + delc[k];\\n\\n                if (nr >= 0 && nc >= 0 && nr < m && nc < n) {\\n                    if (!visited[nr][nc]) {\\n                        //checking if the new cell is connected component or not, if yes, we take it into consideration for the next iteration and push in the queue.\\n                        if (grid[nr][nc] == originalColor) {\\n                            q.push({nr, nc});\\n                            visited[nr][nc] = true;\\n                        } else {\\n                            //if not connected then we have found one cell which is the outline of the connected component.\\n                            isad = true;\\n                        }\\n                    }\\n                }\\n            }\\n            //at last we are just coloring all the cells are which are either border cells or the outline of the connected component.\\n            if (isb || isad) {\\n                grid[r][c] = color;\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673871,
                "title": "c-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool is_safe(int i,int j,int row,int col){\\n    if(i<0 ||j<0 || i>=row || j>=col)return false;\\n    return true;\\n}\\nint deli[4]={0,1,0,-1};\\nint delj[4]={1,0,-1,0};\\nvoid dfs(int i,int j,int row,int col,int curcol,int newcol,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& ggrid){\\n    int temp=0;\\n    for(int k=0;k<4;k++){\\n        int new_i=i+deli[k];\\n        int new_j=j+delj[k];\\n        if(is_safe(new_i,new_j,row,col)&&grid[new_i][new_j]==curcol)temp++;\\n    }\\n    if(temp!=4)ggrid[i][j]=newcol;\\n    for(int k=0;k<4;k++){\\n        int new_i=i+deli[k];\\n        int new_j=j+delj[k];\\n        if(is_safe(new_i,new_j,row,col)&&grid[new_i][new_j]==curcol && !vis[new_i][new_j]){\\n            vis[new_i][new_j]=1;\\n            dfs(new_i,new_j,row,col,curcol,newcol,grid,vis,ggrid);\\n        }\\n    }\\n    \\n}\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int i, int j, int newcol) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        int curcol=grid[i][j];\\n        if (curcol==newcol)return grid;\\n        vector<vector<int>>vis(row,vector<int>(col,0));\\n        vector<vector<int>>ggrid(row,vector<int>(col,0));\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                ggrid[i][j]=grid[i][j];\\n            }\\n        }\\n        vis[i][j]=1;\\n        dfs(i,j,row,col,curcol,newcol,grid,vis,ggrid);\\n        return ggrid;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool is_safe(int i,int j,int row,int col){\\n    if(i<0 ||j<0 || i>=row || j>=col)return false;\\n    return true;\\n}\\nint deli[4]={0,1,0,-1};\\nint delj[4]={1,0,-1,0};\\nvoid dfs(int i,int j,int row,int col,int curcol,int newcol,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& ggrid){\\n    int temp=0;\\n    for(int k=0;k<4;k++){\\n        int new_i=i+deli[k];\\n        int new_j=j+delj[k];\\n        if(is_safe(new_i,new_j,row,col)&&grid[new_i][new_j]==curcol)temp++;\\n    }\\n    if(temp!=4)ggrid[i][j]=newcol;\\n    for(int k=0;k<4;k++){\\n        int new_i=i+deli[k];\\n        int new_j=j+delj[k];\\n        if(is_safe(new_i,new_j,row,col)&&grid[new_i][new_j]==curcol && !vis[new_i][new_j]){\\n            vis[new_i][new_j]=1;\\n            dfs(new_i,new_j,row,col,curcol,newcol,grid,vis,ggrid);\\n        }\\n    }\\n    \\n}\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int i, int j, int newcol) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        int curcol=grid[i][j];\\n        if (curcol==newcol)return grid;\\n        vector<vector<int>>vis(row,vector<int>(col,0));\\n        vector<vector<int>>ggrid(row,vector<int>(col,0));\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                ggrid[i][j]=grid[i][j];\\n            }\\n        }\\n        vis[i][j]=1;\\n        dfs(i,j,row,col,curcol,newcol,grid,vis,ggrid);\\n        return ggrid;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655448,
                "title": "c-dfs-graph-easy-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\nint row[4] = {1, -1, 0, 0};\\nint col[4] = {0, 0, 1, -1};\\n\\nvoid dfs(vector<vector<int>>& grid, vector<vector<int>>& visited, int i, int j, int &target, int& color){\\n    if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() || visited[i][j]==1 || grid[i][j]!=target)\\n    return;\\n\\n    visited[i][j] = 1;\\n    bool flag = 0;\\n\\n    for(int p = 0 ;p<4 ;p++){\\n        int newX = i+row[p];\\n        int newY = j+col[p];\\n\\n        if(i==0 || i==grid.size()-1 || j==0 || j==grid[0].size()-1 || (visited[newX][newY] == 0 && grid[i][j]!=grid[newX][newY]) )\\n        flag = 1;\\n\\n        dfs(grid, visited, newX, newY, target, color);\\n    }\\n\\n    if(flag)\\n    grid[i][j] = color;  \\n}\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        \\n        int target = grid[row][col];\\n        vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(), 0));\\n        \\n        dfs(grid, visited, row, col, target, color);\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint row[4] = {1, -1, 0, 0};\\nint col[4] = {0, 0, 1, -1};\\n\\nvoid dfs(vector<vector<int>>& grid, vector<vector<int>>& visited, int i, int j, int &target, int& color){\\n    if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() || visited[i][j]==1 || grid[i][j]!=target)\\n    return;\\n\\n    visited[i][j] = 1;\\n    bool flag = 0;\\n\\n    for(int p = 0 ;p<4 ;p++){\\n        int newX = i+row[p];\\n        int newY = j+col[p];\\n\\n        if(i==0 || i==grid.size()-1 || j==0 || j==grid[0].size()-1 || (visited[newX][newY] == 0 && grid[i][j]!=grid[newX][newY]) )\\n        flag = 1;\\n\\n        dfs(grid, visited, newX, newY, target, color);\\n    }\\n\\n    if(flag)\\n    grid[i][j] = color;  \\n}\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        \\n        int target = grid[row][col];\\n        vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(), 0));\\n        \\n        dfs(grid, visited, row, col, target, color);\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642008,
                "title": "2-bfs-traversal-in-a-single-question-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        //at first visit all the nodes which have the color = oldcolor and connected to current component \\n        queue<pair<int,int>>q;\\n        vector<pair<int,int>>v;\\n        q.push({row,col});\\n        int oldcolor = grid[row][col];\\n        int delrow[4] = {0,-1,0,+1};\\n        int delcol[4] = {+1,0,-1,0};\\n        vis[row][col] = 1;\\n        //after getting all the nodes of the current component please check which of those nodes lie in the circle \\n        while(q.empty() == false){\\n            int row = q.front().first ;\\n            int col = q.front().second;\\n            v.push_back(make_pair(row,col));\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<m \\n                && !vis[nrow][ncol] && grid[nrow][ncol] == oldcolor){\\n                    vis[nrow][ncol] = 1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n        //now inside v i have got all the nodes which are connected to the current compnent \\n        //and all those nodes have the color oldcolor\\n\\n        //now i have to check all the nodes in the current component which are boundary nodes \\n\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vis[i][j] = 0;\\n            }\\n        }\\n        for(int i=0;i<v.size();i++){\\n            q.push({v[i].first,v[i].second});\\n            cout<<v[i].first<<\" \"<<v[i].second<<endl;\\n            vis[v[i].first][v[i].second] = 1;\\n        }\\n        cout<<v.size()<<endl;\\n        vector<vector<int>> arr = grid;\\n        while(q.empty() == false){\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            if(row == 0 || col == 0 || row == n-1 || col == m-1){\\n                arr[row][col] = color;\\n                q.pop();\\n                continue;\\n            }\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<m){\\n                    if(grid[nrow][ncol]!=oldcolor){\\n                        arr[row][col] = color;\\n                    }\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        //at first visit all the nodes which have the color = oldcolor and connected to current component \\n        queue<pair<int,int>>q;\\n        vector<pair<int,int>>v;\\n        q.push({row,col});\\n        int oldcolor = grid[row][col];\\n        int delrow[4] = {0,-1,0,+1};\\n        int delcol[4] = {+1,0,-1,0};\\n        vis[row][col] = 1;\\n        //after getting all the nodes of the current component please check which of those nodes lie in the circle \\n        while(q.empty() == false){\\n            int row = q.front().first ;\\n            int col = q.front().second;\\n            v.push_back(make_pair(row,col));\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<m \\n                && !vis[nrow][ncol] && grid[nrow][ncol] == oldcolor){\\n                    vis[nrow][ncol] = 1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n        //now inside v i have got all the nodes which are connected to the current compnent \\n        //and all those nodes have the color oldcolor\\n\\n        //now i have to check all the nodes in the current component which are boundary nodes \\n\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vis[i][j] = 0;\\n            }\\n        }\\n        for(int i=0;i<v.size();i++){\\n            q.push({v[i].first,v[i].second});\\n            cout<<v[i].first<<\" \"<<v[i].second<<endl;\\n            vis[v[i].first][v[i].second] = 1;\\n        }\\n        cout<<v.size()<<endl;\\n        vector<vector<int>> arr = grid;\\n        while(q.empty() == false){\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            if(row == 0 || col == 0 || row == n-1 || col == m-1){\\n                arr[row][col] = color;\\n                q.pop();\\n                continue;\\n            }\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<m){\\n                    if(grid[nrow][ncol]!=oldcolor){\\n                        arr[row][col] = color;\\n                    }\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3569737,
                "title": "c-fast-dfs",
                "content": "\\nclass Solution  {\\n\\npublic:\\n\\n    void dfs(int row,int col,int clr,vector<vector<int>>& grid){\\n        grid[row][col] = -clr;\\n        int count = 0;\\n        int r[] = {-1,0,1,0};\\n        int c[] = {0,+1,0,-1};\\n        for(int i=0;i<4;i++){\\n            int adjr = row + r[i];\\n            int adjc = col + c[i];\\n            if(adjr<0||adjr>=grid.size()||adjc<0 || adjc>=grid[0].size() || abs(grid[adjr][adjc]) != clr)\\n            {\\n                continue;\\n            }\\n            count++;\\n            if(grid[adjr][adjc] == clr)\\n                dfs(adjr,adjc,clr,grid);\\n        }\\n        if(count==4){\\n            grid[row][col] = clr;\\n        }\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        dfs(row,col,grid[row][col],grid);\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j] < 0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution  {\\n\\npublic:\\n\\n    void dfs(int row,int col,int clr,vector<vector<int>>& grid){\\n        grid[row][col] = -clr;\\n        int count = 0;\\n        int r[] = {-1,0,1,0}",
                "codeTag": "Java"
            },
            {
                "id": 3561284,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int dx[4] = {0,1,0,-1};\\n    int dy[4] = {1,0,-1,0};\\n    void dfs(vector<vector<int>>& grid, int x, int y, int num){\\n        grid[x][y]= -num;\\n        int cnt=0;\\n        for(int i=0; i<4; ++i){\\n            int x1 = x+dx[i], y1=y+dy[i];\\n            if(x1<0 || x1>=grid.size() || y1<0 || y1>=grid[0].size() || abs(grid[x1][y1]) != num) continue;\\n            cnt+=1;\\n            if(grid[x1][y1] != -num)dfs(grid,x1,y1,num);\\n        }\\n        if(cnt==4) grid[x][y] = num;\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int num = grid[row][col];\\n        dfs(grid,row,col,num);\\n        for(int i=0; i<grid.size(); ++i){\\n            for(int j=0; j<grid[0].size(); ++j){\\n                if(grid[i][j] == -num) grid[i][j]=color;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        M, N = len(grid), len(grid[0])\\n        q = collections.deque()\\n        q.append((row, col))\\n        dir_lst = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        seen = set()\\n        seen.add((row, col))\\n        border = set()\\n        while q:\\n            i, j = q.popleft()\\n            is_border = i in [0, M-1] or j in [0, N-1]\\n            for di, dj in dir_lst:\\n                ni, nj = i+di, j+dj\\n                if 0<=ni<M and 0<=nj<N and (ni, nj) not in seen:\\n                    if grid[ni][nj]!=grid[i][j]:\\n                        is_border = True\\n                    else:\\n                        seen.add((ni, nj))\\n                        q.append((ni, nj))\\n            if is_border:\\n                border.add((i, j))\\n        \\n        for i, j in border:\\n            grid[i][j] = color\\n        return grid\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        if (grid[row][col]==color)\\n            return grid;\\n        \\n        boolean[][] visited = new boolean[n][m];\\n        dfs(grid,row,col,grid[row][col],visited,color,n,m);\\n\\n        return grid;\\n    }\\n    void dfs(int[][] grid,int i,int j,int oldColor,boolean[][] visited,int targetColor,int n,int m) {\\n        if (i>=n || i<0 || j<0 || j>=m || grid[i][j]!=oldColor || visited[i][j])\\n            return;\\n        \\n        visited[i][j] = true;\\n        boolean border = false;\\n\\n        if (i==0 || j==0 || j==m-1 || i==n-1 || grid[i+1][j]!=oldColor || grid[i-1][j]!=oldColor || grid[i][j-1]!=oldColor || grid[i][j+1]!=oldColor)\\n            border = true;\\n        \\n        dfs(grid,i+1,j,oldColor,visited,targetColor,n,m);\\n        dfs(grid,i-1,j,oldColor,visited,targetColor,n,m);\\n        dfs(grid,i,j+1,oldColor,visited,targetColor,n,m);\\n        dfs(grid,i,j-1,oldColor,visited,targetColor,n,m);\\n\\n        if (border)\\n            grid[i][j] = targetColor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int dx[4] = {0,1,0,-1};\\n    int dy[4] = {1,0,-1,0};\\n    void dfs(vector<vector<int>>& grid, int x, int y, int num){\\n        grid[x][y]= -num;\\n        int cnt=0;\\n        for(int i=0; i<4; ++i){\\n            int x1 = x+dx[i], y1=y+dy[i];\\n            if(x1<0 || x1>=grid.size() || y1<0 || y1>=grid[0].size() || abs(grid[x1][y1]) != num) continue;\\n            cnt+=1;\\n            if(grid[x1][y1] != -num)dfs(grid,x1,y1,num);\\n        }\\n        if(cnt==4) grid[x][y] = num;\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int num = grid[row][col];\\n        dfs(grid,row,col,num);\\n        for(int i=0; i<grid.size(); ++i){\\n            for(int j=0; j<grid[0].size(); ++j){\\n                if(grid[i][j] == -num) grid[i][j]=color;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        M, N = len(grid), len(grid[0])\\n        q = collections.deque()\\n        q.append((row, col))\\n        dir_lst = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        seen = set()\\n        seen.add((row, col))\\n        border = set()\\n        while q:\\n            i, j = q.popleft()\\n            is_border = i in [0, M-1] or j in [0, N-1]\\n            for di, dj in dir_lst:\\n                ni, nj = i+di, j+dj\\n                if 0<=ni<M and 0<=nj<N and (ni, nj) not in seen:\\n                    if grid[ni][nj]!=grid[i][j]:\\n                        is_border = True\\n                    else:\\n                        seen.add((ni, nj))\\n                        q.append((ni, nj))\\n            if is_border:\\n                border.add((i, j))\\n        \\n        for i, j in border:\\n            grid[i][j] = color\\n        return grid\\n```\n```Java []\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        if (grid[row][col]==color)\\n            return grid;\\n        \\n        boolean[][] visited = new boolean[n][m];\\n        dfs(grid,row,col,grid[row][col],visited,color,n,m);\\n\\n        return grid;\\n    }\\n    void dfs(int[][] grid,int i,int j,int oldColor,boolean[][] visited,int targetColor,int n,int m) {\\n        if (i>=n || i<0 || j<0 || j>=m || grid[i][j]!=oldColor || visited[i][j])\\n            return;\\n        \\n        visited[i][j] = true;\\n        boolean border = false;\\n\\n        if (i==0 || j==0 || j==m-1 || i==n-1 || grid[i+1][j]!=oldColor || grid[i-1][j]!=oldColor || grid[i][j-1]!=oldColor || grid[i][j+1]!=oldColor)\\n            border = true;\\n        \\n        dfs(grid,i+1,j,oldColor,visited,targetColor,n,m);\\n        dfs(grid,i-1,j,oldColor,visited,targetColor,n,m);\\n        dfs(grid,i,j+1,oldColor,visited,targetColor,n,m);\\n        dfs(grid,i,j-1,oldColor,visited,targetColor,n,m);\\n\\n        if (border)\\n            grid[i][j] = targetColor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513135,
                "title": "souvik-hazra-coloring-a-border",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        if (pre := grid[row][col]) == color:\\n            return grid\\n        m, n, d = len(grid), len(grid[0]), [(0, -1), (0, 1), (1, 0), (-1, 0)]\\n        visited = [[False] * n for _ in range(m)]\\n        \\n        def dfs(x: int, y: int) -> None:\\n            if not -1 < x < m or not -1 < y < n or grid[x][y] != pre:\\n                return\\n            grid[x][y], visited[x][y] = color, True\\n            for dx, dy in d:\\n                dfs(x + dx, y + dy)        \\n        dfs(row, col)\\n        for i in range(1, m - 1):\\n            for j in range(1, n - 1):\\n                if visited[i][j] and all(visited[i + dx][j + dy] for dx, dy in d):\\n                    grid[i][j] = pre\\n        return grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        if (pre := grid[row][col]) == color:\\n            return grid\\n        m, n, d = len(grid), len(grid[0]), [(0, -1), (0, 1), (1, 0), (-1, 0)]\\n        visited = [[False] * n for _ in range(m)]\\n        \\n        def dfs(x: int, y: int) -> None:\\n            if not -1 < x < m or not -1 < y < n or grid[x][y] != pre:\\n                return\\n            grid[x][y], visited[x][y] = color, True\\n            for dx, dy in d:\\n                dfs(x + dx, y + dy)        \\n        dfs(row, col)\\n        for i in range(1, m - 1):\\n            for j in range(1, n - 1):\\n                if visited[i][j] and all(visited[i + dx][j + dy] for dx, dy in d):\\n                    grid[i][j] = pre\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501355,
                "title": "i-am-trying-with-no-extra-space-but-getting-wrong-answer-can-someone-help-me",
                "content": "\\nm, n is grid size\\nc is color that is to be coloured on the perimeter\\nc1 is color that need to replaced\\n\\nThis code is giving WA at 150/154 case.\\n```\\nclass Solution {\\npublic:\\n    int c,m,n,c1;\\n    void solve(vector<vector<int>> &grid, int row,int col){\\n        if(row<0 || row>=m || col<0 || col>=n || grid[row][col]!=c1)return;\\n        grid[row][col] = -c1;\\n        bool tocolor = false;\\n\\n        if(row+1>=m || row-1<0 || col+1>=n || col-1<0){\\n            tocolor = true;\\n        }else if(abs(grid[row+1][col])!=c1 ||\\n                abs(grid[row-1][col])!=c1  ||\\n                abs(grid[row][col-1])!=c1  ||\\n                abs(grid[row][col+1])!=c1){\\n            tocolor=true;\\n        }\\n\\n        solve(grid,row+1,col);\\n        solve(grid,row,col-1);\\n        solve(grid,row-1,col);\\n        solve(grid,row,col+1);\\n\\n        if(tocolor)grid[row][col] = c;\\n        else grid[row][col]*=-1;\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        c = color;\\n        c1=grid[row][col];\\n        m=grid.size(),n=grid[0].size();\\n        solve(grid,row,col);\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int c,m,n,c1;\\n    void solve(vector<vector<int>> &grid, int row,int col){\\n        if(row<0 || row>=m || col<0 || col>=n || grid[row][col]!=c1)return;\\n        grid[row][col] = -c1;\\n        bool tocolor = false;\\n\\n        if(row+1>=m || row-1<0 || col+1>=n || col-1<0){\\n            tocolor = true;\\n        }else if(abs(grid[row+1][col])!=c1 ||\\n                abs(grid[row-1][col])!=c1  ||\\n                abs(grid[row][col-1])!=c1  ||\\n                abs(grid[row][col+1])!=c1){\\n            tocolor=true;\\n        }\\n\\n        solve(grid,row+1,col);\\n        solve(grid,row,col-1);\\n        solve(grid,row-1,col);\\n        solve(grid,row,col+1);\\n\\n        if(tocolor)grid[row][col] = c;\\n        else grid[row][col]*=-1;\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        c = color;\\n        c1=grid[row][col];\\n        m=grid.size(),n=grid[0].size();\\n        solve(grid,row,col);\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478110,
                "title": "coloring-a-border",
                "content": "------------------ Easy C++ Solution ------------------\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n\\n- Space complexity: $$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0,int color) {\\n    dfs(grid, r0, c0, grid[r0][c0]);\\n\\n    for (int i = 0; i < grid.size(); ++i)\\n      for (int j = 0; j < grid[0].size(); ++j)\\n        if(grid[i][j] < 0)\\n          grid[i][j] = color;\\n\\n    return grid;\\n  }\\n\\n private:\\n  void dfs(vector<vector<int>>& grid, int i, int j, int startColor) {\\n    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())\\n      return;\\n    if (grid[i][j] != startColor)\\n      return;\\n\\n    grid[i][j] = -startColor;\\n    dfs(grid, i + 1, j, startColor);\\n    dfs(grid, i - 1, j, startColor);\\n    dfs(grid, i, j + 1, startColor);\\n    dfs(grid, i, j - 1, startColor);\\n\\n    if (i == 0 || i == grid.size() - 1 || j == 0 || j == grid[0].size() - 1)\\n      return;\\n\\n    if (abs(grid[i + 1][j]) == startColor &&  abs(grid[i - 1][j]) == startColor && abs(grid[i][j + 1]) == startColor &&   abs(grid[i][j - 1]) == startColor)\\n      grid[i][j] = startColor;\\n  }\\n};\\n// [\\n// [1,1],\\n// [1,2]\\n// ]\\n// [\\n// [3,3],\\n// [3,2]\\n// ]\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0,int color) {\\n    dfs(grid, r0, c0, grid[r0][c0]);\\n\\n    for (int i = 0; i < grid.size(); ++i)\\n      for (int j = 0; j < grid[0].size(); ++j)\\n        if(grid[i][j] < 0)\\n          grid[i][j] = color;\\n\\n    return grid;\\n  }\\n\\n private:\\n  void dfs(vector<vector<int>>& grid, int i, int j, int startColor) {\\n    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())\\n      return;\\n    if (grid[i][j] != startColor)\\n      return;\\n\\n    grid[i][j] = -startColor;\\n    dfs(grid, i + 1, j, startColor);\\n    dfs(grid, i - 1, j, startColor);\\n    dfs(grid, i, j + 1, startColor);\\n    dfs(grid, i, j - 1, startColor);\\n\\n    if (i == 0 || i == grid.size() - 1 || j == 0 || j == grid[0].size() - 1)\\n      return;\\n\\n    if (abs(grid[i + 1][j]) == startColor &&  abs(grid[i - 1][j]) == startColor && abs(grid[i][j + 1]) == startColor &&   abs(grid[i][j - 1]) == startColor)\\n      grid[i][j] = startColor;\\n  }\\n};\\n// [\\n// [1,1],\\n// [1,2]\\n// ]\\n// [\\n// [3,3],\\n// [3,2]\\n// ]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399098,
                "title": "c-simple-to-understand",
                "content": "# Intuition\\nMark the island, calculate gradient in r,c direction. Any non 0 numbers means point r,c is on border\\n\\n# Approach\\nBFS to mark an island. Gradient dr = map[r] - map[r - 1], same for columns. Any non zero dr or dc means we are on border of found island.\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n) - you can optimize it all a bit and use original grid and negative numbers to save on separate visited grid.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        static const vector<pair<int, int>> D = { {-1, 0}, {+1, 0}, {0, -1}, {0, +1} };\\n        const int testColor = grid[row][col];\\n\\n        const int R = grid.size();\\n        const int C = grid[0].size();\\n\\n        vector<vector<int>> visited(R, vector<int>(C, 0));\\n        queue<pair<int, int>> q;\\n        \\n        q.push( {row, col} );\\n        visited[row][col] = 1;\\n        while (!q.empty()) {\\n            auto p = q.front();\\n            q.pop();\\n\\n            for (auto d: D) {\\n                int nr = p.first + d.first;\\n                int nc = p.second + d.second;\\n\\n                if (nr < 0 || nr == R || nc < 0 || nc == C) {\\n                    continue;\\n                }\\n\\n                if (!visited[nr][nc] && grid[nr][nc] == testColor) {\\n                    q.push( {nr, nc} );\\n                    visited[nr][nc] = 1;\\n                }\\n            }\\n        }\\n\\n        for (int r = 0;r < R;r ++) {\\n            for (int c = 0;c < C;c ++) {\\n                if (visited[r][c] == 0) {\\n                    continue;\\n                }\\n\\n                int rm = r - 1;\\n                int rp = r + 1;\\n                int cm = c - 1;\\n                int cp = c + 1;\\n\\n                if (\\n                    (rm < 0 || visited[rm][c] == 0) || (rp == R || visited[rp][c] == 0) || \\n                    (cm < 0 || visited[r][cm] == 0) || (cp == C || visited[r][cp] == 0)\\n                   ) \\n                {\\n                    grid[r][c] = color;\\n                }\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        static const vector<pair<int, int>> D = { {-1, 0}, {+1, 0}, {0, -1}, {0, +1} };\\n        const int testColor = grid[row][col];\\n\\n        const int R = grid.size();\\n        const int C = grid[0].size();\\n\\n        vector<vector<int>> visited(R, vector<int>(C, 0));\\n        queue<pair<int, int>> q;\\n        \\n        q.push( {row, col} );\\n        visited[row][col] = 1;\\n        while (!q.empty()) {\\n            auto p = q.front();\\n            q.pop();\\n\\n            for (auto d: D) {\\n                int nr = p.first + d.first;\\n                int nc = p.second + d.second;\\n\\n                if (nr < 0 || nr == R || nc < 0 || nc == C) {\\n                    continue;\\n                }\\n\\n                if (!visited[nr][nc] && grid[nr][nc] == testColor) {\\n                    q.push( {nr, nc} );\\n                    visited[nr][nc] = 1;\\n                }\\n            }\\n        }\\n\\n        for (int r = 0;r < R;r ++) {\\n            for (int c = 0;c < C;c ++) {\\n                if (visited[r][c] == 0) {\\n                    continue;\\n                }\\n\\n                int rm = r - 1;\\n                int rp = r + 1;\\n                int cm = c - 1;\\n                int cp = c + 1;\\n\\n                if (\\n                    (rm < 0 || visited[rm][c] == 0) || (rp == R || visited[rp][c] == 0) || \\n                    (cm < 0 || visited[r][cm] == 0) || (cp == C || visited[r][cp] == 0)\\n                   ) \\n                {\\n                    grid[r][c] = color;\\n                }\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392758,
                "title": "2-traversal-solutions-iterative-and-recursive-python",
                "content": "```\\n\"\"\"\\nContinuing on Problem 733 Flood Fill.\\n\\nTreatment: Traversal in both iterative and recursive formats here.\\n\\nFollow up at Youtube channel: \"Code-Yao\"\\n\"\"\"\\n\\nclass SolutionV1:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        \\n        \"\"\"\\n        iterative format\\n        \"\"\"\\n        # step-0 prep\\n        m, n = len(grid), len(grid[0])\\n        \\n        # step-1 dfs fn in iterative format\\n        def get_component(r, c, color):\\n            visited = set()\\n            s = [(r, c)]\\n            while s:\\n                x, y = s.pop()\\n                visited.add((x, y))\\n                for x1, y1 in {(x-1, y), (x+1, y), (x, y-1), (x, y+1)}:\\n                    if (0 <= x1 < m) and (0 <= y1 < n) and ((x1, y1) not in visited) and grid[x1][y1] == color:\\n                        s.append((x1, y1))\\n            return visited\\n        \\n        # step-2 set the \"bdr\" of cc cells to color\\n        cluster = get_component(row, col, grid[row][col])\\n        res = grid.copy()\\n        for (r, c) in cluster:\\n            if r in {0, m-1} or c in {0, n-1}:\\n                res[r][c] = color\\n            for (x, y) in {(r-1, c), (r+1, c), (r, c+1), (r, c-1)}:\\n                if (x, y) not in cluster:\\n                    res[r][c] = color\\n                    break\\n        return res\\n    \\n    \\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        \\n        \"\"\"\\n        recursive format\\n        \"\"\"\\n        # step-0 prep\\n        m, n = len(grid), len(grid[0])\\n        \\n        # step-1 dfs helper fn in recursion\\n        visited = set()\\n        # @cache\\n        def traverse(r, c, color):\\n            if r < 0 or r >= m or c < 0 or c >= n:\\n                return\\n            if grid[r][c] == color and (r, c) not in visited:\\n                visited.add((r, c))\\n                traverse(r-1, c, color)\\n                traverse(r+1, c, color)\\n                traverse(r, c-1, color)\\n                traverse(r, c+1, color)\\n        \\n        # step-2\\n        traverse(row, col, grid[row][col])\\n        \\n        cluster = visited\\n        \\n        # step-3 set the color\\n        res = grid.copy()\\n        for (r, c) in cluster:\\n            if r in {0, m-1} or c in {0, n-1}:\\n                res[r][c] = color\\n            for (x, y) in {(r-1, c), (r+1, c), (r, c+1), (r, c-1)}:\\n                if (x, y) not in cluster:\\n                    res[r][c] = color\\n                    break\\n        return res\\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\nContinuing on Problem 733 Flood Fill.\\n\\nTreatment: Traversal in both iterative and recursive formats here.\\n\\nFollow up at Youtube channel: \"Code-Yao\"\\n\"\"\"\\n\\nclass SolutionV1:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        \\n        \"\"\"\\n        iterative format\\n        \"\"\"\\n        # step-0 prep\\n        m, n = len(grid), len(grid[0])\\n        \\n        # step-1 dfs fn in iterative format\\n        def get_component(r, c, color):\\n            visited = set()\\n            s = [(r, c)]\\n            while s:\\n                x, y = s.pop()\\n                visited.add((x, y))\\n                for x1, y1 in {(x-1, y), (x+1, y), (x, y-1), (x, y+1)}:\\n                    if (0 <= x1 < m) and (0 <= y1 < n) and ((x1, y1) not in visited) and grid[x1][y1] == color:\\n                        s.append((x1, y1))\\n            return visited\\n        \\n        # step-2 set the \"bdr\" of cc cells to color\\n        cluster = get_component(row, col, grid[row][col])\\n        res = grid.copy()\\n        for (r, c) in cluster:\\n            if r in {0, m-1} or c in {0, n-1}:\\n                res[r][c] = color\\n            for (x, y) in {(r-1, c), (r+1, c), (r, c+1), (r, c-1)}:\\n                if (x, y) not in cluster:\\n                    res[r][c] = color\\n                    break\\n        return res\\n    \\n    \\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        \\n        \"\"\"\\n        recursive format\\n        \"\"\"\\n        # step-0 prep\\n        m, n = len(grid), len(grid[0])\\n        \\n        # step-1 dfs helper fn in recursion\\n        visited = set()\\n        # @cache\\n        def traverse(r, c, color):\\n            if r < 0 or r >= m or c < 0 or c >= n:\\n                return\\n            if grid[r][c] == color and (r, c) not in visited:\\n                visited.add((r, c))\\n                traverse(r-1, c, color)\\n                traverse(r+1, c, color)\\n                traverse(r, c-1, color)\\n                traverse(r, c+1, color)\\n        \\n        # step-2\\n        traverse(row, col, grid[row][col])\\n        \\n        cluster = visited\\n        \\n        # step-3 set the color\\n        res = grid.copy()\\n        for (r, c) in cluster:\\n            if r in {0, m-1} or c in {0, n-1}:\\n                res[r][c] = color\\n            for (x, y) in {(r-1, c), (r+1, c), (r, c+1), (r, c-1)}:\\n                if (x, y) not in cluster:\\n                    res[r][c] = color\\n                    break\\n        return res\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374584,
                "title": "simple-c-solution-with-bfs",
                "content": "```\\nclass Solution {\\n    bool isValid(int newr,int newc,int n,int m){\\n        return (newr>=0 and newr<n and newc>=0 and newc<m);\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vis[row][col]=1;\\n        int clr = grid[row][col];\\n        \\n        int delr[] = {0,1,0,-1};\\n        int delc[] = {1,0,-1,0};\\n        \\n        while(!q.empty()){\\n            auto [r,c] = q.front();\\n            q.pop();\\n \\n            for(int i=0;i<4;i++){\\n                int newr = r+delr[i];\\n                int newc = c+delc[i];\\n                \\n                if(isValid(newr,newc,n,m) and !vis[newr][newc] and grid[newr][newc]==clr){\\n                    q.push({newr,newc});\\n                    vis[newr][newc]=1;\\n                }\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]){\\n                    for(int k=0;k<4;k++){\\n                        int newr=i+delr[k];\\n                        int newc=j+delc[k];\\n                        \\n                        if(isValid(newr,newc,n,m) and vis[newr][newc]) continue;\\n                        if(newr<0 or newr>=n or newc<0 or newc>=m or grid[newr][newc]!=clr){           \\n                            grid[i][j]=color;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    bool isValid(int newr,int newc,int n,int m){\\n        return (newr>=0 and newr<n and newc>=0 and newc<m);\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vis[row][col]=1;\\n        int clr = grid[row][col];\\n        \\n        int delr[] = {0,1,0,-1};\\n        int delc[] = {1,0,-1,0};\\n        \\n        while(!q.empty()){\\n            auto [r,c] = q.front();\\n            q.pop();\\n \\n            for(int i=0;i<4;i++){\\n                int newr = r+delr[i];\\n                int newc = c+delc[i];\\n                \\n                if(isValid(newr,newc,n,m) and !vis[newr][newc] and grid[newr][newc]==clr){\\n                    q.push({newr,newc});\\n                    vis[newr][newc]=1;\\n                }\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]){\\n                    for(int k=0;k<4;k++){\\n                        int newr=i+delr[k];\\n                        int newc=j+delc[k];\\n                        \\n                        if(isValid(newr,newc,n,m) and vis[newr][newc]) continue;\\n                        if(newr<0 or newr>=n or newc<0 or newc>=m or grid[newr][newc]!=clr){           \\n                            grid[i][j]=color;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367569,
                "title": "dfs-matrix-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(M*N)\\n\\n- Space complexity:\\nO(M*N)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean allSet(int[][] grid,int i,int j,int color){\\n        int cnt=0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(i==0 || i==m-1 || j==0 || j==n-1) return true;\\n        if(grid[i-1][j]==color) cnt++;\\n        if(grid[i+1][j]==color) cnt++;\\n        if(grid[i][j-1]==color) cnt++;\\n        if(grid[i][j+1]==color) cnt++;\\n        return cnt<4;\\n    }\\n    public void dfs(int[][] grid,int[][] visited,int row,int col,int color,int oldcolor,int[][] board,boolean[][] safe){\\n        visited[row][col]=1;\\n        if(safe[row][col]==true){\\n        board[row][col] = color;\\n        }\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] drow = {-1,0,1,0};\\n        int[] dcol = {0,1,0,-1};   \\n           for(int i=0;i<4;i++){\\n               int newr = row + drow[i];\\n               int newc = col + dcol[i];\\nif(newr>=0 && newr<m && newc>=0 && newc<n && visited[newr][newc]!=1 && grid[newr][newc]==oldcolor){\\n                   dfs(grid,visited,newr,newc,color,oldcolor,board,safe);\\n               }\\n           }\\n\\n    }\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] visited = new int[m][n];\\n        int[][] board = grid;\\n        boolean[][] safe = new boolean[m][n];\\n        int oldcolor = grid[row][col];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                safe[i][j]=allSet(grid,i,j,oldcolor);\\n            }\\n        }\\n        dfs(grid,visited,row,col,color,oldcolor,board,safe);\\n        return board;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean allSet(int[][] grid,int i,int j,int color){\\n        int cnt=0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(i==0 || i==m-1 || j==0 || j==n-1) return true;\\n        if(grid[i-1][j]==color) cnt++;\\n        if(grid[i+1][j]==color) cnt++;\\n        if(grid[i][j-1]==color) cnt++;\\n        if(grid[i][j+1]==color) cnt++;\\n        return cnt<4;\\n    }\\n    public void dfs(int[][] grid,int[][] visited,int row,int col,int color,int oldcolor,int[][] board,boolean[][] safe){\\n        visited[row][col]=1;\\n        if(safe[row][col]==true){\\n        board[row][col] = color;\\n        }\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] drow = {-1,0,1,0};\\n        int[] dcol = {0,1,0,-1};   \\n           for(int i=0;i<4;i++){\\n               int newr = row + drow[i];\\n               int newc = col + dcol[i];\\nif(newr>=0 && newr<m && newc>=0 && newc<n && visited[newr][newc]!=1 && grid[newr][newc]==oldcolor){\\n                   dfs(grid,visited,newr,newc,color,oldcolor,board,safe);\\n               }\\n           }\\n\\n    }\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] visited = new int[m][n];\\n        int[][] board = grid;\\n        boolean[][] safe = new boolean[m][n];\\n        int oldcolor = grid[row][col];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                safe[i][j]=allSet(grid,i,j,oldcolor);\\n            }\\n        }\\n        dfs(grid,visited,row,col,color,oldcolor,board,safe);\\n        return board;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362533,
                "title": "bfs-expalantion-in-comment-java",
                "content": "\\n- Time complexity:M*N\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        /*if value of grid[row][col] is surrounded in 4 adjacent direction and if the value is same then we donot take it*/\\n        /*all adjacent cell which same value as grid[row][col] will be color*/\\n     /*we have used BFS traversal first we are inseting the row col and after removing we are seeing if its adjacent cell has same value then we insert that adjacent cell into the queue and another array we have used so if count <4 so we color that particular res[x][y]=color*/ \\n     /*Also we have used an 2d boolean array of same length as grid so that we marked that cell which is already visited and not to visit again*/\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int res[][]=new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                res[i][j]=grid[i][j];\\n            }\\n        }\\n        Queue<int[]> q=new LinkedList<>();\\n        boolean visited[][]=new boolean[m][n];\\n        int t[]=new int[2];\\n        int v=grid[row][col];\\n        if(v==color)return grid;\\n        t[0]=row;\\n        t[1]=col;\\n        q.add(t);\\n       while(!q.isEmpty()){\\n           int size=q.size();\\n           for(int i=0;i<size;i++){\\n               int arr[]=q.remove();\\n               int x=arr[0];\\n               int y=arr[1];\\n               if(visited[x][y])continue;\\n               visited[x][y]=true;\\n               int c=y+1;\\n               int c1=y-1;\\n               int r=x+1;\\n               int r1=x-1;\\n               int count=0;\\n               if(c<n && grid[x][c]==v){\\n                   count++;\\n                   int temp[]=new int[2];\\n                   temp[0]=x;\\n                   temp[1]=c;\\n                   q.add(temp);\\n               }\\n                if(c1>=0 && grid[x][c1]==v){\\n                   count++;\\n                   int temp[]=new int[2];\\n                   temp[0]=x;\\n                   temp[1]=c1;\\n                   q.add(temp);\\n               }\\n               if(r<m && grid[r][y]==v){\\n                   count++;\\n                   int temp[]=new int[2];\\n                   temp[0]=r;\\n                   temp[1]=y;\\n                   q.add(temp);\\n               }\\n                if(r1>=0 && grid[r1][y]==v){\\n                   count++;\\n                   int temp[]=new int[2];\\n                   temp[0]=r1;\\n                   temp[1]=y;\\n                   q.add(temp);\\n               }\\n               System.out.print(count+\"  \");\\n               if(count!=4){\\n                   res[x][y]=color;\\n               }\\n           }\\n       }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        /*if value of grid[row][col] is surrounded in 4 adjacent direction and if the value is same then we donot take it*/\\n        /*all adjacent cell which same value as grid[row][col] will be color*/\\n     /*we have used BFS traversal first we are inseting the row col and after removing we are seeing if its adjacent cell has same value then we insert that adjacent cell into the queue and another array we have used so if count <4 so we color that particular res[x][y]=color*/ \\n     /*Also we have used an 2d boolean array of same length as grid so that we marked that cell which is already visited and not to visit again*/\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int res[][]=new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                res[i][j]=grid[i][j];\\n            }\\n        }\\n        Queue<int[]> q=new LinkedList<>();\\n        boolean visited[][]=new boolean[m][n];\\n        int t[]=new int[2];\\n        int v=grid[row][col];\\n        if(v==color)return grid;\\n        t[0]=row;\\n        t[1]=col;\\n        q.add(t);\\n       while(!q.isEmpty()){\\n           int size=q.size();\\n           for(int i=0;i<size;i++){\\n               int arr[]=q.remove();\\n               int x=arr[0];\\n               int y=arr[1];\\n               if(visited[x][y])continue;\\n               visited[x][y]=true;\\n               int c=y+1;\\n               int c1=y-1;\\n               int r=x+1;\\n               int r1=x-1;\\n               int count=0;\\n               if(c<n && grid[x][c]==v){\\n                   count++;\\n                   int temp[]=new int[2];\\n                   temp[0]=x;\\n                   temp[1]=c;\\n                   q.add(temp);\\n               }\\n                if(c1>=0 && grid[x][c1]==v){\\n                   count++;\\n                   int temp[]=new int[2];\\n                   temp[0]=x;\\n                   temp[1]=c1;\\n                   q.add(temp);\\n               }\\n               if(r<m && grid[r][y]==v){\\n                   count++;\\n                   int temp[]=new int[2];\\n                   temp[0]=r;\\n                   temp[1]=y;\\n                   q.add(temp);\\n               }\\n                if(r1>=0 && grid[r1][y]==v){\\n                   count++;\\n                   int temp[]=new int[2];\\n                   temp[0]=r1;\\n                   temp[1]=y;\\n                   q.add(temp);\\n               }\\n               System.out.print(count+\"  \");\\n               if(count!=4){\\n                   res[x][y]=color;\\n               }\\n           }\\n       }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334204,
                "title": "c-92-beats",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isBorder(vector<vector<int>> &grid, int i, int j, int n, int m, int val) {\\n        if(i == 0 or j == 0 or i == n - 1 or j == m - 1) return true;\\n        if(grid[i + 1][j] != val or grid[i - 1][j] != val or grid[i][j - 1] != val or grid[i][j + 1] != val) return true;\\n        return false;\\n    }\\n\\n    void dfs(int r, int c, int val, vector<vector<int>> &grid, vector<vector<int>> &temp, vector<vector<int>> &vis, int color, int n, int m) {\\n        vis[r][c] = 1;\\n        \\n        if(isBorder(grid, r, c, n, m, val))\\n            temp[r][c] = color;\\n        \\n        int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};\\n        int cnt = 0;\\n        for(int i = 0; i < 4; i++) {\\n            int nx = r + dx[i], ny = c + dy[i];\\n            if(nx >= 0 and ny >= 0 and nx < n and ny < m and !vis[nx][ny] and grid[nx][ny] == val) \\n                dfs(nx, ny, val, grid, temp, vis, color, n, m);\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>> &grid, int row, int col, int color) {\\n        int val = grid[row][col];\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int> (m)), temp {grid};\\n\\n        dfs(row, col, val, grid, temp, vis, color, n, m);\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBorder(vector<vector<int>> &grid, int i, int j, int n, int m, int val) {\\n        if(i == 0 or j == 0 or i == n - 1 or j == m - 1) return true;\\n        if(grid[i + 1][j] != val or grid[i - 1][j] != val or grid[i][j - 1] != val or grid[i][j + 1] != val) return true;\\n        return false;\\n    }\\n\\n    void dfs(int r, int c, int val, vector<vector<int>> &grid, vector<vector<int>> &temp, vector<vector<int>> &vis, int color, int n, int m) {\\n        vis[r][c] = 1;\\n        \\n        if(isBorder(grid, r, c, n, m, val))\\n            temp[r][c] = color;\\n        \\n        int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};\\n        int cnt = 0;\\n        for(int i = 0; i < 4; i++) {\\n            int nx = r + dx[i], ny = c + dy[i];\\n            if(nx >= 0 and ny >= 0 and nx < n and ny < m and !vis[nx][ny] and grid[nx][ny] == val) \\n                dfs(nx, ny, val, grid, temp, vis, color, n, m);\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>> &grid, int row, int col, int color) {\\n        int val = grid[row][col];\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int> (m)), temp {grid};\\n\\n        dfs(row, col, val, grid, temp, vis, color, n, m);\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327373,
                "title": "easy-solution-with-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        def out_of_boundary(x, y):\\n            return x < 0 or y < 0 or x >= m or y >= n\\n\\n        def get_color(x, y):\\n            if out_of_boundary(x, y):\\n                return -2\\n            return grid[x][y]\\n\\n        def check_inside(x, y, target):\\n            dirs = [1, 0, -1, 0]\\n            for i in range(4):\\n                color = get_color(x + dirs[i], y + dirs[(i + 1) % 4])\\n                if color != -1 and color != target:\\n                    return False\\n            return True\\n\\n        p = []\\n        \\n        def dfs(x, y, target):\\n            if out_of_boundary(x, y):\\n                return\\n            if grid[x][y] != target:\\n                return\\n            if check_inside(x, y, target):\\n                p.append((x, y, grid[x][y]))\\n            grid[x][y] = -1\\n            dfs(x + 1, y, target)\\n            dfs(x - 1, y, target)\\n            dfs(x, y + 1, target)\\n            dfs(x, y - 1, target)\\n        \\n        dfs(row, col, grid[row][col])\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == -1:\\n                    grid[i][j] = color\\n\\n        for x, y, color in p:\\n            grid[x][y] = color\\n            \\n        return grid\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        def out_of_boundary(x, y):\\n            return x < 0 or y < 0 or x >= m or y >= n\\n\\n        def get_color(x, y):\\n            if out_of_boundary(x, y):\\n                return -2\\n            return grid[x][y]\\n\\n        def check_inside(x, y, target):\\n            dirs = [1, 0, -1, 0]\\n            for i in range(4):\\n                color = get_color(x + dirs[i], y + dirs[(i + 1) % 4])\\n                if color != -1 and color != target:\\n                    return False\\n            return True\\n\\n        p = []\\n        \\n        def dfs(x, y, target):\\n            if out_of_boundary(x, y):\\n                return\\n            if grid[x][y] != target:\\n                return\\n            if check_inside(x, y, target):\\n                p.append((x, y, grid[x][y]))\\n            grid[x][y] = -1\\n            dfs(x + 1, y, target)\\n            dfs(x - 1, y, target)\\n            dfs(x, y + 1, target)\\n            dfs(x, y - 1, target)\\n        \\n        dfs(row, col, grid[row][col])\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == -1:\\n                    grid[i][j] = color\\n\\n        for x, y, color in p:\\n            grid[x][y] = color\\n            \\n        return grid\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327297,
                "title": "c-bfs-using-queue-and-set-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse BFS technique to traverse every cell of the connected component and check if the cell color needs to be changed if its a bordering cell.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStart from grid[row][col] cell and traverse all the adjacent cells that are part of same component by BFS technique using queue. While traversing the connected component we also check which cells are border cells by checking if it touches the grid limit (0 <= cell_row < grid_row) or (0 <= cell_col < grid_col) or it touches the cell of another connected component (adjacent cell color != original component color).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(n)**, where \\'n\\' is the no. of cells in the connected component which can be r*c(no. of rows and coloumns in the grid) in worst case. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(n)**, where \\'n\\' is the no. of cells in the connected component which can be r*c(no. of rows and coloumns in the grid) in worst case.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int gr = grid.size();\\n        int gc = grid[0].size();\\n        int compColor = grid[row][col];\\n        queue<pair<int, int>> q;\\n        q.push({row, col});\\n        int move[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        set<pair<int, int>> st;\\n        st.insert({row,col});\\n\\n        while(!q.empty()) {\\n            int cr = q.front().first;\\n            int cc = q.front().second;\\n            q.pop();\\n            for(int k=0; k<4; k++) {\\n                int nr = cr + move[k][0];\\n                int nc = cc + move[k][1];\\n\\n                if(nr < 0 || nr >= gr || nc < 0 || nc >= gc) {\\n                    grid[cr][cc] = color;\\n                }\\n                else if(grid[nr][nc] != compColor && st.find({nr,nc}) == st.end()) {\\n                    grid[cr][cc] = color;\\n                }\\n                else if(grid[nr][nc] == compColor && st.find({nr,nc}) == st.end()) {\\n                    q.push({nr, nc});\\n                    st.insert({nr,nc});\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int gr = grid.size();\\n        int gc = grid[0].size();\\n        int compColor = grid[row][col];\\n        queue<pair<int, int>> q;\\n        q.push({row, col});\\n        int move[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        set<pair<int, int>> st;\\n        st.insert({row,col});\\n\\n        while(!q.empty()) {\\n            int cr = q.front().first;\\n            int cc = q.front().second;\\n            q.pop();\\n            for(int k=0; k<4; k++) {\\n                int nr = cr + move[k][0];\\n                int nc = cc + move[k][1];\\n\\n                if(nr < 0 || nr >= gr || nc < 0 || nc >= gc) {\\n                    grid[cr][cc] = color;\\n                }\\n                else if(grid[nr][nc] != compColor && st.find({nr,nc}) == st.end()) {\\n                    grid[cr][cc] = color;\\n                }\\n                else if(grid[nr][nc] == compColor && st.find({nr,nc}) == st.end()) {\\n                    q.push({nr, nc});\\n                    st.insert({nr,nc});\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303499,
                "title": "python-bfs-solution",
                "content": "# Intuition\\nWe can use BFS solution to solve this problem. Start from point (row, col) and move to the neighbors if neighbour has color that we should repaint. We should use visited and painted set to define visited and painted points.\\n\\n# Approach\\nDefine a queue and first point in the queue as grid[row][col].\\nUse BFS to move to the neigbours of current point if the neigbour has color that should be repainted. If all neigbours should be repainted or were repainted that current point should be leave with current color because the current point in the middle. Otherwise, repaint current point and add the point to repainted.\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        m = len(grid)\\n        if m == 0:\\n            return grid\\n        n = len(grid[0])\\n\\n        dr = [[-1,0],[0,1],[1,0],[0,-1]]\\n        visited = set()\\n        painted = set()\\n        cl = grid[row][col]\\n\\n        q = deque()\\n        q.append([row, col])\\n        while q:\\n            for i in range(len(q)):\\n                paint = False\\n                y, x = q.popleft()\\n                key = str(y) + \\':\\' + str(x)\\n                if key in visited:\\n                    continue\\n                visited.add(key)\\n                for dY, dX in dr:\\n                    newY = y + dY\\n                    newX = x + dX\\n                    if newY >= 0 and newY < m and newX >= 0 and newX < n and grid[newY][newX] == cl:\\n                        q.append([newY, newX])\\n                    elif str(newY) + \\':\\' + str(newX) not in painted:\\n                        paint = True\\n                if paint:\\n                    painted.add(key)\\n                    grid[y][x] = color\\n        return grid\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        m = len(grid)\\n        if m == 0:\\n            return grid\\n        n = len(grid[0])\\n\\n        dr = [[-1,0],[0,1],[1,0],[0,-1]]\\n        visited = set()\\n        painted = set()\\n        cl = grid[row][col]\\n\\n        q = deque()\\n        q.append([row, col])\\n        while q:\\n            for i in range(len(q)):\\n                paint = False\\n                y, x = q.popleft()\\n                key = str(y) + \\':\\' + str(x)\\n                if key in visited:\\n                    continue\\n                visited.add(key)\\n                for dY, dX in dr:\\n                    newY = y + dY\\n                    newX = x + dX\\n                    if newY >= 0 and newY < m and newX >= 0 and newX < n and grid[newY][newX] == cl:\\n                        q.append([newY, newX])\\n                    elif str(newY) + \\':\\' + str(newX) not in painted:\\n                        paint = True\\n                if paint:\\n                    painted.add(key)\\n                    grid[y][x] = color\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300638,
                "title": "java-dfs-o-n2-self-explained-code",
                "content": "# Complexity\\n- Time complexity: $$O(n2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private final List<Integer[]> directions = List.of(new Integer[]{0,1},\\n            new Integer[]{0,-1}, new Integer[]{1,0}, new Integer[]{-1,0});\\n    private final Set<String> visited = new HashSet<>();\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        if(grid[row][col] == color) return grid;\\n        dfs(row, col, grid[row][col], color, grid);\\n        return grid;\\n    }\\n\\n    private void dfs(int row, int col, int componentColor, int newColor, int[][] grid) {\\n        visited.add(row + \",\" + col);\\n        if(isOnBorders(row, col, grid) || isAdjacentToDiffComponent(row, col, componentColor, grid)) \\n            grid[row][col] = newColor;\\n        for (Integer[] direction: directions) {\\n            int i= row + direction[0], j = col + direction[1];\\n            if(isValidCoordinates(grid,i,j) && !visited.contains(i + \",\" + j) && grid[i][j] == componentColor)\\n                dfs(i, j, componentColor, newColor, grid);\\n        }\\n    }\\n\\n    private boolean isAdjacentToDiffComponent(int row, int col, int componentColor, int[][] grid) {\\n        for (Integer[] direction: directions) {\\n            int i= row + direction[0], j = col + direction[1];\\n            if(isValidCoordinates(grid, i, j) && !visited.contains(i + \",\" + j)  && grid[i][j] != componentColor)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean isValidCoordinates(int[][] grid, int i, int j) {\\n        return i >= 0 && i < grid.length && j >= 0 && j < grid[0].length;\\n    }\\n\\n    private boolean isOnBorders(int row, int col, int[][] grid) {\\n        return row == 0 || row == grid.length-1 || col == 0 || col == grid[0].length-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private final List<Integer[]> directions = List.of(new Integer[]{0,1},\\n            new Integer[]{0,-1}, new Integer[]{1,0}, new Integer[]{-1,0});\\n    private final Set<String> visited = new HashSet<>();\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        if(grid[row][col] == color) return grid;\\n        dfs(row, col, grid[row][col], color, grid);\\n        return grid;\\n    }\\n\\n    private void dfs(int row, int col, int componentColor, int newColor, int[][] grid) {\\n        visited.add(row + \",\" + col);\\n        if(isOnBorders(row, col, grid) || isAdjacentToDiffComponent(row, col, componentColor, grid)) \\n            grid[row][col] = newColor;\\n        for (Integer[] direction: directions) {\\n            int i= row + direction[0], j = col + direction[1];\\n            if(isValidCoordinates(grid,i,j) && !visited.contains(i + \",\" + j) && grid[i][j] == componentColor)\\n                dfs(i, j, componentColor, newColor, grid);\\n        }\\n    }\\n\\n    private boolean isAdjacentToDiffComponent(int row, int col, int componentColor, int[][] grid) {\\n        for (Integer[] direction: directions) {\\n            int i= row + direction[0], j = col + direction[1];\\n            if(isValidCoordinates(grid, i, j) && !visited.contains(i + \",\" + j)  && grid[i][j] != componentColor)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean isValidCoordinates(int[][] grid, int i, int j) {\\n        return i >= 0 && i < grid.length && j >= 0 && j < grid[0].length;\\n    }\\n\\n    private boolean isOnBorders(int row, int col, int[][] grid) {\\n        return row == 0 || row == grid.length-1 || col == 0 || col == grid[0].length-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291684,
                "title": "dfs-iterative-and-recursive-approaches-bfs-in-python-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStarting from the given cell (row, col) traverse all the neighbors (UP, DOWN, RIGHT, LEFT neighbors) with the same color, and change the cell\\'s color to given color. But we should only change the color of cell when it is a border.\\n\\nA cell can be a border in 2 cases only:\\n- 1. when it is already in the border of the grid\\n- 2. when it is in the middle of the grid and one of the neighbor has different color\\n\\nWe can solve this problem with either DFS or BFS.\\nFor both of them the approach, intuition, complexity analysis are the same.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. starting from the given cell (row, col)\\n2. mark this cell as visited\\n3. traverse all neighbors [(1,0), (-1, 0), (0,1), (0,-1)] with the same color only\\n4. if one of the neighbors has different color mark `isBorder` flag as true\\n5. if the current cell is border change its color\\n\\n \\n# Complexity\\n- Time complexity: O(MN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(MN)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n**DFS (Iteratative Approach)**\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r: int, c: int, new_color: int) -> List[List[int]]:\\n        R, C = len(grid), len(grid[0])\\n        visited = set()\\n        queue = deque([(r, c)])\\n        neighbor = [(1,0), (-1,0), (0,1), (0,-1)]\\n        color = grid[r][c]\\n\\n        while queue:\\n            row, col = queue.popleft()\\n            visited.add((row, col))\\n            isBorder = False\\n\\n            for r, c in neighbor:\\n                new_r, new_c = row + r, col+c\\n\\n                # skip when the neighbor cell (new_r, new_c) is out of bound or already visited\\n                if new_r < 0 or new_r >= R or new_c < 0 or new_c >= C or (new_r, new_c) in visited:\\n                    continue\\n\\n                # mark current cell (row, col) as border, when neighbor cell (new_r, new_c) has a different color\\n                if grid[new_r][new_c] != color:\\n                    isBorder = True\\n                    continue\\n\\n                queue.append((new_r, new_c))\\n            # if the current (row, col) is already the border of the grid, color the cell with new_color\\n            # if isBorder is true, color the cell with new_color\\n            if row == 0 or row == R-1 or col == 0 or col == C-1 or isBorder:\\n                grid[row][col] = new_color\\n\\n        return grid\\n```\\n\\n**DFS Approach with recursion**\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r: int, c: int, new_color: int) -> List[List[int]]:\\n        R, C = len(grid), len(grid[0])\\n        visited = set()\\n\\n        def dfs(row, col, color):\\n            visited.add((row, col))\\n            neighbor = [(1,0), (-1,0), (0,1), (0,-1)]\\n\\n            isBorder = False\\n\\n            for r, c in neighbor:\\n                new_r, new_c = row+r, col+c\\n                \\n                if new_r < 0 or new_r >= R or new_c < 0 or new_c >= C or (new_r, new_c) in visited:\\n                    continue\\n\\n                if grid[new_r][new_c] != color:\\n                    isBorder = True\\n                    continue\\n\\n                dfs(new_r, new_c, color)\\n            \\n            if row == 0 or row == R-1 or col == 0 or col == C-1 or isBorder:\\n                grid[row][col] = new_color\\n\\n        dfs(r, c, grid[r][c])\\n\\n        return grid\\n```\\n\\n**BFS Approach**\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r: int, c: int, new_color: int) -> List[List[int]]:\\n        R, C = len(grid), len(grid[0])\\n        visited = set()\\n        queue = deque([(r, c)])\\n        neighbor = [(1,0), (-1,0), (0,1), (0,-1)]\\n        color = grid[r][c]\\n\\n        while queue:\\n            row, col = queue.popleft()\\n            visited.add((row, col))\\n            isBorder = False\\n\\n            for r, c in neighbor:\\n                new_r, new_c = row + r, col+c\\n\\n                # skip when the neighbor cell (new_r, new_c) is out of bound or already visited\\n                if new_r < 0 or new_r >= R or new_c < 0 or new_c >= C or (new_r, new_c) in visited:\\n                    continue\\n\\n                # mark current cell (row, col) as border, when neighbor cell (new_r, new_c) has a different color\\n                if grid[new_r][new_c] != color:\\n                    isBorder = True\\n                    continue\\n\\n                queue.append((new_r, new_c))\\n            \\n            # if the current (row, col) is already the border of the grid, color the cell with new_color\\n            # if isBorder is true, color the cell with new_color\\n            if row == 0 or row == R-1 or col == 0 or col == C-1 or isBorder:\\n                grid[row][col] = new_color\\n\\n        return grid\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r: int, c: int, new_color: int) -> List[List[int]]:\\n        R, C = len(grid), len(grid[0])\\n        visited = set()\\n        queue = deque([(r, c)])\\n        neighbor = [(1,0), (-1,0), (0,1), (0,-1)]\\n        color = grid[r][c]\\n\\n        while queue:\\n            row, col = queue.popleft()\\n            visited.add((row, col))\\n            isBorder = False\\n\\n            for r, c in neighbor:\\n                new_r, new_c = row + r, col+c\\n\\n                # skip when the neighbor cell (new_r, new_c) is out of bound or already visited\\n                if new_r < 0 or new_r >= R or new_c < 0 or new_c >= C or (new_r, new_c) in visited:\\n                    continue\\n\\n                # mark current cell (row, col) as border, when neighbor cell (new_r, new_c) has a different color\\n                if grid[new_r][new_c] != color:\\n                    isBorder = True\\n                    continue\\n\\n                queue.append((new_r, new_c))\\n            # if the current (row, col) is already the border of the grid, color the cell with new_color\\n            # if isBorder is true, color the cell with new_color\\n            if row == 0 or row == R-1 or col == 0 or col == C-1 or isBorder:\\n                grid[row][col] = new_color\\n\\n        return grid\\n```\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r: int, c: int, new_color: int) -> List[List[int]]:\\n        R, C = len(grid), len(grid[0])\\n        visited = set()\\n\\n        def dfs(row, col, color):\\n            visited.add((row, col))\\n            neighbor = [(1,0), (-1,0), (0,1), (0,-1)]\\n\\n            isBorder = False\\n\\n            for r, c in neighbor:\\n                new_r, new_c = row+r, col+c\\n                \\n                if new_r < 0 or new_r >= R or new_c < 0 or new_c >= C or (new_r, new_c) in visited:\\n                    continue\\n\\n                if grid[new_r][new_c] != color:\\n                    isBorder = True\\n                    continue\\n\\n                dfs(new_r, new_c, color)\\n            \\n            if row == 0 or row == R-1 or col == 0 or col == C-1 or isBorder:\\n                grid[row][col] = new_color\\n\\n        dfs(r, c, grid[r][c])\\n\\n        return grid\\n```\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r: int, c: int, new_color: int) -> List[List[int]]:\\n        R, C = len(grid), len(grid[0])\\n        visited = set()\\n        queue = deque([(r, c)])\\n        neighbor = [(1,0), (-1,0), (0,1), (0,-1)]\\n        color = grid[r][c]\\n\\n        while queue:\\n            row, col = queue.popleft()\\n            visited.add((row, col))\\n            isBorder = False\\n\\n            for r, c in neighbor:\\n                new_r, new_c = row + r, col+c\\n\\n                # skip when the neighbor cell (new_r, new_c) is out of bound or already visited\\n                if new_r < 0 or new_r >= R or new_c < 0 or new_c >= C or (new_r, new_c) in visited:\\n                    continue\\n\\n                # mark current cell (row, col) as border, when neighbor cell (new_r, new_c) has a different color\\n                if grid[new_r][new_c] != color:\\n                    isBorder = True\\n                    continue\\n\\n                queue.append((new_r, new_c))\\n            \\n            # if the current (row, col) is already the border of the grid, color the cell with new_color\\n            # if isBorder is true, color the cell with new_color\\n            if row == 0 or row == R-1 or col == 0 or col == C-1 or isBorder:\\n                grid[row][col] = new_color\\n\\n        return grid\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267644,
                "title": "1034-coloring-a-border-java-dfs-bit-manipulation-approach",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/4766e2d3-e32d-4122-86db-e060c39a27cf_1678173936.385443.png)\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] ans;\\n\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        ans = new int[grid.length][];\\n        for(int i=0;i<grid.length;i++){\\n            ans[i] = grid[i].clone();\\n        }\\n\\n        coloring(grid,row,col,grid[row][col],color,new int[grid.length]);\\n\\n       return ans;\\n    }\\n\\n    public boolean check(int n, int pos){\\n        int mask = 1<<pos;\\n\\n        if((n&mask) == mask){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    public int toggle(int n, int pos){\\n        int mask = 1<<pos;\\n        return (n^mask);\\n    }\\n\\n    public void coloring(int[][] arr, int row, int col, int oCol,int target, int[] visited){\\n        if(row<0 || row>=arr.length || col<0 || col>=arr[0].length || (check(visited[row],col) == true) || arr[row][col] != oCol){\\n            return;\\n        }\\n\\n        if((row == 0 || row == arr.length-1 || col == 0 || col == arr[0].length-1 || (arr[row-1][col] != oCol || arr[row][col-1] != oCol || arr[row+1][col] != oCol || arr[row][col+1] != oCol)) && arr[row][col] == oCol){\\n            ans[row][col] = target;\\n        }\\n\\n        visited[row] = toggle(visited[row], col);\\n        coloring(arr,row-1,col,oCol,target,visited);\\n        coloring(arr,row,col-1,oCol,target,visited);\\n        coloring(arr,row+1,col,oCol,target,visited);\\n        coloring(arr,row,col+1,oCol,target,visited);\\n        visited[row] = toggle(visited[row], col);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] ans;\\n\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        ans = new int[grid.length][];\\n        for(int i=0;i<grid.length;i++){\\n            ans[i] = grid[i].clone();\\n        }\\n\\n        coloring(grid,row,col,grid[row][col],color,new int[grid.length]);\\n\\n       return ans;\\n    }\\n\\n    public boolean check(int n, int pos){\\n        int mask = 1<<pos;\\n\\n        if((n&mask) == mask){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    public int toggle(int n, int pos){\\n        int mask = 1<<pos;\\n        return (n^mask);\\n    }\\n\\n    public void coloring(int[][] arr, int row, int col, int oCol,int target, int[] visited){\\n        if(row<0 || row>=arr.length || col<0 || col>=arr[0].length || (check(visited[row],col) == true) || arr[row][col] != oCol){\\n            return;\\n        }\\n\\n        if((row == 0 || row == arr.length-1 || col == 0 || col == arr[0].length-1 || (arr[row-1][col] != oCol || arr[row][col-1] != oCol || arr[row+1][col] != oCol || arr[row][col+1] != oCol)) && arr[row][col] == oCol){\\n            ans[row][col] = target;\\n        }\\n\\n        visited[row] = toggle(visited[row], col);\\n        coloring(arr,row-1,col,oCol,target,visited);\\n        coloring(arr,row,col-1,oCol,target,visited);\\n        coloring(arr,row+1,col,oCol,target,visited);\\n        coloring(arr,row,col+1,oCol,target,visited);\\n        visited[row] = toggle(visited[row], col);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191048,
                "title": "c",
                "content": "```\\n\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** colorBorder(int** grid, int gridSize, int* gridColSize, int row, int col, int color, int* returnSize, int** returnColumnSizes){\\n    int m = gridSize;\\n    int n = *gridColSize;\\n    *returnSize = m;\\n    *returnColumnSizes = malloc(m * sizeof(int ));\\n    for(int i = 0; i < m; i++){\\n        returnColumnSizes[0][i] = n;\\n    }\\n    if(grid[row][col] == color)\\n        return grid ;\\n    \\n    bool** used = malloc(m * sizeof(bool*));\\n    for(int i = 0; i < m; i++){\\n        used[i] = calloc(n , sizeof(bool));            \\n    }\\n    \\n    int dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}} ;\\n    \\n    int** queue = malloc(m * n * sizeof(int*));\\n    int org = grid[row][col] ;\\n    int idx = 0;\\n    queue[idx] = malloc(2 * sizeof(int));\\n    queue[idx][0] = row;\\n    queue[idx][1] = col;\\n    idx++;\\n    int pos = 0;\\n      \\n    used[row][col] = true ;\\n    grid[row][col] = -1*color ;\\n    while(pos < idx){\\n        int x = queue[pos][0];\\n        int y = queue[pos][1];\\n        for(int i = 0; i < 4; i++){\\n            int xx = x + dir[i][0] ;\\n            int yy = y + dir[i][1] ;\\n            if(xx < 0 || yy < 0 || xx >= m || yy >= n)\\n                continue ;\\n            if(used[xx][yy] || grid[xx][yy] != org)\\n                continue ;\\n            used[xx][yy] = true ;\\n            queue[idx] = malloc(2 * sizeof(int)) ;\\n            queue[idx][0] = xx ;\\n            queue[idx][1] = yy ;\\n            idx++ ;\\n            grid[xx][yy] = -1 * color ;\\n        }\\n        pos++;\\n    }\\n\\n    for(int i = 0; i < m; i++){\\n        for(int j = 0; j < n; j++){\\n            if(grid[i][j] == -1 * color){\\n                if(i == 0 || j == 0 || (i == (m-1)) || (j == (n-1)) ){\\n                    grid[i][j] = color ;\\n                    continue ;\\n                }\\n                for(int k = 0; k < 4; k++){\\n                    int ii = i + dir[k][0] ;\\n                    int jj = j + dir[k][1] ;\\n                    if(used[ii][jj] == false){\\n                        grid[i][j] = color ;\\n                        break ;\\n                    }\\n                    if(k == 3)\\n                        grid[i][j] = org ;\\n                }\\n            }\\n        }\\n    }\\n    \\n    for(int i = 0; i < idx; i++)\\n        free(queue[i]) ;\\n    free(queue) ;\\n    for(int i = 0; i < m; i++)\\n        free(used[i]) ;\\n    free(used) ;\\n    return grid;\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** colorBorder(int** grid, int gridSize, int* gridColSize, int row, int col, int color, int* returnSize, int** returnColumnSizes){\\n    int m = gridSize;\\n    int n = *gridColSize;\\n    *returnSize = m;\\n    *returnColumnSizes = malloc(m * sizeof(int ));\\n    for(int i = 0; i < m; i++){\\n        returnColumnSizes[0][i] = n;\\n    }\\n    if(grid[row][col] == color)\\n        return grid ;\\n    \\n    bool** used = malloc(m * sizeof(bool*));\\n    for(int i = 0; i < m; i++){\\n        used[i] = calloc(n , sizeof(bool));            \\n    }\\n    \\n    int dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}} ;\\n    \\n    int** queue = malloc(m * n * sizeof(int*));\\n    int org = grid[row][col] ;\\n    int idx = 0;\\n    queue[idx] = malloc(2 * sizeof(int));\\n    queue[idx][0] = row;\\n    queue[idx][1] = col;\\n    idx++;\\n    int pos = 0;\\n      \\n    used[row][col] = true ;\\n    grid[row][col] = -1*color ;\\n    while(pos < idx){\\n        int x = queue[pos][0];\\n        int y = queue[pos][1];\\n        for(int i = 0; i < 4; i++){\\n            int xx = x + dir[i][0] ;\\n            int yy = y + dir[i][1] ;\\n            if(xx < 0 || yy < 0 || xx >= m || yy >= n)\\n                continue ;\\n            if(used[xx][yy] || grid[xx][yy] != org)\\n                continue ;\\n            used[xx][yy] = true ;\\n            queue[idx] = malloc(2 * sizeof(int)) ;\\n            queue[idx][0] = xx ;\\n            queue[idx][1] = yy ;\\n            idx++ ;\\n            grid[xx][yy] = -1 * color ;\\n        }\\n        pos++;\\n    }\\n\\n    for(int i = 0; i < m; i++){\\n        for(int j = 0; j < n; j++){\\n            if(grid[i][j] == -1 * color){\\n                if(i == 0 || j == 0 || (i == (m-1)) || (j == (n-1)) ){\\n                    grid[i][j] = color ;\\n                    continue ;\\n                }\\n                for(int k = 0; k < 4; k++){\\n                    int ii = i + dir[k][0] ;\\n                    int jj = j + dir[k][1] ;\\n                    if(used[ii][jj] == false){\\n                        grid[i][j] = color ;\\n                        break ;\\n                    }\\n                    if(k == 3)\\n                        grid[i][j] = org ;\\n                }\\n            }\\n        }\\n    }\\n    \\n    for(int i = 0; i < idx; i++)\\n        free(queue[i]) ;\\n    free(queue) ;\\n    for(int i = 0; i < m; i++)\\n        free(used[i]) ;\\n    free(used) ;\\n    return grid;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3152022,
                "title": "easy-iterative-bfs-c-self-explanatory-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nSimple Bfs using Queue , just one make sure when you are performing Bfs from a node check whether all it 4 adjacent sides have same intial given color or not. If yes , then no need to color it , else color that node with given final color.\\nAll everything else like visited array , queue processing ,is same\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int iniColor = grid[row][col];\\n        vector<vector<int>> ans = grid;\\n        vector<vector<int>> vis (n,vector<int> (m,0));\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vis[row][col] = 1;\\n        int delrow[] = {0,-1,0,+1};\\n        int delcol[] = {+1,0,-1,0};\\n        while(!q.empty()){\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            int cnt = 0;\\n            for(int i=0;i<4;i++){\\n                int newrow = row + delrow[i];\\n                int newcol = col + delcol[i];\\n                if(newrow >= 0 && newrow < n && newcol >=0 && newcol < m && grid[newrow][newcol] == iniColor){\\n                    cnt++;\\n                    if(!vis[newrow][newcol]){\\n                        vis[newrow][newcol] = 1;\\n                        q.push({newrow,newcol});\\n                    }\\n                }\\n            }\\n            if(cnt != 4) ans[row][col] = color;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int iniColor = grid[row][col];\\n        vector<vector<int>> ans = grid;\\n        vector<vector<int>> vis (n,vector<int> (m,0));\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vis[row][col] = 1;\\n        int delrow[] = {0,-1,0,+1};\\n        int delcol[] = {+1,0,-1,0};\\n        while(!q.empty()){\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            int cnt = 0;\\n            for(int i=0;i<4;i++){\\n                int newrow = row + delrow[i];\\n                int newcol = col + delcol[i];\\n                if(newrow >= 0 && newrow < n && newcol >=0 && newcol < m && grid[newrow][newcol] == iniColor){\\n                    cnt++;\\n                    if(!vis[newrow][newcol]){\\n                        vis[newrow][newcol] = 1;\\n                        q.push({newrow,newcol});\\n                    }\\n                }\\n            }\\n            if(cnt != 4) ans[row][col] = color;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103474,
                "title": "easy-java-dfs-solution-with-clear-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    /**\\n     * We should only color the border not the elements inside the border.\\n     * Approach:\\n     * 1.Run a dfs from row,col and find all the elements in the connected component\\n     * 2.Once we get elements in the connected component, we can check if we have to color a element or not by following the below given rules\\n     * i)If the node is surrounded by all same color nodes don\\'t color it\\n     * ii)If the node at-least have one non-same color node adjacent to it, then color it\\n     */\\n    private static int prevColor;\\n    private static HashSet<Pair<Integer, Integer>> visited;\\n    private static ArrayList<Pair<Integer, Integer>> connectedComponent;\\n\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        prevColor = grid[row][col];\\n        visited = new HashSet<>();\\n        connectedComponent = new ArrayList<>();\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean flag = false;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == prevColor) {\\n                    dfs(grid, row, col);\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag) break;\\n        }\\n\\n        int newGrid[][] = new int[m][n];\\n        //copy grid to newGrid\\n        for (int i = 0; i < m; i++) {\\n            newGrid[i] = grid[i].clone();\\n        }\\n        for (int i = 0; i < connectedComponent.size(); i++) {\\n            Pair<Integer, Integer> p = connectedComponent.get(i);\\n\\n            if (!isSame(grid, p.getKey(), p.getValue(), prevColor)) {\\n                newGrid[p.getKey()][p.getValue()] = color;\\n            }\\n\\n        }\\n        return newGrid;\\n    }\\n\\n\\n    //Helper method to determine if we have to color or not\\n    private boolean isSame(int[][] grid, Integer row, Integer col, int prevColor) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int dirX[] = {0, -1, 0, 1};\\n        int dirY[] = {-1, 0, 1, 0};\\n        //iterate all the four directions and see if it is surrounded by same color\\n        for (int i = 0; i < dirX.length; i++) {\\n            int nextRow = dirX[i] + row;\\n            int nextCol = dirY[i] + col;\\n            if (!isValid(nextRow, nextCol, m, n) || grid[nextRow][nextCol] != prevColor) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private void dfs(int[][] grid, int row, int col) {\\n        visited.add(new Pair<Integer, Integer>(row, col));\\n        connectedComponent.add(new Pair<Integer, Integer>(row, col));\\n\\n        int dirX[] = {0, -1, 0, 1};\\n        int dirY[] = {-1, 0, 1, 0};\\n        for (int i = 0; i < dirX.length; i++) {\\n            int nextRow = dirX[i] + row;\\n            int nextCol = dirY[i] + col;\\n            if (isValid(nextRow, nextCol, grid.length, grid[0].length) && !visited.contains(new Pair<Integer, Integer>(nextRow, nextCol)) && grid[nextRow][nextCol] == prevColor) {\\n                dfs(grid, nextRow, nextCol);\\n            }\\n        }\\n    }\\n\\n    private boolean isValid(int nextRow, int nextCol, int m, int n) {\\n        return nextRow >= 0 && nextRow < m && nextCol >= 0 && nextCol < n;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    /**\\n     * We should only color the border not the elements inside the border.\\n     * Approach:\\n     * 1.Run a dfs from row,col and find all the elements in the connected component\\n     * 2.Once we get elements in the connected component, we can check if we have to color a element or not by following the below given rules\\n     * i)If the node is surrounded by all same color nodes don\\'t color it\\n     * ii)If the node at-least have one non-same color node adjacent to it, then color it\\n     */\\n    private static int prevColor;\\n    private static HashSet<Pair<Integer, Integer>> visited;\\n    private static ArrayList<Pair<Integer, Integer>> connectedComponent;\\n\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        prevColor = grid[row][col];\\n        visited = new HashSet<>();\\n        connectedComponent = new ArrayList<>();\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean flag = false;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == prevColor) {\\n                    dfs(grid, row, col);\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag) break;\\n        }\\n\\n        int newGrid[][] = new int[m][n];\\n        //copy grid to newGrid\\n        for (int i = 0; i < m; i++) {\\n            newGrid[i] = grid[i].clone();\\n        }\\n        for (int i = 0; i < connectedComponent.size(); i++) {\\n            Pair<Integer, Integer> p = connectedComponent.get(i);\\n\\n            if (!isSame(grid, p.getKey(), p.getValue(), prevColor)) {\\n                newGrid[p.getKey()][p.getValue()] = color;\\n            }\\n\\n        }\\n        return newGrid;\\n    }\\n\\n\\n    //Helper method to determine if we have to color or not\\n    private boolean isSame(int[][] grid, Integer row, Integer col, int prevColor) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int dirX[] = {0, -1, 0, 1};\\n        int dirY[] = {-1, 0, 1, 0};\\n        //iterate all the four directions and see if it is surrounded by same color\\n        for (int i = 0; i < dirX.length; i++) {\\n            int nextRow = dirX[i] + row;\\n            int nextCol = dirY[i] + col;\\n            if (!isValid(nextRow, nextCol, m, n) || grid[nextRow][nextCol] != prevColor) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private void dfs(int[][] grid, int row, int col) {\\n        visited.add(new Pair<Integer, Integer>(row, col));\\n        connectedComponent.add(new Pair<Integer, Integer>(row, col));\\n\\n        int dirX[] = {0, -1, 0, 1};\\n        int dirY[] = {-1, 0, 1, 0};\\n        for (int i = 0; i < dirX.length; i++) {\\n            int nextRow = dirX[i] + row;\\n            int nextCol = dirY[i] + col;\\n            if (isValid(nextRow, nextCol, grid.length, grid[0].length) && !visited.contains(new Pair<Integer, Integer>(nextRow, nextCol)) && grid[nextRow][nextCol] == prevColor) {\\n                dfs(grid, nextRow, nextCol);\\n            }\\n        }\\n    }\\n\\n    private boolean isValid(int nextRow, int nextCol, int m, int n) {\\n        return nextRow >= 0 && nextRow < m && nextCol >= 0 && nextCol < n;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078407,
                "title": "c-bfs-easy-understanding-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe are using bfs here.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe start bfs from the given node (row,col).\\nnow we check it\\'s neighbours if it is has same color then we push in queue and increment the counter .\\nif value of counter is less than 4 than we have to recolor to thisw node with given color.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N*M)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N*M)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint n,m;\\nint dx[4]={-1,0,1,0};\\nint dy[4]={0,1,0,-1};\\nvector<vector<int>>vis,ans;\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        ans.resize(n,vector<int>(m,0));\\n        vis.resize(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans[i][j]=grid[i][j];\\n            }\\n        }\\n        queue<pair<int,int>>q;\\n        int c=grid[row][col];\\n        q.push({row,col});\\n        vis[row][col]=1;\\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            q.pop();\\n            int cnt=0;\\n             for(int i=0;i<4;i++){\\n                 int nx=x+dx[i];\\n                 int ny=y+dy[i];\\n                 if(nx>=0 && nx<n && ny>=0 && ny<m && grid[nx][ny]==c){\\n                     cnt++;\\n                     \\n                     if(!vis[nx][ny]){\\n                      q.push({nx,ny});\\n                      vis[nx][ny]=1;\\n                     }\\n                 }\\n             }\\n\\n             if(cnt<4){\\n                 ans[x][y]=color;\\n             }\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint n,m;\\nint dx[4]={-1,0,1,0};\\nint dy[4]={0,1,0,-1};\\nvector<vector<int>>vis,ans;\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        ans.resize(n,vector<int>(m,0));\\n        vis.resize(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans[i][j]=grid[i][j];\\n            }\\n        }\\n        queue<pair<int,int>>q;\\n        int c=grid[row][col];\\n        q.push({row,col});\\n        vis[row][col]=1;\\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            q.pop();\\n            int cnt=0;\\n             for(int i=0;i<4;i++){\\n                 int nx=x+dx[i];\\n                 int ny=y+dy[i];\\n                 if(nx>=0 && nx<n && ny>=0 && ny<m && grid[nx][ny]==c){\\n                     cnt++;\\n                     \\n                     if(!vis[nx][ny]){\\n                      q.push({nx,ny});\\n                      vis[nx][ny]=1;\\n                     }\\n                 }\\n             }\\n\\n             if(cnt<4){\\n                 ans[x][y]=color;\\n             }\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067884,
                "title": "backtracking-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] arr, int row, int col, int color) {\\n        check(arr,row,col,arr[row][col]);\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=0;j<arr[0].length;j++){\\n                if(arr[i][j]<0){\\n                    arr[i][j] = color;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n    public void check(int[][] arr,int row,int col,int clr){\\n        arr[row][col] = -clr;\\n\\n        // check in 4 direction\\n        int count=0;\\n        for(int i=0;i<4;i++){\\n            // check coonected component;\\n            int r = row + dir[i][0];\\n            int c = col + dir[i][1];\\n\\n            if(r<0 || r>=arr.length || c<0 || c>=arr[0].length || Math.abs(arr[r][c]) != clr){\\n                continue;\\n            }\\n\\n            count++;\\n            if(arr[r][c]==clr){\\n                check(arr,r,c,clr);\\n            }\\n        }\\n\\n        // check if all dir same or not\\n        if(count==4){\\n            arr[row][col]=clr;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] arr, int row, int col, int color) {\\n        check(arr,row,col,arr[row][col]);\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=0;j<arr[0].length;j++){\\n                if(arr[i][j]<0){\\n                    arr[i][j] = color;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n    public void check(int[][] arr,int row,int col,int clr){\\n        arr[row][col] = -clr;\\n\\n        // check in 4 direction\\n        int count=0;\\n        for(int i=0;i<4;i++){\\n            // check coonected component;\\n            int r = row + dir[i][0];\\n            int c = col + dir[i][1];\\n\\n            if(r<0 || r>=arr.length || c<0 || c>=arr[0].length || Math.abs(arr[r][c]) != clr){\\n                continue;\\n            }\\n\\n            count++;\\n            if(arr[r][c]==clr){\\n                check(arr,r,c,clr);\\n            }\\n        }\\n\\n        // check if all dir same or not\\n        if(count==4){\\n            arr[row][col]=clr;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056667,
                "title": "clean-python-9-lines-high-speed-o-n-time-o-1-space-beats-96-9",
                "content": "\\n# Python, DFS:\\n##### We can color the border inside the DFS.\\n\\n```\\nclass Solution:\\n    def colorBorder(self, grid, r0, c0, color):\\n        seen, m, n = set(), len(grid), len(grid[0])\\n        def dfs(x, y):\\n            if (x, y) in seen: return True\\n            if not (0 <= x < m and 0 <= y < n and grid[x][y] == grid[r0][c0]): return False\\n            seen.add((x, y))\\n            if dfs(x + 1, y) + dfs(x - 1, y) + dfs(x, y + 1) + dfs(x, y - 1) < 4: grid[x][y] = color\\n            return True\\n        dfs(r0, c0)\\n        return grid\\n```\\n\\n# Python, BFS:\\n\\n```\\n    def colorBorder(self, grid, r0, c0, color):\\n        m, n = len(grid), len(grid[0])\\n        bfs, component, border = [[r0, c0]], set([(r0, c0)]), set()\\n        for r0, c0 in bfs:\\n            for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n                r, c = r0 + i, c0 + j\\n                if 0 <= r < m and 0 <= c < n and grid[r][c] == grid[r0][c0]:\\n                    if (r, c) not in component:\\n                        bfs.append([r, c])\\n                        component.add((r, c))\\n                else: border.add((r0, c0))\\n        for x, y in border: grid[x][y] = color\\n        return grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid, r0, c0, color):\\n        seen, m, n = set(), len(grid), len(grid[0])\\n        def dfs(x, y):\\n            if (x, y) in seen: return True\\n            if not (0 <= x < m and 0 <= y < n and grid[x][y] == grid[r0][c0]): return False\\n            seen.add((x, y))\\n            if dfs(x + 1, y) + dfs(x - 1, y) + dfs(x, y + 1) + dfs(x, y - 1) < 4: grid[x][y] = color\\n            return True\\n        dfs(r0, c0)\\n        return grid\\n```\n```\\n    def colorBorder(self, grid, r0, c0, color):\\n        m, n = len(grid), len(grid[0])\\n        bfs, component, border = [[r0, c0]], set([(r0, c0)]), set()\\n        for r0, c0 in bfs:\\n            for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n                r, c = r0 + i, c0 + j\\n                if 0 <= r < m and 0 <= c < n and grid[r][c] == grid[r0][c0]:\\n                    if (r, c) not in component:\\n                        bfs.append([r, c])\\n                        component.add((r, c))\\n                else: border.add((r0, c0))\\n        for x, y in border: grid[x][y] = color\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049602,
                "title": "simple-java-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int len, wid;\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        this.len = grid.length;\\n        this.wid = grid[0].length;\\n        Dfs(grid, row, col, grid[row][col]);\\n        for(int i = 0; i < len; i++) {\\n            for(int j = 0; j < wid; j++) {\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    public void Dfs(int[][] grid, int row, int col, int color) {\\n        grid[row][col] = -color; \\n        int count = 0;\\n        for(int i = 0; i < 4; i++) {\\n            int rowdash = row + dir[i][0];\\n            int coldash = col + dir[i][1];\\n            if(rowdash < 0 || coldash < 0 || rowdash >= len || coldash >= wid \\n            || Math.abs(grid[rowdash][coldash]) != color) {\\n                continue;\\n            }\\n            count++; \\n            if(grid[rowdash][coldash] == color)\\n                Dfs(grid, rowdash, coldash, color);\\n        }\\n        if(count == 4)\\n            grid[row][col] = color;\\n    }\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int len, wid;\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        this.len = grid.length;\\n        this.wid = grid[0].length;\\n        Dfs(grid, row, col, grid[row][col]);\\n        for(int i = 0; i < len; i++) {\\n            for(int j = 0; j < wid; j++) {\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    public void Dfs(int[][] grid, int row, int col, int color) {\\n        grid[row][col] = -color; \\n        int count = 0;\\n        for(int i = 0; i < 4; i++) {\\n            int rowdash = row + dir[i][0];\\n            int coldash = col + dir[i][1];\\n            if(rowdash < 0 || coldash < 0 || rowdash >= len || coldash >= wid \\n            || Math.abs(grid[rowdash][coldash]) != color) {\\n                continue;\\n            }\\n            count++; \\n            if(grid[rowdash][coldash] == color)\\n                Dfs(grid, rowdash, coldash, color);\\n        }\\n        if(count == 4)\\n            grid[row][col] = color;\\n    }\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041332,
                "title": "95-faster-easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>g(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                g[i][j]=grid[i][j];\\n            }\\n        }\\n        queue<pair<int,int>>q;\\n        q.push({row,col});\\n        int y=grid[row][col];\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int dr[]={0,-1,0,1};\\n        int dc[]={1,0,-1,0};\\n        while(!q.empty()){\\n            auto it=q.front();\\n            q.pop();\\n            int r=it.first;\\n            int c=it.second;\\n            if(vis[r][c]==1)continue;\\n            vis[r][c]=1;\\n            for(int i=0;i<4;i++){\\n                int nr=r+dr[i];\\n                int nc=c+dc[i];\\n                if(nr>=0&&nr<n&&nc>=0&&nc<m){\\n                    if(grid[nr][nc]==y){\\n                        q.push({nr,nc});\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==1){\\n                    if((i==0&&j>=0&&j<m)||(i==n-1&&j>=0&&j<m)\\n                    ||(j==0&&i>=0&&i<n)||(j==m-1&&i>=0&&i<n)){\\n                        g[i][j]=color;\\n                        continue;\\n\\n                    }\\n                    for(int x=0;x<4;x++){\\n                        int nr=i+dr[x];\\n                        int nc=j+dc[x];\\n                        \\n                        if((nr>=0&&nr<n&&nc>=0&&nc<m&&grid[nr][nc]!=y)){\\n                            g[i][j]=color;\\n                            continue;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return g;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>g(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                g[i][j]=grid[i][j];\\n            }\\n        }\\n        queue<pair<int,int>>q;\\n        q.push({row,col});\\n        int y=grid[row][col];\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int dr[]={0,-1,0,1};\\n        int dc[]={1,0,-1,0};\\n        while(!q.empty()){\\n            auto it=q.front();\\n            q.pop();\\n            int r=it.first;\\n            int c=it.second;\\n            if(vis[r][c]==1)continue;\\n            vis[r][c]=1;\\n            for(int i=0;i<4;i++){\\n                int nr=r+dr[i];\\n                int nc=c+dc[i];\\n                if(nr>=0&&nr<n&&nc>=0&&nc<m){\\n                    if(grid[nr][nc]==y){\\n                        q.push({nr,nc});\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==1){\\n                    if((i==0&&j>=0&&j<m)||(i==n-1&&j>=0&&j<m)\\n                    ||(j==0&&i>=0&&i<n)||(j==m-1&&i>=0&&i<n)){\\n                        g[i][j]=color;\\n                        continue;\\n\\n                    }\\n                    for(int x=0;x<4;x++){\\n                        int nr=i+dr[x];\\n                        int nc=j+dc[x];\\n                        \\n                        if((nr>=0&&nr<n&&nc>=0&&nc<m&&grid[nr][nc]!=y)){\\n                            g[i][j]=color;\\n                            continue;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return g;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034757,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn color_border(grid: Vec<Vec<i32>>, row: i32, col: i32, color: i32) -> Vec<Vec<i32>> {\\n        fn dfs(grid: &mut Vec<Vec<i32>>, r: i32, c: i32, cl: i32) {\\n            if r < 0\\n                || r >= grid.len() as i32\\n                || c < 0\\n                || c >= grid[r as usize].len() as i32\\n                || grid[r as usize][c as usize] != cl\\n            {\\n                return;\\n            }\\n            grid[r as usize][c as usize] = -cl;\\n            dfs(grid, r - 1, c, cl);\\n            dfs(grid, r + 1, c, cl);\\n            dfs(grid, r, c - 1, cl);\\n            dfs(grid, r, c + 1, cl);\\n            if r > 0\\n                && r < grid.len() as i32 - 1\\n                && c > 0\\n                && c < grid[r as usize].len() as i32 - 1\\n                && cl == grid[(r - 1) as usize][c as usize].abs()\\n                && cl == grid[(r + 1) as usize][c as usize].abs()\\n                && cl == grid[r as usize][(c - 1) as usize].abs()\\n                && cl == grid[r as usize][(c + 1) as usize].abs()\\n            {\\n                grid[r as usize][c as usize] = cl;\\n            }\\n        }\\n\\n        let mut grid = grid;\\n        let cl = grid[row as usize][col as usize];\\n        dfs(&mut grid, row, col, cl);\\n        for item in grid.iter_mut() {\\n            for pt in item.iter_mut() {\\n                *pt = if *pt < 0 { color } else { *pt };\\n            }\\n        }\\n        grid\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn color_border(grid: Vec<Vec<i32>>, row: i32, col: i32, color: i32) -> Vec<Vec<i32>> {\\n        fn dfs(grid: &mut Vec<Vec<i32>>, r: i32, c: i32, cl: i32) {\\n            if r < 0\\n                || r >= grid.len() as i32\\n                || c < 0\\n                || c >= grid[r as usize].len() as i32\\n                || grid[r as usize][c as usize] != cl\\n            {\\n                return;\\n            }\\n            grid[r as usize][c as usize] = -cl;\\n            dfs(grid, r - 1, c, cl);\\n            dfs(grid, r + 1, c, cl);\\n            dfs(grid, r, c - 1, cl);\\n            dfs(grid, r, c + 1, cl);\\n            if r > 0\\n                && r < grid.len() as i32 - 1\\n                && c > 0\\n                && c < grid[r as usize].len() as i32 - 1\\n                && cl == grid[(r - 1) as usize][c as usize].abs()\\n                && cl == grid[(r + 1) as usize][c as usize].abs()\\n                && cl == grid[r as usize][(c - 1) as usize].abs()\\n                && cl == grid[r as usize][(c + 1) as usize].abs()\\n            {\\n                grid[r as usize][c as usize] = cl;\\n            }\\n        }\\n\\n        let mut grid = grid;\\n        let cl = grid[row as usize][col as usize];\\n        dfs(&mut grid, row, col, cl);\\n        for item in grid.iter_mut() {\\n            for pt in item.iter_mut() {\\n                *pt = if *pt < 0 { color } else { *pt };\\n            }\\n        }\\n        grid\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3031681,
                "title": "cpp-bfs-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    void bfs(vector<vector<int>>grid,vector<vector<int>>&visited,int row,int col,int value) {\\n        \\n        queue<pair<int,int>>q;\\n        q.push({row,col});\\n        visited[row][col] = 1;\\n        while(!q.empty()) {\\n           \\n            int row = q.front().first;\\n            int col = q.front().second;\\n            \\n            q.pop();\\n            int a = row + 1;\\n            int b = row - 1;\\n            int c = col + 1;\\n            int d = col - 1;\\n            if(a>=0&&col>=0&&a<grid.size()&&col<grid[0].size()&&grid[a][col]==value&&visited[a][col]==0){\\n                \\n                q.push({a,col});\\n                visited[a][col] = 1;\\n            }\\n                   if(b>=0&&col>=0&&b<grid.size()&&col<grid[0].size()&&grid[b][col]==value&&visited[b][col]==0){\\n                      \\n                q.push({b,col});\\n                visited[b][col] = 1;\\n            }\\n                             if(row>=0&&c>=0&&row<grid.size()&&c<grid[0].size()&&grid[row][c]==value&&visited[row][c]==0){\\n                                \\n                q.push({row,c});\\n                visited[row][c] = 1;\\n            }\\n                                         if(row>=0&&d>=0&&row<grid.size()&&d<grid[0].size()&&grid[row][d]==value&&visited[row][d]==0){\\n                                             \\n                q.push({row,d});\\n                visited[row][d] = 1;\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>visited(n,vector<int>(m,0));\\n        int val=grid[row][col];\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        ans=grid;\\n        bfs(grid,visited,row,col,val);\\n        \\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     for(int j=0;j<m;j++)\\n        //     {\\n        //         cout<<grid[i][j]<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        // cout<<endl<<endl;\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            for(int j=0;j<m;j++){\\n          \\n              \\n                if(i>0&&j>0&&i<grid.size()-1&&j<grid[i].size()-1)\\n                {\\n                     int a = i + 1;\\n                     int b = i - 1;\\n                     int c = j + 1;\\n                     int d = j - 1; \\n                    \\n                     if(grid[a][j]==val&&grid[b][j]==val&&grid[i]                                     [c]==val&&grid[i][d]==val)\\n                     {\\n                       \\n                             ans[i][j]=grid[i][j];\\n                         \\n                         \\n                     }\\n                    else\\n                    {\\n                          if(visited[i][j]==1)\\n                    {\\n                        ans[i][j]=color;\\n                    }\\n                    else\\n                    {\\n                        ans[i][j]=grid[i][j];\\n                    }\\n                    }\\n        \\n         \\n                   }\\n                else\\n                {\\n                    if(visited[i][j]==1)\\n                    {\\n                        ans[i][j]=color;\\n                    }\\n                    else\\n                    {\\n                        ans[i][j]=grid[i][j];\\n                    }\\n                }\\n            \\n            }\\n           \\n        }\\n        return ans;\\n        \\n    \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void bfs(vector<vector<int>>grid,vector<vector<int>>&visited,int row,int col,int value) {\\n        \\n        queue<pair<int,int>>q;\\n        q.push({row,col}",
                "codeTag": "Java"
            },
            {
                "id": 3027562,
                "title": "go-bfs-beat-100",
                "content": "# Code\\n```\\nfunc colorBorder(grid [][]int, row int, col int, color int) [][]int {\\n    m, n := len(grid), len(grid[0])\\n    directions := [][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}\\n    borders := make([][]int, 0, 10)\\n    queue := make([][]int, 0, 10)\\n    visited := make([][]int, m)\\n    for i := 0; i < m; i++ {\\n        visited[i] = make([]int, n)\\n    }\\n\\n    queue = append(queue, []int{row, col})\\n    connectedValue := grid[row][col]\\n    for len(queue) > 0 {\\n        i, j := queue[0][0], queue[0][1]\\n        queue = queue[1:]\\n        visited[i][j] = 1\\n        \\n        isBorder := false\\n        for _, d := range directions {\\n            di, dj := i+d[0], j+d[1]\\n            if di >= 0 && di < m && dj >= 0 && dj < n {\\n                if grid[di][dj] == connectedValue {\\n                    if visited[di][dj] == 0 {\\n                        queue = append(queue, []int{di, dj})\\n                    }\\n                } else {\\n                    isBorder = true\\n                }\\n            } else {\\n                isBorder = true\\n            }\\n        }\\n        if isBorder {\\n            borders = append(borders, []int{i, j})\\n        }\\n\\n    }\\n    for _, b := range borders {\\n        i, j := b[0], b[1]\\n        grid[i][j] = color\\n    }\\n\\n    return grid \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc colorBorder(grid [][]int, row int, col int, color int) [][]int {\\n    m, n := len(grid), len(grid[0])\\n    directions := [][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}\\n    borders := make([][]int, 0, 10)\\n    queue := make([][]int, 0, 10)\\n    visited := make([][]int, m)\\n    for i := 0; i < m; i++ {\\n        visited[i] = make([]int, n)\\n    }\\n\\n    queue = append(queue, []int{row, col})\\n    connectedValue := grid[row][col]\\n    for len(queue) > 0 {\\n        i, j := queue[0][0], queue[0][1]\\n        queue = queue[1:]\\n        visited[i][j] = 1\\n        \\n        isBorder := false\\n        for _, d := range directions {\\n            di, dj := i+d[0], j+d[1]\\n            if di >= 0 && di < m && dj >= 0 && dj < n {\\n                if grid[di][dj] == connectedValue {\\n                    if visited[di][dj] == 0 {\\n                        queue = append(queue, []int{di, dj})\\n                    }\\n                } else {\\n                    isBorder = true\\n                }\\n            } else {\\n                isBorder = true\\n            }\\n        }\\n        if isBorder {\\n            borders = append(borders, []int{i, j})\\n        }\\n\\n    }\\n    for _, b := range borders {\\n        i, j := b[0], b[1]\\n        grid[i][j] = color\\n    }\\n\\n    return grid \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3011082,
                "title": "easy-java-dfs-with-comments",
                "content": "# Intuition\\n4 directions neighbor tells if a cell is border or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    private int m;\\n    private int n;\\n    private boolean[][] visited;\\n    \\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        visited = new boolean[m][n];\\n        process(grid, row, col, grid[row][col], color);\\n        return grid;\\n    }\\n\\n    private int process(int[][] grid, int row, int col, int origColor, int color) {\\n        // out of bundary\\n        if (row < 0 || row >= m || col < 0 || col >= n) {\\n            return 0;\\n        }\\n\\n        // already visited\\n        if (visited[row][col]) {\\n            return 1;\\n        }\\n\\n        // different color\\n        if (grid[row][col] != origColor) {\\n            return 0;\\n        }\\n\\n        visited[row][col] = true;\\n\\n        // sum up score from 4 directions\\n        int score = process(grid, row - 1, col, origColor, color) + process(grid, row, col + 1, origColor, color) + process(grid, row + 1, col, origColor, color) + process(grid, row, col - 1, origColor, color);\\n\\n        // if score is less than 4, the cell (x, y) is a border\\n        if (score < 4) {\\n            grid[row][col] = color;\\n        }\\n\\n        // inner component cell, return 1 \\n        return 1;\\n    }\\n}\\n\\n\\n/*\\n\\nKey point is to understand what \"border\" is.\\n1. a border cell must belong to connected component \\n2. a border cell is either:\\n    a. connected to a different color cell\\n    b. boundary\\n\\ne.g.\\n\\n[0, 0, 0]\\n[1, 1, 1]\\n[1, 1, 1]\\n[1, 1, 1]\\n\\nrow = 2, col = 1, color = 2\\ncell(2, 1) \\n\\n[0, 0, 0]\\n[2, 2, 2]\\n[2, 1, 2]\\n[2, 2, 2]\\n\\nfor a cell (x, y)\\nif it\\'s inner component, it is surrounded by 4 same-color cells\\nif it\\'s border,\\n    1. it\\'s bundary\\n    2. it\\'s connected to a different color\\n\\nto determine if a cell(x, y) is inner component, we can ask its surranders.\\nif a surrander is same color, it returns 1\\notherwise, bundary returns 0, different color returns 0.\\n\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private int m;\\n    private int n;\\n    private boolean[][] visited;\\n    \\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        visited = new boolean[m][n];\\n        process(grid, row, col, grid[row][col], color);\\n        return grid;\\n    }\\n\\n    private int process(int[][] grid, int row, int col, int origColor, int color) {\\n        // out of bundary\\n        if (row < 0 || row >= m || col < 0 || col >= n) {\\n            return 0;\\n        }\\n\\n        // already visited\\n        if (visited[row][col]) {\\n            return 1;\\n        }\\n\\n        // different color\\n        if (grid[row][col] != origColor) {\\n            return 0;\\n        }\\n\\n        visited[row][col] = true;\\n\\n        // sum up score from 4 directions\\n        int score = process(grid, row - 1, col, origColor, color) + process(grid, row, col + 1, origColor, color) + process(grid, row + 1, col, origColor, color) + process(grid, row, col - 1, origColor, color);\\n\\n        // if score is less than 4, the cell (x, y) is a border\\n        if (score < 4) {\\n            grid[row][col] = color;\\n        }\\n\\n        // inner component cell, return 1 \\n        return 1;\\n    }\\n}\\n\\n\\n/*\\n\\nKey point is to understand what \"border\" is.\\n1. a border cell must belong to connected component \\n2. a border cell is either:\\n    a. connected to a different color cell\\n    b. boundary\\n\\ne.g.\\n\\n[0, 0, 0]\\n[1, 1, 1]\\n[1, 1, 1]\\n[1, 1, 1]\\n\\nrow = 2, col = 1, color = 2\\ncell(2, 1) \\n\\n[0, 0, 0]\\n[2, 2, 2]\\n[2, 1, 2]\\n[2, 2, 2]\\n\\nfor a cell (x, y)\\nif it\\'s inner component, it is surrounded by 4 same-color cells\\nif it\\'s border,\\n    1. it\\'s bundary\\n    2. it\\'s connected to a different color\\n\\nto determine if a cell(x, y) is inner component, we can ask its surranders.\\nif a surrander is same color, it returns 1\\notherwise, bundary returns 0, different color returns 0.\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991007,
                "title": "simple-c-solution-by-breaking-into-steps",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int n , m;\\n    void markMinusOne(int i , int j , int color , vector<vector<int>> &grid){\\n        if(i<0 or j<0 or i>=n or j>=m) return;\\n        if(grid[i][j]!=color) return;\\n\\n        grid[i][j] = -1;\\n\\n        markMinusOne(i+1 , j , color, grid);\\n        markMinusOne(i-1 , j , color, grid);\\n        markMinusOne(i , j+1 , color, grid);\\n        markMinusOne(i , j-1 , color, grid);\\n    }\\n\\n\\n\\n    bool isSurrounded(int i , int j , vector<vector<int>>&grid){\\n        if(i==0 or  j==0 or  i==n-1 or  j==m-1) return false;\\n        if(i!=0 && !(grid[i-1][j]==-1 or grid[i-1][j]==0)) return false;\\n        if(j!=0 && !(grid[i][j-1]==-1 or grid[i][j-1]==0)) return false;\\n        if(i!=n-1 && !(grid[i+1][j]==-1 or grid[i+1][j]==0)) return false;\\n        if(j!=m-1 && !(grid[i][j+1]==-1 or grid[i][j+1]==0)) return false;\\n        return true;\\n    }\\n\\n    void undoInner(int i , int j ,int color ,vector<vector<bool>>&vis  ,vector<vector<int>>&grid){\\n        if(i<0 or j<0 or i>=n or j>=m) return;\\n        if(grid[i][j]!=-1 or vis[i][j]) return;\\n        vis[i][j] = true;\\n\\n        if(isSurrounded(i , j , grid)){\\n            grid[i][j] = 0;\\n        }\\n\\n        undoInner(i+1 , j , color, vis ,grid);\\n        undoInner(i-1 , j , color, vis ,grid);\\n        undoInner(i , j+1 , color,  vis ,grid);\\n        undoInner(i , j-1 , color, vis ,grid);\\n\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int x = grid[row][col];\\n        n = grid.size();\\n        m = grid[0].size();\\n        // -1 -> with color x\\n        // 0 -> inner x within the component\\n\\n        // marking the x as -1 in the connected component\\n        markMinusOne(row , col , x , grid);\\n\\n        // marking the inner x as 0 in the connected component\\n        vector<vector<bool>> vis(n , vector<bool>(m , false));\\n        undoInner(row , col , x , vis ,grid);\\n\\n        // coloring the -1 with color in the connected component and inner blocks as x\\n        for(int i=0 ; i<n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                if(grid[i][j]==-1)grid[i][j] = color;\\n                if(grid[i][j]==0) grid[i][j] = x;\\n            }\\n        }\\n\\n\\n        // returning the final grid\\n\\n        return grid;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n , m;\\n    void markMinusOne(int i , int j , int color , vector<vector<int>> &grid){\\n        if(i<0 or j<0 or i>=n or j>=m) return;\\n        if(grid[i][j]!=color) return;\\n\\n        grid[i][j] = -1;\\n\\n        markMinusOne(i+1 , j , color, grid);\\n        markMinusOne(i-1 , j , color, grid);\\n        markMinusOne(i , j+1 , color, grid);\\n        markMinusOne(i , j-1 , color, grid);\\n    }\\n\\n\\n\\n    bool isSurrounded(int i , int j , vector<vector<int>>&grid){\\n        if(i==0 or  j==0 or  i==n-1 or  j==m-1) return false;\\n        if(i!=0 && !(grid[i-1][j]==-1 or grid[i-1][j]==0)) return false;\\n        if(j!=0 && !(grid[i][j-1]==-1 or grid[i][j-1]==0)) return false;\\n        if(i!=n-1 && !(grid[i+1][j]==-1 or grid[i+1][j]==0)) return false;\\n        if(j!=m-1 && !(grid[i][j+1]==-1 or grid[i][j+1]==0)) return false;\\n        return true;\\n    }\\n\\n    void undoInner(int i , int j ,int color ,vector<vector<bool>>&vis  ,vector<vector<int>>&grid){\\n        if(i<0 or j<0 or i>=n or j>=m) return;\\n        if(grid[i][j]!=-1 or vis[i][j]) return;\\n        vis[i][j] = true;\\n\\n        if(isSurrounded(i , j , grid)){\\n            grid[i][j] = 0;\\n        }\\n\\n        undoInner(i+1 , j , color, vis ,grid);\\n        undoInner(i-1 , j , color, vis ,grid);\\n        undoInner(i , j+1 , color,  vis ,grid);\\n        undoInner(i , j-1 , color, vis ,grid);\\n\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int x = grid[row][col];\\n        n = grid.size();\\n        m = grid[0].size();\\n        // -1 -> with color x\\n        // 0 -> inner x within the component\\n\\n        // marking the x as -1 in the connected component\\n        markMinusOne(row , col , x , grid);\\n\\n        // marking the inner x as 0 in the connected component\\n        vector<vector<bool>> vis(n , vector<bool>(m , false));\\n        undoInner(row , col , x , vis ,grid);\\n\\n        // coloring the -1 with color in the connected component and inner blocks as x\\n        for(int i=0 ; i<n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                if(grid[i][j]==-1)grid[i][j] = color;\\n                if(grid[i][j]==0) grid[i][j] = x;\\n            }\\n        }\\n\\n\\n        // returning the final grid\\n\\n        return grid;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981040,
                "title": "java-solution-0ms-100-faster",
                "content": "Start **DFS** from current point \\n-> If current point is on border of the matrix,mark it with border color\\n->Check 4 directions, If a non-same region,non-border element found,mark current point with border color\\n\\nNote:Here, **```borderValidity```** is a number indicating number of foreign regions or grid borders are in the neighborhood of current cell\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        dfs(grid,row,col,grid.length,grid[0].length,\\n        color,grid[row][col],new boolean[grid.length][grid[0].length]);\\n        return grid;\\n    }\\n\\n   int dfs(int[][] arr,int i,int j,int row,int col,\\n    int borderColor,int regionColor,boolean[][] visited){\\n        if(i<0 || i>=row || j<0 || j>=col) return 1;\\n        if(visited[i][j]) return 0;\\n        if(arr[i][j]!=regionColor) return 1;\\n        visited[i][j] = true;\\n\\n        int borderValidity = 0;\\n        borderValidity+=dfs(arr,i+1,j,row,col,borderColor,regionColor,visited);\\n        borderValidity+=dfs(arr,i,j+1,row,col,borderColor,regionColor,visited);\\n        borderValidity+=dfs(arr,i-1,j,row,col,borderColor,regionColor,visited);\\n        borderValidity+=dfs(arr,i,j-1,row,col,borderColor,regionColor,visited);\\n\\n        if(borderValidity>0) arr[i][j] = borderColor;\\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```borderValidity```\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        dfs(grid,row,col,grid.length,grid[0].length,\\n        color,grid[row][col],new boolean[grid.length][grid[0].length]);\\n        return grid;\\n    }\\n\\n   int dfs(int[][] arr,int i,int j,int row,int col,\\n    int borderColor,int regionColor,boolean[][] visited){\\n        if(i<0 || i>=row || j<0 || j>=col) return 1;\\n        if(visited[i][j]) return 0;\\n        if(arr[i][j]!=regionColor) return 1;\\n        visited[i][j] = true;\\n\\n        int borderValidity = 0;\\n        borderValidity+=dfs(arr,i+1,j,row,col,borderColor,regionColor,visited);\\n        borderValidity+=dfs(arr,i,j+1,row,col,borderColor,regionColor,visited);\\n        borderValidity+=dfs(arr,i-1,j,row,col,borderColor,regionColor,visited);\\n        borderValidity+=dfs(arr,i,j-1,row,col,borderColor,regionColor,visited);\\n\\n        if(borderValidity>0) arr[i][j] = borderColor;\\n        return 0;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937057,
                "title": "beats-98-8-1-ms-java-intuitive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# We should color the cell iff:\\n- The cell is on the grid border\\n- or any of its neighbours does not have the same color\\n\\n# Complexity\\n- Time complexity: O(nxm) won\\'t visit the same cell more than once\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(nxm) for the visited array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        return dfs(grid, row, col, color, visited);\\n    }\\n    public int[][] dfs(int[][] grid, int row, int col, int color, boolean[][] visited){\\n        visited[row][col] = true;\\n        boolean isBoundry = false;\\n        if(row == 0 || row == grid.length - 1 || col == 0 || col == grid[0].length - 1)\\n            isBoundry = true;\\n        int[] rd = {1, 0, -1, 0};\\n        int[] cd = {0, 1, 0, -1};\\n        for(int i = 0; i < 4; i++){\\n            int newRow = row + rd[i];\\n            int newCol = col + cd[i];\\n            if(isValid(grid, newRow, newCol) && !visited[newRow][newCol]){\\n                if(grid[newRow][newCol] == grid[row][col])\\n                    dfs(grid, newRow, newCol, color, visited);\\n                else isBoundry = true;\\n            }\\n        }\\n        if(isBoundry) grid[row][col] = color;\\n        return grid;\\n    }\\n    public boolean isValid(int[][] grid, int row, int col){\\n        return row >= 0 && row < grid.length && col >= 0 && col < grid[0].length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        return dfs(grid, row, col, color, visited);\\n    }\\n    public int[][] dfs(int[][] grid, int row, int col, int color, boolean[][] visited){\\n        visited[row][col] = true;\\n        boolean isBoundry = false;\\n        if(row == 0 || row == grid.length - 1 || col == 0 || col == grid[0].length - 1)\\n            isBoundry = true;\\n        int[] rd = {1, 0, -1, 0};\\n        int[] cd = {0, 1, 0, -1};\\n        for(int i = 0; i < 4; i++){\\n            int newRow = row + rd[i];\\n            int newCol = col + cd[i];\\n            if(isValid(grid, newRow, newCol) && !visited[newRow][newCol]){\\n                if(grid[newRow][newCol] == grid[row][col])\\n                    dfs(grid, newRow, newCol, color, visited);\\n                else isBoundry = true;\\n            }\\n        }\\n        if(isBoundry) grid[row][col] = color;\\n        return grid;\\n    }\\n    public boolean isValid(int[][] grid, int row, int col){\\n        return row >= 0 && row < grid.length && col >= 0 && col < grid[0].length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914741,
                "title": "javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @param {number} row\\n * @param {number} col\\n * @param {number} color\\n * @return {number[][]}\\n */\\nvar colorBorder = function(grid, row, col, color) {\\n    const borderCells = getSolution(grid, row, col, color)()\\n\\n    for(let i=0; i < borderCells.length; i++){\\n        const {row,col} = borderCells[i]\\n\\n        grid[row][col] = color\\n    }\\n\\n    return grid\\n};\\n\\nfunction getSolution(grid, row, col, color){\\n    const visited = {}\\n    const borderCells = []\\n\\n    const componentColor = grid[row][col]\\n    return function(){\\n        const queue = [{row,col}]\\n\\n        while (queue.length) {\\n            const currentPos = queue.shift();\\n            visited[`${currentPos.row}|${currentPos.col}`] = true\\n\\n            if (isABorderCell(currentPos, grid)) {\\n                borderCells.push(currentPos);\\n            }\\n\\n            queue.push(\\n                ...getNeighbouringCells(currentPos, grid).filter(\\n                    pos =>\\n                        Boolean(pos) &&\\n                        visited[`${pos.row}|${pos.col}`] !== true &&\\n                        grid[pos.row][pos.col] === componentColor\\n                )\\n            );\\n        }\\n\\n        return borderCells\\n    }\\n}\\n\\nfunction isABorderCell({ row, col }, grid) {\\n  return (\\n    row === 0 ||\\n    col === 0 ||\\n    row === grid.length - 1 ||\\n    col === grid[0].length - 1 ||\\n    (\\n        grid[row - 1][col] !== grid[row][col]\\n        || grid[row + 1][col] !== grid[row][col]\\n        || grid[row][col - 1] !== grid[row][col]\\n        || grid[row][col + 1] !== grid[row][col]\\n    )\\n  );\\n}\\n\\nfunction getNeighbouringCells({ row, col }, grid){\\n    return [\\n        getNextPos(\"l\", { row, col }, grid),\\n        getNextPos(\"r\", { row, col }, grid),\\n        getNextPos(\"u\", { row, col }, grid),\\n        getNextPos(\"d\", { row, col }, grid),\\n    ]\\n}\\n\\nfunction getNextPos(dir, { row, col }, grid) {\\n  if (dir === \"l\") {\\n    if (col - 1 >= 0) return { row, col: col - 1 };\\n  } else if (dir === \"r\") {\\n    if (col + 1 < grid[0].length) return { row, col: col + 1 };\\n  } else if (dir === \"u\") {\\n    if (row - 1 >= 0) return { row: row - 1, col };\\n  } else if (dir === \"d\") {\\n    if (row + 1 < grid.length) return { row: row + 1, col };\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @param {number} row\\n * @param {number} col\\n * @param {number} color\\n * @return {number[][]}\\n */\\nvar colorBorder = function(grid, row, col, color) {\\n    const borderCells = getSolution(grid, row, col, color)()\\n\\n    for(let i=0; i < borderCells.length; i++){\\n        const {row,col} = borderCells[i]\\n\\n        grid[row][col] = color\\n    }\\n\\n    return grid\\n};\\n\\nfunction getSolution(grid, row, col, color){\\n    const visited = {}\\n    const borderCells = []\\n\\n    const componentColor = grid[row][col]\\n    return function(){\\n        const queue = [{row,col}]\\n\\n        while (queue.length) {\\n            const currentPos = queue.shift();\\n            visited[`${currentPos.row}|${currentPos.col}`] = true\\n\\n            if (isABorderCell(currentPos, grid)) {\\n                borderCells.push(currentPos);\\n            }\\n\\n            queue.push(\\n                ...getNeighbouringCells(currentPos, grid).filter(\\n                    pos =>\\n                        Boolean(pos) &&\\n                        visited[`${pos.row}|${pos.col}`] !== true &&\\n                        grid[pos.row][pos.col] === componentColor\\n                )\\n            );\\n        }\\n\\n        return borderCells\\n    }\\n}\\n\\nfunction isABorderCell({ row, col }, grid) {\\n  return (\\n    row === 0 ||\\n    col === 0 ||\\n    row === grid.length - 1 ||\\n    col === grid[0].length - 1 ||\\n    (\\n        grid[row - 1][col] !== grid[row][col]\\n        || grid[row + 1][col] !== grid[row][col]\\n        || grid[row][col - 1] !== grid[row][col]\\n        || grid[row][col + 1] !== grid[row][col]\\n    )\\n  );\\n}\\n\\nfunction getNeighbouringCells({ row, col }, grid){\\n    return [\\n        getNextPos(\"l\", { row, col }, grid),\\n        getNextPos(\"r\", { row, col }, grid),\\n        getNextPos(\"u\", { row, col }, grid),\\n        getNextPos(\"d\", { row, col }, grid),\\n    ]\\n}\\n\\nfunction getNextPos(dir, { row, col }, grid) {\\n  if (dir === \"l\") {\\n    if (col - 1 >= 0) return { row, col: col - 1 };\\n  } else if (dir === \"r\") {\\n    if (col + 1 < grid[0].length) return { row, col: col + 1 };\\n  } else if (dir === \"u\") {\\n    if (row - 1 >= 0) return { row: row - 1, col };\\n  } else if (dir === \"d\") {\\n    if (row + 1 < grid.length) return { row: row + 1, col };\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2908771,
                "title": "python-3-dfs-quite-simple-solution-with-comments",
                "content": "![image.png](https://assets.leetcode.com/users/images/0eb25c3a-eb99-4568-8ea1-9d9e8a3e822f_1670961669.9535344.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n\\n        visited, changed = set(), set()\\n        stack = deque()\\n        \\n        color_initial = grid[row][col]\\n        row_n, col_n  = len(grid), len(grid[0])\\n        \\n        # add initial cell to stack\\n        stack.append([row, col])\\n        while stack:\\n            r, c = stack.pop()\\n            if (r, c) in visited:   continue\\n            visited.add((r, c))\\n\\n            ind_brd = False   # indicator of border \\n            for r_dlt, c_dlt in [[-1, 0], [0, -1], [1, 0], [0, 1]]:\\n                if 0 <= r + r_dlt < row_n and \\\\\\n                   0 <= c + c_dlt < col_n: \\n                    \\n                    new_cell = grid[r + r_dlt][c + c_dlt]\\n\\n                    # cell on boundary of the grid     or\\n                    # adjacent cell has another color  --> ind = True\\n                    if r in (0, row_n - 1) or \\\\\\n                       c in (0, col_n - 1) or  new_cell != color_initial:\\n                        ind_brd = True\\n                    \\n                    # cell has the same color --> add to stack \\n                    if new_cell == color_initial:\\n                        stack.append([r + r_dlt, c + c_dlt])\\n\\n            # we should change color in the end, otherwise we could paint cells inside              \\n            # add cell to the set\\n            if ind_brd:\\n                changed.add((r, c))\\n        \\n        # paint borders\\n        for (r, c) in changed:\\n            grid[r][c] = color\\n\\n        return grid\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n\\n        visited, changed = set(), set()\\n        stack = deque()\\n        \\n        color_initial = grid[row][col]\\n        row_n, col_n  = len(grid), len(grid[0])\\n        \\n        # add initial cell to stack\\n        stack.append([row, col])\\n        while stack:\\n            r, c = stack.pop()\\n            if (r, c) in visited:   continue\\n            visited.add((r, c))\\n\\n            ind_brd = False   # indicator of border \\n            for r_dlt, c_dlt in [[-1, 0], [0, -1], [1, 0], [0, 1]]:\\n                if 0 <= r + r_dlt < row_n and \\\\\\n                   0 <= c + c_dlt < col_n: \\n                    \\n                    new_cell = grid[r + r_dlt][c + c_dlt]\\n\\n                    # cell on boundary of the grid     or\\n                    # adjacent cell has another color  --> ind = True\\n                    if r in (0, row_n - 1) or \\\\\\n                       c in (0, col_n - 1) or  new_cell != color_initial:\\n                        ind_brd = True\\n                    \\n                    # cell has the same color --> add to stack \\n                    if new_cell == color_initial:\\n                        stack.append([r + r_dlt, c + c_dlt])\\n\\n            # we should change color in the end, otherwise we could paint cells inside              \\n            # add cell to the set\\n            if ind_brd:\\n                changed.add((r, c))\\n        \\n        # paint borders\\n        for (r, c) in changed:\\n            grid[r][c] = color\\n\\n        return grid\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862569,
                "title": "java-solution-bfs-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair {\\n    int row;\\n    int col;\\n\\n    public Pair(int row, int col)\\n    {\\n        this.row = row;\\n        this.col = col;\\n    }\\n}\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        int vis[][] = new int [r][c];\\n        Queue<Pair> queue = new LinkedList<>();\\n        queue.add(new Pair(row , col));\\n        vis[row][col]=1;\\n        int val = grid[row][col];\\n        int ans[][] = new int[r][c];\\n\\n        for(int i=0; i< r; i++)\\n        {\\n            for(int j=0; j< c ; j++)\\n            {\\n                ans[i][j]= grid[i][j];\\n            }\\n        }\\n\\n\\n        int delRow [] = {-1,0,0,1};\\n        int delCol [] = {0,1,-1,0};\\n\\n\\n        while(!queue.isEmpty())\\n        {\\n            int qr = queue.peek().row;\\n            int qc = queue.peek().col;\\n            queue.remove();\\n            int cnt = 0;\\n            for(int i=0; i<4 ; i++)\\n            {\\n                int nrow = qr + delRow[i];\\n                int ncol = qc + delCol[i];\\n\\n                if(nrow >=0 && ncol >=0 && nrow < r && ncol < c && vis[nrow][ncol] != 1 && grid[nrow][ncol] == val)\\n                {\\n                  queue.add(new Pair(nrow, ncol));\\n                  vis[nrow][ncol] =1;\\n                \\n                }\\n                if(nrow >=0 && ncol >=0 && nrow < r && ncol < c && grid[nrow][ncol] == val)\\n                {\\n                  cnt++;              \\n                }\\n            }\\n            if(cnt != 4)\\n            {\\n               ans[qr][qc] = color;\\n            }\\n             \\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Pair {\\n    int row;\\n    int col;\\n\\n    public Pair(int row, int col)\\n    {\\n        this.row = row;\\n        this.col = col;\\n    }\\n}\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        int vis[][] = new int [r][c];\\n        Queue<Pair> queue = new LinkedList<>();\\n        queue.add(new Pair(row , col));\\n        vis[row][col]=1;\\n        int val = grid[row][col];\\n        int ans[][] = new int[r][c];\\n\\n        for(int i=0; i< r; i++)\\n        {\\n            for(int j=0; j< c ; j++)\\n            {\\n                ans[i][j]= grid[i][j];\\n            }\\n        }\\n\\n\\n        int delRow [] = {-1,0,0,1};\\n        int delCol [] = {0,1,-1,0};\\n\\n\\n        while(!queue.isEmpty())\\n        {\\n            int qr = queue.peek().row;\\n            int qc = queue.peek().col;\\n            queue.remove();\\n            int cnt = 0;\\n            for(int i=0; i<4 ; i++)\\n            {\\n                int nrow = qr + delRow[i];\\n                int ncol = qc + delCol[i];\\n\\n                if(nrow >=0 && ncol >=0 && nrow < r && ncol < c && vis[nrow][ncol] != 1 && grid[nrow][ncol] == val)\\n                {\\n                  queue.add(new Pair(nrow, ncol));\\n                  vis[nrow][ncol] =1;\\n                \\n                }\\n                if(nrow >=0 && ncol >=0 && nrow < r && ncol < c && grid[nrow][ncol] == val)\\n                {\\n                  cnt++;              \\n                }\\n            }\\n            if(cnt != 4)\\n            {\\n               ans[qr][qc] = color;\\n            }\\n             \\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2861615,
                "title": "simple-solution-in-c-using-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\nbool solve(int i,int j,vector<vector<int>>&grid,int color,int n,int m,int t,vector<vector<bool>>&visited)\\n{\\n    if(i<0||j<0||i==n||j==m||grid[i][j]!=t||visited[i][j])\\n    return false;\\n    visited[i][j]=true;\\n    bool bod=false;\\n    if(i==0||j==0||i==n-1||j==m-1||grid[i-1][j]!=t||grid[i+1][j]!=t||grid[i][j-1]!=t||grid[i][j+1]!=t)\\n    bod=true ;\\n    solve(i-1,j,grid,color,n,m,t,visited);\\n    solve(i+1,j,grid,color,n,m,t,visited);\\n    solve(i,j-1,grid,color,n,m,t,visited);\\n    solve(i,j+1,grid,color,n,m,t,visited);\\n    if(bod)\\n    grid[i][j]=color;\\n    return bod;\\n}\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size(),m=grid[0].size(),t=grid[row][col];\\n        if(grid[row][col]==color)\\n        return grid;\\n        vector<vector<bool>>visited(n,vector<bool>(m,false));\\n        solve(row,col,grid,color,n,m,t,visited);\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\nbool solve(int i,int j,vector<vector<int>>&grid,int color,int n,int m,int t,vector<vector<bool>>&visited)\\n{\\n    if(i<0||j<0||i==n||j==m||grid[i][j]!=t||visited[i][j])\\n    return false;\\n    visited[i][j]=true;\\n    bool bod=false;\\n    if(i==0||j==0||i==n-1||j==m-1||grid[i-1][j]!=t||grid[i+1][j]!=t||grid[i][j-1]!=t||grid[i][j+1]!=t)\\n    bod=true ;\\n    solve(i-1,j,grid,color,n,m,t,visited);\\n    solve(i+1,j,grid,color,n,m,t,visited);\\n    solve(i,j-1,grid,color,n,m,t,visited);\\n    solve(i,j+1,grid,color,n,m,t,visited);\\n    if(bod)\\n    grid[i][j]=color;\\n    return bod;\\n}\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size(),m=grid[0].size(),t=grid[row][col];\\n        if(grid[row][col]==color)\\n        return grid;\\n        vector<vector<bool>>visited(n,vector<bool>(m,false));\\n        solve(row,col,grid,color,n,m,t,visited);\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848632,
                "title": "dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthis type of problem, it is good to use recursion. isSafe is very important to have this function for further move and identyfy the boundary.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nrecursion move to adjacent block\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    bool isBoundary(vector<vector<int>>& grid, int row, int col, const int& ROWS, const int& COLS, const int& myColor) {\\n        if (row < 0 || col < 0 || row >= ROWS || col >= COLS) {\\n            return true;\\n        } else if (grid[row][col] != myColor) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    void markBoundary(vector<vector<int> >& grid, int row, int col, const int& ROWS, const int& COLS, int color, const int& myColor, vector<vector<int>>& maze) {\\n        if (isBoundary(grid, row, col - 1, ROWS, COLS, myColor)) {\\n            maze[row][col] = color;\\n            return;\\n        }\\n        if (isBoundary(grid, row, col + 1, ROWS, COLS, myColor)) {\\n            maze[row][col] = color;\\n            return;\\n        }\\n        if (isBoundary(grid, row - 1, col, ROWS, COLS, myColor)) {\\n            maze[row][col] = color;\\n            return;\\n        }\\n        if (isBoundary(grid, row + 1, col, ROWS, COLS, myColor)) {\\n            maze[row][col] = color;\\n            return;\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>>& grid, int row, int col, const int& ROWS, const int& COLS, int myColor, vector<vector<bool> >& visited) {\\n        if (row >= 0 && col >= 0 && row < ROWS && col < COLS && grid[row][col] == myColor && !visited[row][col]) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    void colorGrid(vector<vector<int>>& grid, int row, int col, const int& ROWS, const int& COLS, int color, const int& myColor, vector<vector<bool> >& visited, vector<vector<int> >& maze) {\\n        visited[row][col] = true;\\n        markBoundary(grid, row, col, ROWS, COLS, color, myColor, maze);\\n        if (isSafe(grid, row - 1, col, ROWS, COLS, myColor, visited)) {\\n            colorGrid(grid, row - 1, col, ROWS, COLS, color, myColor, visited, maze);\\n        }\\n        if (isSafe(grid, row + 1, col, ROWS, COLS, myColor, visited)) {\\n            colorGrid(grid, row + 1, col, ROWS, COLS, color, myColor, visited, maze);\\n        }\\n        if (isSafe(grid, row, col - 1, ROWS, COLS, myColor, visited)) {\\n            colorGrid(grid, row, col - 1, ROWS, COLS, color, myColor, visited, maze);\\n        }\\n        if (isSafe(grid, row, col + 1, ROWS, COLS, myColor, visited)) {\\n            colorGrid(grid, row, col + 1, ROWS, COLS, color, myColor, visited, maze);\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        const int ROWS = grid.size();\\n        const int COLS = grid[0].size();\\n        vector<bool> vc(COLS, false);\\n        vector<vector<bool> > visited(ROWS, vc);\\n        const int myColor = grid[row][col];\\n        vector<vector<int> > maze = grid;\\n        colorGrid(grid, row, col, ROWS, COLS, color, myColor, visited, maze);\\n        return maze;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    bool isBoundary(vector<vector<int>>& grid, int row, int col, const int& ROWS, const int& COLS, const int& myColor) {\\n        if (row < 0 || col < 0 || row >= ROWS || col >= COLS) {\\n            return true;\\n        } else if (grid[row][col] != myColor) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    void markBoundary(vector<vector<int> >& grid, int row, int col, const int& ROWS, const int& COLS, int color, const int& myColor, vector<vector<int>>& maze) {\\n        if (isBoundary(grid, row, col - 1, ROWS, COLS, myColor)) {\\n            maze[row][col] = color;\\n            return;\\n        }\\n        if (isBoundary(grid, row, col + 1, ROWS, COLS, myColor)) {\\n            maze[row][col] = color;\\n            return;\\n        }\\n        if (isBoundary(grid, row - 1, col, ROWS, COLS, myColor)) {\\n            maze[row][col] = color;\\n            return;\\n        }\\n        if (isBoundary(grid, row + 1, col, ROWS, COLS, myColor)) {\\n            maze[row][col] = color;\\n            return;\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>>& grid, int row, int col, const int& ROWS, const int& COLS, int myColor, vector<vector<bool> >& visited) {\\n        if (row >= 0 && col >= 0 && row < ROWS && col < COLS && grid[row][col] == myColor && !visited[row][col]) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    void colorGrid(vector<vector<int>>& grid, int row, int col, const int& ROWS, const int& COLS, int color, const int& myColor, vector<vector<bool> >& visited, vector<vector<int> >& maze) {\\n        visited[row][col] = true;\\n        markBoundary(grid, row, col, ROWS, COLS, color, myColor, maze);\\n        if (isSafe(grid, row - 1, col, ROWS, COLS, myColor, visited)) {\\n            colorGrid(grid, row - 1, col, ROWS, COLS, color, myColor, visited, maze);\\n        }\\n        if (isSafe(grid, row + 1, col, ROWS, COLS, myColor, visited)) {\\n            colorGrid(grid, row + 1, col, ROWS, COLS, color, myColor, visited, maze);\\n        }\\n        if (isSafe(grid, row, col - 1, ROWS, COLS, myColor, visited)) {\\n            colorGrid(grid, row, col - 1, ROWS, COLS, color, myColor, visited, maze);\\n        }\\n        if (isSafe(grid, row, col + 1, ROWS, COLS, myColor, visited)) {\\n            colorGrid(grid, row, col + 1, ROWS, COLS, color, myColor, visited, maze);\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        const int ROWS = grid.size();\\n        const int COLS = grid[0].size();\\n        vector<bool> vc(COLS, false);\\n        vector<vector<bool> > visited(ROWS, vc);\\n        const int myColor = grid[row][col];\\n        vector<vector<int> > maze = grid;\\n        colorGrid(grid, row, col, ROWS, COLS, color, myColor, visited, maze);\\n        return maze;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833475,
                "title": "simple-dfs-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void recursive(vector<vector<int>>& grid, vector<vector<int>>& ans, int row, int col, int color, int comp, vector<vector<int>>& visited){\\n        if(row>=grid.size() || row<0 || col>=grid[0].size() || col<0 || grid[row][col]!=comp || visited[row][col]) return;\\n\\n        visited[row][col] = 1;\\n        if(row<1 || col<1 || row==grid.size()-1 || col==grid[0].size()-1 || grid[row+1][col]!=comp || grid[row-1][col]!=comp || grid[row][col+1]!=comp || grid[row][col-1]!=comp)\\n        ans[row][col] = color;\\n\\n        recursive(grid, ans, row+1, col, color, comp, visited);\\n        recursive(grid, ans, row-1, col, color, comp, visited);\\n        recursive(grid, ans, row, col+1, color, comp, visited);\\n        recursive(grid, ans, row, col-1, color, comp, visited);\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int component = grid[row][col];\\n        vector<vector<int>> ans = grid;\\n        vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(), 0));\\n        recursive(grid, ans, row, col, color, component, visited);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recursive(vector<vector<int>>& grid, vector<vector<int>>& ans, int row, int col, int color, int comp, vector<vector<int>>& visited){\\n        if(row>=grid.size() || row<0 || col>=grid[0].size() || col<0 || grid[row][col]!=comp || visited[row][col]) return;\\n\\n        visited[row][col] = 1;\\n        if(row<1 || col<1 || row==grid.size()-1 || col==grid[0].size()-1 || grid[row+1][col]!=comp || grid[row-1][col]!=comp || grid[row][col+1]!=comp || grid[row][col-1]!=comp)\\n        ans[row][col] = color;\\n\\n        recursive(grid, ans, row+1, col, color, comp, visited);\\n        recursive(grid, ans, row-1, col, color, comp, visited);\\n        recursive(grid, ans, row, col+1, color, comp, visited);\\n        recursive(grid, ans, row, col-1, color, comp, visited);\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int component = grid[row][col];\\n        vector<vector<int>> ans = grid;\\n        vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(), 0));\\n        recursive(grid, ans, row, col, color, component, visited);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832809,
                "title": "simple-dfs-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int rows, cols;\\n    vector<vector<int>> ans;\\n    bool isValid(int r, int c)\\n    {\\n        if(r<0 || c<0 || r==rows || c==cols) return false;\\n        return true;\\n    }\\n    void dfs(vector<vector<int>>& grid, vector<vector<int>> &vis, int co, int r, int c, int color)\\n    {\\n        vis[r][c]=1;\\n        vector<vector<int>> directions={{-1,0},{0,-1},{1,0},{0,1}};\\n        for(int x=0; x<4; x++)\\n        {\\n            int dr=r+directions[x][0], dc=c+directions[x][1];\\n            if(isValid(dr,dc) && grid[dr][dc]==co) \\n            {\\n                if(!vis[dr][dc]) dfs(grid,vis,co,dr,dc,color);\\n            }\\n            else if(!isValid(dr,dc) || (isValid(dr,dc) && grid[dr][dc]!=co)) ans[r][c]=color;\\n        }\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) \\n    {\\n        ans=grid;\\n        int co=grid[row][col];\\n        rows=grid.size(), cols=grid[0].size();\\n        vector<vector<int>> vis(rows, vector<int> (cols,0));\\n        dfs(grid,vis,co,row,col,color);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int rows, cols;\\n    vector<vector<int>> ans;\\n    bool isValid(int r, int c)\\n    {\\n        if(r<0 || c<0 || r==rows || c==cols) return false;\\n        return true;\\n    }\\n    void dfs(vector<vector<int>>& grid, vector<vector<int>> &vis, int co, int r, int c, int color)\\n    {\\n        vis[r][c]=1;\\n        vector<vector<int>> directions={{-1,0},{0,-1},{1,0},{0,1}};\\n        for(int x=0; x<4; x++)\\n        {\\n            int dr=r+directions[x][0], dc=c+directions[x][1];\\n            if(isValid(dr,dc) && grid[dr][dc]==co) \\n            {\\n                if(!vis[dr][dc]) dfs(grid,vis,co,dr,dc,color);\\n            }\\n            else if(!isValid(dr,dc) || (isValid(dr,dc) && grid[dr][dc]!=co)) ans[r][c]=color;\\n        }\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) \\n    {\\n        ans=grid;\\n        int co=grid[row][col];\\n        rows=grid.size(), cols=grid[0].size();\\n        vector<vector<int>> vis(rows, vector<int> (cols,0));\\n        dfs(grid,vis,co,row,col,color);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832752,
                "title": "dfs",
                "content": "# Intuition\\nsimple dfs\\n\\n# Complexity\\n- Time complexity:\\no(n^2)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int row,int col,int c,vector<vector<int>>& grid,vector<vector<int>>& vis,int m,int n,int color,vector<vector<int>>&ans)\\n    {\\n        vis[row][col]=1;\\n        int di[]={-1,1,0,0};\\n        int dj[]={0,0,-1,1};\\n        for(int i=0;i<4;i++)\\n        {\\n            int ni=row+di[i];\\n            int nj=col+dj[i];\\n            if (ni<m && nj<n && ni>=0 && nj>=0 && grid[ni][nj]==c)\\n            {\\n                if (!vis[ni][nj])\\n                {\\n                dfs(ni,nj,c,grid,vis,m,n,color,ans);\\n                }\\n            }\\n            else{\\n               ans[row][col]=color;\\n                \\n            }\\n        }\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color)\\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n     vector<vector<int>>vis(m,vector<int>(n,0));\\n     vector<vector<int>>ans(m,vector<int>(n,-1));\\n     int c=grid[row][col];\\n      dfs(row,col,c,grid,vis,m,n,color,ans);\\n      for (int i=0;i<m;i++)\\n      {\\n          for (int j=0;j<n;j++)\\n          {\\n              if (ans[i][j]==-1)\\n              {\\n                  ans[i][j]=grid[i][j];\\n              }\\n          }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int row,int col,int c,vector<vector<int>>& grid,vector<vector<int>>& vis,int m,int n,int color,vector<vector<int>>&ans)\\n    {\\n        vis[row][col]=1;\\n        int di[]={-1,1,0,0};\\n        int dj[]={0,0,-1,1};\\n        for(int i=0;i<4;i++)\\n        {\\n            int ni=row+di[i];\\n            int nj=col+dj[i];\\n            if (ni<m && nj<n && ni>=0 && nj>=0 && grid[ni][nj]==c)\\n            {\\n                if (!vis[ni][nj])\\n                {\\n                dfs(ni,nj,c,grid,vis,m,n,color,ans);\\n                }\\n            }\\n            else{\\n               ans[row][col]=color;\\n                \\n            }\\n        }\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color)\\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n     vector<vector<int>>vis(m,vector<int>(n,0));\\n     vector<vector<int>>ans(m,vector<int>(n,-1));\\n     int c=grid[row][col];\\n      dfs(row,col,c,grid,vis,m,n,color,ans);\\n      for (int i=0;i<m;i++)\\n      {\\n          for (int j=0;j<n;j++)\\n          {\\n              if (ans[i][j]==-1)\\n              {\\n                  ans[i][j]=grid[i][j];\\n              }\\n          }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829527,
                "title": "beats-99-java-easy-solution-dfs-graph",
                "content": "```\\nclass Solution {\\n    int initial = 0;\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        boolean[][] visi = new boolean[grid.length][grid[0].length];\\n        initial = grid[row][col];\\n        call(grid,row,col,color,visi);\\n        \\n        return grid;\\n    }\\n    \\n    public boolean  call(int[][] grid,int i,int j,int color,boolean[][] visi){\\n        if(i < 0 || j < 0 || i == grid.length || j == grid[0].length){\\n            return true;\\n        }\\n        if(visi[i][j] == true)return false;\\n        \\n        if(grid[i][j] != initial){\\n            return true;\\n        }\\n        \\n        \\n        visi[i][j] = true;      \\n        boolean r = call(grid,i,j + 1,color,visi);\\n        boolean d = call(grid,i + 1,j,color,visi);\\n        boolean u = call(grid,i - 1,j,color,visi);\\n        boolean l = call(grid,i,j - 1,color,visi);\\n        \\n        if(r || d || u || l){\\n            grid[i][j] = color;\\n        }\\n       \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int initial = 0;\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        boolean[][] visi = new boolean[grid.length][grid[0].length];\\n        initial = grid[row][col];\\n        call(grid,row,col,color,visi);\\n        \\n        return grid;\\n    }\\n    \\n    public boolean  call(int[][] grid,int i,int j,int color,boolean[][] visi){\\n        if(i < 0 || j < 0 || i == grid.length || j == grid[0].length){\\n            return true;\\n        }\\n        if(visi[i][j] == true)return false;\\n        \\n        if(grid[i][j] != initial){\\n            return true;\\n        }\\n        \\n        \\n        visi[i][j] = true;      \\n        boolean r = call(grid,i,j + 1,color,visi);\\n        boolean d = call(grid,i + 1,j,color,visi);\\n        boolean u = call(grid,i - 1,j,color,visi);\\n        boolean l = call(grid,i,j - 1,color,visi);\\n        \\n        if(r || d || u || l){\\n            grid[i][j] = color;\\n        }\\n       \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808321,
                "title": "java-dfs",
                "content": "# Intuition\\nwe will make DFS on the graph and make a flage to check for each nodes if it totally have 4  neighbors with th same color if it does not, this means it is a boundary so we should change its color.\\n# Approach\\nDepth First Search \\n# Complexity\\n- Time complexity:\\nO(n*m + E)\\n- Space complexity:\\nO(n*m) due to recursive calls\\n# Code\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color)\\n    {\\n        Set<Integer> visited = new HashSet<>();\\n        dfs(grid,row,col,grid[row][col],color,visited);\\n        return grid;\\n\\n        \\n    }\\n\\n    public int dfs(int[][] grid, int row, int col,int targetColor, int newColor, Set<Integer> visited)\\n    {\\n        if(visited.contains(row*50+col))\\n        return 1;\\n        if(row<0||col<0||row>=grid.length||col>=grid[0].length||grid[row][col]!=targetColor)\\n        return 0;\\n\\n        int flag = 1;\\n        visited.add(row*50+col);\\n        flag*=dfs(grid,row-1,col,targetColor,newColor,visited);\\n        flag*=dfs(grid,row+1,col,targetColor,newColor,visited);\\n        flag*=dfs(grid,row,col-1,targetColor,newColor,visited);\\n        flag*=dfs(grid,row,col+1,targetColor,newColor,visited);\\n\\n        if(flag==0)\\n        grid[row][col] = newColor;\\n\\n        return 1;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color)\\n    {\\n        Set<Integer> visited = new HashSet<>();\\n        dfs(grid,row,col,grid[row][col],color,visited);\\n        return grid;\\n\\n        \\n    }\\n\\n    public int dfs(int[][] grid, int row, int col,int targetColor, int newColor, Set<Integer> visited)\\n    {\\n        if(visited.contains(row*50+col))\\n        return 1;\\n        if(row<0||col<0||row>=grid.length||col>=grid[0].length||grid[row][col]!=targetColor)\\n        return 0;\\n\\n        int flag = 1;\\n        visited.add(row*50+col);\\n        flag*=dfs(grid,row-1,col,targetColor,newColor,visited);\\n        flag*=dfs(grid,row+1,col,targetColor,newColor,visited);\\n        flag*=dfs(grid,row,col-1,targetColor,newColor,visited);\\n        flag*=dfs(grid,row,col+1,targetColor,newColor,visited);\\n\\n        if(flag==0)\\n        grid[row][col] = newColor;\\n\\n        return 1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805987,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        \\n        dfs(grid , row , col , grid[row][col]);\\n        for(int i = 0 ; i < grid.length ; i++){\\n            for(int j = 0 ; j < grid[0].length ; j++){\\n                if(grid[i][j] < 0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    int[][] dirs = {{1,0} , {0,1}, {-1,0},{0,-1}};\\n    public void dfs(int[][] grid , int row, int col , int clr){\\n        \\n        grid[row][col] = -clr;\\n        int count = 0;\\n        \\n        for(int i = 0 ; i < 4 ; i++){\\n            int rowdash = row + dirs[i][0];\\n            int coldash = col + dirs[i][1];\\n            \\n            if(rowdash < 0 || coldash < 0 || rowdash >= grid.length || coldash >= grid[0].length || Math.abs(grid[rowdash][coldash]) != clr){\\n                continue;\\n            } \\n            \\n                count++;\\n                if(grid[rowdash][coldash] == clr){\\n                    dfs(grid,rowdash , coldash,clr);\\n                }       \\n        }\\n        \\n        if(count == 4){\\n            grid[row][col] = clr;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        \\n        dfs(grid , row , col , grid[row][col]);\\n        for(int i = 0 ; i < grid.length ; i++){\\n            for(int j = 0 ; j < grid[0].length ; j++){\\n                if(grid[i][j] < 0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    int[][] dirs = {{1,0} , {0,1}, {-1,0},{0,-1}};\\n    public void dfs(int[][] grid , int row, int col , int clr){\\n        \\n        grid[row][col] = -clr;\\n        int count = 0;\\n        \\n        for(int i = 0 ; i < 4 ; i++){\\n            int rowdash = row + dirs[i][0];\\n            int coldash = col + dirs[i][1];\\n            \\n            if(rowdash < 0 || coldash < 0 || rowdash >= grid.length || coldash >= grid[0].length || Math.abs(grid[rowdash][coldash]) != clr){\\n                continue;\\n            } \\n            \\n                count++;\\n                if(grid[rowdash][coldash] == clr){\\n                    dfs(grid,rowdash , coldash,clr);\\n                }       \\n        }\\n        \\n        if(count == 4){\\n            grid[row][col] = clr;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788861,
                "title": "java-solution-beats-98",
                "content": "```\\n\\n /**\\n     * [1,1,1],\\n     * [1,1,1],\\n     * [1,1,1]\\n     * @param grid\\n     * @param row\\n     * @param col\\n     * @param color\\n     * @return\\n     */\\n public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int org = grid[row][col];\\n        colorBorder_DFS(row,col,grid,org);\\n        for(int i =0;i<grid.length;i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] < 0) grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    private void colorBorder_DFS(int row_i, int col_j, int[][] grid, int org) {\\n        int col = grid[0].length;\\n        int row = grid.length;\\n        if (col_j < 0 || col_j >= col || row_i < 0 || row_i >= row || grid[row_i][col_j] != org) return;\\n\\n        grid[row_i][col_j] = -org;\\n        colorBorder_DFS(row_i + 1, col_j, grid, org);\\n        colorBorder_DFS(row_i - 1, col_j, grid, org);\\n        colorBorder_DFS(row_i, col_j + 1, grid, org);\\n        colorBorder_DFS(row_i, col_j - 1, grid, org);\\n\\n        if (colorBorder_DFS_abs(grid, row_i + 1, col_j,org) && colorBorder_DFS_abs(grid, row_i - 1, col_j,org)\\n                && colorBorder_DFS_abs(grid, row_i, col_j + 1,org) && colorBorder_DFS_abs(grid, row_i, col_j - 1,org)) {\\n\\t\\t\\t\\t// if the val in 4-diretion is equal to the Math.abs( orginal color ), which means current location is not border, so we don\\'t need to change the color\\n\\t\\t\\t\\t/**\\n\\t\\t\\t\\t1,  -1,  1\\n\\t\\t\\t\\t-1, [1],-1\\n\\t\\t\\t\\t1,  -1,  1\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif  the neighbor of mat[1][1]  all equal -1,  mat[1][1] still is original color 1\\n\\t\\t\\t\\t*/\\n\\t\\t\\n            grid[row_i][col_j] = org;\\n        }\\n\\n    }\\n\\n    private boolean colorBorder_DFS_abs(int[][] grid, int row_i, int col_j,int org) {\\n        int col = grid[0].length;\\n        int row = grid.length;\\n\\t\\t// Beyond the Boundary \\n        if (col_j < 0 || col_j >= col || row_i < 0 || row_i >= row ) return false;\\n\\n       if(grid[row_i][col_j]  ==org ||grid[row_i][col_j]  == -org  ) return true;\\n       return false;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n\\n /**\\n     * [1,1,1],\\n     * [1,1,1],\\n     * [1,1,1]\\n     * @param grid\\n     * @param row\\n     * @param col\\n     * @param color\\n     * @return\\n     */\\n public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int org = grid[row][col];\\n        colorBorder_DFS(row,col,grid,org);\\n        for(int i =0;i<grid.length;i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] < 0) grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    private void colorBorder_DFS(int row_i, int col_j, int[][] grid, int org) {\\n        int col = grid[0].length;\\n        int row = grid.length;\\n        if (col_j < 0 || col_j >= col || row_i < 0 || row_i >= row || grid[row_i][col_j] != org) return;\\n\\n        grid[row_i][col_j] = -org;\\n        colorBorder_DFS(row_i + 1, col_j, grid, org);\\n        colorBorder_DFS(row_i - 1, col_j, grid, org);\\n        colorBorder_DFS(row_i, col_j + 1, grid, org);\\n        colorBorder_DFS(row_i, col_j - 1, grid, org);\\n\\n        if (colorBorder_DFS_abs(grid, row_i + 1, col_j,org) && colorBorder_DFS_abs(grid, row_i - 1, col_j,org)\\n                && colorBorder_DFS_abs(grid, row_i, col_j + 1,org) && colorBorder_DFS_abs(grid, row_i, col_j - 1,org)) {\\n\\t\\t\\t\\t// if the val in 4-diretion is equal to the Math.abs( orginal color ), which means current location is not border, so we don\\'t need to change the color\\n\\t\\t\\t\\t/**\\n\\t\\t\\t\\t1,  -1,  1\\n\\t\\t\\t\\t-1, [1],-1\\n\\t\\t\\t\\t1,  -1,  1\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif  the neighbor of mat[1][1]  all equal -1,  mat[1][1] still is original color 1\\n\\t\\t\\t\\t*/\\n\\t\\t\\n            grid[row_i][col_j] = org;\\n        }\\n\\n    }\\n\\n    private boolean colorBorder_DFS_abs(int[][] grid, int row_i, int col_j,int org) {\\n        int col = grid[0].length;\\n        int row = grid.length;\\n\\t\\t// Beyond the Boundary \\n        if (col_j < 0 || col_j >= col || row_i < 0 || row_i >= row ) return false;\\n\\n       if(grid[row_i][col_j]  ==org ||grid[row_i][col_j]  == -org  ) return true;\\n       return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2782694,
                "title": "java-easy-solution-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nborder rules\\nany adjacent box which can not be colored\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public class Node{\\n        int i;\\n        int j;\\n        public Node(int ii,int jj)\\n        {\\n            i=ii;\\n            j=jj;\\n        }\\n    }\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int comp=grid[row][col];\\n        boolean[][] visited=new boolean[grid.length][grid[0].length];\\n        int[][] dir={{-1,0,1,0},{0,-1,0,1}};\\n        LinkedList<Node> li=new LinkedList<>();\\n        li.addFirst(new Node(row,col));\\n        while(li.size()!=0)\\n        {\\n            Node temp=li.removeFirst();\\n            visited[temp.i][temp.j]=true;\\n            for(int z=0;z<dir[0].length;z++)\\n            {\\n                int i=temp.i+dir[0][z];\\n                int j=temp.j+dir[1][z];\\n                if(i<0 || j<0 || i==grid.length || j==grid[0].length || grid[i][j]!=comp && !visited[i][j])\\n                {\\n                    grid[temp.i][temp.j]=color;\\n                    continue;\\n                }\\n                if(!visited[i][j])\\n                {\\n                    li.addFirst(new Node(i,j));\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public class Node{\\n        int i;\\n        int j;\\n        public Node(int ii,int jj)\\n        {\\n            i=ii;\\n            j=jj;\\n        }\\n    }\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int comp=grid[row][col];\\n        boolean[][] visited=new boolean[grid.length][grid[0].length];\\n        int[][] dir={{-1,0,1,0},{0,-1,0,1}};\\n        LinkedList<Node> li=new LinkedList<>();\\n        li.addFirst(new Node(row,col));\\n        while(li.size()!=0)\\n        {\\n            Node temp=li.removeFirst();\\n            visited[temp.i][temp.j]=true;\\n            for(int z=0;z<dir[0].length;z++)\\n            {\\n                int i=temp.i+dir[0][z];\\n                int j=temp.j+dir[1][z];\\n                if(i<0 || j<0 || i==grid.length || j==grid[0].length || grid[i][j]!=comp && !visited[i][j])\\n                {\\n                    grid[temp.i][temp.j]=color;\\n                    continue;\\n                }\\n                if(!visited[i][j])\\n                {\\n                    li.addFirst(new Node(i,j));\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754832,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int[][] ColorBorder(int[][] grid, int row, int col, int color) {\\n        if(grid[row][col] == color){\\n            return grid;\\n        }\\n        DFS(grid,row,col,grid[row][col]);\\n        for(int i = 0 ; i < grid.Length; i++){\\n            for(int j = 0 ; j < grid[0].Length; j++){\\n                if(grid[i][j] < 0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n    int[,] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n    private void DFS(int[][] grid, int row, int col, int clr){\\n        grid[row][col] = -clr;\\n        int count = 0;\\n        for(int i = 0 ; i < 4 ; i++){\\n            int r = row + dir[i,0];\\n            int c = col + dir[i,1];\\n            \\n            if( r < 0 || c < 0 || r >= grid.Length || c >= grid[0].Length || Math.Abs(grid[r][c]) != clr){\\n                continue;\\n            }\\n            ++count;\\n            if(grid[r][c] == clr){\\n                DFS(grid,r,c,clr);\\n            }\\n        }\\n        if(count == 4){\\n            grid[row][col] = clr;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] ColorBorder(int[][] grid, int row, int col, int color) {\\n        if(grid[row][col] == color){\\n            return grid;\\n        }\\n        DFS(grid,row,col,grid[row][col]);\\n        for(int i = 0 ; i < grid.Length; i++){\\n            for(int j = 0 ; j < grid[0].Length; j++){\\n                if(grid[i][j] < 0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n    int[,] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n    private void DFS(int[][] grid, int row, int col, int clr){\\n        grid[row][col] = -clr;\\n        int count = 0;\\n        for(int i = 0 ; i < 4 ; i++){\\n            int r = row + dir[i,0];\\n            int c = col + dir[i,1];\\n            \\n            if( r < 0 || c < 0 || r >= grid.Length || c >= grid[0].Length || Math.Abs(grid[r][c]) != clr){\\n                continue;\\n            }\\n            ++count;\\n            if(grid[r][c] == clr){\\n                DFS(grid,r,c,clr);\\n            }\\n        }\\n        if(count == 4){\\n            grid[row][col] = clr;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730663,
                "title": "dfs-solution",
                "content": "# Complexity\\n- Time complexity:\\n O(NxM) N is no of rows and M is no of columns\\n\\n- Space complexity:\\nO(NxM) + auxiliary stack space\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] ColorBorder(int[][] grid, int row, int col, int color) {\\n        \\n        int r = grid.Length;\\n        int c = grid[0].Length;\\n        int givenColor = grid[row][col];\\n        bool[,] visited = new bool[r,c];\\n        int[][] finalGrid = new int[r][];\\n        for(int i=0;i<r;i++)\\n          finalGrid[i] = new int[c];\\n          \\n        for(int i=0;i<r;i++)\\n        {\\n          for(int j=0;j<c;j++)\\n            finalGrid[i][j] = grid[i][j];\\n        }\\n        dfs(grid, row, col, givenColor, color, visited);\\n        void dfs(int[][] grid, int row, int col, int givenColor, int color, bool[,] visited)\\n        {\\n          if(row < 0 || col < 0 || row >= r || col >= c) return;\\n          if(grid[row][col] == givenColor && !visited[row,col])\\n          {\\n              visited[row,col] = true;\\n              if((row ==0 || col ==0 || row == r-1 || col == c-1)) \\n              {\\n                    finalGrid[row][col] = color;\\n              }\\n              else if(row-1 >= 0 && !(grid[row-1][col] == givenColor))\\n                  finalGrid[row][col] = color;\\n              else if(row+1 <= r-1 && !(grid[row+1][col] == givenColor))\\n                  finalGrid[row][col] = color;\\n              else if(col-1 >= 0 && !(grid[row][col-1] == givenColor))\\n                  finalGrid[row][col] = color;\\n              else if(col+1 <= c-1 && !(grid[row][col+1] == givenColor))\\n                  finalGrid[row][col] = color;\\n\\n              dfs(grid,row-1,col,givenColor,color, visited);\\n              dfs(grid,row+1,col,givenColor,color, visited);\\n              dfs(grid,row,col-1,givenColor,color, visited);\\n              dfs(grid,row,col+1,givenColor,color, visited);\\n          }\\n        }\\n        return finalGrid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] ColorBorder(int[][] grid, int row, int col, int color) {\\n        \\n        int r = grid.Length;\\n        int c = grid[0].Length;\\n        int givenColor = grid[row][col];\\n        bool[,] visited = new bool[r,c];\\n        int[][] finalGrid = new int[r][];\\n        for(int i=0;i<r;i++)\\n          finalGrid[i] = new int[c];\\n          \\n        for(int i=0;i<r;i++)\\n        {\\n          for(int j=0;j<c;j++)\\n            finalGrid[i][j] = grid[i][j];\\n        }\\n        dfs(grid, row, col, givenColor, color, visited);\\n        void dfs(int[][] grid, int row, int col, int givenColor, int color, bool[,] visited)\\n        {\\n          if(row < 0 || col < 0 || row >= r || col >= c) return;\\n          if(grid[row][col] == givenColor && !visited[row,col])\\n          {\\n              visited[row,col] = true;\\n              if((row ==0 || col ==0 || row == r-1 || col == c-1)) \\n              {\\n                    finalGrid[row][col] = color;\\n              }\\n              else if(row-1 >= 0 && !(grid[row-1][col] == givenColor))\\n                  finalGrid[row][col] = color;\\n              else if(row+1 <= r-1 && !(grid[row+1][col] == givenColor))\\n                  finalGrid[row][col] = color;\\n              else if(col-1 >= 0 && !(grid[row][col-1] == givenColor))\\n                  finalGrid[row][col] = color;\\n              else if(col+1 <= c-1 && !(grid[row][col+1] == givenColor))\\n                  finalGrid[row][col] = color;\\n\\n              dfs(grid,row-1,col,givenColor,color, visited);\\n              dfs(grid,row+1,col,givenColor,color, visited);\\n              dfs(grid,row,col-1,givenColor,color, visited);\\n              dfs(grid,row,col+1,givenColor,color, visited);\\n          }\\n        }\\n        return finalGrid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564824,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1570928,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1575145,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1955641,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1944275,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1942977,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1918113,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1572643,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 2037655,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1955696,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1564824,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1570928,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1575145,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1955641,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1944275,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1942977,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1918113,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1572643,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 2037655,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1955696,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Possible Integer After at Most K Adjacent Swaps On Digits",
        "question_content": "<p>You are given a string <code>num</code> representing <strong>the digits</strong> of a very large integer and an integer <code>k</code>. You are allowed to swap any two adjacent digits of the integer <strong>at most</strong> <code>k</code> times.</p>\n\n<p>Return <em>the minimum integer you can obtain also as a string</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/06/17/q4_1.jpg\" style=\"width: 500px; height: 40px;\" />\n<pre>\n<strong>Input:</strong> num = &quot;4321&quot;, k = 4\n<strong>Output:</strong> &quot;1342&quot;\n<strong>Explanation:</strong> The steps to obtain the minimum integer from 4321 with 4 adjacent swaps are shown.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;100&quot;, k = 1\n<strong>Output:</strong> &quot;010&quot;\n<strong>Explanation:</strong> It&#39;s ok for the output to have leading zeros, but the input is guaranteed not to have any leading zeros.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;36789&quot;, k = 1000\n<strong>Output:</strong> &quot;36789&quot;\n<strong>Explanation:</strong> We can keep the number without any swaps.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>num</code> consists of only <strong>digits</strong> and does not contain <strong>leading zeros</strong>.</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 720548,
                "title": "o-n-logn-detailed-explanation",
                "content": "A hard question = Lots of observation + data structures \\n\\nLet\\'s figure out observations and then find out data structure to implement them.\\n\\n>Observation 0: Well, we know that if we could get smallest digit to the left, then we will be able to make number smaller than we currently have. In that sense, a sorted number(Ascending) will already be smallest. \\n\\nSo, let\\'s take pen and paper and try to find smallest number we can form for this:\\n\\n```\"4321\", k = 4```\\n\\nSo, let\\'s try to move 1 to left most postion. From now on, I\\'ll call the current digit we are moving to left as ```d```:\\n```\"4321\", k = 4```\\n```\"4312\", k = 3```\\n```\"4132\", k = 2```\\n```\"1432\", k = 1```\\nHmm, we can clearly observe: \\n\\n>Observation 1: when we move a digit to left, other digit are shifted to right. i.e 432 got shifted to right by 1.\\n\\nBut, wait.  What if there was another digit to right of ```d```?\\n```\"43219\", k = 4```\\n```\"43129\", k = 3```\\n```\"41329\", k = 2```\\n```\"14329\", k = 1```\\n\\nWell, location of 9 didn\\'t change. Therefore, we can make some correction to our above observation. \\n\\n>Corrected observation 1: Only digits to the left of ```d``` get their position shifted.\\n\\nAlright, what\\'s next?\\n\\nBut what if the ```k``` was really small and we couldn\\'t move 1 to left most?\\n```\"43219\", k = 2```\\n```\"43129\", k = 1```\\n```\"41329\", k = 0```\\n\\nHmm, something is fishy, we clearly didn\\'t reach smallest number here. Smallest for ```k=2``` would be ```24319```.\\n\\nWe can observe here, that we should choose smallest ```d``` that is in the reach of ```k```. \\n\\n>Observation 2: Choose first smallest ```d``` that is in reach of ```k```. \\n\\nIf we combine all the observation, we can see that we will iterate from left to right and try to place digits 0 through 9.\\nLet\\'s work through a bigger example:\\n\\n```\"9438957234785635408\", k = 23```\\n\\nWe will start from left. Let\\'s try to place 0 here. ```0``` is within reach of ```k```,  ```0``` is 17 shifts away to right. So, we will get:\\n```\"0943895723478563548\", k = 6```\\n\\nObserve that all the number got shifted to right except the once to the right of ```d``` (8, here).  \\n\\nNow, let\\'s move to next position:\\nLet\\'s try to place 0 here, again. But wait, we don\\'t 0 left, so try 1, which is not there also. So let\\'s try 2, 2 is 8 distance away from this position. ```8 > k```, so we cannot choose 2. Let\\'s try 3, 3 is 2 distance away. 2 < k, therefore let\\'s choose 3.\\n\\n```\"0394895723478563548\", k = 4```\\n\\nand we can continue like this.\\n\\n>For observation 1, to calculate the correct number of shifts, we will need to also store how many elements before ```d``` already shifted. We will use segment tree for this.\\n>For observation 2, We will use queue to choose latest occurence of each digit.\\n\\n\\n```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        //pqs stores the location of each digit.\\n        List<Queue<Integer>> pqs = new ArrayList<>();\\n        for (int i = 0; i <= 9; ++i) {\\n            pqs.add(new LinkedList<>());\\n        }\\n\\n        for (int i = 0; i < num.length(); ++i) {\\n            pqs.get(num.charAt(i) - \\'0\\').add(i);\\n        }\\n        String ans = \"\";\\n        SegmentTree seg = new SegmentTree(num.length());\\n\\n        for (int i = 0; i < num.length(); ++i) {\\n            // At each location, try to place 0....9\\n            for (int digit = 0; digit <= 9; ++digit) {\\n                // is there any occurrence of digit left?\\n                if (pqs.get(digit).size() != 0) {\\n                    // yes, there is a occurrence of digit at pos\\n                    Integer pos = pqs.get(digit).peek();\\n\\t\\t\\t\\t\\t// Since few numbers already shifted to left, this `pos` might be outdated.\\n                    // we try to find how many number already got shifted that were to the left of pos.\\n                    int shift = seg.getCountLessThan(pos);\\n                    // (pos - shift) is number of steps to make digit move from pos to i.\\n                    if (pos - shift <= k) {\\n                        k -= pos - shift;\\n                        seg.add(pos); // Add pos to our segment tree.\\n                        pqs.get(digit).remove();\\n                        ans += digit;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    class SegmentTree {\\n        int[] nodes;\\n        int n;\\n\\n        public SegmentTree(int max) {\\n            nodes = new int[4 * (max)];\\n            n = max;\\n        }\\n\\n        public void add(int num) {\\n            addUtil(num, 0, n, 0);\\n        }\\n\\n        private void addUtil(int num, int l, int r, int node) {\\n            if (num < l || num > r) {\\n                return;\\n            }\\n            if (l == r) {\\n                nodes[node]++;\\n                return;\\n            }\\n            int mid = (l + r) / 2;\\n            addUtil(num, l, mid, 2 * node + 1);\\n            addUtil(num, mid + 1, r, 2 * node + 2);\\n            nodes[node] = nodes[2 * node + 1] + nodes[2 * node + 2];\\n        }\\n\\n        // Essentialy it tells count of numbers < num.\\n        public int getCountLessThan(int num) {\\n            return getUtil(0, num, 0, n, 0);\\n        }\\n\\n        private int getUtil(int ql, int qr, int l, int r, int node) {\\n            if (qr < l || ql > r) return 0;\\n            if (ql <= l && qr >= r) {\\n                return nodes[node];\\n            }\\n\\n            int mid = (l + r) / 2;\\n            return getUtil(ql, qr, l, mid, 2 * node + 1) + getUtil(ql, qr, mid + 1, r, 2 * node + 2);\\n        }\\n    }\\n\\n}\\n```\\n\\nIf you don\\'t know about segment tree. This is simplest segment tree and you can look up ```sum of ranges using segment tree``` on Google and you will find million articles. You can also use Balanced BST, BIT (Thanks @giftwei for suggestion) to get same complexity.\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\"4321\", k = 4```\n```d```\n```\"4321\", k = 4```\n```\"4312\", k = 3```\n```\"4132\", k = 2```\n```\"1432\", k = 1```\n```d```\n```\"43219\", k = 4```\n```\"43129\", k = 3```\n```\"41329\", k = 2```\n```\"14329\", k = 1```\n```d```\n```k```\n```\"43219\", k = 2```\n```\"43129\", k = 1```\n```\"41329\", k = 0```\n```k=2```\n```24319```\n```d```\n```k```\n```d```\n```k```\n```\"9438957234785635408\", k = 23```\n```0```\n```k```\n```0```\n```\"0943895723478563548\", k = 6```\n```d```\n```8 > k```\n```\"0394895723478563548\", k = 4```\n```d```\n```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        //pqs stores the location of each digit.\\n        List<Queue<Integer>> pqs = new ArrayList<>();\\n        for (int i = 0; i <= 9; ++i) {\\n            pqs.add(new LinkedList<>());\\n        }\\n\\n        for (int i = 0; i < num.length(); ++i) {\\n            pqs.get(num.charAt(i) - \\'0\\').add(i);\\n        }\\n        String ans = \"\";\\n        SegmentTree seg = new SegmentTree(num.length());\\n\\n        for (int i = 0; i < num.length(); ++i) {\\n            // At each location, try to place 0....9\\n            for (int digit = 0; digit <= 9; ++digit) {\\n                // is there any occurrence of digit left?\\n                if (pqs.get(digit).size() != 0) {\\n                    // yes, there is a occurrence of digit at pos\\n                    Integer pos = pqs.get(digit).peek();\\n\\t\\t\\t\\t\\t// Since few numbers already shifted to left, this `pos` might be outdated.\\n                    // we try to find how many number already got shifted that were to the left of pos.\\n                    int shift = seg.getCountLessThan(pos);\\n                    // (pos - shift) is number of steps to make digit move from pos to i.\\n                    if (pos - shift <= k) {\\n                        k -= pos - shift;\\n                        seg.add(pos); // Add pos to our segment tree.\\n                        pqs.get(digit).remove();\\n                        ans += digit;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    class SegmentTree {\\n        int[] nodes;\\n        int n;\\n\\n        public SegmentTree(int max) {\\n            nodes = new int[4 * (max)];\\n            n = max;\\n        }\\n\\n        public void add(int num) {\\n            addUtil(num, 0, n, 0);\\n        }\\n\\n        private void addUtil(int num, int l, int r, int node) {\\n            if (num < l || num > r) {\\n                return;\\n            }\\n            if (l == r) {\\n                nodes[node]++;\\n                return;\\n            }\\n            int mid = (l + r) / 2;\\n            addUtil(num, l, mid, 2 * node + 1);\\n            addUtil(num, mid + 1, r, 2 * node + 2);\\n            nodes[node] = nodes[2 * node + 1] + nodes[2 * node + 2];\\n        }\\n\\n        // Essentialy it tells count of numbers < num.\\n        public int getCountLessThan(int num) {\\n            return getUtil(0, num, 0, n, 0);\\n        }\\n\\n        private int getUtil(int ql, int qr, int l, int r, int node) {\\n            if (qr < l || ql > r) return 0;\\n            if (ql <= l && qr >= r) {\\n                return nodes[node];\\n            }\\n\\n            int mid = (l + r) / 2;\\n            return getUtil(ql, qr, l, mid, 2 * node + 1) + getUtil(ql, qr, mid + 1, r, 2 * node + 2);\\n        }\\n    }\\n\\n}\\n```\n```sum of ranges using segment tree```",
                "codeTag": "Java"
            },
            {
                "id": 720215,
                "title": "the-constraint-was-not-very-helpful-c-python-clean-56ms-o-n2-solution",
                "content": "1 <= num.length <= 30000\\n1 <= k <= 10^9\\n\\nGiven these two constraints, how could leetcode expect someone to know that O(n2) and O(n2logn) would pass the OJ?\\nIt was not hard to figure out the bubble sort as a naive solution (pick the smallest possible number and move to the front) and think about fast return with sorted digits if k >= n*(n-1)//2 (when all numbers can be rearranged freely), but I spent the last hour trying to implement a clever solution, but failed...\\nI think BIT or segment tree will do, but didn\\'t manage to get them right.\\n\\nI would suggest either make the constraint less daunting, or reinforce the constraint as claimed...\\nWell, I guess maybe sometimes we just need to be bold enough and jump off the cliff to realize it was just a pit...\\n\\nUsually, I would think the total number of computation acceptable would be below 10^8. So, if n > 10000, I would hesitate to try O(n2).\\n\\n--------------------\\nWow, so many people voted up, so I attached a solution below, beat 100% in Python (56ms in total).\\nThis is an O(n2) solution just for fun.\\n\\n\\tclass Solution:\\n\\t\\tdef minInteger(self, num: str, k: int) -> str:\\n\\t\\t    # base case\\n\\t\\t    if k <= 0: return num\\n\\t\\t    # the total number of swaps if you need to reverse the whole string is n*(n-1)//2.\\n\\t\\t\\t# therefore, if k is >= this number, any order is achievable.\\n\\t\\t\\tn = len(num)\\n\\t\\t\\tif k >= n*(n-1)//2: \\n\\t\\t\\t\\treturn \"\".join(sorted(list(num)))\\n            \\n\\t\\t    # starting from the smallest number\\n\\t\\t\\tfor i in range(10):\\n\\t\\t\\t    # find the smallest index\\n\\t\\t\\t\\tind = num.find(str(i))\\n\\t\\t\\t\\t# if this index is valid\\n\\t\\t\\t\\tif 0 <= ind <= k:\\n\\t\\t\\t\\t    # move the digit to the front and deal with the rest of the string recursively.\\n\\t\\t\\t\\t\\treturn str(num[ind]) + self.minInteger(num[0:ind] + num[ind+1:], k-ind)\\n\\nTo copy and paste:\\n\\n\\tclass Solution:\\n\\t\\tdef minInteger(self, num: str, k: int) -> str:\\n\\t\\t\\tif k <= 0: return num\\n\\t\\t\\tn = len(num)\\n\\t\\t\\tif k >= n*(n-1)//2: \\n\\t\\t\\t\\treturn \"\".join(sorted(list(num)))\\n\\n\\t\\t\\t# for each number, find the first index\\n\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\tind = num.find(str(i))\\n\\t\\t\\t\\tif 0 <= ind <= k:\\n\\t\\t\\t\\t\\treturn str(num[ind]) + self.minInteger(num[0:ind] + num[ind+1:], k-ind)\\n\\t\\t\\t\\t\\t\\nC++ version by @wanli2019. Thank you.\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring minInteger(string num, int k) {\\n\\t\\t\\tif(k <= 0) \\n\\t\\t\\t\\treturn num;\\n\\t\\t\\tint n = num.size();\\n\\t\\t\\tif(k>=n*(n+1)/2){ \\n\\t\\t\\t\\tsort(num.begin(), num.end());\\n\\t\\t\\t\\treturn num;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0; i<10; i++){\\n\\t\\t\\t\\tint idx = num.find(to_string(i));\\n\\t\\t\\t\\tif(idx>=0 && idx<=k)\\n\\t\\t\\t\\t\\treturn num[idx]+minInteger(num.substr(0,idx)+num.substr(idx+1), k-idx);\\n\\t\\t\\t}\\n\\t\\t\\treturn num;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef minInteger(self, num: str, k: int) -> str:\\n\\t\\t    # base case\\n\\t\\t    if k <= 0: return num\\n\\t\\t    # the total number of swaps if you need to reverse the whole string is n*(n-1)//2.\\n\\t\\t\\t# therefore, if k is >= this number, any order is achievable.\\n\\t\\t\\tn = len(num)\\n\\t\\t\\tif k >= n*(n-1)//2: \\n\\t\\t\\t\\treturn \"\".join(sorted(list(num)))\\n            \\n\\t\\t    # starting from the smallest number\\n\\t\\t\\tfor i in range(10):\\n\\t\\t\\t    # find the smallest index\\n\\t\\t\\t\\tind = num.find(str(i))\\n\\t\\t\\t\\t# if this index is valid\\n\\t\\t\\t\\tif 0 <= ind <= k:\\n\\t\\t\\t\\t    # move the digit to the front and deal with the rest of the string recursively.\\n\\t\\t\\t\\t\\treturn str(num[ind]) + self.minInteger(num[0:ind] + num[ind+1:], k-ind)\\n\\nTo copy and paste:\\n\\n\\tclass Solution:\\n\\t\\tdef minInteger(self, num: str, k: int) -> str:\\n\\t\\t\\tif k <= 0: return num\\n\\t\\t\\tn = len(num)\\n\\t\\t\\tif k >= n*(n-1)//2: \\n\\t\\t\\t\\treturn \"\".join(sorted(list(num)))\\n\\n\\t\\t\\t# for each number, find the first index\\n\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\tind = num.find(str(i))\\n\\t\\t\\t\\tif 0 <= ind <= k:\\n\\t\\t\\t\\t\\treturn str(num[ind]) + self.minInteger(num[0:ind] + num[ind+1:], k-ind)\\n\\t\\t\\t\\t\\t\\nC++ version by @wanli2019. Thank you.\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring minInteger(string num, int k) {\\n\\t\\t\\tif(k <= 0) \\n\\t\\t\\t\\treturn num;\\n\\t\\t\\tint n = num.size();\\n\\t\\t\\tif(k>=n*(n+1)/2){ \\n\\t\\t\\t\\tsort(num.begin(), num.end());\\n\\t\\t\\t\\treturn num;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 720650,
                "title": "python-17-lines-o-nlogn-solution",
                "content": "The idea is quite straightforward: \\n`In each round, pick the smallest number within k distance and move it to the front.`\\nFor each number, we save its indexes in a deque.\\nIn each round, we check from 0 to 9 to see if the nearest index is within k distance.\\nBut here comes the tricky part:\\n`The index of a number may change due to the swaps we made in the previous rounds.`\\nFor example, if 3 numbers after `num[i]` are moved to the front,\\nthen the index of `num[i]` becomes `i + 3` in the new array.\\nSo we need a data structure to store the indexes of picked numbers,\\nto support fast calculation of the new index of each remaining number.\\nBIT, Segment Tree and Balanced Binary Search Tree can do this.\\nHere I use `sortedcontainers`, which is an implementation of Balanced Binary Search Tree.\\n\\n```\\nfrom collections import defaultdict, deque\\nfrom sortedcontainers import SortedList\\nfrom string import digits\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        d = defaultdict(deque)\\n        for i, a in enumerate(num):\\n            d[a].append(i)\\n        ans, seen = \\'\\', SortedList()\\n        for _ in range(len(num)):\\n            for a in digits:\\n                if d[a]:\\n                    i = d[a][0]\\n                    ni = i + (len(seen) - seen.bisect(i))\\n                    dis = ni - len(seen)\\n                    if dis <= k:\\n                        k -= dis\\n                        d[a].popleft()\\n                        ans += a\\n                        seen.add(i)\\n                        break\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict, deque\\nfrom sortedcontainers import SortedList\\nfrom string import digits\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        d = defaultdict(deque)\\n        for i, a in enumerate(num):\\n            d[a].append(i)\\n        ans, seen = \\'\\', SortedList()\\n        for _ in range(len(num)):\\n            for a in digits:\\n                if d[a]:\\n                    i = d[a][0]\\n                    ni = i + (len(seen) - seen.bisect(i))\\n                    dis = ni - len(seen)\\n                    if dis <= k:\\n                        k -= dis\\n                        d[a].popleft()\\n                        ans += a\\n                        seen.add(i)\\n                        break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720101,
                "title": "java-bubblesort-16-lines-with-detailed-explanation-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/9cf54b34-103f-4cf0-bd37-1509056dffde_1593921654.0422919.png)\\n\\n```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        char[] ca = num.toCharArray();\\n        helper(ca, 0, k);\\n        return new String(ca);\\n    }\\n    \\n    public void helper(char[] ca, int I, int k){\\n        if (k==0 || I==ca.length) return;\\n        int min = ca[I], minIdx = I;\\n        for (int i = I+1; i<Math.min(I+k+1, ca.length); i++)\\n            if (ca[i]<min){\\n                min=ca[i];\\n                minIdx=i;\\n            }\\n        char temp = ca[minIdx];\\n        for (int i = minIdx; i>I; i--) ca[i]=ca[i-1];\\n        ca[I] = temp;\\n        helper(ca, I+1, k-(minIdx-I));\\n    }\\n}\\n```\\n\\nTime : \\u041E(n^2), In the worst case, k will be very large, and it becomes bubble sort.\\n\\nHappy Coding!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        char[] ca = num.toCharArray();\\n        helper(ca, 0, k);\\n        return new String(ca);\\n    }\\n    \\n    public void helper(char[] ca, int I, int k){\\n        if (k==0 || I==ca.length) return;\\n        int min = ca[I], minIdx = I;\\n        for (int i = I+1; i<Math.min(I+k+1, ca.length); i++)\\n            if (ca[i]<min){\\n                min=ca[i];\\n                minIdx=i;\\n            }\\n        char temp = ca[minIdx];\\n        for (int i = minIdx; i>I; i--) ca[i]=ca[i-1];\\n        ca[I] = temp;\\n        helper(ca, I+1, k-(minIdx-I));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720235,
                "title": "c-o-n-log-n-fenwick-bit-solution-196ms-with-explanation",
                "content": "```\\nclass Solution {\\n    vector<pair<int, int>> resort;\\n    \\n    priority_queue<int, vector<int>, greater<int>> nums[10];\\n    int used[30001];\\n    int n;\\n    int getSum(int index)  {\\n        int sum = 0;\\n        while (index > 0) { \\n            sum += used[index];\\n            index -= index & (-index); \\n        } \\n        return sum; \\n    } \\n    \\n    void updateBIT(int index, int val) \\n    { \\n        while (index <= n) \\n        { \\n        used[index] += val;\\n        index += index & (-index); \\n        } \\n    }\\n    \\npublic:\\n    string minInteger(string num, int k) {\\n        memset(used, 0, sizeof(used));\\n        \\n        int ctr = 0;\\n        n = num.size();\\n        for (int i = 0; i < n; i++) {\\n            nums[num[i] - \\'0\\'].push(i + 1);\\n        }\\n        string res;\\n        while (ctr < n && k > 0) {\\n            for (int i = 0; i <= 9; i++) {\\n                if (!nums[i].empty()) {\\n                    int cur = nums[i].top();\\n                    \\n                    int holes = getSum(cur - 1);\\n                    int act = cur - holes;\\n                    if (act - 1 <= k) {\\n                        res += (\\'0\\' + i);\\n                        k -= (act - 1);\\n                        updateBIT(cur, 1);\\n                        nums[i].pop();\\n                        break;\\n                    }\\n                }\\n            }\\n            ctr++;\\n        }\\n        \\n        for(int i = 0; i <= 9; i++) {\\n            while (!nums[i].empty()) {\\n                resort.emplace_back(nums[i].top(), i);\\n                nums[i].pop();\\n            }\\n        }\\n        \\n        sort(resort.begin(), resort.end());\\n        for (auto &p : resort) {\\n            res += (\\'0\\' + p.second);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n# General Idea:\\nWe greedily take the smallest digit in the range of remaining ```k``` from the current index we are filling (start from 1st position) and swap it all the way left to the current index. We make sure that we have the right updated cost to take a digit by using BIT to store how many digits have been taken to the left of that digit. The actual cost of taking that digit to the current index is its position subtracted by how many digits have been taken to the left of this digit.\\n\\nThe remaining digts not taken is then put to the back of the answer string.\\n\\n# Explanation of getting the actual cost of taking a digit and swapping it all the way to the current index:\\nWhen there are no swaps done, the cost of taking a digit and swapping it to the first position is its position (subtracted by 1). Say we take the digit in position ```x``` for the first index. When we move to the next index (2nd position), the cost for all digits in front of  ```x``` (to the left) is still its position (since they were all shifted right during the swapping and their distance from the current index stays the same). However, all digits to the right of ```x``` will cost less (since the current index is closer by 1, but their positions have not changed). \\n\\nThis continues for the rest and the actual cost of taking a digit ```x``` to the current index is its position subtracted by how many digits to the left of ```x``` has been taken. We keep track of this efficiently using the Fenwick tree.\\n\\n# Implementation:\\nIn the code above, I first store the positions for each digit in priority queues (Can be done in a vector and sorted after as well). \\n\\nThen, while I am still taking digits (```ctr < n```) and I still have remaining swaps (```k > 0```), I will look for the smallest affordable digit by looking at each priority queue for each digit, then if the furthest left untaken digit\\'s actual cost is affordable, I will take it and update the Fenwick tree.\\n\\nThe last sorting using ```resort``` empties out the priority queues since they are filled with digits that have not been taken and I will append them to the string according to their positions since their ordering stays the same throughout all the swapping.\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<pair<int, int>> resort;\\n    \\n    priority_queue<int, vector<int>, greater<int>> nums[10];\\n    int used[30001];\\n    int n;\\n    int getSum(int index)  {\\n        int sum = 0;\\n        while (index > 0) { \\n            sum += used[index];\\n            index -= index & (-index); \\n        } \\n        return sum; \\n    } \\n    \\n    void updateBIT(int index, int val) \\n    { \\n        while (index <= n) \\n        { \\n        used[index] += val;\\n        index += index & (-index); \\n        } \\n    }\\n    \\npublic:\\n    string minInteger(string num, int k) {\\n        memset(used, 0, sizeof(used));\\n        \\n        int ctr = 0;\\n        n = num.size();\\n        for (int i = 0; i < n; i++) {\\n            nums[num[i] - \\'0\\'].push(i + 1);\\n        }\\n        string res;\\n        while (ctr < n && k > 0) {\\n            for (int i = 0; i <= 9; i++) {\\n                if (!nums[i].empty()) {\\n                    int cur = nums[i].top();\\n                    \\n                    int holes = getSum(cur - 1);\\n                    int act = cur - holes;\\n                    if (act - 1 <= k) {\\n                        res += (\\'0\\' + i);\\n                        k -= (act - 1);\\n                        updateBIT(cur, 1);\\n                        nums[i].pop();\\n                        break;\\n                    }\\n                }\\n            }\\n            ctr++;\\n        }\\n        \\n        for(int i = 0; i <= 9; i++) {\\n            while (!nums[i].empty()) {\\n                resort.emplace_back(nums[i].top(), i);\\n                nums[i].pop();\\n            }\\n        }\\n        \\n        sort(resort.begin(), resort.end());\\n        for (auto &p : resort) {\\n            res += (\\'0\\' + p.second);\\n        }\\n        return res;\\n    }\\n};\\n```\n```k```\n```x```\n```x```\n```x```\n```x```\n```x```\n```ctr < n```\n```k > 0```\n```resort```",
                "codeTag": "Java"
            },
            {
                "id": 720127,
                "title": "python-bytedance-interview-question",
                "content": "**Idea**\\nGreedily select the smallest number we can reach, and push it all the way to the front.\\n\\n**Complexity**\\n- time: O(n^2)\\n- space: O(n)\\n\\n**Python**\\n```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        num = [*map(int, num)]\\n        if k >= (len(num) ** 2) // 2:\\n            return \\'\\'.join(map(str, sorted(num)))\\n        \\n        res = []\\n        q = [(v, i) for i, v in enumerate(num)]\\n        while k and q:\\n            idx, (v, i) = min(enumerate(q[:k + 1]), key=lambda p:p[1])\\n            k -= idx\\n            del q[idx]\\n            res += v,\\n            \\n        res += [v for v, _ in q]\\n        return \\'\\'.join(map(str, res))\\n```\\n\\nPlease please don\\'t downvote unless necessary bro.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        num = [*map(int, num)]\\n        if k >= (len(num) ** 2) // 2:\\n            return \\'\\'.join(map(str, sorted(num)))\\n        \\n        res = []\\n        q = [(v, i) for i, v in enumerate(num)]\\n        while k and q:\\n            idx, (v, i) = min(enumerate(q[:k + 1]), key=lambda p:p[1])\\n            k -= idx\\n            del q[idx]\\n            res += v,\\n            \\n        res += [v for v, _ in q]\\n        return \\'\\'.join(map(str, res))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720487,
                "title": "detailed-c-segment-tree-solution-88ms-might-not-be-optimal",
                "content": "Here is my first post on leetcode. I would like to share my segment tree solution to this problem. My time complexity is **O(nlognlogn)** so it might not be the optimal solution.\\n\\nWell, let us analyze this problem. If we want to construct the mininal number, we need to force the leftmost digit as small as possible. So we can go though the string from left to right, pick the smallest one while the swap operation number does not exceeding the threshold(at first it is **K**). And we do the same operation for the next digit, until we run out our operations.\\n\\nWe can easily find a O(n^2) algorithm following this idea. But it is not YOUXIU (good) enough, we need to optimize it.\\n\\nIn general, we use three steps to pick digits from left to right. \\n\\n1. Calculate the right most index(**1-based**) we can pick in the threshold;\\n2. Pick the smallest one(among smallest ones we choose the left most one), and declare that it has been picked so we can not pick it again;\\n3.  Update the threshold.\\n\\nWe can use Segment Tree. I won\\'t talk about basic knowledge of segment tree(without lazy-tag) in this post, just to show how to use it in this problem.\\n\\nFirst let\\'s talk about the threshold. Threshold here means the largest index that we can pick. We can use the prefix sum to calculate it.\\nFor instance,\\n```\\noriginal string: \"1 2 4 3 5 6 7\", original k = 3;\\nuse/not state:    1 1 1 1 1 1 1 (1: not been used, 0: used);\\nprefix sum:       1 2 3 4 5 6 7 ;\\n```\\nSo the largest index we can pick is 4 = k + 1;\\nAnother instance:\\n```\\noriginal string: \"1 4 2 5 6 7\", k = 2;\\nuse/not state:    0 1 0 1 1 1 (1: not been used, 0: used);\\nprefix sum:       0 1 1 2 3 4; \\n```\\nSo the largest index we can pick is 5 since presum[5] = 3 = k + 1;\\n\\nAt this point, we can design the tree node;\\n```\\ntypedef long long ll;\\nstruct Node {\\n    ll l,r;\\n    ll minv, idx, sum;\\n\\t/* minv: min value in [l...r] in the original string;\\n\\t    idx: the index of minv;\\n\\t\\tsum: sum of use/not use in [l...r] period;*/\\n} tree[4*N];\\n```\\nAnd we can write the push_up method carefully.\\n```\\nvoid push_up(Node& a, Node& b, Node & c) {\\n   // Use information from b and c to update Node a, b.idx is always <= c.idx\\n   if(b.minv <= c.minv) {\\n        a.minv = b.minv;\\n        a.idx = b.idx;\\n    } else {\\n        a.minv = c.minv;\\n        a.idx = c.idx;\\n    }\\n    a.sum = b.sum + c.sum;\\n}\\nvoid push_up(ll u) {\\n    push_up(tree[u], tree[2*u], tree[2*u+1]);\\n}\\n```\\nWe can use binary search to find the right most idx that we can pick;\\n```\\nint get_idx(int presum, int len) {\\n    // O(lognlogn)\\n    int l = 1;\\n    int r = len;\\n    int res = len; // If we can not find it, we should return the last index\\n    while(l <= r) {\\n        int mid = (l + r) / 2;\\n        if(query(1, 1, mid).sum >= presum) {\\n            res = mid;\\n            r = mid - 1;\\n        } else {\\n            l = mid + 1;\\n        }\\n    }\\n    return res;\\n}\\n```\\nAfter we pick one, we should declare that this number has been picked and we should not pick it again by setting it to 10 and set the use/not use state to 0 and we should update our threshold. Details are in the code.\\n\\nFull code:\\n```\\ntypedef long long ll;\\nconst int N =30010;\\nll w[N];\\nll st[N];\\n\\nstruct Node {\\n    ll l,r;\\n    ll minv, idx, sum;\\n} tree[4*N];\\n\\nvoid push_up(Node& a, Node& b, Node & c) {\\n    if(b.minv <= c.minv) {\\n        a.minv = b.minv;\\n        a.idx = b.idx;\\n    } else {\\n        a.minv = c.minv;\\n        a.idx = c.idx;\\n    }\\n    a.sum = b.sum + c.sum;\\n}\\n\\nvoid push_up(ll u) {\\n    push_up(tree[u], tree[2*u], tree[2*u+1]);\\n}\\n\\nvoid build(ll u, ll l, ll r) {\\n    tree[u].l = l;\\n    tree[u].r = r;\\n    if(l == r) {\\n        ll b = w[l];\\n        tree[u].minv = b;\\n        tree[u].idx = l;\\n        tree[u].sum = st[l];\\n    } else {\\n        ll mid = (l + r) / 2;\\n        build(2*u, l, mid);\\n        build(2*u+1, mid+1, r);\\n        push_up(u);\\n    }\\n}\\n\\nvoid update(ll u, ll idx, ll x) {\\n    if(tree[u].l == tree[u].r) {\\n        tree[u].minv = x;\\n        tree[u].sum = 0;\\n        st[tree[u].l] = 0;\\n    } else {\\n        ll mid = (tree[u].l + tree[u].r)/2;\\n        if(idx <= mid) update(2*u, idx, x);\\n        else update(2*u+1, idx, x);\\n        push_up(u);\\n    }\\n}\\n\\nNode query(ll u, ll l, ll r) {\\n    if(tree[u].l >= l && tree[u].r <= r) {\\n        return tree[u];\\n    } else {\\n        ll mid = (tree[u].l + tree[u].r)/2;\\n        if(l > mid) {\\n            return query(2*u+1, l, r);\\n        } else if (r <= mid) {\\n            return query(2*u, l, r);\\n        } else {\\n            auto left = query(2*u, l, r);\\n            auto right = query(2*u+1, l, r);\\n            Node res;\\n            push_up(res, left, right);\\n            return res;\\n        }\\n    }\\n}\\n\\nint get_idx(int presum, int len) {\\n    int l = 1;\\n    int r = len;\\n    int res = len;\\n    while(l <= r) {\\n        int mid = (l + r) / 2;\\n        if(query(1, 1, mid).sum >= presum) {\\n            res = mid;\\n            r = mid - 1;\\n        } else {\\n            l = mid + 1;\\n        }\\n    }\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n        if(k > n*(n-1)/2) {\\n            sort(num.begin(), num.end());\\n            return num;\\n        }\\n        return solve(num, k);\\n    }\\n    void init(string & num) {\\n        // build the SegTree;\\n        int n = num.size();\\n        memset(tree, 0, sizeof tree);\\n        for(int i = 1; i <= n; i ++) w[i] = num[i-1] - \\'0\\';\\n        for(int i = 1; i <= n; i ++) st[i] = 1;\\n        build(1, 1, n);\\n    }\\n    string solve(string & num, int k) {\\n        init(num);\\n        string res;\\n        while(k) {\\n            int max_sum = min(k+1, (int)num.size());\\n            int threshold = get_idx(max_sum, num.size());\\n            Node curr = query(1, 1, threshold);\\n            if(curr.minv == 10) break;\\n            res.push_back(curr.minv + \\'0\\');\\n            update(1, curr.idx, 10);\\n            k -= query(1, 1, curr.idx).sum;\\n        }\\n        for(int i = 1; i <= num.size(); i ++) {\\n            if(st[i] == 1) {\\n\\t\\t\\t// unused digits\\n                res.push_back(num[i-1]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nThe time complexity is O(nlognlogn), space complexity is O(n).\\nThanks for reading.\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\noriginal string: \"1 2 4 3 5 6 7\", original k = 3;\\nuse/not state:    1 1 1 1 1 1 1 (1: not been used, 0: used);\\nprefix sum:       1 2 3 4 5 6 7 ;\\n```\n```\\noriginal string: \"1 4 2 5 6 7\", k = 2;\\nuse/not state:    0 1 0 1 1 1 (1: not been used, 0: used);\\nprefix sum:       0 1 1 2 3 4; \\n```\n```\\ntypedef long long ll;\\nstruct Node {\\n    ll l,r;\\n    ll minv, idx, sum;\\n\\t/* minv: min value in [l...r] in the original string;\\n\\t    idx: the index of minv;\\n\\t\\tsum: sum of use/not use in [l...r] period;*/\\n} tree[4*N];\\n```\n```\\nvoid push_up(Node& a, Node& b, Node & c) {\\n   // Use information from b and c to update Node a, b.idx is always <= c.idx\\n   if(b.minv <= c.minv) {\\n        a.minv = b.minv;\\n        a.idx = b.idx;\\n    } else {\\n        a.minv = c.minv;\\n        a.idx = c.idx;\\n    }\\n    a.sum = b.sum + c.sum;\\n}\\nvoid push_up(ll u) {\\n    push_up(tree[u], tree[2*u], tree[2*u+1]);\\n}\\n```\n```\\nint get_idx(int presum, int len) {\\n    // O(lognlogn)\\n    int l = 1;\\n    int r = len;\\n    int res = len; // If we can not find it, we should return the last index\\n    while(l <= r) {\\n        int mid = (l + r) / 2;\\n        if(query(1, 1, mid).sum >= presum) {\\n            res = mid;\\n            r = mid - 1;\\n        } else {\\n            l = mid + 1;\\n        }\\n    }\\n    return res;\\n}\\n```\n```\\ntypedef long long ll;\\nconst int N =30010;\\nll w[N];\\nll st[N];\\n\\nstruct Node {\\n    ll l,r;\\n    ll minv, idx, sum;\\n} tree[4*N];\\n\\nvoid push_up(Node& a, Node& b, Node & c) {\\n    if(b.minv <= c.minv) {\\n        a.minv = b.minv;\\n        a.idx = b.idx;\\n    } else {\\n        a.minv = c.minv;\\n        a.idx = c.idx;\\n    }\\n    a.sum = b.sum + c.sum;\\n}\\n\\nvoid push_up(ll u) {\\n    push_up(tree[u], tree[2*u], tree[2*u+1]);\\n}\\n\\nvoid build(ll u, ll l, ll r) {\\n    tree[u].l = l;\\n    tree[u].r = r;\\n    if(l == r) {\\n        ll b = w[l];\\n        tree[u].minv = b;\\n        tree[u].idx = l;\\n        tree[u].sum = st[l];\\n    } else {\\n        ll mid = (l + r) / 2;\\n        build(2*u, l, mid);\\n        build(2*u+1, mid+1, r);\\n        push_up(u);\\n    }\\n}\\n\\nvoid update(ll u, ll idx, ll x) {\\n    if(tree[u].l == tree[u].r) {\\n        tree[u].minv = x;\\n        tree[u].sum = 0;\\n        st[tree[u].l] = 0;\\n    } else {\\n        ll mid = (tree[u].l + tree[u].r)/2;\\n        if(idx <= mid) update(2*u, idx, x);\\n        else update(2*u+1, idx, x);\\n        push_up(u);\\n    }\\n}\\n\\nNode query(ll u, ll l, ll r) {\\n    if(tree[u].l >= l && tree[u].r <= r) {\\n        return tree[u];\\n    } else {\\n        ll mid = (tree[u].l + tree[u].r)/2;\\n        if(l > mid) {\\n            return query(2*u+1, l, r);\\n        } else if (r <= mid) {\\n            return query(2*u, l, r);\\n        } else {\\n            auto left = query(2*u, l, r);\\n            auto right = query(2*u+1, l, r);\\n            Node res;\\n            push_up(res, left, right);\\n            return res;\\n        }\\n    }\\n}\\n\\nint get_idx(int presum, int len) {\\n    int l = 1;\\n    int r = len;\\n    int res = len;\\n    while(l <= r) {\\n        int mid = (l + r) / 2;\\n        if(query(1, 1, mid).sum >= presum) {\\n            res = mid;\\n            r = mid - 1;\\n        } else {\\n            l = mid + 1;\\n        }\\n    }\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n        if(k > n*(n-1)/2) {\\n            sort(num.begin(), num.end());\\n            return num;\\n        }\\n        return solve(num, k);\\n    }\\n    void init(string & num) {\\n        // build the SegTree;\\n        int n = num.size();\\n        memset(tree, 0, sizeof tree);\\n        for(int i = 1; i <= n; i ++) w[i] = num[i-1] - \\'0\\';\\n        for(int i = 1; i <= n; i ++) st[i] = 1;\\n        build(1, 1, n);\\n    }\\n    string solve(string & num, int k) {\\n        init(num);\\n        string res;\\n        while(k) {\\n            int max_sum = min(k+1, (int)num.size());\\n            int threshold = get_idx(max_sum, num.size());\\n            Node curr = query(1, 1, threshold);\\n            if(curr.minv == 10) break;\\n            res.push_back(curr.minv + \\'0\\');\\n            update(1, curr.idx, 10);\\n            k -= query(1, 1, curr.idx).sum;\\n        }\\n        for(int i = 1; i <= num.size(); i ++) {\\n            if(st[i] == 1) {\\n\\t\\t\\t// unused digits\\n                res.push_back(num[i-1]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723457,
                "title": "a-simple-c-o-n-solution-100ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        const int n = num.size();\\n        string res;\\n        res.reserve(n);\\n        vector<int> q(10, n);\\n        for (int i = 0; i < n; ++i) {\\n            const int d = num[i] - \\'0\\';\\n            if (q[d] == n)\\n                q[d] = i;\\n        }\\n        vector<bool> used(n);\\n        vector<int> q_used(10);\\n        for (int i = 0; i < n; ++i) {\\n            for (int d = 0; d < 10; ++d) {\\n                if (q[d] == n)\\n                    continue;\\n                const int c = q[d] - q_used[d];\\n                \\n                if (c <= k) {\\n                    k -= c;\\n                    res.push_back(\\'0\\' + d);\\n                    used[q[d]] = true;\\n                    for (int d1 = 0; d1 < 10; ++d1) {\\n                        if (q[d1] > q[d])\\n                            q_used[d1]++;\\n                    }\\n                    while (q[d] < n) {\\n                        if (used[q[d]])\\n                            ++q_used[d];\\n                        if (num[++q[d]] == \\'0\\' + d)\\n                            break;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        const int n = num.size();\\n        string res;\\n        res.reserve(n);\\n        vector<int> q(10, n);\\n        for (int i = 0; i < n; ++i) {\\n            const int d = num[i] - \\'0\\';\\n            if (q[d] == n)\\n                q[d] = i;\\n        }\\n        vector<bool> used(n);\\n        vector<int> q_used(10);\\n        for (int i = 0; i < n; ++i) {\\n            for (int d = 0; d < 10; ++d) {\\n                if (q[d] == n)\\n                    continue;\\n                const int c = q[d] - q_used[d];\\n                \\n                if (c <= k) {\\n                    k -= c;\\n                    res.push_back(\\'0\\' + d);\\n                    used[q[d]] = true;\\n                    for (int d1 = 0; d1 < 10; ++d1) {\\n                        if (q[d1] > q[d])\\n                            q_used[d1]++;\\n                    }\\n                    while (q[d] < n) {\\n                        if (used[q[d]])\\n                            ++q_used[d];\\n                        if (num[++q[d]] == \\'0\\' + d)\\n                            break;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720554,
                "title": "java-27ms-o-nlogn-fenwick-bit-solution",
                "content": "Had the rough idea during the contest but got stuck at how to update INDEX using BIT. Checked @tian-tang-6\\'s answer and this tutorial: https://www.hackerearth.com/practice/data-structures/advanced-data-structures/fenwick-binary-indexed-trees/tutorial/, realized that instead of updating INDEX, we should: \\n1. Initialize BIT with 1 for all indices, which is the character count;\\n2. Update the count to 0 ( count--) when a character at index i is swapped to the beginning.\\n\\n```\\n    public String minInteger(String num, int k) {\\n        char[] cs = num.toCharArray();\\n        int n = cs.length;\\n        StringBuilder sb = new StringBuilder();\\n        IntegerBIT bit = new IntegerBIT(n);\\n        for (int i = 1; i <= n; i++) {\\n            bit.update(i, 1);\\n        }\\n        Deque<Integer>[] dq = new ArrayDeque[10];\\n        for (int i = 0; i < 10; i++) {\\n            dq[i] = new ArrayDeque<>();\\n        }\\n        for (int i = 0; i < n; i++) {\\n            dq[cs[i] - \\'0\\'].offerLast(i);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < 10; j++) {\\n                Integer index = dq[j].peekFirst();\\n                if (!dq[j].isEmpty() && bit.query(index) <= k) {\\n                    //number of \\'1\\'s before index is the number of swaps\\n                    k -= bit.query(index);\\n                    //index in string is represented in BIT at index + 1\\n                    bit.update(index + 1, -1);\\n                    dq[j].pollFirst();\\n                    sb.append((char)(\\'0\\' + j));\\n                    break;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\n    public static class IntegerBIT {\\n        int n;\\n        int[] data;\\n\\n        public IntegerBIT(int n) {\\n            this.n = n;\\n            data = new int[n + 1];//1 based\\n        }\\n\\n        /**\\n         * Queries sum of A[1]..A[x] inclusive. A is the underlying array this BIT represents.\\n         */\\n        public int query(int x) {\\n            int sum = 0;\\n            for (; x > 0 ; x -= x & (-x)) {\\n                sum += data[x];\\n            }\\n            return sum;\\n        }\\n\\n        /**\\n         * Queries sum of A[i]..A[j] inclusive\\n         */\\n        public int query(int i, int j) {\\n            return query(i) - query(j - 1);\\n        }\\n\\n        /**\\n         * Updates A[i] by d\\n         */\\n        public void update(int i, int d) {\\n            for (; i <= n; i += i & (-i)) {\\n                data[i] += d;\\n            }\\n        }\\n    }\\n```\\n",
                "solutionTags": [
                    "Binary Indexed Tree"
                ],
                "code": "```\\n    public String minInteger(String num, int k) {\\n        char[] cs = num.toCharArray();\\n        int n = cs.length;\\n        StringBuilder sb = new StringBuilder();\\n        IntegerBIT bit = new IntegerBIT(n);\\n        for (int i = 1; i <= n; i++) {\\n            bit.update(i, 1);\\n        }\\n        Deque<Integer>[] dq = new ArrayDeque[10];\\n        for (int i = 0; i < 10; i++) {\\n            dq[i] = new ArrayDeque<>();\\n        }\\n        for (int i = 0; i < n; i++) {\\n            dq[cs[i] - \\'0\\'].offerLast(i);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < 10; j++) {\\n                Integer index = dq[j].peekFirst();\\n                if (!dq[j].isEmpty() && bit.query(index) <= k) {\\n                    //number of \\'1\\'s before index is the number of swaps\\n                    k -= bit.query(index);\\n                    //index in string is represented in BIT at index + 1\\n                    bit.update(index + 1, -1);\\n                    dq[j].pollFirst();\\n                    sb.append((char)(\\'0\\' + j));\\n                    break;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\n    public static class IntegerBIT {\\n        int n;\\n        int[] data;\\n\\n        public IntegerBIT(int n) {\\n            this.n = n;\\n            data = new int[n + 1];//1 based\\n        }\\n\\n        /**\\n         * Queries sum of A[1]..A[x] inclusive. A is the underlying array this BIT represents.\\n         */\\n        public int query(int x) {\\n            int sum = 0;\\n            for (; x > 0 ; x -= x & (-x)) {\\n                sum += data[x];\\n            }\\n            return sum;\\n        }\\n\\n        /**\\n         * Queries sum of A[i]..A[j] inclusive\\n         */\\n        public int query(int i, int j) {\\n            return query(i) - query(j - 1);\\n        }\\n\\n        /**\\n         * Updates A[i] by d\\n         */\\n        public void update(int i, int d) {\\n            for (; i <= n; i += i & (-i)) {\\n                data[i] += d;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720270,
                "title": "my-screencast",
                "content": "https://www.youtube.com/watch?v=1wjYXKeGtOc",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=1wjYXKeGtOc",
                "codeTag": "Unknown"
            },
            {
                "id": 720352,
                "title": "c-preprocess-120-ms",
                "content": "The first function is just a greedy brute-force algorithm that checks for the minimal character within K, and bubbles it up.\\n\\nIt\\'s O(n * n) so you will get TLE. I saw folks solved it using logarithmic structures, but all I got is this silly idea.\\n\\nI think that we first need to reduce K. Obviously, if K is large, we would move all zeros, ones, and so on to the front. We can get positions of a given number in one scan, and we do it for each digit `\\'0\\' - \\'9\\'`. Note that we need to quit as soon as the next smallest character cannot be moved to the front, and do brute-force for reduced K.\\n\\n\\n```cpp\\nstring minInteger(string num, int k) {\\n    string pre;\\n    preprocess(pre, num, k);\\n    while (k > 0 && !num.empty()) {\\n        auto pos = 0;\\n        for (auto i = 1; i < num.size() && i <= k; ++i)\\n            if (num[i] < num[pos]) \\n                pos = i;\\n        pre += num[pos];\\n        k -= pos;\\n        num = num.substr(0, pos) + num.substr(pos + 1);\\n    }\\n    return pre + num;\\n}\\nvoid preprocess(string &pre, string &num, int &k) {\\n    for (auto n = \\'0\\'; n < \\'9\\'; ++n) {\\n        vector<int> pos;\\n        for (auto i = 0; i < num.size(); ++i)\\n            if (num[i] == n)\\n                pos.push_back(i);\\n        if (!pos.empty() && k < pos[0])\\n            break;\\n        int cnt = 0;            \\n        for (auto i = 0; i < pos.size() && pos[i] <= k + cnt; ++i) {\\n            k -= pos[i] - cnt;\\n            ++cnt;   \\n        }\\n        pre += string(cnt, n);\\n        string num1;\\n        for (auto ch : num) {\\n            if (ch == n && cnt > 0)\\n                --cnt;\\n            else\\n                num1 += ch;\\n        }\\n        swap(num, num1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nstring minInteger(string num, int k) {\\n    string pre;\\n    preprocess(pre, num, k);\\n    while (k > 0 && !num.empty()) {\\n        auto pos = 0;\\n        for (auto i = 1; i < num.size() && i <= k; ++i)\\n            if (num[i] < num[pos]) \\n                pos = i;\\n        pre += num[pos];\\n        k -= pos;\\n        num = num.substr(0, pos) + num.substr(pos + 1);\\n    }\\n    return pre + num;\\n}\\nvoid preprocess(string &pre, string &num, int &k) {\\n    for (auto n = \\'0\\'; n < \\'9\\'; ++n) {\\n        vector<int> pos;\\n        for (auto i = 0; i < num.size(); ++i)\\n            if (num[i] == n)\\n                pos.push_back(i);\\n        if (!pos.empty() && k < pos[0])\\n            break;\\n        int cnt = 0;            \\n        for (auto i = 0; i < pos.size() && pos[i] <= k + cnt; ++i) {\\n            k -= pos[i] - cnt;\\n            ++cnt;   \\n        }\\n        pre += string(cnt, n);\\n        string num1;\\n        for (auto ch : num) {\\n            if (ch == n && cnt > 0)\\n                --cnt;\\n            else\\n                num1 += ch;\\n        }\\n        swap(num, num1);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 826459,
                "title": "c-o-nlogn-binary-search-with-logic",
                "content": "\\n```\\n/** <Greedy Approach>\\nWe take 10 queues for digits 0 to 9 and store their occurence(index in the original string) in the queues (clearly all the queues are sorted by default) \\nNow we want the most significant digit to be the smallest so we try all the 0-9 digits at position i .\\nSuppose we want to place any digit j in range [0,9] at a position i we do a binay search on all the 10 queues to find the number of digits \\nwith index smaller than the current chosen digits index then we will check if the swaps are less than or equal to the current k value if yes\\nwe put the current digit in new string and go for the (i+1)th place else we will continue to check for digit j+1 .\\nBelow is the implementation\\n*/\\nint bs(vector<int> &v,int l,int r,int key){\\n\\n        if(l>r) return l;\\n        int mid=l+(r-l)/2;\\n\\n        if(v[mid]>key) return bs(v,l,mid-1,key);\\n        return bs(v,mid+1,r,key);\\n}\\nstring minInteger(string num, int k) {\\n     int n=num.size();\\n\\t //trivial case\\n     if(k>=(n*(n-1))/2){\\n        sort(num.begin(),num.end());\\n        return num;\\n     }\\n\\t //queues\\n     vector<vector<int> >v(10);\\n     for(int i=0;i<n;++i){\\n        v[num[i]-\\'0\\'].push_back(i);\\n     }\\n\\t //head for every queue to store the queue state\\n     vector<int> head(10);\\n     string ans=\"\";\\n      vector<bool> visit(n);\\n     for(int i=0;i<n && k>0;++i){\\n        for(int j=0;j<10;++j){\\n\\n            if(head[j]<v[j].size()){\\n\\n\\t\\t\\t\\t// total count of digits with smaller index than the current chosen digit\\n                int idx=0;\\n\\t\\t\\t\\t//binary search on all the 10 queues\\n                for(int l=0;l<10;++l){\\n                    if(l!=j){\\n                        idx+=bs(v[l],0,head[l]-1,v[j][head[j]]);\\n                    }\\n                    else\\n                        idx+=head[l];\\n                }\\n//                cout<<k<<\" \"<<idx<<\" \"<<j<<\"\\\\n\";\\n                if(k>=(v[j][head[j]]-idx)){\\n\\n                    ans.push_back((char)(j+\\'0\\'));\\n                    visit[v[j][head[j]]]=true;\\n                    k-=(v[j][head[j]]-idx);\\n                    ++head[j];\\n                    break;\\n                }\\n            }\\n        }\\n     }\\n\\t// appending the remaining string\\n     for(int i=0;i<n;++i) if(!visit[i]) ans.push_back(num[i]);\\n    \\n     return ans;\\n\\n}",
                "solutionTags": [],
                "code": "\\n```\\n/** <Greedy Approach>\\nWe take 10 queues for digits 0 to 9 and store their occurence(index in the original string) in the queues (clearly all the queues are sorted by default) \\nNow we want the most significant digit to be the smallest so we try all the 0-9 digits at position i .\\nSuppose we want to place any digit j in range [0,9] at a position i we do a binay search on all the 10 queues to find the number of digits \\nwith index smaller than the current chosen digits index then we will check if the swaps are less than or equal to the current k value if yes\\nwe put the current digit in new string and go for the (i+1)th place else we will continue to check for digit j+1 .\\nBelow is the implementation\\n*/\\nint bs(vector<int> &v,int l,int r,int key){\\n\\n        if(l>r) return l;\\n        int mid=l+(r-l)/2;\\n\\n        if(v[mid]>key) return bs(v,l,mid-1,key);\\n        return bs(v,mid+1,r,key);\\n}\\nstring minInteger(string num, int k) {\\n     int n=num.size();\\n\\t //trivial case\\n     if(k>=(n*(n-1))/2){\\n        sort(num.begin(),num.end());\\n        return num;\\n     }\\n\\t //queues\\n     vector<vector<int> >v(10);\\n     for(int i=0;i<n;++i){\\n        v[num[i]-\\'0\\'].push_back(i);\\n     }\\n\\t //head for every queue to store the queue state\\n     vector<int> head(10);\\n     string ans=\"\";\\n      vector<bool> visit(n);\\n     for(int i=0;i<n && k>0;++i){\\n        for(int j=0;j<10;++j){\\n\\n            if(head[j]<v[j].size()){\\n\\n\\t\\t\\t\\t// total count of digits with smaller index than the current chosen digit\\n                int idx=0;\\n\\t\\t\\t\\t//binary search on all the 10 queues\\n                for(int l=0;l<10;++l){\\n                    if(l!=j){\\n                        idx+=bs(v[l],0,head[l]-1,v[j][head[j]]);\\n                    }\\n                    else\\n                        idx+=head[l];\\n                }\\n//                cout<<k<<\" \"<<idx<<\" \"<<j<<\"\\\\n\";\\n                if(k>=(v[j][head[j]]-idx)){\\n\\n                    ans.push_back((char)(j+\\'0\\'));\\n                    visit[v[j][head[j]]]=true;\\n                    k-=(v[j][head[j]]-idx);\\n                    ++head[j];\\n                    break;\\n                }\\n            }\\n        }\\n     }\\n\\t// appending the remaining string\\n     for(int i=0;i<n;++i) if(!visit[i]) ans.push_back(num[i]);\\n    \\n     return ans;\\n\\n}",
                "codeTag": "C++"
            },
            {
                "id": 721509,
                "title": "python-straight-forward-short-greedy-algorithm",
                "content": "A greedy approach will do the job.\\nIterate the index i from the left to right. Each iteration do a swap in a greedy way, i.e. swap num[i] with the smallest number within num[i+1:]\\n\\n```\\nclass Solution:\\n    \\'\\'\\' greedy approach. start from the left side, \\n\\t    and everytime pick the smallest number on the right side that is able to swap, then do the swap\\n    \\'\\'\\'\\n    def minInteger(self, num: str, k: int) -> str:\\n        min_num = sorted(list(num))\\n        min_num = \\'\\'.join(min_num)\\n        i = 0\\n        to_find = 0\\n        while num != min_num and k > 0 and i < len(num):\\n            indx = num.find(str(to_find), i)\\n            while indx != -1:\\n                if indx - i <= k:   # able to swap\\n                    num = num[:i] + num[indx] + num[i:indx] + num[indx+1:]  # the swap\\n                    k -= (indx - i)\\n                    i += 1\\n                    to_find = 0     # restart the to_find variable\\n                    indx = num.find(str(to_find), i)\\n                else:\\n                    break\\n            to_find += 1\\n        return num\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\'\\'\\' greedy approach. start from the left side, \\n\\t    and everytime pick the smallest number on the right side that is able to swap, then do the swap\\n    \\'\\'\\'\\n    def minInteger(self, num: str, k: int) -> str:\\n        min_num = sorted(list(num))\\n        min_num = \\'\\'.join(min_num)\\n        i = 0\\n        to_find = 0\\n        while num != min_num and k > 0 and i < len(num):\\n            indx = num.find(str(to_find), i)\\n            while indx != -1:\\n                if indx - i <= k:   # able to swap\\n                    num = num[:i] + num[indx] + num[i:indx] + num[indx+1:]  # the swap\\n                    k -= (indx - i)\\n                    i += 1\\n                    to_find = 0     # restart the to_find variable\\n                    indx = num.find(str(to_find), i)\\n                else:\\n                    break\\n            to_find += 1\\n        return num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906381,
                "title": "java-treemap-headmap-size-time-complexity-is-not-o-1",
                "content": "I was surprised that no one consider using treemap at first, but found out I didn\\'t quite understand the time complexity of treemap api.\\nImplemente the idea of this [post](https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/discuss/720548/O(n-logn)-or-Detailed-Explanation) using treemap, but got TLE\\n\\nheadMap().size() complexity is O(k) not O(1): https://stackoverflow.com/questions/14750374/what-is-complexity-of-size-for-treeset-portion-view-in-java\\n\\n```\\n  public String minInteger(String num, int k) {\\n    Queue<Integer>[] qArr = new ArrayDeque[10];\\n    char[] arr = num.toCharArray();\\n    int n = num.length();\\n    \\n    for (int d = 0; d < 10; d++) {\\n      qArr[d] = new ArrayDeque<>();\\n    }\\n    \\n    for (int i = 0; i < n; i++) {\\n      qArr[arr[i] - \\'0\\'].offer(i);\\n    }\\n    TreeSet<Integer> treeSet = new TreeSet<>();\\n    \\n    StringBuilder res = new StringBuilder();\\n    for (int i = 0; i < n; i++) {\\n      for (int d = 0; d < 10; d++) {\\n        Queue<Integer> q = qArr[d];\\n        if (q.isEmpty()) {\\n          continue;\\n        }\\n        int idx = q.peek();\\n        int numLessOrEqual = treeSet.headSet(idx).size();\\n        int requiredSteps = idx - numLessOrEqual; \\n        if (k >= requiredSteps) {\\n          q.poll();\\n          k -= requiredSteps;\\n          res.append(d);\\n          treeSet.add(idx);\\n          break;\\n        }\\n      }\\n    }\\n    \\n    return res.toString();\\n    \\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  public String minInteger(String num, int k) {\\n    Queue<Integer>[] qArr = new ArrayDeque[10];\\n    char[] arr = num.toCharArray();\\n    int n = num.length();\\n    \\n    for (int d = 0; d < 10; d++) {\\n      qArr[d] = new ArrayDeque<>();\\n    }\\n    \\n    for (int i = 0; i < n; i++) {\\n      qArr[arr[i] - \\'0\\'].offer(i);\\n    }\\n    TreeSet<Integer> treeSet = new TreeSet<>();\\n    \\n    StringBuilder res = new StringBuilder();\\n    for (int i = 0; i < n; i++) {\\n      for (int d = 0; d < 10; d++) {\\n        Queue<Integer> q = qArr[d];\\n        if (q.isEmpty()) {\\n          continue;\\n        }\\n        int idx = q.peek();\\n        int numLessOrEqual = treeSet.headSet(idx).size();\\n        int requiredSteps = idx - numLessOrEqual; \\n        if (k >= requiredSteps) {\\n          q.poll();\\n          k -= requiredSteps;\\n          res.append(d);\\n          treeSet.add(idx);\\n          break;\\n        }\\n      }\\n    }\\n    \\n    return res.toString();\\n    \\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 720229,
                "title": "java-nlogn-binary-tree",
                "content": "* Store indexes of all digits in a list.\\n* Start putting from 0 to 9 whichever satisfy the condition first.\\n* Condition is satisfied if number of swaps remaining (k) >= number of swaps required (val - count) => `k >= val - count`\\n* `val = index of the digit`\\n* ` count = number of elements used before that index`\\n* To find the number of elements used , maintain a Binary Tree with left count.\\n\\n\\n\\n\\n```\\nclass Solution { \\n    class TreeNode{\\n        TreeNode left;\\n        TreeNode right;\\n        int val;\\n        int leftcount;\\n        TreeNode(int val){\\n            this.val = val;\\n        }\\n    }\\n    int count;\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        List<Integer> al[] = new ArrayList[10];\\n        for(int i=0;i<10;i++){\\n            al[i] = new ArrayList();\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            al[num.charAt(i) - 48].add(i);\\n        }\\n        Set<Integer> hs = new HashSet();\\n        StringBuilder sb = new StringBuilder(\"\");\\n        TreeNode root = null;\\n        while(n-- > 0 && k > 0){\\n            for(int ind=0;ind<10;ind++){\\n                if(al[ind].size() == 0){\\n                    continue ;\\n                }\\n                int val = al[ind].get(al[ind].size()-1);\\n                count = 0;\\n                search(root, val);\\n                if(k >= val - count){\\n                    sb.append(ind);\\n                    root = add(root, val);\\n                    al[ind].remove(al[ind].size()-1);\\n                    hs.add(val);\\n                    k -= val-count;\\n                    break ;\\n                }\\n            }\\n        }\\n        for(int i=0;i<num.length();i++){\\n            if(!hs.contains(i)){\\n                sb.append(num.charAt(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private void search(TreeNode root, int val){\\n        if(root == null){\\n            return ;\\n        }\\n        if(val < root.val){\\n            search(root.left, val);\\n        }else{\\n            count += 1+root.leftcount;\\n            search(root.right, val);\\n        }\\n    }\\n    \\n    private TreeNode add(TreeNode root, int val){\\n        if(root == null){\\n            return new TreeNode(val);\\n        }\\n        if(val < root.val){\\n            root.left = add(root.left, val);\\n            root.leftcount += 1;\\n        }else{\\n            root.right = add(root.right, val);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution { \\n    class TreeNode{\\n        TreeNode left;\\n        TreeNode right;\\n        int val;\\n        int leftcount;\\n        TreeNode(int val){\\n            this.val = val;\\n        }\\n    }\\n    int count;\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        List<Integer> al[] = new ArrayList[10];\\n        for(int i=0;i<10;i++){\\n            al[i] = new ArrayList();\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            al[num.charAt(i) - 48].add(i);\\n        }\\n        Set<Integer> hs = new HashSet();\\n        StringBuilder sb = new StringBuilder(\"\");\\n        TreeNode root = null;\\n        while(n-- > 0 && k > 0){\\n            for(int ind=0;ind<10;ind++){\\n                if(al[ind].size() == 0){\\n                    continue ;\\n                }\\n                int val = al[ind].get(al[ind].size()-1);\\n                count = 0;\\n                search(root, val);\\n                if(k >= val - count){\\n                    sb.append(ind);\\n                    root = add(root, val);\\n                    al[ind].remove(al[ind].size()-1);\\n                    hs.add(val);\\n                    k -= val-count;\\n                    break ;\\n                }\\n            }\\n        }\\n        for(int i=0;i<num.length();i++){\\n            if(!hs.contains(i)){\\n                sb.append(num.charAt(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private void search(TreeNode root, int val){\\n        if(root == null){\\n            return ;\\n        }\\n        if(val < root.val){\\n            search(root.left, val);\\n        }else{\\n            count += 1+root.leftcount;\\n            search(root.right, val);\\n        }\\n    }\\n    \\n    private TreeNode add(TreeNode root, int val){\\n        if(root == null){\\n            return new TreeNode(val);\\n        }\\n        if(val < root.val){\\n            root.left = add(root.left, val);\\n            root.leftcount += 1;\\n        }else{\\n            root.right = add(root.right, val);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389405,
                "title": "python-3-solutions-with-thought-process-when-being-asked-during-interviews",
                "content": "### Binary Search\\nIn order to construct the minimum number, we want to find the minimum digit within the window of size of *k*, which determine the range of digits that can be moved.\\nThe naive solution I came up first is to find out the minimum digit adhoc, which takes many unnecessary comparision. Because the digit is limited from 0 to 9, we can iterate from 0 to 9 to pick the first digit that is within the window. \\nThe key point is that the index of digits after the moved one have to be updated accordingly after moving. For example, `4203 => 0423`, the index of `3` changed from `3` to `2` since we won\\'t consider `0` by excluding it. In another word, the *num* bacomes `423`. However, all digits before `0` are not changed. \\nSo each time we get the index of digit from 0 to 9, we have to update it with the *offset* that is the number of moved digits that appear before it.\\nSo we can use binary search to find the number of moved indices that is smaller than each index we want to pick. If the `index - offset <= k`, we can pick that digit and move on to next digit.\\nOne improvement is that we can quickly return the sorted *num* if *k* is larger than *n^2* since the complexity is O(N^2) for sorting algorithm based on comparision. Then we can append each digit from 0 to 9 instead of actual sorting it, which takes linear time.\\n\\n```python\\ndef minInteger(self, num: str, k: int) -> str:\\n\\tn = len(num)\\n    num = list(num)\\n    res = []\\n\\n    counter = defaultdict(deque)\\n    for i, c in enumerate(num):\\n\\t\\tcounter[int(c)].append(i)\\n\\tif k >= n**2:\\n\\t\\treturn \\'\\'.join(sorted(num))\\n\\n\\tused = []\\n    for _ in range(n):\\n\\t\\tfor i in range(10):\\n\\t\\t\\tif counter[i]:\\n\\t\\t\\t\\tindex = counter[i][0]\\n                offset = bisect.bisect_left(used, index)\\n                if index - offset <= k:\\n\\t\\t\\t\\t\\tk -= index - offset\\n                    res.append(i)\\n                    used.insert(offset, counter[i].popleft())\\n                    break\\n\\treturn \\'\\'.join(map(str, res))\\n```\\nNote, since `insert` takes linear time, the complexity is actual N^2, while it\\'d be NlgN if you use SortedList or Binary Search Tree.\\n\\n*Time Complexity* = **O(NlgN)**\\n*Space Complexity* =**O(N)**\\n\\n### Binary Indexed Tree\\nThe idea is the same, but with a different data structure, binary indexed tree, to query the number of indices of moved digits that is smaller than current index. Binary Indexed Tree is more balanced natually than binary search tree written by manually. \\nActually, BIT is quite easy to wirte and use if you are familiar with the template of BIT.\\n\\n```python\\ndef minInteger(self, num: str, k: int) -> str:\\n\\tn = len(num)\\n    num = list(num)\\n    res = []\\n\\n    counter = defaultdict(deque)\\n    for i, c in enumerate(num):\\n\\t\\tcounter[c].append(i)\\n\\tif k >= n**2:\\n\\t\\treturn \\'\\'.join(sorted(num))\\n\\n\\t# bit template, will always be the same when you use it\\n\\tbit = [0] * (n + 1)\\n    def query(i):\\n\\t\\ttotal = 0\\n        while i:\\n\\t\\t\\ttotal += bit[i]\\n            i -= i & -i\\n\\t\\treturn total\\n        \\n\\tdef update(i, value):\\n\\t\\twhile i < len(bit):\\n\\t\\t\\tbit[i] += value\\n\\t\\t\\ti += i & -i\\n\\n\\tfor _ in range(n):\\n\\t\\tfor i in \\'0123456789\\':\\n\\t\\t\\tif counter[i]:\\n\\t\\t\\t\\tindex = counter[i][0]\\n                offset = query(index)\\n                if index - offset <= k:\\n\\t\\t\\t\\t\\tk -= index - offset\\n                    res.append(i)\\n                    counter[i].popleft()\\n                    update(index + 1, 1)\\n                    break\\n\\treturn \\'\\'.join(res)\\n```\\n\\n### Segment Tree\\nSame idea with different data structure, the only difference between Segment Tree and Binary Indexed Tree here is Segement Tree is more flexible supporting customized merge function, such as range minimum/maximum/sum, while BIT supports limited functions, most of cases is sum. for this problem, both works.\\n```python\\ndef minInteger(self, num: str, k: int) -> str:\\n\\tn = len(num)\\n    num = list(num)\\n    res = []\\n\\n    counter = defaultdict(deque)\\n    for i, c in enumerate(num):\\n\\t\\tcounter[c].append(i)\\n\\tif k >= n**2:\\n\\t\\treturn \\'\\'.join(sorted(num))\\n\\n\\t# segment tree template, modify for use cases\\n\\theight = ceil(log(n, 2))\\n    leaf = 2 ** height - 1\\n    st = [0] * (2 ** (height + 1) - 1)\\n        \\n    def query(i, j):\\n\\t\\ti, j = i + leaf, j + leaf\\n        total = 0\\n        while i <= j:\\n\\t\\t\\tif not i % 2:\\n\\t\\t\\t\\ttotal += st[i]\\n                i += 1\\n\\t\\t\\tif j % 2:\\n\\t\\t\\t\\ttotal += st[j]\\n                j -= 1\\n\\t\\t\\ti = (i - 1) // 2\\n            j = j // 2 - 1 \\n\\t\\treturn total\\n                    \\n\\tdef update(i, value):\\n\\t\\ti += leaf\\n        while i >= 0:\\n\\t\\t\\tst[i] += value\\n            if i % 2:\\n\\t\\t\\t\\ti = (i - 1) // 2\\n\\t\\t\\telse:\\n\\t\\t\\t\\ti = i // 2 - 1\\n             \\n\\tfor _ in range(n):\\n\\t\\tfor i in \\'0123456789\\':\\n\\t\\t\\tif counter[i]:\\n\\t\\t\\t\\tindex = counter[i][0]\\n                offset = query(index)\\n                if index - offset <= k:\\n\\t\\t\\t\\t\\tk -= index - offset\\n                    res.append(i)\\n                    counter[i].popleft()\\n                    update(index + 1, 1)\\n                    break\\n\\treturn \\'\\'.join(res)\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```python\\ndef minInteger(self, num: str, k: int) -> str:\\n\\tn = len(num)\\n    num = list(num)\\n    res = []\\n\\n    counter = defaultdict(deque)\\n    for i, c in enumerate(num):\\n\\t\\tcounter[int(c)].append(i)\\n\\tif k >= n**2:\\n\\t\\treturn \\'\\'.join(sorted(num))\\n\\n\\tused = []\\n    for _ in range(n):\\n\\t\\tfor i in range(10):\\n\\t\\t\\tif counter[i]:\\n\\t\\t\\t\\tindex = counter[i][0]\\n                offset = bisect.bisect_left(used, index)\\n                if index - offset <= k:\\n\\t\\t\\t\\t\\tk -= index - offset\\n                    res.append(i)\\n                    used.insert(offset, counter[i].popleft())\\n                    break\\n\\treturn \\'\\'.join(map(str, res))\\n```\n```python\\ndef minInteger(self, num: str, k: int) -> str:\\n\\tn = len(num)\\n    num = list(num)\\n    res = []\\n\\n    counter = defaultdict(deque)\\n    for i, c in enumerate(num):\\n\\t\\tcounter[c].append(i)\\n\\tif k >= n**2:\\n\\t\\treturn \\'\\'.join(sorted(num))\\n\\n\\t# bit template, will always be the same when you use it\\n\\tbit = [0] * (n + 1)\\n    def query(i):\\n\\t\\ttotal = 0\\n        while i:\\n\\t\\t\\ttotal += bit[i]\\n            i -= i & -i\\n\\t\\treturn total\\n        \\n\\tdef update(i, value):\\n\\t\\twhile i < len(bit):\\n\\t\\t\\tbit[i] += value\\n\\t\\t\\ti += i & -i\\n\\n\\tfor _ in range(n):\\n\\t\\tfor i in \\'0123456789\\':\\n\\t\\t\\tif counter[i]:\\n\\t\\t\\t\\tindex = counter[i][0]\\n                offset = query(index)\\n                if index - offset <= k:\\n\\t\\t\\t\\t\\tk -= index - offset\\n                    res.append(i)\\n                    counter[i].popleft()\\n                    update(index + 1, 1)\\n                    break\\n\\treturn \\'\\'.join(res)\\n```\n```python\\ndef minInteger(self, num: str, k: int) -> str:\\n\\tn = len(num)\\n    num = list(num)\\n    res = []\\n\\n    counter = defaultdict(deque)\\n    for i, c in enumerate(num):\\n\\t\\tcounter[c].append(i)\\n\\tif k >= n**2:\\n\\t\\treturn \\'\\'.join(sorted(num))\\n\\n\\t# segment tree template, modify for use cases\\n\\theight = ceil(log(n, 2))\\n    leaf = 2 ** height - 1\\n    st = [0] * (2 ** (height + 1) - 1)\\n        \\n    def query(i, j):\\n\\t\\ti, j = i + leaf, j + leaf\\n        total = 0\\n        while i <= j:\\n\\t\\t\\tif not i % 2:\\n\\t\\t\\t\\ttotal += st[i]\\n                i += 1\\n\\t\\t\\tif j % 2:\\n\\t\\t\\t\\ttotal += st[j]\\n                j -= 1\\n\\t\\t\\ti = (i - 1) // 2\\n            j = j // 2 - 1 \\n\\t\\treturn total\\n                    \\n\\tdef update(i, value):\\n\\t\\ti += leaf\\n        while i >= 0:\\n\\t\\t\\tst[i] += value\\n            if i % 2:\\n\\t\\t\\t\\ti = (i - 1) // 2\\n\\t\\t\\telse:\\n\\t\\t\\t\\ti = i // 2 - 1\\n             \\n\\tfor _ in range(n):\\n\\t\\tfor i in \\'0123456789\\':\\n\\t\\t\\tif counter[i]:\\n\\t\\t\\t\\tindex = counter[i][0]\\n                offset = query(index)\\n                if index - offset <= k:\\n\\t\\t\\t\\t\\tk -= index - offset\\n                    res.append(i)\\n                    counter[i].popleft()\\n                    update(index + 1, 1)\\n                    break\\n\\treturn \\'\\'.join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 735476,
                "title": "python-o-n-10-deques-with-1-stack",
                "content": "# Idea\\n\\nThe first digit of the output should be the minimum of the first `k + 1` digits in `num`, i.e., `min(num[:k+1])`. Similarly, the `i`-th digit of the output should be `min(num[i:i+k+1])`, where we assume\\n* The digits of `num` are swapped in-place. That is, `num[:i]` are already the first `i` digits of the output.\\n* `k` is the remaining number of moves, which decreases as more and more digits are swapped.\\n\\nIf we swap digits one by one, we will end up with a `O(n^2)` algorithm because there will be a maximum of `O(n^2)` swaps needed. Therefore, we need a more efficient way to swap the digits.\\n\\nInstead of actually swapping *adjacent* digits, assume we store all the digits of interest (`num[i:i+k+1]`) as a **sequence** in a data structure `D`, which supports the following 4 operations:\\n1. `push(x)`: Push `x` to the end of `D`.\\n2. `pop()`: Pop the last element of `D`.\\n3. `pop_min()`: Pop the minimum digit in `D`. If there are multiple ones, return the first one.\\n4. `get_min_position()`: Get the position of the minimum digit in `D`. Here the *position* is the 0-based index in the sequence.\\n\\nThen, we can solve the problem this way.\\n\\n```py\\ndef minInteger(self, num: str, k: int) -> str:\\n    data = D()   # Empty sequence\\n    output = \\'\\'  # Output string\\n    for i in range(len(num)):\\n\\t    # Make sure data contains the (k + 1) digits of interest\\n\\t    while data.count < k + 1:\\n\\t\\t    x = next_digit_in_num()\\n\\t\\t    data.push(x)\\n\\t\\twhile data.count > k + 1:\\n\\t\\t    data.pop()\\n\\t\\t# data.get_min_position() is the number of swaps to move the minimum digit to\\n\\t\\t# the desired position (output[i])\\n\\t\\tk -= data.get_min_position()\\n\\t\\t# Find the minimum number in data\\n\\t\\tx = data.pop_min()\\n\\t\\t# x is the i-th digit of output\\n\\t\\toutput += x\\n\\treturn output\\n```\\n\\nBy `next_digit_in_num()`, we mean to find the first digit in `num` which is neither in `output` nor `data`.\\n\\n# Achieving O(n)\\n\\nThe remaining question is how to implement `D` efficiently. It\\'s easier to explain with an example. Suppose in some iteration `data` contains `[1, 0, 2, 1, 0]`. We store 2 attributes for each element `x` in `data`:\\n* `x.index`: The index of `x` in the input string `num`.\\n* `x.moves`: The number of elements preceding `x` in `data` that are **greater than** `x`. It will become clear later why this is called *moves*.\\n\\nSince there are only 10 possible digits (`0` to `9`), we can store these elements in 10 lists, one per digit:\\n```py\\n# The tuples stand for (index, moves)\\ndigits[0] = [(1, 1), (4, 3)]\\ndigits[1] = [(0, 0), (3, 1)]\\ndigits[2] = [(2, 0)]\\n...\\n```\\n\\nThis way, all the 4 operations of `D` can be done in `O(1)` time.\\n1. `push(x)`: To calculate `x.moves`, we only need to count the total number of elements in `digits[x+1]`, ..., `digits[9]`. Then, simply append `x` as well as its index to `digits[x]`.\\n2. `pop()`: Compare the last element of `digits[x]` for `x in range(10)` and pop the one with minimum index.\\n3. `pop_min()`: Find the minimum `x` with non-empty `digits[x]` and remove the first element of `digits[x]`. **Note that we don\\'t need to update any `moves` attributes of the remaining elements in `data`**, because all the elements after `x` should be greater than or equal to `x`.\\n4. `get_min_position()`: Find the minimum `x` with non-empty `digits[x]`, and return `x.moves`. **`x.moves` will be exactly its position in the sequence** because all the elements preceding `x` should be greater than `x`. In other words, `x.moves` is the **number of moves** required to swap `x` all the way to the front of the sequence.\\n\\n# Complete code\\n\\n```py\\nfrom collections import deque, namedtuple\\n\\nDigit = namedtuple(\\'Digit\\', [\\'index\\', \\'moves\\'])\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        remain_num = [(i, ord(x) - ord(\\'0\\')) for i, x in enumerate(num)][::-1]\\n        digits = [deque() for _ in range(10)]\\n        count = 0   # Number of elements in digits\\n        output = []\\n        for _ in range(n):\\n            # Ensure digits has (k + 1) elements (unless insufficient)\\n            while remain_num and count < k + 1:\\n                index, x = remain_num.pop()\\n                # moves: Number of elements before x that are greater than x\\n                moves = sum(map(len, digits[x+1:]))    \\n                digits[x].append(Digit(index, moves))\\n                count += 1\\n            while count > k + 1:\\n                # Find digit with maximum index\\n                d = max((digit[-1], i) for i, digit in enumerate(digits) if digit)[1]\\n                x = digits[d].pop()\\n                remain_num.append((x.index, d))\\n                count -= 1\\n            # Find the minimum element in the list\\n            d = min(i for i, digit in enumerate(digits) if digit)\\n            x = digits[d].popleft()\\n            count -= 1\\n            k -= x.moves\\n            output.append(d)\\n        return \\'\\'.join(chr(ord(\\'0\\') + d) for d in output)\\n```\\n\\n# Analysis of time complexity\\n\\nLet `r1[i]` and `r2[i]` be the number of iterations of the first and second while loop, in the `i`-th iteration of the for loop. We will show that `sum(r1) + sum(r2) = O(n)`, where `n` is the length of the input string `num`.\\n\\nIn the first iteration of the for loop (`i = 0`), since `k >= 1`, `r1[0] = k + 1` and `r2[0] = 0`.\\n\\nTo find the upper bound of `r1[i]` and `r2[i]` for `i > 0`, we need to define some terms first. Let `T0[i]` be the moment right before entering the `i`-th iteration of the for loop, and `T1[i]` be the moment at the end of the `i`-th iteration. We use `k[i]` to denote the value of `k` in the code at `T0[i]`, and similarly `count[i]` for the value of `count` at `T0[i]`.\\n\\nNow assume `i > 0`. Observe that if `count[i] <= k[i] - 1`, then `count` must be no greater than `k` *right before `digits[d].popleft()` is called in the previous iteration*, which means that `remain_num` must be empty in previous iteration, and hence in `T0[i]`. This observation shows that we either have `count[i] >= k[i]` or `remain_num` is empty in `T0[i]`, which proves that `r1[i] <= 1` for all `i > 0`. Therefore, `sum(r1) <= n`.\\n\\nIn `T1[i-1]`, it\\'s clear that `count <= k` (because of the `count -= 1`), which is equivalent to `count[i] <= k[i-1]`. As a result,\\n```py\\n(*)  r2[i] <= count - (k[i] + 1)\\n           <= k[i-1] - (k[i] + 1)\\n```\\n\\nNow we claim that `sum(r2) <= 2n`. Let `j` be the minimum `i` with `k[i] < n - 1`. If such `i` doesn\\'t exist, then `r2[i] = 0` for all `i > 0` (because `count` is always at most `n`) and we\\'re done. Otherwise, by `(*)`,\\n```py\\nsum(r2[j+1:n]) <= k[j] - k[n-1] - 1 <= k[j] <= n\\n```\\nCombining all the results,\\n```py\\nsum(r2) = r2[0] + sum(r2[0:j]) + r2[j] + sum(r2[j+1:n])\\n        = r2[j] + sum(r2[j+1:n])\\n        <= n + n\\n```\\nwhich proves the claim.",
                "solutionTags": [],
                "code": "```py\\ndef minInteger(self, num: str, k: int) -> str:\\n    data = D()   # Empty sequence\\n    output = \\'\\'  # Output string\\n    for i in range(len(num)):\\n\\t    # Make sure data contains the (k + 1) digits of interest\\n\\t    while data.count < k + 1:\\n\\t\\t    x = next_digit_in_num()\\n\\t\\t    data.push(x)\\n\\t\\twhile data.count > k + 1:\\n\\t\\t    data.pop()\\n\\t\\t# data.get_min_position() is the number of swaps to move the minimum digit to\\n\\t\\t# the desired position (output[i])\\n\\t\\tk -= data.get_min_position()\\n\\t\\t# Find the minimum number in data\\n\\t\\tx = data.pop_min()\\n\\t\\t# x is the i-th digit of output\\n\\t\\toutput += x\\n\\treturn output\\n```\n```py\\n# The tuples stand for (index, moves)\\ndigits[0] = [(1, 1), (4, 3)]\\ndigits[1] = [(0, 0), (3, 1)]\\ndigits[2] = [(2, 0)]\\n...\\n```\n```py\\nfrom collections import deque, namedtuple\\n\\nDigit = namedtuple(\\'Digit\\', [\\'index\\', \\'moves\\'])\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        remain_num = [(i, ord(x) - ord(\\'0\\')) for i, x in enumerate(num)][::-1]\\n        digits = [deque() for _ in range(10)]\\n        count = 0   # Number of elements in digits\\n        output = []\\n        for _ in range(n):\\n            # Ensure digits has (k + 1) elements (unless insufficient)\\n            while remain_num and count < k + 1:\\n                index, x = remain_num.pop()\\n                # moves: Number of elements before x that are greater than x\\n                moves = sum(map(len, digits[x+1:]))    \\n                digits[x].append(Digit(index, moves))\\n                count += 1\\n            while count > k + 1:\\n                # Find digit with maximum index\\n                d = max((digit[-1], i) for i, digit in enumerate(digits) if digit)[1]\\n                x = digits[d].pop()\\n                remain_num.append((x.index, d))\\n                count -= 1\\n            # Find the minimum element in the list\\n            d = min(i for i, digit in enumerate(digits) if digit)\\n            x = digits[d].popleft()\\n            count -= 1\\n            k -= x.moves\\n            output.append(d)\\n        return \\'\\'.join(chr(ord(\\'0\\') + d) for d in output)\\n```\n```py\\n(*)  r2[i] <= count - (k[i] + 1)\\n           <= k[i-1] - (k[i] + 1)\\n```\n```py\\nsum(r2[j+1:n]) <= k[j] - k[n-1] - 1 <= k[j] <= n\\n```\n```py\\nsum(r2) = r2[0] + sum(r2[0:j]) + r2[j] + sum(r2[j+1:n])\\n        = r2[j] + sum(r2[j+1:n])\\n        <= n + n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720783,
                "title": "java-o-n-2-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        int[] nums = new int[n];\\n        for(int i = 0; i < n; i++) nums[i] = Character.getNumericValue(num.charAt(i));\\n        helper(nums, k);\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < n; i++) {\\n            sb.append(nums[i] + \"\");\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private void helper(int[] nums, int k) {\\n        int n = nums.length;\\n        for(int i = 0; i < n && k > 0; i++) {\\n            int index = i;\\n            for(int j = i + 1; j < n; j++) {\\n                if(k < j - i) break;\\n                if(nums[j] < nums[index]) {\\n                    index = j;\\n                }\\n            }\\n            for(int j = index; j > i; j--) {\\n                swap(nums, j, j - 1);\\n            }\\n            k -= (index - i);\\n        }\\n    }\\n    \\n    private void swap(int[] arr, int a, int b) {\\n        int tmp = arr[a];\\n        arr[a] = arr[b];\\n        arr[b] = tmp;\\n    }\\n}\\n```\\n\\nThe essence lies within the helper function. The idea is to get the smallest digit to the front as best as it could (withing k_curr steps).",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        int[] nums = new int[n];\\n        for(int i = 0; i < n; i++) nums[i] = Character.getNumericValue(num.charAt(i));\\n        helper(nums, k);\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < n; i++) {\\n            sb.append(nums[i] + \"\");\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private void helper(int[] nums, int k) {\\n        int n = nums.length;\\n        for(int i = 0; i < n && k > 0; i++) {\\n            int index = i;\\n            for(int j = i + 1; j < n; j++) {\\n                if(k < j - i) break;\\n                if(nums[j] < nums[index]) {\\n                    index = j;\\n                }\\n            }\\n            for(int j = index; j > i; j--) {\\n                swap(nums, j, j - 1);\\n            }\\n            k -= (index - i);\\n        }\\n    }\\n    \\n    private void swap(int[] arr, int a, int b) {\\n        int tmp = arr[a];\\n        arr[a] = arr[b];\\n        arr[b] = tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720572,
                "title": "c-o-nlogn-solution-using-segment-tree",
                "content": "I applied the greedy approach where I will move the smallest possible digit to the leftmost unfixed position. Instead of updating all the ununsed indices to the left, I used a segement tree to find the number of digits on the right side of each digit which crossed over the current digit and go left. This brought down the complexity to O(nlogn).\\n    \\n    void update_seg_tree(vector<int>& seg_tree,int idx,int sidx,int ssrt, int send)\\n    {\\n        if(idx<ssrt or idx>send)    return;\\n        \\n        if(ssrt==send)\\n        {\\n            seg_tree[sidx]=1;\\n            return;\\n        }\\n        \\n        int smid=(ssrt+send)/2;\\n        update_seg_tree(seg_tree,idx,2*sidx+1,ssrt,smid);\\n        update_seg_tree(seg_tree,idx,2*sidx+2,smid+1,send);\\n        \\n        seg_tree[sidx]=seg_tree[2*sidx+1]+seg_tree[2*sidx+2];\\n    }\\n    \\n    int calcte_seg_tree(vector<int>& seg_tree,int srt,int end,int sidx,int ssrt, int send)\\n    {\\n        if(end<ssrt or srt>send)        return 0;\\n        \\n        if(ssrt>=srt and send<=end)     return seg_tree[sidx];\\n        \\n        int smid=(ssrt+send)/2;\\n        int left = calcte_seg_tree(seg_tree,srt,end,2*sidx+1,ssrt,smid);\\n        int rigt = calcte_seg_tree(seg_tree,srt,end,2*sidx+2,smid+1,send);\\n        \\n        return left+rigt;\\n    }\\n    \\npublic:\\n    string minInteger(string num, int k) {\\n        \\n        int n = num.size();\\n        \\n        //Calculating the height of the segment tree(starting from 0)\\n        int height=0;\\n        \\n        int p=n-1;\\n        while(p)\\n        {\\n            p/=2;\\n            height++;\\n        }\\n        \\n        //For a tree of height h, the total number of nodes till height h is 2*(2^h)-1\\n        vector<int> seg_tree(2*(1<<height)-1,0);\\n        \\n        list<int> lst[10];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            lst[num[i]-\\'0\\'].push_back(i);\\n        }\\n        \\n        string ans;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int digit=-1;\\n            int kminus=0;\\n            for(int j=0;j<10;j++)\\n            {\\n                if(!lst[j].empty())\\n                {\\n                    int pos=lst[j].front();\\n                    int right_shift=calcte_seg_tree(seg_tree,pos,n-1,0,0,n-1);\\n                    \\n                    if(pos+right_shift-i<=k)\\n                    {\\n                        kminus=pos+right_shift-i;\\n                        digit=j;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            ans.push_back(\\'0\\'+digit);\\n            \\n            update_seg_tree(seg_tree,lst[digit].front(),0,0,n-1);\\n            \\n            k-=kminus;\\n            \\n            lst[digit].pop_front();\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "I applied the greedy approach where I will move the smallest possible digit to the leftmost unfixed position. Instead of updating all the ununsed indices to the left, I used a segement tree to find the number of digits on the right side of each digit which crossed over the current digit and go left. This brought down the complexity to O(nlogn).\\n    \\n    void update_seg_tree(vector<int>& seg_tree,int idx,int sidx,int ssrt, int send)\\n    {\\n        if(idx<ssrt or idx>send)    return;\\n        \\n        if(ssrt==send)\\n        {\\n            seg_tree[sidx]=1;\\n            return;\\n        }\\n        \\n        int smid=(ssrt+send)/2;\\n        update_seg_tree(seg_tree,idx,2*sidx+1,ssrt,smid);\\n        update_seg_tree(seg_tree,idx,2*sidx+2,smid+1,send);\\n        \\n        seg_tree[sidx]=seg_tree[2*sidx+1]+seg_tree[2*sidx+2];\\n    }\\n    \\n    int calcte_seg_tree(vector<int>& seg_tree,int srt,int end,int sidx,int ssrt, int send)\\n    {\\n        if(end<ssrt or srt>send)        return 0;\\n        \\n        if(ssrt>=srt and send<=end)     return seg_tree[sidx];\\n        \\n        int smid=(ssrt+send)/2;\\n        int left = calcte_seg_tree(seg_tree,srt,end,2*sidx+1,ssrt,smid);\\n        int rigt = calcte_seg_tree(seg_tree,srt,end,2*sidx+2,smid+1,send);\\n        \\n        return left+rigt;\\n    }\\n    \\npublic:\\n    string minInteger(string num, int k) {\\n        \\n        int n = num.size();\\n        \\n        //Calculating the height of the segment tree(starting from 0)\\n        int height=0;\\n        \\n        int p=n-1;\\n        while(p)\\n        {\\n            p/=2;\\n            height++;\\n        }\\n        \\n        //For a tree of height h, the total number of nodes till height h is 2*(2^h)-1\\n        vector<int> seg_tree(2*(1<<height)-1,0);\\n        \\n        list<int> lst[10];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            lst[num[i]-\\'0\\'].push_back(i);\\n        }\\n        \\n        string ans;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int digit=-1;\\n            int kminus=0;\\n            for(int j=0;j<10;j++)\\n            {\\n                if(!lst[j].empty())\\n                {\\n                    int pos=lst[j].front();\\n                    int right_shift=calcte_seg_tree(seg_tree,pos,n-1,0,0,n-1);\\n                    \\n                    if(pos+right_shift-i<=k)\\n                    {\\n                        kminus=pos+right_shift-i;\\n                        digit=j;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            ans.push_back(\\'0\\'+digit);\\n            \\n            update_seg_tree(seg_tree,lst[digit].front(),0,0,n-1);\\n            \\n            k-=kminus;\\n            \\n            lst[digit].pop_front();\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 720157,
                "title": "javascript-specific-bubble-sorting-problem-with-limited-steps-k",
                "content": "```\\n/**\\n * @param {string} num\\n * @param {number} k\\n * @return {string}\\n \\n Idea is based on bubble sorting with limited steps k\\n \\n */\\n\\nvar minInteger = function(num, k) {\\n    if (num.length == 1)\\n        return num;\\n    \\n    let nums = num.split(\\'\\');\\n    let i = 0, j = 0;\\n    \\n    while (k && i < num.length-1) {\\n//         step 0: if leading zero, check the next digit\\n        if (nums[i] == \\'0\\') {\\n            i++;\\n            j++;\\n            continue;\\n        }\\n        \\n//         step 1: find the min digit \\n        let p = j, steps = 0;\\n        while (nums[p] !== \\'0\\' && j < nums.length && steps <= k) {\\n            if (nums[j] < nums[p])\\n                p = j;\\n            j++;\\n            steps++;\\n        }\\n        \\n//         step 2: nums[i] is the current minimum digit --> check next digit\\n        if (p == i) {\\n            i++;\\n            j = i;\\n            continue;\\n        }\\n            \\n//          step 3: move the min digit to i\\n        for (; p > i; p--) {\\n            [nums[p], nums[p-1]] = [nums[p-1], nums[p]];\\n            k--;\\n        }\\n        \\n        i++;\\n        j = i;\\n        \\n    }\\n    \\n    return nums.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @param {number} k\\n * @return {string}\\n \\n Idea is based on bubble sorting with limited steps k\\n \\n */\\n\\nvar minInteger = function(num, k) {\\n    if (num.length == 1)\\n        return num;\\n    \\n    let nums = num.split(\\'\\');\\n    let i = 0, j = 0;\\n    \\n    while (k && i < num.length-1) {\\n//         step 0: if leading zero, check the next digit\\n        if (nums[i] == \\'0\\') {\\n            i++;\\n            j++;\\n            continue;\\n        }\\n        \\n//         step 1: find the min digit \\n        let p = j, steps = 0;\\n        while (nums[p] !== \\'0\\' && j < nums.length && steps <= k) {\\n            if (nums[j] < nums[p])\\n                p = j;\\n            j++;\\n            steps++;\\n        }\\n        \\n//         step 2: nums[i] is the current minimum digit --> check next digit\\n        if (p == i) {\\n            i++;\\n            j = i;\\n            continue;\\n        }\\n            \\n//          step 3: move the min digit to i\\n        for (; p > i; p--) {\\n            [nums[p], nums[p-1]] = [nums[p-1], nums[p]];\\n            k--;\\n        }\\n        \\n        i++;\\n        j = i;\\n        \\n    }\\n    \\n    return nums.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 720149,
                "title": "concise-javascript-solution",
                "content": "```\\nvar minInteger = function(num, k) {\\n    var arr = num.split(\"\");\\n    var n = arr.length;\\n\\t\\tfor (var i = 0; i < n-1 && k > 0; ++i) \\n        {\\n            var pos = i; \\n            for (var j = i+1; j < n ; ++j) \\n            {\\n                if (j - i > k) \\n                    break; \\n       \\n                if (arr[j] < arr[pos]) \\n                    pos = j; \\n            }\\n            var temp;\\n            for (var j = pos; j>i; --j) \\n            { \\n                temp=arr[j]; \\n                arr[j]=arr[j-1]; \\n                arr[j-1]=temp; \\n            }\\n            k -= pos-i; \\n        }\\n    return arr.join(\"\");\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minInteger = function(num, k) {\\n    var arr = num.split(\"\");\\n    var n = arr.length;\\n\\t\\tfor (var i = 0; i < n-1 && k > 0; ++i) \\n        {\\n            var pos = i; \\n            for (var j = i+1; j < n ; ++j) \\n            {\\n                if (j - i > k) \\n                    break; \\n       \\n                if (arr[j] < arr[pos]) \\n                    pos = j; \\n            }\\n            var temp;\\n            for (var j = pos; j>i; --j) \\n            { \\n                temp=arr[j]; \\n                arr[j]=arr[j-1]; \\n                arr[j-1]=temp; \\n            }\\n            k -= pos-i; \\n        }\\n    return arr.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3871251,
                "title": "easy-cpp-sliding-window",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string minInteger(string a, int k) {\\n        int n=a.length();\\n        int req=(n+1)*n/2;       // upper limit for the number of swaps that is also less than 10^9 lowering our time complexity\\n        if(k>req){                    // that means we can try all swaps so returning minimum of all these by sorting \\n            sort(a.begin(),a.end());   \\n            return a;\\n        }\\n        for(int i=0;i<n-1 && k>0;i++){\\n            //iterate in a window of size k \\n            int pos=i;\\n            int j;\\n            for(j=i+1;j<n;j++){\\n                //out of window bound\\n                if(j-i>k){break;}\\n                //else if we actually wanna swap, we do\\n                if(a[j]<a[pos]){pos=j;}\\n            }\\n            //now assuming we swapped we have pos=j\\n            char temp;\\n            for(j=pos;j>i;j--){\\n                //we are swapping a[j] and a[j-1] finally we will have a[pos] swapped with a[i]\\n                temp=a[j];\\n                a[j]=a[j-1];\\n                a[j-1]=temp;\\n            }\\n            //now update k value and do over if we wanna change the second most significant element to\\n            k-=pos-i;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minInteger(string a, int k) {\\n        int n=a.length();\\n        int req=(n+1)*n/2;       // upper limit for the number of swaps that is also less than 10^9 lowering our time complexity\\n        if(k>req){                    // that means we can try all swaps so returning minimum of all these by sorting \\n            sort(a.begin(),a.end());   \\n            return a;\\n        }\\n        for(int i=0;i<n-1 && k>0;i++){\\n            //iterate in a window of size k \\n            int pos=i;\\n            int j;\\n            for(j=i+1;j<n;j++){\\n                //out of window bound\\n                if(j-i>k){break;}\\n                //else if we actually wanna swap, we do\\n                if(a[j]<a[pos]){pos=j;}\\n            }\\n            //now assuming we swapped we have pos=j\\n            char temp;\\n            for(j=pos;j>i;j--){\\n                //we are swapping a[j] and a[j-1] finally we will have a[pos] swapped with a[i]\\n                temp=a[j];\\n                a[j]=a[j-1];\\n                a[j-1]=temp;\\n            }\\n            //now update k value and do over if we wanna change the second most significant element to\\n            k-=pos-i;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398914,
                "title": "segment-tree-and-queue",
                "content": "\\tclass SegmentTree {\\n\\t\\tpublic:\\n\\t\\tvector<int> arr;\\n\\t\\tint n;\\n\\t\\tSegmentTree(int n) {\\n\\t\\t\\tthis->n=n;\\n\\t\\t\\tarr = vector<int>(4*n);\\n\\t\\t}\\n\\t\\tvoid add(int i) {\\n\\t\\t\\taddUtil(0,n-1,i,0);\\n\\t\\t}\\n\\n\\t\\tint addUtil(int l, int r, int ind, int node) {\\n\\t\\t\\tif(l == r && l == ind){\\n\\t\\t\\t\\tarr[node]++;\\n\\t\\t\\t\\treturn arr[node];\\n\\t\\t\\t}\\n\\t\\t\\tif(ind < l || ind > r)\\n\\t\\t\\t\\treturn arr[node];\\n\\t\\t\\tint m = l + (r-l)/2;\\n\\t\\t\\tint le = addUtil(l,m,ind,2*node+1);\\n\\t\\t\\tint ri = addUtil(m+1,r,ind,2*node+2);\\n\\t\\t\\tarr[node] = le+ri;\\n\\t\\t\\treturn arr[node];\\n\\t\\t}\\n\\n\\t\\tint getSum(int ql, int qr, int l, int r, int node) {\\n\\t\\t\\tif(l >= ql && r <= qr)\\n\\t\\t\\t\\treturn arr[node];\\n\\t\\t\\tif(r < ql || l > qr)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\tint m = l + (r-l)/2;\\n\\t\\t\\treturn arr[node] = getSum(ql,qr,l,m,2*node+1) + getSum(ql,qr,m+1,r,2*node+2);\\n\\t\\t}\\n\\t};\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring minInteger(string num, int k) {\\n\\t\\t\\tint n = num.size();\\n\\t\\t\\tvector<queue<int>> arr(10);\\n\\t\\t\\tSegmentTree *tree = new SegmentTree(n);\\n\\n\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\t\\t\\t\\tarr[num[i]-\\'0\\'].push(i);\\n\\t\\t\\t}\\n\\n\\t\\t\\tstring ans;\\n\\t\\t\\tfor(int i = 0; i < num.size(); i++) {\\n\\t\\t\\t\\tfor(int digit = 0; digit <= 9; digit++) {\\n\\t\\t\\t\\t\\tif(arr[digit].size() != 0) {\\n\\t\\t\\t\\t\\t\\tint pos = arr[digit].front();\\n\\t\\t\\t\\t\\t\\tint shift = tree->getSum(0,pos,0,n,0);\\n\\t\\t\\t\\t\\t\\tif(pos-shift <= k) {\\n\\t\\t\\t\\t\\t\\t\\tk -= pos-shift;\\n\\t\\t\\t\\t\\t\\t\\ttree->add(pos);\\n\\t\\t\\t\\t\\t\\t\\tarr[digit].pop();\\n\\t\\t\\t\\t\\t\\t\\tans.push_back(digit+\\'0\\');\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring minInteger(string num, int k) {\\n\\t\\t\\tint n = num.size();\\n\\t\\t\\tvector<queue<int>> arr(10);\\n\\t\\t\\tSegmentTree *tree = new SegmentTree(n);\\n\\n\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\t\\t\\t\\tarr[num[i]-\\'0\\'].push(i);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1639812,
                "title": "c-time-o-n-space-o-n",
                "content": "// The solution is base on:\\n// 1) position queue for each digit\\n// 2) The entries that removed before the first psition for each digit\\n// 3) The next digit to add to the return string is the lowest digit which the position minus removed entries not greater than k;\\n// 4) Update return string; ( time n)\\n// 5) Update removed entries for each digit; (time 10xn)\\n// 6) calculate the removed entries for the entry that moved to queue front (for the digit that added to return string); (time nx10)\\n//  Return to (3)\\n// Time complexity ~n*22 which is O(n)\\n```\\ntemplate <class T>\\nclass simple_queue    \\n{\\n    int out_ix;\\n    vector<T> q;\\npublic:\\n    simple_queue() : out_ix(0) {}\\n    ~simple_queue()  { /* delete [] q;*/ }\\n    void push(T t)   { q.push_back(t);  }\\n    T    pop(void)   { return q[out_ix++]; }\\n    T    front(void) { return q[out_ix]; }\\n    bool empty(void) { return (out_ix == q.size());}\\n};\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.length();\\n        string ans(n,\\'-\\');\\n        ans[n] = \\'\\\\0\\';\\n        int i = 0;\\n        int first = 0;\\n        int start = 0;\\n        bool found = true;\\n        vector<simple_queue<int>> pos(10);\\n        vector<int> first_pos_sub(10,0);\\n\\n        for(int j=0; j<n; j++)\\n            pos[num[j]-\\'0\\'].push(j);\\n        \\n        while (found == true && i<n)\\n        {\\n            found = false;\\n            while(first<=9 && pos[first].empty())  first++;  \\n            for (int d = first; d<=9 && !found; d++)\\n            {\\n                while (!pos[d].empty() && pos[d].front()  - first_pos_sub[d]  <= k)\\n                {\\n                    // cout << d << \", \" << k << \", \" << pos[d].front()- first_pos_sub[d] << endl;\\n                    found = true;\\n                    int p = pos[d].pop();\\n                    k -= (p -first_pos_sub[d]);\\n                    ans[i++] = \\'0\\'+d;\\n                    for (int d1 = first; d1<=9; d1++)\\n                    {\\n                        if (!pos[d1].empty() && pos[d1].front() > p) first_pos_sub[d1]++;\\n                    }\\n                    num[p] = \\'-\\';\\n                    if (!pos[d].empty())\\n                    {\\n                        for (int j=p+1; j<pos[d].front(); j++)\\n                        {\\n                            if (num[j] == \\'-\\') first_pos_sub[d]++;\\n                        }\\n                    }\\n\\n                    if (d != first) break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntemplate <class T>\\nclass simple_queue    \\n{\\n    int out_ix;\\n    vector<T> q;\\npublic:\\n    simple_queue() : out_ix(0) {}\\n    ~simple_queue()  { /* delete [] q;*/ }\\n    void push(T t)   { q.push_back(t);  }\\n    T    pop(void)   { return q[out_ix++]; }\\n    T    front(void) { return q[out_ix]; }\\n    bool empty(void) { return (out_ix == q.size());}\\n};\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.length();\\n        string ans(n,\\'-\\');\\n        ans[n] = \\'\\\\0\\';\\n        int i = 0;\\n        int first = 0;\\n        int start = 0;\\n        bool found = true;\\n        vector<simple_queue<int>> pos(10);\\n        vector<int> first_pos_sub(10,0);\\n\\n        for(int j=0; j<n; j++)\\n            pos[num[j]-\\'0\\'].push(j);\\n        \\n        while (found == true && i<n)\\n        {\\n            found = false;\\n            while(first<=9 && pos[first].empty())  first++;  \\n            for (int d = first; d<=9 && !found; d++)\\n            {\\n                while (!pos[d].empty() && pos[d].front()  - first_pos_sub[d]  <= k)\\n                {\\n                    // cout << d << \", \" << k << \", \" << pos[d].front()- first_pos_sub[d] << endl;\\n                    found = true;\\n                    int p = pos[d].pop();\\n                    k -= (p -first_pos_sub[d]);\\n                    ans[i++] = \\'0\\'+d;\\n                    for (int d1 = first; d1<=9; d1++)\\n                    {\\n                        if (!pos[d1].empty() && pos[d1].front() > p) first_pos_sub[d1]++;\\n                    }\\n                    num[p] = \\'-\\';\\n                    if (!pos[d].empty())\\n                    {\\n                        for (int j=p+1; j<pos[d].front(); j++)\\n                        {\\n                            if (num[j] == \\'-\\') first_pos_sub[d]++;\\n                        }\\n                    }\\n\\n                    if (d != first) break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 815261,
                "title": "java-super-easy-insertion-sort-o-n-2-w-explanation",
                "content": "In the window of length k, the optimal solution is when the smallest integer in the window is occupying the MSB. So, for each position, find the minimum element in that window, perform the swaps and update the MSB.\\n```\\npublic String minInteger(String num, int k) \\n{\\n\\tchar[] arr=num.toCharArray();\\n\\tint n=arr.length;\\n\\tfor(int i=0;i<n;++i)\\n\\t{\\n\\t\\tint pos=i;\\n\\t\\tfor(int j=i+1;j<n&&j<=i+k;++j)\\n\\t\\t\\tif(arr[pos]>arr[j])\\n\\t\\t\\t\\tpos=j;\\n\\t\\tchar temp=arr[pos];\\n\\t\\twhile(pos!=i)// the swaps are being performed.\\n\\t\\t{\\n\\t\\t\\tarr[pos]=arr[pos-1];\\n\\t\\t\\t--k;\\n\\t\\t\\t--pos;\\n\\t\\t}\\n\\t\\tarr[pos]=temp;\\n\\t}\\n\\treturn new String(arr);\\n}\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String minInteger(String num, int k) \\n{\\n\\tchar[] arr=num.toCharArray();\\n\\tint n=arr.length;\\n\\tfor(int i=0;i<n;++i)\\n\\t{\\n\\t\\tint pos=i;\\n\\t\\tfor(int j=i+1;j<n&&j<=i+k;++j)\\n\\t\\t\\tif(arr[pos]>arr[j])\\n\\t\\t\\t\\tpos=j;\\n\\t\\tchar temp=arr[pos];\\n\\t\\twhile(pos!=i)// the swaps are being performed.\\n\\t\\t{\\n\\t\\t\\tarr[pos]=arr[pos-1];\\n\\t\\t\\t--k;\\n\\t\\t\\t--pos;\\n\\t\\t}\\n\\t\\tarr[pos]=temp;\\n\\t}\\n\\treturn new String(arr);\\n}\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 732932,
                "title": "python-detailed-comments-with-explanation-using-bsearch-only",
                "content": "The `O(N*logN)` solution requires a bit of leap of faith and view the problem from a different angle. I\\'ve also left in my first attempt that TLEs which would give some motivation to the `O(N*logN)`\\nsolution.\\n\\nThe key to understanding the solution is viewing it as a selection problem instead of a swapping problem. You have n position to fill with the best digit possible, from n candidate digits. For each position i, you have n - i candidate digits to choose from such that the digit chosen must not be too far away from index i. \\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    # O(N*LogN) solution\\n    def minInteger(self, num: str, k: int) -> str:            \\n        smaller_digit_indexes = collections.defaultdict(collections.deque)\\n        A = [int(d) for d in num]\\n        for i in range(len(A)):\\n            smaller_digit_indexes[A[i]].append(i)\\n        \\n        result = \\'\\'\\n        pulled_to_front_indexes = SortedList()\\n        # This problem requires a leap of faith. Instead of thinking how we could replace\\n        # each individual digit at index i by swapping, let\\'s view it as a selecting problem\\n        # where we continously try to select the smallest digit possible, from all that are\\n        # available, and add them into a result list.\\n        n = len(A)\\n        for _ in range(n):\\n            # Given n digits that are available for selection, we\\'ve so far selected len(result)\\n            # number of digits and is now looking for the best digit to add to result. Since\\n            # we want the smallest digit possible, we go through digit 0-9 (at a constant loop cost\\n            # of 10) and stop at the first available digit.\\n            for d in range(0, 10):\\n                if len(smaller_digit_indexes[d]) == 0:\\n                    continue\\n                \\n                # Okay, we have `d` that we could potentially add to result. To build some intuition,\\n                # let\\'s forget about all the swapping business and simply imagine we\\'ve so far pulled \\n\\t\\t\\t\\t# len(result) digits out of A, each digit pulled out leaving a hole in A, and the \\n                # remaining digits in A remains in-place in their original index. And, `d`, the potential \\n                # candidate for selection is at A[j]. In other words, in each iteration of the loop\\n                # (from 0 to n - 1), we are looking to see if the first digit in those that remain in A\\n                # could be replaced by `d` at A[j]. If so, we simply pull `d` out of its position at j\\n                # and place it into `result`.\\n                j = smaller_digit_indexes[d][0]\\n                \\n                # Now the question is, could we possibly choose `d` at its original index j given the\\n                # constraint that we cannot touch digits that are more than k digits away? (Here k\\n                # digits away means number of digits between some start and some end, inclusive, minus 1)\\n                # Well we could if the number of digits from `d` at the j original index j, to the \\n                # first digit remaining in A that we\\'ve not yet pulled out (and put into `result`) is <= k.\\n                # Why? Because if you were to do the swapping process step by step, you\\'ll notice that\\n                # other than digits we\\'ve pulled and put into `result`, the remaining digits\\n                # in A have remained in the same relative order, except for the holes. We only need to\\n                # deduct for the holes they are between the first digit of A and j, to arrive at the \\n                # true distance\\n                nb_moved_to_front = pulled_to_front_indexes.bisect_right(j)\\n                dist = j - nb_moved_to_front\\n                if dist == 0 or dist <= k:\\n                    # dist == 0 means `d` happens to be the first digit remaining in A\\n                    result += str(d)\\n                    pulled_to_front_indexes.add(j)\\n                    smaller_digit_indexes[d].popleft()\\n                    k -= dist\\n                    break\\n\\n        return result\\n\\n    # First O(N^2) attempt that will LTE\\n    def minInteger2(self, num: str, k: int) -> str:\\n        def bubble_up(A, i, j):\\n            t = A[j]\\n            for x in range(j, i, -1):\\n                A[x] = A[x - 1]\\n            A[i] = t\\n                \\n            \\n        A = [int(d) for d in num]\\n        \\n        i = 0\\n        while i < len(A) and k > 0:\\n            # Given A[i], let\\'s see if we can find the smallest possible A[j] such that j - i <= k.\\n            # That is, the smallest possible A[j], k-swap distance away that we could swap with A[i] \\n            # and get a smallest possible number\\n            j = i + 1\\n            min_digit_idx = None\\n            while j < len(A) and j - i <= k:\\n                if A[j] < A[i]:\\n                    if min_digit_idx is None or A[j] < A[min_digit_idx]:\\n                        min_digit_idx = j\\n                j += 1\\n            \\n            if min_digit_idx != None:\\n                bubble_up(A, i, min_digit_idx)\\n                k -= min_digit_idx - i\\n            \\n            i += 1\\n        \\n        return \\'\\'.join([str(d) for d in A])\\n```\\n",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    # O(N*LogN) solution\\n    def minInteger(self, num: str, k: int) -> str:            \\n        smaller_digit_indexes = collections.defaultdict(collections.deque)\\n        A = [int(d) for d in num]\\n        for i in range(len(A)):\\n            smaller_digit_indexes[A[i]].append(i)\\n        \\n        result = \\'\\'\\n        pulled_to_front_indexes = SortedList()\\n        # This problem requires a leap of faith. Instead of thinking how we could replace\\n        # each individual digit at index i by swapping, let\\'s view it as a selecting problem\\n        # where we continously try to select the smallest digit possible, from all that are\\n        # available, and add them into a result list.\\n        n = len(A)\\n        for _ in range(n):\\n            # Given n digits that are available for selection, we\\'ve so far selected len(result)\\n            # number of digits and is now looking for the best digit to add to result. Since\\n            # we want the smallest digit possible, we go through digit 0-9 (at a constant loop cost\\n            # of 10) and stop at the first available digit.\\n            for d in range(0, 10):\\n                if len(smaller_digit_indexes[d]) == 0:\\n                    continue\\n                \\n                # Okay, we have `d` that we could potentially add to result. To build some intuition,\\n                # let\\'s forget about all the swapping business and simply imagine we\\'ve so far pulled \\n\\t\\t\\t\\t# len(result) digits out of A, each digit pulled out leaving a hole in A, and the \\n                # remaining digits in A remains in-place in their original index. And, `d`, the potential \\n                # candidate for selection is at A[j]. In other words, in each iteration of the loop\\n                # (from 0 to n - 1), we are looking to see if the first digit in those that remain in A\\n                # could be replaced by `d` at A[j]. If so, we simply pull `d` out of its position at j\\n                # and place it into `result`.\\n                j = smaller_digit_indexes[d][0]\\n                \\n                # Now the question is, could we possibly choose `d` at its original index j given the\\n                # constraint that we cannot touch digits that are more than k digits away? (Here k\\n                # digits away means number of digits between some start and some end, inclusive, minus 1)\\n                # Well we could if the number of digits from `d` at the j original index j, to the \\n                # first digit remaining in A that we\\'ve not yet pulled out (and put into `result`) is <= k.\\n                # Why? Because if you were to do the swapping process step by step, you\\'ll notice that\\n                # other than digits we\\'ve pulled and put into `result`, the remaining digits\\n                # in A have remained in the same relative order, except for the holes. We only need to\\n                # deduct for the holes they are between the first digit of A and j, to arrive at the \\n                # true distance\\n                nb_moved_to_front = pulled_to_front_indexes.bisect_right(j)\\n                dist = j - nb_moved_to_front\\n                if dist == 0 or dist <= k:\\n                    # dist == 0 means `d` happens to be the first digit remaining in A\\n                    result += str(d)\\n                    pulled_to_front_indexes.add(j)\\n                    smaller_digit_indexes[d].popleft()\\n                    k -= dist\\n                    break\\n\\n        return result\\n\\n    # First O(N^2) attempt that will LTE\\n    def minInteger2(self, num: str, k: int) -> str:\\n        def bubble_up(A, i, j):\\n            t = A[j]\\n            for x in range(j, i, -1):\\n                A[x] = A[x - 1]\\n            A[i] = t\\n                \\n            \\n        A = [int(d) for d in num]\\n        \\n        i = 0\\n        while i < len(A) and k > 0:\\n            # Given A[i], let\\'s see if we can find the smallest possible A[j] such that j - i <= k.\\n            # That is, the smallest possible A[j], k-swap distance away that we could swap with A[i] \\n            # and get a smallest possible number\\n            j = i + 1\\n            min_digit_idx = None\\n            while j < len(A) and j - i <= k:\\n                if A[j] < A[i]:\\n                    if min_digit_idx is None or A[j] < A[min_digit_idx]:\\n                        min_digit_idx = j\\n                j += 1\\n            \\n            if min_digit_idx != None:\\n                bubble_up(A, i, min_digit_idx)\\n                k -= min_digit_idx - i\\n            \\n            i += 1\\n        \\n        return \\'\\'.join([str(d) for d in A])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729917,
                "title": "python-o-n-log-n-binarysearch-solution",
                "content": "In this post I will focus on stepping through my thought process in solving this question and only post the full solution at the end. So a word of warning: **long post**. But hopefully some may find this useful :) You can also practice implementing after reading analysis instead of refering to the full solution.\\n\\n**Initial Analysis**\\n1) Understand the questions first, realize that *optimal is just the sorted array of digits given* and that greedily making permissible moves of smallest digit to the front will always be optimal. I.e. no movement of digits near the end of the number will yield as large a decrease as *decreasing the leading (leftmost) digit*.\\n2) Look for bounds, `1 <= num.length <= 30000`, and `1 <= k <= 10^9` suggests we cannot use O(k) solution and need faster than O(N^2) to AC. The bounds also give some hints to what\\'s permissible in solution, in this case, O(N\\\\*log(N)) will be ok. (And generally is the case except for very large bounds, hard to distinguish between O(N) vs O(N\\\\*log(N)) solution timings - unless you\\'re using python T.T)\\n\\n**First-pass *(horribly wrong)***\\n- Insight 1: Index of digit determines least number of swaps needed to move it to the front\\n- Insight 2: Number of digits moved before will decrease this cost proportionately (wrong)\\n- So we can do *O(N)* scan while keeping counter for number of previously moved digits?\\n- Since we need to move smaller digits first, if we have a sorted list of digits by index per digit, then doing repeated greedy scans from `0` to `9` always picking from smaller digit first will give us the order of digits to move? (also actually wrong)\\n- That\\'s not too bad, we can init queues for each digit type and push index of each digit as we encounter them by scanning through `num` once with O(N) time and space (number of digit types is constant) then pop them as we consider each digit O(1) time.\\n\\n*code, code, code, Run, Failed!* :O\\n\\n**Ofc, LC-hard, not so easy - Second Try**\\n- Does not pass first test case, seems like we are missing caveat from Insight 1&2. Not the case that number of digits previously moved discounts the next move proportionately, rather:\\n- Insight 3: Number of digits with indices smaller than current digit\\'s index will discount number of swaps to move current digit to front\\n- So we have to not only keep track of how many moves-to-front we\\'ve made but at which indices we\\'ve made them from\\n- Naive Solution:\\n  - Keep list of moved digit indices\\n  - Scan through list when computing next move feasibility (cost) and count number of smaller indices for discount\\n  - O(N) scan per digit => O(N^2) overall, TLE (oops)\\n- Have to think of better way to store and lookup number of indices smaller than current\\n  - This is the actual issue in this problem\\n\\n**Abstract the problem a bit -> Reduce to a familiar classic problem**\\n- Given a list of numbers, find how many are smaller than a given query\\n- We have a time-budget of O(log(N)) -> What algos do we know that can do this? BinarySearch\\n- Problem: BinarySearch only works when the given list of numbers are already sorted.\\n  - Time cost incurred to sort again: O(N\\\\*log(N)) => TLE\\n- **Insight 4** (what needed to click for me to solve this):\\n  - Instead of thinking of *the* (single) list of previously moved digits, we know that the order in which we move a certain type of digit (say all `0`s moved so far) have strictly increasing indices!\\n  - In other words, we already have 10 sorted lists of previously moved indices and we can just do multiple searches for each type of digit previously moved and take the sum as total \\'discount\\' for currently considered move.\\n  - If we just store a \\'taken\\' index for which index we have already taken for this digit type and increment this each time we move a digit to the front rather than using queues, we can reuse sorted arrays for each digit type with `digit[i][:taken[i]+1]` (this store indices of previously moved digits of type `i`)\\n- Time analysis:\\n  - 10\\\\*O(log(N)) ~ O(log(N)) => AC :) at least on time\\n\\n**Yay! AC?**\\n- Nope...\\n- Failed Testcase:\\n  - \"294984148179\"\\n11\\n- Output:\\n  - \"124499488179\"\\n- Expected:\\n  - \"124498948179\"\\n- Notice that in this case, our solution chose to move the third \\'4\\' rather than the first \\'8\\' ahead by 1 position\\n- Stepping through algo to debug:\\n  - We notice that after [1244]99848179, we move \\'up\\' (retain) \\'9\\' in what\\'s currently at index 5, thereafter, as per our greedy strategy, we look for more digits of type \\'9\\' to move, which is in the next position, and so we end up with [124499]848179 and then restart from \\'0\\' and end up moving \\'4\\' up one position since with `k=1` left, that is the next most optimal choice we have\\n- Insight 5 (last one, I promise): When it is impossible to move up any digit smaller than at the current index, we need to consider moving smaller digits into the next position instead and restart from \\'0\\'\\n- With this last modification, our solution will restart the greedy scan from \\'0\\' after [12449]9848179 and consider moving up \\'8\\' with the last swap instead of retaining \\'9\\' and moving \\'4\\'.\\n- But does this restart hurt our time?\\n  - Each time we choose to move a digit, we reduce the number of digits we have to look at by 1\\n  - For each choice of digit movement, we consider moving up at most 10 digits (0-9 and only if our current digit is 9) and to compute each digit\\'s cost, we do at most 10\\\\*O(log(N))\\n  - Worst case: 100\\\\*O(log(N)) per digit in given `num` string ~ O(N\\\\*log(N)) time complexity, should be ok.\\n- AC :D\\n\\nThanks for reading, hopefully stepping through my approach was helpful to some of you!\\n\\n**TL;DR:** realize we need to find how many digits we\\'ve moved prior (smaller than) current digit\\'s index in O(log(N)) time, use BinarySearch, problem: sorted array of previously moved digits\\' index? No problem, we are already picking them in sorted order for each type `0-9`, just whack with 10xBinarySearch, still asymptotically overall O(N\\\\*log(N)) solution => AC :)\\n\\n**A bit lengthly solution, but with comments and debugging output to help with understanding**\\n```python\\n# Turn on for debugging output\\nDEBUG = False\\n\\n# Generic binary search to return insertion index\\ndef binarySearch(arr, s, t, n):\\n    m = (s+t)//2\\n    if (s == t):\\n        return s\\n    if (arr[m] > n):\\n        return binarySearch(arr, s, m, n)\\n    else:\\n        return binarySearch(arr, m+1, t, n)\\n    \\nclass Solution:\\n    def __init__(self):\\n        self.digits = dict()\\n        self.taken = [-1 for i in range(10)]\\n    \\n    # Compute how much it costs to move this digit to the front\\n    def cost(self, cur):\\n        discount = 0\\n\\t\\t# Sum previously moved digits with index less than cur for each type\\n        for i in range(10):\\n            discount += binarySearch(self.digits[i], 0, self.taken[i]+1, cur)\\n\\t\\t\\t\\n            if (DEBUG):\\n                if (self.taken[i] >= 0):\\n                    print(f\"{i}: [{self.digits[i][:self.taken[i]+1]}] search:{cur} discount:{binarySearch(self.digits[i],0,self.taken[i]+1,cur)}\")\\n        return cur - discount\\n    \\n    def minInteger(self, num: str, k: int) -> str:\\n        if (DEBUG):\\n            print(f\"Testcase: [{num}] k={k}\")\\n        \\n        # Keep sorted arrays (by index) for each occurance of digits\\n        self.digits = {i:[] for i in range(10)}\\n        for i,n in enumerate(num):\\n            self.digits[int(n)].append(i)\\n        \\n        extracted = set()\\n        head = \"\" # constructed \\'front\\' of string\\n        \\n        # Terminating conditions:\\n        # 1) No more swaps left\\n        # 2) We have sorted our array\\n        while k > 0 and len(head) < len(num):\\n            i = 0\\n            # Scan each digit occurances from smalled (0) to largest (9) in order\\n            # to greedily make best permissible moves to front\\n            while i < 10:\\n                # Sanity check that we still have digits not yet moved to front\\n                while k > 0 and len(self.digits[i]) and self.taken[i]+1 < len(self.digits[i]):\\n                    # Get number of swaps to move current digit to front\\n\\t\\t\\t\\t\\tcurCost = self.cost(self.digits[i][self.taken[i]+1])\\n                    \\n                    if (DEBUG):\\n                        print(f\"move to head:{i}@{self.digits[i][self.taken[i]+1]} cost: {curCost}\")\\n                    \\n                    # If we can move this digit, move it\\n                    if (curCost <= k):\\n                        self.taken[i] += 1\\n                        k -= curCost\\n                        extracted.add(self.digits[i][self.taken[i]])\\n                        head += str(i)\\n                        \\n                        if (DEBUG):\\n                            print(f\"[{head}]\",end=\"\")\\n                            for j in range(len(num)):\\n                                if j in extracted:\\n                                    continue\\n                                print(num[j],end=\"\")\\n                            print(f\" k={k}\")\\n                    # Otherwise, no further digit of this kind could possible be moved\\n                    # since our self.digits[i] array is sorted (move onto the next digit)\\n                    else:\\n                        break\\n                    # When we move a digit \\'for free\\', we reset our search as a previously seen\\n                    # not-possible but more optimal (smaller) digit could now be moved to front\\n                    if (curCost == 0):\\n                        i = 0\\n                # remember to increment our search onto the next smallest digit\\n                i += 1\\n                \\n        # Parse and output final answer\\n        for i in range(len(num)):\\n            if i in extracted:\\n                continue\\n            head += num[i]\\n        return head\\n```",
                "solutionTags": [],
                "code": "```python\\n# Turn on for debugging output\\nDEBUG = False\\n\\n# Generic binary search to return insertion index\\ndef binarySearch(arr, s, t, n):\\n    m = (s+t)//2\\n    if (s == t):\\n        return s\\n    if (arr[m] > n):\\n        return binarySearch(arr, s, m, n)\\n    else:\\n        return binarySearch(arr, m+1, t, n)\\n    \\nclass Solution:\\n    def __init__(self):\\n        self.digits = dict()\\n        self.taken = [-1 for i in range(10)]\\n    \\n    # Compute how much it costs to move this digit to the front\\n    def cost(self, cur):\\n        discount = 0\\n\\t\\t# Sum previously moved digits with index less than cur for each type\\n        for i in range(10):\\n            discount += binarySearch(self.digits[i], 0, self.taken[i]+1, cur)\\n\\t\\t\\t\\n            if (DEBUG):\\n                if (self.taken[i] >= 0):\\n                    print(f\"{i}: [{self.digits[i][:self.taken[i]+1]}] search:{cur} discount:{binarySearch(self.digits[i],0,self.taken[i]+1,cur)}\")\\n        return cur - discount\\n    \\n    def minInteger(self, num: str, k: int) -> str:\\n        if (DEBUG):\\n            print(f\"Testcase: [{num}] k={k}\")\\n        \\n        # Keep sorted arrays (by index) for each occurance of digits\\n        self.digits = {i:[] for i in range(10)}\\n        for i,n in enumerate(num):\\n            self.digits[int(n)].append(i)\\n        \\n        extracted = set()\\n        head = \"\" # constructed \\'front\\' of string\\n        \\n        # Terminating conditions:\\n        # 1) No more swaps left\\n        # 2) We have sorted our array\\n        while k > 0 and len(head) < len(num):\\n            i = 0\\n            # Scan each digit occurances from smalled (0) to largest (9) in order\\n            # to greedily make best permissible moves to front\\n            while i < 10:\\n                # Sanity check that we still have digits not yet moved to front\\n                while k > 0 and len(self.digits[i]) and self.taken[i]+1 < len(self.digits[i]):\\n                    # Get number of swaps to move current digit to front\\n\\t\\t\\t\\t\\tcurCost = self.cost(self.digits[i][self.taken[i]+1])\\n                    \\n                    if (DEBUG):\\n                        print(f\"move to head:{i}@{self.digits[i][self.taken[i]+1]} cost: {curCost}\")\\n                    \\n                    # If we can move this digit, move it\\n                    if (curCost <= k):\\n                        self.taken[i] += 1\\n                        k -= curCost\\n                        extracted.add(self.digits[i][self.taken[i]])\\n                        head += str(i)\\n                        \\n                        if (DEBUG):\\n                            print(f\"[{head}]\",end=\"\")\\n                            for j in range(len(num)):\\n                                if j in extracted:\\n                                    continue\\n                                print(num[j],end=\"\")\\n                            print(f\" k={k}\")\\n                    # Otherwise, no further digit of this kind could possible be moved\\n                    # since our self.digits[i] array is sorted (move onto the next digit)\\n                    else:\\n                        break\\n                    # When we move a digit \\'for free\\', we reset our search as a previously seen\\n                    # not-possible but more optimal (smaller) digit could now be moved to front\\n                    if (curCost == 0):\\n                        i = 0\\n                # remember to increment our search onto the next smallest digit\\n                i += 1\\n                \\n        # Parse and output final answer\\n        for i in range(len(num)):\\n            if i in extracted:\\n                continue\\n            head += num[i]\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721206,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void helper(char *array, int k, int start, int n){\\n        if (k == 0 or start >= n) // no moves left, done modifying the string\\n            return; \\n        int min_idx = start;       // position of the closest min digit within k\\n        for(int i = start+1; i < min(n, start + k + 1); i++)\\n            if (array[i] < array[min_idx])\\n                min_idx = i;\\n\\t\\t// found a smaller digit within k steps\\n        if (min_idx > start){                       \\n            char temp = array[min_idx];      // memorize the min\\n            for(int j = min_idx; j > start; j--) //shift all digits\\n                array[j] = array[j-1];\\n            array[start] = temp;   // update the first digit\\n            k -= (min_idx - start); // reduce k\\n        }\\n        return helper(array, k, start+1, n); // go to the next digit\\n    }\\n    string minInteger(string num, int k) {\\n        int n = num.length();\\n\\t\\t// worst case digits in number in reverse sorted order, need (n-1) steps to move last to front, then (n-2) mooving new last and so on\\n\\t\\t// so we need max (n-1) + (n-2)+... + 1 = (n-1)*n/2 to sort\\n        if (k >= (n*(n-1)) / 2){ \\n            sort(num.begin(),num.end());\\n            return num;\\n        }\\n        \\n        helper(&num[0], k, 0, n); // strings in c++ already array of chars\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(char *array, int k, int start, int n){\\n        if (k == 0 or start >= n) // no moves left, done modifying the string\\n            return; \\n        int min_idx = start;       // position of the closest min digit within k\\n        for(int i = start+1; i < min(n, start + k + 1); i++)\\n            if (array[i] < array[min_idx])\\n                min_idx = i;\\n\\t\\t// found a smaller digit within k steps\\n        if (min_idx > start){                       \\n            char temp = array[min_idx];      // memorize the min\\n            for(int j = min_idx; j > start; j--) //shift all digits\\n                array[j] = array[j-1];\\n            array[start] = temp;   // update the first digit\\n            k -= (min_idx - start); // reduce k\\n        }\\n        return helper(array, k, start+1, n); // go to the next digit\\n    }\\n    string minInteger(string num, int k) {\\n        int n = num.length();\\n\\t\\t// worst case digits in number in reverse sorted order, need (n-1) steps to move last to front, then (n-2) mooving new last and so on\\n\\t\\t// so we need max (n-1) + (n-2)+... + 1 = (n-1)*n/2 to sort\\n        if (k >= (n*(n-1)) / 2){ \\n            sort(num.begin(),num.end());\\n            return num;\\n        }\\n        \\n        helper(&num[0], k, 0, n); // strings in c++ already array of chars\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720794,
                "title": "python-nlogn-fenwick-bit-solution",
                "content": "```python\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        mp = defaultdict(deque)\\n        for i,v in enumerate(num):\\n            mp[v].append(i)\\n        res = \"\"\\n        def lowbit(x):\\n            return x & (-x)\\n        def query(x):\\n            sums = 0\\n            while x:\\n                sums += arr[x]\\n                x -= lowbit(x)\\n            return sums\\n        def update(x,delta):\\n            while x <= n:\\n                arr[x] += delta\\n                x += lowbit(x)\\n\\n        arr = [0]*(n+1)\\n        for i in range(n):\\n            update(i+1,1)\\n\\n        for i in range(n):\\n            for v in \"0123456789\":\\n                if mp[v]:\\n                    idx = mp[v][0]\\n                    cnt = query(idx)\\n                    if cnt > k: continue\\n                    mp[v].popleft()\\n                    k -= cnt\\n                    res += v\\n                    update(idx+1,-1)\\n                    break\\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        mp = defaultdict(deque)\\n        for i,v in enumerate(num):\\n            mp[v].append(i)\\n        res = \"\"\\n        def lowbit(x):\\n            return x & (-x)\\n        def query(x):\\n            sums = 0\\n            while x:\\n                sums += arr[x]\\n                x -= lowbit(x)\\n            return sums\\n        def update(x,delta):\\n            while x <= n:\\n                arr[x] += delta\\n                x += lowbit(x)\\n\\n        arr = [0]*(n+1)\\n        for i in range(n):\\n            update(i+1,1)\\n\\n        for i in range(n):\\n            for v in \"0123456789\":\\n                if mp[v]:\\n                    idx = mp[v][0]\\n                    cnt = query(idx)\\n                    if cnt > k: continue\\n                    mp[v].popleft()\\n                    k -= cnt\\n                    res += v\\n                    update(idx+1,-1)\\n                    break\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720123,
                "title": "python3-brute-force",
                "content": "Algo\\nScan through the string. At each index, look for the smallest element behind it within k swaps. Upon finding such minimum, swap it to replece the current element, and reduce k to reflect the swaps. Do this for all element until k becomes 0. \\n\\n`O(N^2)` time & `O(N)` space \\n```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        if k >= n*(n-1)//2: return \"\".join(sorted(num)) #special case\\n        \\n        #find smallest elements within k swaps \\n        #and swap it to current position \\n        num = list(num)\\n        for i in range(n):\\n            if not k: break \\n            #find minimum within k swaps\\n            ii = i\\n            for j in range(i+1, min(n, i+k+1)): \\n                if num[ii] > num[j]: ii = j \\n            #swap the min to current position \\n            if ii != i: \\n                k -= ii-i\\n                for j in range(ii, i, -1):\\n                    num[j-1], num[j] = num[j], num[j-1]\\n        return \"\".join(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        if k >= n*(n-1)//2: return \"\".join(sorted(num)) #special case\\n        \\n        #find smallest elements within k swaps \\n        #and swap it to current position \\n        num = list(num)\\n        for i in range(n):\\n            if not k: break \\n            #find minimum within k swaps\\n            ii = i\\n            for j in range(i+1, min(n, i+k+1)): \\n                if num[ii] > num[j]: ii = j \\n            #swap the min to current position \\n            if ii != i: \\n                k -= ii-i\\n                for j in range(ii, i, -1):\\n                    num[j-1], num[j] = num[j], num[j-1]\\n        return \"\".join(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2688655,
                "title": "c-easy-segment-tree",
                "content": "\\n# Code\\n```\\ntypedef long long ll;\\nconst int N =30010;\\nll w[N];\\nll st[N];\\n\\nstruct Node {\\n    ll l,r;\\n    ll minv, idx, sum;\\n} tree[4*N];\\n\\nvoid push_up(Node& a, Node& b, Node & c) {\\n    if(b.minv <= c.minv) {\\n        a.minv = b.minv;\\n        a.idx = b.idx;\\n    } else {\\n        a.minv = c.minv;\\n        a.idx = c.idx;\\n    }\\n    a.sum = b.sum + c.sum;\\n}\\n\\nvoid push_up(ll u) {\\n    push_up(tree[u], tree[2*u], tree[2*u+1]);\\n}\\n\\nvoid build(ll u, ll l, ll r) {\\n    tree[u].l = l;\\n    tree[u].r = r;\\n    if(l == r) {\\n        ll b = w[l];\\n        tree[u].minv = b;\\n        tree[u].idx = l;\\n        tree[u].sum = st[l];\\n    } else {\\n        ll mid = (l + r) / 2;\\n        build(2*u, l, mid);\\n        build(2*u+1, mid+1, r);\\n        push_up(u);\\n    }\\n}\\n\\nvoid update(ll u, ll idx, ll x) {\\n    if(tree[u].l == tree[u].r) {\\n        tree[u].minv = x;\\n        tree[u].sum = 0;\\n        st[tree[u].l] = 0;\\n    } else {\\n        ll mid = (tree[u].l + tree[u].r)/2;\\n        if(idx <= mid) update(2*u, idx, x);\\n        else update(2*u+1, idx, x);\\n        push_up(u);\\n    }\\n}\\n\\nNode query(ll u, ll l, ll r) {\\n    if(tree[u].l >= l && tree[u].r <= r) {\\n        return tree[u];\\n    } else {\\n        ll mid = (tree[u].l + tree[u].r)/2;\\n        if(l > mid) {\\n            return query(2*u+1, l, r);\\n        } else if (r <= mid) {\\n            return query(2*u, l, r);\\n        } else {\\n            auto left = query(2*u, l, r);\\n            auto right = query(2*u+1, l, r);\\n            Node res;\\n            push_up(res, left, right);\\n            return res;\\n        }\\n    }\\n}\\n\\nint get_idx(int presum, int len) {\\n    int l = 1;\\n    int r = len;\\n    int res = len;\\n    while(l <= r) {\\n        int mid = (l + r) / 2;\\n        if(query(1, 1, mid).sum >= presum) {\\n            res = mid;\\n            r = mid - 1;\\n        } else {\\n            l = mid + 1;\\n        }\\n    }\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n        if(k > n*(n-1)/2) {\\n            sort(num.begin(), num.end());\\n            return num;\\n        }\\n        return solve(num, k);\\n    }\\n    void init(string & num) {\\n        int n = num.size();\\n        memset(tree, 0, sizeof tree);\\n        for(int i = 1; i <= n; i ++) w[i] = num[i-1] - \\'0\\';\\n        for(int i = 1; i <= n; i ++) st[i] = 1;\\n        build(1, 1, n);\\n    }\\n    string solve(string & num, int k) {\\n        init(num);\\n        string res;\\n        while(k) {\\n            int max_sum = min(k+1, (int)num.size());\\n            int threshold = get_idx(max_sum, num.size());\\n            Node curr = query(1, 1, threshold);\\n            if(curr.minv == 10) break;\\n            res.push_back(curr.minv + \\'0\\');\\n            update(1, curr.idx, 10);\\n            k -= query(1, 1, curr.idx).sum;\\n        }\\n        for(int i = 1; i <= num.size(); i ++) {\\n            if(st[i] == 1) {\\n                res.push_back(num[i-1]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll;\\nconst int N =30010;\\nll w[N];\\nll st[N];\\n\\nstruct Node {\\n    ll l,r;\\n    ll minv, idx, sum;\\n} tree[4*N];\\n\\nvoid push_up(Node& a, Node& b, Node & c) {\\n    if(b.minv <= c.minv) {\\n        a.minv = b.minv;\\n        a.idx = b.idx;\\n    } else {\\n        a.minv = c.minv;\\n        a.idx = c.idx;\\n    }\\n    a.sum = b.sum + c.sum;\\n}\\n\\nvoid push_up(ll u) {\\n    push_up(tree[u], tree[2*u], tree[2*u+1]);\\n}\\n\\nvoid build(ll u, ll l, ll r) {\\n    tree[u].l = l;\\n    tree[u].r = r;\\n    if(l == r) {\\n        ll b = w[l];\\n        tree[u].minv = b;\\n        tree[u].idx = l;\\n        tree[u].sum = st[l];\\n    } else {\\n        ll mid = (l + r) / 2;\\n        build(2*u, l, mid);\\n        build(2*u+1, mid+1, r);\\n        push_up(u);\\n    }\\n}\\n\\nvoid update(ll u, ll idx, ll x) {\\n    if(tree[u].l == tree[u].r) {\\n        tree[u].minv = x;\\n        tree[u].sum = 0;\\n        st[tree[u].l] = 0;\\n    } else {\\n        ll mid = (tree[u].l + tree[u].r)/2;\\n        if(idx <= mid) update(2*u, idx, x);\\n        else update(2*u+1, idx, x);\\n        push_up(u);\\n    }\\n}\\n\\nNode query(ll u, ll l, ll r) {\\n    if(tree[u].l >= l && tree[u].r <= r) {\\n        return tree[u];\\n    } else {\\n        ll mid = (tree[u].l + tree[u].r)/2;\\n        if(l > mid) {\\n            return query(2*u+1, l, r);\\n        } else if (r <= mid) {\\n            return query(2*u, l, r);\\n        } else {\\n            auto left = query(2*u, l, r);\\n            auto right = query(2*u+1, l, r);\\n            Node res;\\n            push_up(res, left, right);\\n            return res;\\n        }\\n    }\\n}\\n\\nint get_idx(int presum, int len) {\\n    int l = 1;\\n    int r = len;\\n    int res = len;\\n    while(l <= r) {\\n        int mid = (l + r) / 2;\\n        if(query(1, 1, mid).sum >= presum) {\\n            res = mid;\\n            r = mid - 1;\\n        } else {\\n            l = mid + 1;\\n        }\\n    }\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n        if(k > n*(n-1)/2) {\\n            sort(num.begin(), num.end());\\n            return num;\\n        }\\n        return solve(num, k);\\n    }\\n    void init(string & num) {\\n        int n = num.size();\\n        memset(tree, 0, sizeof tree);\\n        for(int i = 1; i <= n; i ++) w[i] = num[i-1] - \\'0\\';\\n        for(int i = 1; i <= n; i ++) st[i] = 1;\\n        build(1, 1, n);\\n    }\\n    string solve(string & num, int k) {\\n        init(num);\\n        string res;\\n        while(k) {\\n            int max_sum = min(k+1, (int)num.size());\\n            int threshold = get_idx(max_sum, num.size());\\n            Node curr = query(1, 1, threshold);\\n            if(curr.minv == 10) break;\\n            res.push_back(curr.minv + \\'0\\');\\n            update(1, curr.idx, 10);\\n            k -= query(1, 1, curr.idx).sum;\\n        }\\n        for(int i = 1; i <= num.size(); i ++) {\\n            if(st[i] == 1) {\\n                res.push_back(num[i-1]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2438941,
                "title": "java-simple-implementation-detailed-explanation",
                "content": "```\\nclass Solution {\\n    public static String minInteger(String num, int k) {\\n        char[] array = num.toCharArray(); // returns a newly allocated character array.\\n        int length = array.length;\\n        int pointer = 0; // the index replaced at most K times by the smallest possible digit\\n        while (k > 0 && pointer < length) {\\n            int minDigit = array[pointer] - \\'0\\', minIndex = pointer;\\n            int limit = Math.min(length - 1, pointer + k); // when k is too large -> pointer + k is too large, run out\\n                                                           // of range -> min(length-1, pointer+k)\\n            for (int i = pointer + 1; i <= limit; i++) {\\n                // take smallest digit from position: pointer -> limit\\n                int temp = array[i] - \\'0\\';\\n                if (temp < minDigit) {\\n                    minDigit = temp; // smallest digit\\n                    minIndex = i; // smallest digit\\'s index\\n                }\\n            }\\n            k -= (minIndex - pointer); // swapping times needed to move smallest digit to pointer position\\n            char c = array[minIndex]; // smallest digit: c (char)\\n            // move c = array[minIndex] to be array[pointer]: line 21 -> 23\\n            for (int i = minIndex - 1; i >= pointer; i--)\\n                array[i + 1] = array[i];\\n            array[pointer] = c;\\n            pointer++; // continue with next array[pointer]\\n        }\\n        return new String(array);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static String minInteger(String num, int k) {\\n        char[] array = num.toCharArray(); // returns a newly allocated character array.\\n        int length = array.length;\\n        int pointer = 0; // the index replaced at most K times by the smallest possible digit\\n        while (k > 0 && pointer < length) {\\n            int minDigit = array[pointer] - \\'0\\', minIndex = pointer;\\n            int limit = Math.min(length - 1, pointer + k); // when k is too large -> pointer + k is too large, run out\\n                                                           // of range -> min(length-1, pointer+k)\\n            for (int i = pointer + 1; i <= limit; i++) {\\n                // take smallest digit from position: pointer -> limit\\n                int temp = array[i] - \\'0\\';\\n                if (temp < minDigit) {\\n                    minDigit = temp; // smallest digit\\n                    minIndex = i; // smallest digit\\'s index\\n                }\\n            }\\n            k -= (minIndex - pointer); // swapping times needed to move smallest digit to pointer position\\n            char c = array[minIndex]; // smallest digit: c (char)\\n            // move c = array[minIndex] to be array[pointer]: line 21 -> 23\\n            for (int i = minIndex - 1; i >= pointer; i--)\\n                array[i + 1] = array[i];\\n            array[pointer] = c;\\n            pointer++; // continue with next array[pointer]\\n        }\\n        return new String(array);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1939797,
                "title": "why-test-case-has-leading-zero",
                "content": "In constraints, said that would not contain leading zeros.\\n```\\nnum consists of only digits and does not contain leading zeros.\\n```\\nHowever, when I submit my answer, show my answer is `Memory Limit Exceeded`\\nAnd I look the Input, there have leading zero in input.\\n![image](https://assets.leetcode.com/users/images/87388602-904d-4511-8b15-a17341f48c59_1649774847.1689444.png)\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nnum consists of only digits and does not contain leading zeros.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1240212,
                "title": "c-o-nlogn-with-segment-tree",
                "content": "```\\nstruct Node {\\n    int l, r;\\n    int v;\\n    Node() {\\n        v = 0;\\n    };\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<Node> tree;\\n    void build(int l, int r, int p) {\\n        tree[p].l = l;\\n        tree[p].r = r;\\n        if (l != r) {\\n            int mid = (l + r) >> 1;\\n            build(l, mid, 2 * p);\\n            build(mid+1, r, 2 * p + 1);\\n        }\\n    }\\n    void insert(int x, int p) {\\n        tree[p].v--;\\n        if (tree[p].l != tree[p].r) {\\n            int mid = (tree[p].l + tree[p].r) >> 1;\\n            if (x <= mid) insert(x, 2*p);\\n            else insert(x, 2*p+1);\\n        }\\n    }\\n    int query(int l, int r, int p) {\\n        if (tree[p].l == l && tree[p].r == r) return tree[p].v;\\n        else {\\n            int mid = (tree[p].l + tree[p].r) >> 1;\\n            if (r <= mid) return query(l, r, 2*p);\\n            else if (l >= mid+1) return query(l, r, 2*p + 1);\\n            else return query(l, mid, 2*p) + query(mid+1, r, 2*p + 1);\\n        }\\n    }\\n    \\n    string minInteger(string num, int k) {\\n        string result;\\n        \\n        vector<int> offset(num.size(), 0);\\n        vector<deque<int>> pos(10);\\n        for (int i = 0; i < num.size(); i++) pos[num[i]-\\'0\\'].push_back(i);\\n        \\n        tree = vector<Node>(4 * num.size() + 10);\\n        build(0, num.size() - 1, 1);\\n        \\n        int i = 0;\\n        while(true) {\\n            while (i < num.size() && offset[i] < 0) i++;\\n            if (i >= num.size()) break;\\n            \\n            int cp = i;\\n            if (cp - 1 >= 0) cp += query(0, cp - 1, 1);\\n            \\n            for (int p = 0; p <= 9; p++) {\\n                if (pos[p].size() > 0) {\\n                    \\n                    int fp = pos[p].front();\\n                    if (fp - 1 >= 0) fp += query(0, fp - 1, 1);\\n                    \\n                    if (fp - cp <= k) {\\n                        k -= fp - cp;\\n                        offset[pos[p].front()] = -1;\\n                        insert(pos[p].front(), 1);\\n                        \\n                        pos[p].pop_front();\\n                        result += char(\\'0\\' + p);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Node {\\n    int l, r;\\n    int v;\\n    Node() {\\n        v = 0;\\n    };\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<Node> tree;\\n    void build(int l, int r, int p) {\\n        tree[p].l = l;\\n        tree[p].r = r;\\n        if (l != r) {\\n            int mid = (l + r) >> 1;\\n            build(l, mid, 2 * p);\\n            build(mid+1, r, 2 * p + 1);\\n        }\\n    }\\n    void insert(int x, int p) {\\n        tree[p].v--;\\n        if (tree[p].l != tree[p].r) {\\n            int mid = (tree[p].l + tree[p].r) >> 1;\\n            if (x <= mid) insert(x, 2*p);\\n            else insert(x, 2*p+1);\\n        }\\n    }\\n    int query(int l, int r, int p) {\\n        if (tree[p].l == l && tree[p].r == r) return tree[p].v;\\n        else {\\n            int mid = (tree[p].l + tree[p].r) >> 1;\\n            if (r <= mid) return query(l, r, 2*p);\\n            else if (l >= mid+1) return query(l, r, 2*p + 1);\\n            else return query(l, mid, 2*p) + query(mid+1, r, 2*p + 1);\\n        }\\n    }\\n    \\n    string minInteger(string num, int k) {\\n        string result;\\n        \\n        vector<int> offset(num.size(), 0);\\n        vector<deque<int>> pos(10);\\n        for (int i = 0; i < num.size(); i++) pos[num[i]-\\'0\\'].push_back(i);\\n        \\n        tree = vector<Node>(4 * num.size() + 10);\\n        build(0, num.size() - 1, 1);\\n        \\n        int i = 0;\\n        while(true) {\\n            while (i < num.size() && offset[i] < 0) i++;\\n            if (i >= num.size()) break;\\n            \\n            int cp = i;\\n            if (cp - 1 >= 0) cp += query(0, cp - 1, 1);\\n            \\n            for (int p = 0; p <= 9; p++) {\\n                if (pos[p].size() > 0) {\\n                    \\n                    int fp = pos[p].front();\\n                    if (fp - 1 >= 0) fp += query(0, fp - 1, 1);\\n                    \\n                    if (fp - cp <= k) {\\n                        k -= fp - cp;\\n                        offset[pos[p].front()] = -1;\\n                        insert(pos[p].front(), 1);\\n                        \\n                        pos[p].pop_front();\\n                        result += char(\\'0\\' + p);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092447,
                "title": "java-brute-force-via-bubble-sort",
                "content": "In short, the idea is to bubble up the smallest element so far (need to consider k swaps constraint)\\n\\n\\tpublic class Solution1505 {\\n\\t\\tpublic static void main(String[] args) {\\n\\t\\t\\tString num = \"9438957234785635408\";\\n\\t\\t\\tint k = 23;\\n\\n\\t\\t\\tSolution1505 solution1505 = new Solution1505();\\n\\n\\t\\t\\tSystem.out.println(solution1505.minInteger(num, k));\\n\\n\\n\\t\\t}\\n\\n\\t\\tpublic String minInteger(String num, int k) {\\n\\t\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\t\\tchar[] input = num.toCharArray();\\n\\n\\t\\t\\tint idx = 0;\\n\\n\\t\\t\\twhile (idx < input.length && k > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint minValue = input[idx] - \\'0\\';\\n\\t\\t\\t\\tint minIndex = idx;\\n\\n\\t\\t\\t\\tint j = idx + 1;\\n\\n\\t\\t\\t\\tint tempK = k;\\n\\t\\t\\t\\twhile (j < input.length && tempK > 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint curValue = input[j] - \\'0\\';\\n\\t\\t\\t\\t\\tif (curValue < minValue) {\\n\\t\\t\\t\\t\\t\\tminValue = curValue;\\n\\t\\t\\t\\t\\t\\tminIndex = j;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\ttempK--;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tsb.append(input[minIndex]);\\n\\n\\t\\t\\t\\tfor (int i = minIndex; i > idx; --i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tswap(input, i, i - 1);\\n\\t\\t\\t\\t\\tk--;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tidx++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int i = idx; i < input.length; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsb.append(input[i]);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn sb.toString();\\n\\n\\t\\t}\\n\\n\\t\\tprivate void swap(char[] input, int i, int j)\\n\\t\\t{\\n\\t\\t\\tchar temp = input[i];\\n\\n\\t\\t\\tinput[i] = input[j];\\n\\n\\t\\t\\tinput[j] = temp;\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [],
                "code": "class Solution1505 {\\n\\t\\tpublic static void main(String[] args) {\\n\\t\\t\\tString num = \"9438957234785635408\";\\n\\t\\t\\tint k = 23;\\n\\n\\t\\t\\tSolution1505 solution1505 = new Solution1505();\\n\\n\\t\\t\\tSystem.out.println(solution1505.minInteger(num, k));\\n\\n\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1087455,
                "title": "python3-o-n-2-and-o-n-log-n",
                "content": "**Solution 1**: The straightfoward O(n^2) solution will use a similar technique as the bubble sort; this will be TLE.\\n```python\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        \"\"\"O(n^2) TLE\"\"\"\\n        i, size = 0, len(num)\\n        while k > 0 and i < size:\\n            mini = num[i]\\n            j_mini = i\\n            for j in range(i,min(i+k+1,size)):\\n                if num[j]<mini:\\n                    mini = num[j]\\n                    j_mini = j\\n            k -= (j_mini - i)\\n            num = num[:i] + mini + num[i:j_mini] + num[j_mini+1:]\\n            i += 1\\n        return num\\n```\\n**Solution 2**: The trickiest part is to convert this problem into a prefix sum problem. We will need to find the cost to move a digit up front. Consider the following case:\\n* 6,5,4,3,2,1 - the move of 1 to the front will be 5, which is its index (5), straightfoward.\\n* 5,1,0,4,3,2 - the move of 2 to the front will be 3, why? Because by the time we start to move 2, the digits 0 and 1 are already upfront by previous operations. Remember, you never want the digit 2 to be in front of digits 0 and 1. Since we have already moved those 2 digits, we need to exclude that cost (2) from its index (5). So the actual cost of moving 2 upfront, is 5-2 =3. How do we get the cost number 2? We can use an array (BIT) to store a 1 for each already moved position, and do a prefix sum up to the current index (5). \\n\\nWe break out from the loop either we run out of budget k, or we have sorted the string fully. Finally, if we have some leftover in the original string (digits that we have not moved because of shortage of k), we need to append the unused digits to our construted answer.\\n\\n```python\\nclass BIT:\\n    def __init__(self, n):\\n        self.bit = [0]*(n+1)\\n        \\n    def update(self, index, value):\\n        index += 1\\n        while index < len(self.bit):\\n            self.bit[index] += value\\n            index += index & -index\\n        \\n    def query(self, index):\\n        index += 1\\n        value = 0\\n        while index > 0:\\n            value += self.bit[index]\\n            index -= index & -index\\n        return value\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        # Fenwick tree\\n        n = len(num)\\n        tree = BIT(n)\\n        queues = defaultdict(lambda:deque([]))\\n        for i,j in enumerate(num):\\n            queues[int(j)].append(i)\\n        used = set()\\n        ans = \\'\\'\\n        while k > 0 and len(ans) < n:\\n            for digit in range(10):\\n                if digit not in queues:\\n                    continue\\n                i = queues[digit][0]\\n                cost = i - tree.query(i-1)\\n                if cost > k:\\n                    continue\\n                queues[digit].popleft()\\n                if not queues[digit]:\\n                    del queues[digit]\\n                k -= cost\\n                tree.update(i,1)\\n                used.add(i)\\n                ans += num[i]\\n                break\\n                \\n        for i,j in enumerate(num):\\n            if i not in used:\\n                ans += j\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        \"\"\"O(n^2) TLE\"\"\"\\n        i, size = 0, len(num)\\n        while k > 0 and i < size:\\n            mini = num[i]\\n            j_mini = i\\n            for j in range(i,min(i+k+1,size)):\\n                if num[j]<mini:\\n                    mini = num[j]\\n                    j_mini = j\\n            k -= (j_mini - i)\\n            num = num[:i] + mini + num[i:j_mini] + num[j_mini+1:]\\n            i += 1\\n        return num\\n```\n```python\\nclass BIT:\\n    def __init__(self, n):\\n        self.bit = [0]*(n+1)\\n        \\n    def update(self, index, value):\\n        index += 1\\n        while index < len(self.bit):\\n            self.bit[index] += value\\n            index += index & -index\\n        \\n    def query(self, index):\\n        index += 1\\n        value = 0\\n        while index > 0:\\n            value += self.bit[index]\\n            index -= index & -index\\n        return value\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        # Fenwick tree\\n        n = len(num)\\n        tree = BIT(n)\\n        queues = defaultdict(lambda:deque([]))\\n        for i,j in enumerate(num):\\n            queues[int(j)].append(i)\\n        used = set()\\n        ans = \\'\\'\\n        while k > 0 and len(ans) < n:\\n            for digit in range(10):\\n                if digit not in queues:\\n                    continue\\n                i = queues[digit][0]\\n                cost = i - tree.query(i-1)\\n                if cost > k:\\n                    continue\\n                queues[digit].popleft()\\n                if not queues[digit]:\\n                    del queues[digit]\\n                k -= cost\\n                tree.update(i,1)\\n                used.add(i)\\n                ans += num[i]\\n                break\\n                \\n        for i,j in enumerate(num):\\n            if i not in used:\\n                ans += j\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 977611,
                "title": "java-solution",
                "content": "java\\n```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        char[] ca = num.toCharArray();\\n        helper(ca, 0, k);\\n        return new String(ca);\\n    }\\n    \\n    public void helper(char[] ca, int I, int k) {\\n        if(k==0 || I==ca.length)\\n            return ;\\n        int min=ca[I], minindex=I;\\n        for(int i=I+1;i<Math.min( I+k+1, ca.length);i++) {\\n            \\n            if(ca[i]<min) {\\n                min=ca[i];\\n                minindex=i;\\n            }\\n        }\\n        char temp=ca[minindex];\\n        \\n        for(int i=minindex;i>I;i--) {\\n            ca[i]=ca[i-1];\\n        }\\n        ca[I]=temp;\\n        helper(ca, I+1, k-(minindex-I));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        char[] ca = num.toCharArray();\\n        helper(ca, 0, k);\\n        return new String(ca);\\n    }\\n    \\n    public void helper(char[] ca, int I, int k) {\\n        if(k==0 || I==ca.length)\\n            return ;\\n        int min=ca[I], minindex=I;\\n        for(int i=I+1;i<Math.min( I+k+1, ca.length);i++) {\\n            \\n            if(ca[i]<min) {\\n                min=ca[i];\\n                minindex=i;\\n            }\\n        }\\n        char temp=ca[minindex];\\n        \\n        for(int i=minindex;i>I;i--) {\\n            ca[i]=ca[i-1];\\n        }\\n        ca[I]=temp;\\n        helper(ca, I+1, k-(minindex-I));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 800836,
                "title": "c-fenwick-tree-o-n-log-n",
                "content": "```\\nclass FenwickTree\\n{\\n public:\\n    explicit FenwickTree(int size)\\n        : arr(size + 1, 0)\\n    {\\n    }\\n    \\n    int get(int index)\\n    {\\n        ++index;\\n        int value = 0;\\n        \\n        while (index)\\n        {\\n            value += arr[index];\\n            index -= index & (-index);\\n        }\\n        \\n        return value;\\n    }\\n    \\n    void set(int index)\\n    {\\n        ++index;\\n        \\n        while (index < arr.size())\\n        {\\n            ++arr[index];\\n            index += index & (-index);\\n        }\\n    }\\n    \\nprivate:\\n    vector<int> arr;\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    string minInteger(string num, int k) \\n    {\\n        vector<deque<int>> indexes(10, deque<int>());\\n        string result;\\n        FenwickTree tree(num.size());\\n        \\n        for (int i = 0; i < num.size(); ++i)\\n            indexes[num[i] - \\'0\\'].push_back(i);\\n        \\n        for (int i = 0; i < num.size(); ++i)\\n        {\\n            auto digit = num[i] - \\'0\\';\\n            \\n            if (indexes[digit].empty() || indexes[digit].front() != i)\\n                continue;\\n            \\n            indexes[digit].pop_front();\\n           \\n            for (int d = 0; d < digit; ++d)\\n            {\\n                if (!indexes[d].empty() && indexes[d].front() - i - \\n                    tree.get(indexes[d].front()) + tree.get(i) <= k)\\n                {\\n                    k -= indexes[d].front() - i - \\n                        tree.get(indexes[d].front()) + tree.get(i);\\n                    \\n                    tree.set(indexes[d].front());\\n                    \\n                    indexes[d].pop_front();\\n                    result += (char)(d-- + \\'0\\');\\n                }\\n            }\\n            \\n            result += num[i];\\n        }\\n       \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass FenwickTree\\n{\\n public:\\n    explicit FenwickTree(int size)\\n        : arr(size + 1, 0)\\n    {\\n    }\\n    \\n    int get(int index)\\n    {\\n        ++index;\\n        int value = 0;\\n        \\n        while (index)\\n        {\\n            value += arr[index];\\n            index -= index & (-index);\\n        }\\n        \\n        return value;\\n    }\\n    \\n    void set(int index)\\n    {\\n        ++index;\\n        \\n        while (index < arr.size())\\n        {\\n            ++arr[index];\\n            index += index & (-index);\\n        }\\n    }\\n    \\nprivate:\\n    vector<int> arr;\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    string minInteger(string num, int k) \\n    {\\n        vector<deque<int>> indexes(10, deque<int>());\\n        string result;\\n        FenwickTree tree(num.size());\\n        \\n        for (int i = 0; i < num.size(); ++i)\\n            indexes[num[i] - \\'0\\'].push_back(i);\\n        \\n        for (int i = 0; i < num.size(); ++i)\\n        {\\n            auto digit = num[i] - \\'0\\';\\n            \\n            if (indexes[digit].empty() || indexes[digit].front() != i)\\n                continue;\\n            \\n            indexes[digit].pop_front();\\n           \\n            for (int d = 0; d < digit; ++d)\\n            {\\n                if (!indexes[d].empty() && indexes[d].front() - i - \\n                    tree.get(indexes[d].front()) + tree.get(i) <= k)\\n                {\\n                    k -= indexes[d].front() - i - \\n                        tree.get(indexes[d].front()) + tree.get(i);\\n                    \\n                    tree.set(indexes[d].front());\\n                    \\n                    indexes[d].pop_front();\\n                    result += (char)(d-- + \\'0\\');\\n                }\\n            }\\n            \\n            result += num[i];\\n        }\\n       \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727273,
                "title": "java-fenwick-tree-o-nlogn-solution",
                "content": "Video:\\nhttps://www.youtube.com/watch?v=GYin0E1ENWM\\n```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        FenwickTree ft = new FenwickTree(n);\\n        for(int i = 0; i < n; i++) {\\n            ft.update(i, 1);\\n        }\\n        Queue[] arr = new Queue[10];\\n        for(int i = 0; i < 10; i++) arr[i] = new LinkedList<>();\\n        for(int i = 0; i < n; i++) {\\n            arr[num.charAt(i) - \\'0\\'].offer(i);\\n        }\\n        int idx = 0;\\n        String res = \"\";\\n        while(idx < n) {\\n            for(int i = 0; i < 10; i++) {\\n                if(arr[i].size() > 0) {\\n                    int bestIdx = (int)arr[i].peek();\\n                    int cost = ft.getSum(bestIdx) - 1;\\n                    if(cost <= k) {\\n                        res += (char)(\\'0\\' + i);\\n                        arr[i].poll();\\n                        k -= cost;\\n                        if(bestIdx < n - 1) ft.update(bestIdx + 1, -1);\\n                        break;\\n                    } else continue;\\n                }\\n            }\\n            idx += 1;\\n        }\\n        return res;  \\n    }\\n}\\n\\nclass FenwickTree {\\n    int[] tree;\\n    public FenwickTree(int n) {\\n        this.tree = new int[n + 1];\\n    }\\n    \\n    private int getNext(int x) {\\n        return x + (x & (-x));\\n    }\\n    \\n    private int getParent(int x) {\\n        return x - (x & (-x));\\n    }\\n    \\n    public void update(int idx, int diff) {\\n        idx += 1;\\n        while(idx < tree.length) {\\n            tree[idx] += diff;\\n            idx = getNext(idx);\\n        }\\n        return;\\n    }\\n    \\n    public int getSum(int idx) {\\n        idx += 1;\\n        int sum = 0;\\n        while(idx > 0) {\\n            sum += tree[idx];\\n            idx = getParent(idx);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        FenwickTree ft = new FenwickTree(n);\\n        for(int i = 0; i < n; i++) {\\n            ft.update(i, 1);\\n        }\\n        Queue[] arr = new Queue[10];\\n        for(int i = 0; i < 10; i++) arr[i] = new LinkedList<>();\\n        for(int i = 0; i < n; i++) {\\n            arr[num.charAt(i) - \\'0\\'].offer(i);\\n        }\\n        int idx = 0;\\n        String res = \"\";\\n        while(idx < n) {\\n            for(int i = 0; i < 10; i++) {\\n                if(arr[i].size() > 0) {\\n                    int bestIdx = (int)arr[i].peek();\\n                    int cost = ft.getSum(bestIdx) - 1;\\n                    if(cost <= k) {\\n                        res += (char)(\\'0\\' + i);\\n                        arr[i].poll();\\n                        k -= cost;\\n                        if(bestIdx < n - 1) ft.update(bestIdx + 1, -1);\\n                        break;\\n                    } else continue;\\n                }\\n            }\\n            idx += 1;\\n        }\\n        return res;  \\n    }\\n}\\n\\nclass FenwickTree {\\n    int[] tree;\\n    public FenwickTree(int n) {\\n        this.tree = new int[n + 1];\\n    }\\n    \\n    private int getNext(int x) {\\n        return x + (x & (-x));\\n    }\\n    \\n    private int getParent(int x) {\\n        return x - (x & (-x));\\n    }\\n    \\n    public void update(int idx, int diff) {\\n        idx += 1;\\n        while(idx < tree.length) {\\n            tree[idx] += diff;\\n            idx = getNext(idx);\\n        }\\n        return;\\n    }\\n    \\n    public int getSum(int idx) {\\n        idx += 1;\\n        int sum = 0;\\n        while(idx > 0) {\\n            sum += tree[idx];\\n            idx = getParent(idx);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723148,
                "title": "python-o-nogn-bit-fenwicktree-solution",
                "content": "`BIT` :  to get number of elements shifted before processing index\\n`ind`  :  to store occurence of digit\\n```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        def update(ind,bit):\\n            ind=ind+1\\n            while ind<len(bit):\\n                bit[ind]+=1\\n                ind += (ind&-ind)\\n        \\n        def getSum(ind,bit):\\n            ind+=1\\n            res=0\\n            while ind>0:\\n                res+=bit[ind]\\n                ind-=(ind&-ind)\\n            return res\\n        \\n        bit = [0]*(1+len(num))\\n        \\n        ind = {i:deque([]) for i in range(10)}\\n        for i,n in enumerate(num):\\n            ind[int(n)].append(i)\\n        res = []\\n        for i in range(len(num)):\\n            for dig in range(10):\\n                if ind[dig]:\\n                    pos = ind[dig][0]\\n                    dist = pos-getSum(pos,bit)\\n                    if dist<=k:\\n                        k-=dist\\n                        res.append(str(dig))\\n                        ind[dig].popleft()\\n                        update(pos,bit)\\n                        break\\n                        \\n        return \\'\\'.join(res)\\n```",
                "solutionTags": [
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        def update(ind,bit):\\n            ind=ind+1\\n            while ind<len(bit):\\n                bit[ind]+=1\\n                ind += (ind&-ind)\\n        \\n        def getSum(ind,bit):\\n            ind+=1\\n            res=0\\n            while ind>0:\\n                res+=bit[ind]\\n                ind-=(ind&-ind)\\n            return res\\n        \\n        bit = [0]*(1+len(num))\\n        \\n        ind = {i:deque([]) for i in range(10)}\\n        for i,n in enumerate(num):\\n            ind[int(n)].append(i)\\n        res = []\\n        for i in range(len(num)):\\n            for dig in range(10):\\n                if ind[dig]:\\n                    pos = ind[dig][0]\\n                    dist = pos-getSum(pos,bit)\\n                    if dist<=k:\\n                        k-=dist\\n                        res.append(str(dig))\\n                        ind[dig].popleft()\\n                        update(pos,bit)\\n                        break\\n                        \\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723146,
                "title": "c-o-n-count-the-used-index",
                "content": "The ituition of the problem is to collect the smallest reachable number iteratively.\\nObviously, Greedy method will be used by looping from 0 to 9, and check if any index reachable.\\n\\nThere are several ways to check if the index is reachable.\\nThe straightfoward way is to loop and find number within K, by recording if the index is used. This will be O(N\\\\*N) and TLE.\\nThis can also be implemented by the elegant Fenwick tree. By updating/querying the used count before the index in O(logN), this solution will be accepted in O(NlogN)\\n\\n\\nHere I proposed the alternative solution of O(N). \\n\\nWhen we look into the chosing history of one number, the used count before the index is  increasing.\\nTherefore we can record the used count before the next candidate (smallest index) of number 0-9.\\nWe update all the other 9 skipped counts after chosing a number. We will find the next candidate index and update the skip count for the chosen number.\\n \\n[main variables]\\n  \\\\- Used[i] : to check if the num[i] is used\\n \\\\- NextIndex[n] : next index of specific number n\\n \\\\- Skipped[n] : total skipped count before next candidate NextIndex[n]\\n\\n```\\nclass Solution {\\nprivate:\\n    int N;\\n    void Update(string& num, vector<int>& NextIndex, vector<int>& Skipped, vector<bool>& Used, int n) {\\n        int idx = NextIndex[n];\\n        \\n        // update the Skipped arrays except n\\n        for (int i = 0; i < 10; i++) {\\n            if (NextIndex[i] > idx)\\n                Skipped[i]++;\\n        }\\n        Used[idx] = true;\\n        NextIndex[n] = -1;\\n        \\n        // update the Skipped array of n\\n        for (int i = idx; i < N; i++) {\\n            if (Used[i])\\n                Skipped[n]++;\\n            else if (num[i] == n + \\'0\\') {\\n                NextIndex[n] = i;\\n                break;\\n            }\\n        }\\n    }\\n\\npublic:\\n    string minInteger(string num, int k) {\\n        N = num.size();\\n        vector<bool> Used(N, false);\\n        vector<int> NextIndex(10, -1);\\n        vector<int> Skipped(10, 0);\\n        \\n        for (int i = 0; i < N; i++) {\\n            if (NextIndex[num[i] - \\'0\\'] == -1)\\n                NextIndex[num[i] - \\'0\\'] = i;\\n        }\\n        \\n        string result;\\n        int i = 0;\\n        while (i < N && k) {\\n            if (Used[i]) {\\n                i++;\\n                continue;\\n            }\\n\\n            // choose the reachable smallest number to swap\\n            int n = 0;\\n            for (; n < 10; n++) {\\n                if (NextIndex[n] == -1)\\n                    continue;\\n                \\n                if (NextIndex[n] - Skipped[n] <= k) {\\n                    k -= (NextIndex[n] - Skipped[n]);\\n                    break;\\n                }\\n            }\\n            \\n            if (n == 10) {              // no swap\\n                n = num[i] - \\'0\\';\\n                i++;\\n            }\\n\\n            result.push_back(n + \\'0\\');\\n            Update(num, NextIndex, Skipped, Used, n);\\n        }\\n        \\n        for (; i < N; i++) {\\n            if (!Used[i])\\n                result.push_back(num[i]);\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int N;\\n    void Update(string& num, vector<int>& NextIndex, vector<int>& Skipped, vector<bool>& Used, int n) {\\n        int idx = NextIndex[n];\\n        \\n        // update the Skipped arrays except n\\n        for (int i = 0; i < 10; i++) {\\n            if (NextIndex[i] > idx)\\n                Skipped[i]++;\\n        }\\n        Used[idx] = true;\\n        NextIndex[n] = -1;\\n        \\n        // update the Skipped array of n\\n        for (int i = idx; i < N; i++) {\\n            if (Used[i])\\n                Skipped[n]++;\\n            else if (num[i] == n + \\'0\\') {\\n                NextIndex[n] = i;\\n                break;\\n            }\\n        }\\n    }\\n\\npublic:\\n    string minInteger(string num, int k) {\\n        N = num.size();\\n        vector<bool> Used(N, false);\\n        vector<int> NextIndex(10, -1);\\n        vector<int> Skipped(10, 0);\\n        \\n        for (int i = 0; i < N; i++) {\\n            if (NextIndex[num[i] - \\'0\\'] == -1)\\n                NextIndex[num[i] - \\'0\\'] = i;\\n        }\\n        \\n        string result;\\n        int i = 0;\\n        while (i < N && k) {\\n            if (Used[i]) {\\n                i++;\\n                continue;\\n            }\\n\\n            // choose the reachable smallest number to swap\\n            int n = 0;\\n            for (; n < 10; n++) {\\n                if (NextIndex[n] == -1)\\n                    continue;\\n                \\n                if (NextIndex[n] - Skipped[n] <= k) {\\n                    k -= (NextIndex[n] - Skipped[n]);\\n                    break;\\n                }\\n            }\\n            \\n            if (n == 10) {              // no swap\\n                n = num[i] - \\'0\\';\\n                i++;\\n            }\\n\\n            result.push_back(n + \\'0\\');\\n            Update(num, NextIndex, Skipped, Used, n);\\n        }\\n        \\n        for (; i < N; i++) {\\n            if (!Used[i])\\n                result.push_back(num[i]);\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721944,
                "title": "c-o-n-log-n-fenwick-tree-solution-inspired-by-awice",
                "content": "You can watch his full explanation starting at 33:47: https://www.youtube.com/watch?v=pO_TtGTe6GQ\\n```\\nclass FenwickTree {\\nprivate:\\n    vector<int> arr; \\n\\npublic:\\n    FenwickTree(int n) {\\n        n++;\\n        arr = vector<int>(n, 0);\\n    }\\n    \\n    void add(int index, const int num) {\\n        index++;\\n        while (index < static_cast<int>(arr.size())) {\\n            arr[index] += num;\\n            index += (~index + 1) & index; \\n        }\\n    }\\n    \\n    int getPrefixSum(int index) const {\\n        int sum = 0;\\n        index++;\\n        while (index > 0) {\\n            sum += arr[index];\\n            index -= (~index + 1) & index; \\n        }\\n        return sum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.length();\\n        FenwickTree tree(n);\\n        vector<int> numArr(n);\\n        for (int i = 0; i < n; i++) {\\n            numArr[i] = num[i] - \\'0\\';\\n        }\\n        unordered_map<int,vector<int>> indexMap;\\n        for (int i = 0; i < n; i++) {\\n            if (indexMap.count(numArr[i]) == 0) {\\n                indexMap[numArr[i]] = {i};\\n            }\\n            else {\\n                indexMap[numArr[i]].push_back(i);\\n            }\\n        }\\n        for (int i = 0; i < 10; i++) {\\n            if (indexMap.count(i) != 0) {\\n                reverse(indexMap[i].begin(), indexMap[i].end());\\n            }\\n        }\\n        string res = \"\";\\n        while (k > 0) {\\n            int i;\\n            for (i = 0; i < 10; i++) {\\n                if (indexMap.count(i) == 0) {\\n                    continue;\\n                }\\n                int leftMostIndex = indexMap[i].back();\\n                int usedIndices = tree.getPrefixSum(leftMostIndex);\\n                int rank = leftMostIndex - usedIndices;\\n                if (rank <= k) {\\n                    k -= rank;\\n                    res.push_back(i + \\'0\\');\\n                    indexMap[i].pop_back();\\n                    if (indexMap[i].empty()) {\\n                        indexMap.erase(i);\\n                    }\\n                    tree.add(leftMostIndex, 1);\\n                    break;\\n                }\\n            }\\n            if (i == 10) {\\n                break;\\n            }\\n        }\\n        vector<vector<int>> remaining;\\n        for (auto& [digit,row] : indexMap) {\\n            for (int i : row) {\\n                remaining.push_back({i,digit});\\n            }\\n        }\\n        sort(remaining.begin(), remaining.end(), \\n            [](const vector<int>& a, const vector<int>& b) -> bool\\n        { \\n            return a[0] < b[0]; \\n        });\\n        for (vector<int>& entry : remaining) {\\n            res.push_back(entry[1] + \\'0\\');\\n        }\\n        return res;\\n    }\\n};\\n```\\nHaven\\'t write C++ in a while. So please forgive me if there are any stylistic issues...",
                "solutionTags": [],
                "code": "```\\nclass FenwickTree {\\nprivate:\\n    vector<int> arr; \\n\\npublic:\\n    FenwickTree(int n) {\\n        n++;\\n        arr = vector<int>(n, 0);\\n    }\\n    \\n    void add(int index, const int num) {\\n        index++;\\n        while (index < static_cast<int>(arr.size())) {\\n            arr[index] += num;\\n            index += (~index + 1) & index; \\n        }\\n    }\\n    \\n    int getPrefixSum(int index) const {\\n        int sum = 0;\\n        index++;\\n        while (index > 0) {\\n            sum += arr[index];\\n            index -= (~index + 1) & index; \\n        }\\n        return sum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.length();\\n        FenwickTree tree(n);\\n        vector<int> numArr(n);\\n        for (int i = 0; i < n; i++) {\\n            numArr[i] = num[i] - \\'0\\';\\n        }\\n        unordered_map<int,vector<int>> indexMap;\\n        for (int i = 0; i < n; i++) {\\n            if (indexMap.count(numArr[i]) == 0) {\\n                indexMap[numArr[i]] = {i};\\n            }\\n            else {\\n                indexMap[numArr[i]].push_back(i);\\n            }\\n        }\\n        for (int i = 0; i < 10; i++) {\\n            if (indexMap.count(i) != 0) {\\n                reverse(indexMap[i].begin(), indexMap[i].end());\\n            }\\n        }\\n        string res = \"\";\\n        while (k > 0) {\\n            int i;\\n            for (i = 0; i < 10; i++) {\\n                if (indexMap.count(i) == 0) {\\n                    continue;\\n                }\\n                int leftMostIndex = indexMap[i].back();\\n                int usedIndices = tree.getPrefixSum(leftMostIndex);\\n                int rank = leftMostIndex - usedIndices;\\n                if (rank <= k) {\\n                    k -= rank;\\n                    res.push_back(i + \\'0\\');\\n                    indexMap[i].pop_back();\\n                    if (indexMap[i].empty()) {\\n                        indexMap.erase(i);\\n                    }\\n                    tree.add(leftMostIndex, 1);\\n                    break;\\n                }\\n            }\\n            if (i == 10) {\\n                break;\\n            }\\n        }\\n        vector<vector<int>> remaining;\\n        for (auto& [digit,row] : indexMap) {\\n            for (int i : row) {\\n                remaining.push_back({i,digit});\\n            }\\n        }\\n        sort(remaining.begin(), remaining.end(), \\n            [](const vector<int>& a, const vector<int>& b) -> bool\\n        { \\n            return a[0] < b[0]; \\n        });\\n        for (vector<int>& entry : remaining) {\\n            res.push_back(entry[1] + \\'0\\');\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720607,
                "title": "c-greedy-with-index-preprocessing",
                "content": "```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        std::vector<std::vector<int>> digit_to_inds(10);\\n        std::vector<int> voids; // locations that are empty, no price to pay\\n        for (int i = num.size() - 1; i >= 0; --i) {\\n            digit_to_inds[static_cast<int>(num[i] - \\'0\\')].push_back(i);\\n        }       \\n        constexpr char VOID_MARK = \\'X\\';\\n        int reserved = k;\\n        std::vector<int> res;\\n        while ((reserved > 0) && (res.size() < num.size())) {\\n            for (int d = 0; d <= 9; ++d) {\\n                auto &inds = digit_to_inds[d];\\n                if (inds.empty()) {\\n                    continue;\\n                }\\n                const int i = inds.back(); // smallest index for `d`\\n                // There were `j` elements prior to the index `i`\\n                // removed from `num`. There\\'s no need to swap with them.\\n                const int j = std::distance(\\n                    voids.begin(), \\n                    std::lower_bound(voids.begin(), voids.end(), i)\\n                );\\n\\t\\t\\t\\t// Number of swap ops needed to bubble this to top.\\n                const int price = i - 0 - j;\\n                if (price > reserved) {\\n                    continue;\\n                }\\n                // Housekeeping.\\n                reserved -= price;\\n                res.push_back(d);\\n                voids.insert(voids.begin() + j, i);      \\n                num[i] = VOID_MARK;\\n                inds.pop_back();\\n                break;\\n            }\\n        }\\n\\t\\t// Results come from the elements pushed to `res`, \\n\\t\\t// as well as the remaining ones in `num`.\\n        std::stringstream ss;\\n        for (int d : res) {\\n            ss << d;\\n        }\\n        for (char ch : num) {\\n            if (ch != VOID_MARK) {\\n                ss << ch;\\n            }\\n        }\\n        return ss.str();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        std::vector<std::vector<int>> digit_to_inds(10);\\n        std::vector<int> voids; // locations that are empty, no price to pay\\n        for (int i = num.size() - 1; i >= 0; --i) {\\n            digit_to_inds[static_cast<int>(num[i] - \\'0\\')].push_back(i);\\n        }       \\n        constexpr char VOID_MARK = \\'X\\';\\n        int reserved = k;\\n        std::vector<int> res;\\n        while ((reserved > 0) && (res.size() < num.size())) {\\n            for (int d = 0; d <= 9; ++d) {\\n                auto &inds = digit_to_inds[d];\\n                if (inds.empty()) {\\n                    continue;\\n                }\\n                const int i = inds.back(); // smallest index for `d`\\n                // There were `j` elements prior to the index `i`\\n                // removed from `num`. There\\'s no need to swap with them.\\n                const int j = std::distance(\\n                    voids.begin(), \\n                    std::lower_bound(voids.begin(), voids.end(), i)\\n                );\\n\\t\\t\\t\\t// Number of swap ops needed to bubble this to top.\\n                const int price = i - 0 - j;\\n                if (price > reserved) {\\n                    continue;\\n                }\\n                // Housekeeping.\\n                reserved -= price;\\n                res.push_back(d);\\n                voids.insert(voids.begin() + j, i);      \\n                num[i] = VOID_MARK;\\n                inds.pop_back();\\n                break;\\n            }\\n        }\\n\\t\\t// Results come from the elements pushed to `res`, \\n\\t\\t// as well as the remaining ones in `num`.\\n        std::stringstream ss;\\n        for (int d : res) {\\n            ss << d;\\n        }\\n        for (char ch : num) {\\n            if (ch != VOID_MARK) {\\n                ss << ch;\\n            }\\n        }\\n        return ss.str();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720338,
                "title": "python-bisect-o-nlgn-pass-so-hard",
                "content": "\\tclass Solution:\\n\\t\\tdef minInteger(self, num: str, k: int) -> str:\\n\\n\\t\\t\\tnum = list(num)\\n\\t\\t\\tsmall = sorted(list(num))\\n\\n\\t\\t\\tif k > len(num) ** 2:\\n\\t\\t\\t\\treturn \\'\\'.join(small)\\n\\n\\t\\t\\td = defaultdict(list)\\n\\t\\t\\tfor i in range(len(num)):\\n\\t\\t\\t\\td[num[i]].append(i)\\n\\n\\t\\t\\tindexs = []\\n\\t\\t\\tfor char in sorted(d.keys()):\\n\\t\\t\\t\\tindexs += d[char]\\n\\n\\t\\t\\tdone = []\\n\\t\\t\\thead = 0\\n\\n\\t\\t\\twhile k > 0 and indexs:\\n\\t\\t\\t\\tif num == small:\\n\\t\\t\\t\\t\\treturn \\'\\'.join(num)\\n\\t\\t\\t\\tfor i in range(len(indexs)):\\n\\t\\t\\t\\t\\tpre = bisect.bisect(done, indexs[i])\\n\\t\\t\\t\\t\\tnewi = indexs[i] + len(done) - pre\\n\\t\\t\\t\\t\\tif newi >= head and newi - head <= k:\\n\\t\\t\\t\\t\\t\\tbisect.insort(done, indexs[i])\\n\\t\\t\\t\\t\\t\\tnum = num[:head] + [num[newi]] + num[head:newi] + num[newi + 1:]\\n\\t\\t\\t\\t\\t\\tk -= newi - head\\n\\t\\t\\t\\t\\t\\thead += 1\\n\\t\\t\\t\\t\\t\\tindexs.pop(i)\\n\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\treturn \\'\\'.join(num)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef minInteger(self, num: str, k: int) -> str:\\n\\n\\t\\t\\tnum = list(num)\\n\\t\\t\\tsmall = sorted(list(num))\\n\\n\\t\\t\\tif k > len(num) ** 2:\\n\\t\\t\\t\\treturn \\'\\'.join(small)\\n\\n\\t\\t\\td = defaultdict(list)\\n\\t\\t\\tfor i in range(len(num)):\\n\\t\\t\\t\\td[num[i]].append(i)\\n\\n\\t\\t\\tindexs = []\\n\\t\\t\\tfor char in sorted(d.keys()):\\n\\t\\t\\t\\tindexs += d[char]\\n\\n\\t\\t\\tdone = []\\n\\t\\t\\thead = 0\\n\\n\\t\\t\\twhile k > 0 and indexs:\\n\\t\\t\\t\\tif num == small:\\n\\t\\t\\t\\t\\treturn \\'\\'.join(num)\\n\\t\\t\\t\\tfor i in range(len(indexs)):\\n\\t\\t\\t\\t\\tpre = bisect.bisect(done, indexs[i])\\n\\t\\t\\t\\t\\tnewi = indexs[i] + len(done) - pre\\n\\t\\t\\t\\t\\tif newi >= head and newi - head <= k:\\n\\t\\t\\t\\t\\t\\tbisect.insort(done, indexs[i])\\n\\t\\t\\t\\t\\t\\tnum = num[:head] + [num[newi]] + num[head:newi] + num[newi + 1:]\\n\\t\\t\\t\\t\\t\\tk -= newi - head\\n\\t\\t\\t\\t\\t\\thead += 1\\n\\t\\t\\t\\t\\t\\tindexs.pop(i)\\n\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\treturn \\'\\'.join(num)",
                "codeTag": "Java"
            },
            {
                "id": 720337,
                "title": "python-nlogn-using-binary-index-tree",
                "content": "Well.. the average performance should be NlogN, but it is hard to prove whether the worst case still holds. Anyway, I still share my solution.\\n\\n```\\nfrom heapq import heapify, heappop, heappush\\n\\ndef getsum(tree, i): \\n    s = 0\\n    i += 1\\n    while i > 0: \\n        s += tree[i] \\n        i -= i & (-i) \\n    return s \\n  \\n# modify the value from the original one,\\n# v is diff/increment.\\ndef update(tree, i ,v): \\n    i += 1\\n    while i < len(tree): \\n        tree[i] += v \\n        i += i & (-i)\\n        \\ndef construct(arr): \\n    tree = [0] * (len(arr) + 1) \\n  \\n    for i in range(len(arr)): \\n        update(tree, i, arr[i]) \\n\\n    return tree \\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        pq = []\\n        ans = []\\n        \\n        # the input array looks like [0, 1,1,1,1,...]\\n        tree = construct([0] + [1] * len(num))\\n        \\n\\n        used = set()\\n        # a heap to store un-unsed indices\\n        wait_queue = list(range(len(num)))\\n        heapify(wait_queue)\\n        \\n        \\n        while k > 0:\\n            # getsum(tree, idx) is to get the actual index of an element whose original index\\n            # is idx.\\n            while len(wait_queue) > 0 and getsum(tree, wait_queue[0]) <= len(ans) + k: \\n                idx = heappop(wait_queue)\\n                heappush(pq, (num[idx], idx))\\n                \\n            if len(pq) == 0:\\n                break\\n            ch, i = heappop(pq)\\n            \\n            \\n            cost = getsum(tree, i) - len(ans)\\n            if cost > k:\\n                heappush(wait_queue, i)\\n                continue\\n                \\n            k -= cost\\n            \\n            # move the one from i and add to zero.\\n            update(tree, i + 1, -1)\\n            update(tree, 0, 1)    \\n            \\n            \\n            ans.append(ch)\\n            used.add(i)\\n            \\n        for i, ch in enumerate(num):\\n            if i not in used:\\n                ans.append(ch)\\n        \\n        return \"\".join(ans)\\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heapify, heappop, heappush\\n\\ndef getsum(tree, i): \\n    s = 0\\n    i += 1\\n    while i > 0: \\n        s += tree[i] \\n        i -= i & (-i) \\n    return s \\n  \\n# modify the value from the original one,\\n# v is diff/increment.\\ndef update(tree, i ,v): \\n    i += 1\\n    while i < len(tree): \\n        tree[i] += v \\n        i += i & (-i)\\n        \\ndef construct(arr): \\n    tree = [0] * (len(arr) + 1) \\n  \\n    for i in range(len(arr)): \\n        update(tree, i, arr[i]) \\n\\n    return tree \\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        pq = []\\n        ans = []\\n        \\n        # the input array looks like [0, 1,1,1,1,...]\\n        tree = construct([0] + [1] * len(num))\\n        \\n\\n        used = set()\\n        # a heap to store un-unsed indices\\n        wait_queue = list(range(len(num)))\\n        heapify(wait_queue)\\n        \\n        \\n        while k > 0:\\n            # getsum(tree, idx) is to get the actual index of an element whose original index\\n            # is idx.\\n            while len(wait_queue) > 0 and getsum(tree, wait_queue[0]) <= len(ans) + k: \\n                idx = heappop(wait_queue)\\n                heappush(pq, (num[idx], idx))\\n                \\n            if len(pq) == 0:\\n                break\\n            ch, i = heappop(pq)\\n            \\n            \\n            cost = getsum(tree, i) - len(ans)\\n            if cost > k:\\n                heappush(wait_queue, i)\\n                continue\\n                \\n            k -= cost\\n            \\n            # move the one from i and add to zero.\\n            update(tree, i + 1, -1)\\n            update(tree, 0, 1)    \\n            \\n            \\n            ans.append(ch)\\n            used.add(i)\\n            \\n        for i, ch in enumerate(num):\\n            if i not in used:\\n                ans.append(ch)\\n        \\n        return \"\".join(ans)\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 720191,
                "title": "python-o-n-log-n-316ms-greedy-solution-finished-5-min-after-contest-end",
                "content": "Probably being distracted by the Independence Day fireworks, I finished coding this O(N log N) solution 5 min after the end of the weekly contest \\uD83D\\uDE2D\\n\\n\\n**O(N log N)** Solution\\n```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        ind = [[] for _ in range(10)]\\n        for i in range(len(num)-1, -1, -1):\\n            ind[int(num[i])].append(i)\\n        i = 0\\n        res = []\\n        picked = []\\n        moveright = {}\\n        for i in range(len(num) - 1):\\n            for _ in range(10):\\n                if ind[_]:\\n                    if _  not in moveright:\\n                        moveright[_] = len(picked) - bisect.bisect(picked, ind[_][-1])\\n                    if ind[_][-1] + moveright[_] - i <= k:\\n                        k -= ind[_][-1] + moveright[_] - i\\n                        insort(picked, ind[_][-1])\\n                        res.append(str(_))\\n                        ind[_].pop()\\n                        moveright.pop(_)\\n                        break\\n            if k == 0:\\n                break\\n        unpicked = []\\n        pickedset = set(picked)\\n        for i in range(len(num)):\\n            if i not in pickedset:\\n                unpicked.append(i)\\n        return \"\".join(res) + \"\".join([num[j] for j in unpicked])\\n```\\n\\n------------------------------------\\nDuring the contest I figured out two \\uFF2F(N^2) solutions (the first one is actually O(10\\\\*N^2)), but both of them result in TLE.\\n\\nI see some other posts in which their O(N^2) solutions pass the OJ. Is it because my way is recursive?  Does `newstr = \"a\" + oldstr_of_length_N` takes O(1) or O(N) time in Python? But anyway my solutions are O(N^2)\\n**O(10\\\\*N^2)** Solution\\n```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        if len(num) == 1 or k == 0:\\n            return num\\n        for i in range(10):\\n            for j in range(min(k+1, len(num))):\\n                if num[j] == str(i):\\n                    return num[j] + self.minInteger(num[:j] + num[j+1:], k - j)\\n```\\n**O(N^2)** Solution\\n```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        if len(num) == 1 or k == 0:\\n            return num\\n        m = 10\\n        for j in range(min(k+1, len(num))):\\n            if num[j] == \"0\":\\n                return num[j] + self.minInteger(num[:j] + num[j+1:], k - j)\\n            if int(num[j]) < m:\\n                m = int(num[j])\\n                i = j\\n        return num[i] + self.minInteger(num[:i] + num[i+1:], k - i)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        ind = [[] for _ in range(10)]\\n        for i in range(len(num)-1, -1, -1):\\n            ind[int(num[i])].append(i)\\n        i = 0\\n        res = []\\n        picked = []\\n        moveright = {}\\n        for i in range(len(num) - 1):\\n            for _ in range(10):\\n                if ind[_]:\\n                    if _  not in moveright:\\n                        moveright[_] = len(picked) - bisect.bisect(picked, ind[_][-1])\\n                    if ind[_][-1] + moveright[_] - i <= k:\\n                        k -= ind[_][-1] + moveright[_] - i\\n                        insort(picked, ind[_][-1])\\n                        res.append(str(_))\\n                        ind[_].pop()\\n                        moveright.pop(_)\\n                        break\\n            if k == 0:\\n                break\\n        unpicked = []\\n        pickedset = set(picked)\\n        for i in range(len(num)):\\n            if i not in pickedset:\\n                unpicked.append(i)\\n        return \"\".join(res) + \"\".join([num[j] for j in unpicked])\\n```\n```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        if len(num) == 1 or k == 0:\\n            return num\\n        for i in range(10):\\n            for j in range(min(k+1, len(num))):\\n                if num[j] == str(i):\\n                    return num[j] + self.minInteger(num[:j] + num[j+1:], k - j)\\n```\n```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        if len(num) == 1 or k == 0:\\n            return num\\n        m = 10\\n        for j in range(min(k+1, len(num))):\\n            if num[j] == \"0\":\\n                return num[j] + self.minInteger(num[:j] + num[j+1:], k - j)\\n            if int(num[j]) < m:\\n                m = int(num[j])\\n                i = j\\n        return num[i] + self.minInteger(num[:i] + num[i+1:], k - i)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003143,
                "title": "very-easy-c-solution-beats-94",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n- O(3*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string minInteger(string s, int k) {\\n        int n=s.size();\\n        vector<int> prefix(n,0),prefix1(n,0),visited(n,0);\\n        string ans=\"\";\\n        int cnt;\\n        bool tp=false;\\n        int current=n;\\n        for(int i=0;i<9;i++){\\n            cnt=0;\\n        for(int j=0;j<n;j++){\\n            if(current<j)break;\\n            if(s[j]==(i+\\'0\\')){\\n                if((j-prefix1[j]-cnt)<=k){\\n                prefix[j]++;\\n                // cout<<prefix1[j]<<\" \"<<i<<\" \"<<cnt<<endl;\\n                k-=(j-prefix1[j]-cnt);\\n                ans+=s[j];\\n                visited[j]=1;\\n                cnt++;\\n                // cout<<k<<\" \"<<i<<endl;\\n                }\\n                else{\\n                    // tp=true;\\n                    current=j;\\n                    break;\\n                }\\n                // else{\\n\\n                // }\\n            }\\n        }\\n        // if(tp)break;\\n            prefix1=prefix;\\n            for(int j=1;j<n;j++){\\n                prefix1[j]+=prefix1[j-1];\\n            }\\n        }\\n        cout<<k<<\" \";\\n        for(int i=0;i<n;i++){\\n           if(!visited[i]){\\n               ans+=s[i];\\n           }\\n        }\\n        cout<<ans<<endl;\\n        for(int i=0;i<n-1;i++){\\n            if(ans[i]>ans[i+1]){\\n                current=i+1;\\n                break;\\n            }\\n        }\\n        // cout<<current<<\" \";\\n        while(current!=n && current>0 && k>0){\\n            swap(ans[current],ans[current-1]);\\n            current--;\\n            k--;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minInteger(string s, int k) {\\n        int n=s.size();\\n        vector<int> prefix(n,0),prefix1(n,0),visited(n,0);\\n        string ans=\"\";\\n        int cnt;\\n        bool tp=false;\\n        int current=n;\\n        for(int i=0;i<9;i++){\\n            cnt=0;\\n        for(int j=0;j<n;j++){\\n            if(current<j)break;\\n            if(s[j]==(i+\\'0\\')){\\n                if((j-prefix1[j]-cnt)<=k){\\n                prefix[j]++;\\n                // cout<<prefix1[j]<<\" \"<<i<<\" \"<<cnt<<endl;\\n                k-=(j-prefix1[j]-cnt);\\n                ans+=s[j];\\n                visited[j]=1;\\n                cnt++;\\n                // cout<<k<<\" \"<<i<<endl;\\n                }\\n                else{\\n                    // tp=true;\\n                    current=j;\\n                    break;\\n                }\\n                // else{\\n\\n                // }\\n            }\\n        }\\n        // if(tp)break;\\n            prefix1=prefix;\\n            for(int j=1;j<n;j++){\\n                prefix1[j]+=prefix1[j-1];\\n            }\\n        }\\n        cout<<k<<\" \";\\n        for(int i=0;i<n;i++){\\n           if(!visited[i]){\\n               ans+=s[i];\\n           }\\n        }\\n        cout<<ans<<endl;\\n        for(int i=0;i<n-1;i++){\\n            if(ans[i]>ans[i+1]){\\n                current=i+1;\\n                break;\\n            }\\n        }\\n        // cout<<current<<\" \";\\n        while(current!=n && current>0 && k>0){\\n            swap(ans[current],ans[current-1]);\\n            current--;\\n            k--;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4002027,
                "title": "bit-commented-queue",
                "content": "****Binary Indexed Tree (BIT):\\n****\\nPurpose: The Binary Indexed Tree, also known as a Fenwick Tree, is used to efficiently perform prefix sum queries and updates. It helps keep track of the number of digits that have been removed from the original string, which is essential for selecting and processing digits during the optimization process.\\nHow It\\'s Used:\\nThe BIT is initialized with a size of \\'n+1,\\' where \\'n\\' is the number of elements (positions in the string).\\nThe update method is used to increment the value at a specific index (position) by a given delta (usually 1). This operation marks that a digit has been removed from the original string.\\nThe query method is used to efficiently compute the prefix sum up to a specific index. It helps determine how many digits have been removed from positions preceding a given position.\\nQueues (qs - Vector of Queues):\\n**\\nPurpose: Queues **are used to keep track of the positions of each digit in the original string. Each queue corresponds to a digit from 0 to 9, and it stores the positions of that digit in the string.\\nHow They\\'re Used:\\nDuring the initialization of qs, each digit\\'s queue is populated with its respective positions in the original string.\\nThe queues are used to efficiently select and process digits during the process of minimizing the integer:\\nDigits that can be moved to the left-hand side (i.e., smaller digits that have sufficient available swaps) are selected from their respective queues and added to the result.\\nPositions of processed digits are marked as \"removed\" in the BIT using the update method.\\nThis process continues until \\'k\\' swaps are exhausted or no more valid swaps are possible.\\n\\n# Code\\n```\\nclass BIT {\\npublic:\\n    int n;               // Number of elements\\n    vector<int> nodes;   // Binary Indexed Tree (Fenwick Tree)\\n\\n    BIT(int n) {\\n        this->n = n;\\n        nodes = vector<int>(n + 1);  // Initialize the BIT with size (n + 1)\\n    }\\n\\n    // Function to update a value at index \\'i\\' by adding \\'delta\\'\\n    void update(int i, int delta) {\\n        ++i;  // Increment \\'i\\' to convert 0-based indexing to 1-based indexing\\n        while (i <= n) {\\n            nodes[i] += delta;  // Update the BIT node at index \\'i\\' by adding \\'delta\\'\\n            i += (i & -i);     // Move to the parent node (next node with a higher significant bit)\\n        }\\n    }\\n\\n    // Function to query the prefix sum up to index \\'i\\'\\n    int query(int i) {\\n        ++i;  // Increment \\'i\\' to convert 0-based indexing to 1-based indexing\\n        int sum = 0;\\n        while (i > 0) {\\n            sum += nodes[i];   // Accumulate the sum from the current node\\n            i -= (i & -i);    // Move to the previous node (next node with a lower significant bit)\\n        }\\n        return sum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        vector<queue<int>> qs(10);  // An array of queues to store positions of each digit\\n        int n = num.size();\\n\\n        // Populate queues with the positions of each digit\\n        for (int i = 0; i < n; ++i) {\\n            qs[num[i] - \\'0\\'].push(i);\\n        }\\n\\n        string lhs;  // Left-hand side of the result string\\n        vector<bool> removed(n, false);  // Indicates if a digit has been removed from the original string\\n        BIT* tree = new BIT(n);  // Create a Binary Indexed Tree (BIT) to track removed digits\\n\\n        while (k > 0) {\\n            bool found = false;\\n            for (int d = 0; d <= 9; ++d) {\\n                if (!qs[d].empty()) {\\n                    int pos = qs[d].front();  // Get the position of the current digit\\n                    int shifted = tree->query(pos - 1);  // Query the BIT to find the number of removed digits before pos\\n                    if (pos - shifted <= k) {\\n                        k -= pos - shifted;  // Update remaining swaps\\n                        tree->update(pos, 1);  // Mark the current digit as removed in the BIT\\n                        qs[d].pop();  // Remove the position from the queue\\n                        lhs += (\\'0\\' + d);  // Append the digit to the left-hand side\\n                        removed[pos] = true;  // Mark the digit as removed\\n                        found = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (!found) break;  // If no valid swap is possible, exit the loop\\n        }\\n\\n        string rhs;  // Right-hand side of the result string\\n        for (int i = 0; i < n; ++i) {\\n            if (!removed[i]) {\\n                rhs += num[i];  // Append the remaining digits to the right-hand side\\n            }\\n        }\\n\\n        return lhs + rhs;  // Concatenate the left-hand and right-hand sides to form the final result\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass BIT {\\npublic:\\n    int n;               // Number of elements\\n    vector<int> nodes;   // Binary Indexed Tree (Fenwick Tree)\\n\\n    BIT(int n) {\\n        this->n = n;\\n        nodes = vector<int>(n + 1);  // Initialize the BIT with size (n + 1)\\n    }\\n\\n    // Function to update a value at index \\'i\\' by adding \\'delta\\'\\n    void update(int i, int delta) {\\n        ++i;  // Increment \\'i\\' to convert 0-based indexing to 1-based indexing\\n        while (i <= n) {\\n            nodes[i] += delta;  // Update the BIT node at index \\'i\\' by adding \\'delta\\'\\n            i += (i & -i);     // Move to the parent node (next node with a higher significant bit)\\n        }\\n    }\\n\\n    // Function to query the prefix sum up to index \\'i\\'\\n    int query(int i) {\\n        ++i;  // Increment \\'i\\' to convert 0-based indexing to 1-based indexing\\n        int sum = 0;\\n        while (i > 0) {\\n            sum += nodes[i];   // Accumulate the sum from the current node\\n            i -= (i & -i);    // Move to the previous node (next node with a lower significant bit)\\n        }\\n        return sum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        vector<queue<int>> qs(10);  // An array of queues to store positions of each digit\\n        int n = num.size();\\n\\n        // Populate queues with the positions of each digit\\n        for (int i = 0; i < n; ++i) {\\n            qs[num[i] - \\'0\\'].push(i);\\n        }\\n\\n        string lhs;  // Left-hand side of the result string\\n        vector<bool> removed(n, false);  // Indicates if a digit has been removed from the original string\\n        BIT* tree = new BIT(n);  // Create a Binary Indexed Tree (BIT) to track removed digits\\n\\n        while (k > 0) {\\n            bool found = false;\\n            for (int d = 0; d <= 9; ++d) {\\n                if (!qs[d].empty()) {\\n                    int pos = qs[d].front();  // Get the position of the current digit\\n                    int shifted = tree->query(pos - 1);  // Query the BIT to find the number of removed digits before pos\\n                    if (pos - shifted <= k) {\\n                        k -= pos - shifted;  // Update remaining swaps\\n                        tree->update(pos, 1);  // Mark the current digit as removed in the BIT\\n                        qs[d].pop();  // Remove the position from the queue\\n                        lhs += (\\'0\\' + d);  // Append the digit to the left-hand side\\n                        removed[pos] = true;  // Mark the digit as removed\\n                        found = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (!found) break;  // If no valid swap is possible, exit the loop\\n        }\\n\\n        string rhs;  // Right-hand side of the result string\\n        for (int i = 0; i < n; ++i) {\\n            if (!removed[i]) {\\n                rhs += num[i];  // Append the remaining digits to the right-hand side\\n            }\\n        }\\n\\n        return lhs + rhs;  // Concatenate the left-hand and right-hand sides to form the final result\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001961,
                "title": "commented-segment-tree-queue",
                "content": "see this for best explanation\\nhttps://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/solutions/720548/o-n-logn-detailed-explanation/\\n\\nwhy\\n\\n1. **Segment Tree (`SegTree`):**\\n   - **Purpose:** The segment tree is used to keep track of which digits have been removed from the original string during the process of minimizing the integer.\\n   - **How It\\'s Used:**\\n     - The segment tree maintains information about the positions of removed digits, allowing quick queries to find the count of removed digits before a given position.\\n     - The `update` method is used to mark a position as \"removed\" in the segment tree when a digit is moved to the left-hand side of the result.\\n     - The `queryLessThan` method is used to find the count of removed digits before a specified position.\\n\\n\\nwhy\\n2. **Queues (`qs` - Vector of Queues):**\\n   - **Purpose:** Queues are used to keep track of the positions of each digit in the original string. Each queue corresponds to a digit from 0 to 9, and it stores the positions of that digit in the string.\\n   - **How They\\'re Used:**\\n     - During the initialization of `qs`, each digit\\'s queue is populated with its respective positions in the original string.\\n     - The queues are used to efficiently select and process digits during the process of minimizing the integer:\\n       - Digits that can be moved to the left-hand side (i.e., smaller digits that have sufficient available swaps) are selected from their respective queues and added to the result.\\n       - Positions of processed digits are marked as \"removed\" in the segment tree.\\n       - This process continues until \\'k\\' swaps are exhausted or no more valid swaps are possible.\\n\\nIn summary, the segment tree is employed to keep track of removed digits and efficiently answer queries about the number of removed digits before a given position. The queues are used to manage the positions of digits in the original string and facilitate the selection and processing of digits during the optimization process. Together, these data structures enable an efficient solution to the problem of minimizing the integer while respecting the swap limit \\'k\\'.\\n\\n# Code\\n```\\nclass SegTree {\\npublic:\\n    vector<int> nodes;  // Array representing the segment tree\\n    int n;              // Number of elements in the original array\\n\\n    SegTree(int n) {\\n        this->n = n;\\n        nodes = vector<int>(this->n << 2);  // Initialize the segment tree with size 4 * n\\n    }\\n\\n    // Function to update a node in the segment tree\\n    void update(int treeIdx, int l, int r, int ql, int val) {\\n        if (ql < l || ql > r) {\\n            return;  // If the query index is out of the current segment, return\\n        }\\n\\n        if (l == r) {\\n            nodes[treeIdx] += val;  // If the segment has only one element, update it and return\\n            return;\\n        }\\n\\n        int mid = (l + r) >> 1;  // Calculate the middle index of the segment\\n\\n        if (ql <= mid) {\\n            update((treeIdx << 1) | 1, l, mid, ql, val);  // Recursively update the left subtree\\n        } else {\\n            update((treeIdx << 1) + 2, mid + 1, r, ql, val);  // Recursively update the right subtree\\n        }\\n\\n        nodes[treeIdx] = nodes[(treeIdx << 1) | 1] + nodes[(treeIdx << 1) + 2];  // Update the current node based on child nodes\\n    }\\n\\n    // Function to increase the value at a specific index in the segment tree\\n    void increase(int ql) {\\n        update(0, 0, n - 1, ql, 1);  // Start the update process from the root of the segment tree\\n    }\\n\\n    // Function to query the sum of elements in a specific range [ql, qr] in the segment tree\\n    int query(int treeIdx, int l, int r, int ql, int qr) {\\n        if (l > qr || r < ql) {\\n            return 0;  // If the current segment is completely outside the query range, return 0\\n        }\\n\\n        if (ql <= l && r <= qr) {\\n            return nodes[treeIdx];  // If the current segment is completely inside the query range, return its value\\n        }\\n\\n        int mid = (l + r) >> 1;  // Calculate the middle index of the segment\\n\\n        if (qr <= mid) {\\n            return query((treeIdx << 1) | 1, l, mid, ql, qr);  // Recursively query the left subtree\\n        } else if (ql > mid) {\\n            return query((treeIdx << 1) + 2, mid + 1, r, ql, qr);  // Recursively query the right subtree\\n        }\\n\\n        // If the query range partially overlaps with both left and right subtrees\\n        int leftRes = query((treeIdx << 1) | 1, l, mid, ql, mid);  // Query the left subtree\\n        int rightRes = query((treeIdx << 1) + 2, mid + 1, r, mid + 1, qr);  // Query the right subtree\\n\\n        return leftRes + rightRes;  // Return the sum of results from both subtrees\\n    }\\n\\n    // Function to query the sum of elements less than a given value qnum in the segment tree\\n    int queryLessThan(int qnum) {\\n        return query(0, 0, n - 1, 0, qnum - 1);  // Start the query from the root with the specified query range\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        vector<queue<int>> qs(10);  // An array of queues to store positions of each digit\\n        int n = num.size();\\n\\n        // Populate queues with the positions of each digit\\n        for (int i = 0; i < n; ++i) {\\n            qs[num[i] - \\'0\\'].push(i);\\n        }\\n\\n        string lhs;  // Left-hand side of the result string\\n        vector<bool> removed(n, false);  // Indicates if a digit has been removed from the original string\\n        SegTree* tree = new SegTree(n);  // Create a segment tree to track removed digits\\n\\n        while (k > 0) {\\n            bool found = false;\\n            for (int d = 0; d <= 9; ++d) {\\n                if (!qs[d].empty()) {\\n                    int pos = qs[d].front();  // Get the position of the current digit\\n                    int shifted = tree->queryLessThan(pos);  // Query the segment tree to find the number of removed digits before pos\\n                    if (pos - shifted <= k) {\\n                        k -= pos - shifted;  // Update remaining swaps\\n                        tree->increase(pos);  // Mark the current digit as removed in the segment tree\\n                        qs[d].pop();  // Remove the position from the queue\\n                        lhs += (\\'0\\' + d);  // Append the digit to the left-hand side\\n                        removed[pos] = true;  // Mark the digit as removed\\n                        found = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (!found) break;  // If no valid swap is possible, exit the loop\\n        }\\n\\n        string rhs;  // Right-hand side of the result string\\n        for (int i = 0; i < n; ++i) {\\n            if (!removed[i]) {\\n                rhs += num[i];  // Append the remaining digits to the right-hand side\\n            }\\n        }\\n\\n        return lhs + rhs;  // Concatenate the left-hand and right-hand sides to form the final result\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SegTree {\\npublic:\\n    vector<int> nodes;  // Array representing the segment tree\\n    int n;              // Number of elements in the original array\\n\\n    SegTree(int n) {\\n        this->n = n;\\n        nodes = vector<int>(this->n << 2);  // Initialize the segment tree with size 4 * n\\n    }\\n\\n    // Function to update a node in the segment tree\\n    void update(int treeIdx, int l, int r, int ql, int val) {\\n        if (ql < l || ql > r) {\\n            return;  // If the query index is out of the current segment, return\\n        }\\n\\n        if (l == r) {\\n            nodes[treeIdx] += val;  // If the segment has only one element, update it and return\\n            return;\\n        }\\n\\n        int mid = (l + r) >> 1;  // Calculate the middle index of the segment\\n\\n        if (ql <= mid) {\\n            update((treeIdx << 1) | 1, l, mid, ql, val);  // Recursively update the left subtree\\n        } else {\\n            update((treeIdx << 1) + 2, mid + 1, r, ql, val);  // Recursively update the right subtree\\n        }\\n\\n        nodes[treeIdx] = nodes[(treeIdx << 1) | 1] + nodes[(treeIdx << 1) + 2];  // Update the current node based on child nodes\\n    }\\n\\n    // Function to increase the value at a specific index in the segment tree\\n    void increase(int ql) {\\n        update(0, 0, n - 1, ql, 1);  // Start the update process from the root of the segment tree\\n    }\\n\\n    // Function to query the sum of elements in a specific range [ql, qr] in the segment tree\\n    int query(int treeIdx, int l, int r, int ql, int qr) {\\n        if (l > qr || r < ql) {\\n            return 0;  // If the current segment is completely outside the query range, return 0\\n        }\\n\\n        if (ql <= l && r <= qr) {\\n            return nodes[treeIdx];  // If the current segment is completely inside the query range, return its value\\n        }\\n\\n        int mid = (l + r) >> 1;  // Calculate the middle index of the segment\\n\\n        if (qr <= mid) {\\n            return query((treeIdx << 1) | 1, l, mid, ql, qr);  // Recursively query the left subtree\\n        } else if (ql > mid) {\\n            return query((treeIdx << 1) + 2, mid + 1, r, ql, qr);  // Recursively query the right subtree\\n        }\\n\\n        // If the query range partially overlaps with both left and right subtrees\\n        int leftRes = query((treeIdx << 1) | 1, l, mid, ql, mid);  // Query the left subtree\\n        int rightRes = query((treeIdx << 1) + 2, mid + 1, r, mid + 1, qr);  // Query the right subtree\\n\\n        return leftRes + rightRes;  // Return the sum of results from both subtrees\\n    }\\n\\n    // Function to query the sum of elements less than a given value qnum in the segment tree\\n    int queryLessThan(int qnum) {\\n        return query(0, 0, n - 1, 0, qnum - 1);  // Start the query from the root with the specified query range\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        vector<queue<int>> qs(10);  // An array of queues to store positions of each digit\\n        int n = num.size();\\n\\n        // Populate queues with the positions of each digit\\n        for (int i = 0; i < n; ++i) {\\n            qs[num[i] - \\'0\\'].push(i);\\n        }\\n\\n        string lhs;  // Left-hand side of the result string\\n        vector<bool> removed(n, false);  // Indicates if a digit has been removed from the original string\\n        SegTree* tree = new SegTree(n);  // Create a segment tree to track removed digits\\n\\n        while (k > 0) {\\n            bool found = false;\\n            for (int d = 0; d <= 9; ++d) {\\n                if (!qs[d].empty()) {\\n                    int pos = qs[d].front();  // Get the position of the current digit\\n                    int shifted = tree->queryLessThan(pos);  // Query the segment tree to find the number of removed digits before pos\\n                    if (pos - shifted <= k) {\\n                        k -= pos - shifted;  // Update remaining swaps\\n                        tree->increase(pos);  // Mark the current digit as removed in the segment tree\\n                        qs[d].pop();  // Remove the position from the queue\\n                        lhs += (\\'0\\' + d);  // Append the digit to the left-hand side\\n                        removed[pos] = true;  // Mark the digit as removed\\n                        found = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (!found) break;  // If no valid swap is possible, exit the loop\\n        }\\n\\n        string rhs;  // Right-hand side of the result string\\n        for (int i = 0; i < n; ++i) {\\n            if (!removed[i]) {\\n                rhs += num[i];  // Append the remaining digits to the right-hand side\\n            }\\n        }\\n\\n        return lhs + rhs;  // Concatenate the left-hand and right-hand sides to form the final result\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903770,
                "title": "c-most-intuitive",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n        if(k > n*(n+1)/2)\\n        {\\n            sort(num.begin(), num.end());\\n        }\\n\\n        for(int i=0;i<n && k >0;i++)\\n        {\\n            int pos = i;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(j-i > k)\\n                    break;\\n                if(num[j] < num[pos])\\n                    pos = j;\\n            }\\n\\n            while(pos > i)\\n            {\\n                swap(num[pos], num[pos-1]);\\n                pos--;\\n                k--;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n        if(k > n*(n+1)/2)\\n        {\\n            sort(num.begin(), num.end());\\n        }\\n\\n        for(int i=0;i<n && k >0;i++)\\n        {\\n            int pos = i;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(j-i > k)\\n                    break;\\n                if(num[j] < num[pos])\\n                    pos = j;\\n            }\\n\\n            while(pos > i)\\n            {\\n                swap(num[pos], num[pos-1]);\\n                pos--;\\n                k--;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774607,
                "title": "easy-java-solution",
                "content": "# Intuition\\nGet the minimum in window of size k that starts from i+1. bring that minimum to front and decerease k accordingly.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        char[] arr = num.toCharArray();\\n        for(int i=0; i<n; i++){\\n            if(k<=0){\\n                break;\\n            }\\n            char minChar = arr[i];\\n            int minCharIndex = -1;\\n            // System.out.println(i+\" \"+minChar+\" \"+ minCharIndex+\" \"+new String(arr));\\n            //for each index get index of min in window of k;\\n            for(int j=i+1; j<Math.min(i+k+1, n); j++){\\n                // System.out.println(minChar+\" \"+ arr[j]);\\n                if(minChar > arr[j]){\\n                    minChar = arr[j];\\n                    minCharIndex = j;\\n                }\\n            }\\n            if(minCharIndex == -1){\\n                continue;\\n            }\\n            while(minCharIndex > i){\\n                swap(arr, minCharIndex);\\n                k--;\\n                minCharIndex--;\\n            }\\n            // System.out.println(new String(arr));\\n            // System.out.println();\\n        }\\n        return new String(arr);\\n    }\\n    private void swap(char[] arr, int i){\\n        char temp = arr[i];\\n        arr[i] = arr[i-1];\\n        arr[i-1] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        char[] arr = num.toCharArray();\\n        for(int i=0; i<n; i++){\\n            if(k<=0){\\n                break;\\n            }\\n            char minChar = arr[i];\\n            int minCharIndex = -1;\\n            // System.out.println(i+\" \"+minChar+\" \"+ minCharIndex+\" \"+new String(arr));\\n            //for each index get index of min in window of k;\\n            for(int j=i+1; j<Math.min(i+k+1, n); j++){\\n                // System.out.println(minChar+\" \"+ arr[j]);\\n                if(minChar > arr[j]){\\n                    minChar = arr[j];\\n                    minCharIndex = j;\\n                }\\n            }\\n            if(minCharIndex == -1){\\n                continue;\\n            }\\n            while(minCharIndex > i){\\n                swap(arr, minCharIndex);\\n                k--;\\n                minCharIndex--;\\n            }\\n            // System.out.println(new String(arr));\\n            // System.out.println();\\n        }\\n        return new String(arr);\\n    }\\n    private void swap(char[] arr, int i){\\n        char temp = arr[i];\\n        arr[i] = arr[i-1];\\n        arr[i-1] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611810,
                "title": "simple-segment-tree-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void build(int nl, int nr, int tidx, vector<int> &nums, vector<pair<int, int>> &tree) {\\n        if(nl == nr) {\\n            tree[tidx] = {nums[nl], nl};\\n            return;\\n        }\\n        int mid = (nl+nr)/2;\\n\\n        build(nl, mid, 2*tidx+1, nums, tree);\\n        build(mid+1, nr, 2*tidx+2, nums, tree);\\n\\n        if(tree[2*tidx+1].first < tree[2*tidx+2].first)  {\\n            tree[tidx] = tree[2*tidx+1];\\n        } else if(tree[2*tidx+1].first > tree[2*tidx+2].first) {\\n            tree[tidx] = tree[2*tidx+2];\\n        } else {\\n            if(tree[2*tidx+1].second < tree[2*tidx+2].second) {\\n                tree[tidx] = tree[2*tidx+1];\\n            } else {\\n                tree[tidx] = tree[2*tidx+2]; \\n            }\\n        }\\n    }\\n\\n    void update(int nl, int nr, int tidx, int idx, vector<pair<int, int>> &tree) {\\n        if(nl == nr) {\\n            tree[tidx] = {INT_MAX, INT_MAX};\\n            return; \\n        }\\n\\n        int mid = (nl+nr)/2;\\n\\n        if(idx <= mid) {\\n            update(nl, mid, 2*tidx+1, idx, tree);\\n        } else {\\n            update(mid+1, nr, 2*tidx+2, idx, tree); \\n        }\\n\\n        if(tree[2*tidx+1].first < tree[2*tidx+2].first)  {\\n            tree[tidx] = tree[2*tidx+1];\\n        } else if(tree[2*tidx+1].first > tree[2*tidx+2].first) {\\n            tree[tidx] = tree[2*tidx+2];\\n        } else {\\n            if(tree[2*tidx+1].second < tree[2*tidx+2].second) {\\n                tree[tidx] = tree[2*tidx+1];\\n            } else {\\n                tree[tidx] = tree[2*tidx+2]; \\n            }\\n        }\\n    }\\n\\n    pair<int, int> query(int nl, int nr, int tidx, int l, int r, vector<pair<int, int>> &tree) {\\n        if(nl > r or nr < l) return {INT_MAX, INT_MAX};\\n        if(nl >= l and nr <= r) return tree[tidx];\\n\\n        int mid = (nl+nr)/2;\\n\\n        pair<int, int> left = query(nl, mid, 2*tidx+1, l, r, tree);\\n        pair<int, int> right = query(mid+1, nr, 2*tidx+2, l, r, tree);\\n\\n        if(left.first < right.first)  {\\n            return left;\\n        } else if(left.first > right.first) {\\n            return right; \\n        } else {\\n            if(left.second < right.second) {\\n                return left;\\n            } \\n        }\\n\\n        return right;\\n    }\\n\\n    void build2(int nl, int nr, int tidx, vector<int> &tree) {\\n        if(nl == nr) {\\n            tree[tidx] = 1;\\n            return; \\n        }\\n\\n        int mid = (nl+nr)/2; \\n        build2(nl, mid, 2*tidx+1, tree);\\n        build2(mid+1, nr, 2*tidx+2, tree);\\n\\n        tree[tidx] = tree[2*tidx+1] + tree[2*tidx+2];\\n    }\\n\\n    void update2(int nl, int nr, int tidx, int idx, vector<int> &tree) {\\n        if(nl == nr) {\\n            tree[tidx] = 0; \\n            return; \\n        }\\n        int mid = (nl+nr)/2; \\n\\n        if(idx <= mid){\\n            update2(nl, mid, 2*tidx+1, idx, tree);\\n        } else {\\n            update2(mid+1, nr, 2*tidx+2, idx, tree);\\n        }\\n\\n        tree[tidx] = tree[2*tidx+1] + tree[2*tidx+2];\\n    }\\n\\n    int query2(int nl, int nr, int tidx, int l, int r, vector<int> &tree) {\\n        if(nl > r or nr < l) return 0;\\n        if(nl >= l and nr <= r) return tree[tidx];\\n\\n        int mid = (nl+nr)/2;\\n        int left = query2(nl, mid, 2*tidx+1, l, r, tree);\\n        int right = query2(mid+1, nr, 2*tidx+2, l, r, tree);\\n\\n        return left + right;\\n    }  \\n\\n    int getIdx(int n, int k, vector<int> &tree, int i) {\\n        int lo = 0, hi = n-1;\\n        int idx = -1; \\n        while(lo <= hi) {\\n            int mid = (lo+hi)/2; \\n            \\n            int sum = query2(0, n-1, 0, 0, mid, tree); \\n            // if(i == 1) {\\n            //     cout<<mid<<\" \"<<sum<<\" \"<<lo<<\" \"<<hi<<\" \"<<k<<endl;\\n            // }\\n            \\n            if(sum-1 > k) {\\n                hi=mid-1; \\n            } else {\\n                idx=mid;\\n                lo=mid+1;\\n            }\\n        }\\n\\n        return idx; \\n    }\\n\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n\\n        vector<int> nums(n);\\n        for(int i = 0; i < n; i++) {\\n            nums[i] = num[i]-\\'0\\'; \\n        }\\n\\n        vector<pair<int, int>> tree1(4*n+1, {0, 0});\\n        build(0,n-1,0, nums, tree1);\\n        vector<int> tree2(4*n+1, 1); \\n        build2(0, n-1, 0, tree2); \\n\\n        string ans = num;\\n\\n        int i = 0; \\n        vector<bool> vis(n,false);\\n        while(k > 0 and i < n) {\\n            \\n            int idx = getIdx(n, k, tree2, i); \\n            pair<int, int> mini = query(0, n-1, 0, 0, idx, tree1);\\n\\n            int valIdx = mini.second;\\n            int val = mini.first;\\n            // cout<<valIdx<<endl;\\n            int temp = query2(0, n-1, 0, valIdx, n-1, tree2); \\n            int numberOfZeroes = n-valIdx-temp; \\n            \\n            int realIdx = numberOfZeroes + valIdx;\\n\\n            int reqOp = abs(i-realIdx); \\n            if(k >= reqOp) {\\n                k -= reqOp;\\n                ans[i] = num[valIdx];\\n            } else {\\n                break;\\n            }\\n\\n            update2(0, n-1, 0, valIdx, tree2);\\n            update(0, n-1, 0, valIdx, tree1);\\n\\n            vis[valIdx] = true; \\n            i++;     \\n        }\\n\\n        for(int j = 0; j < n; j++) {\\n            if(not vis[j]) {\\n                ans[i++] = num[j];\\n            }\\n        }\\n        return ans; \\n\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void build(int nl, int nr, int tidx, vector<int> &nums, vector<pair<int, int>> &tree) {\\n        if(nl == nr) {\\n            tree[tidx] = {nums[nl], nl};\\n            return;\\n        }\\n        int mid = (nl+nr)/2;\\n\\n        build(nl, mid, 2*tidx+1, nums, tree);\\n        build(mid+1, nr, 2*tidx+2, nums, tree);\\n\\n        if(tree[2*tidx+1].first < tree[2*tidx+2].first)  {\\n            tree[tidx] = tree[2*tidx+1];\\n        } else if(tree[2*tidx+1].first > tree[2*tidx+2].first) {\\n            tree[tidx] = tree[2*tidx+2];\\n        } else {\\n            if(tree[2*tidx+1].second < tree[2*tidx+2].second) {\\n                tree[tidx] = tree[2*tidx+1];\\n            } else {\\n                tree[tidx] = tree[2*tidx+2]; \\n            }\\n        }\\n    }\\n\\n    void update(int nl, int nr, int tidx, int idx, vector<pair<int, int>> &tree) {\\n        if(nl == nr) {\\n            tree[tidx] = {INT_MAX, INT_MAX};\\n            return; \\n        }\\n\\n        int mid = (nl+nr)/2;\\n\\n        if(idx <= mid) {\\n            update(nl, mid, 2*tidx+1, idx, tree);\\n        } else {\\n            update(mid+1, nr, 2*tidx+2, idx, tree); \\n        }\\n\\n        if(tree[2*tidx+1].first < tree[2*tidx+2].first)  {\\n            tree[tidx] = tree[2*tidx+1];\\n        } else if(tree[2*tidx+1].first > tree[2*tidx+2].first) {\\n            tree[tidx] = tree[2*tidx+2];\\n        } else {\\n            if(tree[2*tidx+1].second < tree[2*tidx+2].second) {\\n                tree[tidx] = tree[2*tidx+1];\\n            } else {\\n                tree[tidx] = tree[2*tidx+2]; \\n            }\\n        }\\n    }\\n\\n    pair<int, int> query(int nl, int nr, int tidx, int l, int r, vector<pair<int, int>> &tree) {\\n        if(nl > r or nr < l) return {INT_MAX, INT_MAX};\\n        if(nl >= l and nr <= r) return tree[tidx];\\n\\n        int mid = (nl+nr)/2;\\n\\n        pair<int, int> left = query(nl, mid, 2*tidx+1, l, r, tree);\\n        pair<int, int> right = query(mid+1, nr, 2*tidx+2, l, r, tree);\\n\\n        if(left.first < right.first)  {\\n            return left;\\n        } else if(left.first > right.first) {\\n            return right; \\n        } else {\\n            if(left.second < right.second) {\\n                return left;\\n            } \\n        }\\n\\n        return right;\\n    }\\n\\n    void build2(int nl, int nr, int tidx, vector<int> &tree) {\\n        if(nl == nr) {\\n            tree[tidx] = 1;\\n            return; \\n        }\\n\\n        int mid = (nl+nr)/2; \\n        build2(nl, mid, 2*tidx+1, tree);\\n        build2(mid+1, nr, 2*tidx+2, tree);\\n\\n        tree[tidx] = tree[2*tidx+1] + tree[2*tidx+2];\\n    }\\n\\n    void update2(int nl, int nr, int tidx, int idx, vector<int> &tree) {\\n        if(nl == nr) {\\n            tree[tidx] = 0; \\n            return; \\n        }\\n        int mid = (nl+nr)/2; \\n\\n        if(idx <= mid){\\n            update2(nl, mid, 2*tidx+1, idx, tree);\\n        } else {\\n            update2(mid+1, nr, 2*tidx+2, idx, tree);\\n        }\\n\\n        tree[tidx] = tree[2*tidx+1] + tree[2*tidx+2];\\n    }\\n\\n    int query2(int nl, int nr, int tidx, int l, int r, vector<int> &tree) {\\n        if(nl > r or nr < l) return 0;\\n        if(nl >= l and nr <= r) return tree[tidx];\\n\\n        int mid = (nl+nr)/2;\\n        int left = query2(nl, mid, 2*tidx+1, l, r, tree);\\n        int right = query2(mid+1, nr, 2*tidx+2, l, r, tree);\\n\\n        return left + right;\\n    }  \\n\\n    int getIdx(int n, int k, vector<int> &tree, int i) {\\n        int lo = 0, hi = n-1;\\n        int idx = -1; \\n        while(lo <= hi) {\\n            int mid = (lo+hi)/2; \\n            \\n            int sum = query2(0, n-1, 0, 0, mid, tree); \\n            // if(i == 1) {\\n            //     cout<<mid<<\" \"<<sum<<\" \"<<lo<<\" \"<<hi<<\" \"<<k<<endl;\\n            // }\\n            \\n            if(sum-1 > k) {\\n                hi=mid-1; \\n            } else {\\n                idx=mid;\\n                lo=mid+1;\\n            }\\n        }\\n\\n        return idx; \\n    }\\n\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n\\n        vector<int> nums(n);\\n        for(int i = 0; i < n; i++) {\\n            nums[i] = num[i]-\\'0\\'; \\n        }\\n\\n        vector<pair<int, int>> tree1(4*n+1, {0, 0});\\n        build(0,n-1,0, nums, tree1);\\n        vector<int> tree2(4*n+1, 1); \\n        build2(0, n-1, 0, tree2); \\n\\n        string ans = num;\\n\\n        int i = 0; \\n        vector<bool> vis(n,false);\\n        while(k > 0 and i < n) {\\n            \\n            int idx = getIdx(n, k, tree2, i); \\n            pair<int, int> mini = query(0, n-1, 0, 0, idx, tree1);\\n\\n            int valIdx = mini.second;\\n            int val = mini.first;\\n            // cout<<valIdx<<endl;\\n            int temp = query2(0, n-1, 0, valIdx, n-1, tree2); \\n            int numberOfZeroes = n-valIdx-temp; \\n            \\n            int realIdx = numberOfZeroes + valIdx;\\n\\n            int reqOp = abs(i-realIdx); \\n            if(k >= reqOp) {\\n                k -= reqOp;\\n                ans[i] = num[valIdx];\\n            } else {\\n                break;\\n            }\\n\\n            update2(0, n-1, 0, valIdx, tree2);\\n            update(0, n-1, 0, valIdx, tree1);\\n\\n            vis[valIdx] = true; \\n            i++;     \\n        }\\n\\n        for(int j = 0; j < n; j++) {\\n            if(not vis[j]) {\\n                ans[i++] = num[j];\\n            }\\n        }\\n        return ans; \\n\\n    }   \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3393147,
                "title": "python-simple-bit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT:\\n    def __init__(self,n):\\n        self.ans = [0]*(n+1)\\n\\n    def query(self,i):\\n        res = 0\\n        while i > 0:\\n            res += self.ans[i]\\n            i -= i&-i\\n        return res\\n\\n    def update(self,i,val):\\n        while i < len(self.ans):\\n            self.ans[i] += val\\n            i += i&-i\\n\\nclass Solution:\\n    def minInteger(self, num, k):\\n        n, dict1, res = len(num), defaultdict(deque), \"\"\\n\\n        for i,x in enumerate(num):\\n            dict1[x].append(i)\\n\\n        result = BIT(n)\\n\\n        for i in range(n):\\n            result.update(i+1,1)\\n\\n        for i in range(n):\\n            for v in \"0123456789\":\\n                if dict1[v]:\\n                    idx = dict1[v][0]\\n                    cnt = result.query(idx)\\n                    if cnt <= k:\\n                        dict1[v].popleft()\\n                        k -= cnt\\n                        res += v\\n                        result.update(idx+1,-1)\\n                        break\\n\\n        return res\\n\\n\\n        \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass BIT:\\n    def __init__(self,n):\\n        self.ans = [0]*(n+1)\\n\\n    def query(self,i):\\n        res = 0\\n        while i > 0:\\n            res += self.ans[i]\\n            i -= i&-i\\n        return res\\n\\n    def update(self,i,val):\\n        while i < len(self.ans):\\n            self.ans[i] += val\\n            i += i&-i\\n\\nclass Solution:\\n    def minInteger(self, num, k):\\n        n, dict1, res = len(num), defaultdict(deque), \"\"\\n\\n        for i,x in enumerate(num):\\n            dict1[x].append(i)\\n\\n        result = BIT(n)\\n\\n        for i in range(n):\\n            result.update(i+1,1)\\n\\n        for i in range(n):\\n            for v in \"0123456789\":\\n                if dict1[v]:\\n                    idx = dict1[v][0]\\n                    cnt = result.query(idx)\\n                    if cnt <= k:\\n                        dict1[v].popleft()\\n                        k -= cnt\\n                        res += v\\n                        result.update(idx+1,-1)\\n                        break\\n\\n        return res\\n\\n\\n        \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281150,
                "title": "c-segment-tree-with-46ms-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    string ans;\\n    int tree[12*10001],lazy[12*10001],count;\\n    void Lazy(int id)\\n    {\\n        tree[id*2]+=lazy[id];\\n        lazy[id*2]+=lazy[id];\\n        tree[id*2+1]+=lazy[id];\\n        lazy[id*2+1]+=lazy[id];\\n        lazy[id]=0;\\n    }\\n    void update(int id,int l,int r,int x,int y)\\n    {\\n        if(l>y||r<x) return;\\n        if(l>=x&&r<=y)\\n        {\\n            tree[id]++;\\n            lazy[id]++;\\n            return;\\n        }\\n        int mid=(l+r)/2;\\n        Lazy(id);\\n        update(id*2,l,mid,x,y);\\n        update(id*2+1,mid+1,r,x,y);\\n        tree[id]++;\\n    }\\n    int query(int id,int l,int r,int x)\\n    {\\n        if(l>x||r<x) return 0;\\n        if(l==r) return tree[id];\\n        int mid=(l+r)/2;\\n        Lazy(id);\\n        return query(id*2,l,mid,x)+query(id*2+1,mid+1,r,x);\\n    }\\n    string minInteger(string & num, int k) {\\n        vector<queue<int>> A(10);\\n        vector<int> kt(num.size(),0);\\n        for(int i=0;i<=num.size()-1;i++)\\n            A[int(num[i])-\\'0\\'].push(i);\\n        for(int i=0;i<=num.size()-1;i++)\\n        {\\n            if(k==0) break;\\n            for(int j=0;j<=9;j++)\\n            {\\n                if(A[j].empty()!=0) continue;\\n                count=A[j].front()+query(1,0,num.size()-1,A[j].front())-i;\\n                if(count<=k)\\n                {\\n                    kt[A[j].front()]=1;\\n                    ans+=num[A[j].front()];\\n                    k=k-count;\\n                    update(1,0,num.size()-1,0,A[j].front());\\n                    A[j].pop();\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0;i<=num.size()-1;i++)\\n        {\\n            if(kt[i]==0) ans+=num[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string ans;\\n    int tree[12*10001],lazy[12*10001],count;\\n    void Lazy(int id)\\n    {\\n        tree[id*2]+=lazy[id];\\n        lazy[id*2]+=lazy[id];\\n        tree[id*2+1]+=lazy[id];\\n        lazy[id*2+1]+=lazy[id];\\n        lazy[id]=0;\\n    }\\n    void update(int id,int l,int r,int x,int y)\\n    {\\n        if(l>y||r<x) return;\\n        if(l>=x&&r<=y)\\n        {\\n            tree[id]++;\\n            lazy[id]++;\\n            return;\\n        }\\n        int mid=(l+r)/2;\\n        Lazy(id);\\n        update(id*2,l,mid,x,y);\\n        update(id*2+1,mid+1,r,x,y);\\n        tree[id]++;\\n    }\\n    int query(int id,int l,int r,int x)\\n    {\\n        if(l>x||r<x) return 0;\\n        if(l==r) return tree[id];\\n        int mid=(l+r)/2;\\n        Lazy(id);\\n        return query(id*2,l,mid,x)+query(id*2+1,mid+1,r,x);\\n    }\\n    string minInteger(string & num, int k) {\\n        vector<queue<int>> A(10);\\n        vector<int> kt(num.size(),0);\\n        for(int i=0;i<=num.size()-1;i++)\\n            A[int(num[i])-\\'0\\'].push(i);\\n        for(int i=0;i<=num.size()-1;i++)\\n        {\\n            if(k==0) break;\\n            for(int j=0;j<=9;j++)\\n            {\\n                if(A[j].empty()!=0) continue;\\n                count=A[j].front()+query(1,0,num.size()-1,A[j].front())-i;\\n                if(count<=k)\\n                {\\n                    kt[A[j].front()]=1;\\n                    ans+=num[A[j].front()];\\n                    k=k-count;\\n                    update(1,0,num.size()-1,0,A[j].front());\\n                    A[j].pop();\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0;i<=num.size()-1;i++)\\n        {\\n            if(kt[i]==0) ans+=num[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162681,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_integer(num: String, k: i32) -> String {\\n        let mut k = k as usize;\\n        let num = num.into_bytes();\\n        let n = num.len();\\n        let mut res = Vec::with_capacity(n);\\n        let mut q = vec![n; 10];\\n        for (i, &item) in num.iter().enumerate() {\\n            let d = (item - b\\'0\\') as usize;\\n            if q[d] == n {\\n                q[d] = i;\\n            }\\n        }\\n        let mut used = vec![false; n];\\n        let mut q_used = vec![0; 10];\\n        for _ in 0..n {\\n            for d in 0..10_usize {\\n                if q[d] == n {\\n                    continue;\\n                }\\n                let c = q[d] - q_used[d];\\n                if c <= k {\\n                    k -= c;\\n                    res.push(b\\'0\\' + d as u8);\\n                    used[q[d]] = true;\\n                    for d1 in 0..10_usize {\\n                        if q[d1] > q[d] {\\n                            q_used[d1] += 1;\\n                        }\\n                    }\\n                    while q[d] < n {\\n                        if used[q[d]] {\\n                            q_used[d] += 1;\\n                        }\\n                        q[d] += 1;\\n                        let &c = num.get(q[d]).unwrap_or(&0_u8);\\n                        if c == b\\'0\\' + d as u8 {\\n                            break;\\n                        }\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        String::from_utf8(res).unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_integer(num: String, k: i32) -> String {\\n        let mut k = k as usize;\\n        let num = num.into_bytes();\\n        let n = num.len();\\n        let mut res = Vec::with_capacity(n);\\n        let mut q = vec![n; 10];\\n        for (i, &item) in num.iter().enumerate() {\\n            let d = (item - b\\'0\\') as usize;\\n            if q[d] == n {\\n                q[d] = i;\\n            }\\n        }\\n        let mut used = vec![false; n];\\n        let mut q_used = vec![0; 10];\\n        for _ in 0..n {\\n            for d in 0..10_usize {\\n                if q[d] == n {\\n                    continue;\\n                }\\n                let c = q[d] - q_used[d];\\n                if c <= k {\\n                    k -= c;\\n                    res.push(b\\'0\\' + d as u8);\\n                    used[q[d]] = true;\\n                    for d1 in 0..10_usize {\\n                        if q[d1] > q[d] {\\n                            q_used[d1] += 1;\\n                        }\\n                    }\\n                    while q[d] < n {\\n                        if used[q[d]] {\\n                            q_used[d] += 1;\\n                        }\\n                        q[d] += 1;\\n                        let &c = num.get(q[d]).unwrap_or(&0_u8);\\n                        if c == b\\'0\\' + d as u8 {\\n                            break;\\n                        }\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        String::from_utf8(res).unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3064438,
                "title": "o-nlogn-a-sortedlist-and-10-queues",
                "content": "# Intuition\\nIterating from the left, we want to find the smallest reacheable digit and put it on each place.\\n\\n# Approach\\nWe keep 10 queues, containing sequences of indices for each digit. At each step we pick the smallest digit that is not further than `k` steps away. After that we remove it from its queue, and reduce `k` by the number of steps used.\\n\\nThe question, then, rises, how to recalculate the correct indices and distances after a digit is removed from its place. Of course, we don\\'t want to modify the queues, that would be too slow. But, it can be seen that the correction to every index is simply the number of used indices to the left of it, which we can calculate efficiently with `SortedList`.\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$, dominated by `SortedList` operations, at most `n` inserts and `n` bisections. Technically, `SortedList` has larger [time complexity](https://grantjenks.com/docs/sortedcontainers/performance-scale.html), but in practice it is fast.\\n\\n- Space complexity: $$O(n)$$, one `SortedList` and 10 queues each\\n\\n# Code\\n```\\nfrom collections import deque\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        N = len(num)\\n        lists = [deque() for _ in range(10)]\\n        for i,c in enumerate(num):\\n            lists[int(c)].append(i)\\n        res = []\\n        used = SortedList()\\n        unused = set(range(N))\\n        while k and len(res) < N:\\n            for d in range(10):\\n                if not lists[d]:\\n                    continue\\n                i = lists[d][0]\\n                i -= used.bisect_left(i)\\n                if i <= k:\\n                    k -= i\\n                    i = lists[d].popleft()\\n                    used.add(i)\\n                    unused.remove(i)\\n                    res.append(i)\\n                    break\\n        res.extend(unused)\\n        return \\'\\'.join(num[x] for x in res)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        N = len(num)\\n        lists = [deque() for _ in range(10)]\\n        for i,c in enumerate(num):\\n            lists[int(c)].append(i)\\n        res = []\\n        used = SortedList()\\n        unused = set(range(N))\\n        while k and len(res) < N:\\n            for d in range(10):\\n                if not lists[d]:\\n                    continue\\n                i = lists[d][0]\\n                i -= used.bisect_left(i)\\n                if i <= k:\\n                    k -= i\\n                    i = lists[d].popleft()\\n                    used.add(i)\\n                    unused.remove(i)\\n                    res.append(i)\\n                    break\\n        res.extend(unused)\\n        return \\'\\'.join(num[x] for x in res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006259,
                "title": "python-sliding-window-avl-tree-solution-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain a window of size ```k``` in a AVL Tree, pop out the minimum element in the index in $$O(log(n))$$ time, find its index, decrement ```k``` accordingly until ```k``` becomes ```0```.\\n\\n# Complexity\\n- Time complexity: $$O(n * log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        sz, window = len(num), SortedList()\\n        remainedIndices, poppedIndices = SortedList(range(sz)), []\\n        while k > 0:\\n            while len(window) < k + 1 and len(window) < len(remainedIndices):\\n                idx = remainedIndices[len(window)]\\n                window.add((num[idx], idx))\\n            if not window:\\n                break\\n            index = window.pop(0)[1]\\n            k -= remainedIndices.bisect_left(index)\\n            remainedIndices.remove(index)\\n            poppedIndices.append(index)\\n            for idx in remainedIndices[k + 1: len(window)]:\\n                window.remove((num[idx], idx))\\n        poppedSet = set(poppedIndices)\\n        return \"\".join(num[idx] for idx in poppedIndices) + \"\".join(num[idx] for idx in range(sz) if idx not in poppedSet)\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Greedy",
                    "Binary Search Tree",
                    "Sliding Window"
                ],
                "code": "```k```\n```k```\n```k```\n```0```\n```python []\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        sz, window = len(num), SortedList()\\n        remainedIndices, poppedIndices = SortedList(range(sz)), []\\n        while k > 0:\\n            while len(window) < k + 1 and len(window) < len(remainedIndices):\\n                idx = remainedIndices[len(window)]\\n                window.add((num[idx], idx))\\n            if not window:\\n                break\\n            index = window.pop(0)[1]\\n            k -= remainedIndices.bisect_left(index)\\n            remainedIndices.remove(index)\\n            poppedIndices.append(index)\\n            for idx in remainedIndices[k + 1: len(window)]:\\n                window.remove((num[idx], idx))\\n        poppedSet = set(poppedIndices)\\n        return \"\".join(num[idx] for idx in poppedIndices) + \"\".join(num[idx] for idx in range(sz) if idx not in poppedSet)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903739,
                "title": "dart-solution-o-n-2-linkedlist",
                "content": "# Intuition\\nWhen swapping (similar to bubble sort) numbers in a string - we should start minimising number from the left side by swapping every digit with the lowest possible number from the remaining ight side within the K limit.\\n\\n\\n# Approach\\n\\nWhile the idea is prerry simple I faced timeout error on submission when result was kept in the array (List<int>) and swapping was perfomed by internal cycle.\\nReplacing array with the LinkedList (where swap costs O(1) instead of O(N) ) helped to submit solution within the Leetcode time limits.\\n\\n# Complexity\\n- Time complexity:\\nO(N*N)\\n\\n- Space complexity:\\nO(N) for the linked list\\n\\n# Code\\n```\\n\\nimport \\'dart:collection\\';\\n\\nclass IntEntry extends LinkedListEntry<IntEntry> {\\n  int val;\\n  IntEntry(this.val);\\n}\\n\\nclass Solution {\\n  static int zeroCode = \\'0\\'.codeUnitAt(0);\\n\\n  String minInteger(String num, int k) {\\n    int L = num.length;\\n    if (L == 0) return \"\";\\n\\n    final List<int> arr = num.codeUnits.map((e) => e - zeroCode).toList();\\n    final LinkedList<IntEntry> lst = LinkedList<IntEntry>();\\n    lst.addAll(arr.map((e) => IntEntry(e)));\\n\\n    int i = 0;\\n    int r = k;\\n\\n    IntEntry next = lst.first;\\n    while (next.next != null && r > 0) {\\n      int swapLess = 0;\\n      var minIdx = 0;\\n      var minPtr = next;\\n\\n      var findMinIdx = 1;\\n      var findMinPtr = next.next;\\n\\n      for (;\\n          findMinPtr != null && findMinIdx <= r;\\n          findMinPtr = findMinPtr.next, findMinIdx++)\\n        if (findMinPtr.val < minPtr.val) {\\n          minPtr = findMinPtr;\\n          minIdx = findMinIdx;\\n        }\\n\\n      if (minPtr != next) {\\n        r -= minIdx;\\n        minPtr.unlink();\\n        next.insertBefore(minPtr);\\n      } else\\n        next = next.next!;\\n    }\\n\\n    final ret = StringBuffer();\\n    lst.forEach((entry) {\\n      ret.write(entry.val);\\n    });\\n    return ret.toString();\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\n\\nimport \\'dart:collection\\';\\n\\nclass IntEntry extends LinkedListEntry<IntEntry> {\\n  int val;\\n  IntEntry(this.val);\\n}\\n\\nclass Solution {\\n  static int zeroCode = \\'0\\'.codeUnitAt(0);\\n\\n  String minInteger(String num, int k) {\\n    int L = num.length;\\n    if (L == 0) return \"\";\\n\\n    final List<int> arr = num.codeUnits.map((e) => e - zeroCode).toList();\\n    final LinkedList<IntEntry> lst = LinkedList<IntEntry>();\\n    lst.addAll(arr.map((e) => IntEntry(e)));\\n\\n    int i = 0;\\n    int r = k;\\n\\n    IntEntry next = lst.first;\\n    while (next.next != null && r > 0) {\\n      int swapLess = 0;\\n      var minIdx = 0;\\n      var minPtr = next;\\n\\n      var findMinIdx = 1;\\n      var findMinPtr = next.next;\\n\\n      for (;\\n          findMinPtr != null && findMinIdx <= r;\\n          findMinPtr = findMinPtr.next, findMinIdx++)\\n        if (findMinPtr.val < minPtr.val) {\\n          minPtr = findMinPtr;\\n          minIdx = findMinIdx;\\n        }\\n\\n      if (minPtr != next) {\\n        r -= minIdx;\\n        minPtr.unlink();\\n        next.insertBefore(minPtr);\\n      } else\\n        next = next.next!;\\n    }\\n\\n    final ret = StringBuffer();\\n    lst.forEach((entry) {\\n      ret.write(entry.val);\\n    });\\n    return ret.toString();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851740,
                "title": "o-nlogn-sliding-window-and-avl-tree",
                "content": "```\\n        from sortedcontainers import SortedList\\n\\n        n = len(num)\\n        window = SortedList()  # sliding window of size k + 1, store (value, index) of num\\n        remains = SortedList(range(n))  # remained remains\\n        pops = []  # popped indices\\n\\n        while k > 0:\\n            # add to keep window size to k + 1\\n            while len(window) < k + 1 and len(window) < len(remains):\\n                _ = remains[len(window)]\\n                window.add((num[_], _))\\n\\n            # empty window, break\\n            if not window:\\n                break\\n\\n            # pop minimum value\\n            index = window.pop(0)[1]\\n            k -= remains.bisect_left(index)\\n            remains.remove(index)\\n            pops.append(index)\\n\\n            # remove to keep window size to k + 1\\n            for _ in remains[k + 1: len(window)]:\\n                window.remove((num[_], _))\\n\\n        s0 = set(pops)\\n        return \"\".join(num[j] for j in pops) + \"\".join(num[j] for j in range(n) if j not in s0)\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n        from sortedcontainers import SortedList\\n\\n        n = len(num)\\n        window = SortedList()  # sliding window of size k + 1, store (value, index) of num\\n        remains = SortedList(range(n))  # remained remains\\n        pops = []  # popped indices\\n\\n        while k > 0:\\n            # add to keep window size to k + 1\\n            while len(window) < k + 1 and len(window) < len(remains):\\n                _ = remains[len(window)]\\n                window.add((num[_], _))\\n\\n            # empty window, break\\n            if not window:\\n                break\\n\\n            # pop minimum value\\n            index = window.pop(0)[1]\\n            k -= remains.bisect_left(index)\\n            remains.remove(index)\\n            pops.append(index)\\n\\n            # remove to keep window size to k + 1\\n            for _ in remains[k + 1: len(window)]:\\n                window.remove((num[_], _))\\n\\n        s0 = set(pops)\\n        return \"\".join(num[j] for j in pops) + \"\".join(num[j] for j in range(n) if j not in s0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2669347,
                "title": "c-segment-tree-explained-solution",
                "content": "```\\n/*\\n\\nswap any two adjacent digits atmost k times -> minimum integer formed after this??\\n\\nwill greedy approach works here ?\\n\\nbringing all smaller no\\' ahead as possible as\\n \\n \\n(bring that smallest no. here which is towards right of it and can be brought here within k steps) () () ()...\\n\\n\\nValue of k decreases..\\n\\n(.)(bring that smallest no. here which is towards right of it and can be brought here within remaining k steps) () () () () () ...\\n\\nValue of k decreases..\\n\\nand so on till k>0\\n\\n\\nNOTE:\\n\\n7683(1)67 => (1)768367\\n\\n\\nby doing this, index of all no\\'s toward left of (1) increases by 1\\n\\n\\n O(n*n), for each position i, check minimum digit within the range (among next k digits) , and put that minimum digit at this position\\n\\n O(n logn) , for each position i, we check Is it possible to place any digit [0-9] at this position, let we can place \\'3\\' at this position , and index of this \\'3\\' is idx, so no. of swaps we needs to do to bring \\'3\\' from index idx towards left to index i = idx- (no of digits from [0,idx] that have already used)\\n\\nif we are at index i, it means we are already done with [0...i-1]\\n\\n\\n let num= 872124652 , k=20\\n\\n S.T = 0 0 0 0 0 0 0 0 0\\n \\n num= 872124652\\n for i=0, 872124652 => ans=1(87224652)\\n nextIdx=3, alreadyUsed=0, countSwap=3-0=3, k=k-3=17\\n S.T = 0 0 0 1 0 0 0 0 0\\n \\n num= 872124652\\n for i=1, 1|87224652  => ans=12(8724652)\\n nextIdx=2, alreadyUsed=0, countSwap=2-0=2, k=17-2=15\\n S.T = 0 0 1 1 0 0 0 0 0\\n \\n num= 872124652\\n for i=2, 12|8724652 => ans=122(874652)\\n nextIdx=4, alreadyUsed=2, countSwap=4-2=2, k=15-2=13\\n  S.T = 0 0 1 1 1 0 0 0 0\\n\\n num= 87212465(2)\\n for i=3, 122|874652 => ans=1222(87465)\\n nextIdx=8, alreadyUsed=3, countSwap=8-3=5, k=13-5=8\\n  S.T = 0 0 1 1 1 0 0 0 1\\n\\nnum= 87212(4)652\\n for i=4, 1222|87465 => ans=12224(8765)\\n nextIdx=5, alreadyUsed=3, countSwap=5-3=2, k=8-2=6\\n S.T = 0 0 1 1 1 1 0 0 1\\n \\n num= 8721246(5)2\\n for i=5, 12224|8765 => ans=122245(876)\\n nextIdx=7, alreadyUsed=4, countSwap=7-4=3, k=6-3=3\\n S.T = 0 0 1 1 1 1 0 1 1\\n \\n  num= 872124(6)52\\n for i=5, 122245|876 => ans=1222456(87)\\n nextIdx=6, alreadyUsed=4, countSwap=6-4=2, k=3-2=1\\n S.T = 0 0 1 1 1 1 1 1 1\\n \\n num= 8(7)2124652\\n for i=5, 1222456|87 => ans=12224567(8)\\n nextIdx=1, alreadyUsed=0, countSwap=1-0=1, k=1-1=0\\n S.T = 0 1 1 1 1 1 1 1 1\\n \\n k=0\\n \\n return ans=122245678 \\n\\n\\n\\n to keep track of how many digits have been used in range [0....idx] we use segment tree\\n\\n let we shifting digit at index i1 or using digit at index i1 at any left side index , than we update our segment tree by adding 1 at index i1 in the segment tree \\n\\n*/\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        \\n    int n=num.length();\\n    \\n    if(k>n*n){\\n        sort(num.begin(),num.end());\\n        \\n        return num;\\n    }\\n        \\n        \\nunordered_map<int,deque<int>>mp;\\n        \\nint arr[n];\\n        \\n        for(int i=0;i<n;i++){\\n            arr[i]=0;\\n        }\\n        \\nint *st=constructST(arr,n);\\n        \\n        for(int i=0;i<n;i++){\\n            mp[num[i]-\\'0\\'].push_back(i);\\n        }\\n       \\n        string ans;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            for(int d=0;d<=9;d++){\\n                \\n                if(mp[d].size()>0){\\n                    \\n                    int nextIdx=mp[d].front();\\n                    \\n                    // no. of digits that already used\\n                    int alreadyUsed=getsum(st,0,0,n-1,0,nextIdx);\\n                    \\n                    int countSwap=nextIdx-alreadyUsed;\\n                    \\n                    if(k>=countSwap){\\n                        ans+=to_string(d);\\n                        mp[d].pop_front();\\n                        k-=countSwap;\\n                        update(st,0,0,n-1,nextIdx,1);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        return ans;\\n    \\n    }\\n    \\n    \\n    \\nvoid update(int *st,int si,int sl,int sr,int pos,int diff)\\n{\\nif(sl>pos || sr<pos)\\nreturn ;\\nst[si]=st[si]+diff;\\nif(sl!=sr){\\nint mid=(sl+sr)/2;\\nupdate(st,2*si+1,sl,mid,pos,diff);\\nupdate(st,2*si+2,mid+1,sr,pos,diff);\\n}}\\n\\n\\n\\nint getsum(int *st,int si,int sl,int sr,int l,int r)\\n{\\nif(l<=sl && r>=sr)\\nreturn st[si];\\nif(l>sr || r<sl)\\nreturn 0;\\nint mid=(sl+sr)/2;\\nreturn (getsum(st,2*si+1,sl,mid,l,r)+\\ngetsum(st,2*si+2,mid+1,sr,l,r));\\n}\\n\\n\\n\\nint constructSTUL(int *st,int si,int arr[],int l,int r){\\nif(l==r){\\nst[si]=arr[l];\\nreturn arr[l];\\n}\\nint mid=(l+r)/2;\\n\\nst[si]=(constructSTUL(st,2*si+1,arr,l,mid)\\n+ constructSTUL(st,2*si+2,arr,mid+1,r));\\nreturn st[si];\\n}\\n\\n\\n\\nint *constructST(int arr[],int n){\\n\\nint h=(int)(ceil(log2(n)));\\nint max_size_st=2*(int)pow(2,h)-1;\\nint *st=new int[max_size_st];\\n\\nconstructSTUL(st,0,arr,0,n-1);\\n\\nreturn st;\\n}\\n\\n};",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "class Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        \\n    int n=num.length();\\n    \\n    if(k>n*n){\\n        sort(num.begin(),num.end());\\n        \\n        return num;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2610988,
                "title": "segment-tree-bit-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int Do(int a,int b,string &s){\\n        if(a==s.size())return b;\\n        if(b==s.size())return a;\\n        if(s[a]<=s[b])return a;\\n        return b;\\n    }\\n    \\n    void build(vector<int> &seg,int si,int sl,int sr,string &s){\\n        if(sl==sr){\\n            seg[si]=sl;\\n            return;\\n        }\\n        \\n        int mid=(sl+sr)/2;\\n        build(seg,2*si,sl,mid,s);\\n        build(seg,2*si+1,mid+1,sr,s);\\n        seg[si]=Do(\\n            seg[si*2],\\n            seg[si*2+1],\\n            s\\n        );\\n        \\n    }\\n    \\n    \\n    int Q(vector<int> &seg,int si,int sl,int sr,int l,int r,string &s){\\n        if(l>r)return s.size();\\n        if(sl==l and sr==r)return seg[si];\\n        int mid=(sl+sr)/2;\\n        return Do(\\n            Q(seg,si*2,sl,mid,l,min(mid,r),s),\\n            Q(seg,si*2+1,mid+1,sr,max(l,mid+1),r,s),\\n            s\\n        );\\n    }\\n    \\n    void update(vector<int> &seg,int si,int sl,int sr,int ind,char val,string &s){\\n        if(sl==sr){\\n            s[ind]=val;\\n            seg[si]=sl;\\n            return ;\\n        }\\n        \\n        int mid=(sl+sr)/2;\\n        if(ind<=mid)update(seg,si*2,sl,mid,ind,val,s);\\n        else update(seg,si*2+1,mid+1,sr,ind,val,s);\\n        seg[si]=Do(seg[si*2],seg[si*2+1],s);\\n    }\\n    \\n    int sum(int ind,vector<int> &BIT){\\n        if(ind<0)return 0;\\n        return BIT[ind]+sum((ind&(ind+1))-1,BIT);\\n    }\\n    \\n    void updateBIT(int ind,vector<int> &BIT,int val){\\n        if(ind>=BIT.size())return;\\n        BIT[ind]+=val;\\n        updateBIT(ind|(ind+1),BIT,val);\\n    }\\n    \\n    int DO(int k,vector<int> &BIT){\\n        int l=0,r=BIT.size()-1;\\n        int ans;\\n        while(l<=r){\\n            int mid=(l+r)/2;\\n            if(sum(mid,BIT)<=k)ans=mid,l=mid+1;\\n            else r=mid-1;\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    string minInteger(string num, int k) {\\n        int n=num.size();\\n        vector<int> seg(4*n);\\n        build(seg,1,0,n-1,num);\\n        vector<int> BIT(n);\\n        for(int i=0;i<n;i++)updateBIT(i,BIT,1);\\n        \\n        string ans;\\n        vector<int> vis(n,0);\\n        for(int i=0;i<n;i++){\\n            int ind=DO(k+1,BIT);\\n            int aind=Q(seg,1,0,n-1,0,ind,num);\\n            ans+=num[aind];\\n            update(seg,1,0,n-1,aind,(\\'9\\'+1),num);\\n            int sumi=sum(aind,BIT);\\n            k-=sumi;\\n            k++;\\n            updateBIT(aind,BIT,-1);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int Do(int a,int b,string &s){\\n        if(a==s.size())return b;\\n        if(b==s.size())return a;\\n        if(s[a]<=s[b])return a;\\n        return b;\\n    }\\n    \\n    void build(vector<int> &seg,int si,int sl,int sr,string &s){\\n        if(sl==sr){\\n            seg[si]=sl;\\n            return;\\n        }\\n        \\n        int mid=(sl+sr)/2;\\n        build(seg,2*si,sl,mid,s);\\n        build(seg,2*si+1,mid+1,sr,s);\\n        seg[si]=Do(\\n            seg[si*2],\\n            seg[si*2+1],\\n            s\\n        );\\n        \\n    }\\n    \\n    \\n    int Q(vector<int> &seg,int si,int sl,int sr,int l,int r,string &s){\\n        if(l>r)return s.size();\\n        if(sl==l and sr==r)return seg[si];\\n        int mid=(sl+sr)/2;\\n        return Do(\\n            Q(seg,si*2,sl,mid,l,min(mid,r),s),\\n            Q(seg,si*2+1,mid+1,sr,max(l,mid+1),r,s),\\n            s\\n        );\\n    }\\n    \\n    void update(vector<int> &seg,int si,int sl,int sr,int ind,char val,string &s){\\n        if(sl==sr){\\n            s[ind]=val;\\n            seg[si]=sl;\\n            return ;\\n        }\\n        \\n        int mid=(sl+sr)/2;\\n        if(ind<=mid)update(seg,si*2,sl,mid,ind,val,s);\\n        else update(seg,si*2+1,mid+1,sr,ind,val,s);\\n        seg[si]=Do(seg[si*2],seg[si*2+1],s);\\n    }\\n    \\n    int sum(int ind,vector<int> &BIT){\\n        if(ind<0)return 0;\\n        return BIT[ind]+sum((ind&(ind+1))-1,BIT);\\n    }\\n    \\n    void updateBIT(int ind,vector<int> &BIT,int val){\\n        if(ind>=BIT.size())return;\\n        BIT[ind]+=val;\\n        updateBIT(ind|(ind+1),BIT,val);\\n    }\\n    \\n    int DO(int k,vector<int> &BIT){\\n        int l=0,r=BIT.size()-1;\\n        int ans;\\n        while(l<=r){\\n            int mid=(l+r)/2;\\n            if(sum(mid,BIT)<=k)ans=mid,l=mid+1;\\n            else r=mid-1;\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    string minInteger(string num, int k) {\\n        int n=num.size();\\n        vector<int> seg(4*n);\\n        build(seg,1,0,n-1,num);\\n        vector<int> BIT(n);\\n        for(int i=0;i<n;i++)updateBIT(i,BIT,1);\\n        \\n        string ans;\\n        vector<int> vis(n,0);\\n        for(int i=0;i<n;i++){\\n            int ind=DO(k+1,BIT);\\n            int aind=Q(seg,1,0,n-1,0,ind,num);\\n            ans+=num[aind];\\n            update(seg,1,0,n-1,aind,(\\'9\\'+1),num);\\n            int sumi=sum(aind,BIT);\\n            k-=sumi;\\n            k++;\\n            updateBIT(aind,BIT,-1);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570852,
                "title": "c-segment-tree-o-nlogn-cleanest-code",
                "content": "```\\nclass SegTree {\\npublic:\\n    vector<int> nodes;\\n    int n;\\n\\n    //constructor\\n    SegTree(int n) {\\n        this->n = n;\\n        nodes = vector<int>(this->n << 2);\\n    }\\n\\n    void update(int ss, int se, int ql, int idx, int val) {\\n        //update[ql,ql]\\n        if (ql<ss or ql>se) {\\n            return;\\n        }\\n        if (ss == se) {\\n            nodes[idx] += val;\\n            return;\\n        }\\n        int mid = (ss + se) >> 1;\\n        update(ss, mid, ql, 2 * idx + 1, val);\\n        update(mid + 1, se, ql, 2 * idx + 2, val);\\n        nodes[idx] = nodes[2 * idx + 1] + nodes[2 * idx + 2];\\n    }\\n\\n    int query(int ss, int se, int ql, int qr, int idx) {\\n        //ql aur qr ke beech me answer nikal\\n        if (ql > se or qr < ss) {\\n            return 0;\\n        }\\n        if (ql <= ss and se <= qr) {\\n            return nodes[idx];\\n        }\\n        int mid = (ss + se) >> 1;\\n        int lt = query(ss, mid, ql, qr, 2 * idx + 1);\\n        int rt = query(mid + 1, se, ql, qr, 2 * idx + 2);\\n        return lt + rt;\\n    }\\n    int querylessthan(int pos) {\\n        return query(0, n - 1, 0, pos - 1, 0); //query left is 0 and query right is pos-1\\n    }\\n    void increase(int pos) {\\n        update(0, n - 1, pos, 0, 1);\\n    }\\n};\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        string ans = \"\";\\n        int n = num.size();\\n        SegTree* tree = new SegTree(n);\\n        vector<queue<int>> qs(10);\\n        for (int i = 0; i < n; i++) {\\n            qs[num[i] - \\'0\\'].push(i); //pushing back the positions for each digit from 0 to 9\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int d = 0; d <= 9; d++) {\\n                if (qs[d].empty() == false) {\\n                    int pos = qs[d].front();\\n                    \\n\\n                    /*Explanation\\n                     Since few numbers already shifted to left, this `pos` might be outdated,so we try to find how many numbers already got shifted that were to the left of pos.\\n                    int shifted = seg.getCountLessThan(pos);\\n                    (pos - shift) is number of steps to make digit d move from pos to i.\\n\\n                    */\\n\\t\\t\\t\\t\\t/*how many digits infront of this position \"pos\" has been moved to the right position*/\\n                    if (pos - shifted <= k) {\\n                        k -= (pos - shifted);\\n                        tree->increase(pos);\\n                        qs[d].pop();\\n                        ans += d + \\'0\\';\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass SegTree {\\npublic:\\n    vector<int> nodes;\\n    int n;\\n\\n    //constructor\\n    SegTree(int n) {\\n        this->n = n;\\n        nodes = vector<int>(this->n << 2);\\n    }\\n\\n    void update(int ss, int se, int ql, int idx, int val) {\\n        //update[ql,ql]\\n        if (ql<ss or ql>se) {\\n            return;\\n        }\\n        if (ss == se) {\\n            nodes[idx] += val;\\n            return;\\n        }\\n        int mid = (ss + se) >> 1;\\n        update(ss, mid, ql, 2 * idx + 1, val);\\n        update(mid + 1, se, ql, 2 * idx + 2, val);\\n        nodes[idx] = nodes[2 * idx + 1] + nodes[2 * idx + 2];\\n    }\\n\\n    int query(int ss, int se, int ql, int qr, int idx) {\\n        //ql aur qr ke beech me answer nikal\\n        if (ql > se or qr < ss) {\\n            return 0;\\n        }\\n        if (ql <= ss and se <= qr) {\\n            return nodes[idx];\\n        }\\n        int mid = (ss + se) >> 1;\\n        int lt = query(ss, mid, ql, qr, 2 * idx + 1);\\n        int rt = query(mid + 1, se, ql, qr, 2 * idx + 2);\\n        return lt + rt;\\n    }\\n    int querylessthan(int pos) {\\n        return query(0, n - 1, 0, pos - 1, 0); //query left is 0 and query right is pos-1\\n    }\\n    void increase(int pos) {\\n        update(0, n - 1, pos, 0, 1);\\n    }\\n};\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        string ans = \"\";\\n        int n = num.size();\\n        SegTree* tree = new SegTree(n);\\n        vector<queue<int>> qs(10);\\n        for (int i = 0; i < n; i++) {\\n            qs[num[i] - \\'0\\'].push(i); //pushing back the positions for each digit from 0 to 9\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int d = 0; d <= 9; d++) {\\n                if (qs[d].empty() == false) {\\n                    int pos = qs[d].front();\\n                    \\n\\n                    /*Explanation\\n                     Since few numbers already shifted to left, this `pos` might be outdated,so we try to find how many numbers already got shifted that were to the left of pos.\\n                    int shifted = seg.getCountLessThan(pos);\\n                    (pos - shift) is number of steps to make digit d move from pos to i.\\n\\n                    */\\n\\t\\t\\t\\t\\t/*how many digits infront of this position \"pos\" has been moved to the right position*/\\n                    if (pos - shifted <= k) {\\n                        k -= (pos - shifted);\\n                        tree->increase(pos);\\n                        qs[d].pop();\\n                        ans += d + \\'0\\';\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2539404,
                "title": "c-o-nlogn-segment-tree",
                "content": "```\\nclass Solution {\\n    class SegTree {\\n        vector<int> st;\\n        int siz;\\n\\n        void upd(int i, int k) {\\n            i += siz;\\n            st[i]+= k;\\n            i /= 2;\\n            while (i > 0) {\\n                st[i] = st[i * 2] + st[i * 2 + 1];\\n                i /= 2;\\n            }\\n        }\\n        int qry(int l, int r) {\\n            l += siz;\\n            r += siz;\\n            int ans = 0;\\n            while (l <= r) {\\n                if (l % 2 == 1) ans += st[l++];\\n                if (r % 2 == 0) ans += st[r--];\\n                l /= 2;\\n                r /= 2;\\n            }\\n            return ans;\\n        }\\n\\n       public:\\n        SegTree(int n) {\\n            n++;\\n            siz = 1 << int(ceil(log2(n)));\\n            st.resize(siz * 2, 0);\\n        }\\n        int query(int i) {  // elements shifted from 0 to i -> prefix sum from 0 to i\\n            return qry(0, i);\\n        }\\n        void update(int i) {  // shift ith element to first position -> add 1 to 0 to i\\n            upd(0, 1);\\n            upd(i + 1, -1);\\n        }\\n    };\\n\\n   public:\\n    string minInteger(string s, int k) {\\n        int n = s.size();\\n        vector<vector<int>> pos(10);\\n        for (int i = 0; i < n; i++)\\n            pos[s[i] - \\'0\\'].push_back(i);\\n        for (int dig = 0; dig < 10; dig++)\\n            reverse(pos[dig].begin(), pos[dig].end());\\n        SegTree st(n);\\n        string ans;\\n        int i = 0;\\n        while (k > 0 && i < n) {\\n            for (int dig = 0; dig < 10; dig++) {\\n                if (pos[dig].empty()) continue;\\n                int p = pos[dig].back();\\n                int actual = p + st.query(p);\\n                if (actual <= i + k) {\\n                    pos[dig].pop_back();\\n                    ans += to_string(dig);\\n                    st.update(p);\\n                    k -= actual - i;\\n                    break;\\n                }\\n            }\\n            i++;\\n        }\\n        vector<pair<int, int>> v;\\n        for (int dig = 0; dig < 10; dig++) {\\n            while (pos[dig].size()) {\\n                v.push_back({pos[dig].back(), dig});\\n                pos[dig].pop_back();\\n            }\\n        }\\n        sort(v.begin(), v.end());\\n        for (auto &[p, d] : v)\\n            ans += to_string(d);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class SegTree {\\n        vector<int> st;\\n        int siz;\\n\\n        void upd(int i, int k) {\\n            i += siz;\\n            st[i]+= k;\\n            i /= 2;\\n            while (i > 0) {\\n                st[i] = st[i * 2] + st[i * 2 + 1];\\n                i /= 2;\\n            }\\n        }\\n        int qry(int l, int r) {\\n            l += siz;\\n            r += siz;\\n            int ans = 0;\\n            while (l <= r) {\\n                if (l % 2 == 1) ans += st[l++];\\n                if (r % 2 == 0) ans += st[r--];\\n                l /= 2;\\n                r /= 2;\\n            }\\n            return ans;\\n        }\\n\\n       public:\\n        SegTree(int n) {\\n            n++;\\n            siz = 1 << int(ceil(log2(n)));\\n            st.resize(siz * 2, 0);\\n        }\\n        int query(int i) {  // elements shifted from 0 to i -> prefix sum from 0 to i\\n            return qry(0, i);\\n        }\\n        void update(int i) {  // shift ith element to first position -> add 1 to 0 to i\\n            upd(0, 1);\\n            upd(i + 1, -1);\\n        }\\n    };\\n\\n   public:\\n    string minInteger(string s, int k) {\\n        int n = s.size();\\n        vector<vector<int>> pos(10);\\n        for (int i = 0; i < n; i++)\\n            pos[s[i] - \\'0\\'].push_back(i);\\n        for (int dig = 0; dig < 10; dig++)\\n            reverse(pos[dig].begin(), pos[dig].end());\\n        SegTree st(n);\\n        string ans;\\n        int i = 0;\\n        while (k > 0 && i < n) {\\n            for (int dig = 0; dig < 10; dig++) {\\n                if (pos[dig].empty()) continue;\\n                int p = pos[dig].back();\\n                int actual = p + st.query(p);\\n                if (actual <= i + k) {\\n                    pos[dig].pop_back();\\n                    ans += to_string(dig);\\n                    st.update(p);\\n                    k -= actual - i;\\n                    break;\\n                }\\n            }\\n            i++;\\n        }\\n        vector<pair<int, int>> v;\\n        for (int dig = 0; dig < 10; dig++) {\\n            while (pos[dig].size()) {\\n                v.push_back({pos[dig].back(), dig});\\n                pos[dig].pop_back();\\n            }\\n        }\\n        sort(v.begin(), v.end());\\n        for (auto &[p, d] : v)\\n            ans += to_string(d);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460086,
                "title": "python-code",
                "content": "```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        num = list(num)\\n        BIT = [0] *(n+1)\\n        counter = defaultdict(deque)\\n        for idx, val in enumerate(num):\\n            counter[val].append(idx)\\n        def update(i,x):\\n            while i< len(BIT):\\n                BIT[i] +=x\\n                i += i & -i\\n        def query(i):\\n            res = 0\\n            while i>0:\\n                res +=BIT[i]\\n                i -= i&-i\\n            return res\\n        ans = []\\n        used = [False]*n\\n        while k>0 and len(ans)<n:\\n            for d in list(\\'0123456789\\'):\\n                if not counter[d]:\\n                    continue\\n                index = counter[d][0]\\n                offset = query(index)\\n                if index - offset >k:\\n                    continue\\n                if index - offset <=k:\\n                    k -= index-offset\\n                    ans.append(d)\\n                    counter[d].popleft()\\n                    update (index+1, 1)\\n                    used[index] = True\\n                    break\\n        for i in range(n):\\n            if not used[i]:\\n                ans +=num[i]\\n        return \\'\\'.join(ans)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        num = list(num)\\n        BIT = [0] *(n+1)\\n        counter = defaultdict(deque)\\n        for idx, val in enumerate(num):\\n            counter[val].append(idx)\\n        def update(i,x):\\n            while i< len(BIT):\\n                BIT[i] +=x\\n                i += i & -i\\n        def query(i):\\n            res = 0\\n            while i>0:\\n                res +=BIT[i]\\n                i -= i&-i\\n            return res\\n        ans = []\\n        used = [False]*n\\n        while k>0 and len(ans)<n:\\n            for d in list(\\'0123456789\\'):\\n                if not counter[d]:\\n                    continue\\n                index = counter[d][0]\\n                offset = query(index)\\n                if index - offset >k:\\n                    continue\\n                if index - offset <=k:\\n                    k -= index-offset\\n                    ans.append(d)\\n                    counter[d].popleft()\\n                    update (index+1, 1)\\n                    used[index] = True\\n                    break\\n        for i in range(n):\\n            if not used[i]:\\n                ans +=num[i]\\n        return \\'\\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399591,
                "title": "java-o-nlogn-30ms-check-pos-by-pos-not-digit-by-digit",
                "content": "#### Wrong Strategy\\nInitially I tried to arrange all the 0s first, then 1s, 2s ..., but that strategy is flawed when there are multiple identical numbers together like \"235288888...1\" It is because when we are looking at number 1, we conclude that the last 1 can\\'t be moved to the head of whatever current is, so we skipped it, but then when we get to 8, due to it being .. 88888 .. , we incur 0 cost to add them, then 1 becomes doable to switch to the current head when previously we\\'ve concluded that it can\\'t be done - **ERROR (44/50 testcase passed)**. This only works if there is no adjcent identical characters and run in `O(10N)`\\n\\n#### Correct Strategy\\nSo then, I decided to check position by position, for each position, I need the best digit, but for this approach, we\\'ve got a problem to deal with. How do we know how many elements to the **right** of the current digit has been swapped? We care only care about those to the **right** because it pushes the current digit to the right when they pass it. In the **Wrong Strategy** section, I dealt with this by just simple suffix sum update, one update takes `O(N)` and for 10 times, in total, `O(10N)`. That approach is not possible here because the outer loop is now position, so we need a Binary Index Tree, making the whole problem solvable in `O(NlogN)`.\\n\\nI am using a queue to keep track of the index of the first number that hasn\\'t been used. It can be shown that the first index is always the better choice.\\n\\n```Java\\n// Time O(NlogN) [30ms submitted once]\\n// Space O(N)\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] A = num.toCharArray();\\n        int[] bit = new int[A.length+2];\\n        Queue<Integer>[] queue = new ArrayDeque[10];\\n        Arrays.setAll(queue, o -> new ArrayDeque<>());\\n        for (int i = 0; i < A.length; i++){ // track indexes for each digit\\n            queue[A[i]-\\'0\\'].offer(i);\\n        }\\n        for (int i = 0; i < A.length; i++){ // solve for each position\\n            for (int j = 0; j < 10; j++){ // from the best to worst\\n                if (!queue[j].isEmpty()){\\n                    int cost = queue[j].peek() - i + (i - sum(bit, queue[j].peek())); // cost needed to move to the head.\\n                    if (cost <= k){\\n                        k -= cost;\\n                        sb.append(j);\\n                        add(bit, queue[j].poll(), 1);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\n    private void add(int[] bit, int idx, int inc){\\n        for (++idx; idx < bit.length; idx += idx & -idx){\\n            bit[idx]+=inc;\\n        }\\n    }\\n\\n    private int sum(int[] bit, int idx){\\n        int ans = 0;\\n        for (++idx; idx > 0; idx -= idx & -idx){\\n            ans += bit[idx];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\n// Time O(NlogN) [30ms submitted once]\\n// Space O(N)\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] A = num.toCharArray();\\n        int[] bit = new int[A.length+2];\\n        Queue<Integer>[] queue = new ArrayDeque[10];\\n        Arrays.setAll(queue, o -> new ArrayDeque<>());\\n        for (int i = 0; i < A.length; i++){ // track indexes for each digit\\n            queue[A[i]-\\'0\\'].offer(i);\\n        }\\n        for (int i = 0; i < A.length; i++){ // solve for each position\\n            for (int j = 0; j < 10; j++){ // from the best to worst\\n                if (!queue[j].isEmpty()){\\n                    int cost = queue[j].peek() - i + (i - sum(bit, queue[j].peek())); // cost needed to move to the head.\\n                    if (cost <= k){\\n                        k -= cost;\\n                        sb.append(j);\\n                        add(bit, queue[j].poll(), 1);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\n    private void add(int[] bit, int idx, int inc){\\n        for (++idx; idx < bit.length; idx += idx & -idx){\\n            bit[idx]+=inc;\\n        }\\n    }\\n\\n    private int sum(int[] bit, int idx){\\n        int ans = 0;\\n        for (++idx; idx > 0; idx -= idx & -idx){\\n            ans += bit[idx];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397016,
                "title": "my-intuitive-java-solution",
                "content": "```\\nclass Solution {\\n    public String minInteger(String s, int k) {\\n        int length = s.length();\\n        int[] num = new int[length];\\n        int i = 0;\\n        for(char ch : s.toCharArray()) \\n            num[i++] = Integer.parseInt(String.valueOf(ch));\\n        \\n\\t\\tfor (i = 0; i < length && k > 0; i++){\\n\\t\\t\\tint minIndex = 0, min = Integer.MAX_VALUE;\\n\\n\\t\\t\\tint limit = (k + i) > length - 1 ? length - 1 : k + i;\\n\\n\\t\\t\\tfor(int j = i; j <= limit; j++){\\n\\t\\t\\t\\tif (num[j] < min){\\n\\t\\t\\t\\t\\tmin = num[j];\\n\\t\\t\\t\\t\\tminIndex = j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tk -= (minIndex - i);\\n\\t\\t\\tfor(int idx = minIndex; idx > i; idx--) {\\n\\t\\t\\t\\tint temp = num[idx - 1];\\n\\t\\t\\t\\tnum[idx - 1] = num[idx];\\n\\t\\t\\t\\tnum[idx] = temp;\\n\\t\\t\\t}\\n\\t\\t}\\n        StringBuilder ans = new StringBuilder(\"\");\\n        for(int n : num) ans.append(n);\\n\\t\\treturn ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String minInteger(String s, int k) {\\n        int length = s.length();\\n        int[] num = new int[length];\\n        int i = 0;\\n        for(char ch : s.toCharArray()) \\n            num[i++] = Integer.parseInt(String.valueOf(ch));\\n        \\n\\t\\tfor (i = 0; i < length && k > 0; i++){\\n\\t\\t\\tint minIndex = 0, min = Integer.MAX_VALUE;\\n\\n\\t\\t\\tint limit = (k + i) > length - 1 ? length - 1 : k + i;\\n\\n\\t\\t\\tfor(int j = i; j <= limit; j++){\\n\\t\\t\\t\\tif (num[j] < min){\\n\\t\\t\\t\\t\\tmin = num[j];\\n\\t\\t\\t\\t\\tminIndex = j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tk -= (minIndex - i);\\n\\t\\t\\tfor(int idx = minIndex; idx > i; idx--) {\\n\\t\\t\\t\\tint temp = num[idx - 1];\\n\\t\\t\\t\\tnum[idx - 1] = num[idx];\\n\\t\\t\\t\\tnum[idx] = temp;\\n\\t\\t\\t}\\n\\t\\t}\\n        StringBuilder ans = new StringBuilder(\"\");\\n        for(int n : num) ans.append(n);\\n\\t\\treturn ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178682,
                "title": "o-nlogn-segment-tree-binary-search",
                "content": "For a given swap count `k`, if we are currently at index `i` of our array `nums`, we wish to find the minimum element in `nums` that is `<= k` swaps away from index `i`, and bubble it up to `i`\\'s position, eating up some number of swaps along the way. We repeatedly do this until we have either:\\n- exhausted all swaps\\n- exhausted all digits in `nums`\\n\\nThe fact that we are trying to find a minimum value within some prescribed interval range should immediately suggest we leverage a segment tree (`min` is binary, associative operation), where the minimum value stored for an internal/parent node is the minimum of the minimum values stored by it\\'s two children:\\n```\\nparent min = min(left child min, right child min)\\n```\\n\\nThere are a couple of subtleties to be mindful of, which we discuss below.\\n\\n**ACCEPTABLE INDEX INTERVAL**\\nSuppose we have performed a bunch of swaps so far. How do we determine which range of original indexes in `nums` we should be searching our segment tree for the next round of swaps, if we have `k` swaps left? \\n\\nLet\\'s maintain a sorted list `free` of the original indexes of unused values in `nums`, throughout the swapping rounds (by unused, we simply mean the value at this original index has not been bubbled up towards the front yet). Then, the index interval `[free[0], free[k]]` is certainly what we care about (note, if `k > len(free)`, then right-hand endpoint will be `free[n-1]`). This is because we are guaranteed everything we removed from `free` during prior rounds, will precede `free[0]` in our final semi-sorted result, and so the corresponding digits for `free[0], free[1], ..., free[k]` should currently be contiguous after those earlier swaps were performed. By restricting to the first `k+1` such, we are ensured we don\\'t go beyond `k` swaps for this upcoming round.\\n\\nHowever, we want to make sure, when searching our segment tree for the minimum value in this interval `[free[0], free[k]]`, we don\\'t take into account any indexes in this interval that were previously used. We treat this next.\\n\\n**\"DELETION\" OF NODES**\\nWhenever we have used an original index `i`, we want to make sure it won\\'t be eligible in future swapping rounds. How can we easily achieve this? Since our segment tree is keeping track of minimums over index subintervals of `nums`, we should:\\n- search for the segment tree node corresponding to the index `i` we just used\\n- set the min value for this tree node to infinity\\n- parent back up, using the same update rule we did during building of the tree (i.e. `parent min = min(left child min, right child min)`)\\n\\nBy doing this, whenever we later search for a minimum value in some prescribed index range `[a, b]` which contains previously used index `i`, we know `nums[i]` will no longer contribute to this answer since we artificially made it too large in our tree, effectively deleting it from the segment tree (for the purpose of lookups).\\n\\nWe now know:\\n- which subinterval to restrict our segment tree search for a min value; it will depending on the number of remaining swaps `k` and our maintained sorted list of currently free/unused indexes\\n- how to avoid re-using previously used indexes that fall into such a search interval;  \"delete\" the corresponding leaf node from the segment tree by updating the value to something large, and propagate this update to ancestor nodes\\n\\nSo we can easily get the minimum we care about. But once we have it and swapped it forward, how do we know how many swaps are remaining after?\\n\\n\\n**UPDATING REMAINING SWAPS: BINARY SEARCH**\\nAs we\\'ve vaguely discussed so far, our segment tree is returning the minimum free value within a restricted index interval of interest (the restriction being the number of swaps we have remaining). Although this gives us the next value to bubble up, it yields no information about how many swaps actually got used, hence gives us no way to update the remaining swaps after this round.\\n\\nRather than returning the minimum free value within some interval `[free[0], free[k]]`, our segment tree should return the _index of_ the minimum free value within that interval. Suppose we get free index `j`, then we know at most  `j - free[0]` swaps were performed, and we simply need to deduct the number of indexes in `[free[0], j]` that were already used/swapped in prior rounds. \\n\\nFor this, let\\'s just maintain a complementary sorted list to `free`, call it `used`. We can easily binary search for the number of elements in range `[free[0], j]` that are in `used`, denote this value `u`. Then this means the number of swaps we used to bubble up `nums[j]` was precisely:\\n```\\nj - free[0] - u\\n```\\nand that\\'s what we update our remaining swap count `k` to for the next round.\\n\\n**CODE**\\n```\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        \\n        # CORNER CASE: able to handle the worst case scenario of sorting a reverse sorted list\\n        if k >= n * (n - 1) // 2:\\n            return \"\".join(sorted(num))\\n        \\n        nums = [int(x) for x in num]\\n        \\n        # segment tree data structures and methods\\n        min_val = [float(\"inf\")] * 4 * n\\n        min_index = [float(\"inf\")] * 4 * n\\n        \\n        def build(node: int, l: int, r: int):\\n            # CASE 1: arrived at a leaf node\\n            if l == r:\\n                min_val[node] = nums[l]\\n                min_index[node] = l\\n                return\\n            # CASE 2: still at an internal node, recurse down\\n            mid = (l + r) // 2\\n            left_child = 2 * node + 1\\n            right_child = left_child + 1\\n            build(left_child, l, mid)\\n            build(right_child, mid + 1, r)\\n            update(node)\\n        \\n        def update(node: int):\\n            \"\"\"\\n            update rule for internal/parent node in segment tree. In case, minima for children\\n            is a tie, left child wins, since this results in fewer swaps to move corresponding digit in nums forward.\\n            \"\"\"\\n            left_child = 2 * node + 1\\n            right_child = left_child + 1\\n            if min_val[left_child] <= min_val[right_child]:\\n                winner = left_child\\n            else:\\n                winner = right_child\\n            min_val[node] = min_val[winner]\\n            min_index[node] = min_index[winner]\\n        \\n        def lookup(node: int, l: int, r: int, desired_l: int, desired_r: int):\\n            \"\"\"\\n            Return\\'s the index in nums of the currently smallest value in range [desired_l, desired_r]\\n            \"\"\"\\n            # CASE 1: out of bounds\\n            if l > desired_r or r < desired_l:\\n                return None\\n            # CASE 2: containment of node\\'s interval [l,r] inside of [desired_l, desired_r]\\n            if desired_l <= l and r <= desired_r:\\n                return min_index[node]\\n\\t\\t    # CASE 3: intersection of node\\'s interval [l, r] with [desired_l, desired_r]\\n            mid = (l + r) // 2\\n            left_child = 2 * node + 1\\n            right_child = left_child + 1\\n            left_res = lookup(left_child, l,  mid, desired_l, desired_r)\\n            right_res = lookup(right_child, mid + 1, r, desired_l, desired_r)\\n            if left_res is None:\\n                return right_res\\n            if right_res is None:\\n                return left_res\\n            if nums[left_res] <= nums[right_res]:\\n                return left_res\\n            else:\\n                return right_res\\n        \\n        def delete(node: int, l: int, r: int, target: int):\\n            \"\"\"\\n            Update\\'s segment tree leaf corresponding to index target in nums to be infinity, \\n            and updates parent node values on the way back up recursive call stack\\n            \"\"\"\\n            # CASE 1: out of bounds\\n            if l > target or r < target:\\n                return\\n            # CASE 2: at the target leaf\\n            if l == r:\\n                min_val[node] = float(\"inf\")\\n                nums[target] = float(\"inf\")\\n                return\\n            # CASE 3: internal node whose interval [l, r] contains target\\n            mid = (l + r) // 2\\n            if target <= mid:\\n                left_child = 2 * node + 1\\n                delete(left_child, l, mid, target)\\n            else:\\n                right_child = 2 * node + 2\\n                delete(right_child, mid + 1, r, target)\\n            update(node)\\n        \\n        # STEP 1: build the segment tree\\n        build(0, 0, n-1)\\n        \\n        \\n        # STEP 2: While we have swaps available, greedily pick the smallest allowed value possible\\n        # to swap into current position in our result\\n        res = []\\n        free = SortedList([i for i in range(n)])\\n        used = SortedList()\\n        while k > 0 and len(res) < n:\\n            # Find allowed range of indexes in the original array to search for a free minimum\\n            left_index = free[0]\\n            r = min(k, len(free) - 1)\\n            right_index = free[r]\\n            # Get the index of the swapped in element in nums, update our final result, and \"delete\" from segment tree\\n            next_index = lookup(0, 0, n - 1, left_index, right_index) \\n            res.append(str(nums[next_index]))\\n            delete(0, 0, n - 1, next_index)\\n            # Determine precisely how many swaps occurred to bubble up nums[next_index]\\n            intervening_that_were_used = used.bisect_right(next_index) - used.bisect_right(left_index)\\n            swaps = next_index - left_index - intervening_that_were_used\\n            k -= swaps\\n            # Update our sorted lists of used and unused elements\\n            free.remove(next_index)\\n            used.add(next_index)\\n        \\n        # STEP 3: any indices i which were not used, tack on nums[i] IN ORDER, since no more swaps allowed\\n        for i in range(n):\\n            if nums[i] == float(\"inf\"):\\n                continue\\n            res.append(str(nums[i]))\\n        return \"\".join(res)\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nparent min = min(left child min, right child min)\\n```\n```\\nj - free[0] - u\\n```\n```\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        \\n        # CORNER CASE: able to handle the worst case scenario of sorting a reverse sorted list\\n        if k >= n * (n - 1) // 2:\\n            return \"\".join(sorted(num))\\n        \\n        nums = [int(x) for x in num]\\n        \\n        # segment tree data structures and methods\\n        min_val = [float(\"inf\")] * 4 * n\\n        min_index = [float(\"inf\")] * 4 * n\\n        \\n        def build(node: int, l: int, r: int):\\n            # CASE 1: arrived at a leaf node\\n            if l == r:\\n                min_val[node] = nums[l]\\n                min_index[node] = l\\n                return\\n            # CASE 2: still at an internal node, recurse down\\n            mid = (l + r) // 2\\n            left_child = 2 * node + 1\\n            right_child = left_child + 1\\n            build(left_child, l, mid)\\n            build(right_child, mid + 1, r)\\n            update(node)\\n        \\n        def update(node: int):\\n            \"\"\"\\n            update rule for internal/parent node in segment tree. In case, minima for children\\n            is a tie, left child wins, since this results in fewer swaps to move corresponding digit in nums forward.\\n            \"\"\"\\n            left_child = 2 * node + 1\\n            right_child = left_child + 1\\n            if min_val[left_child] <= min_val[right_child]:\\n                winner = left_child\\n            else:\\n                winner = right_child\\n            min_val[node] = min_val[winner]\\n            min_index[node] = min_index[winner]\\n        \\n        def lookup(node: int, l: int, r: int, desired_l: int, desired_r: int):\\n            \"\"\"\\n            Return\\'s the index in nums of the currently smallest value in range [desired_l, desired_r]\\n            \"\"\"\\n            # CASE 1: out of bounds\\n            if l > desired_r or r < desired_l:\\n                return None\\n            # CASE 2: containment of node\\'s interval [l,r] inside of [desired_l, desired_r]\\n            if desired_l <= l and r <= desired_r:\\n                return min_index[node]\\n\\t\\t    # CASE 3: intersection of node\\'s interval [l, r] with [desired_l, desired_r]\\n            mid = (l + r) // 2\\n            left_child = 2 * node + 1\\n            right_child = left_child + 1\\n            left_res = lookup(left_child, l,  mid, desired_l, desired_r)\\n            right_res = lookup(right_child, mid + 1, r, desired_l, desired_r)\\n            if left_res is None:\\n                return right_res\\n            if right_res is None:\\n                return left_res\\n            if nums[left_res] <= nums[right_res]:\\n                return left_res\\n            else:\\n                return right_res\\n        \\n        def delete(node: int, l: int, r: int, target: int):\\n            \"\"\"\\n            Update\\'s segment tree leaf corresponding to index target in nums to be infinity, \\n            and updates parent node values on the way back up recursive call stack\\n            \"\"\"\\n            # CASE 1: out of bounds\\n            if l > target or r < target:\\n                return\\n            # CASE 2: at the target leaf\\n            if l == r:\\n                min_val[node] = float(\"inf\")\\n                nums[target] = float(\"inf\")\\n                return\\n            # CASE 3: internal node whose interval [l, r] contains target\\n            mid = (l + r) // 2\\n            if target <= mid:\\n                left_child = 2 * node + 1\\n                delete(left_child, l, mid, target)\\n            else:\\n                right_child = 2 * node + 2\\n                delete(right_child, mid + 1, r, target)\\n            update(node)\\n        \\n        # STEP 1: build the segment tree\\n        build(0, 0, n-1)\\n        \\n        \\n        # STEP 2: While we have swaps available, greedily pick the smallest allowed value possible\\n        # to swap into current position in our result\\n        res = []\\n        free = SortedList([i for i in range(n)])\\n        used = SortedList()\\n        while k > 0 and len(res) < n:\\n            # Find allowed range of indexes in the original array to search for a free minimum\\n            left_index = free[0]\\n            r = min(k, len(free) - 1)\\n            right_index = free[r]\\n            # Get the index of the swapped in element in nums, update our final result, and \"delete\" from segment tree\\n            next_index = lookup(0, 0, n - 1, left_index, right_index) \\n            res.append(str(nums[next_index]))\\n            delete(0, 0, n - 1, next_index)\\n            # Determine precisely how many swaps occurred to bubble up nums[next_index]\\n            intervening_that_were_used = used.bisect_right(next_index) - used.bisect_right(left_index)\\n            swaps = next_index - left_index - intervening_that_were_used\\n            k -= swaps\\n            # Update our sorted lists of used and unused elements\\n            free.remove(next_index)\\n            used.add(next_index)\\n        \\n        # STEP 3: any indices i which were not used, tack on nums[i] IN ORDER, since no more swaps allowed\\n        for i in range(n):\\n            if nums[i] == float(\"inf\"):\\n                continue\\n            res.append(str(nums[i]))\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100827,
                "title": "python-fenwick-tree-solution",
                "content": "```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        tr = [0 for i in range(n+1)]\\n        def add(ind,d):\\n            while ind<=n:\\n                tr[ind] += d\\n                ind += -ind&ind\\n        def query(ind):\\n            res = 0\\n            while ind:\\n                res += tr[ind]\\n                ind -= -ind&ind\\n            return res\\n        \\n        pm = [[]for i in range(10)]\\n        for i in range(n-1,-1,-1):\\n            pm[ord(num[i]) - ord(\\'0\\')].append(i)\\n        ans = \"\"\\n        for i in range(n):\\n            for j in range(10):\\n                if pm[j]:\\n                    cnt = query(n) - query(pm[j][-1]+1)\\n                    if pm[j][-1] - i + cnt <= k:\\n                        k -= pm[j][-1] - i + cnt\\n                        ans += str(j)\\n                        add(pm[j][-1]+1,1)\\n                        pm[j].pop()\\n                        break\\n        return ans\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        tr = [0 for i in range(n+1)]\\n        def add(ind,d):\\n            while ind<=n:\\n                tr[ind] += d\\n                ind += -ind&ind\\n        def query(ind):\\n            res = 0\\n            while ind:\\n                res += tr[ind]\\n                ind -= -ind&ind\\n            return res\\n        \\n        pm = [[]for i in range(10)]\\n        for i in range(n-1,-1,-1):\\n            pm[ord(num[i]) - ord(\\'0\\')].append(i)\\n        ans = \"\"\\n        for i in range(n):\\n            for j in range(10):\\n                if pm[j]:\\n                    cnt = query(n) - query(pm[j][-1]+1)\\n                    if pm[j][-1] - i + cnt <= k:\\n                        k -= pm[j][-1] - i + cnt\\n                        ans += str(j)\\n                        add(pm[j][-1]+1,1)\\n                        pm[j].pop()\\n                        break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092084,
                "title": "c-segment-tree-greedy-o-nlogn-time",
                "content": "```\\n/* \\n    Time: O(nlogn)\\n    Space: O(n)\\n    Tag: Segment Tree, Greedy (put the possible feasible smallest index in place of cur index), Queue\\n    Difficulty: H (Both Logic and Implementation)\\n*/\\n\\nclass SegmentTree {\\n    vector<int> tree;\\n\\npublic:\\n    SegmentTree(int size) {\\n        tree.resize(4 * size + 1, 0);\\n    }\\n\\n    void printTree() {\\n        for (int num : tree) cout << num << \"\";\\n        cout << endl;\\n    }\\n\\n    void updateTree(int lo, int hi, int index, int upd) {\\n        if (upd < lo || upd > hi) return;\\n        if (lo == hi) {\\n            tree[index]++;\\n            return;\\n        }\\n        int mid = lo + (hi - lo) / 2;\\n        updateTree(lo, mid, 2 * index, upd);\\n        updateTree(mid + 1, hi, 2 * index + 1, upd);\\n        tree[index] = tree[2 * index] + tree[2 * index + 1];\\n    }\\n\\n    int queryTree(int lo, int hi, int index, int qs, int qe) {\\n        if (qe < lo || qs > hi) return 0;\\n        if (qe >= hi && qs <= lo) return tree[index];\\n\\n        int mid = lo + (hi - lo) / 2;\\n\\n        int left = queryTree(lo, mid, 2 * index, qs, qe);\\n        int right = queryTree(mid + 1, hi, 2 * index + 1, qs, qe);\\n        return left + right;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        queue<int> pos[10];\\n        for (int i = 0; i < num.length(); i++) {\\n            pos[num[i] - \\'0\\'].push(i);\\n        }\\n        string res = \"\";\\n        SegmentTree *seg = new SegmentTree((int)num.length());\\n        for (int i = 0; i < num.length(); i++) {\\n            if (num[i] == \\'-\\') continue;\\n            int digit = num[i] - \\'0\\';\\n\\n            bool swapped = false;\\n            for (int j = 0; j < digit; j++) {\\n                if (pos[j].size() > 0) {\\n                    int curNumIndex = pos[j].front();\\n                    int shifts = seg->queryTree(0, num.length() - 1, 1, i, pos[j].front());\\n\\n                    if (curNumIndex - i - shifts <= k) {\\n                        seg->updateTree(0, num.length() - 1, 1, curNumIndex);\\n                        k -= curNumIndex - i - shifts;\\n                        pos[j].pop();\\n                        res += num[curNumIndex];\\n                        num[curNumIndex] = \\'-\\';\\n                        swapped = true;\\n                        i--;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (!swapped) {\\n                res += num[i];\\n                pos[digit].pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Tree",
                    "Queue"
                ],
                "code": "```\\n/* \\n    Time: O(nlogn)\\n    Space: O(n)\\n    Tag: Segment Tree, Greedy (put the possible feasible smallest index in place of cur index), Queue\\n    Difficulty: H (Both Logic and Implementation)\\n*/\\n\\nclass SegmentTree {\\n    vector<int> tree;\\n\\npublic:\\n    SegmentTree(int size) {\\n        tree.resize(4 * size + 1, 0);\\n    }\\n\\n    void printTree() {\\n        for (int num : tree) cout << num << \"\";\\n        cout << endl;\\n    }\\n\\n    void updateTree(int lo, int hi, int index, int upd) {\\n        if (upd < lo || upd > hi) return;\\n        if (lo == hi) {\\n            tree[index]++;\\n            return;\\n        }\\n        int mid = lo + (hi - lo) / 2;\\n        updateTree(lo, mid, 2 * index, upd);\\n        updateTree(mid + 1, hi, 2 * index + 1, upd);\\n        tree[index] = tree[2 * index] + tree[2 * index + 1];\\n    }\\n\\n    int queryTree(int lo, int hi, int index, int qs, int qe) {\\n        if (qe < lo || qs > hi) return 0;\\n        if (qe >= hi && qs <= lo) return tree[index];\\n\\n        int mid = lo + (hi - lo) / 2;\\n\\n        int left = queryTree(lo, mid, 2 * index, qs, qe);\\n        int right = queryTree(mid + 1, hi, 2 * index + 1, qs, qe);\\n        return left + right;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        queue<int> pos[10];\\n        for (int i = 0; i < num.length(); i++) {\\n            pos[num[i] - \\'0\\'].push(i);\\n        }\\n        string res = \"\";\\n        SegmentTree *seg = new SegmentTree((int)num.length());\\n        for (int i = 0; i < num.length(); i++) {\\n            if (num[i] == \\'-\\') continue;\\n            int digit = num[i] - \\'0\\';\\n\\n            bool swapped = false;\\n            for (int j = 0; j < digit; j++) {\\n                if (pos[j].size() > 0) {\\n                    int curNumIndex = pos[j].front();\\n                    int shifts = seg->queryTree(0, num.length() - 1, 1, i, pos[j].front());\\n\\n                    if (curNumIndex - i - shifts <= k) {\\n                        seg->updateTree(0, num.length() - 1, 1, curNumIndex);\\n                        k -= curNumIndex - i - shifts;\\n                        pos[j].pop();\\n                        res += num[curNumIndex];\\n                        num[curNumIndex] = \\'-\\';\\n                        swapped = true;\\n                        i--;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (!swapped) {\\n                res += num[i];\\n                pos[digit].pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1993616,
                "title": "python-bit-solution-with-explanation",
                "content": "```\\n# For each index, find the smallest digit at the right within distance k, and left shift it to current index\\n# After shift, update k \\n# Ex : num = 4321567, k = 4, \\n# [4]321567 -> [1]432567 , since there are 3 left shift, k = k -3 = 1\\n# In the above example, all index before 3 (432) increase by one, and all index after 3 (567) remain its index, \\n# We can use BIT to minus all index after 3 by 1, and then add 1 to all index, this equals to add 1 to all index before 3\\n# Note that index of BIT start from 1, so when query at index use query[j+1], and update at j use update(j+1)\\n# Apply this to all the digits to get the answer\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:   \\n        N = len(num)\\n        BIT = [0] * (N+1)\\n        def update(x):\\n            while x <= N:\\n                BIT[x] -= 1\\n                x += x&(-x)\\n        def query(x):\\n            res = 0\\n            while x > 0:\\n                res += BIT[x]\\n                x -= x&(-x)\\n            return res\\n        dq = collections.defaultdict(collections.deque)\\n        for i,n in enumerate(num):\\n            dq[n].append(i) \\n        res = \\'\\'\\n        for i,c in enumerate(num):\\n            for d in string.digits:\\n                if dq[d]:\\n                    j = dq[d][0]\\n                    j_adj = j + query(j+1) + i\\n                    dis = j_adj - i\\n                    if dis <= k:\\n                        update(j+1)\\n                        k-=dis\\n                        res+=d\\n                        dq[d].popleft()\\n                        break\\n        return res\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\n# For each index, find the smallest digit at the right within distance k, and left shift it to current index\\n# After shift, update k \\n# Ex : num = 4321567, k = 4, \\n# [4]321567 -> [1]432567 , since there are 3 left shift, k = k -3 = 1\\n# In the above example, all index before 3 (432) increase by one, and all index after 3 (567) remain its index, \\n# We can use BIT to minus all index after 3 by 1, and then add 1 to all index, this equals to add 1 to all index before 3\\n# Note that index of BIT start from 1, so when query at index use query[j+1], and update at j use update(j+1)\\n# Apply this to all the digits to get the answer\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:   \\n        N = len(num)\\n        BIT = [0] * (N+1)\\n        def update(x):\\n            while x <= N:\\n                BIT[x] -= 1\\n                x += x&(-x)\\n        def query(x):\\n            res = 0\\n            while x > 0:\\n                res += BIT[x]\\n                x -= x&(-x)\\n            return res\\n        dq = collections.defaultdict(collections.deque)\\n        for i,n in enumerate(num):\\n            dq[n].append(i) \\n        res = \\'\\'\\n        for i,c in enumerate(num):\\n            for d in string.digits:\\n                if dq[d]:\\n                    j = dq[d][0]\\n                    j_adj = j + query(j+1) + i\\n                    dis = j_adj - i\\n                    if dis <= k:\\n                        update(j+1)\\n                        k-=dis\\n                        res+=d\\n                        dq[d].popleft()\\n                        break\\n        return res\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987427,
                "title": "python-clean-and-easy-to-understand",
                "content": "class Solution:\\n    \\'\\'\\'\\n    Observation 1: when we move a digit to left, other digit are shifted to right. i.e 432 got shifted to right by 1.\\n    Observation 2: Choose first smallest d that is in reach of k.\\n\\t*Learned from khaufnak\\n    \\'\\'\\'\\n\\n    def minInteger(self, num: str, k: int) -> str:\\n        preInd = 0\\n        to_find = 0\\n        while k > 0 and to_find < 10 and preInd < len(num):\\n            ind = num.find(str(to_find), preInd)\\n            if ind != -1 and ind - preInd <= k:\\n                # swap and reroder numbers\\n                num = num[:preInd] + num[ind] + num[preInd:ind] + num[ind+1:]\\n                to_find = 0\\n                k = k - ind + preInd\\n                preInd += 1\\n            else:\\n                to_find += 1\\n        return num\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    \\'\\'\\'\\n    Observation 1: when we move a digit to left, other digit are shifted to right. i.e 432 got shifted to right by 1.\\n    Observation 2: Choose first smallest d that is in reach of k.\\n\\t*Learned from khaufnak\\n    \\'\\'\\'\\n\\n    def minInteger(self, num: str, k: int) -> str:\\n        preInd = 0\\n        to_find = 0\\n        while k > 0 and to_find < 10 and preInd < len(num):\\n            ind = num.find(str(to_find), preInd)\\n            if ind != -1 and ind - preInd <= k:\\n                # swap and reroder numbers\\n                num = num[:preInd] + num[ind] + num[preInd:ind] + num[ind+1:]\\n                to_find = 0\\n                k = k - ind + preInd\\n                preInd += 1\\n            else:\\n                to_find += 1\\n        return num\\n",
                "codeTag": "Java"
            },
            {
                "id": 1978663,
                "title": "java-binary-indexed-tree",
                "content": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        StringBuilder ans=new StringBuilder();\\n        int n=num.length();\\n        List<Queue<Integer>> pqs = new ArrayList<>();\\n        for (int i = 0; i <= 9; ++i) {\\n            pqs.add(new LinkedList<>());\\n        }\\n        for (int i = 0; i < num.length(); ++i) {\\n            pqs.get(num.charAt(i) - \\'0\\').add(i);\\n        }\\n        BIT bit=new BIT(n);\\n        for(int i=0; i<n; i++){\\n            // System.out.println(i);\\n            for (int d = 0; d <= 9; ++d) {\\n                // System.out.println(\"  \"+d);\\n                if(pqs.get(d).size()>0){\\n                    int pos=pqs.get(d).peek();\\n                    int shift=bit.query(pos+1);\\n                    // System.out.println(\"   \"+pos+\" \"+shift);\\n                    if(pos-shift<=k){\\n                        k-=pos-shift;\\n                        bit.update(pos+1);\\n                        ans.append(d);\\n                        // System.out.println(\"    \"+k+\" \"+ans);\\n                        pqs.get(d).remove();\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\nclass BIT{\\n    int[] cnt;\\n    int n;\\n    public BIT(int n){\\n        cnt=new int[n+1];\\n        this.n=n+1;\\n    }\\n    int query(int x){\\n        int ans=0;\\n        while(x>0){\\n            ans+=cnt[x];\\n            x-=x&-x;\\n        }\\n        return ans;\\n    }\\n    void update(int x){\\n        while(x<n){\\n            cnt[x]++;\\n            x+=x&-x;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        StringBuilder ans=new StringBuilder();\\n        int n=num.length();\\n        List<Queue<Integer>> pqs = new ArrayList<>();\\n        for (int i = 0; i <= 9; ++i) {\\n            pqs.add(new LinkedList<>());\\n        }\\n        for (int i = 0; i < num.length(); ++i) {\\n            pqs.get(num.charAt(i) - \\'0\\').add(i);\\n        }\\n        BIT bit=new BIT(n);\\n        for(int i=0; i<n; i++){\\n            // System.out.println(i);\\n            for (int d = 0; d <= 9; ++d) {\\n                // System.out.println(\"  \"+d);\\n                if(pqs.get(d).size()>0){\\n                    int pos=pqs.get(d).peek();\\n                    int shift=bit.query(pos+1);\\n                    // System.out.println(\"   \"+pos+\" \"+shift);\\n                    if(pos-shift<=k){\\n                        k-=pos-shift;\\n                        bit.update(pos+1);\\n                        ans.append(d);\\n                        // System.out.println(\"    \"+k+\" \"+ans);\\n                        pqs.get(d).remove();\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\nclass BIT{\\n    int[] cnt;\\n    int n;\\n    public BIT(int n){\\n        cnt=new int[n+1];\\n        this.n=n+1;\\n    }\\n    int query(int x){\\n        int ans=0;\\n        while(x>0){\\n            ans+=cnt[x];\\n            x-=x&-x;\\n        }\\n        return ans;\\n    }\\n    void update(int x){\\n        while(x<n){\\n            cnt[x]++;\\n            x+=x&-x;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1966653,
                "title": "java-iterative-simple",
                "content": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        int n=num.length();\\n        if(num.charAt(0)==\\'0\\'){\\n            return num;\\n        }\\n        System.out.println(n);\\n        char[] cA=num.toCharArray();\\n        for(int i=0; i<n; i++){\\n            for(int d=0; d<cA[i]-\\'0\\'; d++){\\n                int pos=i+1;\\n                while(pos<n && pos-i<=k && cA[pos]-\\'0\\'!=d){\\n                    pos++;\\n                }\\n                if(pos<n && pos-i<=k){\\n                    swap(cA, i, pos);\\n                    k-=pos-i;\\n                }\\n            }\\n        }\\n        return new String(cA);\\n    }\\n    void swap(char[] cA, int i, int j){\\n        char t=cA[j];\\n        while(j>i){\\n            cA[j]=cA[j-1];\\n            j--;\\n        }\\n        cA[i]=t;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        int n=num.length();\\n        if(num.charAt(0)==\\'0\\'){\\n            return num;\\n        }\\n        System.out.println(n);\\n        char[] cA=num.toCharArray();\\n        for(int i=0; i<n; i++){\\n            for(int d=0; d<cA[i]-\\'0\\'; d++){\\n                int pos=i+1;\\n                while(pos<n && pos-i<=k && cA[pos]-\\'0\\'!=d){\\n                    pos++;\\n                }\\n                if(pos<n && pos-i<=k){\\n                    swap(cA, i, pos);\\n                    k-=pos-i;\\n                }\\n            }\\n        }\\n        return new String(cA);\\n    }\\n    void swap(char[] cA, int i, int j){\\n        char t=cA[j];\\n        while(j>i){\\n            cA[j]=cA[j-1];\\n            j--;\\n        }\\n        cA[i]=t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1964479,
                "title": "python-fenwick-tree-bit",
                "content": "```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n=len(num)\\n        ft=[0]*(n+1)\\n        D=defaultdict(lambda : deque())\\n        for idx,val in enumerate(num):\\n            D[int(val)].append(idx+1)\\n            \\n        def update(i,no):\\n            while i<=n:\\n                ft[i]+=no\\n                i += i & -i\\n                \\n        def query(i):\\n            res=0\\n            while i>0:\\n                res+=ft[i]\\n                i -= i & -i\\n            return res\\n        \\n        ans=\"\"\\n        t=0\\n        while k>0:\\n            flag=False\\n            for i in range(10):\\n                if len(D[i])>0:\\n                    x=D[i][0]-query(D[i][0])-1\\n                    if k>=x:\\n                        k-=x\\n                        flag=True\\n                        ans+=str(i)\\n                        update(D[i][0],1)\\n                        D[i].popleft()\\n                        break\\n            if not flag:\\n                break\\n        temp=[]\\n        for key in D:\\n            for val in D[key]:\\n                temp.append((val,key))\\n        temp.sort()\\n        for idx,no in temp:\\n            ans+=str(no)\\n        return ans\\n        \\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n=len(num)\\n        ft=[0]*(n+1)\\n        D=defaultdict(lambda : deque())\\n        for idx,val in enumerate(num):\\n            D[int(val)].append(idx+1)\\n            \\n        def update(i,no):\\n            while i<=n:\\n                ft[i]+=no\\n                i += i & -i\\n                \\n        def query(i):\\n            res=0\\n            while i>0:\\n                res+=ft[i]\\n                i -= i & -i\\n            return res\\n        \\n        ans=\"\"\\n        t=0\\n        while k>0:\\n            flag=False\\n            for i in range(10):\\n                if len(D[i])>0:\\n                    x=D[i][0]-query(D[i][0])-1\\n                    if k>=x:\\n                        k-=x\\n                        flag=True\\n                        ans+=str(i)\\n                        update(D[i][0],1)\\n                        D[i].popleft()\\n                        break\\n            if not flag:\\n                break\\n        temp=[]\\n        for key in D:\\n            for val in D[key]:\\n                temp.append((val,key))\\n        temp.sort()\\n        for idx,no in temp:\\n            ans+=str(no)\\n        return ans\\n        \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705504,
                "title": "python-segment-tree-o-nlogn",
                "content": "For num[i], if it hasn\\'t been shifted, then just find the minimum digit num[j] that j > i, and num[j] is also not been shifted, and the number of swaps for num[j] to be shifted to i-th index = j - i - digits_shift(i, j) <= k.\\n\\nIf such num[j] exists, num[j] will be shifted to i-th index, otherwise num[i] will be kept.\\n\\nTo count digits_shift between [i, j], since we modify the description that if num[t] has been shifted, Segment Tree is a good data structure to qurry the statistic information of [i, j].\\n\\nTime: O(NlogN)\\nSpace: O(N)\\n```\\nclass Solution(object):\\n    def minInteger(self, num, k):\\n        \"\"\"\\n        :type num: str\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        def segmentAdd(idx):\\n            return _add(1, 0, n - 1, idx)\\n\\n        def _add(node, left, right, idx):\\n            if left <= idx <= right:\\n                segment[node] += 1\\n                if left != right:\\n                    mid = (left + right) // 2\\n                    _add(2 * node, left, mid, idx)\\n                    _add(2 * node + 1, mid + 1, right, idx)\\n\\n        def segmentCount(begin, end):\\n            return _count(1, 0, n - 1, begin, end)\\n\\n        def _count(node, left, right, begin, end):\\n            if right < begin or left > end:\\n                return 0\\n            if begin <= left and end >= right:\\n                return segment[node]\\n            mid = (left + right) // 2\\n            return _count(2 * node, left, mid, begin, end) + _count(2 * node + 1, mid + 1, right, begin, end)\\n\\n        n = len(num)\\n        segment = [0] * (4 * n)\\n        digits_idx = collections.defaultdict(lambda :collections.deque())\\n        for i, d in enumerate(num):\\n            digits_idx[int(d)].append(i)\\n        ans = []\\n        shifted = set()\\n        i = 0\\n        n = len(num)\\n        while i < n:\\n            if i in shifted:\\n                i += 1\\n                continue\\n            if k == 0:\\n                ans.append(num[i])\\n                i += 1\\n            else:\\n                for d in range(int(num[i])):\\n                    while digits_idx[d] and digits_idx[d][0] < i:\\n                        digits_idx[d].popleft()\\n                    if digits_idx[d]:\\n                        j = digits_idx[d][0]\\n                        digitsMoved = segmentCount(i, j)\\n                        if j - i - digitsMoved <= k:\\n                            segmentAdd(j)\\n                            ans.append(num[j])\\n                            shifted.add(j)\\n                            k -= digits_idx[d].popleft() - i - digitsMoved\\n                            break\\n                else:\\n                    ans.append(num[i])\\n                    i += 1\\n        return \\'\\'.join(ans)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minInteger(self, num, k):\\n        \"\"\"\\n        :type num: str\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        def segmentAdd(idx):\\n            return _add(1, 0, n - 1, idx)\\n\\n        def _add(node, left, right, idx):\\n            if left <= idx <= right:\\n                segment[node] += 1\\n                if left != right:\\n                    mid = (left + right) // 2\\n                    _add(2 * node, left, mid, idx)\\n                    _add(2 * node + 1, mid + 1, right, idx)\\n\\n        def segmentCount(begin, end):\\n            return _count(1, 0, n - 1, begin, end)\\n\\n        def _count(node, left, right, begin, end):\\n            if right < begin or left > end:\\n                return 0\\n            if begin <= left and end >= right:\\n                return segment[node]\\n            mid = (left + right) // 2\\n            return _count(2 * node, left, mid, begin, end) + _count(2 * node + 1, mid + 1, right, begin, end)\\n\\n        n = len(num)\\n        segment = [0] * (4 * n)\\n        digits_idx = collections.defaultdict(lambda :collections.deque())\\n        for i, d in enumerate(num):\\n            digits_idx[int(d)].append(i)\\n        ans = []\\n        shifted = set()\\n        i = 0\\n        n = len(num)\\n        while i < n:\\n            if i in shifted:\\n                i += 1\\n                continue\\n            if k == 0:\\n                ans.append(num[i])\\n                i += 1\\n            else:\\n                for d in range(int(num[i])):\\n                    while digits_idx[d] and digits_idx[d][0] < i:\\n                        digits_idx[d].popleft()\\n                    if digits_idx[d]:\\n                        j = digits_idx[d][0]\\n                        digitsMoved = segmentCount(i, j)\\n                        if j - i - digitsMoved <= k:\\n                            segmentAdd(j)\\n                            ans.append(num[j])\\n                            shifted.add(j)\\n                            k -= digits_idx[d].popleft() - i - digitsMoved\\n                            break\\n                else:\\n                    ans.append(num[i])\\n                    i += 1\\n        return \\'\\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1638964,
                "title": "c-with-gnu-order-stat-tree-o-nlogn",
                "content": "We basically do insertion sort at each step but we need to keep track of the positions used up so far to calculate the distance. \\nFor that purpose, we can make use of the order stat tree provided by GNU ( not in STL).\\n\\nThe order statistic tree allows O(logN) insertion/deletion and also O(logN) find_rank/find_order.\\n\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        vector<int> d2p[10];\\n        for (int ii = 0; ii < num.size(); ii++) {\\n            d2p[num[ii] - \\'0\\'].push_back(ii);\\n        }\\n        \\n        tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> nums_used_order_stat_tree;\\n            \\n        string ans = \"\";\\n        \\n        for (int ii = 0; ii < 10; ii++) {\\n            reverse(d2p[ii].begin(), d2p[ii].end());\\n        }\\n        \\n        for (int ii = 0; ii < num.size(); ii++) {\\n            int minimum_index = -1;\\n            for (int jj = 0; jj <= 9; jj++) {\\n                if (d2p[jj].size() != 0 && (minimum_index == -1 || d2p[jj].back() < d2p[minimum_index].back()))\\n                    minimum_index = jj;\\n            }\\n            \\n            int jj = 0;\\n            if (k == 0) {\\n                jj = minimum_index;\\n            } else {\\n                for (; jj < minimum_index; jj++) {\\n                    if (d2p[jj].size() != 0) {\\n                        int num_used = nums_used_order_stat_tree.order_of_key(d2p[jj].back()) - \\n                                         nums_used_order_stat_tree.order_of_key(d2p[minimum_index].back());\\n                        if (d2p[jj].back() - d2p[minimum_index].back() - num_used <= k) {\\n                            k -= (d2p[jj].back() - d2p[minimum_index].back() - num_used);\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            ans.push_back(jj + \\'0\\');\\n            nums_used_order_stat_tree.insert(d2p[jj].back());\\n            d2p[jj].pop_back();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        vector<int> d2p[10];\\n        for (int ii = 0; ii < num.size(); ii++) {\\n            d2p[num[ii] - \\'0\\'].push_back(ii);\\n        }\\n        \\n        tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> nums_used_order_stat_tree;\\n            \\n        string ans = \"\";\\n        \\n        for (int ii = 0; ii < 10; ii++) {\\n            reverse(d2p[ii].begin(), d2p[ii].end());\\n        }\\n        \\n        for (int ii = 0; ii < num.size(); ii++) {\\n            int minimum_index = -1;\\n            for (int jj = 0; jj <= 9; jj++) {\\n                if (d2p[jj].size() != 0 && (minimum_index == -1 || d2p[jj].back() < d2p[minimum_index].back()))\\n                    minimum_index = jj;\\n            }\\n            \\n            int jj = 0;\\n            if (k == 0) {\\n                jj = minimum_index;\\n            } else {\\n                for (; jj < minimum_index; jj++) {\\n                    if (d2p[jj].size() != 0) {\\n                        int num_used = nums_used_order_stat_tree.order_of_key(d2p[jj].back()) - \\n                                         nums_used_order_stat_tree.order_of_key(d2p[minimum_index].back());\\n                        if (d2p[jj].back() - d2p[minimum_index].back() - num_used <= k) {\\n                            k -= (d2p[jj].back() - d2p[minimum_index].back() - num_used);\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            ans.push_back(jj + \\'0\\');\\n            nums_used_order_stat_tree.insert(d2p[jj].back());\\n            d2p[jj].pop_back();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1631902,
                "title": "c-o-n-2-simple-bruteforce-91-77-95-88",
                "content": "```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.length();\\n        string ans(n,\\'-\\');\\n        int i = 0;\\n        int first = \\'0\\';\\n        int start = 0;\\n        int end   = n-1;\\n        bool found = true;\\n        while (found == true)\\n        {\\n            found = false;\\n            for (char d = first; d<=\\'9\\' && k>0 && !found; d++)\\n            {\\n                int j, l;\\n                for (j = start, l=0; j<=end && k>=l; j++)\\n                {\\n                    if (num[j] == d)\\n                    {\\n                        found = true;\\n                        // cout << d << endl;\\n                        ans[i++] = d;\\n                        num[j] = \\'-\\';\\n                        k -= l;\\n                        if (d != first)\\n                            break;\\n                    }\\n                    else if (num[j] != \\'-\\') l++;\\n                }\\n                if (j>end && d== first) first++;\\n                while (end  >= start && num[end] == \\'-\\') end--;\\n                while (start <= end && num[start] == \\'-\\') start++;\\n            }\\n        }\\n        int j=start;\\n        while (i<n)\\n        {\\n            if (num[j] == \\'-\\')\\n            {\\n                j++;\\n                continue;\\n            }\\n            ans[i++] = num[j++];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.length();\\n        string ans(n,\\'-\\');\\n        int i = 0;\\n        int first = \\'0\\';\\n        int start = 0;\\n        int end   = n-1;\\n        bool found = true;\\n        while (found == true)\\n        {\\n            found = false;\\n            for (char d = first; d<=\\'9\\' && k>0 && !found; d++)\\n            {\\n                int j, l;\\n                for (j = start, l=0; j<=end && k>=l; j++)\\n                {\\n                    if (num[j] == d)\\n                    {\\n                        found = true;\\n                        // cout << d << endl;\\n                        ans[i++] = d;\\n                        num[j] = \\'-\\';\\n                        k -= l;\\n                        if (d != first)\\n                            break;\\n                    }\\n                    else if (num[j] != \\'-\\') l++;\\n                }\\n                if (j>end && d== first) first++;\\n                while (end  >= start && num[end] == \\'-\\') end--;\\n                while (start <= end && num[start] == \\'-\\') start++;\\n            }\\n        }\\n        int j=start;\\n        while (i<n)\\n        {\\n            if (num[j] == \\'-\\')\\n            {\\n                j++;\\n                continue;\\n            }\\n            ans[i++] = num[j++];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1577995,
                "title": "python-help-please-don-t-understand-bisect-perfm",
                "content": "Duhh I got a crazy difference perf between using bisect.bisect(list,index) and list.bisect(index) (got from stochastic TLE, as i was near 10 000 ms, to AC with 600 ms). \\nIt\\'s crazy. \\nIf someone can explain the difference, would be welcomed (or can point me out my mistake..)\\n\\n```\\nfrom sortedcontainers import SortedList\\nfrom string import digits\\nfrom bisect import bisect\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        \\n        d = defaultdict(list)\\n        ans, seen = [], SortedList()\\n        \\n        for i, n in enumerate(num):\\n            d[n].append(i)\\n        \\n        for digit in digits:\\n            d[digit] = d[digit][::-1]\\n            \\n        for i in range(len(num)):\\n            for digit in digits:\\n                if d[digit]:\\n                    index = d[digit][-1]\\n                    #swap_to_right = len(seen) - bisect(seen,index)\\n                    swap_to_right = len(seen) - seen.bisect(index)\\n                    index_after_swap = index + swap_to_right\\n                    if index_after_swap-i <= k:\\n                        ans.append(digit)\\n                        k -= (index_after_swap - i)\\n                        d[digit].pop()\\n                        seen.add(index)\\n                        break\\n                    \\n        return \"\".join(ans)\\n```\\n\\nEDIT :\\nAlright it seems, I\\'m not crazy finally, after testing locally, bisect.bisect is indeed highly inneficient when used with a SortedList.\\nActually with 10^7 iterations of bisect over a list of 10^5 element I got (to give you a rough estimate): \\n\\n1.5 sec for using bisect.bisect with a normal python list (but sorted of course)\\n13 sec using sortedList.bisect with a sorted list \\n260 sec using bisect.bisect with a sorted list :O",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nfrom string import digits\\nfrom bisect import bisect\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        \\n        d = defaultdict(list)\\n        ans, seen = [], SortedList()\\n        \\n        for i, n in enumerate(num):\\n            d[n].append(i)\\n        \\n        for digit in digits:\\n            d[digit] = d[digit][::-1]\\n            \\n        for i in range(len(num)):\\n            for digit in digits:\\n                if d[digit]:\\n                    index = d[digit][-1]\\n                    #swap_to_right = len(seen) - bisect(seen,index)\\n                    swap_to_right = len(seen) - seen.bisect(index)\\n                    index_after_swap = index + swap_to_right\\n                    if index_after_swap-i <= k:\\n                        ans.append(digit)\\n                        k -= (index_after_swap - i)\\n                        d[digit].pop()\\n                        seen.add(index)\\n                        break\\n                    \\n        return \"\".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1533307,
                "title": "my-notes-on-bit",
                "content": "Solve LC1409 and read [my notes](https://leetcode.com/problems/queries-on-a-permutation-with-key/discuss/1532316/My-notes-on-BIT-solution) first and come back. \\n\\nNow you should have a feel how BIT is used to move char to the front.\\n\\nWe want to move smallest char say 0, to the front, but can we move any 0? No. We can only move 0 within steps. If 0 cannot be moved to front, it is pointless to move it as we could have better choice. Note, if 0 cannot be move to the front this turn, it means this 0 will never have it\\'s chance again. (is this true?)\\n\\nBIT will tell you how many chars are in front.\\n\\nSo while we have steps, find the smallest char we can move to front, move to front, decrease steps, and repeat.\\n\\nNow I got stuck on 1) how to find the smallest char in the range of remaining steps, and 2) how to find the range as some char has been removed(we can use binary search). BIT cannot maintain min value.\\n\\nIt turns out we can just loop through 0 - 9 and try each to see if it is reachable, we keep a size 10 vector of queue and put each number\\'s position in the queue. This try and verify method solved both 1) and 2).\\n\\t\\n\\n\\n",
                "solutionTags": [],
                "code": "Solve LC1409 and read [my notes](https://leetcode.com/problems/queries-on-a-permutation-with-key/discuss/1532316/My-notes-on-BIT-solution) first and come back. \\n\\nNow you should have a feel how BIT is used to move char to the front.\\n\\nWe want to move smallest char say 0, to the front, but can we move any 0? No. We can only move 0 within steps. If 0 cannot be moved to front, it is pointless to move it as we could have better choice. Note, if 0 cannot be move to the front this turn, it means this 0 will never have it\\'s chance again. (is this true?)\\n\\nBIT will tell you how many chars are in front.\\n\\nSo while we have steps, find the smallest char we can move to front, move to front, decrease steps, and repeat.\\n\\nNow I got stuck on 1) how to find the smallest char in the range of remaining steps, and 2) how to find the range as some char has been removed(we can use binary search). BIT cannot maintain min value.\\n\\nIt turns out we can just loop through 0 - 9 and try each to see if it is reachable, we keep a size 10 vector of queue and put each number\\'s position in the queue. This try and verify method solved both 1) and 2).\\n\\t\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1529554,
                "title": "java-short-fenwicktree-solution",
                "content": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        Queue<Integer>[] q = new LinkedList[10];\\n        for(int i = 0; i <= 9; i++) q[i] = new LinkedList<Integer>();\\n        for(int i = 0; i < n; i++) q[num.charAt(i)-\\'0\\'].add(i);\\n        \\n        fenWickTree ft = new fenWickTree(n);\\n        StringBuilder ans = new StringBuilder();\\n        for(int i = 0; i < n; i++) {\\n            for(int d = 0; d <= 9; d++) {\\n                if(q[d].isEmpty()) continue;\\n                int pos = q[d].peek();\\n                int alreadyMoved = ft.getSum(pos+1);\\n                int reqSwaps = pos - alreadyMoved;\\n                if(reqSwaps <= k) {\\n                    k -= reqSwaps;\\n                    char c = (char)(d+\\'0\\');\\n                    ans.append(c);\\n                    q[d].poll();\\n                    ft.update(pos+1);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans.toString();\\n    }\\n    \\n    static class fenWickTree {\\n        int[] tree;\\n        int n;\\n        fenWickTree(int n) {\\n            tree = new int[n+1];\\n            this.n = n;\\n        }\\n        \\n        public void update(int idx) {\\n            while(idx <= n) {\\n                tree[idx]++;\\n                idx += idx&-idx;\\n            }\\n        }\\n        \\n        public int getSum(int idx) {\\n            int sum = 0;\\n            while(idx > 0) {\\n                sum += tree[idx];\\n                idx -= idx&-idx;\\n            }\\n            \\n            return sum;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        Queue<Integer>[] q = new LinkedList[10];\\n        for(int i = 0; i <= 9; i++) q[i] = new LinkedList<Integer>();\\n        for(int i = 0; i < n; i++) q[num.charAt(i)-\\'0\\'].add(i);\\n        \\n        fenWickTree ft = new fenWickTree(n);\\n        StringBuilder ans = new StringBuilder();\\n        for(int i = 0; i < n; i++) {\\n            for(int d = 0; d <= 9; d++) {\\n                if(q[d].isEmpty()) continue;\\n                int pos = q[d].peek();\\n                int alreadyMoved = ft.getSum(pos+1);\\n                int reqSwaps = pos - alreadyMoved;\\n                if(reqSwaps <= k) {\\n                    k -= reqSwaps;\\n                    char c = (char)(d+\\'0\\');\\n                    ans.append(c);\\n                    q[d].poll();\\n                    ft.update(pos+1);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans.toString();\\n    }\\n    \\n    static class fenWickTree {\\n        int[] tree;\\n        int n;\\n        fenWickTree(int n) {\\n            tree = new int[n+1];\\n            this.n = n;\\n        }\\n        \\n        public void update(int idx) {\\n            while(idx <= n) {\\n                tree[idx]++;\\n                idx += idx&-idx;\\n            }\\n        }\\n        \\n        public int getSum(int idx) {\\n            int sum = 0;\\n            while(idx > 0) {\\n                sum += tree[idx];\\n                idx -= idx&-idx;\\n            }\\n            \\n            return sum;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467714,
                "title": "minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits",
                "content": "class Solution {\\n    public String minInteger(String num, int k) {\\n        ArrayList<Character> arr = new ArrayList<Character>();\\n        for(int i=0;i<num.length();i++){\\n            arr.add(num.charAt(i));\\n        }\\n        minimizer(0,arr , k);\\n        String ans = \"\";\\n        for(char i:arr){\\n            ans = ans + i;\\n        }\\n        return ans;\\n    }\\n    public void minimizer(int pos , ArrayList<Character> arr , int k){\\n        if(k==0 || pos >= arr.size()){\\n            return;\\n        }\\n        int n = arr.size();\\n        int swaps = Math.min( k , n - 1 - pos);\\n        char min = \\'9\\';\\n        int min_pos = pos;\\n        for(int i=pos;i<pos + swaps + 1;i++){\\n            if(arr.get(i) < min ){\\n                min = arr.get(i);\\n                min_pos = i;\\n            }\\n        }\\n        arr.remove(min_pos);\\n        arr.add(pos , min);\\n        minimizer(pos+1 , arr  , k - (min_pos - pos));\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String minInteger(String num, int k) {\\n        ArrayList<Character> arr = new ArrayList<Character>();\\n        for(int i=0;i<num.length();i++){\\n            arr.add(num.charAt(i));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1423291,
                "title": "help-with-my-solution",
                "content": "I hereby enclose my O(N^2) solution .\\nI have no idea why it has been accepted.\\nCan someone please explain me the reason\\n\\n```\\nstring minInteger(string num, int k) {\\n        int n=num.size();\\n        string te=\"\";\\n        for(int i=0;i<n;i++){\\n            if(k==0)\\n                break;\\n            int id=i;\\n            char ch=num[i];\\n            for(int j=i+1;j<n;j++){\\n                if(num[j]<ch&&k>=(j-i)){\\n                    ch=num[j];\\n                    id=j;\\n                }}\\n            int le=id-i+1;\\n            if(k<(le-1))\\n                continue;\\n            ch=num[id];\\n            num.erase(num.begin()+id);\\n            num.insert(num.begin()+i,ch);\\n            //cout<<num<<endl;\\n            k-=(le-1);\\n        }\\n        return num;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstring minInteger(string num, int k) {\\n        int n=num.size();\\n        string te=\"\";\\n        for(int i=0;i<n;i++){\\n            if(k==0)\\n                break;\\n            int id=i;\\n            char ch=num[i];\\n            for(int j=i+1;j<n;j++){\\n                if(num[j]<ch&&k>=(j-i)){\\n                    ch=num[j];\\n                    id=j;\\n                }}\\n            int le=id-i+1;\\n            if(k<(le-1))\\n                continue;\\n            ch=num[id];\\n            num.erase(num.begin()+id);\\n            num.insert(num.begin()+i,ch);\\n            //cout<<num<<endl;\\n            k-=(le-1);\\n        }\\n        return num;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1329987,
                "title": "jave-93-fenwick-tree",
                "content": "```\\nclass Solution {\\n    // Using Fewick Tree data structure to compute the nmber of elements removed before eacg element in num\\n    // cost of each element = its index - numer of elements that have been removed before itself\\n    // the number of elements removed before index i can be obtained from the Fenwick Tree\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        List<Queue<Integer>> indices = new ArrayList<>();\\n        for (int d = 0; d < 10; d++) {\\n            indices.add(new LinkedList<>());\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int temp = num.charAt(i) - \\'0\\';\\n            indices.get(temp).add(i);\\n        }\\n        Fenwick tree = new Fenwick(n + 1);\\n        StringBuilder res = new StringBuilder();\\n        boolean[] removed = new boolean[n];\\n        while (k > 0 && res.length() < n) {\\n            for (int d = 0; d < 10; d++) {\\n                if (indices.get(d).isEmpty()) continue;\\n                int pos = indices.get(d).peek();\\n                int cost = pos - tree.preSum(pos - 1);\\n                if (cost > k) continue;\\n                removed[pos] = true;\\n                k -= cost;\\n                res.append(d);\\n                indices.get(d).remove();\\n                tree.update(pos, 1);\\n                break;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (!removed[i]) res.append(num.charAt(i));\\n        }\\n        return res.toString();\\n        \\n    }\\n    \\n    class Fenwick {\\n        int[] tree;\\n        public Fenwick(int n) {\\n            tree = new int[n];\\n        }\\n        public void update(int index, int delta) {\\n            index++;\\n            while (index < tree.length) {\\n                tree[index] += delta;\\n                index += lowbit(index);\\n            }\\n        }\\n        public int preSum(int index) {\\n            int res = 0;\\n            index++;\\n            while (index > 0) {\\n                res += tree[index];\\n                index -= lowbit(index);\\n            }\\n            return res;\\n        }\\n        private int lowbit(int index) {\\n            return index & (-index);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Using Fewick Tree data structure to compute the nmber of elements removed before eacg element in num\\n    // cost of each element = its index - numer of elements that have been removed before itself\\n    // the number of elements removed before index i can be obtained from the Fenwick Tree\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        List<Queue<Integer>> indices = new ArrayList<>();\\n        for (int d = 0; d < 10; d++) {\\n            indices.add(new LinkedList<>());\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int temp = num.charAt(i) - \\'0\\';\\n            indices.get(temp).add(i);\\n        }\\n        Fenwick tree = new Fenwick(n + 1);\\n        StringBuilder res = new StringBuilder();\\n        boolean[] removed = new boolean[n];\\n        while (k > 0 && res.length() < n) {\\n            for (int d = 0; d < 10; d++) {\\n                if (indices.get(d).isEmpty()) continue;\\n                int pos = indices.get(d).peek();\\n                int cost = pos - tree.preSum(pos - 1);\\n                if (cost > k) continue;\\n                removed[pos] = true;\\n                k -= cost;\\n                res.append(d);\\n                indices.get(d).remove();\\n                tree.update(pos, 1);\\n                break;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (!removed[i]) res.append(num.charAt(i));\\n        }\\n        return res.toString();\\n        \\n    }\\n    \\n    class Fenwick {\\n        int[] tree;\\n        public Fenwick(int n) {\\n            tree = new int[n];\\n        }\\n        public void update(int index, int delta) {\\n            index++;\\n            while (index < tree.length) {\\n                tree[index] += delta;\\n                index += lowbit(index);\\n            }\\n        }\\n        public int preSum(int index) {\\n            int res = 0;\\n            index++;\\n            while (index > 0) {\\n                res += tree[index];\\n                index -= lowbit(index);\\n            }\\n            return res;\\n        }\\n        private int lowbit(int index) {\\n            return index & (-index);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247041,
                "title": "java-10ms-o-n-radix-sort",
                "content": "```\\n    public String minInteger(String num, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        //\\u6700\\u8FD1\\u7684[0,9]\\u4F4D\\u4E8Epos\\u4E2D\\u7684\\u4F4D\\u7F6E\\n        int[] digitPos = new int[10];\\n        int[] reduceMove = new int[10];\\n        int matchAmount = 0;\\n        char[] chars = num.toCharArray();\\n        Arrays.fill(digitPos, chars.length);\\n        for (int i = 0; i < chars.length; i++) {\\n            int cur = chars[i] - \\'0\\';\\n            if (digitPos[cur] == chars.length) {\\n                digitPos[cur] = i;\\n                matchAmount++;\\n                if (matchAmount == 10) {\\n                    break;\\n                }\\n            }\\n        }\\n        int curIndex=0;\\n        while (k > 0 && curIndex < chars.length) {\\n            for (int digit = 0; digit <= 9; digit++) {\\n                if (digitPos[digit]<chars.length&&digitPos[digit] - reduceMove[digit] <= k) {\\n                    sb.append(chars[digitPos[digit]]);\\n                    k-=(digitPos[digit] - reduceMove[digit]);\\n                    curIndex++;\\n                    reduceMove[digit]++;\\n                    for(int j=0;j<=9;j++){\\n                        if(j!=digit){\\n                            if(digitPos[j]>digitPos[digit]){\\n                                reduceMove[j]++;\\n                            }\\n                        }\\n                    }\\n                    boolean find=false;\\n                    for(int next=digitPos[digit]+1;next<chars.length;next++){\\n                        int cur=chars[next]-\\'0\\';\\n                        if (cur==digit){\\n                            find=true;\\n                            digitPos[digit]=next;\\n                            break;\\n                        }\\n                        if(next<digitPos[cur]){\\n                            reduceMove[digit]++;\\n                        }\\n                    }\\n                    if(!find){\\n                        digitPos[digit]=chars.length;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        int start=Arrays.stream(digitPos).min().getAsInt();\\n        for(int i=start;i<chars.length;i++){\\n            if(digitPos[chars[i]-\\'0\\']<=i){\\n                sb.append(chars[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String minInteger(String num, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        //\\u6700\\u8FD1\\u7684[0,9]\\u4F4D\\u4E8Epos\\u4E2D\\u7684\\u4F4D\\u7F6E\\n        int[] digitPos = new int[10];\\n        int[] reduceMove = new int[10];\\n        int matchAmount = 0;\\n        char[] chars = num.toCharArray();\\n        Arrays.fill(digitPos, chars.length);\\n        for (int i = 0; i < chars.length; i++) {\\n            int cur = chars[i] - \\'0\\';\\n            if (digitPos[cur] == chars.length) {\\n                digitPos[cur] = i;\\n                matchAmount++;\\n                if (matchAmount == 10) {\\n                    break;\\n                }\\n            }\\n        }\\n        int curIndex=0;\\n        while (k > 0 && curIndex < chars.length) {\\n            for (int digit = 0; digit <= 9; digit++) {\\n                if (digitPos[digit]<chars.length&&digitPos[digit] - reduceMove[digit] <= k) {\\n                    sb.append(chars[digitPos[digit]]);\\n                    k-=(digitPos[digit] - reduceMove[digit]);\\n                    curIndex++;\\n                    reduceMove[digit]++;\\n                    for(int j=0;j<=9;j++){\\n                        if(j!=digit){\\n                            if(digitPos[j]>digitPos[digit]){\\n                                reduceMove[j]++;\\n                            }\\n                        }\\n                    }\\n                    boolean find=false;\\n                    for(int next=digitPos[digit]+1;next<chars.length;next++){\\n                        int cur=chars[next]-\\'0\\';\\n                        if (cur==digit){\\n                            find=true;\\n                            digitPos[digit]=next;\\n                            break;\\n                        }\\n                        if(next<digitPos[cur]){\\n                            reduceMove[digit]++;\\n                        }\\n                    }\\n                    if(!find){\\n                        digitPos[digit]=chars.length;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        int start=Arrays.stream(digitPos).min().getAsInt();\\n        for(int i=start;i<chars.length;i++){\\n            if(digitPos[chars[i]-\\'0\\']<=i){\\n                sb.append(chars[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1174885,
                "title": "scala-linear-solution-o-n-time-o-n-memory",
                "content": "```\\n// Inspired by tztanjunjie\\'s approach\\ndef minInteger(numStr: String, k: Int): String = {\\n    var ans = new StringBuilder(numStr.length)\\n    var swapsLeft = k\\n    var offset = 0\\n    var num: mutable.Map[Int, Char] = mutable.Map() ++ (numStr.indices zip numStr).toMap\\n    var nextOccurrence = mutable.ListBuffer.fill[(Int, Int)](10)((-1, -1)) // True-Index (in numStr), \"fake\" index (i.e. where it belongs after swaps have moved it left)\\n\\n    nextOccurrence = (0 to 9).map(n => numStr.indexWhere(_ == n + \\'0\\')).map(x => (x, x)).toList.to(mutable.ListBuffer)\\n    println(nextOccurrence)\\n\\n   var idx = 0\\n    while (idx < numStr.length) {\\n      //the main process involves keeping num \"array\" constant (except for X-ing out used numbers)\\n      // when a number must be \"moved front\" it is X\\'d-out, and num now represents the remaining string shifted 1\\n      if (num(idx) != \\'X\\') {\\n        val toSwap = num(idx).toString.toInt\\n        var numPicked = nextOccurrence.slice(0, toSwap).indexWhere(tup => tup._1 >= 0 && tup._2 <= idx + swapsLeft)\\n\\n        var pos: Option[(Int, Int)] = nextOccurrence.lift(numPicked)\\n        if (pos.nonEmpty) { // we found a number to be swapped\\n          swapsLeft -= pos.get._2 - idx\\n          ans ++= numPicked.toString\\n          idx -= 1\\n          nextOccurrence.indices.filter(v => nextOccurrence(v)._1 >= 0 && nextOccurrence(v)._1 > pos.get._1).foreach(i => nextOccurrence(i) = (nextOccurrence(i)._1, nextOccurrence(i)._2 - 1))\\n          num(pos.get._1) = \\'X\\'\\n        } else {\\n          num(idx) = \\'X\\'\\n          numPicked = toSwap // nextOccurrence of this same number is out-of-date, must be updated\\n          ans ++= toSwap.toString\\n        }\\n\\n        var i = pos.map(_._1).getOrElse(idx + 1) // starting at last occurrence, search to right for next occurrence\\n        var adj = pos.map(tup => tup._1 - tup._2).getOrElse(0) // start with number of X\\'s to the left so far\\n        \\n        var nextPos = Stream.range(i, numStr.length).indexWhere(n => num(n) == \\'0\\' + numPicked)\\n        if (nextPos != -1)\\n          nextPos += i\\n        adj += Stream.range(i, nextPos).count(num(_) == \\'X\\') // keep track of any new ones along the way\\n        nextOccurrence(numPicked) = (nextPos, nextPos - adj)\\n      } else { // we ingest a left-x, so un-discount all the nextOccurrences by 1\\n        nextOccurrence = nextOccurrence.map(tup => (tup._1, tup._2 + 1))\\n      }\\n      idx += 1\\n    }\\n    ans.toString\\n  }\\n  ```",
                "solutionTags": [],
                "code": "```\\n// Inspired by tztanjunjie\\'s approach\\ndef minInteger(numStr: String, k: Int): String = {\\n    var ans = new StringBuilder(numStr.length)\\n    var swapsLeft = k\\n    var offset = 0\\n    var num: mutable.Map[Int, Char] = mutable.Map() ++ (numStr.indices zip numStr).toMap\\n    var nextOccurrence = mutable.ListBuffer.fill[(Int, Int)](10)((-1, -1)) // True-Index (in numStr), \"fake\" index (i.e. where it belongs after swaps have moved it left)\\n\\n    nextOccurrence = (0 to 9).map(n => numStr.indexWhere(_ == n + \\'0\\')).map(x => (x, x)).toList.to(mutable.ListBuffer)\\n    println(nextOccurrence)\\n\\n   var idx = 0\\n    while (idx < numStr.length) {\\n      //the main process involves keeping num \"array\" constant (except for X-ing out used numbers)\\n      // when a number must be \"moved front\" it is X\\'d-out, and num now represents the remaining string shifted 1\\n      if (num(idx) != \\'X\\') {\\n        val toSwap = num(idx).toString.toInt\\n        var numPicked = nextOccurrence.slice(0, toSwap).indexWhere(tup => tup._1 >= 0 && tup._2 <= idx + swapsLeft)\\n\\n        var pos: Option[(Int, Int)] = nextOccurrence.lift(numPicked)\\n        if (pos.nonEmpty) { // we found a number to be swapped\\n          swapsLeft -= pos.get._2 - idx\\n          ans ++= numPicked.toString\\n          idx -= 1\\n          nextOccurrence.indices.filter(v => nextOccurrence(v)._1 >= 0 && nextOccurrence(v)._1 > pos.get._1).foreach(i => nextOccurrence(i) = (nextOccurrence(i)._1, nextOccurrence(i)._2 - 1))\\n          num(pos.get._1) = \\'X\\'\\n        } else {\\n          num(idx) = \\'X\\'\\n          numPicked = toSwap // nextOccurrence of this same number is out-of-date, must be updated\\n          ans ++= toSwap.toString\\n        }\\n\\n        var i = pos.map(_._1).getOrElse(idx + 1) // starting at last occurrence, search to right for next occurrence\\n        var adj = pos.map(tup => tup._1 - tup._2).getOrElse(0) // start with number of X\\'s to the left so far\\n        \\n        var nextPos = Stream.range(i, numStr.length).indexWhere(n => num(n) == \\'0\\' + numPicked)\\n        if (nextPos != -1)\\n          nextPos += i\\n        adj += Stream.range(i, nextPos).count(num(_) == \\'X\\') // keep track of any new ones along the way\\n        nextOccurrence(numPicked) = (nextPos, nextPos - adj)\\n      } else { // we ingest a left-x, so un-discount all the nextOccurrences by 1\\n        nextOccurrence = nextOccurrence.map(tup => (tup._1, tup._2 + 1))\\n      }\\n      idx += 1\\n    }\\n    ans.toString\\n  }\\n  ```",
                "codeTag": "Python3"
            },
            {
                "id": 997365,
                "title": "note-nlogn-algorithm-takes-more-time-after-leetcode-added-more-test-cases",
                "content": "In case you only beat 20% percent when using nlogn algorithm such as segment tree like me :D\\n\\n```\\nstruct Node {\\npublic:\\n    Node* left, *right;\\n    int l, r;\\n    int sum;\\n    \\n    Node(int _l, int _r): l(_l), r(_r), left(nullptr), right(nullptr), sum(0) {}\\n};\\n\\nvoid add(Node* root, int val) {\\n    if (val < root->l || val > root->r) return;\\n    if (root->l == root->r) root->sum ++;    \\n    else {\\n        int mid = (root->l + root->r) / 2;\\n        if (val <= mid) {\\n            if (!root->left) root->left = new Node(root->l, mid);\\n            add(root->left, val);\\n        }\\n        \\n        else {\\n            if (!root->right) root->right = new Node(mid+1, root->r);\\n            add(root->right, val);\\n        }\\n        root->sum ++;\\n    }\\n} \\n\\nint find(Node* root, int val) {\\n    if (!root) return 0;\\n    if (val < root->l || val > root->r) return 0;\\n    if (val == root->r) return root->sum;\\n    \\n    int mid = (root->l + root->r) / 2;\\n    if (val <= mid) {\\n        return find(root->left, val);\\n    }\\n    \\n    return find(root->left, mid) + find(root->right, val);\\n}\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        vector<queue<int>> record(10);\\n        int n = num.size();\\n        if(k > n*(n-1)/2) {\\n            sort(num.begin(), num.end());\\n            return num;\\n        }\\n        for (int i = 0; i < n; ++i) record[num[i]-\\'0\\'].push(i);\\n        \\n        string res;\\n        Node* root = new Node(0, n-1);\\n        while (n) {\\n            for (int i = 0; i <= 9; ++i) {\\n                if (record[i].size() > 0) {\\n                    int id = record[i].front();\\n                    int pre = find(root, id);\\n                    if (id - pre <= k) {\\n                        k = k - (id - pre);\\n                        res += (char)(\\'0\\' + i);\\n                        add(root, id);\\n                        record[i].pop();\\n                        break;\\n                    }\\n                }\\n            }\\n            n --;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Node {\\npublic:\\n    Node* left, *right;\\n    int l, r;\\n    int sum;\\n    \\n    Node(int _l, int _r): l(_l), r(_r), left(nullptr), right(nullptr), sum(0) {}\\n};\\n\\nvoid add(Node* root, int val) {\\n    if (val < root->l || val > root->r) return;\\n    if (root->l == root->r) root->sum ++;    \\n    else {\\n        int mid = (root->l + root->r) / 2;\\n        if (val <= mid) {\\n            if (!root->left) root->left = new Node(root->l, mid);\\n            add(root->left, val);\\n        }\\n        \\n        else {\\n            if (!root->right) root->right = new Node(mid+1, root->r);\\n            add(root->right, val);\\n        }\\n        root->sum ++;\\n    }\\n} \\n\\nint find(Node* root, int val) {\\n    if (!root) return 0;\\n    if (val < root->l || val > root->r) return 0;\\n    if (val == root->r) return root->sum;\\n    \\n    int mid = (root->l + root->r) / 2;\\n    if (val <= mid) {\\n        return find(root->left, val);\\n    }\\n    \\n    return find(root->left, mid) + find(root->right, val);\\n}\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        vector<queue<int>> record(10);\\n        int n = num.size();\\n        if(k > n*(n-1)/2) {\\n            sort(num.begin(), num.end());\\n            return num;\\n        }\\n        for (int i = 0; i < n; ++i) record[num[i]-\\'0\\'].push(i);\\n        \\n        string res;\\n        Node* root = new Node(0, n-1);\\n        while (n) {\\n            for (int i = 0; i <= 9; ++i) {\\n                if (record[i].size() > 0) {\\n                    int id = record[i].front();\\n                    int pre = find(root, id);\\n                    if (id - pre <= k) {\\n                        k = k - (id - pre);\\n                        res += (char)(\\'0\\' + i);\\n                        add(root, id);\\n                        record[i].pop();\\n                        break;\\n                    }\\n                }\\n            }\\n            n --;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 985260,
                "title": "python-binary-index-tree-solution",
                "content": "\\tclass binaryIndexTree:\\n\\n\\t\\tdef __init__(self, length: int):\\n\\t\\t\\tself.arr = [0] * (length + 1)\\n\\n\\t\\tdef add(self, idx: int, val: int):\\n\\t\\t\\twhile idx < len(self.arr):\\n\\t\\t\\t\\tself.arr[idx] += val\\n\\t\\t\\t\\tidx += idx & -idx\\n\\n\\t\\tdef query(self, idx: int):\\n\\t\\t\\tres = 0\\n\\t\\t\\twhile idx > 0:\\n\\t\\t\\t\\tres += self.arr[idx]\\n\\t\\t\\t\\tidx -= idx & -idx\\n\\t\\t\\treturn res\\n\\n\\tclass Solution:\\n\\t\\tdef minInteger(self, num: str, k: int) -> str:\\n\\t\\t\\tidmap = defaultdict(list)\\n\\t\\t\\tfor i in range(len(num)):\\n\\t\\t\\t\\tidmap[int(num[i])].append(i)\\n\\n\\t\\t\\ttree = binaryIndexTree(len(num))\\n\\t\\t\\tres = \\'\\'\\n\\t\\t\\tfor _ in range(len(num)):\\n\\t\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\t\\tif i in idmap:\\n\\t\\t\\t\\t\\t\\trelevant = tree.query(idmap[i][0] + 1)\\n\\t\\t\\t\\t\\t\\tval = idmap[i][0] - relevant\\n\\t\\t\\t\\t\\t\\tif val <= k:\\n\\t\\t\\t\\t\\t\\t\\tk -= val\\n\\t\\t\\t\\t\\t\\t\\ttree.add(idmap[i].pop(0) + 1, 1)\\n\\t\\t\\t\\t\\t\\t\\tif not idmap[i]:\\n\\t\\t\\t\\t\\t\\t\\t\\tdel idmap[i]\\n\\t\\t\\t\\t\\t\\t\\tres += str(i)\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass binaryIndexTree:\\n\\n\\t\\tdef __init__(self, length: int):\\n\\t\\t\\tself.arr = [0] * (length + 1)\\n\\n\\t\\tdef add(self, idx: int, val: int):\\n\\t\\t\\twhile idx < len(self.arr):\\n\\t\\t\\t\\tself.arr[idx] += val\\n\\t\\t\\t\\tidx += idx & -idx\\n\\n\\t\\tdef query(self, idx: int):\\n\\t\\t\\tres = 0\\n\\t\\t\\twhile idx > 0:\\n\\t\\t\\t\\tres += self.arr[idx]\\n\\t\\t\\t\\tidx -= idx & -idx\\n\\t\\t\\treturn res\\n\\n\\tclass Solution:\\n\\t\\tdef minInteger(self, num: str, k: int) -> str:\\n\\t\\t\\tidmap = defaultdict(list)\\n\\t\\t\\tfor i in range(len(num)):\\n\\t\\t\\t\\tidmap[int(num[i])].append(i)\\n\\n\\t\\t\\ttree = binaryIndexTree(len(num))\\n\\t\\t\\tres = \\'\\'\\n\\t\\t\\tfor _ in range(len(num)):\\n\\t\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\t\\tif i in idmap:\\n\\t\\t\\t\\t\\t\\trelevant = tree.query(idmap[i][0] + 1)\\n\\t\\t\\t\\t\\t\\tval = idmap[i][0] - relevant\\n\\t\\t\\t\\t\\t\\tif val <= k:\\n\\t\\t\\t\\t\\t\\t\\tk -= val\\n\\t\\t\\t\\t\\t\\t\\ttree.add(idmap[i].pop(0) + 1, 1)\\n\\t\\t\\t\\t\\t\\t\\tif not idmap[i]:\\n\\t\\t\\t\\t\\t\\t\\t\\tdel idmap[i]\\n\\t\\t\\t\\t\\t\\t\\tres += str(i)\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 877010,
                "title": "python-o-n-time-and-o-1-space-complexity",
                "content": "```\\nclass Solution:\\n    def minInteger(self, num, k):\\n        ln=len(num)\\n        optimizedNums=0\\n        YJSP=1145141919810\\n        a={\\'0\\':YJSP,\\'1\\':YJSP,\\'2\\':YJSP,\\'3\\':YJSP,\\'4\\':YJSP,\\'5\\':YJSP,\\'6\\':YJSP,\\'7\\':YJSP,\\'8\\':YJSP,\\'9\\':YJSP}\\n        for i in range(ln):\\n            if i<a[num[i]]:a[num[i]]=i   \\n        while k>0 and optimizedNums<ln:\\n            for i in a:\\n                if a[i]-optimizedNums<=k:\\n                    num=num[:optimizedNums]+i+num[optimizedNums:a[i]]+num[a[i]+1:]\\n                    k-=a[i]-optimizedNums\\n                    for j in a:\\n                        if a[j]<a[i]:a[j]+=1               \\n                    for j in range(a[i]+1,ln):\\n                        if num[j]==i:\\n                            a[i]=j\\n                            break\\n                    else:\\n                        a[i]=YJSP\\n                    break\\n            optimizedNums+=1\\n        return num\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInteger(self, num, k):\\n        ln=len(num)\\n        optimizedNums=0\\n        YJSP=1145141919810\\n        a={\\'0\\':YJSP,\\'1\\':YJSP,\\'2\\':YJSP,\\'3\\':YJSP,\\'4\\':YJSP,\\'5\\':YJSP,\\'6\\':YJSP,\\'7\\':YJSP,\\'8\\':YJSP,\\'9\\':YJSP}\\n        for i in range(ln):\\n            if i<a[num[i]]:a[num[i]]=i   \\n        while k>0 and optimizedNums<ln:\\n            for i in a:\\n                if a[i]-optimizedNums<=k:\\n                    num=num[:optimizedNums]+i+num[optimizedNums:a[i]]+num[a[i]+1:]\\n                    k-=a[i]-optimizedNums\\n                    for j in a:\\n                        if a[j]<a[i]:a[j]+=1               \\n                    for j in range(a[i]+1,ln):\\n                        if num[j]==i:\\n                            a[i]=j\\n                            break\\n                    else:\\n                        a[i]=YJSP\\n                    break\\n            optimizedNums+=1\\n        return num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847387,
                "title": "my-java-solution-hashmap-and-segmenttree-o-n-log-n",
                "content": "```\\nclass Solution {\\n    public String minInteger(String num, int k) \\n    {\\n        \\n\\t\\tHashMap<Integer,List<Integer>> digitVsPositionMap = new HashMap< Integer,List<Integer>> ();\\n\\n\\t\\tfor (int i = 0; i <= 9; ++i) \\n\\t\\t{\\n\\t\\t\\tdigitVsPositionMap.put(i, new LinkedList<>());\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < num.length(); ++i) \\n\\t\\t{\\n\\t\\t\\tint numberAtDigit =  Character.getNumericValue(num.charAt(i)) ;\\n\\n\\t\\t\\tList<Integer> list = digitVsPositionMap.get(numberAtDigit);\\n\\n\\t\\t\\tlist.add(i);\\n\\n\\t\\t\\tdigitVsPositionMap.put(numberAtDigit, list);\\n\\t\\t}\\n\\n\\t\\tString ans = \"\";\\n\\t\\t\\n\\t\\t\\n\\t\\tint posArr[] = new int[num.length()];\\n\\t\\t\\n\\t\\tArrays.fill(posArr, 0);\\n\\t\\t\\n\\t\\tSegmentTree tree = new SegmentTree(posArr);\\n\\t\\t\\n\\t\\tfor (int i = 0; i < num.length(); ++i) \\n\\t\\t{\\n\\t\\t\\t\\n\\t\\t\\tfor (int digit = 0; digit <= 9; ++digit) \\n\\t\\t\\t{\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (digitVsPositionMap.get(digit).size() != 0) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tInteger pos = digitVsPositionMap.get(digit).get(0);\\n\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tint shift = tree.sumRange( 0 , pos);\\n\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif (pos - shift <= k) \\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tk -= pos - shift;\\n\\n\\t\\t\\t\\t\\t\\ttree.update(pos, 1);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tdigitVsPositionMap.get(digit).remove(0);\\n\\n\\t\\t\\t\\t\\t\\tans += digit;\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t\\n    }\\n}\\n\\nclass SegmentTree \\n{\\n\\t\\n\\tSegmentTreeNode root = null;\\n\\t\\n\\tpublic SegmentTree( int[] nums )\\n\\t{\\n\\t\\troot = buildTree(nums, 0, nums.length-1);\\n\\t}\\n\\n\\n\\tprivate SegmentTreeNode buildTree(int[] nums, int start, int end) \\n\\t{\\n\\t\\tif (start > end)  // base case\\n\\t\\t{\\n\\t\\t\\treturn null;\\n\\t\\t} \\n\\t\\telse \\n\\t\\t{\\n\\t\\t\\tSegmentTreeNode ret = new SegmentTreeNode(start, end);\\n\\t\\t\\t\\n\\t\\t\\tif (start == end)   // if start and end index are same , then we reached leaf nodes , here after no childs \\n\\t\\t\\t{\\n\\t\\t\\t\\tret.sum = nums[start];\\n\\t\\t\\t} \\n\\t\\t\\telse  // else there is child that we need to explore\\n\\t\\t\\t{\\n\\t\\t\\t\\tint mid = start  + (end - start) / 2;             \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tret.left = buildTree(nums, start, mid);  // constructing left sub tree \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tret.right = buildTree(nums, mid + 1, end); // constructing right sub tree\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tret.sum = ret.left.sum + ret.right.sum;  // updating the root sum \\n\\t\\t\\t} \\n\\t\\t\\t\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic void update(int i, int val) \\n\\t{\\n        update(root, i, val);\\n    }\\n   \\n    private void update(SegmentTreeNode root, int pos, int val) \\n    {\\n        if (root.start == root.end) \\n        {\\n           root.sum = val;\\n        }\\n        else \\n        {\\n            int mid = root.start + (root.end - root.start) / 2;  // find the mid index of the root node\\n            \\n            if (pos <= mid)   // if the index of the element ( for which we have to update value ) is less than mid , \\n            {\\t\\t\\t\\t  //then node lies in left subtree \\n                 update(root.left, pos, val);\\n            } \\n            else  //  or else it lies in right sub tree \\n            {\\n                 update(root.right, pos, val);\\n            }\\n            \\n            root.sum = root.left.sum + root.right.sum; // after exploring  we are updating the root element sum , since it child values changed\\n        }\\n    }\\n\\n    public int sumRange(int i, int j) \\n    {\\n        return sumRange(root, i, j);\\n    }\\n    \\n    private int sumRange(SegmentTreeNode root, int start, int end) \\n    {\\n        if (root.end == end && root.start == start) \\n        {\\n            return root.sum;\\n        } \\n        else \\n        {\\n            int mid = root.start + (root.end - root.start) / 2;\\n            \\n            if (end <= mid)    \\n            {\\n                return sumRange(root.left, start, end);\\n            } \\n            else if (start >= mid+1) \\n            {\\n                return sumRange(root.right, start, end);\\n            }  \\n            else \\n            {    \\n                return sumRange(root.right, mid+1, end) + sumRange(root.left, start, mid);\\n            }\\n        }\\n    }\\n\\t\\n\\tclass SegmentTreeNode \\n\\t{\\n        int start, end;\\n        SegmentTreeNode left, right;\\n        int sum;\\n\\n        public SegmentTreeNode(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n            this.left = null;\\n            this.right = null;\\n            this.sum = 0;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minInteger(String num, int k) \\n    {\\n        \\n\\t\\tHashMap<Integer,List<Integer>> digitVsPositionMap = new HashMap< Integer,List<Integer>> ();\\n\\n\\t\\tfor (int i = 0; i <= 9; ++i) \\n\\t\\t{\\n\\t\\t\\tdigitVsPositionMap.put(i, new LinkedList<>());\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < num.length(); ++i) \\n\\t\\t{\\n\\t\\t\\tint numberAtDigit =  Character.getNumericValue(num.charAt(i)) ;\\n\\n\\t\\t\\tList<Integer> list = digitVsPositionMap.get(numberAtDigit);\\n\\n\\t\\t\\tlist.add(i);\\n\\n\\t\\t\\tdigitVsPositionMap.put(numberAtDigit, list);\\n\\t\\t}\\n\\n\\t\\tString ans = \"\";\\n\\t\\t\\n\\t\\t\\n\\t\\tint posArr[] = new int[num.length()];\\n\\t\\t\\n\\t\\tArrays.fill(posArr, 0);\\n\\t\\t\\n\\t\\tSegmentTree tree = new SegmentTree(posArr);\\n\\t\\t\\n\\t\\tfor (int i = 0; i < num.length(); ++i) \\n\\t\\t{\\n\\t\\t\\t\\n\\t\\t\\tfor (int digit = 0; digit <= 9; ++digit) \\n\\t\\t\\t{\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (digitVsPositionMap.get(digit).size() != 0) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tInteger pos = digitVsPositionMap.get(digit).get(0);\\n\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tint shift = tree.sumRange( 0 , pos);\\n\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif (pos - shift <= k) \\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tk -= pos - shift;\\n\\n\\t\\t\\t\\t\\t\\ttree.update(pos, 1);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tdigitVsPositionMap.get(digit).remove(0);\\n\\n\\t\\t\\t\\t\\t\\tans += digit;\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t\\n    }\\n}\\n\\nclass SegmentTree \\n{\\n\\t\\n\\tSegmentTreeNode root = null;\\n\\t\\n\\tpublic SegmentTree( int[] nums )\\n\\t{\\n\\t\\troot = buildTree(nums, 0, nums.length-1);\\n\\t}\\n\\n\\n\\tprivate SegmentTreeNode buildTree(int[] nums, int start, int end) \\n\\t{\\n\\t\\tif (start > end)  // base case\\n\\t\\t{\\n\\t\\t\\treturn null;\\n\\t\\t} \\n\\t\\telse \\n\\t\\t{\\n\\t\\t\\tSegmentTreeNode ret = new SegmentTreeNode(start, end);\\n\\t\\t\\t\\n\\t\\t\\tif (start == end)   // if start and end index are same , then we reached leaf nodes , here after no childs \\n\\t\\t\\t{\\n\\t\\t\\t\\tret.sum = nums[start];\\n\\t\\t\\t} \\n\\t\\t\\telse  // else there is child that we need to explore\\n\\t\\t\\t{\\n\\t\\t\\t\\tint mid = start  + (end - start) / 2;             \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tret.left = buildTree(nums, start, mid);  // constructing left sub tree \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tret.right = buildTree(nums, mid + 1, end); // constructing right sub tree\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tret.sum = ret.left.sum + ret.right.sum;  // updating the root sum \\n\\t\\t\\t} \\n\\t\\t\\t\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic void update(int i, int val) \\n\\t{\\n        update(root, i, val);\\n    }\\n   \\n    private void update(SegmentTreeNode root, int pos, int val) \\n    {\\n        if (root.start == root.end) \\n        {\\n           root.sum = val;\\n        }\\n        else \\n        {\\n            int mid = root.start + (root.end - root.start) / 2;  // find the mid index of the root node\\n            \\n            if (pos <= mid)   // if the index of the element ( for which we have to update value ) is less than mid , \\n            {\\t\\t\\t\\t  //then node lies in left subtree \\n                 update(root.left, pos, val);\\n            } \\n            else  //  or else it lies in right sub tree \\n            {\\n                 update(root.right, pos, val);\\n            }\\n            \\n            root.sum = root.left.sum + root.right.sum; // after exploring  we are updating the root element sum , since it child values changed\\n        }\\n    }\\n\\n    public int sumRange(int i, int j) \\n    {\\n        return sumRange(root, i, j);\\n    }\\n    \\n    private int sumRange(SegmentTreeNode root, int start, int end) \\n    {\\n        if (root.end == end && root.start == start) \\n        {\\n            return root.sum;\\n        } \\n        else \\n        {\\n            int mid = root.start + (root.end - root.start) / 2;\\n            \\n            if (end <= mid)    \\n            {\\n                return sumRange(root.left, start, end);\\n            } \\n            else if (start >= mid+1) \\n            {\\n                return sumRange(root.right, start, end);\\n            }  \\n            else \\n            {    \\n                return sumRange(root.right, mid+1, end) + sumRange(root.left, start, mid);\\n            }\\n        }\\n    }\\n\\t\\n\\tclass SegmentTreeNode \\n\\t{\\n        int start, end;\\n        SegmentTreeNode left, right;\\n        int sum;\\n\\n        public SegmentTreeNode(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n            this.left = null;\\n            this.right = null;\\n            this.sum = 0;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791475,
                "title": "javascript-greedy-solution",
                "content": "```\\n\\tvar minInteger = function (num, k) {\\n        if (!num || num.length === 0 || k <= 0) return num;\\n        num = num.split(\"\").map(Number);\\n        let len = num.length;\\n        let l = 0,\\n          index = 0,\\n          smallest = Infinity;\\n        while (k > 0 && l < len - 1) {\\n          smallest = Infinity;\\n          for (let i = l; i < len && i <= l + k; i++) {\\n            if (num[i] < smallest) {\\n              smallest = num[i];\\n              index = i;\\n            }\\n          }\\n          for (let j = index; j > l; j--) {\\n            [num[j], num[j - 1]] = [num[j - 1], num[j]];\\n            k--;\\n            if (k <= 0) {\\n              break;\\n            }\\n          }\\n          l++;\\n        }\\n        return num.join(\"\");\\n      };",
                "solutionTags": [],
                "code": "```\\n\\tvar minInteger = function (num, k) {\\n        if (!num || num.length === 0 || k <= 0) return num;\\n        num = num.split(\"\").map(Number);\\n        let len = num.length;\\n        let l = 0,\\n          index = 0,\\n          smallest = Infinity;\\n        while (k > 0 && l < len - 1) {\\n          smallest = Infinity;\\n          for (let i = l; i < len && i <= l + k; i++) {\\n            if (num[i] < smallest) {\\n              smallest = num[i];\\n              index = i;\\n            }\\n          }\\n          for (let j = index; j > l; j--) {\\n            [num[j], num[j - 1]] = [num[j - 1], num[j]];\\n            k--;\\n            if (k <= 0) {\\n              break;\\n            }\\n          }\\n          l++;\\n        }\\n        return num.join(\"\");\\n      };",
                "codeTag": "Unknown"
            },
            {
                "id": 788851,
                "title": "accepted-java-unique-solution-using-doubly-linked-list",
                "content": "Key idea is seeing that using `ArrayList` would TLE because of the `list.add()` and `list.remove()` taking O(n) when used in shifting the digits.\\nDoubly linked list makes these O(1) operations.\\n\\n```\\nimport org.junit.Test;\\n\\nimport static org.junit.Assert.assertEquals;\\n\\npublic class Solution {\\n\\n    private static class Node {\\n\\n        Node prevNode;\\n        Node nextNode;\\n        final int val;\\n\\n        Node(final int val) {\\n            this.val = val;\\n        }\\n\\n        Node addNext(final int i) {\\n            final Node next = new Node(i);\\n            this.nextNode = next;\\n            next.prevNode = this;\\n            return next;\\n        }\\n\\n        void addPrev(final Node node) {\\n            final Node prev = this.prevNode;\\n            node.prevNode = prev;\\n\\n            if (prev != null) {\\n                prev.nextNode = node;\\n            }\\n\\n            node.nextNode = this;\\n            this.prevNode = node;\\n        }\\n\\n        void unlink() {\\n            final Node prev = this.prevNode;\\n            final Node next = this.nextNode;\\n            this.prevNode = null;\\n            this.nextNode = null;\\n            prev.nextNode = next;\\n\\n            if (next != null) {\\n                next.prevNode = prev;\\n            }\\n        }\\n\\n        @Override\\n        public String toString() {\\n            Node current = this;\\n            final StringBuilder sb = new StringBuilder();\\n\\n            while (current != null) {\\n                sb.append(current.val);\\n                current = current.nextNode;\\n            }\\n\\n            return sb.toString();\\n        }\\n\\n    }\\n\\n    private boolean increasing(final String num) {\\n        for (int i = 0; i < num.length() - 1; i++) {\\n            if (num.charAt(i) > num.charAt(i + 1)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    public String minInteger(final String num, final int k) {\\n        if (increasing(num)) {\\n            return num;\\n        }\\n\\n        final Node head = new Node(num.charAt(0) - \\'0\\');\\n        Node tail = head;\\n\\n        for (int i = 1; i < num.length(); i++) {\\n            tail = tail.addNext(num.charAt(i) - \\'0\\');\\n        }\\n\\n        final Node newHead = swap(head, k);\\n        return newHead.toString();\\n    }\\n\\n    private Node swap(final Node head, final int remaining) {\\n        if (remaining == 0 || head == null) {\\n            return null;\\n        }\\n\\n        if (head.val == 0) {\\n            swap(head.nextNode, remaining);\\n            return head;\\n        }\\n\\n        Node nextSmallest = null;\\n        int nextSmallestDistance = 0;\\n\\n        Node current = head.nextNode;\\n        int distance = 1;\\n\\n        while (current != null && distance <= remaining) {\\n            if (nextSmallest == null || current.val < nextSmallest.val) {\\n                nextSmallest = current;\\n                nextSmallestDistance = distance;\\n            }\\n\\n            current = current.nextNode;\\n            distance++;\\n        }\\n\\n        if (nextSmallest != null && nextSmallest.val < head.val) {\\n            nextSmallest.unlink(); // O(1)\\n            head.addPrev(nextSmallest); // O(1)\\n            swap(head, remaining - nextSmallestDistance);\\n            return nextSmallest;\\n        }\\n\\n        swap(head.nextNode, remaining);\\n        return head;\\n    }\\n\\n    @Test\\n    public void test() {\\n        assertEquals(\"012345\", new Solution().minInteger(\"012345\", 23));\\n        assertEquals(\"0345989723478563548\", new Solution().minInteger(\"9438957234785635408\", 23));\\n        assertEquals(\"1342\",new Solution().minInteger(\"4321\", 4));\\n        assertEquals(\"010\",new Solution().minInteger(\"100\", 1));\\n        assertEquals(\"36789\",new Solution().minInteger(\"36789\", 1000));\\n        assertEquals(\"22\",new Solution().minInteger(\"22\", 22));\\n        assertEquals(\"124498948179\",new Solution().minInteger(\"294984148179\", 11));\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport org.junit.Test;\\n\\nimport static org.junit.Assert.assertEquals;\\n\\npublic class Solution {\\n\\n    private static class Node {\\n\\n        Node prevNode;\\n        Node nextNode;\\n        final int val;\\n\\n        Node(final int val) {\\n            this.val = val;\\n        }\\n\\n        Node addNext(final int i) {\\n            final Node next = new Node(i);\\n            this.nextNode = next;\\n            next.prevNode = this;\\n            return next;\\n        }\\n\\n        void addPrev(final Node node) {\\n            final Node prev = this.prevNode;\\n            node.prevNode = prev;\\n\\n            if (prev != null) {\\n                prev.nextNode = node;\\n            }\\n\\n            node.nextNode = this;\\n            this.prevNode = node;\\n        }\\n\\n        void unlink() {\\n            final Node prev = this.prevNode;\\n            final Node next = this.nextNode;\\n            this.prevNode = null;\\n            this.nextNode = null;\\n            prev.nextNode = next;\\n\\n            if (next != null) {\\n                next.prevNode = prev;\\n            }\\n        }\\n\\n        @Override\\n        public String toString() {\\n            Node current = this;\\n            final StringBuilder sb = new StringBuilder();\\n\\n            while (current != null) {\\n                sb.append(current.val);\\n                current = current.nextNode;\\n            }\\n\\n            return sb.toString();\\n        }\\n\\n    }\\n\\n    private boolean increasing(final String num) {\\n        for (int i = 0; i < num.length() - 1; i++) {\\n            if (num.charAt(i) > num.charAt(i + 1)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    public String minInteger(final String num, final int k) {\\n        if (increasing(num)) {\\n            return num;\\n        }\\n\\n        final Node head = new Node(num.charAt(0) - \\'0\\');\\n        Node tail = head;\\n\\n        for (int i = 1; i < num.length(); i++) {\\n            tail = tail.addNext(num.charAt(i) - \\'0\\');\\n        }\\n\\n        final Node newHead = swap(head, k);\\n        return newHead.toString();\\n    }\\n\\n    private Node swap(final Node head, final int remaining) {\\n        if (remaining == 0 || head == null) {\\n            return null;\\n        }\\n\\n        if (head.val == 0) {\\n            swap(head.nextNode, remaining);\\n            return head;\\n        }\\n\\n        Node nextSmallest = null;\\n        int nextSmallestDistance = 0;\\n\\n        Node current = head.nextNode;\\n        int distance = 1;\\n\\n        while (current != null && distance <= remaining) {\\n            if (nextSmallest == null || current.val < nextSmallest.val) {\\n                nextSmallest = current;\\n                nextSmallestDistance = distance;\\n            }\\n\\n            current = current.nextNode;\\n            distance++;\\n        }\\n\\n        if (nextSmallest != null && nextSmallest.val < head.val) {\\n            nextSmallest.unlink(); // O(1)\\n            head.addPrev(nextSmallest); // O(1)\\n            swap(head, remaining - nextSmallestDistance);\\n            return nextSmallest;\\n        }\\n\\n        swap(head.nextNode, remaining);\\n        return head;\\n    }\\n\\n    @Test\\n    public void test() {\\n        assertEquals(\"012345\", new Solution().minInteger(\"012345\", 23));\\n        assertEquals(\"0345989723478563548\", new Solution().minInteger(\"9438957234785635408\", 23));\\n        assertEquals(\"1342\",new Solution().minInteger(\"4321\", 4));\\n        assertEquals(\"010\",new Solution().minInteger(\"100\", 1));\\n        assertEquals(\"36789\",new Solution().minInteger(\"36789\", 1000));\\n        assertEquals(\"22\",new Solution().minInteger(\"22\", 22));\\n        assertEquals(\"124498948179\",new Solution().minInteger(\"294984148179\", 11));\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779446,
                "title": "c-76ms-o-nlgn-time-o-n-space",
                "content": "```\\nclass Solution {\\n    \\n    vector<int> presum;\\n    \\n    void update(int i) {\\n        i++;\\n        while(i < presum.size()) {\\n            presum[i]++;\\n            i += i & -i;\\n        }\\n    }\\n    \\n    int getpresum(int i) {  // get number of digits before index i having already been put into string.\\n        int res = 0;\\n        while(i) {\\n            res += presum[i];\\n            i -= i & -i;\\n        }\\n        return res;\\n    }\\n    \\npublic:\\n\\n    string minInteger(string num, int k) {\\n        \\n        int n = num.size();\\n        if(k >= n * (n - 1) / 2) {  // trivial case\\n            std::sort(num.begin(), num.end());\\n            return num;\\n        }\\n\\n        presum.assign(n + 1, 0);\\n        \\n        vector<vector<int>> v(10);\\n        for(int i = 0; i < num.size(); i++) v[num[i] - \\'0\\'].push_back(i);  // v[i] contains indices of digit i in num\\n        \\n        string res;\\n        vector<int> c(10, 0); // c[i]: beginning index of unprocessed v[i]\\n        \\n        for(int i = 0; i < num.size(); i++) { \\n            for(int j = 0; j < 10; j++) { \\n                if(c[j] < v[j].size() && v[j][c[j]] - getpresum(v[j][c[j]]) <= k) { // choose smallest feasible char to fill res\\n                    res.push_back(\\'0\\' + j);\\n                    update(v[j][c[j]]);\\n                    k -= v[j][c[j]] - getpresum(v[j][c[j]]);\\n                    c[j]++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    vector<int> presum;\\n    \\n    void update(int i) {\\n        i++;\\n        while(i < presum.size()) {\\n            presum[i]++;\\n            i += i & -i;\\n        }\\n    }\\n    \\n    int getpresum(int i) {  // get number of digits before index i having already been put into string.\\n        int res = 0;\\n        while(i) {\\n            res += presum[i];\\n            i -= i & -i;\\n        }\\n        return res;\\n    }\\n    \\npublic:\\n\\n    string minInteger(string num, int k) {\\n        \\n        int n = num.size();\\n        if(k >= n * (n - 1) / 2) {  // trivial case\\n            std::sort(num.begin(), num.end());\\n            return num;\\n        }\\n\\n        presum.assign(n + 1, 0);\\n        \\n        vector<vector<int>> v(10);\\n        for(int i = 0; i < num.size(); i++) v[num[i] - \\'0\\'].push_back(i);  // v[i] contains indices of digit i in num\\n        \\n        string res;\\n        vector<int> c(10, 0); // c[i]: beginning index of unprocessed v[i]\\n        \\n        for(int i = 0; i < num.size(); i++) { \\n            for(int j = 0; j < 10; j++) { \\n                if(c[j] < v[j].size() && v[j][c[j]] - getpresum(v[j][c[j]]) <= k) { // choose smallest feasible char to fill res\\n                    res.push_back(\\'0\\' + j);\\n                    update(v[j][c[j]]);\\n                    k -= v[j][c[j]] - getpresum(v[j][c[j]]);\\n                    c[j]++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747180,
                "title": "javascript-fenwick-tree",
                "content": "\\t/**\\n\\t * @param {string} num\\n\\t * @param {number} k\\n\\t * @return {string}\\n\\t */\\n\\tfunction FenwickTree(n) {\\n\\t\\tthis.sum = Array(n+1).fill(0);\\n\\t}\\n\\n\\tFenwickTree.prototype.update = function(i, delta) {\\n\\t\\twhile (i < this.sum.length) {\\n\\t\\t\\tthis.sum[i] += delta;\\n\\t\\t\\ti += i & (-i);\\n\\t\\t}\\n\\t}\\n\\n\\tFenwickTree.prototype.query = function(i) {\\n\\t\\tlet sum = 0;\\n\\t\\twhile (i > 0) {\\n\\t\\t\\tsum += this.sum[i];\\n\\t\\t\\ti -= i & (-i);\\n\\t\\t}\\n\\n\\t\\treturn sum;\\n\\t}\\n\\n\\tvar minInteger = function(num, k) {\\n\\t\\tconst n = num.length;\\n\\t\\tconst pos = {}\\n\\n\\t\\tfor (let i = 0; i < n; i++) {\\n\\t\\t\\tpos[num[i]] = pos[num[i]] || []\\n\\t\\t\\tpos[num[i]].push(i);\\n\\t\\t}\\n\\n\\t\\tconst fenwickTree = new FenwickTree(n);\\n\\t\\tconst used = new Set();\\n\\t\\tlet ans = \\'\\';\\n\\n\\t\\twhile (k > 0 && ans.length < n) {\\n\\t\\t\\tfor (let d = 0; d < 10; d++) {\\n\\t\\t\\t\\tif (!pos[d+\\'\\'] || !pos[d+\\'\\'].length) continue;\\n\\t\\t\\t\\tconst i = pos[d+\\'\\'][0];\\n\\t\\t\\t\\tconst cost = i - fenwickTree.query(i);\\n\\t\\t\\t\\tif (cost > k) continue;\\n\\t\\t\\t\\tk -= cost;\\n\\t\\t\\t\\tans += d;\\n\\t\\t\\t\\tfenwickTree.update(i+1, 1);\\n\\t\\t\\t\\tused.add(i);\\n\\t\\t\\t\\tpos[d+\\'\\'].shift();\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (let i = 0; i < n; i++) {\\n\\t\\t\\tif (!used.has(i)) ans += num[i];\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t};",
                "solutionTags": [],
                "code": "\\t/**\\n\\t * @param {string} num\\n\\t * @param {number} k\\n\\t * @return {string}\\n\\t */\\n\\tfunction FenwickTree(n) {\\n\\t\\tthis.sum = Array(n+1).fill(0);\\n\\t}\\n\\n\\tFenwickTree.prototype.update = function(i, delta) {\\n\\t\\twhile (i < this.sum.length) {\\n\\t\\t\\tthis.sum[i] += delta;\\n\\t\\t\\ti += i & (-i);\\n\\t\\t}\\n\\t}\\n\\n\\tFenwickTree.prototype.query = function(i) {\\n\\t\\tlet sum = 0;\\n\\t\\twhile (i > 0) {\\n\\t\\t\\tsum += this.sum[i];\\n\\t\\t\\ti -= i & (-i);\\n\\t\\t}\\n\\n\\t\\treturn sum;\\n\\t}\\n\\n\\tvar minInteger = function(num, k) {\\n\\t\\tconst n = num.length;\\n\\t\\tconst pos = {}\\n\\n\\t\\tfor (let i = 0; i < n; i++) {\\n\\t\\t\\tpos[num[i]] = pos[num[i]] || []\\n\\t\\t\\tpos[num[i]].push(i);\\n\\t\\t}\\n\\n\\t\\tconst fenwickTree = new FenwickTree(n);\\n\\t\\tconst used = new Set();\\n\\t\\tlet ans = \\'\\';\\n\\n\\t\\twhile (k > 0 && ans.length < n) {\\n\\t\\t\\tfor (let d = 0; d < 10; d++) {\\n\\t\\t\\t\\tif (!pos[d+\\'\\'] || !pos[d+\\'\\'].length) continue;\\n\\t\\t\\t\\tconst i = pos[d+\\'\\'][0];\\n\\t\\t\\t\\tconst cost = i - fenwickTree.query(i);\\n\\t\\t\\t\\tif (cost > k) continue;\\n\\t\\t\\t\\tk -= cost;\\n\\t\\t\\t\\tans += d;\\n\\t\\t\\t\\tfenwickTree.update(i+1, 1);\\n\\t\\t\\t\\tused.add(i);\\n\\t\\t\\t\\tpos[d+\\'\\'].shift();\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (let i = 0; i < n; i++) {\\n\\t\\t\\tif (!used.has(i)) ans += num[i];\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 746719,
                "title": "rust-translated-binary-indexed-tree",
                "content": "Runtime: 20 ms, faster than 100.00% of Rust online submissions for Minimum Possible Integer After at Most K Adjacent Swaps On Digits.\\nMemory Usage: 2.4 MB, less than 100.00% of Rust online submissions for Minimum Possible Integer After at Most K Adjacent Swaps On Digits.\\n```rust\\n#[derive(Debug, Default)]\\nstruct BinaryIndexedTree {\\n    n: usize,\\n    nodes: Vec<i32>,\\n}\\n\\nimpl BinaryIndexedTree {\\n    fn new(n: usize) -> BinaryIndexedTree {\\n        BinaryIndexedTree {\\n            n,\\n            nodes: vec![0; n + 1],\\n        }\\n    }\\n\\n    pub fn update(&mut self, idx: usize, delta: i32) {\\n        let mut i = (idx + 1) as i32;\\n        while i <= self.n as i32 {\\n            self.nodes[i as usize] += delta;\\n            i += i & (-i);\\n        }\\n    }\\n\\n    pub fn query(&mut self, idx: usize) -> i32 {\\n        let mut i = (idx + 1) as i32;\\n        let mut sum = 0;\\n        while i > 0 {\\n            sum += self.nodes[i as usize];\\n            i -= i & (-i);\\n        }\\n        sum\\n    }\\n}\\nimpl Solution {\\n    pub fn min_integer(num: String, k: i32) -> String {\\n        let n = num.len();\\n        let mut qs = vec![Vec::<i32>::new(); 10];\\n        for (pos, d) in num.as_bytes().iter().enumerate() {\\n            qs[(d - b\\'0\\') as usize].push(pos as i32);\\n        }\\n        let mut removed = vec![false; n];\\n        let mut tree = BinaryIndexedTree::new(n);\\n        let mut k = k;\\n        let mut ans = String::new();\\n        while k > 0 {\\n            let mut found = false;\\n            for d in 0..10 {\\n                if !qs[d as usize].is_empty() {\\n                    let pos = qs[d as usize][0];\\n                    let shifted = tree.query(pos as usize);\\n                    if pos - shifted <= k {\\n                        k -= pos - shifted;\\n                        tree.update(pos as usize, 1);\\n                        qs[d].remove(0);\\n                        ans.push((b\\'0\\' + d as u8) as char);\\n                        removed[pos as usize] = true;\\n                        found = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if !found {\\n                break;\\n            }\\n        }\\n        for i in 0..n {\\n            if !removed[i] {\\n                ans.push(num.as_bytes()[i] as char);\\n            }\\n        }\\n        ans\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_min_integer() {\\n        assert_eq!(\\n            Solution::min_integer(String::from(\"4321\"), 4),\\n            String::from(\"1342\")\\n        )\\n    }\\n\\n    #[test]\\n    fn test_min_integer_02() {\\n        assert_eq!(\\n            Solution::min_integer(String::from(\"100\"), 1),\\n            String::from(\"010\")\\n        )\\n    }\\n\\n    #[test]\\n    fn test_min_integer_03() {\\n        assert_eq!(\\n            Solution::min_integer(String::from(\"36789\"), 1000),\\n            String::from(\"36789\")\\n        )\\n    }\\n\\n    #[test]\\n    fn test_min_integer_04() {\\n        assert_eq!(\\n            Solution::min_integer(String::from(\"22\"), 22),\\n            String::from(\"22\")\\n        )\\n    }\\n\\n    #[test]\\n    fn test_min_integer_05() {\\n        assert_eq!(\\n            Solution::min_integer(String::from(\"9438957234785635408\"), 23),\\n            String::from(\"0345989723478563548\")\\n        )\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\n#[derive(Debug, Default)]\\nstruct BinaryIndexedTree {\\n    n: usize,\\n    nodes: Vec<i32>,\\n}\\n\\nimpl BinaryIndexedTree {\\n    fn new(n: usize) -> BinaryIndexedTree {\\n        BinaryIndexedTree {\\n            n,\\n            nodes: vec![0; n + 1],\\n        }\\n    }\\n\\n    pub fn update(&mut self, idx: usize, delta: i32) {\\n        let mut i = (idx + 1) as i32;\\n        while i <= self.n as i32 {\\n            self.nodes[i as usize] += delta;\\n            i += i & (-i);\\n        }\\n    }\\n\\n    pub fn query(&mut self, idx: usize) -> i32 {\\n        let mut i = (idx + 1) as i32;\\n        let mut sum = 0;\\n        while i > 0 {\\n            sum += self.nodes[i as usize];\\n            i -= i & (-i);\\n        }\\n        sum\\n    }\\n}\\nimpl Solution {\\n    pub fn min_integer(num: String, k: i32) -> String {\\n        let n = num.len();\\n        let mut qs = vec![Vec::<i32>::new(); 10];\\n        for (pos, d) in num.as_bytes().iter().enumerate() {\\n            qs[(d - b\\'0\\') as usize].push(pos as i32);\\n        }\\n        let mut removed = vec![false; n];\\n        let mut tree = BinaryIndexedTree::new(n);\\n        let mut k = k;\\n        let mut ans = String::new();\\n        while k > 0 {\\n            let mut found = false;\\n            for d in 0..10 {\\n                if !qs[d as usize].is_empty() {\\n                    let pos = qs[d as usize][0];\\n                    let shifted = tree.query(pos as usize);\\n                    if pos - shifted <= k {\\n                        k -= pos - shifted;\\n                        tree.update(pos as usize, 1);\\n                        qs[d].remove(0);\\n                        ans.push((b\\'0\\' + d as u8) as char);\\n                        removed[pos as usize] = true;\\n                        found = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if !found {\\n                break;\\n            }\\n        }\\n        for i in 0..n {\\n            if !removed[i] {\\n                ans.push(num.as_bytes()[i] as char);\\n            }\\n        }\\n        ans\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_min_integer() {\\n        assert_eq!(\\n            Solution::min_integer(String::from(\"4321\"), 4),\\n            String::from(\"1342\")\\n        )\\n    }\\n\\n    #[test]\\n    fn test_min_integer_02() {\\n        assert_eq!(\\n            Solution::min_integer(String::from(\"100\"), 1),\\n            String::from(\"010\")\\n        )\\n    }\\n\\n    #[test]\\n    fn test_min_integer_03() {\\n        assert_eq!(\\n            Solution::min_integer(String::from(\"36789\"), 1000),\\n            String::from(\"36789\")\\n        )\\n    }\\n\\n    #[test]\\n    fn test_min_integer_04() {\\n        assert_eq!(\\n            Solution::min_integer(String::from(\"22\"), 22),\\n            String::from(\"22\")\\n        )\\n    }\\n\\n    #[test]\\n    fn test_min_integer_05() {\\n        assert_eq!(\\n            Solution::min_integer(String::from(\"9438957234785635408\"), 23),\\n            String::from(\"0345989723478563548\")\\n        )\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 733274,
                "title": "java-segmenttree",
                "content": "Ref: https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/discuss/720548/O(n-logn)-or-Java-or-Heavily-Commented-or-Segment-Tree-or-Detailed-Explanation\\n```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        List<Queue<Integer>> list = new ArrayList<>();\\n        for (int i = 0; i <= 9; i++) {\\n            list.add(new LinkedList<>());\\n        }\\n        for (int i = 0; i < num.length(); i++) {\\n            list.get(num.charAt(i) - \\'0\\').offer(i);\\n        }\\n        \\n        Tree tr = new Tree(num.length());\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < num.length(); i++) {\\n            for (int j = 0; j <= 9; j++) {\\n                if (list.get(j).size() != 0) {\\n                    Integer pos = list.get(j).peek();\\n                    int shift = tr.getLowerSum(pos);\\n                    if (pos - shift <= k) {\\n                        list.get(j).poll();\\n                        k -= pos -shift;\\n                        tr.add(pos);\\n                        sb.append(j);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public class Tree{\\n        int[] nodes;\\n        int n;\\n        \\n        public Tree(int max) {\\n            nodes = new int[4 * max];\\n            n = max;\\n        }\\n        \\n        public void add(int num) {\\n            add(num, 0, n, 0);\\n        }\\n        \\n        private void add(int num, int l, int r, int node) {\\n            if (num < l || num > r) return;\\n            if (l == r) {\\n                nodes[node]++;\\n                return;\\n            }\\n            int mid = (r + l) / 2;\\n            add(num, l, mid, node * 2 + 1);\\n            add(num, mid + 1, r, node * 2 + 2);\\n            nodes[node] = nodes[node * 2 + 1] + nodes[node * 2 + 2];\\n        }\\n        \\n        public int getLowerSum(int pos) {\\n            return getSum(0, pos, 0, n, 0);\\n        }\\n        \\n        private int getSum(int ql, int qr, int l, int r, int node) {\\n            if (ql > r || qr < l) return 0;\\n            if (ql <= l && qr >= r) return nodes[node];\\n            int mid = (r + l) / 2;\\n            return getSum(ql, qr, l, mid, node * 2 + 1) + getSum(ql, qr, mid + 1, r, node * 2 + 2);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        List<Queue<Integer>> list = new ArrayList<>();\\n        for (int i = 0; i <= 9; i++) {\\n            list.add(new LinkedList<>());\\n        }\\n        for (int i = 0; i < num.length(); i++) {\\n            list.get(num.charAt(i) - \\'0\\').offer(i);\\n        }\\n        \\n        Tree tr = new Tree(num.length());\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < num.length(); i++) {\\n            for (int j = 0; j <= 9; j++) {\\n                if (list.get(j).size() != 0) {\\n                    Integer pos = list.get(j).peek();\\n                    int shift = tr.getLowerSum(pos);\\n                    if (pos - shift <= k) {\\n                        list.get(j).poll();\\n                        k -= pos -shift;\\n                        tr.add(pos);\\n                        sb.append(j);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public class Tree{\\n        int[] nodes;\\n        int n;\\n        \\n        public Tree(int max) {\\n            nodes = new int[4 * max];\\n            n = max;\\n        }\\n        \\n        public void add(int num) {\\n            add(num, 0, n, 0);\\n        }\\n        \\n        private void add(int num, int l, int r, int node) {\\n            if (num < l || num > r) return;\\n            if (l == r) {\\n                nodes[node]++;\\n                return;\\n            }\\n            int mid = (r + l) / 2;\\n            add(num, l, mid, node * 2 + 1);\\n            add(num, mid + 1, r, node * 2 + 2);\\n            nodes[node] = nodes[node * 2 + 1] + nodes[node * 2 + 2];\\n        }\\n        \\n        public int getLowerSum(int pos) {\\n            return getSum(0, pos, 0, n, 0);\\n        }\\n        \\n        private int getSum(int ql, int qr, int l, int r, int node) {\\n            if (ql > r || qr < l) return 0;\\n            if (ql <= l && qr >= r) return nodes[node];\\n            int mid = (r + l) / 2;\\n            return getSum(ql, qr, l, mid, node * 2 + 1) + getSum(ql, qr, mid + 1, r, node * 2 + 2);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731420,
                "title": "o-nlogn-binary-indexed-tree-recommend-one-video-otherwise-it-s-too-subtle-to-explain",
                "content": "Learned the whole process from this solution video https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/discuss/727273/Java-Fenwick-Tree-O(nlogn)-Solution, I personally feel that it\\'s very hard to understand what is going on by reading solutions by texts.\\n\\n```\\nclass FenwickArray {\\nprivate:\\n    vector<int> array;\\n\\npublic:\\n    FenwickArray(int n): array(vector<int>(n + 1, 0)) {}\\n\\n    int query(int idx) {\\n        int ans = 0;\\n        while (idx > 0) {\\n            ans += array[idx];\\n            idx -= idx & -idx;\\n        }\\n        return ans;\\n    }\\n\\n    void add(int idx, int delta) {\\n        while (idx < array.size()) {\\n            array[idx] += delta;\\n            idx += idx & -idx;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        vector<queue<int>> indices(10, queue<int>());\\n        for (int i = 0; i < num.size(); ++i) {\\n            indices[num[i] - \\'0\\'].emplace(i);\\n        }\\n        FenwickArray fenwick(num.size());\\n        for (int i = 0; i < num.size(); ++i) {\\n            fenwick.add(i + 1, 1);\\n        }\\n        ostringstream ans;\\n        for (int i = 0; i < num.size(); ++i) {\\n            for (int j = 0; j < 10; ++j) {\\n                if (!indices[j].empty()) {\\n                    int idx = indices[j].front();\\n                    int cost = fenwick.query(idx + 1) - 1;\\n                    if (cost <= k) {\\n                        ans << char(\\'0\\' + j);\\n                        indices[j].pop();\\n                        if (idx < num.size() - 1) {\\n                            fenwick.add(idx + 2, -1);\\n                        }\\n                        k -= cost;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans.str();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass FenwickArray {\\nprivate:\\n    vector<int> array;\\n\\npublic:\\n    FenwickArray(int n): array(vector<int>(n + 1, 0)) {}\\n\\n    int query(int idx) {\\n        int ans = 0;\\n        while (idx > 0) {\\n            ans += array[idx];\\n            idx -= idx & -idx;\\n        }\\n        return ans;\\n    }\\n\\n    void add(int idx, int delta) {\\n        while (idx < array.size()) {\\n            array[idx] += delta;\\n            idx += idx & -idx;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        vector<queue<int>> indices(10, queue<int>());\\n        for (int i = 0; i < num.size(); ++i) {\\n            indices[num[i] - \\'0\\'].emplace(i);\\n        }\\n        FenwickArray fenwick(num.size());\\n        for (int i = 0; i < num.size(); ++i) {\\n            fenwick.add(i + 1, 1);\\n        }\\n        ostringstream ans;\\n        for (int i = 0; i < num.size(); ++i) {\\n            for (int j = 0; j < 10; ++j) {\\n                if (!indices[j].empty()) {\\n                    int idx = indices[j].front();\\n                    int cost = fenwick.query(idx + 1) - 1;\\n                    if (cost <= k) {\\n                        ans << char(\\'0\\' + j);\\n                        indices[j].pop();\\n                        if (idx < num.size() - 1) {\\n                            fenwick.add(idx + 2, -1);\\n                        }\\n                        k -= cost;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans.str();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729134,
                "title": "o-n-log-n-solution-no-complex-ds",
                "content": "Let\\'s build queue for each digit and store the positions of this digit in the given string. For each item in the queue store number of items in original string which were moved to the front before this item. Do a loop while k > 0 and try to figure out, what is the smallest digit can be moved to the front. Let me illustrate this:\\n\\nFor instance, consider you have a string **4131231**.\\nThen we will store the following information:\\n\\nPositions for 1: 1, 3, 6, amount of moved items in front = 0, 0, 0\\nPositions for 2: 4, amount of moved items = 0\\nPositions for 3: 2, 5, amount of moved items = 0, 0\\nPositions for 4: 0, amount = 0\\n\\nSuppose we can move the first 1 to the front. Then we should update our amounts of moved items for other queues. So it becomes:\\nPositions for 1: 3, 6, amount = **1**, 0\\nPositions for 2: 4, amount = **1**\\nPositions for 3: 2, 5, amount of moved items = **1**, 0\\nPositions for 4: 0, amount = 0\\n\\nSuppose we move 1 to the front again. Then our information becomes as follows:\\nPositions for 1: 6, amount = **2**\\nPositions for 2: 4, amount = **2**\\nPositions for 3: 2, 5, amount of moved items = **1**, **1**\\nPositions for 4: 0, amount = 0\\nNotice the way we updated amount of moved items for 3, we simply found smallest item (5) > position (3) of moved digit (and incremented it).\\nThis is the place we can use binary search.\\n\\nAt each step, for each digit we compare k with value in the front queue - amount of moved items before. If a digit can be moved, we pop the item from the queue and update amount of items for each queue.\\n```\\nstring minInteger(string num, int k) {\\n\\tconst int n = num.size();\\n\\tconst int digits = 10;\\n\\n\\tvector<vector<int>> queues(digits);\\n\\tvector<int> curr(digits); // stores the head of each queue\\n\\n\\tvector<vector<int>> deltas(digits);\\n\\n\\tfor(int i = 0; i < n; ++i)\\n\\t{\\n\\t\\tqueues[num[i]-\\'0\\'].push_back(i);\\n\\t\\tdeltas[num[i]-\\'0\\'].push_back(0);\\n\\t}\\n\\n\\tstring prefix;\\n\\tvector<int> used(n);\\n\\n\\t// Put some sentinels to ease bunary search\\n\\tfor(int d = 0; d < digits; ++d)\\n\\t{\\n\\t\\tqueues[d].push_back(INT_MAX);\\n\\t\\tdeltas[d].push_back(0);            \\n\\t}\\n\\n\\twhile (k > 0)\\n\\t{\\n\\t\\tbool found = false;\\n\\n\\t\\tfor(int d = 0; d < digits; ++d)\\n\\t\\t{\\n\\t\\t\\tint& p = curr[d];\\n\\t\\t\\tif (p < queues[d].size())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint delta = queues[d][p] + deltas[d][p];\\n\\t\\t\\t\\tif (delta <= k)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint pos = queues[d][p];\\n\\t\\t\\t\\t\\tused[pos] = true;\\n\\n\\t\\t\\t\\t\\tprefix.push_back(\\'0\\' + d);\\n\\n\\t\\t\\t\\t\\t++p;\\n\\t\\t\\t\\t\\tif (p < queues[d].size())\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdeltas[d][p] += deltas[d][p-1];\\n\\t\\t\\t\\t\\t\\tdeltas[d][p] -= 1;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfound = true;\\n\\t\\t\\t\\t\\tk -= delta;\\n\\n\\t\\t\\t\\t\\tfor(int t = 0; t < digits; ++t)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (t == d)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\t\\tint low = curr[t]-1, high = queues[t].size()-1;\\n\\t\\t\\t\\t\\t\\twhile (low + 1 < high)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tint m = (low + high) / 2;    \\n\\n\\t\\t\\t\\t\\t\\t\\tif (queues[t][m] > pos)\\n\\t\\t\\t\\t\\t\\t\\t\\thigh = m;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tlow = m;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tdeltas[t][high]--;\\n\\n\\t\\t\\t\\t\\t\\t/*\\n\\t\\t\\t\\t\\t\\t// Equivalent of the binary search above\\n\\t\\t\\t\\t\\t\\tfor(int u = curr[t]; u < queues[t].size(); ++u)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif (queues[t][u] > pos)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tdeltas[t][u]--;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t*/\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!found)\\n\\t\\t\\tbreak;            \\n\\t}\\n\\n\\tstring suffix = \"\";\\n\\tfor(int i = 0; i < n; ++i)\\n\\t{\\n\\t\\tif (!used[i])\\n\\t\\t\\tsuffix.push_back(num[i]);\\n\\t}        \\n\\n\\treturn prefix + suffix;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nstring minInteger(string num, int k) {\\n\\tconst int n = num.size();\\n\\tconst int digits = 10;\\n\\n\\tvector<vector<int>> queues(digits);\\n\\tvector<int> curr(digits); // stores the head of each queue\\n\\n\\tvector<vector<int>> deltas(digits);\\n\\n\\tfor(int i = 0; i < n; ++i)\\n\\t{\\n\\t\\tqueues[num[i]-\\'0\\'].push_back(i);\\n\\t\\tdeltas[num[i]-\\'0\\'].push_back(0);\\n\\t}\\n\\n\\tstring prefix;\\n\\tvector<int> used(n);\\n\\n\\t// Put some sentinels to ease bunary search\\n\\tfor(int d = 0; d < digits; ++d)\\n\\t{\\n\\t\\tqueues[d].push_back(INT_MAX);\\n\\t\\tdeltas[d].push_back(0);            \\n\\t}\\n\\n\\twhile (k > 0)\\n\\t{\\n\\t\\tbool found = false;\\n\\n\\t\\tfor(int d = 0; d < digits; ++d)\\n\\t\\t{\\n\\t\\t\\tint& p = curr[d];\\n\\t\\t\\tif (p < queues[d].size())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint delta = queues[d][p] + deltas[d][p];\\n\\t\\t\\t\\tif (delta <= k)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint pos = queues[d][p];\\n\\t\\t\\t\\t\\tused[pos] = true;\\n\\n\\t\\t\\t\\t\\tprefix.push_back(\\'0\\' + d);\\n\\n\\t\\t\\t\\t\\t++p;\\n\\t\\t\\t\\t\\tif (p < queues[d].size())\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdeltas[d][p] += deltas[d][p-1];\\n\\t\\t\\t\\t\\t\\tdeltas[d][p] -= 1;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfound = true;\\n\\t\\t\\t\\t\\tk -= delta;\\n\\n\\t\\t\\t\\t\\tfor(int t = 0; t < digits; ++t)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (t == d)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\t\\tint low = curr[t]-1, high = queues[t].size()-1;\\n\\t\\t\\t\\t\\t\\twhile (low + 1 < high)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tint m = (low + high) / 2;    \\n\\n\\t\\t\\t\\t\\t\\t\\tif (queues[t][m] > pos)\\n\\t\\t\\t\\t\\t\\t\\t\\thigh = m;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tlow = m;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tdeltas[t][high]--;\\n\\n\\t\\t\\t\\t\\t\\t/*\\n\\t\\t\\t\\t\\t\\t// Equivalent of the binary search above\\n\\t\\t\\t\\t\\t\\tfor(int u = curr[t]; u < queues[t].size(); ++u)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif (queues[t][u] > pos)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tdeltas[t][u]--;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t*/\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!found)\\n\\t\\t\\tbreak;            \\n\\t}\\n\\n\\tstring suffix = \"\";\\n\\tfor(int i = 0; i < n; ++i)\\n\\t{\\n\\t\\tif (!used[i])\\n\\t\\t\\tsuffix.push_back(num[i]);\\n\\t}        \\n\\n\\treturn prefix + suffix;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 728883,
                "title": "java-bit-fenwick-tree",
                "content": "```\\nclass Solution {\\n    int n;\\n    int[] sum;\\n    \\n    private int lowbit(int i) {return i & (-i);}\\n    private void add(int x, int v) {\\n        for (int i = x; i <= n; i += lowbit(i)) {\\n            sum[i] += v;\\n        }\\n    }\\n    private int query(int x) {\\n        int res = 0;\\n        for (int i = x; i > 0; i -= lowbit(i)) {\\n            res += sum[i];\\n        }\\n        return res;\\n    }\\n    \\n    public String minInteger(String num, int k) {\\n        if (num == null || num.length() == 0) return num;\\n        Deque<Integer>[] pos = new Deque[10];  // save all pos of current digit\\n        for (int i = 0; i < 10; i++) {\\n            pos[i] = new ArrayDeque<>();\\n        }\\n        n = num.length();\\n        sum = new int[n + 1];\\n        for (int i = 0; i < n; i++) {\\n            pos[num.charAt(i) - \\'0\\'].addLast(i + 1);   // BIT starts with 1\\n        }\\n        \\n        StringBuilder res = new StringBuilder();\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j < 10; j++) {              // try all digits\\n                if (pos[j].isEmpty()) continue;         // all used\\n                int t = pos[j].peekFirst();             // get next closest digit\\n                int p = t + query(t);                   // query(p) \\u662F\\u5750\\u6807\\u504F\\u79FB\\u91CF\\n                if (p - i <= k) {\\n                    k -= p - i;\\n                    pos[j].pollFirst();\\n                    res.append(j);\\n                    add(1, 1);              // add all 1 in [1, t-1]    \\n                    add(t, -1);                \\n                    break;\\n                }   \\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int n;\\n    int[] sum;\\n    \\n    private int lowbit(int i) {return i & (-i);}\\n    private void add(int x, int v) {\\n        for (int i = x; i <= n; i += lowbit(i)) {\\n            sum[i] += v;\\n        }\\n    }\\n    private int query(int x) {\\n        int res = 0;\\n        for (int i = x; i > 0; i -= lowbit(i)) {\\n            res += sum[i];\\n        }\\n        return res;\\n    }\\n    \\n    public String minInteger(String num, int k) {\\n        if (num == null || num.length() == 0) return num;\\n        Deque<Integer>[] pos = new Deque[10];  // save all pos of current digit\\n        for (int i = 0; i < 10; i++) {\\n            pos[i] = new ArrayDeque<>();\\n        }\\n        n = num.length();\\n        sum = new int[n + 1];\\n        for (int i = 0; i < n; i++) {\\n            pos[num.charAt(i) - \\'0\\'].addLast(i + 1);   // BIT starts with 1\\n        }\\n        \\n        StringBuilder res = new StringBuilder();\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j < 10; j++) {              // try all digits\\n                if (pos[j].isEmpty()) continue;         // all used\\n                int t = pos[j].peekFirst();             // get next closest digit\\n                int p = t + query(t);                   // query(p) \\u662F\\u5750\\u6807\\u504F\\u79FB\\u91CF\\n                if (p - i <= k) {\\n                    k -= p - i;\\n                    pos[j].pollFirst();\\n                    res.append(j);\\n                    add(1, 1);              // add all 1 in [1, t-1]    \\n                    add(t, -1);                \\n                    break;\\n                }   \\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 728201,
                "title": "java-o-n-2-108-ms-easy-understand-and-with-detailed-explaination",
                "content": "fisrt, follow the question description, we can got:\\n\\nif we want to got the min number,  we must  serach from `0` to `9` for each move , and make the count of move to head is **less than or equal** `k`.\\n\\nfor example:  `num = 4321`, `k = 4`.\\n\\nthe min number we can find is `1`, and move it to head need move 3 times.\\n\\nafter move,  we got `num = 1432`, `k = 4 - 3 = 1`\\n\\nand the min number for `432` is `2`, and move it to head need move  2 times,  but k is `1`, so we can not move it,\\n\\nand the next min number is `3`, and move it to head need move 1 times, and k is `1`, so we do it.\\n\\nand than `num = 1342`,  `k = 1 - 1 = 0`.\\n\\nbecause k is 0, so we return `1342.`\\n\\n---\\n\\n**Recursion(Time Limit Exceeded)**\\ni got the following code from the comments.  it can passed 47 testcase, but **Time Limit Exceeded** on the 48th testcase.\\n`indexOf()` and `substring` is  `O(N)`, and it run N times, so the time complexity is O(N<sup>2</sup>).\\n```\\npublic String minInteger(String num, int k) {\\n    if (k == 0) return num;\\n    for (char c = \\'0\\'; c <= \\'9\\'; c++) {\\n        int i = num.indexOf(c);\\n        if (i >= 0) {\\n            if (i <= k) {\\n                return c + minInteger(num.substring(0, i) + num.substring(i + 1), k - i);\\n            }\\n        }\\n    }\\n    return num;\\n}\\n```\\n\\n---\\n\\n**Optimization Recusion**\\nwe can optimize `indexOf` and `substring`, but how?\\n\\nbecause we will search the position from 0 to 9 for each move, so we can traverse the num string, and record the position for each char. so we can make the time complexity for search index from `O(N)` to `O(1)`.\\n```\\nLinkedList<Integer>[] list = new LinkedList[10];\\nfor (int i = 0; i < 10; i++) {\\n    list[i] = new LinkedList<>();\\n}\\nint len = num.length();\\nchar[] arr = num.toCharArray();\\nfor (int i = 0; i < len; i++) {\\n    list[arr[i] - \\'0\\'].add(i);\\n}\\n```\\nthe pos in the `list[i]` is the index in the num string.\\n\\nlet\\'s see a example again.  ` num = 4132`, `k = 4`.\\n\\nif we want move `4` to the head, we need move 0 times, and `1` is 1 times, `3` is 2 times, `2` is 3 times.\\n\\nbut after we moved `1`,  `num = 1432`, `k = 3`.\\n\\nand move `4` to the head, we also need move 0 times, but `3` is  `2 - 1 = 1` times, `2` is ` 3 - 1  = 2` times.\\n\\nso we can see, the number after the each moved number,  the move count will be **minus one**.  so we record it.\\n\\n\\nand for `substring`, we can record the index we had used, than we not need to use `substring`.\\n\\n**Runtime: 846 ms, faster than 51.21%**\\n```\\n// O(N^2)time\\n// O(N)space\\npublic String minInteger(String num, int k) {\\n    //recrod the index for 0 - 9\\n    LinkedList<Integer>[] list = new LinkedList[10];\\n    for (int i = 0; i < 10; i++) {\\n        list[i] = new LinkedList<>();\\n    }\\n    int len = num.length();\\n    char[] arr = num.toCharArray();\\n    for (int i = 0; i < len; i++) {\\n        list[arr[i] - \\'0\\'].add(i);\\n    }\\n\\t\\n    //append the moved char\\n    StringBuilder res = new StringBuilder();\\n    //offset[i] is record the number had move befor i.\\n    int[] offset = new int[len];\\n    outer:\\n    // k > 0 mean we can move continue\\uFF0C res.length() < len  mean we have number not move.\\n    while (k > 0 && res.length() < len) {\\n        for (int i = 0; i < 10; i++) {\\n            if (list[i].isEmpty()){\\n                continue;\\n            }\\n            //get the need move times\\n            int move = list[i].getFirst() - offset[list[i].getFirst()];\\n            if (move > k) {\\n                //if move > k, we can not move it\\n                continue ;\\n            }\\n            //update k\\n            k -= move;\\n\\t\\t\\t// remove the used index in list\\n            int index = list[i].removeFirst();\\n            //append the moved number\\n            res.append(arr[index]);\\n            //update arr[index] = 0,  record we had used it\\n            arr[index] = 0;\\n            //update offset\\n            for (int j = index + 1; j < len; j++) {\\n                offset[j]++;\\n            }\\n            continue outer;\\n        }\\n    }\\n    //if we have not moved num, we append it one by one.\\n    for (int i = 0; i < len; i++) {\\n        if (arr[i] != 0) {\\n            res.append(arr[i]);\\n        }\\n    }\\n    return res.toString();\\n}\\n```\\n\\n---\\n\\n**Optimize to O(N LogN)**\\n\\nin the upper code, we use offset[i] to record the count of moved number before i.\\n\\nwe can alse record the moved index, and then use **Binary Search** to find the count of less the i.\\n\\nand for the num, we can total move ` 1 + 2 + 3 + ... + (n - 1) = (n - 1) * n / 2`,  so  if ` k >=  (n - 1) * n / 2`, we can use `Arrays.sort(arr)` to sort the `char[] arr = num.toCharArray()`. and `return new String(arr);`\\n\\n\\n**Runtime: 108 ms, faster than 77.38%\\uFF0C Memory Usage: 53.8 MB, less than 100.00% of Java online submissions**\\n```\\n//O(N * logN)time\\n//O(N)space\\npublic String minInteger(String num, int k) {\\n    LinkedList<Integer>[] list = new LinkedList[10];\\n    for (int i = 0; i < 10; i++) {\\n        list[i] = new LinkedList<>();\\n    }\\n    int len = num.length();\\n    char[] arr = num.toCharArray();\\n    for (int i = 0; i < len; i++) {\\n        list[arr[i] - \\'0\\'].add(i);\\n    }\\n    if (k >= (len - 1) * len / 2) {\\n        Arrays.sort(arr);\\n        return new String(arr);\\n    }\\n    //record moved index\\n    List<Integer> record = new ArrayList<>();\\n    //record res\\n    StringBuilder res = new StringBuilder();\\n    outer:\\n    while (k > 0 && res.length() < len) {\\n        for (int i = 0; i < 10; i++) {\\n            if (list[i].isEmpty()) {\\n                continue;\\n            }\\n            //find the moved count before pos\\n            int index = findIndex(record, list[i].getFirst());\\n            int move = list[i].getFirst() - index;\\n            if (move > k) {\\n                continue;\\n            }\\n            //update k\\n            k -= move;\\n\\t\\t\\t// remove used form list\\n            int pos = list[i].removeFirst();\\n\\t\\t\\t//add to the moved index list\\n            record.add(index, pos);\\n            res.append(i);\\n            arr[pos] = 0;\\n            continue outer;\\n        }\\n    }\\n    for (int i = 0; i < len; i++) {\\n        if (arr[i] != 0) {\\n            res.append(arr[i]);\\n        }\\n    }\\n    return res.toString();\\n}\\n\\n/**\\n    *Binary Search find the count less than value\\n    */\\nint findIndex(List<Integer> list, int value) {\\n    int l = 0, r = list.size();\\n    while (l < r) {\\n        int mid = (l + r) >> 1;\\n        if (list.get(mid) < value) {\\n            l = mid + 1;\\n        } else {\\n            r = mid;\\n        }\\n    }\\n    return l;\\n}\\n```\\n\\n---\\n\\nif i had made any mistake, please let me know, thanks a lot.\\n\\nthe following description is in Chinese.\\n\\n\\n---\\n\\n## \\u7406\\u89E3\\u9898\\u610F\\n\\n\\u9996\\u5148\\u6839\\u636E\\u9898\\u76EE\\u63CF\\u8FF0\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u5F97\\u5230\\uFF1A\\n\\u8981\\u60F3\\u5728\\u79FB\\u52A8 k \\u6B21\\u4E4B\\u540E\\u5F97\\u5230\\u6700\\u5C0F\\u7684\\u6570\\uFF0C \\u5FC5\\u987B\\u6BCF\\u6B21\\u79FB\\u52A8\\u5C3D\\u53EF\\u80FD\\u7684\\u5728K\\u6B21\\u5185\\uFF0C\\u628A\\u4ECE 0 \\u5F00\\u59CB\\u5230 9 \\u7684\\u6570\\u79FB\\u52A8\\u5230\\u4F7F\\u524D\\u9762\\u6CA1\\u6709\\u6BD4\\u5B83\\u5927\\u7684\\u6570\\u5B57\\u3002\\n\\n\\u6BD4\\u5982\\uFF1A `num = 4321`, `k = 4`.\\n\\u6211\\u4EEC\\u80FD\\u627E\\u5230\\u7684\\u6700\\u5C0F\\u7684\\u6570\\u662F `1`, \\u628A `1` \\u79FB\\u52A8\\u5230\\u5F00\\u5934\\u9700\\u8981\\u79FB\\u52A8 `3` \\u6B21\\u3002\\n\\u6240\\u4EE5\\u79FB\\u52A8\\u4E4B\\u540E\\u5F97\\u5230\\uFF1A `num = 1432`, `k = 4 - 3 = 1`;\\n\\u7136\\u540E\\u4ECE 1 \\u540E\\u9762\\u5F00\\u59CB\\uFF0C\\u6211\\u4EEC\\u80FD\\u627E\\u5230\\u7684 `2`\\uFF0C \\u628A `2` \\u79FB\\u52A8\\u5230 `1` \\u540E\\u9762\\u9700\\u8981\\u79FB\\u52A8 2 \\u6B21\\uFF0C \\u4F46\\u662F k = 1, \\u6240\\u4EE5\\u6211\\u4EEC\\u5F97\\u627E\\u4E0B\\u4E00\\u4E2A\\u5C0F\\u7684\\u6570\\u3002 \\u6211\\u4EEC\\u627E\\u5230\\u4E86 `3`\\uFF0C\\u7136\\u540E\\u628A `3` \\u79FB\\u52A8\\u5230 1 \\u540E\\u9762\\u9700\\u8981 \\u79FB\\u52A8 1 \\u6B21\\uFF0C k = 1, \\u521A\\u597D\\u53EF\\u4EE5\\u3002\\n\\u6240\\u4EE5\\u79FB\\u52A8\\u4E4B\\u540E\\u5F97\\u5230\\uFF1A `num = 1342`,  `k = 1 - 1 = 0`;\\n\\u56E0\\u4E3A `k = 0` \\u4E0D\\u80FD\\u79FB\\u52A8\\u4E86\\uFF0C \\u6240\\u4EE5\\u6211\\u4EEC\\u76F4\\u63A5\\u8FD4\\u56DE  `1342`\\u3002\\n\\n---\\n\\n### \\u9012\\u5F52\\u89E3\\u6CD5\\uFF08\\u8D85\\u51FA\\u65F6\\u95F4\\u9650\\u5236\\uFF09\\n\\u6240\\u4EE5\\u4EE3\\u7801\\u6211\\u4EEC\\u53EF\\u4EE5\\u7528 \\u9012\\u5F52 \\u76F4\\u63A5\\u8FD9\\u6837\\u5199, **\\u4F46\\u662F\\u5728\\u7B2C48\\u4E2A\\u6D4B\\u8BD5\\u7528\\u4F8B\\u7684\\u65F6\\u5019\\u4F1A\\u63D0\\u793A \\u8D85\\u51FA\\u65F6\\u95F4\\u9650\\u5236**\\u3002\\n\\u6211\\u4EEC\\u6765\\u5206\\u6790\\u4E0B\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\uFF0C\\n`num.indexOf(c)` \\u662F `O(N)`, \\n`subString` \\u4E5F\\u662F `O(N)`, \\n\\u4E00\\u5171\\u6267\\u884C\\u4E86 N \\u6B21\\uFF0C \\u6240\\u4EE5\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u662F `O(N^2)`.\\n```\\n//\\u4EE3\\u7801\\u6765\\u81EA\\u8BC4\\u8BBA\\u533A\\npublic String minInteger(String num, int k) {\\n    if (k == 0) return num;\\n    for (char c = \\'0\\'; c <= \\'9\\'; c++) {\\n        int i = num.indexOf(c);\\n        if (i >= 0) {\\n            if (i <= k) {\\n                return c + minInteger(num.substring(0, i) + num.substring(i + 1), k - i);\\n            }\\n        }\\n    }\\n    return num;\\n}\\n```\\n\\n---\\n\\n### \\u4F18\\u5316\\u9012\\u5F52\\n\\u5BF9\\u4E8E\\u9012\\u5F52\\u65B9\\u6CD5\\u7684 `indexOf` \\u548C `substring` \\u6211\\u4EEC\\u53EF\\u4EE5\\u600E\\u4E48\\u4F18\\u5316\\u5462\\uFF1F\\n\\n\\u56E0\\u4E3A\\u6211\\u4EEC\\u6BCF\\u6B21\\u90FD\\u8981\\u4ECE 0 \\u5230 9 \\u53BB\\u83B7\\u53D6\\u5176\\u5728 `num` \\u5BF9\\u5E94\\u7684\\u4F4D\\u7F6E, \\u6240\\u4EE5\\u6211\\u4EEC\\u53EF\\u4EE5\\u5148\\u8BB0\\u5F55\\u4ED6\\u4EEC\\u7684\\u4F4D\\u7F6E\\uFF0C \\u53EF\\u4EE5\\u901A\\u8FC7\\u4E0B\\u9762\\u7684\\u4EE3\\u7801\\u4E00\\u6B21\\u904D\\u5386\\u5C31\\u80FD\\u83B7\\u53D6\\u5230 0 - 9 \\u5728 num\\u4E2D\\u7684\\u6240\\u6709\\u4F4D\\u7F6E\\u3002\\u53EF\\u4EE5\\u628A\\u6BCF\\u6B21\\u67E5\\u627E\\u4F4D\\u7F6E\\u7684\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u4ECE `O(N)` \\u964D\\u5230 `O(1)`.\\n```\\nLinkedList<Integer>[] list = new LinkedList[10];\\nfor (int i = 0; i < 10; i++) {\\n    list[i] = new LinkedList<>();\\n}\\nint len = num.length();\\nchar[] arr = num.toCharArray();\\nfor (int i = 0; i < len; i++) {\\n    list[arr[i] - \\'0\\'].add(i);\\n}\\n```\\n\\u8FD9\\u6837\\u6211\\u4EEC\\u4FDD\\u5B58\\u7684\\u662F 0 - 9 \\u5728 num\\u4E2D\\u7684\\u539F\\u59CB\\u4F4D\\u7F6E\\u3002\\n\\u6211\\u4EEC\\u518D\\u6765\\u770B\\u4E2A\\u793A\\u4F8B `num = 4132`, `k = 4`.\\n\\u628A `4` \\u79FB\\u52A8\\u5230\\u6700\\u524D\\u9762\\u662F 0 \\u6B21\\uFF0C `1` \\u662F1\\u6B21\\uFF0C`3` \\u662F 2\\u6B21\\uFF0C`2` \\u662F 3\\u6B21\\n\\u5F53\\u6211\\u4EEC\\u79FB\\u52A8 `1` \\u4E4B\\u540E \\u5F97\\u5230 `num = 1432`, `k = 3`.\\n\\u6B64\\u65F6 `1` \\u662F\\u5DF2\\u7ECF\\u786E\\u5B9A\\u7684\\u76F8\\u5F53\\u4E8E\\u53EA\\u662F\\u5904\\u7406 `432`\\uFF0C \\u6B64\\u65F6\\u6211\\u4EEC\\u548C\\u5F00\\u59CB\\u7684 `4132` \\u76F8\\u6BD4\\u628A\\u6BCF\\u4E2A\\u6570 \\u79FB\\u52A8\\u5230\\u6700\\u524D\\u9762\\u7684\\u6B21\\u6570\\u53D8\\u6210\\u4E86:\\n\\u628A `4` \\u79FB\\u52A8\\u5230\\u6700\\u524D\\u9762\\u662F 0 \\u6B21\\uFF0C `3` \\u662F 1\\u6B21\\uFF0C`2` \\u662F 2\\u6B21.\\n\\u6211\\u4EEC\\u53D1\\u73B0\\uFF0C \\u6BCF\\u4E00\\u79FB\\u52A8\\u5B8C\\u4E00\\u4E2A\\u5B57\\u7B26\\uFF0C\\u4ED6\\u540E\\u9762\\u7684\\u5B57\\u7B26\\u6700\\u524D\\u9762\\u7684\\u6B21\\u6570\\u5C31\\u4F1A **\\u51CF1**\\u3002\\n\\n**\\u8FD9\\u6837\\u6211\\u4EEC\\u5C31\\u53EF\\u4EE5\\u8BB0\\u5F55\\u6BCF\\u6B21\\u79FB\\u52A8\\u7684\\u5B57\\u7B26\\u540E\\u9762\\u5B57\\u7B26\\u8BA9\\u540E\\u9762\\u7684\\u5B57\\u7B26\\u7684\\u79FB\\u52A8\\u6B21\\u6570\\u51CF\\u4E00\\u3002**\\n\\n\\u5BF9\\u4E8E`substring` \\u6211\\u4EEC\\u53EF\\u4EE5\\u8BB0\\u5F55\\u90A3\\u4E9B\\u5B57\\u7B26\\u5DF2\\u7ECF\\u7528\\u8FC7\\u4E86, \\u8FD9\\u6837\\u5C31\\u53EF\\u4EE5\\u76F4\\u63A5\\u5728\\u539F\\u5B57\\u7B26\\u4E0A\\u64CD\\u4F5C\\u4E86\\uFF0C\\u4E0D\\u9700\\u8981\\u5229\\u7528`substring`\\u4E86\\u3002\\n\\n\\n\\u4EE3\\u7801\\u5982\\u4E0B\\uFF0C \\u8FD9\\u6837\\u80FD\\u901A\\u8FC7\\u6240\\u6709\\u7684\\u6D4B\\u8BD5\\u7528\\u4F8B\\u4E86\\uFF0C**\\u4F46\\u662F \\u6267\\u884C\\u7528\\u65F6\\uFF1A1131 ms\\uFF0C \\u8FD8\\u662F\\u6BD4\\u8F83\\u6162\\u7684\\uFF0C \\u6211\\u4EEC\\u8FD8\\u53EF\\u4EE5\\u7EE7\\u7EED\\u4F18\\u5316**\\u3002\\n\\n```\\n// O(N^2)time\\n// O(N)space\\npublic String minInteger(String num, int k) {\\n    //\\u8BB0\\u5F550 - 9 \\u5728 num\\u4E2D\\u7684\\u4F4D\\u7F6E \\n    LinkedList<Integer>[] list = new LinkedList[10];\\n    for (int i = 0; i < 10; i++) {\\n        list[i] = new LinkedList<>();\\n    }\\n    int len = num.length();\\n    char[] arr = num.toCharArray();\\n    for (int i = 0; i < len; i++) {\\n        list[arr[i] - \\'0\\'].add(i);\\n    }\\n    //\\u8BB0\\u5F55\\u7ED3\\u679C\\uFF0C \\u6DFB\\u52A0\\u5DF2\\u7ECF\\u79FB\\u52A8\\u8FC7\\u7684\\u5B57\\u7B26\\n    StringBuilder res = new StringBuilder();\\n    //\\u8BB0\\u5F55 \\u5F53\\u524D\\u4F4D\\u7F6E \\u524D\\u9762\\u7531\\u591A\\u5C11\\u4E2A\\u5B57\\u7B26\\u5DF2\\u7ECF\\u79FB\\u52A8\\u8FC7\\n    int[] offset = new int[len];\\n    outer:\\n    // k > 0 \\u8BF4\\u660E\\u6211\\u4EEC \\u53EF\\u4EE5\\u79FB\\u52A8\\uFF0C res.length() < len \\u8BF4\\u660E\\u8FD8\\u6709\\u5B57\\u7B26\\u672A\\u88AB\\u79FB\\u52A8  \\n    while (k > 0 && res.length() < len) {\\n        for (int i = 0; i < 10; i++) {\\n            if (list[i].isEmpty()){\\n                //num\\u4E2D\\u6CA1\\u6709\\u8FD9\\u4E2A\\u5B57\\u7B26\\n                continue;\\n            }\\n            //\\u83B7\\u53D6\\u5B57\\u7B26\\u7684\\u4E0B\\u6807 \\u51CF\\u53BB \\u524D\\u9762\\u5DF2\\u7ECF\\u79FB\\u52A8\\u8FC7\\u7684\\u5B57\\u7B26 \\u5F97\\u5230 \\u5B83\\u79FB\\u52A8\\u5230\\u6700\\u524D\\u9762\\u9700\\u8981\\u7684\\u6B21\\u6570\\n            int move = list[i].getFirst() - offset[list[i].getFirst()];\\n            if (move > k) {\\n                //\\u6BD4 K \\u5927\\uFF0C\\u5219\\u627E\\u4E0B\\u4E00\\u4E2A\\u6570\\u5B57\\n                continue ;\\n            }\\n            //\\u66F4\\u65B0 k\\u7684\\u503C \\n            k -= move;\\n            //\\u83B7\\u53D6\\u8FD9\\u4E2A\\u5B57\\u7B26\\u7684\\u9996\\u4E2A\\u4F4D\\u7F6E\\uFF0C \\u5E76\\u628A\\u5B83\\u4ECE\\u4FDD\\u5B58\\u4F4D\\u7F6E\\u7684\\u94FE\\u8868\\u4E2D\\u79FB\\u9664\\uFF0C\\u56E0\\u4E3A\\u6211\\u4EEC\\u5DF2\\u7ECF\\u7528\\u8FC7\\u4E86\\uFF0C\\u4E0D\\u80FD\\u518D\\u7528\\n            int index = list[i].removeFirst();\\n            //\\u6DFB\\u52A0\\u5230\\u7ED3\\u679C\\u4E2D\\n            res.append(arr[index]);\\n            //\\u4FEE\\u6539num\\u4E2D\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E3A \\u5B57\\u7B26 0\\uFF0C \\u8868\\u793A\\u6211\\u4EEC\\u5DF2\\u7ECF\\u7528\\u8FC7\\u4E86\\u3002\\n            arr[index] = 0;\\n            //\\u5C06 index \\u540E\\u9762\\u7684\\u5B57\\u7B26\\u7684\\u9700\\u8981\\u51CF\\u53BB\\u7684\\u79FB\\u52A8\\u6B21\\u6570 + 1\\n            for (int j = index + 1; j < len; j++) {\\n                offset[j]++;\\n            }\\n            //\\u7EE7\\u7EED\\u4ECE 0 \\u5F00\\u59CB\\u627E \\u79FB\\u52A8\\u6B21\\u6570\\u5C0F\\u4E8E k \\u7684\\u5B57\\u7B26\\n            continue outer;\\n        }\\n    }\\n    //\\u5982\\u679C k \\u6BD4\\u8F83\\u5C0F\\uFF0C \\u5C31\\u4F1A\\u5B58\\u5728 \\u8FD8\\u6709\\u5B57\\u7B26\\u672A\\u88AB\\u79FB\\u52A8\\uFF0C \\u6211\\u4EEC\\u6309\\u539F\\u987A\\u5E8F\\u4F9D\\u6B21\\u6DFB\\u52A0\\n    for (int i = 0; i < len; i++) {\\n        if (arr[i] != 0) {\\n            res.append(arr[i]);\\n        }\\n    }\\n    return res.toString();\\n}\\n```\\n\\n---\\n\\n### \\u4F18\\u5316\\u5230 O(N*logN)\\n\\n\\u4E0A\\u9762\\u7684\\u4EE3\\u7801\\uFF0C \\u6BCF\\u6B21\\u79FB\\u52A8\\u4E00\\u4E2A\\u5B57\\u7B26\\u4E4B\\u540E\\uFF0C\\u9700\\u8981\\u5BF9\\u540E\\u9762\\u7684\\u6240\\u6709\\u5B57\\u7B26\\u8BB0\\u5F55\\u524D\\u9762\\u79FB\\u52A8\\u7684\\u5B57\\u7B26 \\u52A0 1\\u3002\\n\\n**\\u90A3\\u6211\\u4EEC\\u4E5F\\u53EF\\u4EE5\\u76F4\\u63A5\\u4FDD\\u5B58 \\u79FB\\u52A8\\u8FC7\\u5B57\\u7B26\\u7684\\u4F4D\\u7F6E\\uFF0C\\u627E\\u5B57\\u7B26\\u65F6\\uFF0C\\u901A\\u8FC7\\u4E8C\\u5206\\u67E5\\u627E \\u5DF2\\u7ECF\\u79FB\\u52A8\\u8FC7\\u7684\\u4F4D\\u7F6E\\u8BB0\\u5F55\\u4E2D \\u6709\\u591A\\u5C11\\u4E2A \\u6BD4\\u5F53\\u524D\\u4F4D\\u7F6E\\u5C0F\\u3002**\\n\\n**\\u800C\\u4E14\\u6211\\u4EEC\\u5B57\\u7B26\\u6700\\u591A\\u79FB\\u52A8 1 + 2 + ... + n-1 = (n - 1) * n / 2 \\u6B21\\uFF0C \\u6240\\u4EE5\\u5F53 k >= (n -1) * n / 2 \\u65F6\\uFF0C \\u6211\\u4EEC\\u53EF\\u4EE5\\u76F4\\u63A5\\u5BF9\\u5B57\\u7B26\\u6309\\u5347\\u5E8F\\u6392\\u5E8F\\u3002**\\n\\n\\n```\\n//O(N * logN)time\\n//O(N)space\\npublic String minInteger(String num, int k) {\\n    //\\u8BB0\\u5F550 - 9 \\u5728 num\\u4E2D\\u7684\\u4F4D\\u7F6E\\n    LinkedList<Integer>[] list = new LinkedList[10];\\n    for (int i = 0; i < 10; i++) {\\n        list[i] = new LinkedList<>();\\n    }\\n    int len = num.length();\\n    char[] arr = num.toCharArray();\\n    for (int i = 0; i < len; i++) {\\n        list[arr[i] - \\'0\\'].add(i);\\n    }\\n    if (k >= (len - 1) * len / 2) {\\n        Arrays.sort(arr);\\n        return new String(arr);\\n    }\\n    //\\u8BB0\\u5F55\\u79FB\\u52A8\\u7684\\u5B57\\u7B26\\u4F4D\\u7F6E\\n    List<Integer> record = new ArrayList<>();\\n    //\\u8BB0\\u5F55\\u7ED3\\u679C\\uFF0C \\u6DFB\\u52A0\\u5DF2\\u7ECF\\u79FB\\u52A8\\u8FC7\\u7684\\u5B57\\u7B26\\n    StringBuilder res = new StringBuilder();\\n    outer:\\n    while (k > 0 && res.length() < len) {\\n        for (int i = 0; i < 10; i++) {\\n            if (list[i].isEmpty()) {\\n                continue;\\n            }\\n            //\\u627E\\u5230\\u79FB\\u52A8\\u7684\\u5B57\\u7B26\\u4F4D\\u7F6E\\u4E2D\\u6709 \\u591A\\u5C11\\u4E2A\\u6BD4\\u5F53\\u524D\\u4F4D\\u7F6E\\u5C0F\\n            int index = findIndex(record, list[i].getFirst());\\n            int move = list[i].getFirst() - index;\\n            if (move > k) {\\n                continue;\\n            }\\n            //\\u66F4\\u65B0 k\\u7684\\u503C \\n            k -= move;\\n            //\\u83B7\\u53D6\\u8FD9\\u4E2A\\u5B57\\u7B26\\u7684\\u9996\\u4E2A\\u4F4D\\u7F6E\\uFF0C \\u5E76\\u628A\\u5B83\\u4ECE\\u4FDD\\u5B58\\u4F4D\\u7F6E\\u7684\\u94FE\\u8868\\u4E2D\\u79FB\\u9664\\uFF0C\\u56E0\\u4E3A\\u6211\\u4EEC\\u5DF2\\u7ECF\\u7528\\u8FC7\\u4E86\\uFF0C\\u4E0D\\u80FD\\u518D\\u7528\\n            int pos = list[i].removeFirst();\\n            //\\u628A\\u5F53\\u524D \\u4F4D\\u7F6E \\u6DFB\\u52A0\\u5230 \\u5DF2\\u7ECF\\u79FB\\u52A8\\u8FC7\\u7684\\u4F4D\\u7F6E\\u5217\\u8868\\u4E2D\\n            record.add(index, pos);\\n            res.append(i);\\n            arr[pos] = 0;\\n            continue outer;\\n        }\\n    }\\n    for (int i = 0; i < len; i++) {\\n        if (arr[i] != 0) {\\n            res.append(arr[i]);\\n        }\\n    }\\n    return res.toString();\\n}\\n\\n/**\\n    * \\u4E8C\\u5206\\u67E5\\u627E\\u6BD4 value\\u5C0F\\u7684\\u4E2A\\u6570\\n    */\\nint findIndex(List<Integer> list, int value) {\\n    int l = 0, r = list.size();\\n    while (l < r) {\\n        int mid = (l + r) >> 1;\\n        if (list.get(mid) < value) {\\n            l = mid + 1;\\n        } else {\\n            r = mid;\\n        }\\n    }\\n    return l;\\n}\\n```\\n\\n\\u5982\\u679C\\u4E0A\\u9762\\u6709\\u4EC0\\u4E48\\u63CF\\u8FF0\\u9519\\u8BEF\\u7684\\uFF0C\\u8BF7\\u6307\\u51FA\\u6765\\uFF0C \\u611F\\u8C22\\u3002",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic String minInteger(String num, int k) {\\n    if (k == 0) return num;\\n    for (char c = \\'0\\'; c <= \\'9\\'; c++) {\\n        int i = num.indexOf(c);\\n        if (i >= 0) {\\n            if (i <= k) {\\n                return c + minInteger(num.substring(0, i) + num.substring(i + 1), k - i);\\n            }\\n        }\\n    }\\n    return num;\\n}\\n```\n```\\nLinkedList<Integer>[] list = new LinkedList[10];\\nfor (int i = 0; i < 10; i++) {\\n    list[i] = new LinkedList<>();\\n}\\nint len = num.length();\\nchar[] arr = num.toCharArray();\\nfor (int i = 0; i < len; i++) {\\n    list[arr[i] - \\'0\\'].add(i);\\n}\\n```\n```\\n// O(N^2)time\\n// O(N)space\\npublic String minInteger(String num, int k) {\\n    //recrod the index for 0 - 9\\n    LinkedList<Integer>[] list = new LinkedList[10];\\n    for (int i = 0; i < 10; i++) {\\n        list[i] = new LinkedList<>();\\n    }\\n    int len = num.length();\\n    char[] arr = num.toCharArray();\\n    for (int i = 0; i < len; i++) {\\n        list[arr[i] - \\'0\\'].add(i);\\n    }\\n\\t\\n    //append the moved char\\n    StringBuilder res = new StringBuilder();\\n    //offset[i] is record the number had move befor i.\\n    int[] offset = new int[len];\\n    outer:\\n    // k > 0 mean we can move continue\\uFF0C res.length() < len  mean we have number not move.\\n    while (k > 0 && res.length() < len) {\\n        for (int i = 0; i < 10; i++) {\\n            if (list[i].isEmpty()){\\n                continue;\\n            }\\n            //get the need move times\\n            int move = list[i].getFirst() - offset[list[i].getFirst()];\\n            if (move > k) {\\n                //if move > k, we can not move it\\n                continue ;\\n            }\\n            //update k\\n            k -= move;\\n\\t\\t\\t// remove the used index in list\\n            int index = list[i].removeFirst();\\n            //append the moved number\\n            res.append(arr[index]);\\n            //update arr[index] = 0,  record we had used it\\n            arr[index] = 0;\\n            //update offset\\n            for (int j = index + 1; j < len; j++) {\\n                offset[j]++;\\n            }\\n            continue outer;\\n        }\\n    }\\n    //if we have not moved num, we append it one by one.\\n    for (int i = 0; i < len; i++) {\\n        if (arr[i] != 0) {\\n            res.append(arr[i]);\\n        }\\n    }\\n    return res.toString();\\n}\\n```\n```\\n//O(N * logN)time\\n//O(N)space\\npublic String minInteger(String num, int k) {\\n    LinkedList<Integer>[] list = new LinkedList[10];\\n    for (int i = 0; i < 10; i++) {\\n        list[i] = new LinkedList<>();\\n    }\\n    int len = num.length();\\n    char[] arr = num.toCharArray();\\n    for (int i = 0; i < len; i++) {\\n        list[arr[i] - \\'0\\'].add(i);\\n    }\\n    if (k >= (len - 1) * len / 2) {\\n        Arrays.sort(arr);\\n        return new String(arr);\\n    }\\n    //record moved index\\n    List<Integer> record = new ArrayList<>();\\n    //record res\\n    StringBuilder res = new StringBuilder();\\n    outer:\\n    while (k > 0 && res.length() < len) {\\n        for (int i = 0; i < 10; i++) {\\n            if (list[i].isEmpty()) {\\n                continue;\\n            }\\n            //find the moved count before pos\\n            int index = findIndex(record, list[i].getFirst());\\n            int move = list[i].getFirst() - index;\\n            if (move > k) {\\n                continue;\\n            }\\n            //update k\\n            k -= move;\\n\\t\\t\\t// remove used form list\\n            int pos = list[i].removeFirst();\\n\\t\\t\\t//add to the moved index list\\n            record.add(index, pos);\\n            res.append(i);\\n            arr[pos] = 0;\\n            continue outer;\\n        }\\n    }\\n    for (int i = 0; i < len; i++) {\\n        if (arr[i] != 0) {\\n            res.append(arr[i]);\\n        }\\n    }\\n    return res.toString();\\n}\\n\\n/**\\n    *Binary Search find the count less than value\\n    */\\nint findIndex(List<Integer> list, int value) {\\n    int l = 0, r = list.size();\\n    while (l < r) {\\n        int mid = (l + r) >> 1;\\n        if (list.get(mid) < value) {\\n            l = mid + 1;\\n        } else {\\n            r = mid;\\n        }\\n    }\\n    return l;\\n}\\n```\n```\\n//\\u4EE3\\u7801\\u6765\\u81EA\\u8BC4\\u8BBA\\u533A\\npublic String minInteger(String num, int k) {\\n    if (k == 0) return num;\\n    for (char c = \\'0\\'; c <= \\'9\\'; c++) {\\n        int i = num.indexOf(c);\\n        if (i >= 0) {\\n            if (i <= k) {\\n                return c + minInteger(num.substring(0, i) + num.substring(i + 1), k - i);\\n            }\\n        }\\n    }\\n    return num;\\n}\\n```\n```\\nLinkedList<Integer>[] list = new LinkedList[10];\\nfor (int i = 0; i < 10; i++) {\\n    list[i] = new LinkedList<>();\\n}\\nint len = num.length();\\nchar[] arr = num.toCharArray();\\nfor (int i = 0; i < len; i++) {\\n    list[arr[i] - \\'0\\'].add(i);\\n}\\n```\n```\\n// O(N^2)time\\n// O(N)space\\npublic String minInteger(String num, int k) {\\n    //\\u8BB0\\u5F550 - 9 \\u5728 num\\u4E2D\\u7684\\u4F4D\\u7F6E \\n    LinkedList<Integer>[] list = new LinkedList[10];\\n    for (int i = 0; i < 10; i++) {\\n        list[i] = new LinkedList<>();\\n    }\\n    int len = num.length();\\n    char[] arr = num.toCharArray();\\n    for (int i = 0; i < len; i++) {\\n        list[arr[i] - \\'0\\'].add(i);\\n    }\\n    //\\u8BB0\\u5F55\\u7ED3\\u679C\\uFF0C \\u6DFB\\u52A0\\u5DF2\\u7ECF\\u79FB\\u52A8\\u8FC7\\u7684\\u5B57\\u7B26\\n    StringBuilder res = new StringBuilder();\\n    //\\u8BB0\\u5F55 \\u5F53\\u524D\\u4F4D\\u7F6E \\u524D\\u9762\\u7531\\u591A\\u5C11\\u4E2A\\u5B57\\u7B26\\u5DF2\\u7ECF\\u79FB\\u52A8\\u8FC7\\n    int[] offset = new int[len];\\n    outer:\\n    // k > 0 \\u8BF4\\u660E\\u6211\\u4EEC \\u53EF\\u4EE5\\u79FB\\u52A8\\uFF0C res.length() < len \\u8BF4\\u660E\\u8FD8\\u6709\\u5B57\\u7B26\\u672A\\u88AB\\u79FB\\u52A8  \\n    while (k > 0 && res.length() < len) {\\n        for (int i = 0; i < 10; i++) {\\n            if (list[i].isEmpty()){\\n                //num\\u4E2D\\u6CA1\\u6709\\u8FD9\\u4E2A\\u5B57\\u7B26\\n                continue;\\n            }\\n            //\\u83B7\\u53D6\\u5B57\\u7B26\\u7684\\u4E0B\\u6807 \\u51CF\\u53BB \\u524D\\u9762\\u5DF2\\u7ECF\\u79FB\\u52A8\\u8FC7\\u7684\\u5B57\\u7B26 \\u5F97\\u5230 \\u5B83\\u79FB\\u52A8\\u5230\\u6700\\u524D\\u9762\\u9700\\u8981\\u7684\\u6B21\\u6570\\n            int move = list[i].getFirst() - offset[list[i].getFirst()];\\n            if (move > k) {\\n                //\\u6BD4 K \\u5927\\uFF0C\\u5219\\u627E\\u4E0B\\u4E00\\u4E2A\\u6570\\u5B57\\n                continue ;\\n            }\\n            //\\u66F4\\u65B0 k\\u7684\\u503C \\n            k -= move;\\n            //\\u83B7\\u53D6\\u8FD9\\u4E2A\\u5B57\\u7B26\\u7684\\u9996\\u4E2A\\u4F4D\\u7F6E\\uFF0C \\u5E76\\u628A\\u5B83\\u4ECE\\u4FDD\\u5B58\\u4F4D\\u7F6E\\u7684\\u94FE\\u8868\\u4E2D\\u79FB\\u9664\\uFF0C\\u56E0\\u4E3A\\u6211\\u4EEC\\u5DF2\\u7ECF\\u7528\\u8FC7\\u4E86\\uFF0C\\u4E0D\\u80FD\\u518D\\u7528\\n            int index = list[i].removeFirst();\\n            //\\u6DFB\\u52A0\\u5230\\u7ED3\\u679C\\u4E2D\\n            res.append(arr[index]);\\n            //\\u4FEE\\u6539num\\u4E2D\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E3A \\u5B57\\u7B26 0\\uFF0C \\u8868\\u793A\\u6211\\u4EEC\\u5DF2\\u7ECF\\u7528\\u8FC7\\u4E86\\u3002\\n            arr[index] = 0;\\n            //\\u5C06 index \\u540E\\u9762\\u7684\\u5B57\\u7B26\\u7684\\u9700\\u8981\\u51CF\\u53BB\\u7684\\u79FB\\u52A8\\u6B21\\u6570 + 1\\n            for (int j = index + 1; j < len; j++) {\\n                offset[j]++;\\n            }\\n            //\\u7EE7\\u7EED\\u4ECE 0 \\u5F00\\u59CB\\u627E \\u79FB\\u52A8\\u6B21\\u6570\\u5C0F\\u4E8E k \\u7684\\u5B57\\u7B26\\n            continue outer;\\n        }\\n    }\\n    //\\u5982\\u679C k \\u6BD4\\u8F83\\u5C0F\\uFF0C \\u5C31\\u4F1A\\u5B58\\u5728 \\u8FD8\\u6709\\u5B57\\u7B26\\u672A\\u88AB\\u79FB\\u52A8\\uFF0C \\u6211\\u4EEC\\u6309\\u539F\\u987A\\u5E8F\\u4F9D\\u6B21\\u6DFB\\u52A0\\n    for (int i = 0; i < len; i++) {\\n        if (arr[i] != 0) {\\n            res.append(arr[i]);\\n        }\\n    }\\n    return res.toString();\\n}\\n```\n```\\n//O(N * logN)time\\n//O(N)space\\npublic String minInteger(String num, int k) {\\n    //\\u8BB0\\u5F550 - 9 \\u5728 num\\u4E2D\\u7684\\u4F4D\\u7F6E\\n    LinkedList<Integer>[] list = new LinkedList[10];\\n    for (int i = 0; i < 10; i++) {\\n        list[i] = new LinkedList<>();\\n    }\\n    int len = num.length();\\n    char[] arr = num.toCharArray();\\n    for (int i = 0; i < len; i++) {\\n        list[arr[i] - \\'0\\'].add(i);\\n    }\\n    if (k >= (len - 1) * len / 2) {\\n        Arrays.sort(arr);\\n        return new String(arr);\\n    }\\n    //\\u8BB0\\u5F55\\u79FB\\u52A8\\u7684\\u5B57\\u7B26\\u4F4D\\u7F6E\\n    List<Integer> record = new ArrayList<>();\\n    //\\u8BB0\\u5F55\\u7ED3\\u679C\\uFF0C \\u6DFB\\u52A0\\u5DF2\\u7ECF\\u79FB\\u52A8\\u8FC7\\u7684\\u5B57\\u7B26\\n    StringBuilder res = new StringBuilder();\\n    outer:\\n    while (k > 0 && res.length() < len) {\\n        for (int i = 0; i < 10; i++) {\\n            if (list[i].isEmpty()) {\\n                continue;\\n            }\\n            //\\u627E\\u5230\\u79FB\\u52A8\\u7684\\u5B57\\u7B26\\u4F4D\\u7F6E\\u4E2D\\u6709 \\u591A\\u5C11\\u4E2A\\u6BD4\\u5F53\\u524D\\u4F4D\\u7F6E\\u5C0F\\n            int index = findIndex(record, list[i].getFirst());\\n            int move = list[i].getFirst() - index;\\n            if (move > k) {\\n                continue;\\n            }\\n            //\\u66F4\\u65B0 k\\u7684\\u503C \\n            k -= move;\\n            //\\u83B7\\u53D6\\u8FD9\\u4E2A\\u5B57\\u7B26\\u7684\\u9996\\u4E2A\\u4F4D\\u7F6E\\uFF0C \\u5E76\\u628A\\u5B83\\u4ECE\\u4FDD\\u5B58\\u4F4D\\u7F6E\\u7684\\u94FE\\u8868\\u4E2D\\u79FB\\u9664\\uFF0C\\u56E0\\u4E3A\\u6211\\u4EEC\\u5DF2\\u7ECF\\u7528\\u8FC7\\u4E86\\uFF0C\\u4E0D\\u80FD\\u518D\\u7528\\n            int pos = list[i].removeFirst();\\n            //\\u628A\\u5F53\\u524D \\u4F4D\\u7F6E \\u6DFB\\u52A0\\u5230 \\u5DF2\\u7ECF\\u79FB\\u52A8\\u8FC7\\u7684\\u4F4D\\u7F6E\\u5217\\u8868\\u4E2D\\n            record.add(index, pos);\\n            res.append(i);\\n            arr[pos] = 0;\\n            continue outer;\\n        }\\n    }\\n    for (int i = 0; i < len; i++) {\\n        if (arr[i] != 0) {\\n            res.append(arr[i]);\\n        }\\n    }\\n    return res.toString();\\n}\\n\\n/**\\n    * \\u4E8C\\u5206\\u67E5\\u627E\\u6BD4 value\\u5C0F\\u7684\\u4E2A\\u6570\\n    */\\nint findIndex(List<Integer> list, int value) {\\n    int l = 0, r = list.size();\\n    while (l < r) {\\n        int mid = (l + r) >> 1;\\n        if (list.get(mid) < value) {\\n            l = mid + 1;\\n        } else {\\n            r = mid;\\n        }\\n    }\\n    return l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 725256,
                "title": "java-o-n-sqrt-n-sqrt-decomposition-and-index-queues",
                "content": "A solution with **O(n*sqrt(n))** time and  **O(n)** space complexity. \\nIt is asymptotically slower than the Segment Tree solution,\\nbut it has not been offered so far, so I will add it here for completeness.\\n\\nWe create queues of index occurences for every digit, and we pick the left most index of the smallest digit we could move to first position.\\nOnce we have exhausted all k swaps, we append remaining unused digits.\\n\\nWhen we do swaps to move an element to the front, all elements to the left of it shift one position to the right.\\nTo keep track of how far every element has shifted we use a Sqrt Decomposition structure (we could use instead a Segment Tree for this purpose, see other solutions). \\nSqrt Decomposition is a simpler structure, but less efficient too: **calculateShift()** has a **sqrt(n)** instead of **log(n)** execution time. For more information see https://cp-algorithms.com/data_structures/sqrt_decomposition.html\\n\\n\\n\\n```\\n// O(n*sqrt(n)) time, O(n) space\\t\\nclass Solution {\\t\\n   \\t\\n    public String minInteger(String num, int k) {\\t\\n        int n = num.length();\\t\\n        char[] arr = num.toCharArray();\\t\\n        \\n        Queue[] indexQueues = createIndexQueues(arr);\\t\\n        SqrtDecomposition sqrt = new SqrtDecomposition(n);\\t\\n            \\t\\n        StringBuilder sb = new StringBuilder();\\t\\n        for (int i = 0; i < n; i++) {\\t\\n            if (k == 0) break;\\t\\n            for (int digit = 0; digit < 10; digit++) {\\t\\n                Queue<Integer> q = indexQueues[digit];\\t\\n                if (!q.isEmpty()) {\\t\\n                    int originalIndex = q.peek();\\t\\n                    int shiftedIndex = originalIndex + sqrt.calculateShift(originalIndex) - i;\\t\\n                    if (shiftedIndex <= k) {\\t\\n                        sb.append(arr[originalIndex]);\\t\\n                        sqrt.add(q.poll());\\t\\n                        k -= shiftedIndex;\\t\\n                        break;\\t\\n                    }    \\t\\n                }\\t\\n            }            \\t\\n        }\\t\\n        \\t\\n        //add digits which we haven\\'t used yet    \\t\\n        for (int i = 0; i < n; i++) if (sqrt.a[i] == 0) sb.append(arr[i]);\\t\\n        return sb.toString();\\t\\n    }\\t\\n    \\t\\n    private Queue[] createIndexQueues(char[] arr) {\\t\\n        Queue[] queues = new LinkedList[10];\\t\\n        for (int i = 0; i < 10; i++) queues[i] = new LinkedList<Integer>();\\t\\n        for (int i = 0; i < arr.length; i++) queues[arr[i]-\\'0\\'].offer(i);\\t\\n        return queues;\\t\\n    }\\t\\n}\\t\\n\\n//For explanation on how Sqrt Decomposition works, see https://cp-algorithms.com/data_structures/sqrt_decomposition.html\\nclass SqrtDecomposition {\\t\\n    int[] a;\\t\\n    int[] b;\\t\\n    int n;\\t\\n    int sqrtN;\\t\\n    \\t\\n    SqrtDecomposition(int n) {\\t\\n        this.n = n;\\n        sqrtN = ((int) Math.sqrt(n)) + 1;\\t\\n        a = new int[n];\\t\\n        b = new int[sqrtN];\\t\\n    }\\t\\n    \\t\\n    void add(int i) {\\t\\n        a[i]++;\\t\\n        b[i/sqrtN]++;\\t\\n    }\\t\\n    \\t\\n    int calculateShift(int i) {\\t\\n        int answer = 0;\\t\\n        while ( i < n && i % sqrtN != 0) {\\t\\n            answer += a[i++];\\t\\n        }\\t\\n        int j = i/sqrtN;\\t\\n        while (j < sqrtN) {\\t\\n            answer += b[j++];\\t\\n        }\\t\\n        return answer;\\t\\n    }\\t\\n}\\t\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// O(n*sqrt(n)) time, O(n) space\\t\\nclass Solution {\\t\\n   \\t\\n    public String minInteger(String num, int k) {\\t\\n        int n = num.length();\\t\\n        char[] arr = num.toCharArray();\\t\\n        \\n        Queue[] indexQueues = createIndexQueues(arr);\\t\\n        SqrtDecomposition sqrt = new SqrtDecomposition(n);\\t\\n            \\t\\n        StringBuilder sb = new StringBuilder();\\t\\n        for (int i = 0; i < n; i++) {\\t\\n            if (k == 0) break;\\t\\n            for (int digit = 0; digit < 10; digit++) {\\t\\n                Queue<Integer> q = indexQueues[digit];\\t\\n                if (!q.isEmpty()) {\\t\\n                    int originalIndex = q.peek();\\t\\n                    int shiftedIndex = originalIndex + sqrt.calculateShift(originalIndex) - i;\\t\\n                    if (shiftedIndex <= k) {\\t\\n                        sb.append(arr[originalIndex]);\\t\\n                        sqrt.add(q.poll());\\t\\n                        k -= shiftedIndex;\\t\\n                        break;\\t\\n                    }    \\t\\n                }\\t\\n            }            \\t\\n        }\\t\\n        \\t\\n        //add digits which we haven\\'t used yet    \\t\\n        for (int i = 0; i < n; i++) if (sqrt.a[i] == 0) sb.append(arr[i]);\\t\\n        return sb.toString();\\t\\n    }\\t\\n    \\t\\n    private Queue[] createIndexQueues(char[] arr) {\\t\\n        Queue[] queues = new LinkedList[10];\\t\\n        for (int i = 0; i < 10; i++) queues[i] = new LinkedList<Integer>();\\t\\n        for (int i = 0; i < arr.length; i++) queues[arr[i]-\\'0\\'].offer(i);\\t\\n        return queues;\\t\\n    }\\t\\n}\\t\\n\\n//For explanation on how Sqrt Decomposition works, see https://cp-algorithms.com/data_structures/sqrt_decomposition.html\\nclass SqrtDecomposition {\\t\\n    int[] a;\\t\\n    int[] b;\\t\\n    int n;\\t\\n    int sqrtN;\\t\\n    \\t\\n    SqrtDecomposition(int n) {\\t\\n        this.n = n;\\n        sqrtN = ((int) Math.sqrt(n)) + 1;\\t\\n        a = new int[n];\\t\\n        b = new int[sqrtN];\\t\\n    }\\t\\n    \\t\\n    void add(int i) {\\t\\n        a[i]++;\\t\\n        b[i/sqrtN]++;\\t\\n    }\\t\\n    \\t\\n    int calculateShift(int i) {\\t\\n        int answer = 0;\\t\\n        while ( i < n && i % sqrtN != 0) {\\t\\n            answer += a[i++];\\t\\n        }\\t\\n        int j = i/sqrtN;\\t\\n        while (j < sqrtN) {\\t\\n            answer += b[j++];\\t\\n        }\\t\\n        return answer;\\t\\n    }\\t\\n}\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724464,
                "title": "java-solution-complexity-o-k-n",
                "content": "```\\nclass Solution {\\n    public String minInteger(String num, int swaps) {\\n        char[] arr = num.toCharArray();\\n        arr = minArray(arr, arr.length, swaps); \\n        return new String(arr);\\n    }\\n    char[] minArray(char[] arr, int length, int swaps) { \\n        if (swaps == 0) \\n            return arr; \\n        for (int i = 0; i < length; i++) { \\n            int min_index = 0, min = Integer.MAX_VALUE;\\n            int limit = (swaps+i) > length-1 ?  length-1 : swaps + i; \\n            for (int j = i; j <= limit; j++) {\\n                if (arr[j] < min) { \\n                    min = arr[j]; \\n                    min_index = j; \\n                }\\n            }\\n            swaps -= (min_index - i);     \\n            arr = swapMin(arr, i, min_index); \\n            if (swaps == 0) \\n                break; \\n        }\\n        return arr;\\n    } \\n    char[] swapMin(char[] arr, int target, int current) { \\n        char temp = \\'0\\'; \\n        for (int i = current; i > target; i--) { \\n            temp = arr[i - 1]; \\n            arr[i - 1] = arr[i]; \\n            arr[i] = temp; \\n        }\\n        return arr;\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minInteger(String num, int swaps) {\\n        char[] arr = num.toCharArray();\\n        arr = minArray(arr, arr.length, swaps); \\n        return new String(arr);\\n    }\\n    char[] minArray(char[] arr, int length, int swaps) { \\n        if (swaps == 0) \\n            return arr; \\n        for (int i = 0; i < length; i++) { \\n            int min_index = 0, min = Integer.MAX_VALUE;\\n            int limit = (swaps+i) > length-1 ?  length-1 : swaps + i; \\n            for (int j = i; j <= limit; j++) {\\n                if (arr[j] < min) { \\n                    min = arr[j]; \\n                    min_index = j; \\n                }\\n            }\\n            swaps -= (min_index - i);     \\n            arr = swapMin(arr, i, min_index); \\n            if (swaps == 0) \\n                break; \\n        }\\n        return arr;\\n    } \\n    char[] swapMin(char[] arr, int target, int current) { \\n        char temp = \\'0\\'; \\n        for (int i = current; i > target; i--) { \\n            temp = arr[i - 1]; \\n            arr[i - 1] = arr[i]; \\n            arr[i] = temp; \\n        }\\n        return arr;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724013,
                "title": "c-bit-easy-understand-with-explanation",
                "content": "Data Structures used: Binary Indexed tree, Priority Queue, Vector.\\nBIT Tree: To store the count as well as the position of the swapped numbers.\\nPriority Queue: Used for storing the positions of all the numbers\\nVector: For storing the remaining numbers which were not swapped and will be added to the resutling string in the end.\\n\\nTo get the minimum number possible we have to find the smallest number possible in the beginning of the string. So, we will greedily choose numbers from 0-9 for each position, check how many previous numbers have been swapped before this number, (It is important because for each swapped number at position ```cur```, all the numbers left to it are shifted by 1 position to the right and the numbers to the right are at their original position).  We will subtract the ```cur``` with ```prevCnt``` because since the numbers are shifted by 1 position to the right, the position of the the current number to be swapped is also moving forward with each swap, so net effect reamins the same and we only have to take care of the number of swaps upto that position ```cur``` After checking if swap is possible or not, we update the current position of the number for all the future swaps. Like this we do for all the numbers and at the end we store all the numbers in the tmp vector, sort it and add it to the resulting string.\\n\\nHope this clears your doubt. Feel free to ask any questions! \\nCredits: [jt3698](https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/discuss/720235/C%2B%2B-O(N-log-N)-FenwickBIT-solution-196ms-(with-explanation))\\n\\n```\\nclass Solution {\\npublic:\\n    int BIT[30002];\\n    priority_queue<int,vector<int>,greater<int>> pq[10];\\n    vector<pair<int,int>> tmp;\\n    int n;\\n    \\n    string minInteger(string num, int k) {\\n        string res=\"\";\\n        int counter=0;\\n        n=num.size();\\n        memset(BIT,0,sizeof BIT);\\n        tmp.clear();\\n        for(int i=0;i<n;i++)\\n            pq[num[i]-\\'0\\'].push(i);\\n        \\n        \\n        while(counter < n && k>0) {\\n            for(int i=0;i<=9;i++){\\n                if(!pq[i].empty()){\\n                    int cur=pq[i].top();\\n                    int prevCnt=getPrevCnt(cur);\\n                    int swaps=cur-prevCnt;\\n                    if(swaps<=k){\\n                        k-=swaps;\\n                        res+=(i+\\'0\\');\\n                        pq[i].pop();\\n                        updateBIT(cur+1);\\n                        break;\\n                    }\\n                }\\n            }\\n            counter++;\\n        }\\n        for(int i=0;i<=9;i++){\\n            while(!pq[i].empty()){\\n                int num=pq[i].top();\\n                pq[i].pop();\\n                tmp.push_back({num,i});\\n            }\\n        }\\n        \\n        sort(tmp.begin(),tmp.end());\\n        \\n        for(int i=0;i<tmp.size();i++)\\n            res+=(tmp[i].second+\\'0\\');\\n        \\n        return res;\\n    }\\n    \\n    int getPrevCnt(int x){\\n        int cnt=0;\\n        while(x>0){\\n            cnt+=BIT[x];\\n            x-=(x&-x);\\n        }\\n        return cnt;\\n    }\\n    \\n    void updateBIT(int x){\\n        while(x<=n){\\n            BIT[x]++;\\n            x+=(x&-x);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cur```\n```cur```\n```prevCnt```\n```cur```\n```\\nclass Solution {\\npublic:\\n    int BIT[30002];\\n    priority_queue<int,vector<int>,greater<int>> pq[10];\\n    vector<pair<int,int>> tmp;\\n    int n;\\n    \\n    string minInteger(string num, int k) {\\n        string res=\"\";\\n        int counter=0;\\n        n=num.size();\\n        memset(BIT,0,sizeof BIT);\\n        tmp.clear();\\n        for(int i=0;i<n;i++)\\n            pq[num[i]-\\'0\\'].push(i);\\n        \\n        \\n        while(counter < n && k>0) {\\n            for(int i=0;i<=9;i++){\\n                if(!pq[i].empty()){\\n                    int cur=pq[i].top();\\n                    int prevCnt=getPrevCnt(cur);\\n                    int swaps=cur-prevCnt;\\n                    if(swaps<=k){\\n                        k-=swaps;\\n                        res+=(i+\\'0\\');\\n                        pq[i].pop();\\n                        updateBIT(cur+1);\\n                        break;\\n                    }\\n                }\\n            }\\n            counter++;\\n        }\\n        for(int i=0;i<=9;i++){\\n            while(!pq[i].empty()){\\n                int num=pq[i].top();\\n                pq[i].pop();\\n                tmp.push_back({num,i});\\n            }\\n        }\\n        \\n        sort(tmp.begin(),tmp.end());\\n        \\n        for(int i=0;i<tmp.size();i++)\\n            res+=(tmp[i].second+\\'0\\');\\n        \\n        return res;\\n    }\\n    \\n    int getPrevCnt(int x){\\n        int cnt=0;\\n        while(x>0){\\n            cnt+=BIT[x];\\n            x-=(x&-x);\\n        }\\n        return cnt;\\n    }\\n    \\n    void updateBIT(int x){\\n        while(x<=n){\\n            BIT[x]++;\\n            x+=(x&-x);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722393,
                "title": "java-solution-no-collections-super-slow-ac",
                "content": "```\\nclass Solution {\\n    \\n    public String minInteger(String num, int k) {\\n        \\n\\t\\t// the k enough to make the string ordered\\n        if(k>=num.length()*(num.length()-1)/2){\\n            char[] cs = num.toCharArray();\\n            Arrays.sort(cs);\\n            return new String(cs);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder(num);\\n        StringBuilder rst = new StringBuilder();\\n        \\n        while(k>0){\\n            for(int i=0; i<9; i++){\\n                int idx = sb.indexOf(String.valueOf(i));\\n\\t\\t\\t\\t// swap the char to the head\\n                if(idx>=0 && idx<=k){\\n                    k-=idx;\\n                    rst.append(i);\\n                    sb.deleteCharAt(idx);\\n                    i=-1;\\n                }\\n            }\\n            break;\\n        }\\n        \\n\\t\\t// if the k still>0, move the first non ordered char k forward\\n        if(k>0){\\n            for(int i=1; i<sb.length(); i++){\\n                if(sb.charAt(i)<sb.charAt(i-1)){\\n                    char ch = sb.charAt(i);\\n                    sb.deleteCharAt(i);\\n                    sb.insert(i-k, ch);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        rst.append(sb);\\n        return rst.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public String minInteger(String num, int k) {\\n        \\n\\t\\t// the k enough to make the string ordered\\n        if(k>=num.length()*(num.length()-1)/2){\\n            char[] cs = num.toCharArray();\\n            Arrays.sort(cs);\\n            return new String(cs);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder(num);\\n        StringBuilder rst = new StringBuilder();\\n        \\n        while(k>0){\\n            for(int i=0; i<9; i++){\\n                int idx = sb.indexOf(String.valueOf(i));\\n\\t\\t\\t\\t// swap the char to the head\\n                if(idx>=0 && idx<=k){\\n                    k-=idx;\\n                    rst.append(i);\\n                    sb.deleteCharAt(idx);\\n                    i=-1;\\n                }\\n            }\\n            break;\\n        }\\n        \\n\\t\\t// if the k still>0, move the first non ordered char k forward\\n        if(k>0){\\n            for(int i=1; i<sb.length(); i++){\\n                if(sb.charAt(i)<sb.charAt(i-1)){\\n                    char ch = sb.charAt(i);\\n                    sb.deleteCharAt(i);\\n                    sb.insert(i-k, ch);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        rst.append(sb);\\n        return rst.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721962,
                "title": "268ms-python-solution-beat-100",
                "content": "store the position of all previously moved-to-front element and keep in order, then use binary search to find out how many elements before the current one have been forwarded.\\n```python\\nfrom bisect import bisect\\n\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        len_num = len(num)\\n        if k >= len_num * (len_num - 1) / 2:\\n            return \\'\\'.join(sorted(num))\\n        pos = [[] for _ in range(10)]\\n        for i in range(len_num - 1, -1, -1):\\n            pos[int(num[i])].append(i)\\n        prev = []\\n        ans = \\'\\'\\n        candi = list(range(10))\\n        while k and len(ans) < len_num:\\n            for di in candi[:]:\\n                if pos[di]:\\n                    index = pos[di][-1]\\n                    place = bisect(prev, index)\\n                    if index - place <= k:\\n                        prev.insert(place, index)\\n                        k -= index - place\\n                        pos[di].pop()\\n                        ans += str(di)\\n                        break\\n                else:\\n                    candi.remove(di)\\n        if k == 0 and len(ans) < len_num:\\n            prev = set(prev)\\n            return ans + \\'\\'.join(ch for i, ch in enumerate(num) if i not in prev)\\n        else:\\n            return ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nfrom bisect import bisect\\n\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        len_num = len(num)\\n        if k >= len_num * (len_num - 1) / 2:\\n            return \\'\\'.join(sorted(num))\\n        pos = [[] for _ in range(10)]\\n        for i in range(len_num - 1, -1, -1):\\n            pos[int(num[i])].append(i)\\n        prev = []\\n        ans = \\'\\'\\n        candi = list(range(10))\\n        while k and len(ans) < len_num:\\n            for di in candi[:]:\\n                if pos[di]:\\n                    index = pos[di][-1]\\n                    place = bisect(prev, index)\\n                    if index - place <= k:\\n                        prev.insert(place, index)\\n                        k -= index - place\\n                        pos[di].pop()\\n                        ans += str(di)\\n                        break\\n                else:\\n                    candi.remove(di)\\n        if k == 0 and len(ans) < len_num:\\n            prev = set(prev)\\n            return ans + \\'\\'.join(ch for i, ch in enumerate(num) if i not in prev)\\n        else:\\n            return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721935,
                "title": "an-interesting-observation-linear-time-edge-cases",
                "content": "Just a small observation: let k = #swaps and n=(len string - 1) If k > (n^2 + n) / 2 just return sorted string.\\n\\nWhy?\\n\\nRecall, Gauss\\' sum, g(n) = 1+2+3+...+n = (n^2 + n) / 2\\n\\nand imagine some worst-case string. This worst-case string will be reverse order, like:\\n\\n\"54321\". Imagine this string, and k = 1000\\n\\nBest string is clearly \"12345\". # of swaps to create this number is\\n\\n4+3+2+1. So, g(N-1) where N is length of string. We can immediately return sorted string if this condition is true.\\n\\nWe can sort this string with Radix sort, since alphabet is only 0-9. And Radix sort is O(n) for this problem.\\n\\n",
                "solutionTags": [],
                "code": "Just a small observation: let k = #swaps and n=(len string - 1) If k > (n^2 + n) / 2 just return sorted string.\\n\\nWhy?\\n\\nRecall, Gauss\\' sum, g(n) = 1+2+3+...+n = (n^2 + n) / 2\\n\\nand imagine some worst-case string. This worst-case string will be reverse order, like:\\n\\n\"54321\". Imagine this string, and k = 1000\\n\\nBest string is clearly \"12345\". # of swaps to create this number is\\n\\n4+3+2+1. So, g(N-1) where N is length of string. We can immediately return sorted string if this condition is true.\\n\\nWe can sort this string with Radix sort, since alphabet is only 0-9. And Radix sort is O(n) for this problem.\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 721774,
                "title": "c-o-n-2-172ms-greedy-solution-28-lines-with-explanation",
                "content": "* To make num string sorted, the maximal numer of swaps is n*(n-1)/2. If k is >= this number,  the sorted one could just be returned. (This helps to pass some test cases with TLE).\\n* getNext() tries to find the smallest character within range k to replace the current character. If it was not found (or the smaller ones are all out of k range), it means the current one is the best one (we don\\'t need to do any swap), we just go to the next position.\\n* If the smallest one was found, we shift the substring (idx, replacement-idx) one element back, and replace the current one with the smallest one. \\n```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n        if(k> n*n/2) {\\n            sort(num.begin(), num.end());\\n            return num;\\n        }\\n        for(int i=0; i<n; i++){\\n            getNext(num, i, k);\\n        }\\n        return num;\\n    }\\n    void getNext(string& num, int idx, int& k) {\\n        int replacement = idx;\\n        for(char c=\\'0\\'; c<num[idx]; c++) {\\n            size_t pos = num.find(c, idx+1);\\n            if(pos-idx<=k) {\\n                replacement = pos;\\n                break;\\n            }\\n        }\\n        if(replacement==idx) return;\\n        char c = num[replacement];\\n        for(int i=replacement; i>idx; i--) num[i] = num[i-1];\\n        num[idx] = c;\\n        k-=(replacement-idx);  \\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n        if(k> n*n/2) {\\n            sort(num.begin(), num.end());\\n            return num;\\n        }\\n        for(int i=0; i<n; i++){\\n            getNext(num, i, k);\\n        }\\n        return num;\\n    }\\n    void getNext(string& num, int idx, int& k) {\\n        int replacement = idx;\\n        for(char c=\\'0\\'; c<num[idx]; c++) {\\n            size_t pos = num.find(c, idx+1);\\n            if(pos-idx<=k) {\\n                replacement = pos;\\n                break;\\n            }\\n        }\\n        if(replacement==idx) return;\\n        char c = num[replacement];\\n        for(int i=replacement; i>idx; i--) num[i] = num[i-1];\\n        num[idx] = c;\\n        k-=(replacement-idx);  \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721697,
                "title": "python3-solution-in-o-nlogn-time",
                "content": "Use a subscript *idx* to represent the character that can be replaced by a smaller digit. *idx* traverses from num[0] to num[-1]. In O(N^2) solution, it takes linear time to find the minimum digit on the right to *num[idx]*. In order to reduce it to O(logN) time:\\n\\n1. Use a dict to find a minimum digit in O(1) time. The key of this dict is a digit, the value(a sorted list) of the dict is the indices of its occurrences. This digit is just a candidate, use step 2 to check if it is appropriate.\\n2. Compute the real distance between [idx] and the candidate, which is the tricky part.\\n\\nThe dict only contains the original indices of the digits, but during the algorithm, we rebuild the string *num* each loop. However we don\\'t want to update the dict, because it will take linear time. Therefore, we use the value in the dict to compute the real-time distance.\\n\\nThe key is to maintain a list *pick_idx*, which records the digits that we have swapped to the front, and we use bisect to keep it sorted. Every time we compute a distance, we use bisect_right to find the index of it in *pick_idx*, and count how many swapped digits are on its right. We have to add this number to *index of candidate - idx* because the candidate actually moves right for 1 slot if another candidate right to it was swapped in the past.\\n\\nMaintain *pick_idx*, add the appropriate candidate to this list, and use this list to compute the real distance.\\n\\n\\n``` python\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        map = collections.defaultdict(list)\\n        for i,c in enumerate(num):\\n            map[c].append(i)\\n        \\n        idx, pick_idx= 0, []\\n        for idx in range(len(num)):\\n            for target in range(10):\\n                if target<=int(num[idx]) and map[str(target)]:\\n                    insert_pos = bisect.bisect_right(pick_idx, map[str(target)][0])\\n                    num_on_the_right = len(pick_idx)-insert_pos\\n                    move_length = map[str(target)][0]+num_on_the_right-idx\\n\\t\\t\\t\\t\\t# compute the actual move length\\n                    if move_length>=0 and move_length<=k:\\n                        k-=move_length\\n                        target_pos = map[str(target)][0]\\n                        pick_idx.insert(insert_pos, target_pos)\\n                        target_pos+=num_on_the_right                        \\n                        num = num[0:idx]+num[target_pos]+num[idx:target_pos]+num[target_pos+1:]\\n                        map[str(target)].pop(0)\\n                        if len(map[str(target)])==0: del map[str(target)]          \\n                        break    \\n                                        \\n            if k==0: break  # no jumps left\\n        return num\\n```",
                "solutionTags": [],
                "code": "``` python\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        map = collections.defaultdict(list)\\n        for i,c in enumerate(num):\\n            map[c].append(i)\\n        \\n        idx, pick_idx= 0, []\\n        for idx in range(len(num)):\\n            for target in range(10):\\n                if target<=int(num[idx]) and map[str(target)]:\\n                    insert_pos = bisect.bisect_right(pick_idx, map[str(target)][0])\\n                    num_on_the_right = len(pick_idx)-insert_pos\\n                    move_length = map[str(target)][0]+num_on_the_right-idx\\n\\t\\t\\t\\t\\t# compute the actual move length\\n                    if move_length>=0 and move_length<=k:\\n                        k-=move_length\\n                        target_pos = map[str(target)][0]\\n                        pick_idx.insert(insert_pos, target_pos)\\n                        target_pos+=num_on_the_right                        \\n                        num = num[0:idx]+num[target_pos]+num[idx:target_pos]+num[target_pos+1:]\\n                        map[str(target)].pop(0)\\n                        if len(map[str(target)])==0: del map[str(target)]          \\n                        break    \\n                                        \\n            if k==0: break  # no jumps left\\n        return num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721647,
                "title": "c-bit-solution-with-comments-and-explanations",
                "content": "Credits to https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/discuss/720235/C%2B%2B-O(N-log-N)-FenwickBIT-solution-196ms-(with-explanation) for the original idea. This is my implementation and understanding of the idea.\\n\\nTo summarize here:\\n1. Preprocess the string to get all indexes of each digit in the original string.\\n2. At each point, greedily see whether we can put the smallest digit to the current position, here we use BIT to store total number of digits already selected before index i, to calculate and update the cost in O(logn) time.\\n3. We stop when we no longer have any additional moves, or when we have already reconstructed the whole string. If we ran out of moves before the whole string is reconstructed, we need to put back the rest of the characters in their original order, which can be done in a merge-sort fashion.\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int GetSum(const vector<int>& bit, int index) {\\n        int x = index;\\n        int sum = 0;\\n        while (x > 0) {\\n            sum += bit[x];\\n            x -= x&(-x);\\n        }\\n        return sum;\\n    }\\n    \\n    void update(vector<int>& bit, int index, int val) {\\n        int x = index;\\n        while (x < bit.size()) {\\n            bit[x] += val;\\n            x += x & (-x);\\n        }\\n    }\\n    \\n    string minInteger(string num, int k) {\\n        // Stores indexes of each number incrementally.\\n        vector<deque<int>> indexes(10, deque<int>());\\n        \\n        for (int i = 0; i < num.length(); ++i) {\\n            int n = num[i] - \\'0\\';\\n            indexes[n].push_back(i);\\n        }\\n        \\n        // BIT for storing how many numbers have we already taken so far.\\n        vector<int> bit(num.length() + 1, 0);\\n\\n        // Prefix for storing already swapped elements.\\n        string prefix;\\n        \\n        // Iterate when we are not already finished (prefix length == num length), and when we still have moves.\\n        while (k > 0 && prefix.length() < num.length()) {\\n            // Iterate each number from small to large, greedily.\\n            for (int i = 0; i <= 9; ++i) {\\n                if (indexes[i].empty()) {\\n                    continue;\\n                }\\n                int next = indexes[i].front();\\n                \\n                // The cost to move this number from its current position to front.\\n                // The cost is equal to \"original index - number of digits already taken before this\".\\n                int taken = GetSum(bit, next + 1);\\n                int cost = next - taken;\\n                \\n                // If we can move this digit, we move it and adjust the cost in the BIT accordingly.\\n                if (cost <= k) {\\n                    prefix.append(1, \\'0\\' + i);\\n                    update(bit, next + 1, 1);\\n                    k -= cost;\\n                    indexes[i].pop_front();\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // For cases where we have used all moves, but the entire string hasn\\'t been constructed yet,\\n\\t\\t// we just need to reconstruct the rest of the original string based on its initial order.\\n        // Since the relative positions of them are not moved, we can simply do a \"merge sort from k lists\" here.\\n        while (prefix.length() != num.length()) {\\n            int smallest = INT_MAX;\\n            int smallest_num = -1; \\n            for (int i = 0; i <= 9; ++i) {\\n                if (!indexes[i].empty()) {\\n                    if (smallest > indexes[i].front()) {\\n                        smallest = indexes[i].front();\\n                        smallest_num = i;\\n                    }\\n                }\\n            }\\n            \\n            if (smallest_num != -1) {\\n                indexes[smallest_num].pop_front();\\n                prefix.append(1, \\'0\\' + smallest_num);\\n            }\\n        }\\n\\n        return prefix;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int GetSum(const vector<int>& bit, int index) {\\n        int x = index;\\n        int sum = 0;\\n        while (x > 0) {\\n            sum += bit[x];\\n            x -= x&(-x);\\n        }\\n        return sum;\\n    }\\n    \\n    void update(vector<int>& bit, int index, int val) {\\n        int x = index;\\n        while (x < bit.size()) {\\n            bit[x] += val;\\n            x += x & (-x);\\n        }\\n    }\\n    \\n    string minInteger(string num, int k) {\\n        // Stores indexes of each number incrementally.\\n        vector<deque<int>> indexes(10, deque<int>());\\n        \\n        for (int i = 0; i < num.length(); ++i) {\\n            int n = num[i] - \\'0\\';\\n            indexes[n].push_back(i);\\n        }\\n        \\n        // BIT for storing how many numbers have we already taken so far.\\n        vector<int> bit(num.length() + 1, 0);\\n\\n        // Prefix for storing already swapped elements.\\n        string prefix;\\n        \\n        // Iterate when we are not already finished (prefix length == num length), and when we still have moves.\\n        while (k > 0 && prefix.length() < num.length()) {\\n            // Iterate each number from small to large, greedily.\\n            for (int i = 0; i <= 9; ++i) {\\n                if (indexes[i].empty()) {\\n                    continue;\\n                }\\n                int next = indexes[i].front();\\n                \\n                // The cost to move this number from its current position to front.\\n                // The cost is equal to \"original index - number of digits already taken before this\".\\n                int taken = GetSum(bit, next + 1);\\n                int cost = next - taken;\\n                \\n                // If we can move this digit, we move it and adjust the cost in the BIT accordingly.\\n                if (cost <= k) {\\n                    prefix.append(1, \\'0\\' + i);\\n                    update(bit, next + 1, 1);\\n                    k -= cost;\\n                    indexes[i].pop_front();\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // For cases where we have used all moves, but the entire string hasn\\'t been constructed yet,\\n\\t\\t// we just need to reconstruct the rest of the original string based on its initial order.\\n        // Since the relative positions of them are not moved, we can simply do a \"merge sort from k lists\" here.\\n        while (prefix.length() != num.length()) {\\n            int smallest = INT_MAX;\\n            int smallest_num = -1; \\n            for (int i = 0; i <= 9; ++i) {\\n                if (!indexes[i].empty()) {\\n                    if (smallest > indexes[i].front()) {\\n                        smallest = indexes[i].front();\\n                        smallest_num = i;\\n                    }\\n                }\\n            }\\n            \\n            if (smallest_num != -1) {\\n                indexes[smallest_num].pop_front();\\n                prefix.append(1, \\'0\\' + smallest_num);\\n            }\\n        }\\n\\n        return prefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721506,
                "title": "java-nlogn-solution-20-ms-using-fenwick-tree",
                "content": "1) Use fenwick tree to determine how many digits before a particular index have already been swapped. This will help us determine the number of swaps needed.\\n2) Use greedy approach to move the smallest possible digit at every step, to the most significant possible position.\\n\\n```\\nclass Solution {\\n    int[] bt;\\n    \\n    public String minInteger(String num, int k) {\\n        bt = new int[num.length()+1];\\n        char[] nums = num.toCharArray();\\n        List<List<Integer>> a = new ArrayList();\\n        for(int i=0;i<=9;i++) a.add(new ArrayList());\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int ind = nums[i]-\\'0\\';\\n            a.get(ind).add(i);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n   \\n        while(sb.length()<nums.length && k>0){\\n            int i=0; \\n        while(i<=9){\\n                if(a.get(i).size() == 0) i++;\\n                else{\\n                  int index = a.get(i).get(0);\\n                  int swap = index-get(index+1);  // find elements to be swapped\\n                    if(k<swap){\\n                        i++;\\n                    }\\n                    else{\\n                        update(index+1); // update the fenwick tree to give this information to future indexes\\n                        a.get(i).remove(0);\\n                        k-=swap;\\n                        sb.append(nums[index]);\\n                        nums[index] = \\'a\\';\\n                        break;\\n                    }\\n                }\\n           }\\n       }\\n        if(sb.length() == nums.length) return sb.toString();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] != \\'a\\') sb.append(nums[i]);\\n        } \\n        \\n        return sb.toString();\\n    }\\n    \\n    public int get(int val){\\n        int count = 0;\\n        \\n        while(val>0){\\n            count+=bt[val];\\n            val-= -val&val;\\n        }\\n        return count;\\n    }\\n    \\n    public void update(int val){ \\n        while(val < bt.length){\\n            bt[val]+=1;\\n            val += -val&val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] bt;\\n    \\n    public String minInteger(String num, int k) {\\n        bt = new int[num.length()+1];\\n        char[] nums = num.toCharArray();\\n        List<List<Integer>> a = new ArrayList();\\n        for(int i=0;i<=9;i++) a.add(new ArrayList());\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int ind = nums[i]-\\'0\\';\\n            a.get(ind).add(i);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n   \\n        while(sb.length()<nums.length && k>0){\\n            int i=0; \\n        while(i<=9){\\n                if(a.get(i).size() == 0) i++;\\n                else{\\n                  int index = a.get(i).get(0);\\n                  int swap = index-get(index+1);  // find elements to be swapped\\n                    if(k<swap){\\n                        i++;\\n                    }\\n                    else{\\n                        update(index+1); // update the fenwick tree to give this information to future indexes\\n                        a.get(i).remove(0);\\n                        k-=swap;\\n                        sb.append(nums[index]);\\n                        nums[index] = \\'a\\';\\n                        break;\\n                    }\\n                }\\n           }\\n       }\\n        if(sb.length() == nums.length) return sb.toString();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] != \\'a\\') sb.append(nums[i]);\\n        } \\n        \\n        return sb.toString();\\n    }\\n    \\n    public int get(int val){\\n        int count = 0;\\n        \\n        while(val>0){\\n            count+=bt[val];\\n            val-= -val&val;\\n        }\\n        return count;\\n    }\\n    \\n    public void update(int val){ \\n        while(val < bt.length){\\n            bt[val]+=1;\\n            val += -val&val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721181,
                "title": "greedy-algorithm-binary-indexed-tree-ten-pointers",
                "content": "```\\nfrom queue import deque\\n\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        nums = [int(c) for c in num]\\n        N = n+1\\n        cnts = [0]*N\\n        \\n        def update(pos, v):\\n            i = pos+1\\n            while i < N:\\n                cnts[i] += v\\n                i += i & (-i)\\n        \\n        def getSum(pos):\\n            i = pos+1\\n            ans = 0\\n            while i > 0:\\n                ans += cnts[i]\\n                i -= i & (-i)\\n            return ans\\n        \\n        left = [-1]*10\\n        for i, v in enumerate(nums):\\n            if left[v] != -1:\\n                continue\\n            left[v] = i\\n        ans = []\\n        res = k\\n        i = 0\\n        while res > 0 and i < n:\\n            cur = nums[i]\\n            flg = False\\n            for v in range(cur):\\n                if left[v] == -1:\\n                    continue\\n                pos = left[v]\\n                cost = pos-getSum(pos)\\n                if cost > res:\\n                    continue\\n                flg = True\\n                res -= cost\\n                ans.append(v)\\n                nums[pos] = -1\\n                update(pos, 1)\\n                left[v] = -1\\n                for ni in range(pos+1, n):\\n                    if nums[ni] == v:\\n                        left[v] = ni\\n                        break\\n                break\\n            if not flg:\\n                ans.append(cur)\\n                nums[i] = -1\\n                update(i, 1)\\n                while i < n and nums[i] == -1:\\n                    i += 1\\n                if left[cur] != -1:\\n                    left[cur] = -1\\n                    for ni in range(i, n):\\n                        if nums[ni] == cur:\\n                            left[cur] = ni\\n                            break\\n        while i < n:\\n            if nums[i] != -1:\\n                ans.append(nums[i])\\n            i += 1\\n        return \"\".join([str(v) for v in ans])\\n \\n```",
                "solutionTags": [],
                "code": "```\\nfrom queue import deque\\n\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        nums = [int(c) for c in num]\\n        N = n+1\\n        cnts = [0]*N\\n        \\n        def update(pos, v):\\n            i = pos+1\\n            while i < N:\\n                cnts[i] += v\\n                i += i & (-i)\\n        \\n        def getSum(pos):\\n            i = pos+1\\n            ans = 0\\n            while i > 0:\\n                ans += cnts[i]\\n                i -= i & (-i)\\n            return ans\\n        \\n        left = [-1]*10\\n        for i, v in enumerate(nums):\\n            if left[v] != -1:\\n                continue\\n            left[v] = i\\n        ans = []\\n        res = k\\n        i = 0\\n        while res > 0 and i < n:\\n            cur = nums[i]\\n            flg = False\\n            for v in range(cur):\\n                if left[v] == -1:\\n                    continue\\n                pos = left[v]\\n                cost = pos-getSum(pos)\\n                if cost > res:\\n                    continue\\n                flg = True\\n                res -= cost\\n                ans.append(v)\\n                nums[pos] = -1\\n                update(pos, 1)\\n                left[v] = -1\\n                for ni in range(pos+1, n):\\n                    if nums[ni] == v:\\n                        left[v] = ni\\n                        break\\n                break\\n            if not flg:\\n                ans.append(cur)\\n                nums[i] = -1\\n                update(i, 1)\\n                while i < n and nums[i] == -1:\\n                    i += 1\\n                if left[cur] != -1:\\n                    left[cur] = -1\\n                    for ni in range(i, n):\\n                        if nums[ni] == cur:\\n                            left[cur] = ni\\n                            break\\n        while i < n:\\n            if nums[i] != -1:\\n                ans.append(nums[i])\\n            i += 1\\n        return \"\".join([str(v) for v in ans])\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 721119,
                "title": "java-nlogn-recursion",
                "content": "```\\nclass Solution {\\n    class Item {\\n        int val;\\n        int dist;\\n        public Item(int val, int dist) {\\n            this.val = val;\\n            this.dist = dist;\\n        }\\n        \\n        public String toString() {\\n            return \"(\"+val+\",\"+dist+\")\";\\n        }\\n    }\\n    \\n    public String minInteger(String num, int k) {\\n        if(k == 0) return num;\\n        if(num.length() == 0) return num;\\n        PriorityQueue<Item> queue = new PriorityQueue<>((a, b) -> a.val == b.val ? a.dist - b.dist : a.val - b.val);\\n        for(int i = 0; i < num.length(); i++) {\\n            queue.offer(new Item(num.charAt(i) - \\'0\\', i));\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        List<Integer> exclude = new ArrayList<>();\\n        \\n        while(!queue.isEmpty() && queue.peek().dist <= k) {\\n            Item item = queue.poll();\\n            sb.append(item.val);\\n            int insertPos = bisearch(exclude, item.dist);\\n            exclude.add(insertPos, item.dist);\\n            k -= Math.max(0, (item.dist - insertPos));\\n        }\\n        if(!exclude.isEmpty()) {\\n            String next = throwaway(num, exclude);\\n            return sb.toString() + minInteger(next, k);\\n        }\\n        \\n        while(!queue.isEmpty() && queue.peek().dist > k) queue.poll();\\n        Item item = queue.peek();\\n        return \"\" + item.val + minInteger(num.substring(0, item.dist) + num.substring(item.dist+1), k-item.dist);\\n    }\\n    \\n    private int bisearch(List<Integer> list, int i) {\\n        int index = Collections.binarySearch(list, i);\\n        if(index < 0) index = -index-1;\\n        return index;\\n    }\\n    \\n    private String throwaway(String s, List<Integer> exclude) {\\n        Set<Integer> set = new HashSet<>(exclude);\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < s.length(); i++) {\\n            if(set.contains(i)) continue;\\n            sb.append(s.charAt(i));\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Item {\\n        int val;\\n        int dist;\\n        public Item(int val, int dist) {\\n            this.val = val;\\n            this.dist = dist;\\n        }\\n        \\n        public String toString() {\\n            return \"(\"+val+\",\"+dist+\")\";\\n        }\\n    }\\n    \\n    public String minInteger(String num, int k) {\\n        if(k == 0) return num;\\n        if(num.length() == 0) return num;\\n        PriorityQueue<Item> queue = new PriorityQueue<>((a, b) -> a.val == b.val ? a.dist - b.dist : a.val - b.val);\\n        for(int i = 0; i < num.length(); i++) {\\n            queue.offer(new Item(num.charAt(i) - \\'0\\', i));\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        List<Integer> exclude = new ArrayList<>();\\n        \\n        while(!queue.isEmpty() && queue.peek().dist <= k) {\\n            Item item = queue.poll();\\n            sb.append(item.val);\\n            int insertPos = bisearch(exclude, item.dist);\\n            exclude.add(insertPos, item.dist);\\n            k -= Math.max(0, (item.dist - insertPos));\\n        }\\n        if(!exclude.isEmpty()) {\\n            String next = throwaway(num, exclude);\\n            return sb.toString() + minInteger(next, k);\\n        }\\n        \\n        while(!queue.isEmpty() && queue.peek().dist > k) queue.poll();\\n        Item item = queue.peek();\\n        return \"\" + item.val + minInteger(num.substring(0, item.dist) + num.substring(item.dist+1), k-item.dist);\\n    }\\n    \\n    private int bisearch(List<Integer> list, int i) {\\n        int index = Collections.binarySearch(list, i);\\n        if(index < 0) index = -index-1;\\n        return index;\\n    }\\n    \\n    private String throwaway(String s, List<Integer> exclude) {\\n        Set<Integer> set = new HashSet<>(exclude);\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < s.length(); i++) {\\n            if(set.contains(i)) continue;\\n            sb.append(s.charAt(i));\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721117,
                "title": "c-intuitive-solution",
                "content": "In the given problem max string length is 30000 and max number of swaps is 10^9.\\nTherefore it is understood that any k more than n*(n+1)/2 will give the sorted array.\\nThe next step is to find the minimum element and place it in the front under the limit of permissible swaps. Next we count the number of swaps remaining and find the next smallest element and bring it to the second place and so on. If at any point we have a sorted array, we break.\\n```\\nstring minInteger(string num, int k) {\\n        int n = num.length();\\n        string num2 = num;\\n        sort(num2.begin(),num2.end());\\n        if(k>(n*(n+1))/2)\\n        {\\n            return num2;\\n        }\\n        int posi = -1;\\n        int mini = 10;\\n        int done = 0;\\n        while(k>0)\\n        {\\n            mini = 10;\\n            for(int i=done;i<n && i<=done+k;i++)\\n            {\\n                if(mini>(num[i]-\\'0\\'))\\n                {\\n                    posi = i;\\n                    mini = num[i]-\\'0\\';\\n                }\\n            }\\n            for(int i=posi;i>done;i--)\\n            {\\n                swap(num[i],num[i-1]);\\n                k--;\\n            }\\n            done++;\\n            if(num==num2)\\n                return num2;\\n        }\\n        return num;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstring minInteger(string num, int k) {\\n        int n = num.length();\\n        string num2 = num;\\n        sort(num2.begin(),num2.end());\\n        if(k>(n*(n+1))/2)\\n        {\\n            return num2;\\n        }\\n        int posi = -1;\\n        int mini = 10;\\n        int done = 0;\\n        while(k>0)\\n        {\\n            mini = 10;\\n            for(int i=done;i<n && i<=done+k;i++)\\n            {\\n                if(mini>(num[i]-\\'0\\'))\\n                {\\n                    posi = i;\\n                    mini = num[i]-\\'0\\';\\n                }\\n            }\\n            for(int i=posi;i>done;i--)\\n            {\\n                swap(num[i],num[i-1]);\\n                k--;\\n            }\\n            done++;\\n            if(num==num2)\\n                return num2;\\n        }\\n        return num;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 720751,
                "title": "c-o-nlogn-solution-faster-than-100-soln",
                "content": "Well Idea is to reduce the simple n^2 solution using Binary Indexed Tree. In O(n^2) solution we check for all non selected indices but only ten digits are possible from \\'0\\' to \\'9\\' well we can maintain a queue for each digit from \\'0\\' to \\'9\\' that consists first occurance of the the digit at the front. We can use BIT to find how many indices before the current indices have been moved in front of our answer by that amount we have to shift to find the cost of swapping current index to the ith position. Rest can be done same as the n^2 soln.\\n\\n\\n\\n\\n\\n```\\ntypedef int ll;\\nclass Solution {\\n    vector<ll>bit;\\npublic:\\n    \\n    void update(ll x,ll n)\\n    {\\n        while(x<=n)\\n        {\\n            bit[x]+=1;\\n            x+=(x&(-x));\\n        }\\n    }\\n    ll query(ll x)\\n    {\\n        ll ans=0;\\n        while(x>0)\\n        {\\n            ans+=bit[x];\\n            x-=(x&(-x));\\n        }\\n        return ans;\\n    }\\n    string minInteger(string num, int k) {\\n        ll n=num.size();\\n        for(ll i=0;i<=n+1;i++)\\n        {\\n            bit.push_back(0);\\n        }\\n        \\n        \\n        string ans=\"\";\\n        vector< queue<ll> > v(10);\\n        for(ll i=0;i<n;i++)\\n        {\\n            ll x=num[i]-\\'0\\';\\n            v[x].push(i);\\n        }\\n        for(ll i=0;i<n;i++)\\n        {\\n            ll pos=-1;\\n            ll dig=\\'a\\';\\n            ll cnt=i;\\n            ll hh=0;\\n            for(ll j=9;j>=0;j--)\\n            {\\n              \\n                ll ch=j+\\'0\\';\\n                if((!v[j].empty())&&ch<dig)\\n                {\\n                    ll pp=v[j].front();\\n                    ll ind=query(pp+1);\\n                    ll val=pp-i+cnt-ind;\\n                  \\n                    if(val<=k)\\n                    {\\n                        pos=pp;\\n                        dig=ch;\\n                        hh=val;\\n                    }\\n                }\\n            }\\n            if(pos!=-1)\\n            {\\n                update(pos+1,n);\\n                v[dig-\\'0\\'].pop();\\n                ans+=dig;\\n                k=k-hh;\\n                //cout<<(char)dig<<\" \"<<k<< \" \"<<pos<<endl;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef int ll;\\nclass Solution {\\n    vector<ll>bit;\\npublic:\\n    \\n    void update(ll x,ll n)\\n    {\\n        while(x<=n)\\n        {\\n            bit[x]+=1;\\n            x+=(x&(-x));\\n        }\\n    }\\n    ll query(ll x)\\n    {\\n        ll ans=0;\\n        while(x>0)\\n        {\\n            ans+=bit[x];\\n            x-=(x&(-x));\\n        }\\n        return ans;\\n    }\\n    string minInteger(string num, int k) {\\n        ll n=num.size();\\n        for(ll i=0;i<=n+1;i++)\\n        {\\n            bit.push_back(0);\\n        }\\n        \\n        \\n        string ans=\"\";\\n        vector< queue<ll> > v(10);\\n        for(ll i=0;i<n;i++)\\n        {\\n            ll x=num[i]-\\'0\\';\\n            v[x].push(i);\\n        }\\n        for(ll i=0;i<n;i++)\\n        {\\n            ll pos=-1;\\n            ll dig=\\'a\\';\\n            ll cnt=i;\\n            ll hh=0;\\n            for(ll j=9;j>=0;j--)\\n            {\\n              \\n                ll ch=j+\\'0\\';\\n                if((!v[j].empty())&&ch<dig)\\n                {\\n                    ll pp=v[j].front();\\n                    ll ind=query(pp+1);\\n                    ll val=pp-i+cnt-ind;\\n                  \\n                    if(val<=k)\\n                    {\\n                        pos=pp;\\n                        dig=ch;\\n                        hh=val;\\n                    }\\n                }\\n            }\\n            if(pos!=-1)\\n            {\\n                update(pos+1,n);\\n                v[dig-\\'0\\'].pop();\\n                ans+=dig;\\n                k=k-hh;\\n                //cout<<(char)dig<<\" \"<<k<< \" \"<<pos<<endl;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 720721,
                "title": "simple-c-position-memorization",
                "content": "I feel that the contest is unfair. C++ without a postion remember helper will fail due to time limit error while java can pass.\\n\\nThose code are not optimized. (contest code..) Sorry about this..\\n\\n\\nlike this:\\n```\\n    string minInteger_(string& num, int k, int idx) {\\n        if (idx >= num.length()) return num;\\n        if (k <= 0) return num;\\n        \\n        char maxVal = num[idx];\\n        int nextIdx = -1;\\n        \\n        for (int i = idx + 1; i < num.size() && i - idx <= k; ++i) {\\n            if (num[i] < maxVal) {\\n                maxVal = num[i];\\n                nextIdx = i;\\n            }\\n        }\\n        \\n        if (nextIdx < 0) return minInteger_(num, k, idx + 1);\\n        \\n        char t = num[nextIdx];\\n        num.erase(nextIdx, 1);\\n        num.insert(idx, string(1, t));\\n        \\n        return minInteger_(num, k - (nextIdx - idx), idx + 1);\\n    }\\n    \\n    string minInteger(string num, int k) {\\n        return minInteger_(num, k, 0);\\n    }\\n```\\n\\nTherefore, I have to introduce a position remember helper:\\n\\n```\\nstring minInteger_(string& num, int k, int idx, vector<int>& pos) {\\n\\tif (idx >= num.length()) return num;\\n\\tif (k <= 0) return num;\\n\\n\\tint nextIdx = -1;\\n\\n\\tfor (int j = 0; j < num[idx] - \\'0\\'; ++j) {\\n\\t\\tint i = max(idx + 1, pos[j]);\\n\\t\\tfor (; i < num.size() && i - idx <= k; ++i) {\\n\\t\\t\\tif (num[i] - \\'0\\' == j) {\\n\\t\\t\\t\\tnextIdx = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tpos[j] = i;\\n\\t\\tif (nextIdx != -1) break;\\n\\t}\\n\\n\\tif (nextIdx < 0) return minInteger_(num, k, idx + 1, pos);\\n\\n\\tchar t = num[nextIdx];\\n\\tnum.erase(nextIdx, 1);\\n\\tnum.insert(idx, string(1, t));\\n\\n\\treturn minInteger_(num, k - (nextIdx - idx), idx + 1, pos);\\n}\\n\\nstring minInteger(string num, int k) {\\n\\tvector<int> pos(10, 0);\\n\\treturn minInteger_(num, k, 0, pos);\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    string minInteger_(string& num, int k, int idx) {\\n        if (idx >= num.length()) return num;\\n        if (k <= 0) return num;\\n        \\n        char maxVal = num[idx];\\n        int nextIdx = -1;\\n        \\n        for (int i = idx + 1; i < num.size() && i - idx <= k; ++i) {\\n            if (num[i] < maxVal) {\\n                maxVal = num[i];\\n                nextIdx = i;\\n            }\\n        }\\n        \\n        if (nextIdx < 0) return minInteger_(num, k, idx + 1);\\n        \\n        char t = num[nextIdx];\\n        num.erase(nextIdx, 1);\\n        num.insert(idx, string(1, t));\\n        \\n        return minInteger_(num, k - (nextIdx - idx), idx + 1);\\n    }\\n    \\n    string minInteger(string num, int k) {\\n        return minInteger_(num, k, 0);\\n    }\\n```\n```\\nstring minInteger_(string& num, int k, int idx, vector<int>& pos) {\\n\\tif (idx >= num.length()) return num;\\n\\tif (k <= 0) return num;\\n\\n\\tint nextIdx = -1;\\n\\n\\tfor (int j = 0; j < num[idx] - \\'0\\'; ++j) {\\n\\t\\tint i = max(idx + 1, pos[j]);\\n\\t\\tfor (; i < num.size() && i - idx <= k; ++i) {\\n\\t\\t\\tif (num[i] - \\'0\\' == j) {\\n\\t\\t\\t\\tnextIdx = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tpos[j] = i;\\n\\t\\tif (nextIdx != -1) break;\\n\\t}\\n\\n\\tif (nextIdx < 0) return minInteger_(num, k, idx + 1, pos);\\n\\n\\tchar t = num[nextIdx];\\n\\tnum.erase(nextIdx, 1);\\n\\tnum.insert(idx, string(1, t));\\n\\n\\treturn minInteger_(num, k - (nextIdx - idx), idx + 1, pos);\\n}\\n\\nstring minInteger(string num, int k) {\\n\\tvector<int> pos(10, 0);\\n\\treturn minInteger_(num, k, 0, pos);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 720677,
                "title": "java-n-2-solution-nlogn-segment-tree-solution-nlogn-bit-solution",
                "content": "BIT\\n```\\nclass Solution {\\n    public String minInteger(String s, int k) {\\n        int arr[]=new int[s.length()];\\n        Arrays.fill(arr,1);\\n        Fenwick fe=new Fenwick(arr);\\n        StringBuilder res=new StringBuilder();\\n        Queue<Integer>q[]=new LinkedList[10];\\n        for(int i=0;i<q.length;i++){\\n            q[i]=new LinkedList<>();\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            q[c-\\'0\\'].add(i);\\n        }\\n        \\n        \\n        \\n        while(k>0){\\n            boolean good=false;\\n            for(int i=0;i<10;i++){\\n                if(q[i].size()==0)continue;\\n                \\n                int index=q[i].peek();\\n                int less=fe.sumRange(0,index-1);//how many elements remain less than it \\n                if(k>=less){\\n                    good=true;\\n                    q[i].poll();\\n                    k-=less;\\n                    res.append(i+\"\");\\n                    fe.update(index,-1);\\n                    break;\\n                }\\n            }\\n            \\n            if(!good)break;\\n        }\\n        \\n        \\n        \\n        \\n        \\n        \\n        List<int[]>A=new ArrayList<>();\\n        for(int i=0;i<q.length;i++){\\n           while(q[i].size()>0){\\n               A.add(new int[]{i,q[i].poll()});\\n           }\\n        }\\n        \\n        Collections.sort(A,(a,b)->{\\n            return a[1]-b[1];\\n        });\\n        \\n        for(int i=0;i<A.size();i++){\\n            res.append(A.get(i)[0]+\"\");\\n        }\\n        \\n        return res.toString();\\n    }\\n    \\n    \\n    class Fenwick {\\n        int tree[];//1-index based\\n        int A[];\\n        int arr[];\\n        public Fenwick(int[] A) {\\n            this.A=A;\\n            arr=new int[A.length];\\n            tree=new int[A.length+1];\\n            int sum=0;\\n            for(int i=0;i<A.length;i++){\\n                update(i,A[i]);\\n            }\\n        }\\n\\n        public void update(int i, int val) {\\n            arr[i]+=val;\\n            i++;\\n            while(i<tree.length){\\n                tree[i]+=val;\\n                i+=(i&-i);\\n            }\\n            \\n        }\\n\\n        public int sumRange(int i, int j) {\\n            \\n            return pre(j+1)-pre(i);\\n        }\\n\\n        public int pre(int i){\\n            int sum=0;\\n            while(i>0){\\n                sum+=tree[i];\\n                i-=(i&-i);\\n            }\\n            return sum;\\n        }\\n    }\\n}\\n```\\n\\nn^2 solution\\n```\\nclass Solution {\\n    public String minInteger(String s, int k) {\\n        char A[]=s.toCharArray();\\n        for(int i=0;i<A.length;i++){\\n            char min=A[i];\\n            int j=i+1;\\n            int copyk=k;\\n            int index=-1;\\n            while(copyk>0&&j<A.length){\\n                if(A[j]<min){\\n                    min=A[j];\\n                    index=j;\\n                }\\n                copyk--;j++;\\n            }\\n            if(index==-1||min==A[i])continue;\\n            for(j=index;j>i;j--){\\n                swap(A,j,j-1);\\n            }\\n            k-=(index-i);\\n            if(k==0)break;\\n        }\\n        StringBuilder str=new StringBuilder();\\n        for(char c:A)str.append(c+\"\");\\n        return str.toString();\\n    }\\n    \\n    public void swap(char A[],int i,int j){\\n        char temp=A[i];\\n        A[i]=A[j];\\n        A[j]=temp;\\n    }\\n}\\n```\\n\\n\\nsegment tree nlogn\\n\\n```\\nclass Solution {\\n    public String minInteger(String s, int k) {\\n        Seg seg=new Seg(0,s.length()-1);\\n        StringBuilder str=new StringBuilder();\\n        Queue<Integer>A[]=new LinkedList[10];\\n        for(int i=0;i<10;i++)A[i]=new LinkedList<>();\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            A[c-\\'0\\'].add(i);\\n        }\\n        \\n        while(k>0){\\n            int i=Integer.MAX_VALUE;\\n            for(int j=0;j<10;j++){\\n                if(A[j].size()==0)continue;\\n                i=Math.min(i,A[j].peek());\\n            }\\n            if(i==Integer.MAX_VALUE)break;\\n            char cur=s.charAt(i);\\n            boolean found=false;\\n            for(int j=0;j<10;j++){\\n                char next=(char)(j+\\'0\\');\\n                if(next>=cur)break;\\n                if(A[j].size()==0)continue;//nothing can take out\\n                int index=A[j].peek();\\n                int cnt=seg.query(i+1,index);\\n                if(cnt<=k){//smallest\\n                    found=true;\\n                    A[j].poll();\\n                    k-=cnt;\\n                    str.append(next);\\n                    seg.update(index);\\n                    break;\\n                }\\n            }\\n            if(!found){\\n                A[cur-\\'0\\'].poll();\\n                str.append(\"\"+cur);\\n            }\\n        }\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            if(A[c-\\'0\\'].size()==0)continue;\\n            if(A[c-\\'0\\'].peek()!=i)continue;\\n            str.append(\"\"+c);A[c-\\'0\\'].poll();\\n        }\\n        return str.toString();\\n    }\\n    \\n    class Seg{\\n        int l,r;\\n        Seg left,right;\\n        int cnt;\\n        public Seg(int l,int r){\\n            this.l=l;this.r=r;\\n            if(l!=r){\\n                int mid=l+(r-l)/2;\\n                left=new Seg(l,mid);\\n                right=new Seg(mid+1,r);\\n                cnt=(r-l)+1;\\n            }else{\\n                cnt=1;\\n            }\\n            \\n        }\\n        \\n        public int query(int s,int e){\\n            if(l==s&&e==r){\\n                return cnt;\\n            }\\n            int mid=l+(r-l)/2;\\n            int res=0;\\n            if(e<=mid){\\n                res+=left.query(s,e);\\n            }\\n            else if(s>=mid+1){\\n                res+=right.query(s,e);\\n            }else{\\n                res+=left.query(s,mid)+right.query(mid+1,e);\\n            }\\n            return res;\\n            \\n        }\\n        \\n        public void update(int index){\\n            this.cnt--;\\n            if(l==r&&l==index){\\n                return;\\n            }\\n            int mid=l+(r-l)/2;\\n            if(index<=mid){\\n                left.update(index);\\n            }else{\\n                right.update(index);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minInteger(String s, int k) {\\n        int arr[]=new int[s.length()];\\n        Arrays.fill(arr,1);\\n        Fenwick fe=new Fenwick(arr);\\n        StringBuilder res=new StringBuilder();\\n        Queue<Integer>q[]=new LinkedList[10];\\n        for(int i=0;i<q.length;i++){\\n            q[i]=new LinkedList<>();\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            q[c-\\'0\\'].add(i);\\n        }\\n        \\n        \\n        \\n        while(k>0){\\n            boolean good=false;\\n            for(int i=0;i<10;i++){\\n                if(q[i].size()==0)continue;\\n                \\n                int index=q[i].peek();\\n                int less=fe.sumRange(0,index-1);//how many elements remain less than it \\n                if(k>=less){\\n                    good=true;\\n                    q[i].poll();\\n                    k-=less;\\n                    res.append(i+\"\");\\n                    fe.update(index,-1);\\n                    break;\\n                }\\n            }\\n            \\n            if(!good)break;\\n        }\\n        \\n        \\n        \\n        \\n        \\n        \\n        List<int[]>A=new ArrayList<>();\\n        for(int i=0;i<q.length;i++){\\n           while(q[i].size()>0){\\n               A.add(new int[]{i,q[i].poll()});\\n           }\\n        }\\n        \\n        Collections.sort(A,(a,b)->{\\n            return a[1]-b[1];\\n        });\\n        \\n        for(int i=0;i<A.size();i++){\\n            res.append(A.get(i)[0]+\"\");\\n        }\\n        \\n        return res.toString();\\n    }\\n    \\n    \\n    class Fenwick {\\n        int tree[];//1-index based\\n        int A[];\\n        int arr[];\\n        public Fenwick(int[] A) {\\n            this.A=A;\\n            arr=new int[A.length];\\n            tree=new int[A.length+1];\\n            int sum=0;\\n            for(int i=0;i<A.length;i++){\\n                update(i,A[i]);\\n            }\\n        }\\n\\n        public void update(int i, int val) {\\n            arr[i]+=val;\\n            i++;\\n            while(i<tree.length){\\n                tree[i]+=val;\\n                i+=(i&-i);\\n            }\\n            \\n        }\\n\\n        public int sumRange(int i, int j) {\\n            \\n            return pre(j+1)-pre(i);\\n        }\\n\\n        public int pre(int i){\\n            int sum=0;\\n            while(i>0){\\n                sum+=tree[i];\\n                i-=(i&-i);\\n            }\\n            return sum;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String minInteger(String s, int k) {\\n        char A[]=s.toCharArray();\\n        for(int i=0;i<A.length;i++){\\n            char min=A[i];\\n            int j=i+1;\\n            int copyk=k;\\n            int index=-1;\\n            while(copyk>0&&j<A.length){\\n                if(A[j]<min){\\n                    min=A[j];\\n                    index=j;\\n                }\\n                copyk--;j++;\\n            }\\n            if(index==-1||min==A[i])continue;\\n            for(j=index;j>i;j--){\\n                swap(A,j,j-1);\\n            }\\n            k-=(index-i);\\n            if(k==0)break;\\n        }\\n        StringBuilder str=new StringBuilder();\\n        for(char c:A)str.append(c+\"\");\\n        return str.toString();\\n    }\\n    \\n    public void swap(char A[],int i,int j){\\n        char temp=A[i];\\n        A[i]=A[j];\\n        A[j]=temp;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String minInteger(String s, int k) {\\n        Seg seg=new Seg(0,s.length()-1);\\n        StringBuilder str=new StringBuilder();\\n        Queue<Integer>A[]=new LinkedList[10];\\n        for(int i=0;i<10;i++)A[i]=new LinkedList<>();\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            A[c-\\'0\\'].add(i);\\n        }\\n        \\n        while(k>0){\\n            int i=Integer.MAX_VALUE;\\n            for(int j=0;j<10;j++){\\n                if(A[j].size()==0)continue;\\n                i=Math.min(i,A[j].peek());\\n            }\\n            if(i==Integer.MAX_VALUE)break;\\n            char cur=s.charAt(i);\\n            boolean found=false;\\n            for(int j=0;j<10;j++){\\n                char next=(char)(j+\\'0\\');\\n                if(next>=cur)break;\\n                if(A[j].size()==0)continue;//nothing can take out\\n                int index=A[j].peek();\\n                int cnt=seg.query(i+1,index);\\n                if(cnt<=k){//smallest\\n                    found=true;\\n                    A[j].poll();\\n                    k-=cnt;\\n                    str.append(next);\\n                    seg.update(index);\\n                    break;\\n                }\\n            }\\n            if(!found){\\n                A[cur-\\'0\\'].poll();\\n                str.append(\"\"+cur);\\n            }\\n        }\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            if(A[c-\\'0\\'].size()==0)continue;\\n            if(A[c-\\'0\\'].peek()!=i)continue;\\n            str.append(\"\"+c);A[c-\\'0\\'].poll();\\n        }\\n        return str.toString();\\n    }\\n    \\n    class Seg{\\n        int l,r;\\n        Seg left,right;\\n        int cnt;\\n        public Seg(int l,int r){\\n            this.l=l;this.r=r;\\n            if(l!=r){\\n                int mid=l+(r-l)/2;\\n                left=new Seg(l,mid);\\n                right=new Seg(mid+1,r);\\n                cnt=(r-l)+1;\\n            }else{\\n                cnt=1;\\n            }\\n            \\n        }\\n        \\n        public int query(int s,int e){\\n            if(l==s&&e==r){\\n                return cnt;\\n            }\\n            int mid=l+(r-l)/2;\\n            int res=0;\\n            if(e<=mid){\\n                res+=left.query(s,e);\\n            }\\n            else if(s>=mid+1){\\n                res+=right.query(s,e);\\n            }else{\\n                res+=left.query(s,mid)+right.query(mid+1,e);\\n            }\\n            return res;\\n            \\n        }\\n        \\n        public void update(int index){\\n            this.cnt--;\\n            if(l==r&&l==index){\\n                return;\\n            }\\n            int mid=l+(r-l)/2;\\n            if(index<=mid){\\n                left.update(index);\\n            }else{\\n                right.update(index);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720656,
                "title": "python-segmenttree-o-nlogn",
                "content": "```python\\n\\n\\nclass Node:\\n    def __init__(self, left, right, l, r, val, cnt, idx):\\n        self.left = left\\n        self.right = right\\n        self.l = l\\n        self.r = r\\n        self.val = val\\n        self.cnt = cnt\\n        self.idx = idx\\nNONE_NODE = Node(None, None, -1, -1, float(\\'inf\\'), 0, -1)\\nclass SegmentTree:\\n    def __init__(self, nums):\\n        self.head = self.build(nums, 0, len(nums)-1) \\n    \\n    def build(self, nums, l, r):\\n        if l == r:\\n            return Node(None, None, l, r, nums[l], 1, l)\\n        mid = (l+r)//2\\n        left = self.build(nums, l, mid)\\n        right = self.build(nums, mid+1, r)\\n        return Node(left, right, l, r, min(left.val, right.val), left.cnt+right.cnt, left.idx if left.val <= right.val else right.idx)\\n    def remove(self, u, node):\\n        if node == None or u == node.l == node.r:\\n            return None\\n        if node.r < u or u < node.l:\\n            return node\\n        \\n        node.left = left = self.remove(u, node.left)\\n        node.right = right = self.remove(u, node.right)\\n        if left == None:\\n            left = NONE_NODE\\n        if right == None:\\n            right = NONE_NODE\\n        node.val = min(left.val, right.val)\\n        node.cnt = left.cnt + right.cnt\\n        node.idx = left.idx if left.val <= right.val else right.idx\\n        return node\\n    def query(self, k, node):\\n        \\n        if k <= 0 or node == None:\\n            return (float(\\'inf\\'), -1)\\n        if node.cnt <= k:\\n            return (node.val, node.idx)\\n        if node.left != None:\\n            return min(self.query(k, node.left), self.query(k-node.left.cnt, node.right))\\n        return self.query(k, node.right)\\n    def get_nth(self, u, node):\\n        if node == None or node.l == node.r == u:\\n            return 0\\n        if node.left == None:\\n            return self.get_nth(u, node.right)\\n        if node.left.l <= u <= node.left.r:\\n            return self.get_nth(u, node.left)\\n        return node.left.cnt + self.get_nth(u, node.right)\\n        \\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        nums = [int(c) for c in num]\\n        used = set()\\n        ans = []\\n        segmentTree = SegmentTree(nums)\\n        while len(ans) < len(num) and k > 0:\\n            val, idx = segmentTree.query(k+1, segmentTree.head)\\n            \\n            used.add(idx)\\n            ans.append(str(val))\\n            k -= segmentTree.get_nth(idx, segmentTree.head)\\n            \\n            segmentTree.remove(idx, segmentTree.head)\\n        for idx, val in enumerate(nums):\\n            if idx not in used:\\n                ans.append(str(val))\\n        return \"\".join(ans)\\n```\\n",
                "solutionTags": [],
                "code": "```python\\n\\n\\nclass Node:\\n    def __init__(self, left, right, l, r, val, cnt, idx):\\n        self.left = left\\n        self.right = right\\n        self.l = l\\n        self.r = r\\n        self.val = val\\n        self.cnt = cnt\\n        self.idx = idx\\nNONE_NODE = Node(None, None, -1, -1, float(\\'inf\\'), 0, -1)\\nclass SegmentTree:\\n    def __init__(self, nums):\\n        self.head = self.build(nums, 0, len(nums)-1) \\n    \\n    def build(self, nums, l, r):\\n        if l == r:\\n            return Node(None, None, l, r, nums[l], 1, l)\\n        mid = (l+r)//2\\n        left = self.build(nums, l, mid)\\n        right = self.build(nums, mid+1, r)\\n        return Node(left, right, l, r, min(left.val, right.val), left.cnt+right.cnt, left.idx if left.val <= right.val else right.idx)\\n    def remove(self, u, node):\\n        if node == None or u == node.l == node.r:\\n            return None\\n        if node.r < u or u < node.l:\\n            return node\\n        \\n        node.left = left = self.remove(u, node.left)\\n        node.right = right = self.remove(u, node.right)\\n        if left == None:\\n            left = NONE_NODE\\n        if right == None:\\n            right = NONE_NODE\\n        node.val = min(left.val, right.val)\\n        node.cnt = left.cnt + right.cnt\\n        node.idx = left.idx if left.val <= right.val else right.idx\\n        return node\\n    def query(self, k, node):\\n        \\n        if k <= 0 or node == None:\\n            return (float(\\'inf\\'), -1)\\n        if node.cnt <= k:\\n            return (node.val, node.idx)\\n        if node.left != None:\\n            return min(self.query(k, node.left), self.query(k-node.left.cnt, node.right))\\n        return self.query(k, node.right)\\n    def get_nth(self, u, node):\\n        if node == None or node.l == node.r == u:\\n            return 0\\n        if node.left == None:\\n            return self.get_nth(u, node.right)\\n        if node.left.l <= u <= node.left.r:\\n            return self.get_nth(u, node.left)\\n        return node.left.cnt + self.get_nth(u, node.right)\\n        \\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        nums = [int(c) for c in num]\\n        used = set()\\n        ans = []\\n        segmentTree = SegmentTree(nums)\\n        while len(ans) < len(num) and k > 0:\\n            val, idx = segmentTree.query(k+1, segmentTree.head)\\n            \\n            used.add(idx)\\n            ans.append(str(val))\\n            k -= segmentTree.get_nth(idx, segmentTree.head)\\n            \\n            segmentTree.remove(idx, segmentTree.head)\\n        for idx, val in enumerate(nums):\\n            if idx not in used:\\n                ans.append(str(val))\\n        return \"\".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720646,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\n    vector<int> v;\\n    \\n    int lowbit(int x) {\\n        return x & (-x);\\n    }\\n    \\n    void update(int x, int y) {\\n        for (int i = x; i < v.size(); i += lowbit(i)) {\\n            v[i] += y;\\n        }\\n    }\\n    \\n    int get(int x) {\\n        int r = 0;\\n        for (int i = x; i; i ^= lowbit(i)) {\\n            r += v[i];\\n        }\\n        return r;\\n    }\\n    \\npublic:\\n    string minInteger(string num, int k) {\\n        const int n = num.length();\\n        v.resize(n + 1);\\n        vector<list<int>> d(10);\\n        for (int i = 0; i < n; ++i) {\\n            update(i + 1, 1);\\n            d[num[i] - \\'0\\'].push_back(i);\\n        }\\n        string r(n, \\' \\');\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < 10; ++j) {\\n                if (!d[j].empty()) {\\n                    const int x = get(*d[j].begin());\\n                    if (x <= k) {\\n                        k -= x;\\n                        r[i] = j + \\'0\\';\\n                        update(1 + *d[j].begin(), -1); \\n                        d[j].pop_front();\\n                        break;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> v;\\n    \\n    int lowbit(int x) {\\n        return x & (-x);\\n    }\\n    \\n    void update(int x, int y) {\\n        for (int i = x; i < v.size(); i += lowbit(i)) {\\n            v[i] += y;\\n        }\\n    }\\n    \\n    int get(int x) {\\n        int r = 0;\\n        for (int i = x; i; i ^= lowbit(i)) {\\n            r += v[i];\\n        }\\n        return r;\\n    }\\n    \\npublic:\\n    string minInteger(string num, int k) {\\n        const int n = num.length();\\n        v.resize(n + 1);\\n        vector<list<int>> d(10);\\n        for (int i = 0; i < n; ++i) {\\n            update(i + 1, 1);\\n            d[num[i] - \\'0\\'].push_back(i);\\n        }\\n        string r(n, \\' \\');\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < 10; ++j) {\\n                if (!d[j].empty()) {\\n                    const int x = get(*d[j].begin());\\n                    if (x <= k) {\\n                        k -= x;\\n                        r[i] = j + \\'0\\';\\n                        update(1 + *d[j].begin(), -1); \\n                        d[j].pop_front();\\n                        break;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720501,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n        if(k == 0)\\n            return num;\\n        int t;\\n        string ans = \"\";\\n        int cur[30010] = {0};\\n        for(t = 0; t < 10; t++){\\n            cur[0] = 0;\\n            int ind = 0;\\n            for(int i = 0; i < num.size(); i++){\\n                if(i > 0)\\n                    cur[i] = cur[i-1];\\n                if(num[i] == t+\\'0\\'){\\n                    if(i - cur[i] <= k){\\n                        ans += t+\\'0\\';\\n                        k -= i - cur[i];\\n                        cur[i]++;\\n                        ind = i+1;\\n                    }\\n                    else{\\n                        ind = i;\\n                        break;\\n                    }\\n                }\\n                if(k == 0)\\n                    break;\\n            }\\n            string tmp = \"\";\\n            for(int i = 0; i < ind; i++)\\n                if(num[i] != t + \\'0\\')\\n                    tmp += num[i];\\n            int l = tmp.size();\\n            for(int i = ind; i < num.size(); i++)\\n                tmp += num[i];\\n            num = tmp;\\n            if(k == 0)\\n                return ans + num;\\n            ind = -1;\\n            for(int i = l; i < num.size(); i++)\\n                if(num[i] == t + \\'0\\'){\\n                    ind = i;\\n                    break;\\n                }\\n            if(ind > 1){\\n                bool rise = true;\\n                for(int i = 1; i < ind - k; i++)\\n                    if(num[i] < num[i-1]){\\n                        rise = false;\\n                        break;\\n                    }\\n                for(int i = 0; i < k; i++){\\n                    if(num[ind-k-1] > num[ind-k+i]){\\n                        rise = false;\\n                        break;\\n                    }\\n                }\\n                if(rise){\\n                    for(int i = 0; i < k; i++){\\n                        char cc = num[ind-i];\\n                        num[ind-i] = num[ind-i-1];\\n                        num[ind-i-1] = cc;\\n                    }\\n                    return ans + num;\\n                }\\n            }\\n            if(k == 0){\\n                ans += num;\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n        if(k == 0)\\n            return num;\\n        int t;\\n        string ans = \"\";\\n        int cur[30010] = {0};\\n        for(t = 0; t < 10; t++){\\n            cur[0] = 0;\\n            int ind = 0;\\n            for(int i = 0; i < num.size(); i++){\\n                if(i > 0)\\n                    cur[i] = cur[i-1];\\n                if(num[i] == t+\\'0\\'){\\n                    if(i - cur[i] <= k){\\n                        ans += t+\\'0\\';\\n                        k -= i - cur[i];\\n                        cur[i]++;\\n                        ind = i+1;\\n                    }\\n                    else{\\n                        ind = i;\\n                        break;\\n                    }\\n                }\\n                if(k == 0)\\n                    break;\\n            }\\n            string tmp = \"\";\\n            for(int i = 0; i < ind; i++)\\n                if(num[i] != t + \\'0\\')\\n                    tmp += num[i];\\n            int l = tmp.size();\\n            for(int i = ind; i < num.size(); i++)\\n                tmp += num[i];\\n            num = tmp;\\n            if(k == 0)\\n                return ans + num;\\n            ind = -1;\\n            for(int i = l; i < num.size(); i++)\\n                if(num[i] == t + \\'0\\'){\\n                    ind = i;\\n                    break;\\n                }\\n            if(ind > 1){\\n                bool rise = true;\\n                for(int i = 1; i < ind - k; i++)\\n                    if(num[i] < num[i-1]){\\n                        rise = false;\\n                        break;\\n                    }\\n                for(int i = 0; i < k; i++){\\n                    if(num[ind-k-1] > num[ind-k+i]){\\n                        rise = false;\\n                        break;\\n                    }\\n                }\\n                if(rise){\\n                    for(int i = 0; i < k; i++){\\n                        char cc = num[ind-i];\\n                        num[ind-i] = num[ind-i-1];\\n                        num[ind-i-1] = cc;\\n                    }\\n                    return ans + num;\\n                }\\n            }\\n            if(k == 0){\\n                ans += num;\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720463,
                "title": "find-min-in-next-k-items-and-swap-o-n2",
                "content": "```\\n fun minInteger(num: String, k: Int): String {\\n        val arr = num.toCharArray()\\n        helper(arr, 0, k)\\n        return arr.joinToString(\"\")\\n    }\\n    \\n    fun helper(arr: CharArray, index: Int, k: Int) {\\n        var count = k        \\n        for(index in 0 until arr.size) {\\n\\t\\t    // Get the min value out of an arr from index + 1 to min(remaining k, arr.size)\\n            var minIndex = index\\n            for(i in index + 1 until Math.min(arr.size, index + count + 1)) {\\n                if(arr[i] < arr[minIndex]) {\\n                    minIndex = i\\n                }\\n            }\\n\\t\\t\\t// After finiding minimum value adjust items\\n            val temp = arr[minIndex]\\n            for(j in minIndex downTo index + 1) {\\n                arr[j] = arr[j - 1]\\n            }\\n            arr[index] = temp\\n\\t\\t\\t// reduce count by number of used for above operation.\\n            count -= (minIndex - index)\\n        }\\n    }",
                "solutionTags": [],
                "code": "```\\n fun minInteger(num: String, k: Int): String {\\n        val arr = num.toCharArray()\\n        helper(arr, 0, k)\\n        return arr.joinToString(\"\")\\n    }\\n    \\n    fun helper(arr: CharArray, index: Int, k: Int) {\\n        var count = k        \\n        for(index in 0 until arr.size) {\\n\\t\\t    // Get the min value out of an arr from index + 1 to min(remaining k, arr.size)\\n            var minIndex = index\\n            for(i in index + 1 until Math.min(arr.size, index + count + 1)) {\\n                if(arr[i] < arr[minIndex]) {\\n                    minIndex = i\\n                }\\n            }\\n\\t\\t\\t// After finiding minimum value adjust items\\n            val temp = arr[minIndex]\\n            for(j in minIndex downTo index + 1) {\\n                arr[j] = arr[j - 1]\\n            }\\n            arr[index] = temp\\n\\t\\t\\t// reduce count by number of used for above operation.\\n            count -= (minIndex - index)\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 720462,
                "title": "c-greedy-solution-fenwick-tree-for-keep-shifts-sorted-set-for-min-char-linkedlist",
                "content": "```\\n   public class Solution\\n    {\\n        private struct Data : IComparable<Data>, IEquatable<Data>\\n        {\\n            public readonly char C;\\n            public readonly int Pos;\\n\\n            public Data(char c, int pos)\\n            {\\n                C = c;\\n                Pos = pos;\\n            }\\n\\n            public int CompareTo(Data other)\\n            {\\n                var cmp = C.CompareTo(other.C);\\n                if (cmp != 0)\\n                {\\n                    return cmp;\\n                }\\n\\n                return Pos.CompareTo(other.Pos);\\n            }\\n\\n            public override string ToString()\\n            {\\n                return $\"C: {C}; Pos: {Pos}\";\\n            }\\n\\n            public override bool Equals(object obj)\\n            {\\n                return Equals((Data)obj);\\n            }\\n\\n            public override int GetHashCode()\\n            {\\n                unchecked\\n                {\\n                    return C * 117 + Pos;\\n                }\\n            }\\n\\n            int IComparable<Data>.CompareTo(Data other)\\n            {\\n                return CompareTo(other);\\n            }\\n\\n            public bool Equals(Data other)\\n            {\\n                return C == other.C && Pos == other.Pos;\\n            }\\n        }\\n\\n        private class Fenwick\\n        {\\n            private const int CHUNK_SIZE = 256;\\n\\n            private class Node\\n            {\\n                public readonly int Min;\\n                public readonly int Max;\\n\\n                public Node(int min, int max)\\n                {\\n                    Min = min;\\n                    Max = max;\\n                }\\n\\n                public Node Left;\\n                public Node Right;\\n                public bool IsLeaf => Left == null && Right == null;\\n                public long Sum;\\n            }\\n\\n            private readonly Node _root;\\n\\n            public Fenwick(int min, int max, int[] input)\\n            {\\n                _root = new Node(min, max);\\n                Build(_root, input);\\n            }\\n\\n            private void Build(Node node, int[] input)\\n            {\\n                int chunk = node.Max - node.Min + 1;\\n                int chunksCount = Convert.ToInt32(Math.Ceiling((double)chunk / CHUNK_SIZE));\\n\\n                if (chunksCount <= 1)\\n                {\\n                    checked\\n                    {\\n                        long sum = 0;\\n\\n                        for (int i = node.Min; i <= node.Max; i++)\\n                        {\\n                            sum += input[i];\\n                        }\\n\\n                        node.Sum = sum;\\n                    }\\n\\n                    return;\\n                }\\n\\n                int leftChunksCount = chunksCount / 2;\\n\\n                node.Left = new Node(node.Min, node.Min + leftChunksCount * CHUNK_SIZE - 1);\\n                node.Right = new Node(node.Min + leftChunksCount * CHUNK_SIZE, node.Max);\\n\\n                Build(node.Left, input);\\n                Build(node.Right, input);\\n\\n                node.Sum = node.Left.Sum + node.Right.Sum;\\n            }\\n\\n            private void Update(Node node, int i, int val, int[] data)\\n            {\\n                if (node == null || i < node.Min || i > node.Max)\\n                {\\n                    return;\\n                }\\n\\n                var diff = val - data[i];\\n                node.Sum += diff;\\n\\n                if (!node.IsLeaf)\\n                {\\n                    Update(node.Left, i, diff, data);\\n                    Update(node.Right, i, diff, data);\\n                }\\n                else\\n                {\\n                    data[i] = val;\\n                }\\n            }\\n\\n            public void Update(int i, int val, int[] data)\\n            {\\n                Update(_root, i, val, data);\\n            }\\n\\n            private long SumRange(Node node, int from, int to, int[] data)\\n            {\\n                if (node == null || from > node.Max || to < node.Min)\\n                {\\n                    return 0;\\n                }\\n\\n                if (node.Min == from && node.Max == to)\\n                {\\n                    return node.Sum;\\n                }\\n\\n                if (node.IsLeaf)\\n                {\\n                    int start = Math.Max(node.Min, from);\\n                    int end = Math.Min(node.Max, to);\\n                    long res = 0;\\n                    for (int i = start; i <= end; i++)\\n                    {\\n                        res += data[i];\\n                    }\\n\\n                    return res;\\n                }\\n\\n                return SumRange(node.Left, Math.Max(node.Left.Min, from), Math.Min(node.Left.Max, to), data)\\n                       + SumRange(node.Right, Math.Max(node.Right.Min, from), Math.Min(node.Right.Max, to), data);\\n            }\\n\\n            public long SumRange(int from, int to, int[] data)\\n            {\\n                return SumRange(_root, from, to, data);\\n            }\\n        }\\n\\n\\n        public string MinInteger(string num, int k)\\n        {\\n            int[] shifts = new int[num.Length];\\n            Fenwick f = new Fenwick(0, num.Length - 1, shifts);\\n            StringBuilder res = new StringBuilder(num.Length);\\n            SortedSet<Data> set = new SortedSet<Data>();\\n            LinkedList<Data> ll = new LinkedList<Data>();\\n            IDictionary<Data, LinkedListNode<Data>> map = new Dictionary<Data, LinkedListNode<Data>>();\\n\\n            for (int i = 0; i < num.Length; i++)\\n            {\\n                var d = new Data(num[i], i);\\n                ll.AddLast(d);\\n                map[d] = ll.Last;\\n            }\\n\\n            LinkedListNode<Data> last = ll.First;\\n\\n            for (int i = 0; i < num.Length; i++)\\n            {\\n                //try attach all possible chars for next step\\n                while (true)\\n                {\\n                    if (set.Count == k + 1)\\n                    {\\n                        break;\\n                    }\\n\\n                    set.Add(last.Value);\\n                    if (last.Next == null)\\n                    {\\n                        break;\\n                    }\\n\\n                    last = last.Next;\\n                }\\n\\n                var top = set.First();\\n\\n\\n                //here we should need to know the index of selected item\\n\\t\\t\\t\\t//shifted = count of removed precedessors of selected items in LinkedList\\n                var shifted = (int) f.SumRange(0, top.Pos, shifts);\\n                k -= top.Pos + shifted;\\n                f.Update(top.Pos, -1, shifts);\\n\\n                res.Append(top.C);\\n\\n                if (last == map[top])\\n                {\\n                    last = map[top].Previous;\\n                    if (last == null)\\n                    {\\n                        last = map[top].Next;\\n                    }\\n                }\\n\\n                ll.Remove(map[top]);\\n                set.Remove(top);\\n                map.Remove(top);\\n\\n\\n                //remove items that can not to be used as next char\\n                while (set.Count > k + 1 && last != null)\\n                {\\n                    set.Remove(last.Value);\\n                    last = last.Previous;\\n                }\\n            }\\n\\n            return res.ToString();\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   public class Solution\\n    {\\n        private struct Data : IComparable<Data>, IEquatable<Data>\\n        {\\n            public readonly char C;\\n            public readonly int Pos;\\n\\n            public Data(char c, int pos)\\n            {\\n                C = c;\\n                Pos = pos;\\n            }\\n\\n            public int CompareTo(Data other)\\n            {\\n                var cmp = C.CompareTo(other.C);\\n                if (cmp != 0)\\n                {\\n                    return cmp;\\n                }\\n\\n                return Pos.CompareTo(other.Pos);\\n            }\\n\\n            public override string ToString()\\n            {\\n                return $\"C: {C}; Pos: {Pos}\";\\n            }\\n\\n            public override bool Equals(object obj)\\n            {\\n                return Equals((Data)obj);\\n            }\\n\\n            public override int GetHashCode()\\n            {\\n                unchecked\\n                {\\n                    return C * 117 + Pos;\\n                }\\n            }\\n\\n            int IComparable<Data>.CompareTo(Data other)\\n            {\\n                return CompareTo(other);\\n            }\\n\\n            public bool Equals(Data other)\\n            {\\n                return C == other.C && Pos == other.Pos;\\n            }\\n        }\\n\\n        private class Fenwick\\n        {\\n            private const int CHUNK_SIZE = 256;\\n\\n            private class Node\\n            {\\n                public readonly int Min;\\n                public readonly int Max;\\n\\n                public Node(int min, int max)\\n                {\\n                    Min = min;\\n                    Max = max;\\n                }\\n\\n                public Node Left;\\n                public Node Right;\\n                public bool IsLeaf => Left == null && Right == null;\\n                public long Sum;\\n            }\\n\\n            private readonly Node _root;\\n\\n            public Fenwick(int min, int max, int[] input)\\n            {\\n                _root = new Node(min, max);\\n                Build(_root, input);\\n            }\\n\\n            private void Build(Node node, int[] input)\\n            {\\n                int chunk = node.Max - node.Min + 1;\\n                int chunksCount = Convert.ToInt32(Math.Ceiling((double)chunk / CHUNK_SIZE));\\n\\n                if (chunksCount <= 1)\\n                {\\n                    checked\\n                    {\\n                        long sum = 0;\\n\\n                        for (int i = node.Min; i <= node.Max; i++)\\n                        {\\n                            sum += input[i];\\n                        }\\n\\n                        node.Sum = sum;\\n                    }\\n\\n                    return;\\n                }\\n\\n                int leftChunksCount = chunksCount / 2;\\n\\n                node.Left = new Node(node.Min, node.Min + leftChunksCount * CHUNK_SIZE - 1);\\n                node.Right = new Node(node.Min + leftChunksCount * CHUNK_SIZE, node.Max);\\n\\n                Build(node.Left, input);\\n                Build(node.Right, input);\\n\\n                node.Sum = node.Left.Sum + node.Right.Sum;\\n            }\\n\\n            private void Update(Node node, int i, int val, int[] data)\\n            {\\n                if (node == null || i < node.Min || i > node.Max)\\n                {\\n                    return;\\n                }\\n\\n                var diff = val - data[i];\\n                node.Sum += diff;\\n\\n                if (!node.IsLeaf)\\n                {\\n                    Update(node.Left, i, diff, data);\\n                    Update(node.Right, i, diff, data);\\n                }\\n                else\\n                {\\n                    data[i] = val;\\n                }\\n            }\\n\\n            public void Update(int i, int val, int[] data)\\n            {\\n                Update(_root, i, val, data);\\n            }\\n\\n            private long SumRange(Node node, int from, int to, int[] data)\\n            {\\n                if (node == null || from > node.Max || to < node.Min)\\n                {\\n                    return 0;\\n                }\\n\\n                if (node.Min == from && node.Max == to)\\n                {\\n                    return node.Sum;\\n                }\\n\\n                if (node.IsLeaf)\\n                {\\n                    int start = Math.Max(node.Min, from);\\n                    int end = Math.Min(node.Max, to);\\n                    long res = 0;\\n                    for (int i = start; i <= end; i++)\\n                    {\\n                        res += data[i];\\n                    }\\n\\n                    return res;\\n                }\\n\\n                return SumRange(node.Left, Math.Max(node.Left.Min, from), Math.Min(node.Left.Max, to), data)\\n                       + SumRange(node.Right, Math.Max(node.Right.Min, from), Math.Min(node.Right.Max, to), data);\\n            }\\n\\n            public long SumRange(int from, int to, int[] data)\\n            {\\n                return SumRange(_root, from, to, data);\\n            }\\n        }\\n\\n\\n        public string MinInteger(string num, int k)\\n        {\\n            int[] shifts = new int[num.Length];\\n            Fenwick f = new Fenwick(0, num.Length - 1, shifts);\\n            StringBuilder res = new StringBuilder(num.Length);\\n            SortedSet<Data> set = new SortedSet<Data>();\\n            LinkedList<Data> ll = new LinkedList<Data>();\\n            IDictionary<Data, LinkedListNode<Data>> map = new Dictionary<Data, LinkedListNode<Data>>();\\n\\n            for (int i = 0; i < num.Length; i++)\\n            {\\n                var d = new Data(num[i], i);\\n                ll.AddLast(d);\\n                map[d] = ll.Last;\\n            }\\n\\n            LinkedListNode<Data> last = ll.First;\\n\\n            for (int i = 0; i < num.Length; i++)\\n            {\\n                //try attach all possible chars for next step\\n                while (true)\\n                {\\n                    if (set.Count == k + 1)\\n                    {\\n                        break;\\n                    }\\n\\n                    set.Add(last.Value);\\n                    if (last.Next == null)\\n                    {\\n                        break;\\n                    }\\n\\n                    last = last.Next;\\n                }\\n\\n                var top = set.First();\\n\\n\\n                //here we should need to know the index of selected item\\n\\t\\t\\t\\t//shifted = count of removed precedessors of selected items in LinkedList\\n                var shifted = (int) f.SumRange(0, top.Pos, shifts);\\n                k -= top.Pos + shifted;\\n                f.Update(top.Pos, -1, shifts);\\n\\n                res.Append(top.C);\\n\\n                if (last == map[top])\\n                {\\n                    last = map[top].Previous;\\n                    if (last == null)\\n                    {\\n                        last = map[top].Next;\\n                    }\\n                }\\n\\n                ll.Remove(map[top]);\\n                set.Remove(top);\\n                map.Remove(top);\\n\\n\\n                //remove items that can not to be used as next char\\n                while (set.Count > k + 1 && last != null)\\n                {\\n                    set.Remove(last.Value);\\n                    last = last.Previous;\\n                }\\n            }\\n\\n            return res.ToString();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720449,
                "title": "c-solution-with-no-extra-space-easy-understanding",
                "content": "From num[0], every time try to make num[i] the smallest, or move to next char;\\n```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        for (int i = 0; i < num.size() - 1; i++) {\\n            char min = \\'0\\';\\n            int position;\\n            while (min <= \\'9\\') {\\n                position = num.find(min, i);\\n                if (position != num.npos) {\\n                    if (min == \\'9\\') break;\\n                    if (num[i] == min) break;\\n                    if (position - i <= k) {\\n                        num.erase(position, 1);\\n                        num.insert(i, 1, min);\\n                        k -= position - i;\\n                        break;\\n                    }\\n                }\\n                min += 1;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        for (int i = 0; i < num.size() - 1; i++) {\\n            char min = \\'0\\';\\n            int position;\\n            while (min <= \\'9\\') {\\n                position = num.find(min, i);\\n                if (position != num.npos) {\\n                    if (min == \\'9\\') break;\\n                    if (num[i] == min) break;\\n                    if (position - i <= k) {\\n                        num.erase(position, 1);\\n                        num.insert(i, 1, min);\\n                        k -= position - i;\\n                        break;\\n                    }\\n                }\\n                min += 1;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720448,
                "title": "java-binary-indexed-tree-o-nlogn-17ms",
                "content": "idea : Every turn we find the smallest number that we can move to the head of the left string, it will make the answer  minimum. We can calculate how many characters  in the left string before the most left index of current number, if it is less than or equal to k, then we can move a current number of most left index to the head of the left string.Using data struct like BIT or segment Tree will solve this problem.\\n```\\nclass Solution {\\n    int[] C;\\n    int lowbit(int x) {\\n        return x & (-x);\\n    }\\n    void add(int x, int k) {\\n        while(k < C.length) {\\n            C[k] += x;\\n            k += lowbit(k);\\n        }\\n    }\\n    int getSum(int r) {\\n        int res = 0;\\n        while(r > 0) {\\n            res += C[r];\\n            r ^= lowbit(r);\\n        }\\n        return res;\\n    }\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        C = new int [n + 1];\\n        for(int i = 1; i < C.length; ++i) add(1,i);\\n        StringBuilder ans = new StringBuilder();\\n        ArrayList<Integer>[] arr = new ArrayList[10];\\n        for(int i = 0; i < num.length(); i++) {\\n            int x = num.charAt(i) - \\'0\\';\\n            if(arr[x] == null) arr[x] = new ArrayList<>();\\n            arr[x].add(i + 1);\\n        }\\n        int[] pos = new int[10];\\n        for(int i = 0; i < n; i++ ){\\n            for(int j = 0; j <= 9; j++) {\\n                if(arr[j] == null || pos[j] >= arr[j].size()) continue;\\n                int top = arr[j].get(pos[j]);\\n                int p = getSum(top - 1);\\n                if(p <= k) {\\n                    ans.append((char)(\\'0\\' + j));\\n                    k -= p;\\n                    add(-1,top);\\n                    pos[j]++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int[] C;\\n    int lowbit(int x) {\\n        return x & (-x);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 720395,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public string MinInteger(string num, int k) \\n    {\\n        int start = 0, n = num.Length;\\n        var charArray = num.ToCharArray();\\n        if(k >=(n * (n - 1))/ 2)\\n        {\\n            Array.Sort(charArray);\\n            return new string(charArray);\\n        }\\n        \\n        while(start < charArray.Length)\\n        {\\n            int minIndex = start;\\n            int length = Math.Min(k, charArray.Length - start - 1);\\n            for(int len = length; len > 0; len--)\\n            {\\n                if(charArray[start + len] <= charArray[minIndex])\\n                    minIndex = start + len;\\n            }\\n                \\n            char val = charArray[minIndex];\\n            if(charArray[minIndex] != charArray[start])\\n            {\\n                for(int i = minIndex; i > start; i--)\\n                {\\n                    charArray[i] = charArray[i - 1];\\n                    k--;\\n                }\\n            }\\n            \\n            charArray[start] = val;\\n            start++;\\n        }\\n        \\n        return new string(charArray);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public string MinInteger(string num, int k) \\n    {\\n        int start = 0, n = num.Length;\\n        var charArray = num.ToCharArray();\\n        if(k >=(n * (n - 1))/ 2)\\n        {\\n            Array.Sort(charArray);\\n            return new string(charArray);\\n        }\\n        \\n        while(start < charArray.Length)\\n        {\\n            int minIndex = start;\\n            int length = Math.Min(k, charArray.Length - start - 1);\\n            for(int len = length; len > 0; len--)\\n            {\\n                if(charArray[start + len] <= charArray[minIndex])\\n                    minIndex = start + len;\\n            }\\n                \\n            char val = charArray[minIndex];\\n            if(charArray[minIndex] != charArray[start])\\n            {\\n                for(int i = minIndex; i > start; i--)\\n                {\\n                    charArray[i] = charArray[i - 1];\\n                    k--;\\n                }\\n            }\\n            \\n            charArray[start] = val;\\n            start++;\\n        }\\n        \\n        return new string(charArray);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720389,
                "title": "python-runtime-100-ms-beat-100-better-than-o-n-2-analyse-the-complexity-if-you-can-help",
                "content": "try digit ==0 firstly.\\n\\n1. Try to move all digit to left. Say positions= all of indice of digit in num and it\\'s length is N\\nThen it needs (sum(positions)-(1+N-1) * (N-1)/2) swaps to move all digit to the left.\\nif K is large enough, remove all the digit from num, problem turns out to be [digit]* N + solve(num,k-temp,digit+1)\\n\\n2 if k is not large enough, try to move as many digit to left as possible, so move the leftmost digit firstly  every move cost position[i]-i swaps.\\n3. At last if k is not big enough to finish a single move, then use bubble sort to bruteforce the result.\\n\\nAs part 1 is O(10* n) \\npart2 is O(n)\\npart3 is hard to analyse, please comment if you have an idea.\\n\\n```\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        def sum1ton(n):\\n            return (1+n)*n//2\\n\\n        def brutforce(num,k: int):\\n            N = len(num)\\n            i = 0\\n            while i < N - 1 and k > 0:\\n                min_ind = i\\n                j = i + 1\\n                while j - i <= k and j < N:\\n                    if num[j] < num[min_ind]:\\n                        min_ind = j\\n                    j += 1\\n                num[i:min_ind + 1] = [num[min_ind]] + num[i:min_ind]\\n                k -= min_ind - i\\n                i += 1\\n            return num\\n\\n        def solve(num,k,digit):\\n            if digit==10:\\n                return num\\n            if k==0:\\n                return num\\n\\n            positons = []\\n            summ = 0\\n            for i, x in enumerate(num):\\n                if x ==digit:\\n                    positons.append(i)\\n                    summ += i\\n\\n            if len(positons)==0:\\n                return solve(num,k,digit+1)\\n            temp=summ-sum1ton(len(positons)-1)\\n            if k>=temp:# if can move all digit to left\\n                new_num=[x for x in num if x!=digit]\\n                res=[digit]*len(positons)+solve(new_num,k-temp,digit+1)\\n                return res\\n            else:#otherwise try to move as many digit to left as possible\\n                ind=0\\n                while k>=positons[ind]-ind:\\n                    k-=positons[ind]-ind\\n                    ind+=1\\n                pre=[digit]*ind\\n                temp=[x for x in num[:positons[ind]] if x!=digit]+num[positons[ind]:]\\n\\t\\t\\t\\t#cannot move any digit to left use bubble sort\\n                return pre+brutforce(temp,k)\\n\\n        num=[int(ch) for ch in num]\\n        ans=solve(num,k,0)\\n        return \"\".join([str(x) for x in ans])\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        def sum1ton(n):\\n            return (1+n)*n//2\\n\\n        def brutforce(num,k: int):\\n            N = len(num)\\n            i = 0\\n            while i < N - 1 and k > 0:\\n                min_ind = i\\n                j = i + 1\\n                while j - i <= k and j < N:\\n                    if num[j] < num[min_ind]:\\n                        min_ind = j\\n                    j += 1\\n                num[i:min_ind + 1] = [num[min_ind]] + num[i:min_ind]\\n                k -= min_ind - i\\n                i += 1\\n            return num\\n\\n        def solve(num,k,digit):\\n            if digit==10:\\n                return num\\n            if k==0:\\n                return num\\n\\n            positons = []\\n            summ = 0\\n            for i, x in enumerate(num):\\n                if x ==digit:\\n                    positons.append(i)\\n                    summ += i\\n\\n            if len(positons)==0:\\n                return solve(num,k,digit+1)\\n            temp=summ-sum1ton(len(positons)-1)\\n            if k>=temp:# if can move all digit to left\\n                new_num=[x for x in num if x!=digit]\\n                res=[digit]*len(positons)+solve(new_num,k-temp,digit+1)\\n                return res\\n            else:#otherwise try to move as many digit to left as possible\\n                ind=0\\n                while k>=positons[ind]-ind:\\n                    k-=positons[ind]-ind\\n                    ind+=1\\n                pre=[digit]*ind\\n                temp=[x for x in num[:positons[ind]] if x!=digit]+num[positons[ind]:]\\n\\t\\t\\t\\t#cannot move any digit to left use bubble sort\\n                return pre+brutforce(temp,k)\\n\\n        num=[int(ch) for ch in num]\\n        ans=solve(num,k,0)\\n        return \"\".join([str(x) for x in ans])\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720369,
                "title": "c-nlogn-using-std-set-to-record-position",
                "content": "132 ms.\\nwe search from  0 - 9 to find the next number with range k greedly.\\nSort previus number in a set.  keep a dis[10] array to record each number\\'s distance.  keep pos[10] array to track each number\\'s next position.\\nTrick is we need to update dis[10] each time we find a number v in front postion curpos.\\nfor other 9 number v1 that is not v, just compare position pos[v1]  with curpos, add 1 if cupos is bigger than pos[v1].\\nfor number v,  we need to caulate distance \\n\\n                            auto iter1 = m.lower_bound(pre);\\n                            auto iter2 = m.lower_bound(pos[v]);\\n                            int offset = std::distance(iter1, iter2);\\n                            dis[v] = dis[v] - offset;\\nNote this is (much) faster than std::distance(iter2, m.end());\\n\\ntime O(nlogn)\\n \\n\\n```\\nclass Solution {\\npublic:\\n\\n    int next(int cur, string& num)\\n    {\\n        int v = num[cur] - \\'0\\';\\n        for (int i = cur + 1; i < num.size(); i++)\\n        {\\n            int nv = num[i] - \\'0\\';\\n            if (nv == v)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    string minInteger(string num, int k) {\\n        vector<int> pos(10, -1);\\n        vector<int> dis(10, 0);\\n        for (int i = 0; i < num.size(); i++)\\n        {\\n            int v = num[i] - \\'0\\';\\n            if (pos[v] == -1)\\n            {\\n                pos[v] = i;\\n            }\\n        }\\n        int i = 0;\\n        vector<int> res;\\n        set<int> m;\\n        while (k > 0)\\n        {\\n            bool find = false;\\n            int v = 0;\\n            int cur;\\n            for (v = 0; v < 10; v++)\\n            {\\n                cur = pos[v];\\n                if (cur != -1 )\\n                {\\n                    if ((cur + dis[v] - i) <= k)\\n                    {\\n                        int pre = pos[v];\\n                        find = true;\\n                        res.push_back(v);\\n                        k = k - (cur + dis[v] - i);\\n                        pos[v] = next(cur, num);\\n                        if (pos[v] != -1)\\n                        {\\n                            auto iter1 = m.lower_bound(pre);\\n                            auto iter2 = m.lower_bound(pos[v]);\\n                            int offset = std::distance(iter1, iter2);\\n                            dis[v] = dis[v] - offset;\\n                        }\\n                        m.insert(cur);\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            i++;\\n            if (!find) break;\\n            for (int t = 0; t < 10; t++)\\n            {\\n                if (t != v)\\n                {\\n                    if (pos[t] < cur)\\n                    {\\n                        dis[t]++;\\n                    }\\n                }\\n            }\\n            \\n        }\\n\\n        bool allend = false;\\n        while (true)\\n        {\\n            int minpos = INT_MAX;\\n            int minv = -1;\\n            int v = -1;\\n            for (v = 0; v < 10; v++)\\n            {\\n                if (pos[v] != -1 && minpos > (pos[v]))\\n                {\\n                    minpos = pos[v];\\n                    minv = v;\\n                }\\n            }\\n\\n            if (minpos == INT_MAX)\\n            {\\n                break;\\n            }\\n            pos[minv] = next(minpos, num);\\n            res.push_back(minv);\\n        }\\n        string re;\\n        re.resize(res.size());\\n        for (int i = 0; i < res.size(); i++)\\n        {\\n            re[i] = res[i] + \\'0\\';\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int next(int cur, string& num)\\n    {\\n        int v = num[cur] - \\'0\\';\\n        for (int i = cur + 1; i < num.size(); i++)\\n        {\\n            int nv = num[i] - \\'0\\';\\n            if (nv == v)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    string minInteger(string num, int k) {\\n        vector<int> pos(10, -1);\\n        vector<int> dis(10, 0);\\n        for (int i = 0; i < num.size(); i++)\\n        {\\n            int v = num[i] - \\'0\\';\\n            if (pos[v] == -1)\\n            {\\n                pos[v] = i;\\n            }\\n        }\\n        int i = 0;\\n        vector<int> res;\\n        set<int> m;\\n        while (k > 0)\\n        {\\n            bool find = false;\\n            int v = 0;\\n            int cur;\\n            for (v = 0; v < 10; v++)\\n            {\\n                cur = pos[v];\\n                if (cur != -1 )\\n                {\\n                    if ((cur + dis[v] - i) <= k)\\n                    {\\n                        int pre = pos[v];\\n                        find = true;\\n                        res.push_back(v);\\n                        k = k - (cur + dis[v] - i);\\n                        pos[v] = next(cur, num);\\n                        if (pos[v] != -1)\\n                        {\\n                            auto iter1 = m.lower_bound(pre);\\n                            auto iter2 = m.lower_bound(pos[v]);\\n                            int offset = std::distance(iter1, iter2);\\n                            dis[v] = dis[v] - offset;\\n                        }\\n                        m.insert(cur);\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            i++;\\n            if (!find) break;\\n            for (int t = 0; t < 10; t++)\\n            {\\n                if (t != v)\\n                {\\n                    if (pos[t] < cur)\\n                    {\\n                        dis[t]++;\\n                    }\\n                }\\n            }\\n            \\n        }\\n\\n        bool allend = false;\\n        while (true)\\n        {\\n            int minpos = INT_MAX;\\n            int minv = -1;\\n            int v = -1;\\n            for (v = 0; v < 10; v++)\\n            {\\n                if (pos[v] != -1 && minpos > (pos[v]))\\n                {\\n                    minpos = pos[v];\\n                    minv = v;\\n                }\\n            }\\n\\n            if (minpos == INT_MAX)\\n            {\\n                break;\\n            }\\n            pos[minv] = next(minpos, num);\\n            res.push_back(minv);\\n        }\\n        string re;\\n        re.resize(res.size());\\n        for (int i = 0; i < res.size(); i++)\\n        {\\n            re[i] = res[i] + \\'0\\';\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720293,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        \\n        char[] ca = num.toCharArray();\\n        helper(ca, k, 0);\\n        return new String(ca);\\n        \\n    }\\n    \\n    \\n    \\n    public char[] helper(char[] num,int k,int i){\\n        if(k==0  || i==num.length-1){\\n            return num;\\n        }\\n        char min=num[i];\\n        int index=i;\\n        for(int j=i+1;j<Math.min(num.length,i+k+1);j++){\\n            char n=num[j];\\n            if(n<min){\\n                    \\n                    min=n;\\n                    index=j;\\n                }    \\n            }\\n        \\n        for (int j = index; j>i; j--) {num[j]=num[j-1];}\\n        num[i] = min;\\n        \\n        return helper(num,k-(index-i),i+1);  \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String minInteger(String num, int k) {\\n        \\n        char[] ca = num.toCharArray();\\n        helper(ca, k, 0);\\n        return new String(ca);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 720277,
                "title": "python-580ms-using-heap-336ms-sorting-by-digit",
                "content": "Finish this 20 minutes after deadline, unfortunately. \\uD83D\\uDE22\\n\\nI tried the O(n^2) method but got a TLE. Then I tried to use heap... Finished too late.\\n\\n**UPDATE**: Just saw this post [[Python] O(N log N) 316ms Greedy Solution](http://https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/discuss/720191/Python-O(N-log-N)-316ms-Greedy-Solution), sorting digits by 0 ~ 9. This is a great insight. I post my update at the bottom, with a runtime of 336ms. \\n\\n```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        if len(num) <= 1: return num\\n        def f(i):  # calculate the cost to k after some digits picked\\n            return i - bisect.bisect(pops, i)\\n        hp = [(c, i) for i, c in enumerate(num)]\\n        heapq.heapify(hp)\\n        ans = []\\n        pops = []  # picked nums\\' index. Keep increasing ordered for f()\\n        while hp and k:\\n            bak = []  # digits too far for this round might be valid later\\n            while hp and f(hp[0][1]) > k: bak.append(heapq.heappop(hp))\\n            if not hp: break\\n            k -= f(hp[0][1])\\n            ans.append(hp[0][0])\\n            bisect.insort(pops, hp[0][1])\\n            heapq.heappop(hp)\\n            for pair in bak: heapq.heappush(hp, pair)  # abandoned digits might be usefull later\\n        pops.insert(0, -1)\\n        pops.append(len(num))\\n        for i in range(len(pops)-1):\\n            ans.append(num[pops[i]+1:pops[i+1]])\\n        t = \"\".join(ans)\\n        if k > 0:  # if some k left, find the first not increasing digit and move it k step forward\\n            for i in range(1, len(t)):\\n                if t[i] < t[i-1]: break\\n            if t[i] >= t[i-1]: return t\\n            return t[:i-k-1] + t[i] + t[i-k-1:i] + t[i+1:]\\n        return t\\n```\\n\\nUpdate:\\n```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        def f(i):  # calculate the cost to k after some digits picked\\n            return i - bisect.bisect(pops, i)\\n        idx = [[] for _ in range(10)]\\n        for i in range(len(num)-1, -1, -1):\\n            idx[int(num[i])].append(i)\\n        ans = []\\n        pops = []  # picked nums\\' index. Keep increasing ordered for f()\\n        while k:\\n            d = 0\\n            while d < 10 and (not idx[d] or f(idx[d][-1]) > k): d += 1\\n            if d == 10: break\\n            k -= f(idx[d][-1])\\n            ans.append(str(d))\\n            bisect.insort(pops, idx[d].pop())\\n        pops.insert(0, -1)\\n        pops.append(len(num))\\n        for i in range(len(pops)-1):\\n            ans.append(num[pops[i]+1:pops[i+1]])\\n        t = \"\".join(ans)\\n        if k > 0:  # if some k left, find the first not increasing digit and move it k step forward\\n            for i in range(1, len(t)):\\n                if t[i] < t[i-1]: break\\n            if t[i] >= t[i-1]: return t\\n            return t[:i-k-1] + t[i] + t[i-k-1:i] + t[i+1:]\\n        return t\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        if len(num) <= 1: return num\\n        def f(i):  # calculate the cost to k after some digits picked\\n            return i - bisect.bisect(pops, i)\\n        hp = [(c, i) for i, c in enumerate(num)]\\n        heapq.heapify(hp)\\n        ans = []\\n        pops = []  # picked nums\\' index. Keep increasing ordered for f()\\n        while hp and k:\\n            bak = []  # digits too far for this round might be valid later\\n            while hp and f(hp[0][1]) > k: bak.append(heapq.heappop(hp))\\n            if not hp: break\\n            k -= f(hp[0][1])\\n            ans.append(hp[0][0])\\n            bisect.insort(pops, hp[0][1])\\n            heapq.heappop(hp)\\n            for pair in bak: heapq.heappush(hp, pair)  # abandoned digits might be usefull later\\n        pops.insert(0, -1)\\n        pops.append(len(num))\\n        for i in range(len(pops)-1):\\n            ans.append(num[pops[i]+1:pops[i+1]])\\n        t = \"\".join(ans)\\n        if k > 0:  # if some k left, find the first not increasing digit and move it k step forward\\n            for i in range(1, len(t)):\\n                if t[i] < t[i-1]: break\\n            if t[i] >= t[i-1]: return t\\n            return t[:i-k-1] + t[i] + t[i-k-1:i] + t[i+1:]\\n        return t\\n```\n```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        def f(i):  # calculate the cost to k after some digits picked\\n            return i - bisect.bisect(pops, i)\\n        idx = [[] for _ in range(10)]\\n        for i in range(len(num)-1, -1, -1):\\n            idx[int(num[i])].append(i)\\n        ans = []\\n        pops = []  # picked nums\\' index. Keep increasing ordered for f()\\n        while k:\\n            d = 0\\n            while d < 10 and (not idx[d] or f(idx[d][-1]) > k): d += 1\\n            if d == 10: break\\n            k -= f(idx[d][-1])\\n            ans.append(str(d))\\n            bisect.insort(pops, idx[d].pop())\\n        pops.insert(0, -1)\\n        pops.append(len(num))\\n        for i in range(len(pops)-1):\\n            ans.append(num[pops[i]+1:pops[i+1]])\\n        t = \"\".join(ans)\\n        if k > 0:  # if some k left, find the first not increasing digit and move it k step forward\\n            for i in range(1, len(t)):\\n                if t[i] < t[i-1]: break\\n            if t[i] >= t[i-1]: return t\\n            return t[:i-k-1] + t[i] + t[i-k-1:i] + t[i+1:]\\n        return t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720252,
                "title": "o-n-log-n-solution-using-segmenttree-124-ms-c",
                "content": "Store the indices of all digits 0 - 9. For each index from the start, greedily shift the smallest possible digit to this index provided that the number of swaps remaining is larger than the number of swaps required to move the smallest index in which this digit occurs. As swaps happen, the actual index of said digit may be different as there may be indices behind this actual index being pushed to the front, making the actual index of this digit larger than its original index.\\n      Let\\'s call this index `i`. Upon observation, the actual index is equal to `i + the number of elements with index > i which have been shifted to the front`. Once the actual index is found, the number of swaps required is just equal to the `actual index - target index location`. We could use a segment tree to maintain the count of pushed indices after each index.\\n\\t  After exhausting all swaps possible, just concatenate the remaining unsorted digits to the back of the sorted ones. `SegmentTree` takes `O(log N)` time per query therefore this algorithm runs in `O(N log N)`.\\n```\\nconst int MAXN = 30000 + 5;\\nclass SegmentTree {\\nprivate:\\n    int tree[4 * MAXN];\\n    int n;\\n    int merge(int, int);\\n    void build(vector<int>&, int, int, int);\\n    void modify(int, int, int, int, int);\\n    int get(int, int, int, int, int);\\npublic:\\n    SegmentTree(vector<int>&);\\n    void build(vector<int>&);\\n    void modify(int, int);\\n    int get(int, int);\\n};\\n\\n// initialize segment tree\\nSegmentTree::SegmentTree(vector<int>& arr) {\\n    n = arr.size();\\n    build(arr);\\n}\\n\\n// merging method of nodes in the segmment tree\\nint SegmentTree::merge(int left, int right) {\\n    return left + right;\\n}\\n\\n// recursively build the segment tree\\nvoid SegmentTree::build(vector<int>& arr, int treeIndex, int lo, int hi) {  \\n    if (lo == hi) {\\n        tree[treeIndex] = arr[lo];\\n        return;\\n    }\\n    int mid = lo + (hi - lo) / 2;\\n    build(arr, 2 * treeIndex + 1, lo, mid);\\n    build(arr, 2 * treeIndex + 2, mid + 1, hi);\\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\\n}\\n\\n// function to get value on interval [left, right]\\nint SegmentTree::get(int treeIndex, int left, int right, int lo, int hi) {\\n    // segment completely out of range\\n    if (lo > right || hi < left) {\\n        return 0;\\n    }\\n    // segment completely inside range\\n    if (left <= lo && right >= hi) {          \\n        return tree[treeIndex];\\n    }\\n    int mid = lo + (hi - lo) / 2;\\n    // segment completely to the left of mid\\n    if (right <= mid) {\\n        return get(2 * treeIndex + 1, left, right, lo, mid);\\n    }\\n    // segment completely to the right of mid\\n    else if (left > mid) {\\n        return get(2 * treeIndex + 2, left, right, mid + 1, hi);\\n    }\\n    // segment overlapping both left and right\\n    int leftRes = get(2 * treeIndex + 1, left, mid, lo, mid);\\n    int rightRes = get(2 * treeIndex + 2, mid + 1, right, mid + 1, hi);\\n    // merge query results\\n    return merge(leftRes, rightRes);\\n}\\n\\n// function to modify a tree node \\nvoid SegmentTree::modify(int treeIndex, int arrIndex, int val, int lo, int hi) {  \\n    // leaf node. update element.\\n     if (lo == hi) {\\n        tree[treeIndex] = val;\\n        return;\\n     }\\n    int mid = lo + (hi - lo) / 2;\\n    // update descendants\\n    if (arrIndex <= mid) {\\n        modify(2 * treeIndex + 1, arrIndex, val, lo, mid);\\n    } else {\\n        modify(2 * treeIndex + 2, arrIndex, val, mid + 1, hi);\\n    }\\n    // merge updates\\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\\n}\\n\\n// public wrapper for build\\nvoid SegmentTree::build(vector<int>& arr) {\\n    return build(arr, 0, 0, n - 1);\\n}\\n\\n// public wrapper for get\\nint SegmentTree::get(int left, int right) {\\n    return get(0, left, right, 0, n - 1);\\n}\\n\\n// public wrapper for modify\\nvoid SegmentTree::modify(int arrIndex, int val) {\\n    return modify(0, arrIndex, val, 0, n - 1);\\n}\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int N = num.size();\\n        queue<int> digs[10];\\n        for(int i = 0; i < N; i++) {\\n            int d = num[i]-\\'0\\';\\n            digs[d].push(i);\\n        }\\n        vector<int> pushed(N);\\n        SegmentTree segT(pushed);\\n        string sorted;\\n        for(int i = 0; i < N && k; i++) {\\n            bool canImprove = false;\\n            for(int d = 0; d <= 9; d++) {\\n                if(digs[d].empty()) {\\n                    continue;\\n                }\\n                int ind = digs[d].front();\\n                int actualInd = ind + (ind < N - 1 ? segT.get(ind + 1, N - 1) : 0);\\n                int swapsNeeded = actualInd - i;\\n                if(k >= swapsNeeded) {\\n                    k -= swapsNeeded;\\n                    sorted.push_back(d + \\'0\\');\\n                    segT.modify(ind, 1);\\n                    canImprove = true;\\n                    digs[d].pop();\\n                    break;\\n                }\\n            }\\n            if(!canImprove) {\\n                break;\\n            }\\n        }\\n        vector<int> leftover;\\n        for(int d = 0; d <= 9; d++) {\\n            while(!digs[d].empty()) {\\n                leftover.push_back(digs[d].front());\\n                digs[d].pop();\\n            }\\n        }\\n        sort(leftover.begin(), leftover.end());\\n        string unsorted;\\n        for(int i : leftover) {\\n            unsorted.push_back(num[i]);\\n        }\\n        return sorted + unsorted;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int MAXN = 30000 + 5;\\nclass SegmentTree {\\nprivate:\\n    int tree[4 * MAXN];\\n    int n;\\n    int merge(int, int);\\n    void build(vector<int>&, int, int, int);\\n    void modify(int, int, int, int, int);\\n    int get(int, int, int, int, int);\\npublic:\\n    SegmentTree(vector<int>&);\\n    void build(vector<int>&);\\n    void modify(int, int);\\n    int get(int, int);\\n};\\n\\n// initialize segment tree\\nSegmentTree::SegmentTree(vector<int>& arr) {\\n    n = arr.size();\\n    build(arr);\\n}\\n\\n// merging method of nodes in the segmment tree\\nint SegmentTree::merge(int left, int right) {\\n    return left + right;\\n}\\n\\n// recursively build the segment tree\\nvoid SegmentTree::build(vector<int>& arr, int treeIndex, int lo, int hi) {  \\n    if (lo == hi) {\\n        tree[treeIndex] = arr[lo];\\n        return;\\n    }\\n    int mid = lo + (hi - lo) / 2;\\n    build(arr, 2 * treeIndex + 1, lo, mid);\\n    build(arr, 2 * treeIndex + 2, mid + 1, hi);\\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\\n}\\n\\n// function to get value on interval [left, right]\\nint SegmentTree::get(int treeIndex, int left, int right, int lo, int hi) {\\n    // segment completely out of range\\n    if (lo > right || hi < left) {\\n        return 0;\\n    }\\n    // segment completely inside range\\n    if (left <= lo && right >= hi) {          \\n        return tree[treeIndex];\\n    }\\n    int mid = lo + (hi - lo) / 2;\\n    // segment completely to the left of mid\\n    if (right <= mid) {\\n        return get(2 * treeIndex + 1, left, right, lo, mid);\\n    }\\n    // segment completely to the right of mid\\n    else if (left > mid) {\\n        return get(2 * treeIndex + 2, left, right, mid + 1, hi);\\n    }\\n    // segment overlapping both left and right\\n    int leftRes = get(2 * treeIndex + 1, left, mid, lo, mid);\\n    int rightRes = get(2 * treeIndex + 2, mid + 1, right, mid + 1, hi);\\n    // merge query results\\n    return merge(leftRes, rightRes);\\n}\\n\\n// function to modify a tree node \\nvoid SegmentTree::modify(int treeIndex, int arrIndex, int val, int lo, int hi) {  \\n    // leaf node. update element.\\n     if (lo == hi) {\\n        tree[treeIndex] = val;\\n        return;\\n     }\\n    int mid = lo + (hi - lo) / 2;\\n    // update descendants\\n    if (arrIndex <= mid) {\\n        modify(2 * treeIndex + 1, arrIndex, val, lo, mid);\\n    } else {\\n        modify(2 * treeIndex + 2, arrIndex, val, mid + 1, hi);\\n    }\\n    // merge updates\\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\\n}\\n\\n// public wrapper for build\\nvoid SegmentTree::build(vector<int>& arr) {\\n    return build(arr, 0, 0, n - 1);\\n}\\n\\n// public wrapper for get\\nint SegmentTree::get(int left, int right) {\\n    return get(0, left, right, 0, n - 1);\\n}\\n\\n// public wrapper for modify\\nvoid SegmentTree::modify(int arrIndex, int val) {\\n    return modify(0, arrIndex, val, 0, n - 1);\\n}\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int N = num.size();\\n        queue<int> digs[10];\\n        for(int i = 0; i < N; i++) {\\n            int d = num[i]-\\'0\\';\\n            digs[d].push(i);\\n        }\\n        vector<int> pushed(N);\\n        SegmentTree segT(pushed);\\n        string sorted;\\n        for(int i = 0; i < N && k; i++) {\\n            bool canImprove = false;\\n            for(int d = 0; d <= 9; d++) {\\n                if(digs[d].empty()) {\\n                    continue;\\n                }\\n                int ind = digs[d].front();\\n                int actualInd = ind + (ind < N - 1 ? segT.get(ind + 1, N - 1) : 0);\\n                int swapsNeeded = actualInd - i;\\n                if(k >= swapsNeeded) {\\n                    k -= swapsNeeded;\\n                    sorted.push_back(d + \\'0\\');\\n                    segT.modify(ind, 1);\\n                    canImprove = true;\\n                    digs[d].pop();\\n                    break;\\n                }\\n            }\\n            if(!canImprove) {\\n                break;\\n            }\\n        }\\n        vector<int> leftover;\\n        for(int d = 0; d <= 9; d++) {\\n            while(!digs[d].empty()) {\\n                leftover.push_back(digs[d].front());\\n                digs[d].pop();\\n            }\\n        }\\n        sort(leftover.begin(), leftover.end());\\n        string unsorted;\\n        for(int i : leftover) {\\n            unsorted.push_back(num[i]);\\n        }\\n        return sorted + unsorted;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720247,
                "title": "can-someone-help-in-optimizing-this-backtracking-solution",
                "content": "I am getting a TLE through this backtracking solution for string \"9438957234785635408\".\\nCan someone help me with some pruning step?\\n\\n```\\n void findMin(string S, long long int n, int k, string &min_so_far){\\n    // compare current number with minimum number so far\\n    if (min_so_far.compare(S) > 0)\\n        min_so_far = S;\\n\\n    // base case: no swaps left\\n    if (k < 1)\\n        return;\\n        \\n\\n    // do for each digit in the input string\\n    for (int i = 0; i < n - 1; i++){\\n        // compare the current digit with remaining digits\\n            // if digit at i\\'th index is more than the digit at j\\'th index\\n            int j=i+1;\\n            if (S[i] > S[j])\\n            {\\n                // swap S[i] and S[j]\\n                swap(S[i], S[j]);\\n\\n                // recur for remaining k - 1 swaps\\n                findMin(S, n, k - 1, min_so_far);\\n\\n                // backtrack - restore the string back\\n                swap(S[i], S[j]);\\n            }\\n    }\\n }\\n    \\n    string minInteger(string num, int k) {\\n        string minimum= num;\\n        \\n        findMin(num, num.length(), k, minimum);\\n        \\n        return minimum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n void findMin(string S, long long int n, int k, string &min_so_far){\\n    // compare current number with minimum number so far\\n    if (min_so_far.compare(S) > 0)\\n        min_so_far = S;\\n\\n    // base case: no swaps left\\n    if (k < 1)\\n        return;\\n        \\n\\n    // do for each digit in the input string\\n    for (int i = 0; i < n - 1; i++){\\n        // compare the current digit with remaining digits\\n            // if digit at i\\'th index is more than the digit at j\\'th index\\n            int j=i+1;\\n            if (S[i] > S[j])\\n            {\\n                // swap S[i] and S[j]\\n                swap(S[i], S[j]);\\n\\n                // recur for remaining k - 1 swaps\\n                findMin(S, n, k - 1, min_so_far);\\n\\n                // backtrack - restore the string back\\n                swap(S[i], S[j]);\\n            }\\n    }\\n }\\n    \\n    string minInteger(string num, int k) {\\n        string minimum= num;\\n        \\n        findMin(num, num.length(), k, minimum);\\n        \\n        return minimum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 720217,
                "title": "greedy-solution-using-heap",
                "content": "Imagine k as the moving budget, intuitively, \\n1. we always want to move the smallest possible item (as long as the moving distance is maller than remaining budget k) to the begining of the final array first. \\n2. Then decrease the budget k by moving distance (the position of the candidate item in current string, a little tricky here, I try to find how many items after the current item in the initial array have been moved to begining as the position shift)\\n3. Keep iterating until k equals 0, then the order all remaining items will not change.\\n4. To always pick the smallest item, use a heap to store all values and initial position.\\n\\n```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        queue = []\\n        res = []\\n\\t\\t# Initialize the heap, always pop the smallest value\\n        for i in range(len(num)):\\n            heapq.heappush(queue, (num[i], i))\\n        \\n\\t\\t# The next position we need to decide for the output\\n        cur = 0\\n\\t\\t# The indices that have been moved to begining\\n        vis = []\\n        while queue and k > 0:\\n            temp = []\\n            while queue and k > 0:\\n                x, idx = heapq.heappop(queue)\\n                # binary search, find how many items after x have been moved to array begining, use the shift to decide the new position of x in current array\\n                shift = bisect.bisect_left(vis, -idx)\\n                if idx + shift - cur <= k:\\n                    res.append(x)\\n                    bisect.insort_left(vis, -idx)\\n                    k -= (idx + shift - cur)\\n                    cur += 1\\n                    break\\n                else:\\n                    temp.append((x, idx))\\n\\t\\t\\t# Put the candidates that are too far for moving back to heap ... I think this step could be improved\\n            for item in temp:\\n                heapq.heappush(queue, item)\\n        # If k equals 0, but there still items remaining in the queue, just output all remaining items in original order\\n        if queue:\\n            queue = sorted(queue, key = lambda x: x[1])\\n            for x, idx in queue:\\n                res.append(x)\\n        \\n        return \"\".join(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        queue = []\\n        res = []\\n\\t\\t# Initialize the heap, always pop the smallest value\\n        for i in range(len(num)):\\n            heapq.heappush(queue, (num[i], i))\\n        \\n\\t\\t# The next position we need to decide for the output\\n        cur = 0\\n\\t\\t# The indices that have been moved to begining\\n        vis = []\\n        while queue and k > 0:\\n            temp = []\\n            while queue and k > 0:\\n                x, idx = heapq.heappop(queue)\\n                # binary search, find how many items after x have been moved to array begining, use the shift to decide the new position of x in current array\\n                shift = bisect.bisect_left(vis, -idx)\\n                if idx + shift - cur <= k:\\n                    res.append(x)\\n                    bisect.insort_left(vis, -idx)\\n                    k -= (idx + shift - cur)\\n                    cur += 1\\n                    break\\n                else:\\n                    temp.append((x, idx))\\n\\t\\t\\t# Put the candidates that are too far for moving back to heap ... I think this step could be improved\\n            for item in temp:\\n                heapq.heappush(queue, item)\\n        # If k equals 0, but there still items remaining in the queue, just output all remaining items in original order\\n        if queue:\\n            queue = sorted(queue, key = lambda x: x[1])\\n            for x, idx in queue:\\n                res.append(x)\\n        \\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861118,
                "title": "another-bubble-sort-solution-may-be-easier-to-understand-java",
                "content": "```java\\n public int getMinNumberIdx(char[] a, int i, int k){\\n        int minIdx = -1;\\n        int min = Integer.MAX_VALUE;\\n        for(int j=i; j <=k+i && j < a.length; j++){\\n            if((int)(a[j]-\\'0\\') < min){\\n                min = (int)(a[j]-\\'0\\');\\n                minIdx = j;\\n            }\\n        }\\n        return minIdx;\\n    }\\n    public String minInteger(String num, int k) {\\n        \\n        char[] ar = num.toCharArray();\\n        int i =0;\\n        while(k > 0){\\n            int idx = getMinNumberIdx(ar, i, k);\\n            if(idx==-1)break; //whole array is sorted.\\n\\t\\t\\t\\n            char min = ar[idx];\\n            for(int j=idx; j >i; j--){\\n                ar[j] = ar[j-1]; \\n            }\\n            ar[i] = min;\\n             \\n            k -= (idx-i); \\n\\t\\t\\t\\n            i++;\\n            \\n        }\\n        return new String(ar);\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n public int getMinNumberIdx(char[] a, int i, int k){\\n        int minIdx = -1;\\n        int min = Integer.MAX_VALUE;\\n        for(int j=i; j <=k+i && j < a.length; j++){\\n            if((int)(a[j]-\\'0\\') < min){\\n                min = (int)(a[j]-\\'0\\');\\n                minIdx = j;\\n            }\\n        }\\n        return minIdx;\\n    }\\n    public String minInteger(String num, int k) {\\n        \\n        char[] ar = num.toCharArray();\\n        int i =0;\\n        while(k > 0){\\n            int idx = getMinNumberIdx(ar, i, k);\\n            if(idx==-1)break; //whole array is sorted.\\n\\t\\t\\t\\n            char min = ar[idx];\\n            for(int j=idx; j >i; j--){\\n                ar[j] = ar[j-1]; \\n            }\\n            ar[i] = min;\\n             \\n            k -= (idx-i); \\n\\t\\t\\t\\n            i++;\\n            \\n        }\\n        return new String(ar);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 826662,
                "title": "easy-to-understand-c-priority-queue-ordered-set-o-nlogn-time",
                "content": "```\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp> \\nusing namespace __gnu_pbds; \\nclass Solution {\\n\\npublic:\\n    #define pr pair<int,int>\\n    #define pb push_back\\n    #define fi first\\n    #define se second\\n\\n    \\n    #define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\n\\n    \\n    struct compare_queue\\n    {\\n        bool operator()(const int& a, const int& b)\\n        {\\n            return a>b;\\n        }\\n    };\\n    \\n    string minInteger(string num, int k) {\\n            vector<priority_queue<int,vector<int>,compare_queue>  > q(10);              int n=num.size();\\n        int i,j;\\n        for(i=0;i<n;i++){\\n            q[num[i]-\\'0\\'].push(i);\\n        }\\n        i=0;\\n        string ans=\"\";\\n        ordered_set po;\\n        while(i<n){\\n            if(num[i]==\\'X\\'){i++; continue;}\\n            if(k==0){\\n                ans+=num[i];\\n                i++;\\n                continue;\\n            }\\n            int curr=num[i]-\\'0\\';\\n            int flag=0;\\n            for(j=0;j<curr;j++){\\n                \\n                while(!q[j].empty()  &&  q[j].top()<i){q[j].pop();}\\n                if(q[j].empty()){continue;}\\n                int val1=po.order_of_key(q[j].top());\\n               int val2=po.order_of_key(i);\\n                val1=val1-val2;\\n                val1=q[j].top()-i-val1;\\n               \\n                if(k>=val1){\\n                    flag=1;\\n                    k-=val1;\\n                    ans+=num[q[j].top()];\\n                    po.insert(q[j].top());\\n                    num[q[j].top()]=\\'X\\';\\n                    q[j].pop();\\n                    break;\\n                }\\n            }\\n            if(flag==0){\\n                ans+=num[i];\\n                i++;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp> \\nusing namespace __gnu_pbds; \\nclass Solution {\\n\\npublic:\\n    #define pr pair<int,int>\\n    #define pb push_back\\n    #define fi first\\n    #define se second\\n\\n    \\n    #define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\n\\n    \\n    struct compare_queue\\n    {\\n        bool operator()(const int& a, const int& b)\\n        {\\n            return a>b;\\n        }\\n    };\\n    \\n    string minInteger(string num, int k) {\\n            vector<priority_queue<int,vector<int>,compare_queue>  > q(10);              int n=num.size();\\n        int i,j;\\n        for(i=0;i<n;i++){\\n            q[num[i]-\\'0\\'].push(i);\\n        }\\n        i=0;\\n        string ans=\"\";\\n        ordered_set po;\\n        while(i<n){\\n            if(num[i]==\\'X\\'){i++; continue;}\\n            if(k==0){\\n                ans+=num[i];\\n                i++;\\n                continue;\\n            }\\n            int curr=num[i]-\\'0\\';\\n            int flag=0;\\n            for(j=0;j<curr;j++){\\n                \\n                while(!q[j].empty()  &&  q[j].top()<i){q[j].pop();}\\n                if(q[j].empty()){continue;}\\n                int val1=po.order_of_key(q[j].top());\\n               int val2=po.order_of_key(i);\\n                val1=val1-val2;\\n                val1=q[j].top()-i-val1;\\n               \\n                if(k>=val1){\\n                    flag=1;\\n                    k-=val1;\\n                    ans+=num[q[j].top()];\\n                    po.insert(q[j].top());\\n                    num[q[j].top()]=\\'X\\';\\n                    q[j].pop();\\n                    break;\\n                }\\n            }\\n            if(flag==0){\\n                ans+=num[i];\\n                i++;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 722656,
                "title": "simple-solution-with-explanation-o-n-2-greedy-solution-passed-c-iterative",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string minInteger(string num, int k) {\\n//         greedy approach\\n//         time O(n^2) || space O(n)\\n        \\n//         iterative algorithm:\\n//         On each iteration:\\n//         find the smallest digit say num[i], such that num[i] < num[0]  \\n//         where i > 0 and (i - 0) <= k\\n//         add num[i] to min, as\\n//         min += num[i];\\n//         and new subproblem would be \\n//         minInteger(num\\' = (num[0:i] + num[i + 1:]), k\\' = (k - i))\\n        \\n//         Little optimization is when \\n//         num swaps left k > n * (n - 1) / 2, where n = num.length()\\n//         then we can directly form min number by sorting and returns\\n        \\n//         without the above optimization code only passing 55/57 test cases.\\n        \\n        string min = \"\";\\n        while(k && num.length()) {\\n            \\n            int n = num.length();     \\n            if(k >= (n * (n - 1)) / 2) {\\n                sort(num.begin(), num.end());\\n                return min + num;\\n            }\\n            \\n            int mi_idx = 0;\\n            for(int i = 1; i < num.length() && i <= k; i++) {\\n                if(num[i] < num[mi_idx]) \\n                    mi_idx = i;\\n            }\\n            min += num[mi_idx];\\n            k -= (mi_idx);\\n            num = num.substr(0, mi_idx) + num.substr(mi_idx + 1);\\n        }\\n        min += num;\\n        return min;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string minInteger(string num, int k) {\\n//         greedy approach\\n//         time O(n^2) || space O(n)\\n        \\n//         iterative algorithm:\\n//         On each iteration:\\n//         find the smallest digit say num[i], such that num[i] < num[0]  \\n//         where i > 0 and (i - 0) <= k\\n//         add num[i] to min, as\\n//         min += num[i];\\n//         and new subproblem would be \\n//         minInteger(num\\' = (num[0:i] + num[i + 1:]), k\\' = (k - i))\\n        \\n//         Little optimization is when \\n//         num swaps left k > n * (n - 1) / 2, where n = num.length()\\n//         then we can directly form min number by sorting and returns\\n        \\n//         without the above optimization code only passing 55/57 test cases.\\n        \\n        string min = \"\";\\n        while(k && num.length()) {\\n            \\n            int n = num.length();     \\n            if(k >= (n * (n - 1)) / 2) {\\n                sort(num.begin(), num.end());\\n                return min + num;\\n            }\\n            \\n            int mi_idx = 0;\\n            for(int i = 1; i < num.length() && i <= k; i++) {\\n                if(num[i] < num[mi_idx]) \\n                    mi_idx = i;\\n            }\\n            min += num[mi_idx];\\n            k -= (mi_idx);\\n            num = num.substr(0, mi_idx) + num.substr(mi_idx + 1);\\n        }\\n        min += num;\\n        return min;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720983,
                "title": "cpp-similar-to-sorting-a-string-in-lexicographic-order-with-at-most-k-changes",
                "content": "Below are the observation.\\n- If K is too large we can directly return the sorted string.\\n- Otherwise at each position find the smallest character on right side within K reach and replace current character with it and also move all right side neighbours to right by one position. Reduce K by the distance we got the small character.\\n\\n```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n\\t\\t\\n\\t\\t/*If K is too large, sort and return*/\\n        if(k>=n*(n-1)/2){\\n            sort(num.begin(), num.end());\\n            return num;\\n        }\\n        for(int i=0;i<n && k>0;i++){\\n            char mn = num[i];\\n            int index=i;\\n            int tk=k;\\n\\t\\t\\t\\n\\t\\t\\t//for the character at index i , find the smallest character with at most K distance\\n            for(int j= i+1;j<n && tk>0;j++){\\n                if(mn>num[j]){\\n\\t\\t\\t\\t    // save character and index for the swap\\n                    mn=num[j];\\n                    index=j;\\n                }\\n                tk--;\\n            }\\n\\t\\t\\t// Move all characters from i to min_char_index to the right to make space for the smallest character\\n            for(int j=index;j>i;j--){\\n                num[j]=num[j-1];\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//replace current character with minimum char\\n            num[i]=mn;\\n\\t\\t\\t\\n\\t\\t\\t//reduce K\\n            k-=(index-i);\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n\\t\\t\\n\\t\\t/*If K is too large, sort and return*/\\n        if(k>=n*(n-1)/2){\\n            sort(num.begin(), num.end());\\n            return num;\\n        }\\n        for(int i=0;i<n && k>0;i++){\\n            char mn = num[i];\\n            int index=i;\\n            int tk=k;\\n\\t\\t\\t\\n\\t\\t\\t//for the character at index i , find the smallest character with at most K distance\\n            for(int j= i+1;j<n && tk>0;j++){\\n                if(mn>num[j]){\\n\\t\\t\\t\\t    // save character and index for the swap\\n                    mn=num[j];\\n                    index=j;\\n                }\\n                tk--;\\n            }\\n\\t\\t\\t// Move all characters from i to min_char_index to the right to make space for the smallest character\\n            for(int j=index;j>i;j--){\\n                num[j]=num[j-1];\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//replace current character with minimum char\\n            num[i]=mn;\\n\\t\\t\\t\\n\\t\\t\\t//reduce K\\n            k-=(index-i);\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720241,
                "title": "javascript-bubble-sort",
                "content": "Learned my lesson: `localeCompare` is slower than `>` or `<` operators\\n```javascript\\n// pseudo code:\\n// put number into a data structure that reduces the need for unnecessary copying\\n// iterate through the datastructure and find the minimum value we can put into the digit\\n// with the greatest weight with the minimum number of moves\\n// move that value to the current digit while shifting all digits from the digit to the minimum digit to the right\\n// decrement k by the amount of digits we moved\\n\\nvar minInteger = function(num, k) {\\n    const numArr = num.split(\\'\\');\\n    for (let i = 0; i < num.length && k; i++) {\\n        let swapIdx = i;\\n        const end = Math.min(num.length, k + i + 1);\\n        for (let j = i + 1; j < end; j++) {\\n            if (numArr[swapIdx] > numArr[j]) swapIdx = j;\\n        }\\n        const temp = numArr[swapIdx];\\n        for (let k = swapIdx; k > i; k--) {\\n            numArr[k] = numArr[k - 1];\\n        }\\n        numArr[i] = temp;\\n        k -= swapIdx - i;\\n    }\\n    return numArr.join(\\'\\');\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n// pseudo code:\\n// put number into a data structure that reduces the need for unnecessary copying\\n// iterate through the datastructure and find the minimum value we can put into the digit\\n// with the greatest weight with the minimum number of moves\\n// move that value to the current digit while shifting all digits from the digit to the minimum digit to the right\\n// decrement k by the amount of digits we moved\\n\\nvar minInteger = function(num, k) {\\n    const numArr = num.split(\\'\\');\\n    for (let i = 0; i < num.length && k; i++) {\\n        let swapIdx = i;\\n        const end = Math.min(num.length, k + i + 1);\\n        for (let j = i + 1; j < end; j++) {\\n            if (numArr[swapIdx] > numArr[j]) swapIdx = j;\\n        }\\n        const temp = numArr[swapIdx];\\n        for (let k = swapIdx; k > i; k--) {\\n            numArr[k] = numArr[k - 1];\\n        }\\n        numArr[i] = temp;\\n        k -= swapIdx - i;\\n    }\\n    return numArr.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565628,
                "content": [
                    {
                        "username": "theOtherWC",
                        "content": "It would not be acceptable to accept solutions that needs 8s to run with the large test case in python but not in C#. Right now this is what I see. This is ridiculous: a 8s Python is accepted but not C#. Please, be consistent when it comes to timing. Accept either none or all, especially during a contest! \\n\\n![image](https://assets.leetcode.com/users/images/164782dd-15cc-4cac-a7ad-57736b4384e4_1593923029.0101244.png)\\n"
                    },
                    {
                        "username": "Imqqqqq",
                        "content": "Does this make sense? Make the description should be modified?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "For every index i, search for the minimum number in range i to i + k (inclusive). Keep track of the minimum numbers distance from i and the minimum numbers index. \\n\\nIf  num[i] is the minimum, we can just continue in our loop because that number is already where it should be.\\n\\nOtherwise, remove the minimum at its index, append it to index i, and subtract the distance from k.\\n\\nDo this until either k == 0 or you\\'ve gone through every index. It makes this process a lot easier to use something like a List in python or c#, because when you append the number to its new index it will automatically push all the indexes in front of it forward.\\n\\nFinally, construct the new string from your list and return the answer!"
                    }
                ]
            },
            {
                "id": 1576513,
                "content": [
                    {
                        "username": "theOtherWC",
                        "content": "It would not be acceptable to accept solutions that needs 8s to run with the large test case in python but not in C#. Right now this is what I see. This is ridiculous: a 8s Python is accepted but not C#. Please, be consistent when it comes to timing. Accept either none or all, especially during a contest! \\n\\n![image](https://assets.leetcode.com/users/images/164782dd-15cc-4cac-a7ad-57736b4384e4_1593923029.0101244.png)\\n"
                    },
                    {
                        "username": "Imqqqqq",
                        "content": "Does this make sense? Make the description should be modified?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "For every index i, search for the minimum number in range i to i + k (inclusive). Keep track of the minimum numbers distance from i and the minimum numbers index. \\n\\nIf  num[i] is the minimum, we can just continue in our loop because that number is already where it should be.\\n\\nOtherwise, remove the minimum at its index, append it to index i, and subtract the distance from k.\\n\\nDo this until either k == 0 or you\\'ve gone through every index. It makes this process a lot easier to use something like a List in python or c#, because when you append the number to its new index it will automatically push all the indexes in front of it forward.\\n\\nFinally, construct the new string from your list and return the answer!"
                    }
                ]
            },
            {
                "id": 2033594,
                "content": [
                    {
                        "username": "theOtherWC",
                        "content": "It would not be acceptable to accept solutions that needs 8s to run with the large test case in python but not in C#. Right now this is what I see. This is ridiculous: a 8s Python is accepted but not C#. Please, be consistent when it comes to timing. Accept either none or all, especially during a contest! \\n\\n![image](https://assets.leetcode.com/users/images/164782dd-15cc-4cac-a7ad-57736b4384e4_1593923029.0101244.png)\\n"
                    },
                    {
                        "username": "Imqqqqq",
                        "content": "Does this make sense? Make the description should be modified?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "For every index i, search for the minimum number in range i to i + k (inclusive). Keep track of the minimum numbers distance from i and the minimum numbers index. \\n\\nIf  num[i] is the minimum, we can just continue in our loop because that number is already where it should be.\\n\\nOtherwise, remove the minimum at its index, append it to index i, and subtract the distance from k.\\n\\nDo this until either k == 0 or you\\'ve gone through every index. It makes this process a lot easier to use something like a List in python or c#, because when you append the number to its new index it will automatically push all the indexes in front of it forward.\\n\\nFinally, construct the new string from your list and return the answer!"
                    }
                ]
            }
        ]
    }
]