[
    {
        "title": "Sqrt(x)",
        "question_content": "Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.\nYou must not use any built-in exponent function or operator.\n\n\tFor example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.\n\n&nbsp;\nExample 1:\n\nInput: x = 4\nOutput: 2\nExplanation: The square root of 4 is 2, so we return 2.\n\nExample 2:\n\nInput: x = 8\nOutput: 2\nExplanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.\n\n&nbsp;\nConstraints:\n\n\t0 <= x <= 231 - 1",
        "solutions": [
            {
                "id": 25047,
                "title": "a-binary-search-solution",
                "content": "Instead of using fancy Newton's method, this plain binary search approach also works.\\n\\n    public int sqrt(int x) {\\n        if (x == 0)\\n            return 0;\\n        int left = 1, right = Integer.MAX_VALUE;\\n        while (true) {\\n            int mid = left + (right - left)/2;\\n            if (mid > x/mid) {\\n                right = mid - 1;\\n            } else {\\n                if (mid + 1 > x/(mid + 1))\\n                    return mid;\\n                left = mid + 1;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "Instead of using fancy Newton's method, this plain binary search approach also works.\\n\\n    public int sqrt(int x) {\\n        if (x == 0)\\n            return 0;\\n        int left = 1, right = Integer.MAX_VALUE;\\n        while (true) {\\n            int mid = left + (right - left)/2;\\n            if (mid > x/mid) {\\n                right = mid - 1;\\n            } else {\\n                if (mid + 1 > x/(mid + 1))\\n                    return mid;\\n                left = mid + 1;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 25057,
                "title": "3-4-short-lines-integer-newton-every-language",
                "content": "Quite a few people used Newton already, but I didn't see someone make it this short. Same solution in every language. Explanation under the solutions.\\n\\n**C++ and C**\\n\\n        long r = x;\\n        while (r*r > x)\\n            r = (r + x/r) / 2;\\n        return r;\\n\\n**Python**\\n\\n        r = x\\n        while r*r > x:\\n            r = (r + x/r) / 2\\n        return r\\n\\n**Ruby**\\n\\n        r = x\\n        r = (r + x/r) / 2 while r*r > x\\n        r\\n\\n**Java and C#**\\n\\n        long r = x;\\n        while (r*r > x)\\n            r = (r + x/r) / 2;\\n        return (int) r;\\n\\n**JavaScript**\\n\\n        r = x;\\n        while (r*r > x)\\n            r = ((r + x/r) / 2) | 0;\\n        return r;\\n\\n---\\n\\n**Explanation**\\n\\nApparently, [using only integer division for the Newton method works](https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division). And I guessed that if I start at x, the root candidate will decrease monotonically and never get too small.\\n\\nThe above solutions all got accepted, and in C++ I also verified it locally on my PC for all possible inputs (0 to 2147483647):\\n\\n    #include <iostream>\\n    #include <climits>\\n    using namespace std;\\n    \\n    int mySqrt(int x) {\\n        long long r = x;\\n        while (r*r > x)\\n            r = (r + x/r) / 2;\\n        return r;\\n    }\\n    \\n    int main() {\\n        for (long long x=0; x<=INT_MAX; ++x) {\\n            long long r = mySqrt(x);\\n            if (r<0 || r*r > x || (r+1)*(r+1) <= x)\\n                cout << \"false: \" << x << \" \" << r << endl;\\n            if (x % 10000000 == 0)\\n                cout << x << endl;\\n        }\\n        cout << \"all checked\" << endl;\\n    }",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "Quite a few people used Newton already, but I didn't see someone make it this short. Same solution in every language. Explanation under the solutions.\\n\\n**C++ and C**\\n\\n        long r = x;\\n        while (r*r > x)\\n            r = (r + x/r) / 2;\\n        return r;\\n\\n**Python**\\n\\n        r = x\\n        while r*r > x:\\n            r = (r + x/r) / 2\\n        return r\\n\\n**Ruby**\\n\\n        r = x\\n        r = (r + x/r) / 2 while r*r > x\\n        r\\n\\n**Java and C#**\\n\\n        long r = x;\\n        while (r*r > x)\\n            r = (r + x/r) / 2;\\n        return (int) r;\\n\\n**JavaScript**\\n\\n        r = x;\\n        while (r*r > x)\\n            r = ((r + x/r) / 2) | 0;\\n        return r;\\n\\n---\\n\\n**Explanation**\\n\\nApparently, [using only integer division for the Newton method works](https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division). And I guessed that if I start at x, the root candidate will decrease monotonically and never get too small.\\n\\nThe above solutions all got accepted, and in C++ I also verified it locally on my PC for all possible inputs (0 to 2147483647):\\n\\n    #include <iostream>\\n    #include <climits>\\n    using namespace std;\\n    \\n    int mySqrt(int x) {\\n        long long r = x;\\n        while (r*r > x)\\n            r = (r + x/r) / 2;\\n        return r;\\n    }\\n    \\n    int main() {\\n        for (long long x=0; x<=INT_MAX; ++x) {\\n            long long r = mySqrt(x);\\n            if (r<0 || r*r > x || (r+1)*(r+1) <= x)\\n                cout << \"false: \" << x << \" \" << r << endl;\\n            if (x % 10000000 == 0)\\n                cout << x << endl;\\n        }\\n        cout << \"all checked\" << endl;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 25198,
                "title": "3-java-solutions-with-explanation",
                "content": "The three solutions are as the follows, solution1 and solution3 are pretty straight forward. \\n\\n     Look for the critical point: i * i <= x && (i+1)(i+1) > x\\n\\n A little trick is using i <=  x / i for comparison, instead of i * i <= x, to avoid exceeding integer upper limit.\\n\\n**Solution1 - Binary Search Solution: Time complexity = O(lg(x)) = O(32)=O(1)**\\n\\n\\n    public int mySqrt(int x) {\\n    \\tif (x == 0) return 0;\\n    \\tint start = 1, end = x;\\n    \\twhile (start < end) { \\n    \\t\\tint mid = start + (end - start) / 2;\\n    \\t\\tif (mid <= x / mid && (mid + 1) > x / (mid + 1))// Found the result\\n    \\t\\t\\treturn mid; \\n    \\t\\telse if (mid > x / mid)// Keep checking the left part\\n    \\t\\t\\tend = mid;\\n    \\t\\telse\\n    \\t\\t\\tstart = mid + 1;// Keep checking the right part\\n    \\t}\\n    \\treturn start;\\n    }\\n\\n**Solution2 - Newton Solution: Time complexity = O(lg(x))**\\n\\nI think Newton solution will not be faster than Solution1(Binary Search), because i = (i + x / i) / 2, the two factors i and x / i are with opposite trends. So time complexity in the best case is O(lgx). \\n\\n**Anyone can give the accurate time complexity? Appreciate it!**\\n\\n    public int mySqrt(int x) {\\n        if (x == 0) return 0;\\n    \\tlong i = x;\\n    \\twhile(i > x / i)  \\n    \\t\\ti = (i + x / i) / 2;\\t    \\t\\n    \\treturn (int)i;\\n    }\\n\\n**Solution3 - Brute Force: Time complexity = O(sqrt(x))**\\n\\n    public int mySqrt(int x) { \\n    \\tif (x == 0) return 0;\\n    \\tfor (int i = 1; i <= x / i; i++) \\t\\t\\n    \\t\\tif (i <= x / i && (i + 1) > x / (i + 1))// Look for the critical point: i*i <= x && (i+1)(i+1) > x\\n    \\t\\t\\treturn i;\\t\\t\\n    \\treturn -1;\\n    }",
                "solutionTags": [],
                "code": "The three solutions are as the follows, solution1 and solution3 are pretty straight forward. \\n\\n     Look for the critical point: i * i <= x && (i+1)(i+1) > x\\n\\n A little trick is using i <=  x / i for comparison, instead of i * i <= x, to avoid exceeding integer upper limit.\\n\\n**Solution1 - Binary Search Solution: Time complexity = O(lg(x)) = O(32)=O(1)**\\n\\n\\n    public int mySqrt(int x) {\\n    \\tif (x == 0) return 0;\\n    \\tint start = 1, end = x;\\n    \\twhile (start < end) { \\n    \\t\\tint mid = start + (end - start) / 2;\\n    \\t\\tif (mid <= x / mid && (mid + 1) > x / (mid + 1))// Found the result\\n    \\t\\t\\treturn mid; \\n    \\t\\telse if (mid > x / mid)// Keep checking the left part\\n    \\t\\t\\tend = mid;\\n    \\t\\telse\\n    \\t\\t\\tstart = mid + 1;// Keep checking the right part\\n    \\t}\\n    \\treturn start;\\n    }\\n\\n**Solution2 - Newton Solution: Time complexity = O(lg(x))**\\n\\nI think Newton solution will not be faster than Solution1(Binary Search), because i = (i + x / i) / 2, the two factors i and x / i are with opposite trends. So time complexity in the best case is O(lgx). \\n\\n**Anyone can give the accurate time complexity? Appreciate it!**\\n\\n    public int mySqrt(int x) {\\n        if (x == 0) return 0;\\n    \\tlong i = x;\\n    \\twhile(i > x / i)  \\n    \\t\\ti = (i + x / i) / 2;\\t    \\t\\n    \\treturn (int)i;\\n    }\\n\\n**Solution3 - Brute Force: Time complexity = O(sqrt(x))**\\n\\n    public int mySqrt(int x) { \\n    \\tif (x == 0) return 0;\\n    \\tfor (int i = 1; i <= x / i; i++) \\t\\t\\n    \\t\\tif (i <= x / i && (i + 1) > x / (i + 1))// Look for the critical point: i*i <= x && (i+1)(i+1) > x\\n    \\t\\t\\treturn i;\\t\\t\\n    \\treturn -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3212506,
                "title": "c-binary-search-easiest-beginner-friendly-sol",
                "content": "# Intuition of this Problem:\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. If x is 0, return 0.\\n2. Initialize first to 1 and last to x.\\n3. While first is less than or equal to last, do the following:\\n    a. Compute mid as first + (last - first) / 2.\\n    b. If mid * mid equals x, return mid.\\n    c. If mid * mid is greater than x, update last to mid - 1.\\n    d. If mid * mid is less than x, update first to mid + 1.\\n4. Return last.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        if (x == 0)\\n            return x;\\n        int first = 1, last = x;\\n        while (first <= last) {\\n            int mid = first + (last - first) / 2;\\n            // mid * mid == x gives runtime error\\n            if (mid  == x / mid)\\n                return mid;\\n            else if (mid > x / mid) {\\n                last = mid - 1;\\n            }\\n            else {\\n                first = mid + 1;\\n            }\\n        }\\n        return last;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int mySqrt(int x) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n        int first = 1, last = x;\\n        while (first <= last) {\\n            int mid = first + (last - first) / 2;\\n            if (mid == x / mid) {\\n                return mid;\\n            } else if (mid > x / mid) {\\n                last = mid - 1;\\n            } else {\\n                first = mid + 1;\\n            }\\n        }\\n        return last;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x == 0:\\n            return 0\\n        first, last = 1, x\\n        while first <= last:\\n            mid = first + (last - first) // 2\\n            if mid == x // mid:\\n                return mid\\n            elif mid > x // mid:\\n                last = mid - 1\\n            else:\\n                first = mid + 1\\n        return last\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(logn)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        if (x == 0)\\n            return x;\\n        int first = 1, last = x;\\n        while (first <= last) {\\n            int mid = first + (last - first) / 2;\\n            // mid * mid == x gives runtime error\\n            if (mid  == x / mid)\\n                return mid;\\n            else if (mid > x / mid) {\\n                last = mid - 1;\\n            }\\n            else {\\n                first = mid + 1;\\n            }\\n        }\\n        return last;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int mySqrt(int x) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n        int first = 1, last = x;\\n        while (first <= last) {\\n            int mid = first + (last - first) / 2;\\n            if (mid == x / mid) {\\n                return mid;\\n            } else if (mid > x / mid) {\\n                last = mid - 1;\\n            } else {\\n                first = mid + 1;\\n            }\\n        }\\n        return last;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x == 0:\\n            return 0\\n        first, last = 1, x\\n        while first <= last:\\n            mid = first + (last - first) // 2\\n            if mid == x // mid:\\n                return mid\\n            elif mid > x // mid:\\n                last = mid - 1\\n            else:\\n                first = mid + 1\\n        return last\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706594,
                "title": "easy-explained-solution-beats-100",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nWe want to find the square root of a given non-negative integer x. Instead of using a traditional approach like repeatedly subtracting numbers until we reach 0 or using a library function, we\\'ll use a smarter method called \"Binary Search.\" Binary Search helps us quickly find the square root by repeatedly narrowing down the search range.\\n\\n# Approach\\n1. We first check if x is 0 or 1. If it is, we know that the square root of 0 and 1 is 0 and 1 respectively, so we directly return x.\\n\\n1. For any other value of x, we set up a search range between 1 and x. We initialize two variables start and end to represent the range.\\n\\n1. Now comes the clever part: We use a while loop to repeatedly divide the search range in half (Binary Search) to find the square root.\\n\\n1. In each iteration of the loop, we calculate the middle value mid using the formula **start + (end - start) / 2**. This formula ensures that we don\\'t encounter any integer overflow when dealing with large values of x.\\n\\n1. Next, we calculate the square of mid and compare it with x.\\n\\n1. If the square of mid is greater than x, we know the square root lies in the lower half of the search range. So, we move the end pointer to the left to narrow down the search range.\\n\\n1. If the square of mid is equal to x, we have found the square root! So, we return mid as the answer.\\n\\n1. If the square of mid is less than x, we know the square root lies in the upper half of the search range. So, we move the start pointer to the right to continue the search.\\n\\n1. We repeat steps 4 to 8 until the start pointer becomes greater than the end pointer. At this point, we have found the floor value of the square root, and end holds that value.\\n\\n1. To ensure that we return the correct floor value of the square root, we round down the value of end to the nearest integer using the Math.round() method.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this approach is $$O(logN)$$. It\\'s very efficient because Binary Search reduces the search range by half in each iteration, making the search faster.\\n\\n- Space complexity:\\nThe space complexity is $$O(1)$$, which means the amount of extra memory used is constant, regardless of the input. We only use a few variables to store the search range and the middle value during the computation.\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int mySqrt(int x) {\\n        // For special cases when x is 0 or 1, return x.\\n        if (x == 0 || x == 1)\\n            return x;\\n\\n        // Initialize the search range for the square root.\\n        int start = 1;\\n        int end = x;\\n        int mid = -1;\\n\\n        // Perform binary search to find the square root of x.\\n        while (start <= end) {\\n            // Calculate the middle point using \"start + (end - start) / 2\" to avoid integer overflow.\\n            mid = start + (end - start) / 2;\\n\\n            // If the square of the middle value is greater than x, move the \"end\" to the left (mid - 1).\\n            if ((long) mid * mid > (long) x)\\n                end = mid - 1;\\n            else if (mid * mid == x)\\n                // If the square of the middle value is equal to x, we found the square root.\\n                return mid;\\n            else\\n                // If the square of the middle value is less than x, move the \"start\" to the right (mid + 1).\\n                start = mid + 1;\\n        }\\n\\n        // The loop ends when \"start\" becomes greater than \"end\", and \"end\" is the integer value of the square root.\\n        // However, since we might have been using integer division in the calculations,\\n        // we round down the value of \"end\" to the nearest integer to get the correct square root.\\n        return Math.round(end);\\n    }\\n}\\n\\n```\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        // For special cases when x is 0 or 1, return x.\\n        if (x == 0 || x == 1)\\n            return x;\\n        \\n        // Initialize the search range for the square root.\\n        int start = 1;\\n        int end = x;\\n        int mid = -1;\\n        \\n        // Perform binary search to find the square root of x.\\n        while (start <= end) {\\n            // Calculate the middle point using \"start + (end - start) / 2\" to avoid integer overflow.\\n            mid = start + (end - start) / 2;\\n            \\n            // Convert mid to long to handle large values without overflow.\\n            long long square = static_cast<long long>(mid) * mid;\\n            \\n            // If the square of the middle value is greater than x, move the \"end\" to the left (mid - 1).\\n            if (square > x)\\n                end = mid - 1;\\n            else if (square == x)\\n                // If the square of the middle value is equal to x, we found the square root.\\n                return mid;\\n            else\\n                // If the square of the middle value is less than x, move the \"start\" to the right (mid + 1).\\n                start = mid + 1;\\n        }\\n        \\n        // The loop ends when \"start\" becomes greater than \"end\", and \"end\" is the integer value of the square root.\\n        // However, since we might have been using integer division in the calculations,\\n        // we round down the value of \"end\" to the nearest integer to get the correct square root.\\n        return static_cast<int>(std::round(end));\\n    }\\n};\\n```\\n## ***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/3fc6215b-c7f4-4c0a-a984-cf5e7cadbaa9_1688235529.8419888.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Math",
                    "Binary Search"
                ],
                "code": "```java []\\nclass Solution {\\n    public int mySqrt(int x) {\\n        // For special cases when x is 0 or 1, return x.\\n        if (x == 0 || x == 1)\\n            return x;\\n\\n        // Initialize the search range for the square root.\\n        int start = 1;\\n        int end = x;\\n        int mid = -1;\\n\\n        // Perform binary search to find the square root of x.\\n        while (start <= end) {\\n            // Calculate the middle point using \"start + (end - start) / 2\" to avoid integer overflow.\\n            mid = start + (end - start) / 2;\\n\\n            // If the square of the middle value is greater than x, move the \"end\" to the left (mid - 1).\\n            if ((long) mid * mid > (long) x)\\n                end = mid - 1;\\n            else if (mid * mid == x)\\n                // If the square of the middle value is equal to x, we found the square root.\\n                return mid;\\n            else\\n                // If the square of the middle value is less than x, move the \"start\" to the right (mid + 1).\\n                start = mid + 1;\\n        }\\n\\n        // The loop ends when \"start\" becomes greater than \"end\", and \"end\" is the integer value of the square root.\\n        // However, since we might have been using integer division in the calculations,\\n        // we round down the value of \"end\" to the nearest integer to get the correct square root.\\n        return Math.round(end);\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        // For special cases when x is 0 or 1, return x.\\n        if (x == 0 || x == 1)\\n            return x;\\n        \\n        // Initialize the search range for the square root.\\n        int start = 1;\\n        int end = x;\\n        int mid = -1;\\n        \\n        // Perform binary search to find the square root of x.\\n        while (start <= end) {\\n            // Calculate the middle point using \"start + (end - start) / 2\" to avoid integer overflow.\\n            mid = start + (end - start) / 2;\\n            \\n            // Convert mid to long to handle large values without overflow.\\n            long long square = static_cast<long long>(mid) * mid;\\n            \\n            // If the square of the middle value is greater than x, move the \"end\" to the left (mid - 1).\\n            if (square > x)\\n                end = mid - 1;\\n            else if (square == x)\\n                // If the square of the middle value is equal to x, we found the square root.\\n                return mid;\\n            else\\n                // If the square of the middle value is less than x, move the \"start\" to the right (mid + 1).\\n                start = mid + 1;\\n        }\\n        \\n        // The loop ends when \"start\" becomes greater than \"end\", and \"end\" is the integer value of the square root.\\n        // However, since we might have been using integer division in the calculations,\\n        // we round down the value of \"end\" to the nearest integer to get the correct square root.\\n        return static_cast<int>(std::round(end));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25061,
                "title": "python-binary-search-solution-o-lgn",
                "content": "```\\nclass Solution(object):\\n    def mySqrt(self, x):\\n        l, r = 0, x\\n        while l <= r:\\n            mid = l + (r-l)//2\\n            if mid * mid <= x < (mid+1)*(mid+1):\\n                return mid\\n            elif x < mid * mid:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution(object):\\n    def mySqrt(self, x):\\n        l, r = 0, x\\n        while l <= r:\\n            mid = l + (r-l)//2\\n            if mid * mid <= x < (mid+1)*(mid+1):\\n                return mid\\n            elif x < mid * mid:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25048,
                "title": "share-my-o-log-n-solution-using-bit-manipulation",
                "content": "## Basic Idea: ##\\n\\n----------\\nSince sqrt(x) is composed of binary bits, I calculate sqrt(x) by deciding every bit from the most significant to least significant. **Since an integer n can have O(log n) bits with each bit decided within constant time, this algorithm has time limit O(log n), actually, because an Integer can have at most 32 bits, I can also say this algorithm takes O(32)=O(1) time.**\\n\\n----------\\n  \\n\\n     public int sqrt(int x) {\\n        if(x==0)\\n            return 0;\\n        int h=0;\\n        while((long)(1<<h)*(long)(1<<h)<=x) // firstly, find the most significant bit\\n            h++;\\n        h--;\\n        int b=h-1;\\n        int res=(1<<h);\\n        while(b>=0){  // find the remaining bits\\n            if((long)(res | (1<<b))*(long)(res |(1<<b))<=x)\\n                res|=(1<<b);\\n            b--;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "## Basic Idea: ##\\n\\n----------\\nSince sqrt(x) is composed of binary bits, I calculate sqrt(x) by deciding every bit from the most significant to least significant. **Since an integer n can have O(log n) bits with each bit decided within constant time, this algorithm has time limit O(log n), actually, because an Integer can have at most 32 bits, I can also say this algorithm takes O(32)=O(1) time.**\\n\\n----------\\n  \\n\\n     public int sqrt(int x) {\\n        if(x==0)\\n            return 0;\\n        int h=0;\\n        while((long)(1<<h)*(long)(1<<h)<=x) // firstly, find the most significant bit\\n            h++;\\n        h--;\\n        int b=h-1;\\n        int res=(1<<h);\\n        while(b>=0){  // find the remaining bits\\n            if((long)(res | (1<<b))*(long)(res |(1<<b))<=x)\\n                res|=(1<<b);\\n            b--;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 25066,
                "title": "solve-this-problem-with-binary-search",
                "content": "    class Solution {\\n    public:\\n        int sqrt(int x) {\\n            if (0 == x) return 0;\\n            int left = 1, right = x, ans;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                if (mid <= x / mid) {\\n                    left = mid + 1;\\n                    ans = mid;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            }\\n            return ans;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int sqrt(int x) {\\n            if (0 == x) return 0;\\n            int left = 1, right = x, ans;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                if (mid <= x / mid) {\\n                    left = mid + 1;\\n                    ans = mid;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 553452,
                "title": "c-binary-search-approach-runtime-0ms-faster-than-100",
                "content": "As stated this approach gives:\\nRuntime: 0ms.\\nFaster than 100% of C++ online submission (*as of date posted*).\\n\\n**Time Complexity:** O(logn) | due to binary search using while loop.\\n**Space Complexity:** O(1) | as only 4 variables are initialized at the beginning. Which is constant irrespective of given input.\\n\\n```\\nlong long s=0, e=x, ans, mid;   //long long due to some of test cases overflows integer limit.\\n        while(s<=e){             \\n            mid=(s+e)/2;\\n            if(mid*mid==x) return mid;     //if the \\'mid\\' value ever gives the result, we simply return it.\\n            else if(mid*mid<x){             \\n                s=mid+1;        //if \\'mid\\' value encounterted gives lower result, we simply discard all the values lower than mid.\\n                ans=mid;        //an extra pointer \\'ans\\' is maintained to keep track of only lowest \\'mid\\' value. \\n            }\\n            else e=mid-1;       //if \\'mid\\' value encountered gives greater result, we simply discard all the values greater than mid. \\n        }\\n        return ans;   \\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nlong long s=0, e=x, ans, mid;   //long long due to some of test cases overflows integer limit.\\n        while(s<=e){             \\n            mid=(s+e)/2;\\n            if(mid*mid==x) return mid;     //if the \\'mid\\' value ever gives the result, we simply return it.\\n            else if(mid*mid<x){             \\n                s=mid+1;        //if \\'mid\\' value encounterted gives lower result, we simply discard all the values lower than mid.\\n                ans=mid;        //an extra pointer \\'ans\\' is maintained to keep track of only lowest \\'mid\\' value. \\n            }\\n            else e=mid-1;       //if \\'mid\\' value encountered gives greater result, we simply discard all the values greater than mid. \\n        }\\n        return ans;   \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3093338,
                "title": "2-approaches-using-linear-search-and-binary-search",
                "content": "\\n# Approach 1(Using Linear Search)\\n<!-- Describe your approach to solving the problem. -->\\nIt uses a for loop to iterate through the numbers from 1 to x/i. If the number is found, then it returns that number. Otherwise, it returns i-1.\\n### Note 1:\\nHere we are returning (i-1) because at some point (i*i) became greater than x and loop stopped!!!\\n### Note 2:\\nHere we are using division instead of multiplication to avoid integer overflow.\\n\\n\\n# Complexity\\n- Time complexity: $$O(sqrt(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        if(x==0) return 0;\\n        int i=1;\\n        for(;i<=x/i;i++) //using division instead of multiplication to avoid integer overflow\\n            if(x/i==i)  return i;\\n        return i-1; //returning (i-1) because at some point (i*i) became greater than x and loop stopped!!!\\n    }\\n}\\n```\\n\\n# Approach 2(Using Binary Search)\\n<!-- Describe your approach to solving the problem. -->\\nIt uses a binary search algorithm to find the square root of a number.\\n\\n# Complexity\\n- Time complexity: $$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        if(x==0) return 0;\\n        int low = 1,high = x,ans =0;\\n        while(low<=high){\\n            int mid =low + (high-low)/2;\\n            if(x/mid==mid)  return mid;\\n            else if(x/mid<mid)   high=mid-1;\\n            else {low = mid+1; ans = mid;}\\n        }\\n        return ans;\\n    }\\n}\\n```\\n### Upvote me if you find the solution helpful",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        if(x==0) return 0;\\n        int i=1;\\n        for(;i<=x/i;i++) //using division instead of multiplication to avoid integer overflow\\n            if(x/i==i)  return i;\\n        return i-1; //returning (i-1) because at some point (i*i) became greater than x and loop stopped!!!\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        if(x==0) return 0;\\n        int low = 1,high = x,ans =0;\\n        while(low<=high){\\n            int mid =low + (high-low)/2;\\n            if(x/mid==mid)  return mid;\\n            else if(x/mid<mid)   high=mid-1;\\n            else {low = mid+1; ans = mid;}\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860465,
                "title": "simple-java-solution-with-comments-1ms-o-log-n",
                "content": "**Approach:**\\n- Intuitive Brute force solution would be `O(n)` as we check every element from `0` to `x/2`\\n- The next better time complexity we can target it `O(logN)` which suggests at using binary search.\\n\\n**Algorithm:**\\n- start with a range between `1 to x/2` (square root of any number can not be greater than half of the number)\\n- find the mid point and calculate the `x/mid` as `quotient`\\n\\t- we go for division instead of multiplication to avoid unwanted overflow\\n- If `quotient == mid`; we have our answer\\n- If `quotient > mid`;  move start to `mid`; not to `mid + 1` as `mid` might be a valid answer\\n- if `quotient < mid`; move end to `mid-1`\\n\\n```\\n// using binary search\\nclass Solution {\\n    public int mySqrt(int x) {\\n        if(x <= 1) return x;\\n        int start = 1;\\n        int end = x/2;\\n        \\n        while(start < end) {\\n            // start is not always moving and hence we can get stuck in infinite loop with mid calculation\\n            // Adding 1 to mid everytime to ensure we always move the mid\\n            int mid = (start + (end-start)/2) + 1;\\n            \\n            // use division instead of multiplication to avoid overflow\\n            int div = x/mid;\\n            if(div == mid) return mid;\\n            if(div > mid) start = mid;\\n            else end = mid-1;\\n        }\\n        \\n        return start;\\n    }\\n}\\n```\\n\\n**Please Vote up, if this helped you!!**\\n\\nHappy Coding!! :)",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n// using binary search\\nclass Solution {\\n    public int mySqrt(int x) {\\n        if(x <= 1) return x;\\n        int start = 1;\\n        int end = x/2;\\n        \\n        while(start < end) {\\n            // start is not always moving and hence we can get stuck in infinite loop with mid calculation\\n            // Adding 1 to mid everytime to ensure we always move the mid\\n            int mid = (start + (end-start)/2) + 1;\\n            \\n            // use division instead of multiplication to avoid overflow\\n            int div = x/mid;\\n            if(div == mid) return mid;\\n            if(div > mid) start = mid;\\n            else end = mid-1;\\n        }\\n        \\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 344755,
                "title": "python-solution-with-binary-search",
                "content": "```python\\n    def mySqrt(self, x):\\n        lo, hi = 0, x\\n        \\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            \\n            if mid * mid > x:\\n                hi = mid - 1\\n            elif mid * mid < x:\\n                lo = mid + 1\\n            else:\\n                return mid\\n        \\n        # When there is no perfect square, hi is the the value on the left\\n        # of where it would have been (rounding down). If we were rounding up, \\n        # we would return lo\\n        return hi\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```python\\n    def mySqrt(self, x):\\n        lo, hi = 0, x\\n        \\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            \\n            if mid * mid > x:\\n                hi = mid - 1\\n            elif mid * mid < x:\\n                lo = mid + 1\\n            else:\\n                return mid\\n        \\n        # When there is no perfect square, hi is the the value on the left\\n        # of where it would have been (rounding down). If we were rounding up, \\n        # we would return lo\\n        return hi\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 25255,
                "title": "newton-s-iterative-method-in-c",
                "content": "    int sqrt(int x) {\\n        double ans    = x;\\n        double delta  = 0.0001;\\n        while (fabs(pow(ans, 2) - x) > delta) {\\n            ans = (ans + x / ans) / 2;\\n        }\\n        return ans;\\n    }\\n\\nThe key point is the average result is calculate by \"ans = (ans + x / ans) / 2\";\\n\\nFor instance, when calculate sqrt(2) :\\n\\n       Guess Result        Quotient                             Average Result\\n              1          2 / 1 = 2                            (2 + 1) / 2 = 1.5\\n             1.5      2 / 1.5 = 1.3333                (1.3333 + 1.5) / 2 = 1.4167\\n           1.4167    2 / 1.4167 = 1.4118          (1.4167 + 1.4118) / 2 = 1.4142\\n            ... ...",
                "solutionTags": [],
                "code": "    int sqrt(int x) {\\n        double ans    = x;\\n        double delta  = 0.0001;\\n        while (fabs(pow(ans, 2) - x) > delta) {\\n            ans = (ans + x / ans) / 2;\\n        }\\n        return ans;\\n    }\\n\\nThe key point is the average result is calculate by \"ans = (ans + x / ans) / 2\";\\n\\nFor instance, when calculate sqrt(2) :\\n\\n       Guess Result        Quotient                             Average Result\\n              1          2 / 1 = 2                            (2 + 1) / 2 = 1.5\\n             1.5      2 / 1.5 = 1.3333                (1.3333 + 1.5) / 2 = 1.4167\\n           1.4167    2 / 1.4167 = 1.4118          (1.4167 + 1.4118) / 2 = 1.4142\\n            ... ...",
                "codeTag": "Unknown"
            },
            {
                "id": 25167,
                "title": "easy-to-understand-javascript-solution",
                "content": "Just simple binary search.\\n\\nRemember that the square root of each X must happen within [1, x/2 + 1]\\n\\nSo we can cut half at the first place.\\n\\n      var mySqrt = function(x) {\\n      var left = 1;\\n      var right = Math.floor(x / 2) + 1;\\n      var mid;\\n    \\n      while (left <= right) {\\n        mid = Math.floor((left + right) / 2);\\n    \\n        if (mid * mid > x) {\\n          right = mid - 1;\\n        } else if (mid * mid < x) {\\n          left = mid + 1;\\n        } else {\\n          return mid;\\n        }\\n      }\\n    \\n      return right;\\n    };\\n\\nThe tricky point is that we will return `right` if there is no square root found.\\n\\nThe reason is the square root is between [n-1, n] and we can know that when `while` is broken `right` must be n-1",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "Just simple binary search.\\n\\nRemember that the square root of each X must happen within [1, x/2 + 1]\\n\\nSo we can cut half at the first place.\\n\\n      var mySqrt = function(x) {\\n      var left = 1;\\n      var right = Math.floor(x / 2) + 1;\\n      var mid;\\n    \\n      while (left <= right) {\\n        mid = Math.floor((left + right) / 2);\\n    \\n        if (mid * mid > x) {\\n          right = mid - 1;\\n        } else if (mid * mid < x) {\\n          left = mid + 1;\\n        } else {\\n          return mid;\\n        }\\n      }\\n    \\n      return right;\\n    };\\n\\nThe tricky point is that we will return `right` if there is no square root found.\\n\\nThe reason is the square root is between [n-1, n] and we can know that when `while` is broken `right` must be n-1",
                "codeTag": "Unknown"
            },
            {
                "id": 3317131,
                "title": "4-lines-of-code-binary-search-approach-and-normal-approach",
                "content": "\\n\\n# 1. Normal Math Approach\\n```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        number=1\\n        while number*number<=x:\\n            number+=1\\n        return number\\n\\n```\\n# Binary Search Approach\\n```\\n\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        left,right=1,x\\n        while left<=right:\\n            mid=(left+right)//2\\n            if mid*mid==x:\\n                return mid\\n            if mid*mid>x:\\n                right=mid-1\\n            else:\\n                left=mid+1\\n        return right\\n    \\n\\n```\\n# please upvote me it would encourage me alot\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        number=1\\n        while number*number<=x:\\n            number+=1\\n        return number\\n\\n```\n```\\n\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        left,right=1,x\\n        while left<=right:\\n            mid=(left+right)//2\\n            if mid*mid==x:\\n                return mid\\n            if mid*mid>x:\\n                right=mid-1\\n            else:\\n                left=mid+1\\n        return right\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2438966,
                "title": "java-1ms-100-faster-than-all-submission-using-binary-search-beginner-friendly-code",
                "content": "**Please UPVOTE if you like it\\nHappy coding**\\n```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        if(x == 0){\\n            return 0;\\n        }\\n        int start = 1;\\n        int end = x;\\n        int ans = 0;\\n        while(start <= end){\\n            int mid = start + (end-start)/2;\\n\\t\\t\\t//instead of mid*mid we are giving x/mid to tackle overflow of integer range when multiplying with bigger numbers\\n            if(mid <= x/mid){\\n                ans = mid;\\n                start = mid + 1;\\n            }else{\\n                end = mid -1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        if(x == 0){\\n            return 0;\\n        }\\n        int start = 1;\\n        int end = x;\\n        int ans = 0;\\n        while(start <= end){\\n            int mid = start + (end-start)/2;\\n\\t\\t\\t//instead of mid*mid we are giving x/mid to tackle overflow of integer range when multiplying with bigger numbers\\n            if(mid <= x/mid){\\n                ans = mid;\\n                start = mid + 1;\\n            }else{\\n                end = mid -1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352725,
                "title": "solutions-without-math-sqrt-o-log10-n-included",
                "content": "I see that alot of solutions here using Math.pow() or Math.sqrt(), which you are not supposed to do in real interview, because it\\'s the whole point - think of algorithm yourself.\\nSo I\\'ll provide three solutions - from slowest and easiest to fastest and most complex.\\n___\\n**Solution 1.**\\nFirst solution is pretty simple. Because we can truncate decimal digits, we can be sure that answer will always be integer number, so we can just try every number until we hit our target:\\n```\\nconst mySqrt = function(x) {\\n    let result = 1;\\n    while (result*result <= x) result++;\\n    return result - 1;\\n};\\n```\\nHere we start from `1` and increase it until we will encounter a point where `target*target > x`. Then, because we overshot our target by 1, we return `result - 1`.\\nTime complexity is **O(sqrt(n))**.\\n___\\n**Solution 2.**\\nThis solution essentially does the same as a first algorithm, but it uses binary search instead.\\n```\\nconst mySqrt = function(x) {\\n    let start = 0;\\n    let end = x;\\n    let res = 0;\\n    while (start < end) {\\n        res = Math.ceil((start + end)/2); // 1.\\n        if (res*res <= x && (res + 1)*(res + 1) > x) return res; // 2.\\n        if (res*res < x) start = res; // 3.\\n        else end = res; // 4.\\n    }\\n    return res;\\n};\\n```\\nIt starts search in `[0, x]`, then takes following steps:\\n1) It takes number in the middle: `res = Math.ceil((start + end)/2)`.\\n2) Checks if `res` is the number we need - it will happen only if `res^2 <= x` AND `(res + 1)^2 > x`. Return if correct.\\n3) Otherwise check if it overshot target or not. If not, reduce search segment to `[res, end]` (i.e. it now knows that every number before `res` will be less than number we search, so it now searches only for numbers of `res` or higher).\\n4) Else if it overshot, search in segment `[start, res]`.\\n5) Repeat until required number found.\\n\\nTime complexity is **O(log2(n))**.\\n___\\n**Solution 3.**\\nIt\\'s the fastest solution for long numbers. For short numbers it will work slower, but eventually it will become faster and also works for *very* big numbers.\\n*Another benefit of this algorithm is that with couple changed lines it can find decimal part of the answer with any precision.*\\nI will not explain this algorithm, but will provide link for explanation and example, as well as comments for my code where it will walk through algorithm on example from link.\\nHere\\'s explanation: https://www.homeschoolmath.net/teaching/square-root-algorithm.php.\\nNote that 3 first panels in example from link is enough for us because we don\\'t need decimal numbers.\\nNow here\\'s whole code:\\n```\\n/** https://www.homeschoolmath.net/teaching/square-root-algorithm.php\\n * @param {number} x Number to find square root from\\n * @return {number} Truncated square root result\\n */\\nconst mySqrt = function(x) {\\n    // quotient is a result which we assemble during for loop\\n    // divisor is number in brackets from example (e.g. (45))\\n    // dividend is number we get after subtraction (e.g. 2 after 6 - 4 in example)\\n    \\n    // Prepare first iteration (calculate values for the first pair)\\n    const source = cutString(String(x)); // Convert to array of pairs\\n    let quotient = String(findSqrt(source[0])); // Get square root of first pair. It\\'s the first number of the answer\\n    let dividend = (source[0] - quotient*quotient); // 2 in example (result of 6 - 4)\\n    \\n    // This for loop works for all pairs except of first (which was processed above)\\n    for (let i = 1; i < source.length; i++) {\\n        dividend = dividend + source[i]; // add next pair\\n        let tempD = String(findClosest(quotient*2, dividend)); // _ in example (in 4_)\\n        const divisor = String(quotient*2) + tempD; // actual divisor (where 4_ became 45)\\n        dividend = dividend - (divisor * tempD); // perform subtraction\\n        quotient += tempD; // finally get new quotient (result) for current iteration\\n    }    \\n    return quotient;\\n};\\n\\n/** Used to cut string in pairs\\n * @param {string} str String to cut in pairs\\n * @return {string[]} Array with pairs in it (first element can be single digit)\\n */\\nfunction cutString(str) {\\n    const chunks = [str.substr(0, 2 - str.length%2)];\\n\\tstr = str.substr(2 - str.length%2);\\n    const length = Math.ceil(str.length / 2);\\n    for (let i = 0; i < length; i++) {\\n        chunks.push(str.substr(i*2, 2));\\n    }\\n    return chunks;\\n}\\n\\n/** Used to find first square root (binary search will be slower here)\\n * @param {number} num Number to find square root from\\n * @return {string[]} Square root result\\n */\\nfunction findSqrt(num) {\\n    let result = 1;\\n    while (result*result <= num) result++;\\n    return result - 1;\\n};\\n\\n/** Used to find _ (*something* from example) (binary search will be slower here as well)\\n * @param {number} num Number to find last digit (123_)\\n * @param {number} target Number to use as target\\n * @return {number} Result in _, that justifies expression\\n */\\nfunction findClosest(num, target) {\\n    let result = 0;\\n    while ((num*10 + result) * result <= target) result++;\\n    return result - 1;\\n}\\n```\\nTime complexity is **O(log10(n))** (O(log10(n)/2) to be precise, but constants usually dropped for time complexity).",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nconst mySqrt = function(x) {\\n    let result = 1;\\n    while (result*result <= x) result++;\\n    return result - 1;\\n};\\n```\n```\\nconst mySqrt = function(x) {\\n    let start = 0;\\n    let end = x;\\n    let res = 0;\\n    while (start < end) {\\n        res = Math.ceil((start + end)/2); // 1.\\n        if (res*res <= x && (res + 1)*(res + 1) > x) return res; // 2.\\n        if (res*res < x) start = res; // 3.\\n        else end = res; // 4.\\n    }\\n    return res;\\n};\\n```\n```\\n/** https://www.homeschoolmath.net/teaching/square-root-algorithm.php\\n * @param {number} x Number to find square root from\\n * @return {number} Truncated square root result\\n */\\nconst mySqrt = function(x) {\\n    // quotient is a result which we assemble during for loop\\n    // divisor is number in brackets from example (e.g. (45))\\n    // dividend is number we get after subtraction (e.g. 2 after 6 - 4 in example)\\n    \\n    // Prepare first iteration (calculate values for the first pair)\\n    const source = cutString(String(x)); // Convert to array of pairs\\n    let quotient = String(findSqrt(source[0])); // Get square root of first pair. It\\'s the first number of the answer\\n    let dividend = (source[0] - quotient*quotient); // 2 in example (result of 6 - 4)\\n    \\n    // This for loop works for all pairs except of first (which was processed above)\\n    for (let i = 1; i < source.length; i++) {\\n        dividend = dividend + source[i]; // add next pair\\n        let tempD = String(findClosest(quotient*2, dividend)); // _ in example (in 4_)\\n        const divisor = String(quotient*2) + tempD; // actual divisor (where 4_ became 45)\\n        dividend = dividend - (divisor * tempD); // perform subtraction\\n        quotient += tempD; // finally get new quotient (result) for current iteration\\n    }    \\n    return quotient;\\n};\\n\\n/** Used to cut string in pairs\\n * @param {string} str String to cut in pairs\\n * @return {string[]} Array with pairs in it (first element can be single digit)\\n */\\nfunction cutString(str) {\\n    const chunks = [str.substr(0, 2 - str.length%2)];\\n\\tstr = str.substr(2 - str.length%2);\\n    const length = Math.ceil(str.length / 2);\\n    for (let i = 0; i < length; i++) {\\n        chunks.push(str.substr(i*2, 2));\\n    }\\n    return chunks;\\n}\\n\\n/** Used to find first square root (binary search will be slower here)\\n * @param {number} num Number to find square root from\\n * @return {string[]} Square root result\\n */\\nfunction findSqrt(num) {\\n    let result = 1;\\n    while (result*result <= num) result++;\\n    return result - 1;\\n};\\n\\n/** Used to find _ (*something* from example) (binary search will be slower here as well)\\n * @param {number} num Number to find last digit (123_)\\n * @param {number} target Number to use as target\\n * @return {number} Result in _, that justifies expression\\n */\\nfunction findClosest(num, target) {\\n    let result = 0;\\n    while ((num*10 + result) * result <= target) result++;\\n    return result - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25130,
                "title": "my-clean-c-code-8ms",
                "content": "Binary search and high is always converged to the one that 1 larger than the result.\\n\\n    class Solution {\\n    public:\\n        int mySqrt(int x) {\\n            int low = 0,  high = x, mid;\\n            if(x<2) return x; // to avoid mid = 0\\n            while(low<high)\\n            {\\n                mid = (low + high)/2;\\n                if(x/mid >= mid) low = mid+1;\\n                else high = mid;\\n            }\\n            return high-1;\\n            \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int mySqrt(int x) {\\n            int low = 0,  high = x, mid;\\n            if(x<2) return x; // to avoid mid = 0\\n            while(low<high)\\n            {\\n                mid = (low + high)/2;\\n                if(x/mid >= mid) low = mid+1;\\n                else high = mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 359172,
                "title": "python-newton-solution",
                "content": "# Idea\\n\\nThe idea is that Newton is a root finding algorithm. By root finding we mean find a value `x` such that a given function `f(x) = 0`. \\n\\nTo use this technique we need to first define a function for which the root is the square root of our integer. \\n\\n```python\\nf(x) = x**2 - n \\n```\\n\\nYou can easily convince yourself that `sqrt(n)` is a root.\\n\\n```python\\nf(sqrt(n)) = sqrt(n)**2 - n  = n - n = 0\\n```\\n\\n# How does the Newton method work?\\nWe need to start with an approximation of the root say `x1 = x/2` and refine our estimate of the root iteratively. To do so we take the intersection of the tangent at our current root estimate and the x-axis see below.\\n\\n<img src=\"https://assets.leetcode.com/users/amchoukir/image_1565868791.png\" alt=\"drawing\" width=\"400\"/>\\n\\n<img src=\"https://assets.leetcode.com/users/amchoukir/image_1565868822.png\" alt=\"drawing\" width=\"400\"/>\\n\\n<img src=\"https://assets.leetcode.com/users/amchoukir/image_1565868861.png\" alt=\"drawing\" width=\"400\"/>\\n\\n<img src=\"https://assets.leetcode.com/users/amchoukir/image_1565868896.png\" alt=\"drawing\" width=\"400\"/>\\n\\n\\nTaken from wikipedia: https://en.wikipedia.org/wiki/Newton%27s_method\\n\\n# How can we derive the update equation?\\nThe tangent at our initial estimate is of the form `y = a * x + b`, basically the equation of line. The slope of the line is given by the derivative at our initial estimate.\\n\\n```python\\nf(x) = x**2 - n\\ndf(x) = 2 * x\\na = df(x1) = 2 * x1\\n```\\n\\nTo find `b` we can use the fact we already a point on the line `f(x1)` at `x1`\\n\\n```python\\nf(x1) = df(x1) * x1 + b\\nb = f(x1) - df(x1) * x1\\n```\\n\\nPutting it all together\\n\\n```python\\ny = df(x1) * x + (f(x1) - df(x1) * x1)\\n```\\n\\nNow we are looking for the intersection with the x-axis\\n\\n```python\\n0 = df(x1) * x2 + (f(x1) - df(x1) * x1)\\nx2 = (df(x1) * x1 - f(x1))/df(x1)\\nx2 = x1  -  f(x1)/df(x1)\\nx2 = x1 - (x1**2 - n)/(2 * x1)\\nx2 = (2 * x1**2 - x1**2 + n)/(2 * x1)\\nx2 = (x1**2 + n)/(2 * x1)\\nx2 = (1/2) * (x1 + n/x1)\\n```\\n\\nGeneralyzing to any update\\n\\n```python\\nx_new = (1/2) * ( x_current + n/x_current)\\n```\\n\\n## In case you are wondering why the derivative is the slope of the tangent at our estimate\\n\\nThe derivative is defined as\\n\\n```python\\ndf(x) = lim(\\u2206x->0) (f(x + \\u2206x) - f(x))/\\u2206x\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/amchoukir/image_1565870151.png)\\n\\n# Code\\n```python\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        x_previous = x\\n        x_current = x / 2\\n        precision = 0.1\\n        while abs(x_previous - x_current) > precision:\\n            x_previous = x_current\\n            x_current = (1/2) * (x_current + x/x_current)\\n            \\n        return int(x_current)\\n```",
                "solutionTags": [],
                "code": "```python\\nf(x) = x**2 - n \\n```\n```python\\nf(sqrt(n)) = sqrt(n)**2 - n  = n - n = 0\\n```\n```python\\nf(x) = x**2 - n\\ndf(x) = 2 * x\\na = df(x1) = 2 * x1\\n```\n```python\\nf(x1) = df(x1) * x1 + b\\nb = f(x1) - df(x1) * x1\\n```\n```python\\ny = df(x1) * x + (f(x1) - df(x1) * x1)\\n```\n```python\\n0 = df(x1) * x2 + (f(x1) - df(x1) * x1)\\nx2 = (df(x1) * x1 - f(x1))/df(x1)\\nx2 = x1  -  f(x1)/df(x1)\\nx2 = x1 - (x1**2 - n)/(2 * x1)\\nx2 = (2 * x1**2 - x1**2 + n)/(2 * x1)\\nx2 = (x1**2 + n)/(2 * x1)\\nx2 = (1/2) * (x1 + n/x1)\\n```\n```python\\nx_new = (1/2) * ( x_current + n/x_current)\\n```\n```python\\ndf(x) = lim(\\u2206x->0) (f(x + \\u2206x) - f(x))/\\u2206x\\n```\n```python\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        x_previous = x\\n        x_current = x / 2\\n        precision = 0.1\\n        while abs(x_previous - x_current) > precision:\\n            x_previous = x_current\\n            x_current = (1/2) * (x_current + x/x_current)\\n            \\n        return int(x_current)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994246,
                "title": "effective-binary-search-algorithm-java",
                "content": "# Approach\\nSearch needed number using binary search algorithm\\n\\n# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int l = 1;\\n        int r = x;\\n\\n        while(l <= r){\\n            int mid = (l + r) / 2;\\n\\n            if(x / mid == mid){\\n                return mid;\\n            } else if(mid > x / mid){\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int l = 1;\\n        int r = x;\\n\\n        while(l <= r){\\n            int mid = (l + r) / 2;\\n\\n            if(x / mid == mid){\\n                return mid;\\n            } else if(mid > x / mid){\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25068,
                "title": "share-my-2ms-and-4lines-java-code",
                "content": "My idea is, for any non-negative number N, sqrt(N) = 2/2*sqrt(N) =2*sqrt(1/4)*sqrt(N) = 2*sqrt(N/4). And for the Ns that are not multiple of 4, for example, 9, 25 or 49, the actual result should be 1+2*sqrt(N/4), because we need to take remainders into account.\\n\\n    public int mySqrt(int x) {\\n        if(x < 4) return x == 0 ? 0 : 1;\\n        int res = 2 * mySqrt(x/4);\\n        if((res+1) * (res+1) <= x && (res+1) * (res+1) >= 0) return res+1;\\n        return res;\\n    }\\n\\nHope it helps.",
                "solutionTags": [],
                "code": "My idea is, for any non-negative number N, sqrt(N) = 2/2*sqrt(N) =2*sqrt(1/4)*sqrt(N) = 2*sqrt(N/4). And for the Ns that are not multiple of 4, for example, 9, 25 or 49, the actual result should be 1+2*sqrt(N/4), because we need to take remainders into account.\\n\\n    public int mySqrt(int x) {\\n        if(x < 4) return x == 0 ? 0 : 1;\\n        int res = 2 * mySqrt(x/4);\\n        if((res+1) * (res+1) <= x && (res+1) * (res+1) >= 0) return res+1;\\n        return res;\\n    }\\n\\nHope it helps.",
                "codeTag": "Unknown"
            },
            {
                "id": 25065,
                "title": "share-java-log-n-solution-no-need-to-change-type",
                "content": "    public class Solution {\\n        public int mySqrt(int x) {\\n            if(x <= 0) return 0;\\n            int l = 1, r = x, res = 1;\\n            while(l < r) {\\n                int mid = (l + r) / 2;\\n                if(mid > x/mid) {\\n                    r = mid;\\n                } else {\\n                    res = mid;\\n                    l = mid + 1;\\n                }\\n            }\\n            return res;\\n        }\\n    }\\n\\nUsing  x / mid to avoid overflow of Integer. l means left, r means right. Always have a variable res to maintain the result.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int mySqrt(int x) {\\n            if(x <= 0) return 0;\\n            int l = 1, r = x, res = 1;\\n            while(l < r) {\\n                int mid = (l + r) / 2;\\n                if(mid > x/mid) {\\n                    r = mid;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3067835,
                "title": "c-solution-based-on-visual-representation-for-perfect-square-roots",
                "content": "# Intuition\\n\\nThe idea behind this approach is to use the mathematical property that the sum of the first n odd numbers is n^2, and use this to find the square root of a given integer x.\\n\\n![1_AF3IpOFN-hyhc08bnQHMSw.webp](https://assets.leetcode.com/users/images/9cd517e2-8ad9-4d1c-a91f-5a527ab0358f_1674036268.1887174.webp)\\n\\n\\n\\n# Approach\\n1. Initialize a variable n to 1, and a variable y to 0.\\n1. Use a while loop to iterate until y is greater than or equal to x.\\n1. In each iteration, add 2n-1 to y, and increment n.\\n1. Once the while loop exits, return n-1 as the square root of x.\\n\\n# Complexity\\n- Time complexity:  O(sqrt(n))\\n\\n- Space complexity: O(1) as the code only uses a few variables and not creating any data structure.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        // Initializing variables \\n        long long y=0,i=3,cnt=0;\\n    \\n        //loop until y is greater than x\\n        while(x>y){\\n            y+=i;\\n            i+=2;\\n            cnt++;\\n        }\\n\\n    // return cnt as the square root of x\\n    return cnt;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        // Initializing variables \\n        long long y=0,i=3,cnt=0;\\n    \\n        //loop until y is greater than x\\n        while(x>y){\\n            y+=i;\\n            i+=2;\\n            cnt++;\\n        }\\n\\n    // return cnt as the square root of x\\n    return cnt;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372638,
                "title": "java-1ms-100-binary-search-with-explanation",
                "content": "```java\\nclass Solution {\\n    public int mySqrt(int x) {        \\n        \\n        if (x == 0 || x == 1) return x;\\n        \\n        // Binary Search\\n        int left = 0, right = x;\\n        while (left < right) {\\n            // mid = (left + right) / 2 can overflow if right > Integer.MAX_VALUE - left\\n            int mid = left + (right - left) / 2;\\n            \\n            // same thing here , mid * mid > x can overflow. replace by mid > x / mid\\n            if (mid > x / mid) {\\n                right = mid - 1; \\n            } else {\\n                left = mid + 1;\\n                // if mid * mid < x but (mid + 1) * (mid + 1) > x then mid was the right answer\\n                if (left > x / left) {\\n                    return mid;\\n                }                \\n            }\\n        }\\n        \\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```java\\nclass Solution {\\n    public int mySqrt(int x) {        \\n        \\n        if (x == 0 || x == 1) return x;\\n        \\n        // Binary Search\\n        int left = 0, right = x;\\n        while (left < right) {\\n            // mid = (left + right) / 2 can overflow if right > Integer.MAX_VALUE - left\\n            int mid = left + (right - left) / 2;\\n            \\n            // same thing here , mid * mid > x can overflow. replace by mid > x / mid\\n            if (mid > x / mid) {\\n                right = mid - 1; \\n            } else {\\n                left = mid + 1;\\n                // if mid * mid < x but (mid + 1) * (mid + 1) > x then mid was the right answer\\n                if (left > x / left) {\\n                    return mid;\\n                }                \\n            }\\n        }\\n        \\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625550,
                "title": "2-sol-sqrt-x-beats-100-c-binary-search",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        long long s=0,e=INT_MAX,ans=0;\\n        while(s<=e){\\n            long long m=s+(e-s)/2;\\n            \\n            if(m*m<=x){\\n                ans=m;\\n                s=m+1;\\n            }\\n            else e=m-1;\\n        }\\n      \\n        return ans;\\n    }\\n};\\n```\\ntime complexity for this will be log x\\n\\n```\\nint mySqrt(int x) {\\n      long long i=0;\\n      while(i*i<=x)\\n         i++;\\n         return i-1;\\n     }\\n```\\ntime complexity for this is root x\\n\\nupvote to motivate :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        long long s=0,e=INT_MAX,ans=0;\\n        while(s<=e){\\n            long long m=s+(e-s)/2;\\n            \\n            if(m*m<=x){\\n                ans=m;\\n                s=m+1;\\n            }\\n            else e=m-1;\\n        }\\n      \\n        return ans;\\n    }\\n};\\n```\n```\\nint mySqrt(int x) {\\n      long long i=0;\\n      while(i*i<=x)\\n         i++;\\n         return i-1;\\n     }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333624,
                "title": "python-solution",
                "content": "Hope it helps\\n\\n```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        low = 0\\n        high = x\\n        while low <= high:\\n            mid = low + (high - low) // 2\\n            if mid * mid == x:\\n                return mid\\n            elif mid * mid < x:\\n                ans = mid\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        low = 0\\n        high = x\\n        while low <= high:\\n            mid = low + (high - low) // 2\\n            if mid * mid == x:\\n                return mid\\n            elif mid * mid < x:\\n                ans = mid\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25052,
                "title": "python-one-line",
                "content": "\\n     return int(x**0.5)",
                "solutionTags": [],
                "code": "\\n     return int(x**0.5)",
                "codeTag": "Unknown"
            },
            {
                "id": 25258,
                "title": "using-binary-search-accepted-but-one-question",
                "content": "    int sqrt(int x) {\\n            if(x == 0 || x == 1){\\n                return x;\\n            }\\n            int l = 1, r = x, res;\\n            while(l <= r){\\n                int m = (l + r)/2;\\n                if(m == x / m){ \\n                    return m;\\n                }else if(m > x / m){\\n                    r = m - 1;\\n                }else{\\n                    l = m + 1;\\n                    res = m;\\n                }\\n            }\\n            return res;\\n        }\\n\\nMy question is:\\nIf using `if(m * m == x)` instead of `if(m == x / m)` (and `if(m * m > x)` instead of `if(m > x / m)` ), I will get \"Time Limit Exceeded\" on case 2147395599. Why that happens?\\n\\nThank you in advance!",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "    int sqrt(int x) {\\n            if(x == 0 || x == 1){\\n                return x;\\n            }\\n            int l = 1, r = x, res;\\n            while(l <= r){\\n                int m = (l + r)/2;\\n                if(m == x / m){ \\n                    return m;\\n                }else if(m > x / m){\\n                    r = m - 1;\\n                }else{\\n                    l = m + 1;\\n                    res = m;\\n                }\\n            }\\n            return res;\\n        }\\n\\nMy question is:\\nIf using `if(m * m == x)` instead of `if(m == x / m)` (and `if(m * m > x)` instead of `if(m > x / m)` ), I will get \"Time Limit Exceeded\" on case 2147395599. Why that happens?\\n\\nThank you in advance!",
                "codeTag": "Unknown"
            },
            {
                "id": 2129929,
                "title": "0ms-1liner-100-fastest-solution-explained-o-n-time-complexity-o-n-space-complexity",
                "content": "**As a professional with a passion for problem-solving and collaboration, I am always looking to expand my network of like-minded individuals on LinkedIn. By connecting with me, we can work together to tackle complex challenges, share ideas, and grow both professionally and personally.**\\n\\n**Whether you\\'re an expert in your field or just starting out, I welcome connections from all backgrounds and experiences. By building a diverse and collaborative network, we can leverage our unique perspectives and skill sets to push the boundaries of what\\'s possible.**\\n\\n**So, if you\\'re interested in connecting and exploring the potential for future collaborations, please don\\'t hesitate to reach out. Let\\'s start a conversation and see where it takes us!**\\n\\n---\\n\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\n\\n---\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* *** Java ***\\n\\n```\\n\\nclass Solution {\\n    public int mySqrt(int x) {\\n        if(x == 0) // To avoid division by 0\\n            return 0;\\n        int start = 1, end = x / 2 + 1; // The squareroot can only lie in this range\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(mid == x / mid) // Not multiplying as the product for a large number may be greater than the max value of int\\n                return mid;\\n            else if(mid < x / mid) \\n                start = mid + 1;\\n            else\\n                end = mid - 1;\\n        }\\n        return end; // end will be the largest integer such that end^2 < x\\n    }\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Kotlin",
                    "PHP"
                ],
                "code": "```\\n```\n```\\n\\nclass Solution {\\n    public int mySqrt(int x) {\\n        if(x == 0) // To avoid division by 0\\n            return 0;\\n        int start = 1, end = x / 2 + 1; // The squareroot can only lie in this range\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(mid == x / mid) // Not multiplying as the product for a large number may be greater than the max value of int\\n                return mid;\\n            else if(mid < x / mid) \\n                start = mid + 1;\\n            else\\n                end = mid - 1;\\n        }\\n        return end; // end will be the largest integer such that end^2 < x\\n    }\\n}\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785872,
                "title": "java-simple-java-solution-easy-to-understand",
                "content": "Upvote if you liked the solution\\n```\\nclass Solution {\\n    public int mySqrt(int n) {\\n        long lo=0,hi=n;\\n        long ans=0;\\n        while(lo<=hi)\\n        {\\n            long mid=(lo+hi)/2;\\n            if(mid*mid<n)\\n            {\\n                lo=mid+1;\\n                //mid*mid chota hai to usko equal laane ke lie lo ko badhao\\n                ans=mid;\\n            }\\n            else if(mid*mid>n) hi=mid-1;\\n            else return (int)mid;\\n        }\\n        return (int)ans;\\n    }\\n}",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int mySqrt(int n) {\\n        long lo=0,hi=n;\\n        long ans=0;\\n        while(lo<=hi)\\n        {\\n            long mid=(lo+hi)/2;\\n            if(mid*mid<n)\\n            {\\n                lo=mid+1;\\n                //mid*mid chota hai to usko equal laane ke lie lo ko badhao\\n                ans=mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 25240,
                "title": "newton-method-accepted-solution",
                "content": "    class Solution:\\n\\t# @param x, an integer\\n\\t# @return an integer\\n\\tdef sqrt(self, x):\\n\\t\\ti=1.0;\\n\\t\\twhile(True):\\n\\t\\t\\tj=(i+x/i)/2.0;\\n\\t\\t\\tif(abs(i-j)< 0.000000000005):\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\ti=j;\\n\\t\\treturn int(j);",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n\\t# @param x, an integer\\n\\t# @return an integer\\n\\tdef sqrt(self, x):\\n\\t\\ti=1.0;\\n\\t\\twhile(True):\\n\\t\\t\\tj=(i+x/i)/2.0;\\n\\t\\t\\tif(abs(i-j)< 0.000000000005):\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\ti=j;\\n\\t\\treturn int(j);",
                "codeTag": "Java"
            },
            {
                "id": 2732386,
                "title": "o-1-solution-in-python-newton-raphson-method",
                "content": "# Intuition\\n1. I aleady knew this numerical trick that finding sqaure root of **a** is identical to finding roots of quadtratic polynomial **x^2 - a = 0**.\\n\\n# Approach\\n![7KrMvNiT7l-newtons-method.png](https://assets.leetcode.com/users/images/9c7842bf-e45f-46a9-b399-621188ecfd5f_1666444203.7846649.png)\\n\\nrandomly choose a point, find the slope there and see where its intersect the x axis, then repat again.\\n\\n![images (1).jpg](https://assets.leetcode.com/users/images/70c0a897-5e6e-479b-b29f-4b11de002265_1666444286.9747567.jpeg)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# the time complexity of calculating a root of a function **f(x)** with n-digit precision, provided that a good initial approximation is known, is **O((log n)F(n))** where **F(n)** is the cost of calculating f(x)/f\\'(x) with n-digit precision.\\n\\n**here in my code I only used 20 loops to converge to a solution no matter the inputs, assuming F(n) also constant the time complexity her is O(1).**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        res = 1\\n        for i in range(20):\\n            temp = res\\n            res = temp - (temp**2 - x)/(2 * temp)\\n        return math.floor(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        res = 1\\n        for i in range(20):\\n            temp = res\\n            res = temp - (temp**2 - x)/(2 * temp)\\n        return math.floor(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480399,
                "title": "binary-search-summary",
                "content": "leetcode 69 sqrt, leetcode 278 first bad version, 875 monkey eat banana\\nI\\'m inspired by the HuaHua [youtube channel. ](https://youtu.be/J-IQxfYRTto)\\n\\n## Template \\n\\twhile i < j:     -> [left close, right open)\\n\\t\\tmid = (i + j) // 2\\n\\t\\tif g(m):    -> here g(m) can be a statement or a function\\n\\t\\t\\tj = mid\\n\\t\\telse:\\n\\t\\t\\ti = mid + 1\\n\\treturn i              -> return the first element that satisfy the g(m)\\n\\t\\nFor example:\\n[leetcode 69 sqrt](https://leetcode.com/problems/sqrtx/):\\n\\n\\n\\n\\tdef mySqrt(self, x: int) -> int:\\n\\t\\tif x == 0 or x == 1:\\n\\t\\t\\treturn x\\n\\t\\ti = 1  -> set up the left bound 1\\n        j = x   -> set up the upper open bound x, because we have taken the corner case x == 0 or 1 into consider\\n        while i < j:   -> node that the searching space is [1, x)\\n            mid = (i + j) // 2\\n            if mid * mid > x:    -> This is our g(m), our goal is to find a point, mid,  where mid is the first element that satisfy mid**mid > x. \\n                j = mid\\n            else:\\n                i = mid + 1\\n        return i - 1   -> note that g(m) statement is the first element that is larger than x, so we just need to subtract by 1 to get the result we want (the square root of the i is equal or smaller than x)\\n\\n\\n[leetcode 278 bad version](https://leetcode.com/problems/first-bad-version/)\\n\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        i, j = 0, n + 1  -> here n + 1 because we want to include the last version into our searching space\\n        \\n        while i < j:\\n            mid = (i + j) // 2\\n            if isBadVersion(mid):  -> this is our g(m), our goal is to find the first element that g(m) is False\\n                j = mid        -> searching space [i, mid)\\n            else:\\n                i = mid + 1    -> searching space [mid + 1, j)\\n        return i   \\n\\n\\n[leetcode 875 eating banana](https://leetcode.com/problems/koko-eating-bananas/)\\n\\ndef minEatingSpeed(self, piles: List[int], H: int) -> int:\\n        \\n        def time_spend(k):   -> this is our g(m), which returns the time\\n            h = 0\\n            for banana in piles:\\n                if banana <= k:\\n                    h += 1\\n                else:\\n                    times, res = divmod(banana, k)\\n                    h = h + times + 1          \\n            return h\\n       \\n        i, j = 1, max(piles) + 1   -> binary search h, ranging from [1, n), where n is the max(piles) note, that the right is open, so, [1, max(piles) + 1)\\n        while i < j:\\n            mid = (i + j) // 2\\n            time = time_spend(mid)   -> the g(m)\\n        \\n            if time <= H:  # eat slow  \\n                j = mid\\n            else:   # eat fast\\n                i = mid + 1\\n        return i\\n",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "leetcode 69 sqrt, leetcode 278 first bad version, 875 monkey eat banana\\nI\\'m inspired by the HuaHua [youtube channel. ](https://youtu.be/J-IQxfYRTto)\\n\\n## Template \\n\\twhile i < j:     -> [left close, right open)\\n\\t\\tmid = (i + j) // 2\\n\\t\\tif g(m):    -> here g(m) can be a statement or a function\\n\\t\\t\\tj = mid\\n\\t\\telse:\\n\\t\\t\\ti = mid + 1\\n\\treturn i              -> return the first element that satisfy the g(m)\\n\\t\\nFor example:\\n[leetcode 69 sqrt](https://leetcode.com/problems/sqrtx/):\\n\\n\\n\\n\\tdef mySqrt(self, x: int) -> int:\\n\\t\\tif x == 0 or x == 1:\\n\\t\\t\\treturn x\\n\\t\\ti = 1  -> set up the left bound 1\\n        j = x   -> set up the upper open bound x, because we have taken the corner case x == 0 or 1 into consider\\n        while i < j:   -> node that the searching space is [1, x)\\n            mid = (i + j) // 2\\n            if mid * mid > x:    -> This is our g(m), our goal is to find a point, mid,  where mid is the first element that satisfy mid**mid > x. \\n                j = mid\\n            else:\\n                i = mid + 1\\n        return i - 1   -> note that g(m) statement is the first element that is larger than x, so we just need to subtract by 1 to get the result we want (the square root of the i is equal or smaller than x)\\n\\n\\n[leetcode 278 bad version](https://leetcode.com/problems/first-bad-version/)\\n\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        i, j = 0, n + 1  -> here n + 1 because we want to include the last version into our searching space\\n        \\n        while i < j:\\n            mid = (i + j) // 2\\n            if isBadVersion(mid):  -> this is our g(m), our goal is to find the first element that g(m) is False\\n                j = mid        -> searching space [i, mid)\\n            else:\\n                i = mid + 1    -> searching space [mid + 1, j)\\n        return i   \\n\\n\\n[leetcode 875 eating banana](https://leetcode.com/problems/koko-eating-bananas/)\\n\\ndef minEatingSpeed(self, piles: List[int], H: int) -> int:\\n        \\n        def time_spend(k):   -> this is our g(m), which returns the time\\n            h = 0\\n            for banana in piles:\\n                if banana <= k:\\n                    h += 1\\n                else:\\n                    times, res = divmod(banana, k)\\n                    h = h + times + 1          \\n            return h\\n       \\n        i, j = 1, max(piles) + 1   -> binary search h, ranging from [1, n), where n is the max(piles) note, that the right is open, so, [1, max(piles) + 1)\\n        while i < j:\\n            mid = (i + j) // 2\\n            time = time_spend(mid)   -> the g(m)\\n        \\n            if time <= H:  # eat slow  \\n                j = mid\\n            else:   # eat fast\\n                i = mid + 1\\n        return i\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2350089,
                "title": "very-easy-100-fully-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution (Binary Search Approach):**\\n```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        // Initialise beg and end values as 1 and x / 2 respectively...\\n        int beg = 1 , end = x / 2 , mid;\\n        // Initialize variable res to store the result\\n        int res = 0;\\n        long tmp;\\n        // If the number is less than 2, return itself...\\n        if(x <= 1)\\n            return x;\\n        while(beg <= end) {\\n            // Find middle of this range...\\n            mid = (beg + (end - beg) / 2);\\n            tmp = (long)mid * (long)mid;      // mid * mid can be large, so use long...\\n            // If square of mid is equal to x...\\n            // return it as it is the square root...\\n            if(tmp == x)\\n                return mid;\\n            // If square of mid is less than x...\\n            // jump to the end half by setting beg = mid + 1...\\n            if(tmp < x) {\\n                res = mid;\\n                beg = mid + 1;\\n            }\\n            // Otherwise, jump to the beg half by setting end = mid \\u2013 1...\\n            // And save this value in res...\\n            else\\n                end = mid - 1;\\n        }\\n        return res;     // Print the result...\\n    }\\n}\\n```\\n\\n# **C++ Solution (Pre-built Functions Approach):**\\n```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        //If the number is less than or equal to 1, return itself...\\n        if(x <= 1)\\n            return x;\\n        // Call the sqrt() function & Floor the value obtained...\\n        return floor(sqrt(x));      // Apply floor() to avoid any decimal value.\\n    }\\n};\\n```\\n\\n# **Python Solution (Newton\\'s Approach):**\\n```\\nclass Solution(object):\\n    def mySqrt(self, x):\\n        res = x\\n        while not res * res - x < 1:\\n            res = (res + x / res) / 2\\n        return int(res)\\n```\\n                 \\n# **JavaScript Solution (Binary Search Approach):**\\n```\\nvar mySqrt = function(x) {\\n    // Initialise beg and end values as 0 and x respectively...\\n    let beg = 0, end = x, mid = 0;\\n    while (beg < end) {\\n        // Find middle of this range...\\n        mid = parseInt((beg + end)/2);\\n        // If square of mid is equal to x...\\n        // return it as it is the square root...\\n        if (mid * mid === x) {\\n            return mid;\\n        }\\n        // If square of mid is greater than x...\\n        // jump to the beg half by setting end = mid \\u2013 1...\\n        if (x < mid * mid) {\\n            end = mid - 1;\\n        }\\n        // Otherwise, jump to the end half by setting beg = mid + 1...\\n        else {\\n            beg = mid + 1;\\n        }\\n    }\\n    // Save this value in result and return...\\n    return x < end * end ? end - 1 : end;\\n};\\n```\\n\\n# **C Language:**\\n```\\nint mySqrt(int x){\\n    long int i = 1, res;\\n    if(x == 0)\\n        return 0;\\n    for(i; i*i <= x; i++) {\\n        res = i;\\n    }\\n    return res;\\n}\\n```\\n                 \\n# **Python3 Solution (Pre-built Functions Approach):**\\n```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        return int(floor(sqrt(x)))\\n```\\n**Binary search, Pre-built function, Newton\\'s method & Brute force approaches are here in the solution...\\nPlease upvote if you find any help with this code...\\nI am working hard for you guys...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        // Initialise beg and end values as 1 and x / 2 respectively...\\n        int beg = 1 , end = x / 2 , mid;\\n        // Initialize variable res to store the result\\n        int res = 0;\\n        long tmp;\\n        // If the number is less than 2, return itself...\\n        if(x <= 1)\\n            return x;\\n        while(beg <= end) {\\n            // Find middle of this range...\\n            mid = (beg + (end - beg) / 2);\\n            tmp = (long)mid * (long)mid;      // mid * mid can be large, so use long...\\n            // If square of mid is equal to x...\\n            // return it as it is the square root...\\n            if(tmp == x)\\n                return mid;\\n            // If square of mid is less than x...\\n            // jump to the end half by setting beg = mid + 1...\\n            if(tmp < x) {\\n                res = mid;\\n                beg = mid + 1;\\n            }\\n            // Otherwise, jump to the beg half by setting end = mid \\u2013 1...\\n            // And save this value in res...\\n            else\\n                end = mid - 1;\\n        }\\n        return res;     // Print the result...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        //If the number is less than or equal to 1, return itself...\\n        if(x <= 1)\\n            return x;\\n        // Call the sqrt() function & Floor the value obtained...\\n        return floor(sqrt(x));      // Apply floor() to avoid any decimal value.\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def mySqrt(self, x):\\n        res = x\\n        while not res * res - x < 1:\\n            res = (res + x / res) / 2\\n        return int(res)\\n```\n```\\nvar mySqrt = function(x) {\\n    // Initialise beg and end values as 0 and x respectively...\\n    let beg = 0, end = x, mid = 0;\\n    while (beg < end) {\\n        // Find middle of this range...\\n        mid = parseInt((beg + end)/2);\\n        // If square of mid is equal to x...\\n        // return it as it is the square root...\\n        if (mid * mid === x) {\\n            return mid;\\n        }\\n        // If square of mid is greater than x...\\n        // jump to the beg half by setting end = mid \\u2013 1...\\n        if (x < mid * mid) {\\n            end = mid - 1;\\n        }\\n        // Otherwise, jump to the end half by setting beg = mid + 1...\\n        else {\\n            beg = mid + 1;\\n        }\\n    }\\n    // Save this value in result and return...\\n    return x < end * end ? end - 1 : end;\\n};\\n```\n```\\nint mySqrt(int x){\\n    long int i = 1, res;\\n    if(x == 0)\\n        return 0;\\n    for(i; i*i <= x; i++) {\\n        res = i;\\n    }\\n    return res;\\n}\\n```\n```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        return int(floor(sqrt(x)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496645,
                "title": "best-solution-in-java-runtime-1ms-and-beats-100-by-binarysearch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int low = 1 , high = x  , ans = 0;\\n\\n            while (low <= high){\\n              int mid = low + (high - low) /2;\\n\\n                if (x/mid == mid) return mid;\\n                else if (x/mid < mid)  high = mid-1;\\n                else {\\n                    low= mid + 1; ans=mid;\\n                }\\n            }\\n        return ans;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int low = 1 , high = x  , ans = 0;\\n\\n            while (low <= high){\\n              int mid = low + (high - low) /2;\\n\\n                if (x/mid == mid) return mid;\\n                else if (x/mid < mid)  high = mid-1;\\n                else {\\n                    low= mid + 1; ans=mid;\\n                }\\n            }\\n        return ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2059043,
                "title": "c-java-c-c-simple-logic-binary-search-newton-s-method",
                "content": "# Frequently encountered in technical interviews\\n```\\nstd::vector<std::pair<std::string, int>> interview_frequency= {\\n    {\"LinkedIn\", 9},\\n    {\"Amazon\", 9},\\n    {\"Apple\", 5},\\n    {\"Google\", 4},\\n    {\"Adobe\", 4},\\n    {\"Microsoft\", 3},\\n    {\"Bloomberg\", 2}\\n};\\n```\\n\\n# Solution\\n\\nA simple [Binary Search](https://www.khanacademy.org/computing/computer-science/algorithms/binary-search/a/binary-search) Solution would also help to solve this problem.\\n\\nThe [time complexity](https://www.scaler.com/topics/time-complexity-of-binary-search/) of this implementation is O(log n). This is because it uses binary search to find the square root, and binary search has a time complexity of O(log n).\\n\\nThe space complexity of this implementation is O(1), because it only uses a constant amount of extra space to store the integer variables. It does not use any extra data structures that grow with the input size.\\n```C++ []\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        int first=0,last=x;\\n        while (first<=last) {\\n\\t\\t\\tlong mid=(first+last)/2,temp=mid*mid;\\n            if (x==temp) \\n                return (int)mid;\\n            else if (temp>x) \\n                last=(int)(mid-1);\\n            else \\n                first=(int)(mid+1);\\n        }\\n        return last;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int first=0,last=x;\\n        while (first<=last) {\\n\\t\\t\\tlong mid=(first+last)/2,temp=mid*mid;\\n            if (x==temp) \\n                return (int)mid;\\n            else if (temp>x) \\n                last=(int)(mid-1);\\n            else \\n                first=(int)(mid+1);\\n        }\\n        return last;\\n    }\\n}\\n```\\n```csharp []\\n// Time complexity: O(log n)\\n// space complexity: O(1)\\npublic class Solution {\\n    public int MySqrt(int x) {\\n        int first=0,last=x;\\n        while (first<=last) {\\n\\t\\t\\tlong mid=(first+last)/2,temp=mid*mid;\\n            if (x==temp) \\n                return (int)mid;\\n            else if (temp>x) \\n                last=(int)(mid-1);\\n            else \\n                first=(int)(mid+1);\\n        }\\n        return last;\\n    }\\n}\\n```\\n```C []\\nint mySqrt(int x){\\n    int first=0,last=x;\\n    while (first<=last) {\\n        long mid=(first+last)/2,temp=mid*mid;\\n        if (x==temp) \\n            return (int)mid;\\n        else if (temp>x) \\n            last=(int)(mid-1);\\n        else \\n            first=(int)(mid+1);\\n    }\\n    return last;\\n}\\n```\\n\\n**Newton Solution:** \\nThis implementation of MySqrt uses the Newton\\'s method to find the square root of x. It has a time complexity of O(log n). This is because it converges quadratically to the solution, meaning that each iteration roughly doubles the number of correct digits in the result.\\n\\nThe space complexity of this implementation is O(1), because it only uses a constant amount of extra space to store the long integer variable res. It does not use any extra data structures that grow with the input size.\\n```C++ []\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        long res = x;\\n        while (res*res > x)\\n            res = (res + x/res) / 2;\\n        return (int) res;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int mySqrt(int x) {\\n        long res = x;\\n        while (res*res > x)\\n            res = (res + x/res) / 2;\\n        return (int) res;\\n    }\\n}\\n```\\n```csharp []\\n// Time complexity: O(log n)\\n// space complexity: O(1)\\npublic class Solution {\\n     public int MySqrt(int x) {         \\n        long res = x;\\n        while (res*res > x)\\n            res = (res + x/res) / 2;\\n        return (int) res;\\n    }\\n}\\n```\\n```C []\\nint mySqrt(int x){\\n    long res = x;\\n    while (res*res > x)\\n        res = (res + x/res) / 2;\\n    return (int) res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C#",
                    "Binary Search"
                ],
                "code": "```\\nstd::vector<std::pair<std::string, int>> interview_frequency= {\\n    {\"LinkedIn\", 9},\\n    {\"Amazon\", 9},\\n    {\"Apple\", 5},\\n    {\"Google\", 4},\\n    {\"Adobe\", 4},\\n    {\"Microsoft\", 3},\\n    {\"Bloomberg\", 2}\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        int first=0,last=x;\\n        while (first<=last) {\\n\\t\\t\\tlong mid=(first+last)/2,temp=mid*mid;\\n            if (x==temp) \\n                return (int)mid;\\n            else if (temp>x) \\n                last=(int)(mid-1);\\n            else \\n                first=(int)(mid+1);\\n        }\\n        return last;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int first=0,last=x;\\n        while (first<=last) {\\n\\t\\t\\tlong mid=(first+last)/2,temp=mid*mid;\\n            if (x==temp) \\n                return (int)mid;\\n            else if (temp>x) \\n                last=(int)(mid-1);\\n            else \\n                first=(int)(mid+1);\\n        }\\n        return last;\\n    }\\n}\\n```\n```csharp []\\n// Time complexity: O(log n)\\n// space complexity: O(1)\\npublic class Solution {\\n    public int MySqrt(int x) {\\n        int first=0,last=x;\\n        while (first<=last) {\\n\\t\\t\\tlong mid=(first+last)/2,temp=mid*mid;\\n            if (x==temp) \\n                return (int)mid;\\n            else if (temp>x) \\n                last=(int)(mid-1);\\n            else \\n                first=(int)(mid+1);\\n        }\\n        return last;\\n    }\\n}\\n```\n```C []\\nint mySqrt(int x){\\n    int first=0,last=x;\\n    while (first<=last) {\\n        long mid=(first+last)/2,temp=mid*mid;\\n        if (x==temp) \\n            return (int)mid;\\n        else if (temp>x) \\n            last=(int)(mid-1);\\n        else \\n            first=(int)(mid+1);\\n    }\\n    return last;\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        long res = x;\\n        while (res*res > x)\\n            res = (res + x/res) / 2;\\n        return (int) res;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int mySqrt(int x) {\\n        long res = x;\\n        while (res*res > x)\\n            res = (res + x/res) / 2;\\n        return (int) res;\\n    }\\n}\\n```\n```csharp []\\n// Time complexity: O(log n)\\n// space complexity: O(1)\\npublic class Solution {\\n     public int MySqrt(int x) {         \\n        long res = x;\\n        while (res*res > x)\\n            res = (res + x/res) / 2;\\n        return (int) res;\\n    }\\n}\\n```\n```C []\\nint mySqrt(int x){\\n    long res = x;\\n    while (res*res > x)\\n        res = (res + x/res) / 2;\\n    return (int) res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915715,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func mySqrt(_ x: Int) -> Int {\\n        if x == 0 { return 0 }\\n        if x < 4 { return 1 }\\n        \\n        var left = 0\\n        var right = (x + 1) / 2\\n        var mid = (left + right) / 2\\n        \\n        while left < right {\\n            if mid * mid > x {\\n                right = mid - 1\\n            } else {\\n                left = mid + 1\\n            }\\n            \\n            mid = (left + right) / 2\\n        }\\n        \\n        return left * left > x ? left - 1 : left\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func mySqrt(_ x: Int) -> Int {\\n        if x == 0 { return 0 }\\n        if x < 4 { return 1 }\\n        \\n        var left = 0\\n        var right = (x + 1) / 2\\n        var mid = (left + right) / 2\\n        \\n        while left < right {\\n            if mid * mid > x {\\n                right = mid - 1\\n            } else {\\n                left = mid + 1\\n            }\\n            \\n            mid = (left + right) / 2\\n        }\\n        \\n        return left * left > x ? left - 1 : left\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272353,
                "title": "o-log-n-binary-search-solution",
                "content": "# Complexity\\n- Time complexity: $$O(log n)$$\\n\\n- Space complexity: $$O(1)$$\\n```\\n/**\\n * @param {number} x\\n * @return {number}\\n */\\nvar mySqrt = function(x) {\\n    let left = 0;\\n    let right = x;\\n    while(left <= right) {\\n        const mid = Math.floor((left+right)/2);\\n        if(mid*mid <= x && (mid+1) * (mid+1) > x) {\\n            return mid;\\n        }\\n        else if(mid*mid < x) {\\n            left = mid + 1;\\n        }\\n        else {\\n            right = mid - 1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} x\\n * @return {number}\\n */\\nvar mySqrt = function(x) {\\n    let left = 0;\\n    let right = x;\\n    while(left <= right) {\\n        const mid = Math.floor((left+right)/2);\\n        if(mid*mid <= x && (mid+1) * (mid+1) > x) {\\n            return mid;\\n        }\\n        else if(mid*mid < x) {\\n            left = mid + 1;\\n        }\\n        else {\\n            right = mid - 1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2138467,
                "title": "simple-efficient-easy-binary-search-faster-solution",
                "content": "**<<<<<<< Press the Upvote Button please !!!!!!!!** it really Helps\\n\\n```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        \\n        int low=1,high=x;\\n        \\n        while(low<=high)\\n        {\\n            long long mid= low + (high-low)/2;\\n            long long sqr=mid*mid;\\n            \\n            if(sqr <= x)\\n            {\\n                sqr=(mid+1)*(mid+1);\\n                \\n                if(sqr<=x)\\n                {\\n                    low=mid+1;\\n                }\\n                else\\n                    return mid;\\n                \\n            }   \\n            else if(sqr>x)\\n                high=mid-1;        \\n        }\\n        \\n        return 0;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/88deab96-b0cb-4ed9-9be3-8e6d630dec50_1654954670.2653778.jpeg)\\n\\n\\n**<+++++++ Press the Upvote Button please !!!!!!!!**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        \\n        int low=1,high=x;\\n        \\n        while(low<=high)\\n        {\\n            long long mid= low + (high-low)/2;\\n            long long sqr=mid*mid;\\n            \\n            if(sqr <= x)\\n            {\\n                sqr=(mid+1)*(mid+1);\\n                \\n                if(sqr<=x)\\n                {\\n                    low=mid+1;\\n                }\\n                else\\n                    return mid;\\n                \\n            }   \\n            else if(sqr>x)\\n                high=mid-1;        \\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534320,
                "title": "javascript-binary-search",
                "content": "- Time Complexity: O(log x)\\n- Space Complexity: O(1)\\n\\nThere are 3 possible way to escape the loop.\\n1. when `mid * mid` is equal to `x` immediately return `mid`\\n2. when `hi` is smaller than `lo`\\n3. when `hi` is equal to `lo`\\n\\n- At outside of loop, `hi` is smaller or equal to `lo`\\n- Need to consider return value when `hi === lo`\\n\\ne.g. `x = 5`\\nlo | mid | hi\\n:--:|:--:|:--:\\n0|2|5\\n3|4|5\\n3|-|3\\n\\nat the out of the loop `lo = hi = 3`, however it should return `2`\\n```JavaScript\\n/**\\n * @param {number} x\\n * @return {number}\\n */\\nvar mySqrt = function(x) {\\n    let lo = 0, hi = x;\\n    while (lo < hi) {\\n        const mid = parseInt((lo + hi)/2);\\n        if (mid * mid === x) {\\n            return mid;\\n        }\\n        if (x < mid * mid) {\\n            hi = mid - 1;\\n        } else {\\n            lo = mid + 1;\\n        }\\n    }\\n    return x < hi * hi ? hi - 1 : hi; \\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```JavaScript\\n/**\\n * @param {number} x\\n * @return {number}\\n */\\nvar mySqrt = function(x) {\\n    let lo = 0, hi = x;\\n    while (lo < hi) {\\n        const mid = parseInt((lo + hi)/2);\\n        if (mid * mid === x) {\\n            return mid;\\n        }\\n        if (x < mid * mid) {\\n            hi = mid - 1;\\n        } else {\\n            lo = mid + 1;\\n        }\\n    }\\n    return x < hi * hi ? hi - 1 : hi; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2797953,
                "title": "best-python-code-time",
                "content": "This is the fastest and bestest way to code this problem. So efficient!!!!\\n\\n```class Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x == 0:\\n            return 0\\n        for i in range(1,x+1):\\n            if i * i == x:\\n                return i\\n            elif i * i > x:\\n                return (i-1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```class Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x == 0:\\n            return 0\\n        for i in range(1,x+1):\\n            if i * i == x:\\n                return i\\n            elif i * i > x:\\n                return (i-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737958,
                "title": "java-simple-solution-binary-search-without-using-sqrt-method",
                "content": "```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        long low =  0;\\n        long high = x;\\n        long ans = 0;\\n        while(low <= high){\\n            long mid = (low+high)/2;\\n            if(mid*mid < x){\\n                low = mid + 1;\\n                ans = mid;\\n            }\\n            else if(mid*mid > x){\\n                high = mid - 1;\\n            }\\n            else{\\n                return (int)mid;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\\n\\n***UP-VOTE IF HELPFUL***",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        long low =  0;\\n        long high = x;\\n        long ans = 0;\\n        while(low <= high){\\n            long mid = (low+high)/2;\\n            if(mid*mid < x){\\n                low = mid + 1;\\n                ans = mid;\\n            }\\n            else if(mid*mid > x){\\n                high = mid - 1;\\n            }\\n            else{\\n                return (int)mid;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501651,
                "title": "python-binary-search-simple-solution",
                "content": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        start = 0\\n        end = x // 2\\n        while start <= end:\\n            mid = start + ((end - start) // 2)\\n            if mid * mid <= x and (mid+1) * (mid+1) > x:\\n                return mid\\n            elif mid * mid < x:\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        return start\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        start = 0\\n        end = x // 2\\n        while start <= end:\\n            mid = start + ((end - start) // 2)\\n            if mid * mid <= x and (mid+1) * (mid+1) > x:\\n                return mid\\n            elif mid * mid < x:\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        return start\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702332,
                "title": "python-solution",
                "content": "```\\ndef mySqrt(self, x: int) -> int:\\n        i=0\\n        while(i*i<=x):\\n            i+=1\\n        return i-1",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef mySqrt(self, x: int) -> int:\\n        i=0\\n        while(i*i<=x):\\n            i+=1\\n        return i-1",
                "codeTag": "Python3"
            },
            {
                "id": 480993,
                "title": "a-chinese-traditional-solution-yanghui-suancao",
                "content": "# Handy Calculation\\n![image](https://assets.leetcode.com/users/pianoguy/image_1579076714.png)\\n\\nThank [SNaveenMathew](https://leetcode.com/SNaveenMathew) for the [explanation](https://leetcode.com/problems/sqrtx/discuss/480993/A-Chinese-Traditional-Solution:-Yanghui-Suancao-()/1077352) below:\\n> Here\\'s a mathematical explanation for a 4 digit number abcd\\nThe result starts with y = floor(sqrt(ab)). Therefore, the result is of the form 10*y + z, where z is a number in range [0, 9]\\n(10y+z)^2 = 100*y^2 + 2*10*yz + z^2\\nWe already identified y, so subtract 100*y^2 from abcd to obtain remainder (say, rem). Now 2*10*yz + z^2 can be written as (2*10y + z) * z. Iterate from z = 0 to 9 (inclusive) to find the value z such that the resulting product is less than or equal to rem. There\\'s our answer! This approach can be extended to any number of digits (odd or even).\\n\\n# Coding (C#)\\n\\n```csharp\\npublic class Solution\\n{\\n    public int MySqrt(int x)\\n    {\\n        var result = 0;\\n        var (shang, yu, lian, fa) = (0, 0, 0, 1);\\n        while (x / fa >= 100)\\n        {\\n            fa *= 100;\\n        }\\n        while (fa > 0)\\n        {\\n            result *= 10;\\n            lian += shang;\\n            lian *= 10;\\n            yu = x % fa;\\n            x /= fa;\\n            shang = GuessShang(x, lian);\\n            lian += shang;\\n            result += shang;\\n            x = (x - shang * lian) * fa + yu;\\n            fa /= 100;\\n        }\\n        return result;\\n    }\\n\\n    private static int GuessShang(int x, int lian)\\n    {\\n        var shang = 0;\\n        while ((lian + shang) * shang < x)\\n        {\\n            shang++;\\n        }\\n        if ((lian + shang) * shang > x)\\n        {\\n            shang--;\\n        }\\n        return shang;\\n    }\\n}\\n```\\n\\n# Reference\\n[1]. [\\u589E\\u4E58\\u958B\\u5E73\\u65B9\\u6CD5\\u2014\\u2014\\u7DAD\\u57FA\\u767E\\u79D1](https://zh.wikipedia.org/w/index.php?title=%E5%A2%9E%E4%B9%98%E5%BC%80%E5%B9%B3%E6%96%B9%E6%B3%95&oldid=51962280)",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution\\n{\\n    public int MySqrt(int x)\\n    {\\n        var result = 0;\\n        var (shang, yu, lian, fa) = (0, 0, 0, 1);\\n        while (x / fa >= 100)\\n        {\\n            fa *= 100;\\n        }\\n        while (fa > 0)\\n        {\\n            result *= 10;\\n            lian += shang;\\n            lian *= 10;\\n            yu = x % fa;\\n            x /= fa;\\n            shang = GuessShang(x, lian);\\n            lian += shang;\\n            result += shang;\\n            x = (x - shang * lian) * fa + yu;\\n            fa /= 100;\\n        }\\n        return result;\\n    }\\n\\n    private static int GuessShang(int x, int lian)\\n    {\\n        var shang = 0;\\n        while ((lian + shang) * shang < x)\\n        {\\n            shang++;\\n        }\\n        if ((lian + shang) * shang > x)\\n        {\\n            shang--;\\n        }\\n        return shang;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25044,
                "title": "c-binary-search",
                "content": "```\\n    int mySqrt(int x) {\\n        if(x == 1) return 1;\\n        int l = 0;\\n        int r = x;\\n        while(l < r - 1){  // ** not l < r => think about the case r = l + 2\\n            int mid = l + (r - l) / 2;\\n            if(mid == x / mid) return mid; // prevent from mid * mid overflow\\n            else if(mid > x / mid) r = mid;  // prevent from mid * mid overflow\\n            else l = mid; // *** not l = mid + 1\\n        }\\n        return l;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int mySqrt(int x) {\\n        if(x == 1) return 1;\\n        int l = 0;\\n        int r = x;\\n        while(l < r - 1){  // ** not l < r => think about the case r = l + 2\\n            int mid = l + (r - l) / 2;\\n            if(mid == x / mid) return mid; // prevent from mid * mid overflow\\n            else if(mid > x / mid) r = mid;  // prevent from mid * mid overflow\\n            else l = mid; // *** not l = mid + 1\\n        }\\n        return l;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3069606,
                "title": "c-and-python3-solution-with-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary Search\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$log(n)$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Python\\n```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        left=0\\n        right=10000000\\n        mid=(left+right)//2\\n        while(True):\\n            temp=mid\\n            if mid*mid>x:\\n                right=mid+1\\n            else:\\n                left=mid\\n            mid=(left+right)//2\\n            if temp==mid:\\n                break\\n        return left\\n\\n```\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        long long int left=0,right=100000;\\n        long long int mid=(left+right)/2;\\n        while(true)\\n        {\\n            long long int temp=mid;\\n            if (mid*mid>x) right=mid+1;else left=mid;\\n            mid=(left+right)/2;\\n            if (temp==mid) break;\\n        }\\n            \\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        left=0\\n        right=10000000\\n        mid=(left+right)//2\\n        while(True):\\n            temp=mid\\n            if mid*mid>x:\\n                right=mid+1\\n            else:\\n                left=mid\\n            mid=(left+right)//2\\n            if temp==mid:\\n                break\\n        return left\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        long long int left=0,right=100000;\\n        long long int mid=(left+right)/2;\\n        while(true)\\n        {\\n            long long int temp=mid;\\n            if (mid*mid>x) right=mid+1;else left=mid;\\n            mid=(left+right)/2;\\n            if (temp==mid) break;\\n        }\\n            \\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200492,
                "title": "javascript-simple-solution",
                "content": "```\\n/**\\n * @param {number} x\\n * @return {number}\\n */\\nvar mySqrt = function(x) {\\n    let val = 0;\\n    while((val * val) <= x) val++;\\n    return val - 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} x\\n * @return {number}\\n */\\nvar mySqrt = function(x) {\\n    let val = 0;\\n    while((val * val) <= x) val++;\\n    return val - 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25190,
                "title": "newton-s-method-in-python",
                "content": "For reference of [Newton's method](https://en.wikipedia.org/wiki/Newton%27s_method). For the sake of description, I will call the input `k` instead of `x`.\\n\\n`Newton's method` finds the root of a function `f(x) = 0`. In this case `f(x) = k - x^2, x > 0`, where `k` is the given input and `x` is the variable we are trying to solve for. Take an initial guess of `x`, call it `x_0`. We can draw a tangent to the curve of the function `y = f(x)` at the point `(x_0, f(x_0))`. We can then find the intersection of this tangent with the `x-axis`. The intersection point can be solved as:\\n    \\n`(x_0 + (k - x_0^2)/(2 * x_0), 0)`\\n\\nIn general the intersection point is `(x_0 - f(x_0) / f'(x_0), 0)`, where `f'(x)` is the derivative of `f(x)`.\\n\\nWe can then update our guess to `x_1 = x_0 + (k - x_0^2)/(2 * x_0)` and iterate the process until a tolerance is reached:\\n\\n    class Solution(object):\\n        def mySqrt(self, k):\\n            \"\"\"\\n            :type x: int\\n            :rtype: int\\n            \"\"\"\\n            \\n            #the sqrt of x should be less than (x+1)/2.0\\n            x = (k + 1)/4.0\\n            x2 = x * x\\n            \\n            diff = x2 - k\\n            e = 0.5\\n            \\n            while diff < -e or diff > e:\\n                x = x + (k - x2) / (2 * x)\\n                x2 = x * x\\n                diff = x2 - k\\n            \\n            return int(x)",
                "solutionTags": [
                    "Python"
                ],
                "code": "For reference of [Newton's method](https://en.wikipedia.org/wiki/Newton%27s_method). For the sake of description, I will call the input `k` instead of `x`.\\n\\n`Newton's method` finds the root of a function `f(x) = 0`. In this case `f(x) = k - x^2, x > 0`, where `k` is the given input and `x` is the variable we are trying to solve for. Take an initial guess of `x`, call it `x_0`. We can draw a tangent to the curve of the function `y = f(x)` at the point `(x_0, f(x_0))`. We can then find the intersection of this tangent with the `x-axis`. The intersection point can be solved as:\\n    \\n`(x_0 + (k - x_0^2)/(2 * x_0), 0)`\\n\\nIn general the intersection point is `(x_0 - f(x_0) / f'(x_0), 0)`, where `f'(x)` is the derivative of `f(x)`.\\n\\nWe can then update our guess to `x_1 = x_0 + (k - x_0^2)/(2 * x_0)` and iterate the process until a tolerance is reached:\\n\\n    class Solution(object):\\n        def mySqrt(self, k):\\n            \"\"\"\\n            :type x: int\\n            :rtype: int\\n            \"\"\"\\n            \\n            #the sqrt of x should be less than (x+1)/2.0\\n            x = (k + 1)/4.0\\n            x2 = x * x\\n            \\n            diff = x2 - k\\n            e = 0.5\\n            \\n            while diff < -e or diff > e:\\n                x = x + (k - x2) / (2 * x)\\n                x2 = x * x\\n                diff = x2 - k\\n            \\n            return int(x)",
                "codeTag": "Java"
            },
            {
                "id": 2670638,
                "title": "easy-binary-search-solution-java",
                "content": "nice pls upvote i want leet coins\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\t\\tpublic int mySqrt(int x) {\\n\\t\\t\\tint start = 0;\\n\\t\\t\\tint end = x; \\n\\t\\t\\tint mid = 0;\\n\\n\\t\\t\\tif(x==0) return 0;\\n\\t\\t\\tif(x==1) return 1;\\n\\n\\t\\t\\twhile(start<=end){\\n\\t\\t\\t\\tmid = start+(end-start)/2;\\n\\n\\t\\t\\t\\tif(mid==(x/mid)){\\n\\t\\t\\t\\t\\treturn mid;\\n\\n\\t\\t\\t\\t}else if(mid>x/mid){\\n\\n\\t\\t\\t\\t\\tend = mid-1;\\n\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tif((mid+1) > x/(mid+1)){\\n\\t\\t\\t\\t\\t\\treturn mid;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tstart = mid+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\n\\n\\t\\t\\treturn mid;\\n\\t\\t}\\n\\t}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\t\\tpublic int mySqrt(int x) {\\n\\t\\t\\tint start = 0;\\n\\t\\t\\tint end = x; \\n\\t\\t\\tint mid = 0;\\n\\n\\t\\t\\tif(x==0) return 0;\\n\\t\\t\\tif(x==1) return 1;\\n\\n\\t\\t\\twhile(start<=end){\\n\\t\\t\\t\\tmid = start+(end-start)/2;\\n\\n\\t\\t\\t\\tif(mid==(x/mid)){\\n\\t\\t\\t\\t\\treturn mid;\\n\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2419984,
                "title": "100-c-easy-to-understand-binary-search",
                "content": "**Code**\\n\\n**C++ :**\\n\\n**General Idea:**\\n- Draw a number line from 0 to x.\\n- Now we know that square root lies between 0 to x.\\n- Now apply binary search and find the solution in O(log N).\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\tint mySqrt(int x) {\\n\\t\\tlong i = 0;\\n\\t\\tint start, end;\\n\\t\\tlong mid;\\n\\t\\tstart = 0;\\n\\t\\tend = x;\\n\\t\\tif(x==1) return 1;\\n\\t\\tif(x==0) return 0;\\n\\t\\n\\t\\twhile (start<=end) // x=8\\n\\t\\t{\\n\\t\\t\\tmid = (start + end) / 2; // 4\\n        \\n\\t\\t\\tif (x >= (mid-1)*(mid-1) && x <= mid*mid )\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(mid*mid==x) return mid;\\n\\t\\t\\t\\telse return mid-1;\\n\\t\\t\\t}\\n\\n\\t\\t\\telse if (mid * mid > x)\\n\\t\\t\\t{\\n\\t\\t\\t\\tend = mid-1;\\n\\t\\t\\t}\\n\\n\\t\\t\\telse\\n\\t\\t\\t{start = mid+1;}\\n            \\n\\t\\t}\\n\\n\\t\\ti++;\\n\\n\\t\\treturn mid;\\n        \\n\\t\\t}\\n\\t\\t};\\n\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community).**\\n\\n**HAPPY CODING:)**\\n\\n*Any suggestions and improvements are always welcome*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\tint mySqrt(int x) {\\n\\t\\tlong i = 0;\\n\\t\\tint start, end;\\n\\t\\tlong mid;\\n\\t\\tstart = 0;\\n\\t\\tend = x;\\n\\t\\tif(x==1) return 1;\\n\\t\\tif(x==0) return 0;\\n\\t\\n\\t\\twhile (start<=end) // x=8\\n\\t\\t{\\n\\t\\t\\tmid = (start + end) / 2; // 4\\n        \\n\\t\\t\\tif (x >= (mid-1)*(mid-1) && x <= mid*mid )\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(mid*mid==x) return mid;\\n\\t\\t\\t\\telse return mid-1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1913570,
                "title": "problem-due-to-mid-mid-x-and-working-fine-with-mid-x-mid",
                "content": "**Any difference between `mid * mid > x`  and `mid > x / mid` ?**\\n\\nInitially I thought why the above same mathematical operation is not working, the operation with **mid * mid > x** is not working and the operation with **mid > x / mid** is working. Later I got to know its due to integer overflow because **mid * mid** may give a large number which may not be supported by simple int type. **mid** is integer, **mid * mid** might overflow?\\n\\n\\nWrong One:\\n```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        if(x<=1)\\n            return x;\\n        \\n        int low = 1;\\n        int high = x;\\n        while(high >= low) {\\n            int mid = (low + high) / 2;\\n            if (mid * mid == x ) {\\n                return mid;\\n            }\\n            else if(mid*mid > x ) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return high;\\n    }\\n}\\n```\\n\\n\\nAccepted One:\\n```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        if(x<=1)\\n            return x;\\n        \\n        int low = 1;\\n        int high = x;\\n        while(high >= low) {\\n            int mid = (low + high) / 2;\\n            if (mid == x / mid) {\\n                return mid;\\n            }\\n            else if(mid > x / mid) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return high;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        if(x<=1)\\n            return x;\\n        \\n        int low = 1;\\n        int high = x;\\n        while(high >= low) {\\n            int mid = (low + high) / 2;\\n            if (mid * mid == x ) {\\n                return mid;\\n            }\\n            else if(mid*mid > x ) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return high;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        if(x<=1)\\n            return x;\\n        \\n        int low = 1;\\n        int high = x;\\n        while(high >= low) {\\n            int mid = (low + high) / 2;\\n            if (mid == x / mid) {\\n                return mid;\\n            }\\n            else if(mid > x / mid) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return high;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693011,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n     public int mySqrt(int x) {\\n        if(x <= 1) return x;\\n        int start = 1;\\n        int end = x/2;\\n        \\n        while(start < end) {\\n            int mid = (start + (end-start)/2) + 1;\\n            \\n            int div = x/mid;\\n            if(div == mid) return mid;\\n            if(div > mid) start = mid;\\n            else end = mid-1;\\n        }\\n        \\n        return start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int mySqrt(int x) {\\n        if(x <= 1) return x;\\n        int start = 1;\\n        int end = x/2;\\n        \\n        while(start < end) {\\n            int mid = (start + (end-start)/2) + 1;\\n            \\n            int div = x/mid;\\n            if(div == mid) return mid;\\n            if(div > mid) start = mid;\\n            else end = mid-1;\\n        }\\n        \\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635982,
                "title": "python-faster-than-97-binary-search",
                "content": "![image](https://assets.leetcode.com/users/images/3fa1c0ca-f02a-4f9a-9739-4ca7bfd4b53c_1664393023.4905994.png)\\n```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        low = 0\\n        high = x\\n        \\n        while low <= high:\\n            mid = (low + high) // 2\\n            sqr = mid * mid\\n            if sqr == x or (sqr < x and (mid + 1) * (mid + 1) > x):\\n                return mid\\n            \\n            elif sqr > x:\\n                high = mid - 1\\n                \\n            else:\\n                low = mid + 1\\n```\\n**Please upvote if you find this helpful**",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        low = 0\\n        high = x\\n        \\n        while low <= high:\\n            mid = (low + high) // 2\\n            sqr = mid * mid\\n            if sqr == x or (sqr < x and (mid + 1) * (mid + 1) > x):\\n                return mid\\n            \\n            elif sqr > x:\\n                high = mid - 1\\n                \\n            else:\\n                low = mid + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587756,
                "title": "c-easy-and-fast-two-line-solution",
                "content": "**please upvote if helpful**\\n```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n          long r = x;\\n    while (r*r > x)\\n        r = (r + x/r) / 2;\\n    return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n          long r = x;\\n    while (r*r > x)\\n        r = (r + x/r) / 2;\\n    return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2110372,
                "title": "javascript-simple-solution",
                "content": "**Runtime: 152 ms, faster than 14.67% of JavaScript online submissions for Sqrt(x).\\nMemory Usage: 43.7 MB, less than 53.52% of JavaScript online submissions for Sqrt(x).**\\n```\\nvar mySqrt = function(x) {\\n    let sqrt = 1;\\n    if(x===0){\\n        return 0;\\n    }\\n    for(let i=1; i*i<=x; i++){\\n      sqrt = i;\\n    }\\n    return sqrt;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar mySqrt = function(x) {\\n    let sqrt = 1;\\n    if(x===0){\\n        return 0;\\n    }\\n    for(let i=1; i*i<=x; i++){\\n      sqrt = i;\\n    }\\n    return sqrt;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1584603,
                "title": "java-binary-search-100-fast-explained-with-comments",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int mySqrt(int x) {\\n        \\n       /* Brute force approach : Let us consider x as 16, now to find the square root we will take 16 nos. in the array [1,2,3,4,5,6,7,8,9, ... 16] and will check \\n            if  1*1 == 16\\n                2*2 == 16\\n                3*3 == 16\\n                4*4 == 16 -> found our answer  */\\n        \\n        int len = x;\\n        \\n        //Applying binary search in the array we formed\\n        \\n        int start = 0;\\n        int end = len;\\n        \\n        while(start <= end)\\n        {\\n            long mid = start + (end-start)/2;   //long datatype, as the range of x is very high\\n            \\n            if(x < mid * mid)\\n            {\\n                end = (int)mid - 1;\\n            }\\n            else if(x > mid * mid)\\n            {\\n                start = (int)mid + 1;\\n            }\\n            else \\n            {\\n                return (int)mid;\\n            }\\n        }\\n        \\n        //Now in the array we have to find the square root of the non-perfect squares\\n        /* Consider an example, \\n            x = 7 so, len = 7 \\n           \\n           start = 0, end = 7\\n           mid = 3 --->  7 < 9 -----> end = mid - 1 ----> end = 3 - 1 = 2\\n           \\n           start = 0, end = 2 \\n           mid = 1 ----> 7 > 1 -----> start = mid + 1 -----> start = 1 + 1 = 2\\n           \\n           start = 2, end = 2\\n           mid = 2 -----> 7 > 4 -------> start = mid + 1 -----> start = 2 + 1 = 3\\n           \\n           start > end terminated \\n           END ----> answer, if the number is non-perfect square */\\n        \\n        return end;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int mySqrt(int x) {\\n        \\n       /* Brute force approach : Let us consider x as 16, now to find the square root we will take 16 nos. in the array [1,2,3,4,5,6,7,8,9, ... 16] and will check \\n            if  1*1 == 16\\n                2*2 == 16\\n                3*3 == 16\\n                4*4 == 16 -> found our answer  */\\n        \\n        int len = x;\\n        \\n        //Applying binary search in the array we formed\\n        \\n        int start = 0;\\n        int end = len;\\n        \\n        while(start <= end)\\n        {\\n            long mid = start + (end-start)/2;   //long datatype, as the range of x is very high\\n            \\n            if(x < mid * mid)\\n            {\\n                end = (int)mid - 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 25208,
                "title": "c-binary-search-solution-easy-understand",
                "content": "    class Solution {\\n    public:\\n    int mySqrt(int x)\\n    {\\n    \\tlong long low = 0;\\n    \\tlong long high = x;\\n\\n    \\twhile (low < high)\\n    \\t{\\n    \\t\\tlong long mid = (high - low) / 2 + low;\\n\\n    \\t\\tif (mid * mid == x)\\n    \\t\\t\\treturn mid;\\n    \\t\\telse if (mid * mid > x)\\n    \\t\\t\\thigh = mid - 1;\\n    \\t\\telse\\n    \\t\\t\\tlow = mid + 1;\\n    \\t}\\n\\n    \\treturn low * low > x ? low - 1 : low;\\n    }\\n    };",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n    int mySqrt(int x)\\n    {\\n    \\tlong long low = 0;\\n    \\tlong long high = x;\\n\\n    \\twhile (low < high)\\n    \\t{\\n    \\t\\tlong long mid = (high - low) / 2 + low;\\n\\n    \\t\\tif (mid * mid == x)\\n    \\t\\t\\treturn mid;\\n    \\t\\telse if (mid * mid > x)\\n    \\t\\t\\thigh = mid - 1;\\n    \\t\\telse\\n    \\t\\t\\tlow = mid + 1;\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 3346718,
                "title": "easy-c-solution-binary-search",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe function first initializes two variables, `l` and `h` to **0** and `x` respectively. These variables are used to represent the lower and upper limits of the search range. \\n\\nWe also initializes an integer variable `\"ans\"` to store the final result.\\n\\nWe star a while loop where it continues to perform the Binary Search until the search range is exhausted (i.e., `l>h`). In each iteration of the loop, the function calculates the midpoint of the search range, `\"mid\"`, using the formula `\"mid=l+(h-l)/2\"`. It also calculates the square of `\"mid\"`, `\"sq=mid*mid\"`.\\n\\nIf `sq == x`, then `\"mid\"` is the square root of `\"x\"`, and the function sets \"ans\" to `\"mid\"` and breaks out of the loop.\\n\\nIf `sq < x`, then the square root of `\"x\"` must be in the right half of the search range, and the function sets \"l\" to \"mid+1\" to search in the right half.\\n\\nIf `sq > x`, then the square root of `\"x\"` must be in the left half of the search range, and the function sets `\"h\" to \"mid-1\"` to search in the left half.\\n\\nFinally, the function returns the value of \"ans\", which represents the floor value of the square root of `\"x\"`.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(log(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int mySqrt(int x) {\\n         int l=0,h=x;\\n         int ans;\\n        while(l<=h){\\n\\n           long long int mid=l+(h-l)/2;\\n           long long int sq=mid*mid;\\n\\n           if(sq==x){\\n               ans=mid;\\n               break;\\n            }\\n            else if(sq<x){\\n                //mid=ans;\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int mySqrt(int x) {\\n         int l=0,h=x;\\n         int ans;\\n        while(l<=h){\\n\\n           long long int mid=l+(h-l)/2;\\n           long long int sq=mid*mid;\\n\\n           if(sq==x){\\n               ans=mid;\\n               break;\\n            }\\n            else if(sq<x){\\n                //mid=ans;\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101509,
                "title": "3-different-solutions-using-js-o-1-o-n-o-logn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJavaScript Solution\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSolution I:\\n\\n- This is the simplest solution which uses the built-in function Math.sqrt() which takes a number as input and returns the square root of that number.\\n\\n- The function Math.floor() is used to round down the decimal number to the nearest integer.\\n\\nSolution II:\\n\\n- This solution uses a for loop to iterate through all the numbers from 0 to x+1.\\n\\n- It checks if i*i is greater than x, if it is then it returns i-1.\\n\\nSolution III:\\n\\n- This solution uses a binary search algorithm to find the square root.\\n- It checks if x is less than 2, if it is then it returns x.\\n- It initializes a variable result to 0, start to 1, and end to x/2.\\n- It uses while loop to iterate until start is less than or equal to end.\\n- It finds the middle element between start and end and checks if mid*mid is equal to x, if it is then return mid.\\n- If mid*mid is less than x then start is set to mid+1 and result is set to mid.\\n- Else end is set to mid-1.\\n- Finally, it returns the result.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSolution I:\\n\\n- Time Complexity: O(1) as it uses a built-in function to calculate the square root.\\n\\nSolution II:\\n\\n- Time Complexity: O(x) as it iterates through all the numbers from 0 to x+1.\\n\\nSolution III:\\n\\n- Time Complexity: O(log n) as the binary search algorithm reduces the number of iterations by half on each iteration.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nSolution I: \\n- Space Complexity: O(1) as it only uses a single variable to store the result.\\n\\nSolution II:\\n- Space Complexity: O(1) as it only uses a single variable to store the result.\\n\\n\\nSolution III:\\n- Space Complexity: O(1) as it only uses a few variables to store the result, start, and end.\\n# Code\\n```\\n/**\\n * @param {number} x\\n * @return {number}\\n */\\nvar mySqrt = function(x) {\\n\\n    // Solution I\\n\\n    // return Math.floor(Math.sqrt(x));\\n\\n    // Solution II\\n\\n    // for(let i = 0; i<=x + 1; i++){\\n    //     if(i*i>x){\\n    //         return i-1;\\n    //     }\\n    // }\\n\\n     // Solution III\\n\\n    //  Binary Search Solution\\n\\n    if(x < 2) return x;\\n    let result = 0;\\n    let start = 1;\\n    let end = x/2;\\n\\n    while(start<=end){\\n        let mid = Math.floor(start + (end-start)/2);\\n        let sqr = mid*mid;\\n        if(sqr == x) return mid;\\n        else if(sqr<x){ start = mid + 1; result = mid;}\\n        else end = mid - 1;\\n\\n    }\\n\\n    return result;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * @param {number} x\\n * @return {number}\\n */\\nvar mySqrt = function(x) {\\n\\n    // Solution I\\n\\n    // return Math.floor(Math.sqrt(x));\\n\\n    // Solution II\\n\\n    // for(let i = 0; i<=x + 1; i++){\\n    //     if(i*i>x){\\n    //         return i-1;\\n    //     }\\n    // }\\n\\n     // Solution III\\n\\n    //  Binary Search Solution\\n\\n    if(x < 2) return x;\\n    let result = 0;\\n    let start = 1;\\n    let end = x/2;\\n\\n    while(start<=end){\\n        let mid = Math.floor(start + (end-start)/2);\\n        let sqr = mid*mid;\\n        if(sqr == x) return mid;\\n        else if(sqr<x){ start = mid + 1; result = mid;}\\n        else end = mid - 1;\\n\\n    }\\n\\n    return result;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 992001,
                "title": "easy-without-inbuilt-function-binary-search-96-faster",
                "content": "```\\nimport math\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x < 2: return x\\n        result = 0 \\n        left = 1\\n        right = x/2\\n        while left <= right:\\n            mid = math.floor((left+right)/2)\\n            if mid * mid > x:\\n                right = mid - 1\\n            else:\\n                result = mid\\n                left = mid + 1\\n        return result\\n```\\n\\nPlease Upvote once you get it.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x < 2: return x\\n        result = 0 \\n        left = 1\\n        right = x/2\\n        while left <= right:\\n            mid = math.floor((left+right)/2)\\n            if mid * mid > x:\\n                right = mid - 1\\n            else:\\n                result = mid\\n                left = mid + 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 715772,
                "title": "rust-solutions",
                "content": "### 1. Brute Force\\n```Rust\\nimpl Solution {\\n    pub fn my_sqrt(x: i32) -> i32 {\\n        let mut n = 1;\\n        while n <= x / n {\\n            n += 1;\\n        }\\n        n - 1\\n    }\\n}\\n```\\n\\n### 2. Binary Search\\n```Rust\\nimpl Solution {\\n    pub fn my_sqrt(x: i32) -> i32 {\\n        if x == 0 || x == 1 {\\n            return x;\\n        }\\n        let mut left = 0;\\n        let mut right = x;\\n        let mut mid = (left + right) / 2;\\n        loop {\\n            if mid <= x / mid && (mid + 1) > x / (mid + 1) {\\n                return mid;\\n            } else if mid > x / mid {\\n                right = mid;\\n            } else if mid < x / mid {\\n                left = mid;\\n            }\\n            mid = (left + right) / 2;\\n        }\\n    }\\n}\\n```\\n\\n### 3. (n + 1)<sup>2</sup> = n<sup>2</sup> + 2n + 1\\n```Rust\\nimpl Solution {\\n    pub fn my_sqrt(x: i32) -> i32 {\\n        let mut n = 0;\\n        let mut x = x - 1;\\n        while x >= 0 {\\n            n += 1;\\n            x -= 2 * n + 1;\\n        }\\n        n\\n    }\\n}\\n```\\n\\n### 4. Newton\\'s Method\\n```Rust\\nimpl Solution {\\n    pub fn my_sqrt(x: i32) -> i32 {\\n        if x == 0 {\\n            return 0;\\n        }\\n        let x = x as usize;\\n        let mut n = x;\\n        while n > x / n {\\n            n = (n + x / n) / 2;\\n        }\\n        n as i32\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\nimpl Solution {\\n    pub fn my_sqrt(x: i32) -> i32 {\\n        let mut n = 1;\\n        while n <= x / n {\\n            n += 1;\\n        }\\n        n - 1\\n    }\\n}\\n```\n```Rust\\nimpl Solution {\\n    pub fn my_sqrt(x: i32) -> i32 {\\n        if x == 0 || x == 1 {\\n            return x;\\n        }\\n        let mut left = 0;\\n        let mut right = x;\\n        let mut mid = (left + right) / 2;\\n        loop {\\n            if mid <= x / mid && (mid + 1) > x / (mid + 1) {\\n                return mid;\\n            } else if mid > x / mid {\\n                right = mid;\\n            } else if mid < x / mid {\\n                left = mid;\\n            }\\n            mid = (left + right) / 2;\\n        }\\n    }\\n}\\n```\n```Rust\\nimpl Solution {\\n    pub fn my_sqrt(x: i32) -> i32 {\\n        let mut n = 0;\\n        let mut x = x - 1;\\n        while x >= 0 {\\n            n += 1;\\n            x -= 2 * n + 1;\\n        }\\n        n\\n    }\\n}\\n```\n```Rust\\nimpl Solution {\\n    pub fn my_sqrt(x: i32) -> i32 {\\n        if x == 0 {\\n            return 0;\\n        }\\n        let x = x as usize;\\n        let mut n = x;\\n        while n > x / n {\\n            n = (n + x / n) / 2;\\n        }\\n        n as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 220383,
                "title": "binary-search-solution-with-pictured-explanation-o-log-x",
                "content": "Explanaiton for this step is:\\nif mid == low or mid ** 2 == x: return mid\\nWhen its a perfect square then it will follow the mid ** 2 ==x, \\nbut for not perfect squares we have to give lower bound, thus it boils down to mid == low. I have tried to explain in picture Below.\\n\\n```\\nclass Solution:\\n    def mySqrt(self, x):\\n        if x==1 or x==0:\\n            return x\\n        low,high = 1,x\\n        while low<high:\\n            mid = (low+high)//2\\n            if mid == low or mid**2 == x: \\n                return mid\\n            if mid**2 > x:\\n                high = mid\\n            else:\\n                low = mid\\n```\\n![image](https://assets.leetcode.com/users/ramanahuja/image_1547702774.png)\\n![image](https://assets.leetcode.com/users/ramanahuja/image_1547702778.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mySqrt(self, x):\\n        if x==1 or x==0:\\n            return x\\n        low,high = 1,x\\n        while low<high:\\n            mid = (low+high)//2\\n            if mid == low or mid**2 == x: \\n                return mid\\n            if mid**2 > x:\\n                high = mid\\n            else:\\n                low = mid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25200,
                "title": "very-easy-java-o-log-n-method-using-binary-search-with-explanation",
                "content": "I used the idea of https://leetcode.com/discuss/24942/a-binary-search-solution for this. I have made modifications to make it more readable and easy to understand.\\n\\n    // Log n - Binary Search\\n\\tpublic int mySqrt(int x) \\n\\t{\\n\\t\\tif (x == 0)\\n\\t\\t\\treturn 0;\\n\\t\\t\\n\\t\\tlong left = 1;\\n\\t\\tlong right = x;\\n\\t\\t\\n\\t\\twhile (true) \\n\\t\\t{\\n\\t\\t    // It has to be long because we are calculating its product while checking\\n\\t\\t\\tlong mid = (left + right)/2;\\n\\t\\t\\t\\n\\t\\t\\tif (mid * mid > x) \\n\\t\\t\\t{\\n\\t\\t\\t\\tright = mid - 1;\\n\\t\\t\\t} \\n\\t\\t\\telse \\n\\t\\t\\t{\\n\\t\\t\\t    // mid^2 was less than x. Check about (mid+1) is greater than x? If yes, he's our guy.\\n\\t\\t\\t\\tif ((mid + 1) * (mid + 1) > x)\\n\\t\\t\\t\\t\\treturn (int) mid;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "I used the idea of https://leetcode.com/discuss/24942/a-binary-search-solution for this. I have made modifications to make it more readable and easy to understand.\\n\\n    // Log n - Binary Search\\n\\tpublic int mySqrt(int x) \\n\\t{\\n\\t\\tif (x == 0)\\n\\t\\t\\treturn 0;\\n\\t\\t\\n\\t\\tlong left = 1;\\n\\t\\tlong right = x;\\n\\t\\t\\n\\t\\twhile (true) \\n\\t\\t{\\n\\t\\t    // It has to be long because we are calculating its product while checking\\n\\t\\t\\tlong mid = (left + right)/2;\\n\\t\\t\\t\\n\\t\\t\\tif (mid * mid > x) \\n\\t\\t\\t{\\n\\t\\t\\t\\tright = mid - 1;\\n\\t\\t\\t} \\n\\t\\t\\telse \\n\\t\\t\\t{\\n\\t\\t\\t    // mid^2 was less than x. Check about (mid+1) is greater than x? If yes, he's our guy.\\n\\t\\t\\t\\tif ((mid + 1) * (mid + 1) > x)\\n\\t\\t\\t\\t\\treturn (int) mid;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2789266,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint mySqrt(int x) {\\n\\t\\t\\tint i=0, j=x, ans;\\n\\t\\t\\twhile(i<=j){\\n\\t\\t\\t\\tlong long int mid=i+(j-i)/2;\\n\\t\\t\\t\\tif(mid*mid==x){ans = mid; break;}\\n\\t\\t\\t\\telse if(mid*mid<x){i=mid+1;}\\n\\t\\t\\t\\telse{j=mid-1;}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint mySqrt(int x) {\\n\\t\\t\\tint i=0, j=x, ans;\\n\\t\\t\\twhile(i<=j){\\n\\t\\t\\t\\tlong long int mid=i+(j-i)/2;\\n\\t\\t\\t\\tif(mid*mid==x){ans = mid; break;}",
                "codeTag": "Java"
            },
            {
                "id": 2711670,
                "title": "fastest-and-easiest-faster-than-99-submissions-binary-search",
                "content": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x==0 or x==1: return x\\n        max = x;\\n        min = 0;\\n        q = (min+max)//2;\\n        while(min < max):\\n            c = q * q;\\n            if c == x: \\n                return q;\\n            elif c < x: \\n                min = q+1;\\n            else: \\n                max=q;\\n            q=(min+max)//2;\\n        return q - 1;\\n```\\nDo upvote if its helpful,Thanks,",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x==0 or x==1: return x\\n        max = x;\\n        min = 0;\\n        q = (min+max)//2;\\n        while(min < max):\\n            c = q * q;\\n            if c == x: \\n                return q;\\n            elif c < x: \\n                min = q+1;\\n            else: \\n                max=q;\\n            q=(min+max)//2;\\n        return q - 1;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995489,
                "title": "python-98-easy-binary-search",
                "content": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x == 1:\\n            return 1\\n        left = 0\\n        right = x//2\\n        while left <= right:\\n            mid = (left + right)//2\\n            if mid * mid == x:\\n                return mid\\n            elif mid * mid < x:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        \\n        return trunc(right)\\n\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x == 1:\\n            return 1\\n        left = 0\\n        right = x//2\\n        while left <= right:\\n            mid = (left + right)//2\\n            if mid * mid == x:\\n                return mid\\n            elif mid * mid < x:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        \\n        return trunc(right)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1947340,
                "title": "python-newton-s-method",
                "content": "![image](https://assets.leetcode.com/users/images/6d9788fa-f156-4ec8-8d20-1ea3568f4af7_1649959471.8358445.png)\\n\\n```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n\\n        k = x/2 # initial value\\n        \\n        while abs(k*k - x)>=0.1:    \\n            k = k  - (k*k - x)/(2 * k) #update\\n        return int(k)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n\\n        k = x/2 # initial value\\n        \\n        while abs(k*k - x)>=0.1:    \\n            k = k  - (k*k - x)/(2 * k) #update\\n        return int(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441125,
                "title": "java-o-logn-time-o-1-space-binary-search-faster-than-100",
                "content": "Runtime: 1 ms, faster than 100.00% of Java online submissions for Sqrt(x).\\nMemory Usage: 36.1 MB, less than 66.60% of Java online submissions for Sqrt(x).\\n\\n```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        if(x == 0) // To avoid division by 0\\n            return 0;\\n        int start = 1, end = x / 2 + 1; // The squareroot can only lie in this range\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(mid == x / mid) // Not multiplying as the product for a large number may be greater than the max value of int\\n                return mid;\\n            else if(mid < x / mid) \\n                start = mid + 1;\\n            else\\n                end = mid - 1;\\n        }\\n        return end; // end will be the largest integer such that end^2 < x\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        if(x == 0) // To avoid division by 0\\n            return 0;\\n        int start = 1, end = x / 2 + 1; // The squareroot can only lie in this range\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(mid == x / mid) // Not multiplying as the product for a large number may be greater than the max value of int\\n                return mid;\\n            else if(mid < x / mid) \\n                start = mid + 1;\\n            else\\n                end = mid - 1;\\n        }\\n        return end; // end will be the largest integer such that end^2 < x\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250217,
                "title": "java-visual-explaination-binary-search-clean-and-short-solution-2ms",
                "content": "I\\'m a visual learner so i have to map it out on piece of paper, to help me see it clearly, hope this can help you too.\\nAlso I saw few people asking why `x / mid` instead of `mid * mid`, i was struggling to see it at first, but finally understood it. \\nit\\'s just a math trick.\\n```java\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int left = 1;\\n        int right = x;\\n        while (left <= right){\\n            // pervent overflow\\n            int mid = left + (right - left) / 2;\\n            // math concept of move multiplication to other side becomes division\\n            // (this)                       (here)      \\n            //  |                            |\\n            //  V                            V\\n            // mid * mid = x equals to  x / mid = mid\\n            // this also pervents overflow of mid * mid being too large\\n            if (mid > x / mid) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        \\n        return right;\\n    }\\n}\\n// Time O(logn)\\n\\n// Visual Run x = 8\\n// X   Left  Right  Mid  compare  X/Mid\\n// 8     1    8      4       >       2\\n// 8     1    3      2       <       4\\n// 8     3    3      3       >       2\\n// 8     3    2      Stopped here because right < left\\n\\n// x = 9\\n// X   Left  Right  Mid  compare  X/Mid\\n// 9     1    9      5       >       1\\n// 9     1    4      2       <       4\\n// 9     3    4      3       >       2\\n// 9     3    2     Stopped here because right < left\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```java\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int left = 1;\\n        int right = x;\\n        while (left <= right){\\n            // pervent overflow\\n            int mid = left + (right - left) / 2;\\n            // math concept of move multiplication to other side becomes division\\n            // (this)                       (here)      \\n            //  |                            |\\n            //  V                            V\\n            // mid * mid = x equals to  x / mid = mid\\n            // this also pervents overflow of mid * mid being too large\\n            if (mid > x / mid) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        \\n        return right;\\n    }\\n}\\n// Time O(logn)\\n\\n// Visual Run x = 8\\n// X   Left  Right  Mid  compare  X/Mid\\n// 8     1    8      4       >       2\\n// 8     1    3      2       <       4\\n// 8     3    3      3       >       2\\n// 8     3    2      Stopped here because right < left\\n\\n// x = 9\\n// X   Left  Right  Mid  compare  X/Mid\\n// 9     1    9      5       >       1\\n// 9     1    4      2       <       4\\n// 9     3    4      3       >       2\\n// 9     3    2     Stopped here because right < left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 311341,
                "title": "java-binary-search-solution-with-no-overflow-errors",
                "content": "```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        if(x == 0 || x== 1){\\n            return x;\\n        }\\n        int left = 0;\\n        int right = x/2 + 1;\\n        while (left <= right){\\n            int mid = left + (right-left)/2;\\n            if (mid < x/mid) { left = mid+1;}\\n            else if (mid > x/mid) { right = mid-1;}\\n            else { return mid;}\\n        }\\n        return right;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        if(x == 0 || x== 1){\\n            return x;\\n        }\\n        int left = 0;\\n        int right = x/2 + 1;\\n        while (left <= right){\\n            int mid = left + (right-left)/2;\\n            if (mid < x/mid) { left = mid+1;}\\n            else if (mid > x/mid) { right = mid-1;}\\n            else { return mid;}\\n        }\\n        return right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 166438,
                "title": "binary-search-java-with-explanations",
                "content": "**Logical Thought**\\nThe problem is to find a value `v` such that `v * v <= x && (v + 1) * (v + 1) > x` in `[1, x / 2]`. That\\'s natural to **Binary Search**.\\nThe **loop invariant** contributes to the implementation.\\nIf we assert `v` must exist in `[lo, hi]`,\\n* Initially, `1 <= v <= x / 2`, to satisfy the assertion, `lo = 0, hi = x / 2`.\\n* For `mi = lo + ((hi - lo) >> 1)`,\\nif ``mi * mi <= x && (mi + 1) * (mi+ 1) > x``, mi is target, return `mi`; [there]\\nif ``mi * mi <= x && (mi + 1) * (mi + 1) <= x``, to satisfy the assertion, `lo = mi + 1`.\\nif ``mi * mi > x && (mi + 1) * (mi + 1) > x``, hi = mi, `v` must exist in `[lo, mi - 1]`, to satisfy the assertion, `hi = mi - 1`.\\n* Since there must be a valid answer, the loop will terminates [there].\\n\\n**Trick**\\n`x = 0 or 1` can be processed specially. In addition, to avoid Integer Overflow,` lo, hi, and mi `are `long` rather than `int`.\\n\\n**Clear Code**\\n```\\n    public int mySqrt(int x) {\\n        \\n        if (x <= 1) {\\n            return x;\\n        }\\n        \\n        long lo = 1, hi = x / 2;\\n        \\n        while (lo <= hi) {\\n            long mi = lo + ((hi - lo) >> 1);\\n            if (mi * mi <= x && (mi + 1) * (mi + 1) > x) {\\n                return (int)mi;\\n            }\\n            if ((mi + 1) * (mi + 1) <= x) {\\n                lo = mi + 1;\\n            }\\n            if (mi * mi > x) {\\n                hi = mi - 1;\\n            }\\n        }\\n        \\n        throw null;\\n    }\\n```\\nI appreciate your **VOTE UP** (\\u02CAo\\u0334\\u0336\\u0337\\u0324\\u2304o\\u0334\\u0336\\u0337\\u0324\\u02CB) ",
                "solutionTags": [],
                "code": "```\\n    public int mySqrt(int x) {\\n        \\n        if (x <= 1) {\\n            return x;\\n        }\\n        \\n        long lo = 1, hi = x / 2;\\n        \\n        while (lo <= hi) {\\n            long mi = lo + ((hi - lo) >> 1);\\n            if (mi * mi <= x && (mi + 1) * (mi + 1) > x) {\\n                return (int)mi;\\n            }\\n            if ((mi + 1) * (mi + 1) <= x) {\\n                lo = mi + 1;\\n            }\\n            if (mi * mi > x) {\\n                hi = mi - 1;\\n            }\\n        }\\n        \\n        throw null;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25224,
                "title": "newton-s-method-with-only-one-variable",
                "content": "    public class Solution {\\n        public int mySqrt(int x) {\\n            double x0 = 1;\\n            do{\\n                x0 = (x0+ x/x0)/2;\\n            }while(Math.abs(Math.pow(x0, 2) - x) >= 1);\\n            return (int)x0;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int mySqrt(int x) {\\n            double x0 = 1;\\n            do{\\n                x0 = (x0+ x/x0)/2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 25217,
                "title": "4ms-c-solution-using-carmack-s-method",
                "content": "Carmack's method is a fast way to find the inverse square root of a float number:\\n\\n[http://en.wikipedia.org/wiki/Fast_inverse_square_root][1]\\n\\nCarmack's method is fast because:\\n\\n 1. The initial guess is super accurate.\\n 2. Does not use division.\\n 3. Does not use loops.\\n\\nNote that Carmack's method is no longer useful nowadays and this is just for fun.\\n\\n\\n    class Solution {\\n        public:\\n        int mySqrt(int x) {\\n            uint64_t i;\\n            double x2, y;\\n            x2 = x * 0.5;\\n            y = x;\\n            i = *(uint64_t *) &y;\\n            i = 0x5fe6eb50c7b537a9 - (i >> 1); // This magic number is taken from wikipedia.\\n            y = *(double *) &i; // initial guess of the inverse square root\\n            y = y * (1.5 - (x2 * y * y)); // Newton for inverse square root.\\n            y = y * (1.5 - (x2 * y * y));\\n            y = y * (1.5 - (x2 * y * y));\\n            y = y * (1.5 - (x2 * y * y)); // repeate 4 times to get enough precision.\\n            return x * y;\\n        }\\n    };\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Fast_inverse_square_root",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        public:\\n        int mySqrt(int x) {\\n            uint64_t i;\\n            double x2, y;\\n            x2 = x * 0.5;\\n            y = x;\\n            i = *(uint64_t *) &y;\\n            i = 0x5fe6eb50c7b537a9 - (i >> 1); // This magic number is taken from wikipedia.\\n            y = *(double *) &i; // initial guess of the inverse square root\\n            y = y * (1.5 - (x2 * y * y)); // Newton for inverse square root.\\n            y = y * (1.5 - (x2 * y * y));\\n            y = y * (1.5 - (x2 * y * y));\\n            y = y * (1.5 - (x2 * y * y)); // repeate 4 times to get enough precision.\\n            return x * y;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3648823,
                "title": "beats-100-c-solutions-using-newton-s-method-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNewton\\'s method is taught in Calculus. Just use it to solve the problem\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe fomula for Newton\\'s method for finding $\\\\sqrt{a}$ is:\\n$$\\nx_{n+1}=x_n-\\\\frac{f(x_n)}{f\\'(x_n)}\\n$$\\nwhere $f(x)=x^2-a$, $f\\'(x)=2x$ is the first derivative. The sequence $\\\\{ x_n\\\\}$ converges to $\\\\sqrt{a}$.\\n```\\na=2147483647, the values for x_n for n=0,1,2,....\\n2147483647\\n1073741824\\n536870913\\n268435458.5\\n134217733.2\\n67108874.62\\n33554453.31\\n16777258.66\\n8388693.328\\n4194474.663\\n2097493.321\\n1049258.577\\n525652.6224\\n264868.9945\\n136488.3573\\n76111.0901\\n52163.10575\\n46665.86832\\n46342.08115\\n46340.95001\\n46340.95\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n[Please turn the English subtitles if necessary]\\n[https://www.youtube.com/watch?v=7MmCTAbviyY](https://www.youtube.com/watch?v=7MmCTAbviyY)\\n# Code using Newton\\'s method\\n```C++ []\\nclass Solution {\\npublic:\\n    int mySqrt(int n) {\\n        if (n==0) return 0;\\n        double x=n ,x0=1;\\n        while (abs(x-x0)>=1){\\n            x0=x;\\n            x=x0-(x0*x0-n)/(2*x0);\\n        }\\n        if (x<=x0) return int(x);\\n        else return int(x0);\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def mySqrt(self, n: int) -> int:\\n        if n==0 : return 0\\n        x, x0=n, 1\\n        while abs(x-x0)>=1:\\n            x0=x \\n            x=x0-(x0*x0-n)/(2*x0)\\n        if x<=x0: return int(x)\\n        else: return int(x0)\\n```\\n# Code using binary search\\n```\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        if (x==0) return 0;\\n        int low=1, high=x, mid;\\n        while(high-low>1){\\n            mid=low+(high-low)/2;\\n            if ((long long)mid*mid<=(long long)x)\\n                low=mid;\\n            else\\n                high=mid;\\n        }\\n        return low;       \\n    }\\n};\\n```\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\na=2147483647, the values for x_n for n=0,1,2,....\\n2147483647\\n1073741824\\n536870913\\n268435458.5\\n134217733.2\\n67108874.62\\n33554453.31\\n16777258.66\\n8388693.328\\n4194474.663\\n2097493.321\\n1049258.577\\n525652.6224\\n264868.9945\\n136488.3573\\n76111.0901\\n52163.10575\\n46665.86832\\n46342.08115\\n46340.95001\\n46340.95\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int mySqrt(int n) {\\n        if (n==0) return 0;\\n        double x=n ,x0=1;\\n        while (abs(x-x0)>=1){\\n            x0=x;\\n            x=x0-(x0*x0-n)/(2*x0);\\n        }\\n        if (x<=x0) return int(x);\\n        else return int(x0);\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def mySqrt(self, n: int) -> int:\\n        if n==0 : return 0\\n        x, x0=n, 1\\n        while abs(x-x0)>=1:\\n            x0=x \\n            x=x0-(x0*x0-n)/(2*x0)\\n        if x<=x0: return int(x)\\n        else: return int(x0)\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        if (x==0) return 0;\\n        int low=1, high=x, mid;\\n        while(high-low>1){\\n            mid=low+(high-low)/2;\\n            if ((long long)mid*mid<=(long long)x)\\n                low=mid;\\n            else\\n                high=mid;\\n        }\\n        return low;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412512,
                "title": "easiest-c-binary-search-100-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- There is a trick in this question that we have to spot first.\\n- We know that the square root of a number cannot be bigger than the number itself so we got out end point.\\n- now we can check if any number which has square `more` or `less` or `equal` to the number itself.\\n- Right ! binary search would be a great approach to proceed.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- So first lets take care of the edge cases, for `0 and 1` we will simply return x itself.\\n- for everything else we can proceed with normal binary search algorithm.\\n- one more thing to remember that `mid*mid` will give you a very large number so instead of proceeding with that use `mid = x/mid` which is nothing but same thing and also dos\\'nt cost you that issue.\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Upvote! It only takes 1 click :)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        if(x==0 || x==1){\\n            return x;\\n        }\\n        int start = 0;\\n        int end = x;\\n        int  mid = start + (end-start)/2;\\n        while(start<=end){\\n            if(mid == x / mid){\\n                return mid;\\n            }\\n            else if(mid > x/mid){\\n                end = mid-1;\\n            }\\n            else{\\n                start = mid+1;\\n            }\\n            mid = start +(end-start)/2;\\n        }\\n        return end;\\n\\n    }\\n};\\n```\\n![Upvote.jpeg](https://assets.leetcode.com/users/images/0094b8d5-a402-48bc-96ee-02c9e86fb6f0_1681384103.2052226.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        if(x==0 || x==1){\\n            return x;\\n        }\\n        int start = 0;\\n        int end = x;\\n        int  mid = start + (end-start)/2;\\n        while(start<=end){\\n            if(mid == x / mid){\\n                return mid;\\n            }\\n            else if(mid > x/mid){\\n                end = mid-1;\\n            }\\n            else{\\n                start = mid+1;\\n            }\\n            mid = start +(end-start)/2;\\n        }\\n        return end;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946417,
                "title": "simple-java-solution-100-faster",
                "content": "\\n```\\nclass Solution {\\n    public int mySqrt(int x) {\\n       int start=1, end=x,floorRes=0;\\n       while(start<=end){\\n           int mid=start+(end-start)/2;\\n\\n           if(mid<=x/mid){\\n               floorRes=mid;\\n               start=mid+1;\\n           }\\n           else{\\n               end=mid-1;\\n           }\\n       } \\n       return floorRes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mySqrt(int x) {\\n       int start=1, end=x,floorRes=0;\\n       while(start<=end){\\n           int mid=start+(end-start)/2;\\n\\n           if(mid<=x/mid){\\n               floorRes=mid;\\n               start=mid+1;\\n           }\\n           else{\\n               end=mid-1;\\n           }\\n       } \\n       return floorRes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872277,
                "title": "commented-go-solution-w-binary-search-100-runtime",
                "content": "```\\nfunc mySqrt(x int) int {\\n    /*\\n    Define the search space:\\n        Min answer we can get is 0.\\n        Max answer is x + 1 in case x = 0 or x = 1.\\n    */\\n    left, right := 0, x + 1\\n\\n    for left < right {\\n        mid := left + (right - left) / 2\\n\\n        /*\\n        If we overshoot, move the right pointer to the left.\\n        Otherwise, move the left pointer to the right.\\n        */\\n        if mid * mid > x {\\n            right = mid\\n        } else {\\n            left = mid + 1\\n        }\\n    }\\n\\n    /*\\n    At the end of the loop, the left pointer will be placed at ceil(n) such that n^2 = x.\\n\\n    For example, x = 8 (sqrt is 2.82842...) and the left pointer will be at 3. \\n    Return left - 1 = 3 - 1 = 2\\n\\n    So we need to return (left - 1) as we are asked to round the answer down to the neares integer.\\n    */\\n    return left - 1\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nfunc mySqrt(x int) int {\\n    /*\\n    Define the search space:\\n        Min answer we can get is 0.\\n        Max answer is x + 1 in case x = 0 or x = 1.\\n    */\\n    left, right := 0, x + 1\\n\\n    for left < right {\\n        mid := left + (right - left) / 2\\n\\n        /*\\n        If we overshoot, move the right pointer to the left.\\n        Otherwise, move the left pointer to the right.\\n        */\\n        if mid * mid > x {\\n            right = mid\\n        } else {\\n            left = mid + 1\\n        }\\n    }\\n\\n    /*\\n    At the end of the loop, the left pointer will be placed at ceil(n) such that n^2 = x.\\n\\n    For example, x = 8 (sqrt is 2.82842...) and the left pointer will be at 3. \\n    Return left - 1 = 3 - 1 = 2\\n\\n    So we need to return (left - 1) as we are asked to round the answer down to the neares integer.\\n    */\\n    return left - 1\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2812675,
                "title": "use-newton-s-approach",
                "content": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n\\n        k = x/2 # initial value\\n        \\n        while abs(k*k - x)>=0.1:    \\n            k = k  - (k*k - x)/(2 * k) #update\\n        return int(k)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n\\n        k = x/2 # initial value\\n        \\n        while abs(k*k - x)>=0.1:    \\n            k = k  - (k*k - x)/(2 * k) #update\\n        return int(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765330,
                "title": "c-sqrt",
                "content": "```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        if (x==0) return 0;\\n        int left{1}, right{x}, mid{x/2};\\n        while (left<=right) {\\n            if (mid==0) break;\\n            \\n            if (x/mid < mid) {\\n                right=mid-1;\\n            }\\n            \\n            else if (x/mid > mid) {\\n                if (x/(mid+1) < mid+1) return mid;\\n                else left = mid+1;\\n            }\\n\\n            else return mid;\\n\\n            mid=left + (right-left)/2;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        if (x==0) return 0;\\n        int left{1}, right{x}, mid{x/2};\\n        while (left<=right) {\\n            if (mid==0) break;\\n            \\n            if (x/mid < mid) {\\n                right=mid-1;\\n            }\\n            \\n            else if (x/mid > mid) {\\n                if (x/(mid+1) < mid+1) return mid;\\n                else left = mid+1;\\n            }\\n\\n            else return mid;\\n\\n            mid=left + (right-left)/2;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765137,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n\\n        low = 0\\n        high = x//2 + 1\\n        while low < high:\\n            mid = low + (high - low + 1) // 2\\n            if mid * mid > x:\\n                high = mid - 1\\n            else:\\n                low = mid\\n\\n        return low\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n\\n        low = 0\\n        high = x//2 + 1\\n        while low < high:\\n            mid = low + (high - low + 1) // 2\\n            if mid * mid > x:\\n                high = mid - 1\\n            else:\\n                low = mid\\n\\n        return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761949,
                "title": "c-python-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nfind the largest `n` that `n * n <= x`. The largest possible number is `x // 2 + 1`, and smallest is `0`. so use binary search to find `n`.\\n\\nwhy `mid = low + (high - low + 1) // 2`?\\nBecause we update high value with `high = mid - 1`, we need to set mid closer to `high`, or we will have infinite loop if:\\n`mid = low = high + 1`, so `mid = (low + high) //2` and `mid * mid <= x`.\\n\\nwhy `left < right` rather than `left <= right`?\\n`left <= right` will also lead to infinite loop when:\\n`left = right = mid` and `mid * mid <= x`.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(logN)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\nPython:\\n```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n\\n        low = 0\\n        high = x//2 + 1\\n        while low < high:\\n            mid = low + (high - low + 1) // 2\\n            if mid * mid > x:\\n                high = mid - 1\\n            else:\\n                low = mid\\n\\n        return low\\n```\\n\\nC++:\\n```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        int low = 0, high = x/2 + 1;\\n        while (low < high) {\\n            long mid = low + (high - low + 1) / 2;\\n            if (mid * mid <= x) {\\n                low = mid;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n\\n        low = 0\\n        high = x//2 + 1\\n        while low < high:\\n            mid = low + (high - low + 1) // 2\\n            if mid * mid > x:\\n                high = mid - 1\\n            else:\\n                low = mid\\n\\n        return low\\n```\n```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        int low = 0, high = x/2 + 1;\\n        while (low < high) {\\n            long mid = low + (high - low + 1) / 2;\\n            if (mid * mid <= x) {\\n                low = mid;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881328,
                "title": "java-multiple-approach-solutions-0ms-2ms",
                "content": "**Approach 1: Using Build - in Math.sqrt() function and type casting it to int, to get the integer value**\\n```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        return (int)Math.sqrt(x);\\n    }\\n}\\n```\\n\\n**Approach 2: Using Binary Search\\nHere the search space for possible solutions is 1 to x-1**\\n\\n```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        if(x<=1)return x;\\n        int l=1; //low or start value = 1\\n        int h=x-1; //high or end value = x-1\\n        \\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n           \\n            if(mid==x/mid){\\n                return mid;\\n            }else if(mid<x/mid){\\n                l = mid+1;\\n            }else{\\n                h=mid-1;\\n            }\\n        }\\n        return h;\\n    }\\n}\\n```\\n**Perform a dry run for better understanding !\\nHappy Coding !\\nDo Upvote if it helped !**",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        return (int)Math.sqrt(x);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        if(x<=1)return x;\\n        int l=1; //low or start value = 1\\n        int h=x-1; //high or end value = x-1\\n        \\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n           \\n            if(mid==x/mid){\\n                return mid;\\n            }else if(mid<x/mid){\\n                l = mid+1;\\n            }else{\\n                h=mid-1;\\n            }\\n        }\\n        return h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1799530,
                "title": "best-solution-with-complete-explanation",
                "content": "**Your runtime beats 95.85 % of python3 submissions.\\nYour memory usage beats 98.50 % of python3 submissions.**\\n\\n```\\ndef my_sqrt(x: int) -> int:\\n    \"\"\"\"\"\"\\n    \\n    # Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\\n    # -1) Not Allowed (Using Built-in Exponent Function or Operator): TC = O(log(x)); SC = O(1)\\n\\n    \"\"\"\\n    return int(x ** .5)\\n    \"\"\"\\n    \"\"\"\\n    return int(pow(x, .5))\\n    \"\"\"\\n    \"\"\"\\n    from math import pow\\n    return int(pow(x, .5))\\n    \"\"\"\\n    \"\"\"\\n    from math import sqrt\\n    return int(sqrt(x))\\n    \"\"\"\\n    \"\"\"\\n    from math import isqrt\\n    return isqrt(x)\\n    \"\"\"\\n\\n    # NOTE: Python doesn\\'t bound integer limit, otherwise we would have to use i == x/i instead of i*i == x for\\n    # comparisons, to avoid exceeding integer upper limit.\\n\\n    # 0) Brute Force (Linear Search): TC = O(\\u221Ax); SC = O(1)\\n    # https://en.wikipedia.org/wiki/Integer_square_root#Algorithm_using_linear_search\\n\\n    # 0.1) Intuitive:\\n    \"\"\"\\n    for sqrt in range(0, x+1):  # \\u2235 for a non-negative integer x, range(sqrt(x)) = [0, x]\\n        if (sq := sqrt*sqrt) == x:\\n            return sqrt\\n        if sq > x:  # for non-perfect square x\\n            return sqrt-1\\n    \"\"\"\\n    # 0.2) Bit Faster (due to fewer comparisons):\\n    \"\"\"\\n    sqrt = 0\\n    while sqrt*sqrt < x:\\n        sqrt += 1\\n    return sqrt if (sqrt*sqrt == x) else sqrt-1\\n    \"\"\"\\n\\n    # 1.1) Optimal (Binary Search): TC = O(log2(x)); SC = O(1)\\n    # https://leetcode.com/problems/sqrtx/discuss/25047/A-Binary-Search-Solution/24042\\n    # https://en.wikipedia.org/wiki/Binary_search_algorithm#Procedure\\n    # https://en.wikipedia.org/wiki/Integer_square_root#Algorithm_using_binary_search\\n\\n    lo, hi = 0, x  # \\u2235 for a non-negative integer x, range(sqrt(x)) = [0, x]\\n    while lo <= hi:\\n        mid = (lo + hi) // 2\\n        mid_sq = mid * mid\\n        if mid_sq == x:  # => mid = sqrt(x)\\n            return mid\\n        elif mid_sq < x:  # => mid < sqrt(x)\\n            lo = mid + 1  # compress range\\n        else:  # (if mid_sq > x) => mid > sqrt(x)\\n            hi = mid - 1  # compress range\\n    # If x is not a perfect square, ans. won\\'t be returned above, and `lo` will become > than `hi`, and the loop will\\n    # terminate.\\n    # In these cases answer will be = `lo-1` = `hi`, because the loop terminated because of two possible cases:\\n    # Either:\\n    # `mid_sq < x` (=> mid < sqrt(x)), `lo = mid + 1` executed, and `lo` became > than `hi` => int(sqrt(x)) = lo-1 = hi\\n    # Or:\\n    # `mid_sq > x` (=> mid > sqrt(x)), `hi = mid - 1` executed, and `hi` became < than `lo` => int(sqrt(x)) = hi = lo-1\\n    return lo - 1  # or hi\\n\\n    # 1.2) Optimal (Heron\\'s method, a special case of Newton\\'s method): TC = O(log(x)); SC = O(1)\\n    # -> Harder and Slower than Binary Search\\n    # https://leetcode.com/problems/sqrtx/discuss/25057/3-4-short-lines-Integer-Newton-Every-Language\\n    # https://en.wikipedia.org/wiki/Integer_square_root#Algorithm_using_Newton%27s_method\\n```\\n\\n**For more of such clear codes and explanations, here\\'s my [GitHub repository](https://github.com/samyak1409/DSA). Please upvote this post and star the repository if these helped!**\\n\\n**Thanks! :)**\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef my_sqrt(x: int) -> int:\\n    \"\"\"\"\"\"\\n    \\n    # Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\\n    # -1) Not Allowed (Using Built-in Exponent Function or Operator): TC = O(log(x)); SC = O(1)\\n\\n    \"\"\"\\n    return int(x ** .5)\\n    \"\"\"\\n    \"\"\"\\n    return int(pow(x, .5))\\n    \"\"\"\\n    \"\"\"\\n    from math import pow\\n    return int(pow(x, .5))\\n    \"\"\"\\n    \"\"\"\\n    from math import sqrt\\n    return int(sqrt(x))\\n    \"\"\"\\n    \"\"\"\\n    from math import isqrt\\n    return isqrt(x)\\n    \"\"\"\\n\\n    # NOTE: Python doesn\\'t bound integer limit, otherwise we would have to use i == x/i instead of i*i == x for\\n    # comparisons, to avoid exceeding integer upper limit.\\n\\n    # 0) Brute Force (Linear Search): TC = O(\\u221Ax); SC = O(1)\\n    # https://en.wikipedia.org/wiki/Integer_square_root#Algorithm_using_linear_search\\n\\n    # 0.1) Intuitive:\\n    \"\"\"\\n    for sqrt in range(0, x+1):  # \\u2235 for a non-negative integer x, range(sqrt(x)) = [0, x]\\n        if (sq := sqrt*sqrt) == x:\\n            return sqrt\\n        if sq > x:  # for non-perfect square x\\n            return sqrt-1\\n    \"\"\"\\n    # 0.2) Bit Faster (due to fewer comparisons):\\n    \"\"\"\\n    sqrt = 0\\n    while sqrt*sqrt < x:\\n        sqrt += 1\\n    return sqrt if (sqrt*sqrt == x) else sqrt-1\\n    \"\"\"\\n\\n    # 1.1) Optimal (Binary Search): TC = O(log2(x)); SC = O(1)\\n    # https://leetcode.com/problems/sqrtx/discuss/25047/A-Binary-Search-Solution/24042\\n    # https://en.wikipedia.org/wiki/Binary_search_algorithm#Procedure\\n    # https://en.wikipedia.org/wiki/Integer_square_root#Algorithm_using_binary_search\\n\\n    lo, hi = 0, x  # \\u2235 for a non-negative integer x, range(sqrt(x)) = [0, x]\\n    while lo <= hi:\\n        mid = (lo + hi) // 2\\n        mid_sq = mid * mid\\n        if mid_sq == x:  # => mid = sqrt(x)\\n            return mid\\n        elif mid_sq < x:  # => mid < sqrt(x)\\n            lo = mid + 1  # compress range\\n        else:  # (if mid_sq > x) => mid > sqrt(x)\\n            hi = mid - 1  # compress range\\n    # If x is not a perfect square, ans. won\\'t be returned above, and `lo` will become > than `hi`, and the loop will\\n    # terminate.\\n    # In these cases answer will be = `lo-1` = `hi`, because the loop terminated because of two possible cases:\\n    # Either:\\n    # `mid_sq < x` (=> mid < sqrt(x)), `lo = mid + 1` executed, and `lo` became > than `hi` => int(sqrt(x)) = lo-1 = hi\\n    # Or:\\n    # `mid_sq > x` (=> mid > sqrt(x)), `hi = mid - 1` executed, and `hi` became < than `lo` => int(sqrt(x)) = hi = lo-1\\n    return lo - 1  # or hi\\n\\n    # 1.2) Optimal (Heron\\'s method, a special case of Newton\\'s method): TC = O(log(x)); SC = O(1)\\n    # -> Harder and Slower than Binary Search\\n    # https://leetcode.com/problems/sqrtx/discuss/25057/3-4-short-lines-Integer-Newton-Every-Language\\n    # https://en.wikipedia.org/wiki/Integer_square_root#Algorithm_using_Newton%27s_method\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1482586,
                "title": "o-1-time-square-root-using-new-technique-bit-manipulation",
                "content": "Start checking the set bits of the probable square root from the left\\n\\n```\\n int mySqrt(int x) {\\n        \\n        int res = 0;\\n        \\n        for(int mask = 1<<15 ; mask>0 ; mask = mask>>1)\\n        {\\n            int probable_ans = res | mask;\\n            \\n            if(probable_ans <= x/probable_ans)\\n            {\\n                res = probable_ans;\\n            }\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "Start checking the set bits of the probable square root from the left\\n\\n```\\n int mySqrt(int x) {\\n        \\n        int res = 0;\\n        \\n        for(int mask = 1<<15 ; mask>0 ; mask = mask>>1)\\n        {\\n            int probable_ans = res | mask;\\n            \\n            if(probable_ans <= x/probable_ans)\\n            {\\n                res = probable_ans;\\n            }\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1438799,
                "title": "c-binarysearch-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int mySqrt(long long x) {\\n        long long low = 0,high = x+1; //Use of long long to avoid integer overflow\\n        while(low<high) {\\n            long long mid = low+(high -low)/2;\\n            if(mid*mid>x) \\n                high = mid ;\\n            else low = mid+1;\\n        }\\n        return low-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mySqrt(long long x) {\\n        long long low = 0,high = x+1; //Use of long long to avoid integer overflow\\n        while(low<high) {\\n            long long mid = low+(high -low)/2;\\n            if(mid*mid>x) \\n                high = mid ;\\n            else low = mid+1;\\n        }\\n        return low-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1422413,
                "title": "100-faster-java-solution-binary-search",
                "content": "```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        \\n        if(x==0 || x==1)\\n            return x;\\n        \\n        int start=1;\\n        int end=x/2;\\n        int ans=0;\\n        \\n        \\n        \\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            \\n            if(mid<=x/mid)          //To escape the INT OVERFLOW\\n                {ans=mid;\\n                start=mid+1;}\\n            else\\n                end=mid-1;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        \\n        if(x==0 || x==1)\\n            return x;\\n        \\n        int start=1;\\n        int end=x/2;\\n        int ans=0;\\n        \\n        \\n        \\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            \\n            if(mid<=x/mid)          //To escape the INT OVERFLOW\\n                {ans=mid;\\n                start=mid+1;}\\n            else\\n                end=mid-1;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1275704,
                "title": "a-simple-binary-search-solution",
                "content": "We know that the range will always be from 1 to x so we can use binary search to implement it in O(log n ) time.\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int x)\\n    {\\n        int low = 0 , high = x , ans = -1 ;\\n        \\n        while (low <= high)\\n        {\\n            long long mid = (low + high)/2;\\n            \\n            long long sq = mid*mid;\\n            \\n            if(sq == x )\\n                return mid;\\n            else if (sq > x)\\n                high = mid -1 ;\\n            else\\n            {\\n                low = mid +1;\\n                ans = mid;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int mySqrt(int x)\\n    {\\n        int low = 0 , high = x , ans = -1 ;\\n        \\n        while (low <= high)\\n        {\\n            long long mid = (low + high)/2;\\n            \\n            long long sq = mid*mid;\\n            \\n            if(sq == x )\\n                return mid;\\n            else if (sq > x)\\n                high = mid -1 ;\\n            else\\n            {\\n                low = mid +1;\\n                ans = mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 402730,
                "title": "sqrt-x-binary-search-solution-with-explanation",
                "content": "Since we are interested in an integer, the decimals of the square root have to be truncated, as stated in the problem statement.\\n\\nThat means the result of sqrt(x) will be the **closest perfect square, a, to the left of x**, including itself (a^2 <= x)\\n*Assuming a^2 <= x*, the closest perfect square to the right of x is (a + 1)^2. \\nThis gives us the tightest integer left and right bounds: **a^2 <= x < (a + 1)^2, which, in turn, gives us a <= sqrt(x) < (a + 1)**\\n\\nSo if we can somehow narrow down to a and a + 1, then we will have obtained our answer.\\n\\nKnowing this, we just need some sorted integer interval which a and a + 1  lie within in order to identify them.\\nFor x > 1, we know that 1 <= truncated sqrt(x) <= truncated (x/2), so we can narrow down our search to this sorted interval.\\n\\nWhat efficient search algorithm do we know for identifying some value in a sorted list? Binary search.\\n\\nInitialize right = (x / 2)\\nIntialize left = 1\\nDefine midpoint (our guess) to be (right + left) / 2.\\nOur goal is to keep, at most, halving our search space until we\\'ve narrowed our search space down to a and a + 1.\\n\\nSo our search will look like: \\nwhile (left <= right)\\n\\tmid = (right + left) / 2\\n\\tif ((long) (mid * mid) > x), then set right = mid - 1. *// Recall a^2 <= x < (a + 1)^2*\\n\\telse, set left = mid + 1.\\nBecause of the loop condition, our final answer \\'a\\' will be assigned to the variable named right.\\n```\\nclass Solution {\\n    \\n    public int mySqrt(int x) {\\n        if (x < 2) return x;\\n        \\n        int right = x / 2;\\n        int left = 1;\\n        while (left <= right) {\\n            int mid = (right + left) / 2;\\n            if ((long)mid*mid > x) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return right;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int mySqrt(int x) {\\n        if (x < 2) return x;\\n        \\n        int right = x / 2;\\n        int left = 1;\\n        while (left <= right) {\\n            int mid = (right + left) / 2;\\n            if ((long)mid*mid > x) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return right;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25103,
                "title": "newton-s-method-uff1ajust-need-4-simple-lines-c",
                "content": "    class Solution {\\n    public:\\n    int mySqrt(int x) {\\n        long long v = x;  \\n\\n        while(v * v > x)\\n            v = (v + (x / v)) >> 1;\\n\\n        return v; \\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int mySqrt(int x) {\\n        long long v = x;  \\n\\n        while(v * v > x)\\n            v = (v + (x / v)) >> 1;\\n\\n        return v; \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 25189,
                "title": "newton-s-method-in-c",
                "content": "    class Solution {\\n    public:\\n        int mySqrt(int x) {\\n            int y = 1;\\n            int n = x;\\n            while (n > y) {\\n                n = y +  (n - y) / 2;\\n                y = x / n;\\n            }\\n            return n;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int mySqrt(int x) {\\n            int y = 1;\\n            int n = x;\\n            while (n > y) {\\n                n = y +  (n - y) / 2;\\n                y = x / n;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 25226,
                "title": "my-c-code-accepted-with-5-ms",
                "content": "    //binary search\\n    int mySqrt(int x) {\\n        if(x == 0)\\n        {\\n            return 0;\\n        }\\n        int left = 1, right = x;\\n        int mid = (left + right)/2;\\n        while(true)\\n        {\\n            if(x/mid > mid)\\n            {\\n                if((x/mid - mid) == 1)\\n                {\\n                    return mid;\\n                }\\n                left = mid;\\n                mid = (left + right)/2;\\n            }else if(x/mid < mid)\\n            {\\n                if((mid - x/mid) == 1)\\n                {\\n                    return x/mid;\\n                }\\n                right = mid;\\n                mid = (left + right)/2;\\n            }else\\n            {\\n                return mid;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "    //binary search\\n    int mySqrt(int x) {\\n        if(x == 0)\\n        {\\n            return 0;\\n        }\\n        int left = 1, right = x;\\n        int mid = (left + right)/2;\\n        while(true)\\n        {\\n            if(x/mid > mid)\\n            {\\n                if((x/mid - mid) == 1)\\n                {\\n                    return mid;\\n                }\\n                left = mid;\\n                mid = (left + right)/2;\\n            }else if(x/mid < mid)\\n            {\\n                if((mid - x/mid) == 1)\\n                {\\n                    return x/mid;\\n                }\\n                right = mid;\\n                mid = (left + right)/2;\\n            }else\\n            {\\n                return mid;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3493096,
                "title": "c-using-binary-search-with-explanation",
                "content": "# Intuition\\nTo find the square root of a non-negative integer x, we can use a binary search approach to narrow down the range of possible square root values.\\n\\n# Approach\\n1. Handle the special case where x is 0 and return 0 since the square root of 0 is 0.\\n2. Initialize the left pointer to 1 and the right pointer to x.\\n3. While the left pointer is less than or equal to the right pointer:\\n     - Calculate the middle pointer using the formula `mid = left + (right - left) / 2`.\\n     - Calculate the square of the middle value and compare it with x:\\n         - If the square is equal to x, return the middle value as the square root.\\n         - If the square is less than x, update the left pointer to `mid + 1` since the square root must be greater than or equal to mid.\\n         - If the square is greater than x, update the right pointer to `mid - 1` since the square root must be less than mid.\\n4. If no exact square root is found, return the value of the right pointer as the floor value of the square root of x.\\n\\n# Complexity\\n- Time complexity: O(log(x))\\n   - The binary search approach reduces the search space by half in each iteration, resulting in logarithmic time complexity.\\n- Space complexity: O(1)\\n   - The algorithm uses a constant amount of extra space to store the pointers and variables, regardless of the input size.\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MySqrt(int x) {\\n        if (x == 0)\\n            return 0;\\n\\n        int left = 1;\\n        int right = x;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int sqrt = x / mid;\\n\\n            if (sqrt == mid)\\n                return mid;\\n            else if (sqrt < mid)\\n                right = mid - 1;\\n            else\\n                left = mid + 1;\\n        }\\n\\n        return right;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MySqrt(int x) {\\n        if (x == 0)\\n            return 0;\\n\\n        int left = 1;\\n        int right = x;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int sqrt = x / mid;\\n\\n            if (sqrt == mid)\\n                return mid;\\n            else if (sqrt < mid)\\n                right = mid - 1;\\n            else\\n                left = mid + 1;\\n        }\\n\\n        return right;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348996,
                "title": "c-solution-with-nice-explanation-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere, we are told to find the rounded off square root of any given number. So the initial intuition would be to find if the given number is a perfect square or not. So, we will accordingly employ binary search search to check that. If x would be a perfect square it would lie somewhere in between 1 to x, so perform binary search accordingly. If it is not then we will use the below approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhile performing our binary search, we will surf throughout 1 to n, if the given number is not at all a perfect square, then we print the current \\'mid\\' as answer only. Because the current mid will be the nearest rounded off square root.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long int mySqrt(long long int x) {\\n        \\n        long long int low = 0, high = x;\\n\\n        int ans;\\n        while(low<=high){\\n            if(x==0) ans = 0;\\n\\n            long long int mid = low + (high-low)/2;\\n            long long int sq = mid*mid;\\n\\n            if(sq==x) return mid;\\n\\n            else if(sq>x) high = mid-1;\\n\\n            else {\\n                low = mid+1;\\n                ans = mid;\\n            }\\n\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int mySqrt(long long int x) {\\n        \\n        long long int low = 0, high = x;\\n\\n        int ans;\\n        while(low<=high){\\n            if(x==0) ans = 0;\\n\\n            long long int mid = low + (high-low)/2;\\n            long long int sq = mid*mid;\\n\\n            if(sq==x) return mid;\\n\\n            else if(sq>x) high = mid-1;\\n\\n            else {\\n                low = mid+1;\\n                ans = mid;\\n            }\\n\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244299,
                "title": "simple-java-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs per the repeated subtraction method, if a number is a perfect square, then we can determine its square root by:\\n\\nRepeatedly subtracting consecutive odd numbers from it\\nSubtract till the difference is zero(for perfect squares) and greater than 0 for non perfect squares\\nNumber of times we subtract is the required square root\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int sqrt=0;\\n        int i=1;\\n        while(x>0){\\n            x-=i;\\n            if(x<0) break;\\n            i+=2;\\n            sqrt++;\\n        }\\n        return sqrt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int sqrt=0;\\n        int i=1;\\n        while(x>0){\\n            x-=i;\\n            if(x<0) break;\\n            i+=2;\\n            sqrt++;\\n        }\\n        return sqrt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115414,
                "title": "basic-method-for-finding-square-root",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MySqrt(int x) \\n    {\\n            if(x == 1)\\n            {\\n                return x;\\n            }\\n            for (double i = 0; i <= x ; i++)\\n            {\\n                \\n                if (i * i > x)\\n                {\\n                    return Convert.ToInt32(i-1);\\n                    break;\\n                }\\n            }\\n            return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MySqrt(int x) \\n    {\\n            if(x == 1)\\n            {\\n                return x;\\n            }\\n            for (double i = 0; i <= x ; i++)\\n            {\\n                \\n                if (i * i > x)\\n                {\\n                    return Convert.ToInt32(i-1);\\n                    break;\\n                }\\n            }\\n            return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073151,
                "title": "very-simple-javascript-2-line-code-without-using-functions-clue-doesn-t-need-to-think-too-much",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} x\\n * @return {number}\\n */\\nvar mySqrt = function(x) {\\n    for(i=0;i<=x+1;i++){\\n        if(i*i>x) return i-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n/**\\n * @param {number} x\\n * @return {number}\\n */\\nvar mySqrt = function(x) {\\n    for(i=0;i<=x+1;i++){\\n        if(i*i>x) return i-1;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2981409,
                "title": "binary-search-finding-first-true-statement-in-false-true-list-python",
                "content": "# Intuition\\nThis problem can also be seen as finding the **first** `True` element in an array of consecutive `False/True` statements.\\n\\n`mySqrt = 8`\\n\\n```\\n[0*0,1*1,2*2,3*3,4*4,5*5,6*6,7*7,8*8]\\n[ 0 , 1 , 2 , 9 , 16, 25, 36, 49, 64]\\n```\\n\\n`n*n` is greater or equal than `8`?\\n\\n```\\n[ F , F , F , T , T , T , T , T , T]\\n```\\n\\nAs such the **1st** `True` element can be found either linearly $$O(n)$$ or through binary search $$O(logn)$$, the second being the fastest.\\n\\nOn every iteration the range is split in 2 discarting either the left or the right side until there is no more space where to look for.\\n\\n```\\nmySqrt = 8 = [0,1,2,3,4,5,6,7,8]\\nleft right mid mid*mid         nums\\n0      8    4    16     [0,1,2,3,4,5,6,7,8]\\n                         ^       ^       ^\\n0      3    1    1      [0,1,2,3,4,5,6,7,8]\\n                         ^ ^   ^\\n1      3    2    4      [0,1,2,3,4,5,6,7,8]\\n                           ^ ^ ^\\n3      3    3    9      [0,1,2,3,4,5,6,7,8]\\n                               ^\\n```\\n\\nLast value where `mid` didn\\'t pass `8` was `2`, therefore `2` is returned.\\n\\n# Complexity\\n- Time complexity: $$O(logn)$$ binary search\\n\\n- Space complexity: $$O(1)$$ left / right / mid variables. \\n\\n# Code\\n```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        left, right, root = 0, x, -1\\n        while left <= right:\\n            mid = (right + left) // 2\\n            if mid * mid == x:\\n                return mid\\n            elif mid * mid < x:\\n                root = mid\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return root \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\n[0*0,1*1,2*2,3*3,4*4,5*5,6*6,7*7,8*8]\\n[ 0 , 1 , 2 , 9 , 16, 25, 36, 49, 64]\\n```\n```\\n[ F , F , F , T , T , T , T , T , T]\\n```\n```\\nmySqrt = 8 = [0,1,2,3,4,5,6,7,8]\\nleft right mid mid*mid         nums\\n0      8    4    16     [0,1,2,3,4,5,6,7,8]\\n                         ^       ^       ^\\n0      3    1    1      [0,1,2,3,4,5,6,7,8]\\n                         ^ ^   ^\\n1      3    2    4      [0,1,2,3,4,5,6,7,8]\\n                           ^ ^ ^\\n3      3    3    9      [0,1,2,3,4,5,6,7,8]\\n                               ^\\n```\n```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        left, right, root = 0, x, -1\\n        while left <= right:\\n            mid = (right + left) // 2\\n            if mid * mid == x:\\n                return mid\\n            elif mid * mid < x:\\n                root = mid\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return root \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401150,
                "title": "python-solution",
                "content": "Runtime: 2470 ms, faster than 12.52% of Python online submissions for Sqrt(x).\\nMemory Usage: 13.5 MB, less than 36.55% of Python online submissions for Sqrt(x).\\n```\\nclass Solution(object):\\n    def mySqrt(self, x):\\n        sr =1\\n        while True:\\n            if x < sr*sr:\\n                return sr-1\\n            else:\\n                sr +=1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def mySqrt(self, x):\\n        sr =1\\n        while True:\\n            if x < sr*sr:\\n                return sr-1\\n            else:\\n                sr +=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803436,
                "title": "c-binary-search-approach",
                "content": "Kindly **upvote** if you find it helpful **: )**\\n```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        long long int ans = -1;\\n        int s = 0;\\n        int e = x;\\n        long long int m = s + (e-s)/2;\\n        while(s<=e){\\n            if(m*m == x){\\n                return m;\\n            }else if(m*m < x){\\n                ans = m;\\n                s = m+1;\\n            }else if(m*m > x){\\n                e = m-1;\\n            }\\n            \\n            m = s + (e-s)/2;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\\nLet me know, if you have different approach...",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        long long int ans = -1;\\n        int s = 0;\\n        int e = x;\\n        long long int m = s + (e-s)/2;\\n        while(s<=e){\\n            if(m*m == x){\\n                return m;\\n            }else if(m*m < x){\\n                ans = m;\\n                s = m+1;\\n            }else if(m*m > x){\\n                e = m-1;\\n            }\\n            \\n            m = s + (e-s)/2;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1779982,
                "title": "a-binary-search-solution-c-code",
                "content": "Here\\'s my code below with **binary search** approach to it.\\nUpvote if you find it useful\\n```\\nint mySqrt(int x) {\\n        long left = 0, right = x, mid = (left + right)/2;\\n        while(left<=right){\\n            long ans = mid * mid;\\n            if(ans == x)\\n                return mid;\\n            if(ans<x){\\n                left = mid + 1;\\n                mid = (left + right)/2; \\n            }\\n            else{\\n                right = mid -1;\\n                mid = (left + right)/2;\\n            }\\n        }\\n        return mid;\\n    }\\n```\\nplease do let me know for any improvements to my code writing style.",
                "solutionTags": [],
                "code": "```\\nint mySqrt(int x) {\\n        long left = 0, right = x, mid = (left + right)/2;\\n        while(left<=right){\\n            long ans = mid * mid;\\n            if(ans == x)\\n                return mid;\\n            if(ans<x){\\n                left = mid + 1;\\n                mid = (left + right)/2; \\n            }\\n            else{\\n                right = mid -1;\\n                mid = (left + right)/2;\\n            }\\n        }\\n        return mid;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 778537,
                "title": "javascript-simple-binary-search-98-faster",
                "content": "```\\nvar mySqrt = function (x) {\\n  let left = 0;\\n  let right = Math.ceil(x / 2);\\n  let mid = 0;\\n\\n  while (left <= right) {\\n    mid = Math.floor((left + right) / 2);\\n\\n    if (mid * mid < x) left = mid + 1;\\n    else if (mid * mid > x) right = mid - 1;\\n    else return mid;\\n  }\\n\\n  return right;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar mySqrt = function (x) {\\n  let left = 0;\\n  let right = Math.ceil(x / 2);\\n  let mid = 0;\\n\\n  while (left <= right) {\\n    mid = Math.floor((left + right) / 2);\\n\\n    if (mid * mid < x) left = mid + 1;\\n    else if (mid * mid > x) right = mid - 1;\\n    else return mid;\\n  }\\n\\n  return right;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 561164,
                "title": "my-python-binary-search-algorithm",
                "content": "Explanation: \\n\\n**Brute Force approach**:\\nAs a brute force approach we can compute check each number in the range of 1 to x to search the largest number k (0 < k <= x) such that `k * k < x` and return it as the desired solution. The time complexity for this approach will be `O(k)`. For a 32-bit integeer this algorithm may take over a billion iterations.\\n\\n**Binarry Search/Divide and conquer Approach**:\\nLooking more carefully the following oservations can be made:\\n1. All the numbers 1 .. x are sorted (which should strike that binary search can be used)\\n2. If a random number k `(0 < k <= x)` (middlie element in this algorithm) is chosen it can fall in any one of the following cases: \\n\\t1.  `k * k > x` in which case we can just ignore all the numbers to the right of k and we can strictly limit the search space to the left of k i.e. between 0 (or left bound) and k -1. \\n\\t2.  Similarly if `k * k <= x` then it could be the desired answer we are after or much less than the desired answer in any case we still need to search to the right of k i.e a much bigger number whose square is less than x could be found in the range of k + 1 and x (or right boundary) so we jsut simply remember k in `res` and keep searching on the right half until we reach a k such that `k * k > x`. At this point the last recorded answer in res is the desired solution. (This is exactly how bisect_left of python is implemented). \\n3.  This algorithm has `O(log x)` complexity in the worst case as we are exponentially reducing the search space by half in every iteration by selecting the random k as the middle element.\\n\\n```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        left, right = 0, x\\n        res = 0\\n        while left <= right:\\n            mid = (right + left) // 2\\n            if mid * mid <= x:\\n                res = mid\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        left, right = 0, x\\n        res = 0\\n        while left <= right:\\n            mid = (right + left) // 2\\n            if mid * mid <= x:\\n                res = mid\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393944,
                "title": "golang-integer-newton",
                "content": "```\\nfunc mySqrt(x int) int {\\n\\tr := x\\n\\tfor r*r > x {\\n\\t\\tr = (r + x/r) / 2\\n\\t}\\n\\treturn r\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc mySqrt(x int) int {\\n\\tr := x\\n\\tfor r*r > x {\\n\\t\\tr = (r + x/r) / 2\\n\\t}\\n\\treturn r\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 313887,
                "title": "swift-web-solutionz-web-solutions-prime-torrentz-code-haxxxx0rz",
                "content": "```\\nclass Solution {\\n    func mySqrt(_ x: Int) -> Int {\\n        var res = x\\n        while res * res > x {\\n            res = (res + x / res) / 2\\n        }\\n        return res\\n    }\\n}\\n```\\n\\nKaboom.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func mySqrt(_ x: Int) -> Int {\\n        var res = x\\n        while res * res > x {\\n            res = (res + x / res) / 2\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 166409,
                "title": "javascript-74-23",
                "content": "Honestly I was expecting better. I guess the cost is object instantiation?\\n\\n** Should be up to 5k but forum limit\\n\\n```\\n/**\\n * @param {number} x\\n * @return {number}\\n */\\n\\nconst preCalc = {\\n  \"0\": 0,\\n  \"1\": 1,\\n  \"2\": 1,\\n  \"3\": 1,\\n  \"4\": 2,\\n  \"5\": 2,\\n  \"6\": 2,\\n  \"7\": 2,\\n  \"8\": 2,\\n  \"9\": 3,\\n  \"10\": 3,\\n  \"11\": 3,\\n  \"12\": 3,\\n  \"13\": 3,\\n  \"14\": 3,\\n  \"15\": 3,\\n  \"16\": 4,\\n  \"17\": 4,\\n  \"18\": 4,\\n  \"19\": 4,\\n  \"20\": 4,\\n  \"21\": 4,\\n  \"22\": 4,\\n  \"23\": 4,\\n  \"24\": 4,\\n  \"25\": 5,\\n  \"26\": 5,\\n  \"27\": 5,\\n  \"28\": 5,\\n  \"29\": 5,\\n  \"30\": 5,\\n  \"31\": 5,\\n  \"32\": 5,\\n  \"33\": 5,\\n  \"34\": 5,\\n  \"35\": 5,\\n  \"36\": 6,\\n  \"37\": 6,\\n  \"38\": 6,\\n  \"39\": 6,\\n  \"40\": 6,\\n  \"41\": 6,\\n  \"42\": 6,\\n  \"43\": 6,\\n  \"44\": 6,\\n  \"45\": 6,\\n  \"46\": 6,\\n  \"47\": 6,\\n  \"48\": 6,\\n  \"49\": 7,\\n  \"50\": 7,\\n  \"51\": 7,\\n  \"52\": 7,\\n  \"53\": 7,\\n  \"54\": 7,\\n  \"55\": 7,\\n  \"56\": 7,\\n  \"57\": 7,\\n  \"58\": 7,\\n  \"59\": 7,\\n  \"60\": 7,\\n  \"61\": 7,\\n  \"62\": 7,\\n  \"63\": 7,\\n  \"64\": 8,\\n  \"65\": 8,\\n  \"66\": 8,\\n  \"67\": 8,\\n  \"68\": 8,\\n  \"69\": 8,\\n  \"70\": 8,\\n  \"71\": 8,\\n  \"72\": 8,\\n  \"73\": 8,\\n  \"74\": 8,\\n  \"75\": 8,\\n  \"76\": 8,\\n  \"77\": 8,\\n  \"78\": 8,\\n  \"79\": 8,\\n  \"80\": 8,\\n  \"81\": 9,\\n  \"82\": 9,\\n  \"83\": 9,\\n  \"84\": 9,\\n  \"85\": 9,\\n  \"86\": 9,\\n  \"87\": 9,\\n  \"88\": 9,\\n  \"89\": 9,\\n  \"90\": 9,\\n  \"91\": 9,\\n  \"92\": 9,\\n  \"93\": 9,\\n  \"94\": 9,\\n  \"95\": 9,\\n  \"96\": 9,\\n  \"97\": 9,\\n  \"98\": 9,\\n  \"99\": 9,\\n  \"100\": 10,\\n  \"101\": 10,\\n  \"102\": 10,\\n  \"103\": 10,\\n  \"104\": 10,\\n  \"105\": 10,\\n  \"106\": 10,\\n  \"107\": 10,\\n  \"108\": 10,\\n  \"109\": 10,\\n  \"110\": 10,\\n  \"111\": 10,\\n  \"112\": 10,\\n  \"113\": 10,\\n  \"114\": 10,\\n  \"115\": 10,\\n  \"116\": 10,\\n  \"117\": 10,\\n  \"118\": 10,\\n  \"119\": 10,\\n  \"120\": 10,\\n  \"121\": 11,\\n  \"122\": 11,\\n  \"123\": 11,\\n  \"124\": 11,\\n  \"125\": 11,\\n  \"126\": 11,\\n  \"127\": 11,\\n  \"128\": 11,\\n  \"129\": 11,\\n  \"130\": 11,\\n  \"131\": 11,\\n  \"132\": 11,\\n  \"133\": 11,\\n  \"134\": 11,\\n  \"135\": 11,\\n  \"136\": 11,\\n  \"137\": 11,\\n  \"138\": 11,\\n  \"139\": 11,\\n  \"140\": 11,\\n  \"141\": 11,\\n  \"142\": 11,\\n  \"143\": 11,\\n  \"144\": 12,\\n  \"145\": 12,\\n  \"146\": 12,\\n  \"147\": 12,\\n  \"148\": 12,\\n  \"149\": 12,\\n  \"150\": 12,\\n  \"151\": 12,\\n  \"152\": 12,\\n  \"153\": 12,\\n  \"154\": 12,\\n  \"155\": 12,\\n  \"156\": 12,\\n  \"157\": 12,\\n  \"158\": 12,\\n  \"159\": 12,\\n  \"160\": 12,\\n  \"161\": 12,\\n  \"162\": 12,\\n  \"163\": 12,\\n  \"164\": 12,\\n  \"165\": 12,\\n  \"166\": 12,\\n  \"167\": 12,\\n  \"168\": 12,\\n  \"169\": 13,\\n  \"170\": 13,\\n  \"171\": 13,\\n  \"172\": 13,\\n  \"173\": 13,\\n  \"174\": 13,\\n  \"175\": 13,\\n  \"176\": 13,\\n  \"177\": 13,\\n  \"178\": 13,\\n  \"179\": 13,\\n  \"180\": 13,\\n  \"181\": 13,\\n  \"182\": 13,\\n  \"183\": 13,\\n  \"184\": 13,\\n  \"185\": 13,\\n  \"186\": 13,\\n  \"187\": 13,\\n  \"188\": 13,\\n  \"189\": 13,\\n  \"190\": 13,\\n  \"191\": 13,\\n  \"192\": 13,\\n  \"193\": 13,\\n  \"194\": 13,\\n  \"195\": 13,\\n  \"196\": 14,\\n  \"197\": 14,\\n  \"198\": 14,\\n  \"199\": 14,\\n  \"200\": 14,\\n  \"201\": 14,\\n  \"202\": 14,\\n  \"203\": 14,\\n  \"204\": 14,\\n  \"205\": 14,\\n  \"206\": 14,\\n  \"207\": 14,\\n  \"208\": 14,\\n  \"209\": 14,\\n  \"210\": 14,\\n  \"211\": 14,\\n  \"212\": 14,\\n  \"213\": 14,\\n  \"214\": 14,\\n  \"215\": 14,\\n  \"216\": 14,\\n  \"217\": 14,\\n  \"218\": 14,\\n  \"219\": 14,\\n  \"220\": 14,\\n  \"221\": 14,\\n  \"222\": 14,\\n  \"223\": 14,\\n  \"224\": 14,\\n  \"225\": 15,\\n  \"226\": 15,\\n  \"227\": 15,\\n  \"228\": 15,\\n  \"229\": 15,\\n  \"230\": 15,\\n  \"231\": 15,\\n  \"232\": 15,\\n  \"233\": 15,\\n  \"234\": 15,\\n  \"235\": 15,\\n  \"236\": 15,\\n  \"237\": 15,\\n  \"238\": 15,\\n  \"239\": 15,\\n  \"240\": 15,\\n  \"241\": 15,\\n  \"242\": 15,\\n  \"243\": 15,\\n  \"244\": 15,\\n  \"245\": 15,\\n  \"246\": 15,\\n  \"247\": 15,\\n  \"248\": 15,\\n  \"249\": 15,\\n  \"250\": 15,\\n  \"251\": 15,\\n  \"252\": 15,\\n  \"253\": 15,\\n  \"254\": 15,\\n  \"255\": 15,\\n  \"256\": 16,\\n  \"257\": 16,\\n  \"258\": 16,\\n  \"259\": 16,\\n  \"260\": 16,\\n  \"261\": 16,\\n  \"262\": 16,\\n  \"263\": 16,\\n  \"264\": 16,\\n  \"265\": 16,\\n  \"266\": 16,\\n  \"267\": 16,\\n  \"268\": 16,\\n  \"269\": 16,\\n  \"270\": 16,\\n  \"271\": 16,\\n  \"272\": 16,\\n  \"273\": 16,\\n  \"274\": 16,\\n  \"275\": 16,\\n  \"276\": 16,\\n  \"277\": 16,\\n  \"278\": 16,\\n  \"279\": 16,\\n  \"280\": 16,\\n  \"281\": 16,\\n  \"282\": 16,\\n  \"283\": 16,\\n  \"284\": 16,\\n  \"285\": 16,\\n  \"286\": 16,\\n  \"287\": 16,\\n  \"288\": 16,\\n  \"289\": 17,\\n  \"290\": 17,\\n  \"291\": 17,\\n  \"292\": 17,\\n  \"293\": 17,\\n  \"294\": 17,\\n  \"295\": 17,\\n  \"296\": 17,\\n  \"297\": 17,\\n  \"298\": 17,\\n  \"299\": 17,\\n  \"300\": 17,\\n  \"301\": 17,\\n  \"302\": 17,\\n  \"303\": 17,\\n  \"304\": 17,\\n  \"305\": 17,\\n  \"306\": 17,\\n  \"307\": 17,\\n  \"308\": 17,\\n  \"309\": 17,\\n  \"310\": 17,\\n  \"311\": 17,\\n  \"312\": 17,\\n  \"313\": 17,\\n  \"314\": 17,\\n  \"315\": 17,\\n  \"316\": 17,\\n  \"317\": 17,\\n  \"318\": 17,\\n  \"319\": 17,\\n  \"320\": 17,\\n  \"321\": 17,\\n  \"322\": 17,\\n  \"323\": 17,\\n  \"324\": 18,\\n  \"325\": 18,\\n  \"326\": 18,\\n  \"327\": 18,\\n  \"328\": 18,\\n  \"329\": 18,\\n  \"330\": 18,\\n  \"331\": 18,\\n  \"332\": 18,\\n  \"333\": 18,\\n  \"334\": 18,\\n  \"335\": 18,\\n  \"336\": 18,\\n  \"337\": 18,\\n  \"338\": 18,\\n  \"339\": 18,\\n  \"340\": 18,\\n  \"341\": 18,\\n  \"342\": 18,\\n  \"343\": 18,\\n  \"344\": 18,\\n  \"345\": 18,\\n  \"346\": 18,\\n  \"347\": 18,\\n  \"348\": 18,\\n  \"349\": 18,\\n  \"350\": 18,\\n  \"351\": 18,\\n  \"352\": 18,\\n  \"353\": 18,\\n  \"354\": 18,\\n  \"355\": 18,\\n  \"356\": 18,\\n  \"357\": 18,\\n  \"358\": 18,\\n  \"359\": 18,\\n  \"360\": 18,\\n  \"361\": 19,\\n  \"362\": 19,\\n  \"363\": 19,\\n  \"364\": 19,\\n  \"365\": 19,\\n  \"366\": 19,\\n  \"367\": 19,\\n  \"368\": 19,\\n  \"369\": 19,\\n  \"370\": 19,\\n  \"371\": 19,\\n  \"372\": 19,\\n  \"373\": 19,\\n  \"374\": 19,\\n  \"375\": 19,\\n  \"376\": 19,\\n  \"377\": 19,\\n  \"378\": 19,\\n  \"379\": 19,\\n  \"380\": 19,\\n  \"381\": 19,\\n  \"382\": 19,\\n  \"383\": 19,\\n  \"384\": 19,\\n  \"385\": 19,\\n  \"386\": 19,\\n  \"387\": 19,\\n  \"388\": 19,\\n  \"389\": 19,\\n  \"390\": 19,\\n  \"391\": 19,\\n  \"392\": 19,\\n  \"393\": 19,\\n  \"394\": 19,\\n  \"395\": 19,\\n  \"396\": 19,\\n  \"397\": 19,\\n  \"398\": 19,\\n  \"399\": 19,\\n  \"400\": 20,\\n  \"401\": 20,\\n  \"402\": 20,\\n  \"403\": 20,\\n  \"404\": 20,\\n  \"405\": 20,\\n  \"406\": 20,\\n  \"407\": 20,\\n  \"408\": 20,\\n  \"409\": 20,\\n  \"410\": 20,\\n  \"411\": 20,\\n  \"412\": 20,\\n  \"413\": 20,\\n  \"414\": 20,\\n  \"415\": 20,\\n  \"416\": 20,\\n  \"417\": 20,\\n  \"418\": 20,\\n  \"419\": 20,\\n  \"420\": 20,\\n  \"421\": 20,\\n  \"422\": 20,\\n  \"423\": 20,\\n  \"424\": 20,\\n  \"425\": 20,\\n  \"426\": 20,\\n  \"427\": 20,\\n  \"428\": 20,\\n  \"429\": 20,\\n  \"430\": 20,\\n  \"431\": 20,\\n  \"432\": 20,\\n  \"433\": 20,\\n  \"434\": 20,\\n  \"435\": 20,\\n  \"436\": 20,\\n  \"437\": 20,\\n  \"438\": 20,\\n  \"439\": 20,\\n  \"440\": 20,\\n  \"441\": 21,\\n  \"442\": 21,\\n  \"443\": 21,\\n  \"444\": 21,\\n  \"445\": 21,\\n  \"446\": 21,\\n  \"447\": 21,\\n  \"448\": 21,\\n  \"449\": 21,\\n  \"450\": 21,\\n  \"451\": 21,\\n  \"452\": 21,\\n  \"453\": 21,\\n  \"454\": 21,\\n  \"455\": 21,\\n  \"456\": 21,\\n  \"457\": 21,\\n  \"458\": 21,\\n  \"459\": 21,\\n  \"460\": 21,\\n  \"461\": 21,\\n  \"462\": 21,\\n  \"463\": 21,\\n  \"464\": 21,\\n  \"465\": 21,\\n  \"466\": 21,\\n  \"467\": 21,\\n  \"468\": 21,\\n  \"469\": 21,\\n  \"470\": 21,\\n  \"471\": 21,\\n  \"472\": 21,\\n  \"473\": 21,\\n  \"474\": 21,\\n  \"475\": 21,\\n  \"476\": 21,\\n  \"477\": 21,\\n  \"478\": 21,\\n  \"479\": 21,\\n  \"480\": 21,\\n  \"481\": 21,\\n  \"482\": 21,\\n  \"483\": 21,\\n  \"484\": 22,\\n  \"485\": 22,\\n  \"486\": 22,\\n  \"487\": 22,\\n  \"488\": 22,\\n  \"489\": 22,\\n  \"490\": 22,\\n  \"491\": 22,\\n  \"492\": 22,\\n  \"493\": 22,\\n  \"494\": 22,\\n  \"495\": 22,\\n  \"496\": 22,\\n  \"497\": 22,\\n  \"498\": 22,\\n  \"499\": 22,\\n  \"500\": 22,\\n  \"501\": 22,\\n  \"502\": 22,\\n  \"503\": 22,\\n  \"504\": 22,\\n  \"505\": 22,\\n  \"506\": 22,\\n  \"507\": 22,\\n  \"508\": 22,\\n  \"509\": 22,\\n  \"510\": 22,\\n  \"511\": 22,\\n  \"512\": 22,\\n  \"513\": 22,\\n  \"514\": 22,\\n  \"515\": 22,\\n  \"516\": 22,\\n  \"517\": 22,\\n  \"518\": 22,\\n  \"519\": 22,\\n  \"520\": 22,\\n  \"521\": 22,\\n  \"522\": 22,\\n  \"523\": 22,\\n  \"524\": 22,\\n  \"525\": 22,\\n  \"526\": 22,\\n  \"527\": 22,\\n  \"528\": 22,\\n  \"529\": 23,\\n  \"530\": 23,\\n  \"531\": 23,\\n  \"532\": 23,\\n  \"533\": 23,\\n  \"534\": 23,\\n  \"535\": 23,\\n  \"536\": 23,\\n  \"537\": 23,\\n  \"538\": 23,\\n  \"539\": 23,\\n  \"540\": 23,\\n  \"541\": 23,\\n  \"542\": 23,\\n  \"543\": 23,\\n  \"544\": 23,\\n  \"545\": 23,\\n  \"546\": 23,\\n  \"547\": 23,\\n  \"548\": 23,\\n  \"549\": 23,\\n  \"550\": 23,\\n  \"551\": 23,\\n  \"552\": 23,\\n  \"553\": 23,\\n  \"554\": 23,\\n  \"555\": 23,\\n  \"556\": 23,\\n  \"557\": 23,\\n  \"558\": 23,\\n  \"559\": 23,\\n  \"560\": 23,\\n  \"561\": 23,\\n  \"562\": 23,\\n  \"563\": 23,\\n  \"564\": 23,\\n  \"565\": 23,\\n  \"566\": 23,\\n  \"567\": 23,\\n  \"568\": 23,\\n  \"569\": 23,\\n  \"570\": 23,\\n  \"571\": 23,\\n  \"572\": 23,\\n  \"573\": 23,\\n  \"574\": 23,\\n  \"575\": 23,\\n  \"576\": 24,\\n  \"577\": 24,\\n  \"578\": 24,\\n  \"579\": 24,\\n  \"580\": 24,\\n  \"581\": 24,\\n  \"582\": 24,\\n  \"583\": 24,\\n  \"584\": 24,\\n  \"585\": 24,\\n  \"586\": 24,\\n  \"587\": 24,\\n  \"588\": 24,\\n  \"589\": 24,\\n  \"590\": 24,\\n  \"591\": 24,\\n  \"592\": 24,\\n  \"593\": 24,\\n  \"594\": 24,\\n  \"595\": 24,\\n  \"596\": 24,\\n  \"597\": 24,\\n  \"598\": 24,\\n  \"599\": 24,\\n  \"600\": 24,\\n  \"601\": 24,\\n  \"602\": 24,\\n  \"603\": 24,\\n  \"604\": 24,\\n  \"605\": 24,\\n  \"606\": 24,\\n  \"607\": 24,\\n  \"608\": 24,\\n  \"609\": 24,\\n  \"610\": 24,\\n  \"611\": 24,\\n  \"612\": 24,\\n  \"613\": 24,\\n  \"614\": 24,\\n  \"615\": 24,\\n  \"616\": 24,\\n  \"617\": 24,\\n  \"618\": 24,\\n  \"619\": 24,\\n  \"620\": 24,\\n  \"621\": 24,\\n  \"622\": 24,\\n  \"623\": 24,\\n  \"624\": 24,\\n  \"625\": 25,\\n  \"626\": 25,\\n  \"627\": 25,\\n  \"628\": 25,\\n  \"629\": 25,\\n  \"630\": 25,\\n  \"631\": 25,\\n  \"632\": 25,\\n  \"633\": 25,\\n  \"634\": 25,\\n  \"635\": 25,\\n  \"636\": 25,\\n  \"637\": 25,\\n  \"638\": 25,\\n  \"639\": 25,\\n  \"640\": 25,\\n  \"641\": 25,\\n  \"642\": 25,\\n  \"643\": 25,\\n  \"644\": 25,\\n  \"645\": 25,\\n  \"646\": 25,\\n  \"647\": 25,\\n  \"648\": 25,\\n  \"649\": 25,\\n  \"650\": 25,\\n  \"651\": 25,\\n  \"652\": 25,\\n  \"653\": 25,\\n  \"654\": 25,\\n  \"655\": 25,\\n  \"656\": 25,\\n  \"657\": 25,\\n  \"658\": 25,\\n  \"659\": 25,\\n  \"660\": 25,\\n  \"661\": 25,\\n  \"662\": 25,\\n  \"663\": 25,\\n  \"664\": 25,\\n  \"665\": 25,\\n  \"666\": 25,\\n  \"667\": 25,\\n  \"668\": 25,\\n  \"669\": 25,\\n  \"670\": 25,\\n  \"671\": 25,\\n  \"672\": 25,\\n  \"673\": 25,\\n  \"674\": 25,\\n  \"675\": 25,\\n  \"676\": 26,\\n  \"677\": 26,\\n  \"678\": 26,\\n  \"679\": 26,\\n  \"680\": 26,\\n  \"681\": 26,\\n  \"682\": 26,\\n  \"683\": 26,\\n  \"684\": 26,\\n  \"685\": 26,\\n  \"686\": 26,\\n  \"687\": 26,\\n  \"688\": 26,\\n  \"689\": 26,\\n  \"690\": 26,\\n  \"691\": 26,\\n  \"692\": 26,\\n  \"693\": 26,\\n  \"694\": 26,\\n  \"695\": 26,\\n  \"696\": 26,\\n  \"697\": 26,\\n  \"698\": 26,\\n  \"699\": 26,\\n  \"700\": 26,\\n  \"701\": 26,\\n  \"702\": 26,\\n  \"703\": 26,\\n  \"704\": 26,\\n  \"705\": 26,\\n  \"706\": 26,\\n  \"707\": 26,\\n  \"708\": 26,\\n  \"709\": 26,\\n  \"710\": 26,\\n  \"711\": 26,\\n  \"712\": 26,\\n  \"713\": 26,\\n  \"714\": 26,\\n  \"715\": 26,\\n  \"716\": 26,\\n  \"717\": 26,\\n  \"718\": 26,\\n  \"719\": 26,\\n  \"720\": 26,\\n  \"721\": 26,\\n  \"722\": 26,\\n  \"723\": 26,\\n  \"724\": 26,\\n  \"725\": 26,\\n  \"726\": 26,\\n  \"727\": 26,\\n  \"728\": 26,\\n  \"729\": 27,\\n  \"730\": 27,\\n  \"731\": 27,\\n  \"732\": 27,\\n  \"733\": 27,\\n  \"734\": 27,\\n  \"735\": 27,\\n  \"736\": 27,\\n  \"737\": 27,\\n  \"738\": 27,\\n  \"739\": 27,\\n  \"740\": 27,\\n  \"741\": 27,\\n  \"742\": 27,\\n  \"743\": 27,\\n  \"744\": 27,\\n  \"745\": 27,\\n  \"746\": 27,\\n  \"747\": 27,\\n  \"748\": 27,\\n  \"749\": 27,\\n  \"750\": 27,\\n  \"751\": 27,\\n  \"752\": 27,\\n  \"753\": 27,\\n  \"754\": 27,\\n  \"755\": 27,\\n  \"756\": 27,\\n  \"757\": 27,\\n  \"758\": 27,\\n  \"759\": 27,\\n  \"760\": 27,\\n  \"761\": 27,\\n  \"762\": 27,\\n  \"763\": 27,\\n  \"764\": 27,\\n  \"765\": 27,\\n  \"766\": 27,\\n  \"767\": 27,\\n  \"768\": 27,\\n  \"769\": 27,\\n  \"770\": 27,\\n  \"771\": 27,\\n  \"772\": 27,\\n  \"773\": 27,\\n  \"774\": 27,\\n  \"775\": 27,\\n  \"776\": 27,\\n  \"777\": 27,\\n  \"778\": 27,\\n  \"779\": 27,\\n  \"780\": 27,\\n  \"781\": 27,\\n  \"782\": 27,\\n  \"783\": 27,\\n  \"784\": 28,\\n  \"785\": 28,\\n  \"786\": 28,\\n  \"787\": 28,\\n  \"788\": 28,\\n  \"789\": 28,\\n  \"790\": 28,\\n  \"791\": 28,\\n  \"792\": 28,\\n  \"793\": 28,\\n  \"794\": 28,\\n  \"795\": 28,\\n  \"796\": 28,\\n  \"797\": 28,\\n  \"798\": 28,\\n  \"799\": 28,\\n  \"800\": 28,\\n  \"801\": 28,\\n  \"802\": 28,\\n  \"803\": 28,\\n  \"804\": 28,\\n  \"805\": 28,\\n  \"806\": 28,\\n  \"807\": 28,\\n  \"808\": 28,\\n  \"809\": 28,\\n  \"810\": 28,\\n  \"811\": 28,\\n  \"812\": 28,\\n  \"813\": 28,\\n  \"814\": 28,\\n  \"815\": 28,\\n  \"816\": 28,\\n  \"817\": 28,\\n  \"818\": 28,\\n  \"819\": 28,\\n  \"820\": 28,\\n  \"821\": 28,\\n  \"822\": 28,\\n  \"823\": 28,\\n  \"824\": 28,\\n  \"825\": 28,\\n  \"826\": 28,\\n  \"827\": 28,\\n  \"828\": 28,\\n  \"829\": 28,\\n  \"830\": 28,\\n  \"831\": 28,\\n  \"832\": 28,\\n  \"833\": 28,\\n  \"834\": 28,\\n  \"835\": 28,\\n  \"836\": 28,\\n  \"837\": 28,\\n  \"838\": 28,\\n  \"839\": 28,\\n  \"840\": 28,\\n  \"841\": 29,\\n  \"842\": 29,\\n  \"843\": 29,\\n  \"844\": 29,\\n  \"845\": 29,\\n  \"846\": 29,\\n  \"847\": 29,\\n  \"848\": 29,\\n  \"849\": 29,\\n  \"850\": 29,\\n  \"851\": 29,\\n  \"852\": 29,\\n  \"853\": 29,\\n  \"854\": 29,\\n  \"855\": 29,\\n  \"856\": 29,\\n  \"857\": 29,\\n  \"858\": 29,\\n  \"859\": 29,\\n  \"860\": 29,\\n  \"861\": 29,\\n  \"862\": 29,\\n  \"863\": 29,\\n  \"864\": 29,\\n  \"865\": 29,\\n  \"866\": 29,\\n  \"867\": 29,\\n  \"868\": 29,\\n  \"869\": 29,\\n  \"870\": 29,\\n  \"871\": 29,\\n  \"872\": 29,\\n  \"873\": 29,\\n  \"874\": 29,\\n  \"875\": 29,\\n  \"876\": 29,\\n  \"877\": 29,\\n  \"878\": 29,\\n  \"879\": 29,\\n  \"880\": 29,\\n  \"881\": 29,\\n  \"882\": 29,\\n  \"883\": 29,\\n  \"884\": 29,\\n  \"885\": 29,\\n  \"886\": 29,\\n  \"887\": 29,\\n  \"888\": 29,\\n  \"889\": 29,\\n  \"890\": 29,\\n  \"891\": 29,\\n  \"892\": 29,\\n  \"893\": 29,\\n  \"894\": 29,\\n  \"895\": 29,\\n  \"896\": 29,\\n  \"897\": 29,\\n  \"898\": 29,\\n  \"899\": 29,\\n  \"900\": 30,\\n  \"901\": 30,\\n  \"902\": 30,\\n  \"903\": 30,\\n  \"904\": 30,\\n  \"905\": 30,\\n  \"906\": 30,\\n  \"907\": 30,\\n  \"908\": 30,\\n  \"909\": 30,\\n  \"910\": 30,\\n  \"911\": 30,\\n  \"912\": 30,\\n  \"913\": 30,\\n  \"914\": 30,\\n  \"915\": 30,\\n  \"916\": 30,\\n  \"917\": 30,\\n  \"918\": 30,\\n  \"919\": 30,\\n  \"920\": 30,\\n  \"921\": 30,\\n  \"922\": 30,\\n  \"923\": 30,\\n  \"924\": 30,\\n  \"925\": 30,\\n  \"926\": 30,\\n  \"927\": 30,\\n  \"928\": 30,\\n  \"929\": 30,\\n  \"930\": 30,\\n  \"931\": 30,\\n  \"932\": 30,\\n  \"933\": 30,\\n  \"934\": 30,\\n  \"935\": 30,\\n  \"936\": 30,\\n  \"937\": 30,\\n  \"938\": 30,\\n  \"939\": 30,\\n  \"940\": 30,\\n  \"941\": 30,\\n  \"942\": 30,\\n  \"943\": 30,\\n  \"944\": 30,\\n  \"945\": 30,\\n  \"946\": 30,\\n  \"947\": 30,\\n  \"948\": 30,\\n  \"949\": 30,\\n  \"950\": 30,\\n  \"951\": 30,\\n  \"952\": 30,\\n  \"953\": 30,\\n  \"954\": 30,\\n  \"955\": 30,\\n  \"956\": 30,\\n  \"957\": 30,\\n  \"958\": 30,\\n  \"959\": 30,\\n  \"960\": 30,\\n  \"961\": 31,\\n  \"962\": 31,\\n  \"963\": 31,\\n  \"964\": 31,\\n  \"965\": 31,\\n  \"966\": 31,\\n  \"967\": 31,\\n  \"968\": 31,\\n  \"969\": 31,\\n  \"970\": 31,\\n  \"971\": 31,\\n  \"972\": 31,\\n  \"973\": 31,\\n  \"974\": 31,\\n  \"975\": 31,\\n  \"976\": 31,\\n  \"977\": 31,\\n  \"978\": 31,\\n  \"979\": 31,\\n  \"980\": 31,\\n  \"981\": 31,\\n  \"982\": 31,\\n  \"983\": 31,\\n  \"984\": 31,\\n  \"985\": 31,\\n  \"986\": 31,\\n  \"987\": 31,\\n  \"988\": 31,\\n  \"989\": 31,\\n  \"990\": 31,\\n  \"991\": 31,\\n  \"992\": 31,\\n  \"993\": 31,\\n  \"994\": 31,\\n  \"995\": 31,\\n  \"996\": 31,\\n  \"997\": 31,\\n  \"998\": 31,\\n  \"999\": 31,\\n  \"1000\": 31,\\n  \"1001\": 31,\\n  \"1002\": 31,\\n  \"1003\": 31,\\n  \"1004\": 31,\\n  \"1005\": 31,\\n  \"1006\": 31,\\n  \"1007\": 31,\\n  \"1008\": 31,\\n  \"1009\": 31,\\n  \"1010\": 31,\\n  \"1011\": 31,\\n  \"1012\": 31,\\n  \"1013\": 31,\\n  \"1014\": 31,\\n  \"1015\": 31,\\n  \"1016\": 31,\\n  \"1017\": 31,\\n  \"1018\": 31,\\n  \"1019\": 31,\\n  \"1020\": 31,\\n  \"1021\": 31,\\n  \"1022\": 31,\\n  \"1023\": 31,\\n  \"1024\": 32,\\n  \"1025\": 32,\\n  \"1026\": 32,\\n  \"1027\": 32,\\n  \"1028\": 32,\\n  \"1029\": 32,\\n  \"1030\": 32,\\n  \"1031\": 32,\\n  \"1032\": 32,\\n  \"1033\": 32,\\n  \"1034\": 32,\\n  \"1035\": 32,\\n  \"1036\": 32,\\n  \"1037\": 32,\\n  \"1038\": 32,\\n  \"1039\": 32,\\n  \"1040\": 32,\\n  \"1041\": 32,\\n  \"1042\": 32,\\n  \"1043\": 32,\\n  \"1044\": 32,\\n  \"1045\": 32,\\n  \"1046\": 32,\\n  \"1047\": 32,\\n  \"1048\": 32,\\n  \"1049\": 32,\\n  \"1050\": 32,\\n  \"1051\": 32,\\n  \"1052\": 32,\\n  \"1053\": 32,\\n  \"1054\": 32,\\n  \"1055\": 32,\\n  \"1056\": 32,\\n  \"1057\": 32,\\n  \"1058\": 32,\\n  \"1059\": 32,\\n  \"1060\": 32,\\n  \"1061\": 32,\\n  \"1062\": 32,\\n  \"1063\": 32,\\n  \"1064\": 32,\\n  \"1065\": 32,\\n  \"1066\": 32,\\n  \"1067\": 32,\\n  \"1068\": 32,\\n  \"1069\": 32,\\n  \"1070\": 32,\\n  \"1071\": 32,\\n  \"1072\": 32,\\n  \"1073\": 32,\\n  \"1074\": 32,\\n  \"1075\": 32,\\n  \"1076\": 32,\\n  \"1077\": 32,\\n  \"1078\": 32,\\n  \"1079\": 32,\\n  \"1080\": 32,\\n  \"1081\": 32,\\n  \"1082\": 32,\\n  \"1083\": 32,\\n  \"1084\": 32,\\n  \"1085\": 32,\\n  \"1086\": 32,\\n  \"1087\": 32,\\n  \"1088\": 32,\\n  \"1089\": 33,\\n  \"1090\": 33,\\n  \"1091\": 33,\\n  \"1092\": 33,\\n  \"1093\": 33,\\n  \"1094\": 33,\\n  \"1095\": 33,\\n  \"1096\": 33,\\n  \"1097\": 33,\\n  \"1098\": 33,\\n  \"1099\": 33,\\n  \"1100\": 33,\\n  \"1101\": 33,\\n  \"1102\": 33,\\n  \"1103\": 33,\\n  \"1104\": 33,\\n  \"1105\": 33,\\n  \"1106\": 33,\\n  \"1107\": 33,\\n  \"1108\": 33,\\n  \"1109\": 33,\\n  \"1110\": 33,\\n  \"1111\": 33,\\n  \"1112\": 33,\\n  \"1113\": 33,\\n  \"1114\": 33,\\n  \"1115\": 33,\\n  \"1116\": 33,\\n  \"1117\": 33,\\n  \"1118\": 33,\\n  \"1119\": 33,\\n  \"1120\": 33,\\n  \"1121\": 33,\\n  \"1122\": 33,\\n  \"1123\": 33,\\n  \"1124\": 33,\\n  \"1125\": 33,\\n  \"1126\": 33,\\n  \"1127\": 33,\\n  \"1128\": 33,\\n  \"1129\": 33,\\n  \"1130\": 33,\\n  \"1131\": 33,\\n  \"1132\": 33,\\n  \"1133\": 33,\\n  \"1134\": 33,\\n  \"1135\": 33,\\n  \"1136\": 33,\\n  \"1137\": 33,\\n  \"1138\": 33,\\n  \"1139\": 33,\\n  \"1140\": 33,\\n  \"1141\": 33,\\n  \"1142\": 33,\\n  \"1143\": 33,\\n  \"1144\": 33,\\n  \"1145\": 33,\\n  \"1146\": 33,\\n  \"1147\": 33,\\n  \"1148\": 33,\\n  \"1149\": 33,\\n  \"1150\": 33,\\n  \"1151\": 33,\\n  \"1152\": 33,\\n  \"1153\": 33,\\n  \"1154\": 33,\\n  \"1155\": 33,\\n  \"1156\": 34,\\n  \"1157\": 34,\\n  \"1158\": 34,\\n  \"1159\": 34,\\n  \"1160\": 34,\\n  \"1161\": 34,\\n  \"1162\": 34,\\n  \"1163\": 34,\\n  \"1164\": 34,\\n  \"1165\": 34,\\n  \"1166\": 34,\\n  \"1167\": 34,\\n  \"1168\": 34,\\n  \"1169\": 34,\\n  \"1170\": 34,\\n  \"1171\": 34,\\n  \"1172\": 34,\\n  \"1173\": 34,\\n  \"1174\": 34,\\n  \"1175\": 34,\\n  \"1176\": 34,\\n  \"1177\": 34,\\n  \"1178\": 34,\\n  \"1179\": 34,\\n  \"1180\": 34,\\n  \"1181\": 34,\\n  \"1182\": 34,\\n  \"1183\": 34,\\n  \"1184\": 34,\\n  \"1185\": 34,\\n  \"1186\": 34,\\n  \"1187\": 34,\\n  \"1188\": 34,\\n  \"1189\": 34,\\n  \"1190\": 34,\\n  \"1191\": 34,\\n  \"1192\": 34,\\n  \"1193\": 34,\\n  \"1194\": 34,\\n  \"1195\": 34,\\n  \"1196\": 34,\\n  \"1197\": 34,\\n  \"1198\": 34,\\n  \"1199\": 34,\\n  \"1200\": 34,\\n  \"1201\": 34,\\n  \"1202\": 34,\\n  \"1203\": 34,\\n  \"1204\": 34,\\n  \"1205\": 34,\\n  \"1206\": 34,\\n  \"1207\": 34,\\n  \"1208\": 34,\\n  \"1209\": 34,\\n  \"1210\": 34,\\n  \"1211\": 34,\\n  \"1212\": 34,\\n  \"1213\": 34,\\n  \"1214\": 34,\\n  \"1215\": 34,\\n  \"1216\": 34,\\n  \"1217\": 34,\\n  \"1218\": 34,\\n  \"1219\": 34,\\n  \"1220\": 34,\\n  \"1221\": 34,\\n  \"1222\": 34,\\n  \"1223\": 34,\\n  \"1224\": 34,\\n  \"1225\": 35,\\n  \"1226\": 35,\\n  \"1227\": 35,\\n  \"1228\": 35,\\n  \"1229\": 35,\\n  \"1230\": 35,\\n  \"1231\": 35,\\n  \"1232\": 35,\\n  \"1233\": 35,\\n  \"1234\": 35,\\n  \"1235\": 35,\\n  \"1236\": 35,\\n  \"1237\": 35,\\n  \"1238\": 35,\\n  \"1239\": 35,\\n  \"1240\": 35,\\n  \"1241\": 35,\\n  \"1242\": 35,\\n  \"1243\": 35,\\n  \"1244\": 35,\\n  \"1245\": 35,\\n  \"1246\": 35,\\n  \"1247\": 35,\\n  \"1248\": 35,\\n  \"1249\": 35,\\n  \"1250\": 35,\\n  \"1251\": 35,\\n  \"1252\": 35,\\n  \"1253\": 35,\\n  \"1254\": 35,\\n  \"1255\": 35,\\n  \"1256\": 35,\\n  \"1257\": 35,\\n  \"1258\": 35,\\n  \"1259\": 35,\\n  \"1260\": 35,\\n  \"1261\": 35,\\n  \"1262\": 35,\\n  \"1263\": 35,\\n  \"1264\": 35,\\n  \"1265\": 35,\\n  \"1266\": 35,\\n  \"1267\": 35,\\n  \"1268\": 35,\\n  \"1269\": 35,\\n  \"1270\": 35,\\n  \"1271\": 35,\\n  \"1272\": 35,\\n  \"1273\": 35,\\n  \"1274\": 35,\\n  \"1275\": 35,\\n  \"1276\": 35,\\n  \"1277\": 35,\\n  \"1278\": 35,\\n  \"1279\": 35,\\n  \"1280\": 35,\\n  \"1281\": 35,\\n  \"1282\": 35,\\n  \"1283\": 35,\\n  \"1284\": 35,\\n  \"1285\": 35,\\n  \"1286\": 35,\\n  \"1287\": 35,\\n  \"1288\": 35,\\n  \"1289\": 35,\\n  \"1290\": 35,\\n  \"1291\": 35,\\n  \"1292\": 35,\\n  \"1293\": 35,\\n  \"1294\": 35,\\n  \"1295\": 35,\\n  \"1296\": 36,\\n  \"1297\": 36,\\n  \"1298\": 36,\\n  \"1299\": 36,\\n  \"1300\": 36,\\n  \"1301\": 36,\\n  \"1302\": 36,\\n  \"1303\": 36,\\n  \"1304\": 36,\\n  \"1305\": 36,\\n  \"1306\": 36,\\n  \"1307\": 36,\\n  \"1308\": 36,\\n  \"1309\": 36,\\n  \"1310\": 36,\\n  \"1311\": 36,\\n  \"1312\": 36,\\n  \"1313\": 36,\\n  \"1314\": 36,\\n  \"1315\": 36,\\n  \"1316\": 36,\\n  \"1317\": 36,\\n  \"1318\": 36,\\n  \"1319\": 36,\\n  \"1320\": 36,\\n  \"1321\": 36,\\n  \"1322\": 36,\\n  \"1323\": 36,\\n  \"1324\": 36,\\n  \"1325\": 36,\\n  \"1326\": 36,\\n  \"1327\": 36,\\n  \"1328\": 36,\\n  \"1329\": 36,\\n  \"1330\": 36,\\n  \"1331\": 36,\\n  \"1332\": 36,\\n  \"1333\": 36,\\n  \"1334\": 36,\\n  \"1335\": 36,\\n  \"1336\": 36,\\n  \"1337\": 36,\\n  \"1338\": 36,\\n  \"1339\": 36,\\n  \"1340\": 36,\\n  \"1341\": 36,\\n  \"1342\": 36,\\n  \"1343\": 36,\\n  \"1344\": 36,\\n  \"1345\": 36,\\n  \"1346\": 36,\\n  \"1347\": 36,\\n  \"1348\": 36,\\n  \"1349\": 36,\\n  \"1350\": 36,\\n  \"1351\": 36,\\n  \"1352\": 36,\\n  \"1353\": 36,\\n  \"1354\": 36,\\n  \"1355\": 36,\\n  \"1356\": 36,\\n  \"1357\": 36,\\n  \"1358\": 36,\\n  \"1359\": 36,\\n  \"1360\": 36,\\n  \"1361\": 36,\\n  \"1362\": 36,\\n  \"1363\": 36,\\n  \"1364\": 36,\\n  \"1365\": 36,\\n  \"1366\": 36,\\n  \"1367\": 36,\\n  \"1368\": 36,\\n  \"1369\": 37,\\n  \"1370\": 37,\\n  \"1371\": 37,\\n  \"1372\": 37,\\n  \"1373\": 37,\\n  \"1374\": 37,\\n  \"1375\": 37,\\n  \"1376\": 37,\\n  \"1377\": 37,\\n  \"1378\": 37,\\n  \"1379\": 37,\\n  \"1380\": 37,\\n  \"1381\": 37,\\n  \"1382\": 37,\\n  \"1383\": 37,\\n  \"1384\": 37,\\n  \"1385\": 37,\\n  \"1386\": 37,\\n  \"1387\": 37,\\n  \"1388\": 37,\\n  \"1389\": 37,\\n  \"1390\": 37,\\n  \"1391\": 37,\\n  \"1392\": 37,\\n  \"1393\": 37,\\n  \"1394\": 37,\\n  \"1395\": 37,\\n  \"1396\": 37,\\n  \"1397\": 37,\\n  \"1398\": 37,\\n  \"1399\": 37,\\n  \"1400\": 37,\\n  \"1401\": 37,\\n  \"1402\": 37,\\n  \"1403\": 37,\\n  \"1404\": 37,\\n  \"1405\": 37,\\n  \"1406\": 37,\\n  \"1407\": 37,\\n  \"1408\": 37,\\n  \"1409\": 37,\\n  \"1410\": 37,\\n  \"1411\": 37,\\n  \"1412\": 37,\\n  \"1413\": 37,\\n  \"1414\": 37,\\n  \"1415\": 37,\\n  \"1416\": 37,\\n  \"1417\": 37,\\n  \"1418\": 37,\\n  \"1419\": 37,\\n  \"1420\": 37,\\n  \"1421\": 37,\\n  \"1422\": 37,\\n  \"1423\": 37,\\n  \"1424\": 37,\\n  \"1425\": 37,\\n  \"1426\": 37,\\n  \"1427\": 37,\\n  \"1428\": 37,\\n  \"1429\": 37,\\n  \"1430\": 37,\\n  \"1431\": 37,\\n  \"1432\": 37,\\n  \"1433\": 37,\\n  \"1434\": 37,\\n  \"1435\": 37,\\n  \"1436\": 37,\\n  \"1437\": 37,\\n  \"1438\": 37,\\n  \"1439\": 37,\\n  \"1440\": 37,\\n  \"1441\": 37,\\n  \"1442\": 37,\\n  \"1443\": 37,\\n  \"1444\": 38,\\n  \"1445\": 38,\\n  \"1446\": 38,\\n  \"1447\": 38,\\n  \"1448\": 38,\\n  \"1449\": 38,\\n  \"1450\": 38,\\n  \"1451\": 38,\\n  \"1452\": 38,\\n  \"1453\": 38,\\n  \"1454\": 38,\\n  \"1455\": 38,\\n  \"1456\": 38,\\n  \"1457\": 38,\\n  \"1458\": 38,\\n  \"1459\": 38,\\n  \"1460\": 38,\\n  \"1461\": 38,\\n  \"1462\": 38,\\n  \"1463\": 38,\\n  \"1464\": 38,\\n  \"1465\": 38,\\n  \"1466\": 38,\\n  \"1467\": 38,\\n  \"1468\": 38,\\n  \"1469\": 38,\\n  \"1470\": 38,\\n  \"1471\": 38,\\n  \"1472\": 38,\\n  \"1473\": 38,\\n  \"1474\": 38,\\n  \"1475\": 38,\\n  \"1476\": 38,\\n  \"1477\": 38,\\n  \"1478\": 38,\\n  \"1479\": 38,\\n  \"1480\": 38,\\n  \"1481\": 38,\\n  \"1482\": 38,\\n  \"1483\": 38,\\n  \"1484\": 38,\\n  \"1485\": 38,\\n  \"1486\": 38,\\n  \"1487\": 38,\\n  \"1488\": 38,\\n  \"1489\": 38,\\n  \"1490\": 38,\\n  \"1491\": 38,\\n  \"1492\": 38,\\n  \"1493\": 38,\\n  \"1494\": 38,\\n  \"1495\": 38,\\n  \"1496\": 38,\\n  \"1497\": 38,\\n  \"1498\": 38,\\n  \"1499\": 38,\\n  \"1500\": 38,\\n  \"1501\": 38,\\n  \"1502\": 38,\\n  \"1503\": 38,\\n  \"1504\": 38,\\n  \"1505\": 38,\\n  \"1506\": 38,\\n  \"1507\": 38,\\n  \"1508\": 38,\\n  \"1509\": 38,\\n  \"1510\": 38,\\n  \"1511\": 38,\\n  \"1512\": 38,\\n  \"1513\": 38,\\n  \"1514\": 38,\\n  \"1515\": 38,\\n  \"1516\": 38,\\n  \"1517\": 38,\\n  \"1518\": 38,\\n  \"1519\": 38,\\n  \"1520\": 38,\\n  \"1521\": 39,\\n  \"1522\": 39,\\n  \"1523\": 39,\\n  \"1524\": 39,\\n  \"1525\": 39,\\n  \"1526\": 39,\\n  \"1527\": 39,\\n  \"1528\": 39,\\n  \"1529\": 39,\\n  \"1530\": 39,\\n  \"1531\": 39,\\n  \"1532\": 39,\\n  \"1533\": 39,\\n  \"1534\": 39,\\n  \"1535\": 39,\\n  \"1536\": 39,\\n  \"1537\": 39,\\n  \"1538\": 39,\\n  \"1539\": 39,\\n  \"1540\": 39,\\n  \"1541\": 39,\\n  \"1542\": 39,\\n  \"1543\": 39,\\n  \"1544\": 39,\\n  \"1545\": 39,\\n  \"1546\": 39,\\n  \"1547\": 39,\\n  \"1548\": 39,\\n  \"1549\": 39,\\n  \"1550\": 39,\\n  \"1551\": 39,\\n  \"1552\": 39,\\n  \"1553\": 39,\\n  \"1554\": 39,\\n  \"1555\": 39,\\n  \"1556\": 39,\\n  \"1557\": 39,\\n  \"1558\": 39,\\n  \"1559\": 39,\\n  \"1560\": 39,\\n  \"1561\": 39,\\n  \"1562\": 39,\\n  \"1563\": 39,\\n  \"1564\": 39,\\n  \"1565\": 39,\\n  \"1566\": 39,\\n  \"1567\": 39,\\n  \"1568\": 39,\\n  \"1569\": 39,\\n  \"1570\": 39,\\n  \"1571\": 39,\\n  \"1572\": 39,\\n  \"1573\": 39,\\n  \"1574\": 39,\\n  \"1575\": 39,\\n  \"1576\": 39,\\n  \"1577\": 39,\\n  \"1578\": 39,\\n  \"1579\": 39,\\n  \"1580\": 39,\\n  \"1581\": 39,\\n  \"1582\": 39,\\n  \"1583\": 39,\\n  \"1584\": 39,\\n  \"1585\": 39,\\n  \"1586\": 39,\\n  \"1587\": 39,\\n  \"1588\": 39,\\n  \"1589\": 39,\\n  \"1590\": 39,\\n  \"1591\": 39,\\n  \"1592\": 39,\\n  \"1593\": 39,\\n  \"1594\": 39,\\n  \"1595\": 39,\\n  \"1596\": 39,\\n  \"1597\": 39,\\n  \"1598\": 39,\\n  \"1599\": 39,\\n  \"1600\": 40,\\n  \"1601\": 40,\\n  \"1602\": 40,\\n  \"1603\": 40,\\n  \"1604\": 40,\\n  \"1605\": 40,\\n  \"1606\": 40,\\n  \"1607\": 40,\\n  \"1608\": 40,\\n  \"1609\": 40,\\n  \"1610\": 40,\\n  \"1611\": 40,\\n  \"1612\": 40,\\n  \"1613\": 40,\\n  \"1614\": 40,\\n  \"1615\": 40,\\n  \"1616\": 40\\n}\\n\\nvar mySqrt = function(x) {\\n  return preCalc[x] || parseInt(Math.sqrt(x))\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} x\\n * @return {number}\\n */\\n\\nconst preCalc = {\\n  \"0\": 0,\\n  \"1\": 1,\\n  \"2\": 1,\\n  \"3\": 1,\\n  \"4\": 2,\\n  \"5\": 2,\\n  \"6\": 2,\\n  \"7\": 2,\\n  \"8\": 2,\\n  \"9\": 3,\\n  \"10\": 3,\\n  \"11\": 3,\\n  \"12\": 3,\\n  \"13\": 3,\\n  \"14\": 3,\\n  \"15\": 3,\\n  \"16\": 4,\\n  \"17\": 4,\\n  \"18\": 4,\\n  \"19\": 4,\\n  \"20\": 4,\\n  \"21\": 4,\\n  \"22\": 4,\\n  \"23\": 4,\\n  \"24\": 4,\\n  \"25\": 5,\\n  \"26\": 5,\\n  \"27\": 5,\\n  \"28\": 5,\\n  \"29\": 5,\\n  \"30\": 5,\\n  \"31\": 5,\\n  \"32\": 5,\\n  \"33\": 5,\\n  \"34\": 5,\\n  \"35\": 5,\\n  \"36\": 6,\\n  \"37\": 6,\\n  \"38\": 6,\\n  \"39\": 6,\\n  \"40\": 6,\\n  \"41\": 6,\\n  \"42\": 6,\\n  \"43\": 6,\\n  \"44\": 6,\\n  \"45\": 6,\\n  \"46\": 6,\\n  \"47\": 6,\\n  \"48\": 6,\\n  \"49\": 7,\\n  \"50\": 7,\\n  \"51\": 7,\\n  \"52\": 7,\\n  \"53\": 7,\\n  \"54\": 7,\\n  \"55\": 7,\\n  \"56\": 7,\\n  \"57\": 7,\\n  \"58\": 7,\\n  \"59\": 7,\\n  \"60\": 7,\\n  \"61\": 7,\\n  \"62\": 7,\\n  \"63\": 7,\\n  \"64\": 8,\\n  \"65\": 8,\\n  \"66\": 8,\\n  \"67\": 8,\\n  \"68\": 8,\\n  \"69\": 8,\\n  \"70\": 8,\\n  \"71\": 8,\\n  \"72\": 8,\\n  \"73\": 8,\\n  \"74\": 8,\\n  \"75\": 8,\\n  \"76\": 8,\\n  \"77\": 8,\\n  \"78\": 8,\\n  \"79\": 8,\\n  \"80\": 8,\\n  \"81\": 9,\\n  \"82\": 9,\\n  \"83\": 9,\\n  \"84\": 9,\\n  \"85\": 9,\\n  \"86\": 9,\\n  \"87\": 9,\\n  \"88\": 9,\\n  \"89\": 9,\\n  \"90\": 9,\\n  \"91\": 9,\\n  \"92\": 9,\\n  \"93\": 9,\\n  \"94\": 9,\\n  \"95\": 9,\\n  \"96\": 9,\\n  \"97\": 9,\\n  \"98\": 9,\\n  \"99\": 9,\\n  \"100\": 10,\\n  \"101\": 10,\\n  \"102\": 10,\\n  \"103\": 10,\\n  \"104\": 10,\\n  \"105\": 10,\\n  \"106\": 10,\\n  \"107\": 10,\\n  \"108\": 10,\\n  \"109\": 10,\\n  \"110\": 10,\\n  \"111\": 10,\\n  \"112\": 10,\\n  \"113\": 10,\\n  \"114\": 10,\\n  \"115\": 10,\\n  \"116\": 10,\\n  \"117\": 10,\\n  \"118\": 10,\\n  \"119\": 10,\\n  \"120\": 10,\\n  \"121\": 11,\\n  \"122\": 11,\\n  \"123\": 11,\\n  \"124\": 11,\\n  \"125\": 11,\\n  \"126\": 11,\\n  \"127\": 11,\\n  \"128\": 11,\\n  \"129\": 11,\\n  \"130\": 11,\\n  \"131\": 11,\\n  \"132\": 11,\\n  \"133\": 11,\\n  \"134\": 11,\\n  \"135\": 11,\\n  \"136\": 11,\\n  \"137\": 11,\\n  \"138\": 11,\\n  \"139\": 11,\\n  \"140\": 11,\\n  \"141\": 11,\\n  \"142\": 11,\\n  \"143\": 11,\\n  \"144\": 12,\\n  \"145\": 12,\\n  \"146\": 12,\\n  \"147\": 12,\\n  \"148\": 12,\\n  \"149\": 12,\\n  \"150\": 12,\\n  \"151\": 12,\\n  \"152\": 12,\\n  \"153\": 12,\\n  \"154\": 12,\\n  \"155\": 12,\\n  \"156\": 12,\\n  \"157\": 12,\\n  \"158\": 12,\\n  \"159\": 12,\\n  \"160\": 12,\\n  \"161\": 12,\\n  \"162\": 12,\\n  \"163\": 12,\\n  \"164\": 12,\\n  \"165\": 12,\\n  \"166\": 12,\\n  \"167\": 12,\\n  \"168\": 12,\\n  \"169\": 13,\\n  \"170\": 13,\\n  \"171\": 13,\\n  \"172\": 13,\\n  \"173\": 13,\\n  \"174\": 13,\\n  \"175\": 13,\\n  \"176\": 13,\\n  \"177\": 13,\\n  \"178\": 13,\\n  \"179\": 13,\\n  \"180\": 13,\\n  \"181\": 13,\\n  \"182\": 13,\\n  \"183\": 13,\\n  \"184\": 13,\\n  \"185\": 13,\\n  \"186\": 13,\\n  \"187\": 13,\\n  \"188\": 13,\\n  \"189\": 13,\\n  \"190\": 13,\\n  \"191\": 13,\\n  \"192\": 13,\\n  \"193\": 13,\\n  \"194\": 13,\\n  \"195\": 13,\\n  \"196\": 14,\\n  \"197\": 14,\\n  \"198\": 14,\\n  \"199\": 14,\\n  \"200\": 14,\\n  \"201\": 14,\\n  \"202\": 14,\\n  \"203\": 14,\\n  \"204\": 14,\\n  \"205\": 14,\\n  \"206\": 14,\\n  \"207\": 14,\\n  \"208\": 14,\\n  \"209\": 14,\\n  \"210\": 14,\\n  \"211\": 14,\\n  \"212\": 14,\\n  \"213\": 14,\\n  \"214\": 14,\\n  \"215\": 14,\\n  \"216\": 14,\\n  \"217\": 14,\\n  \"218\": 14,\\n  \"219\": 14,\\n  \"220\": 14,\\n  \"221\": 14,\\n  \"222\": 14,\\n  \"223\": 14,\\n  \"224\": 14,\\n  \"225\": 15,\\n  \"226\": 15,\\n  \"227\": 15,\\n  \"228\": 15,\\n  \"229\": 15,\\n  \"230\": 15,\\n  \"231\": 15,\\n  \"232\": 15,\\n  \"233\": 15,\\n  \"234\": 15,\\n  \"235\": 15,\\n  \"236\": 15,\\n  \"237\": 15,\\n  \"238\": 15,\\n  \"239\": 15,\\n  \"240\": 15,\\n  \"241\": 15,\\n  \"242\": 15,\\n  \"243\": 15,\\n  \"244\": 15,\\n  \"245\": 15,\\n  \"246\": 15,\\n  \"247\": 15,\\n  \"248\": 15,\\n  \"249\": 15,\\n  \"250\": 15,\\n  \"251\": 15,\\n  \"252\": 15,\\n  \"253\": 15,\\n  \"254\": 15,\\n  \"255\": 15,\\n  \"256\": 16,\\n  \"257\": 16,\\n  \"258\": 16,\\n  \"259\": 16,\\n  \"260\": 16,\\n  \"261\": 16,\\n  \"262\": 16,\\n  \"263\": 16,\\n  \"264\": 16,\\n  \"265\": 16,\\n  \"266\": 16,\\n  \"267\": 16,\\n  \"268\": 16,\\n  \"269\": 16,\\n  \"270\": 16,\\n  \"271\": 16,\\n  \"272\": 16,\\n  \"273\": 16,\\n  \"274\": 16,\\n  \"275\": 16,\\n  \"276\": 16,\\n  \"277\": 16,\\n  \"278\": 16,\\n  \"279\": 16,\\n  \"280\": 16,\\n  \"281\": 16,\\n  \"282\": 16,\\n  \"283\": 16,\\n  \"284\": 16,\\n  \"285\": 16,\\n  \"286\": 16,\\n  \"287\": 16,\\n  \"288\": 16,\\n  \"289\": 17,\\n  \"290\": 17,\\n  \"291\": 17,\\n  \"292\": 17,\\n  \"293\": 17,\\n  \"294\": 17,\\n  \"295\": 17,\\n  \"296\": 17,\\n  \"297\": 17,\\n  \"298\": 17,\\n  \"299\": 17,\\n  \"300\": 17,\\n  \"301\": 17,\\n  \"302\": 17,\\n  \"303\": 17,\\n  \"304\": 17,\\n  \"305\": 17,\\n  \"306\": 17,\\n  \"307\": 17,\\n  \"308\": 17,\\n  \"309\": 17,\\n  \"310\": 17,\\n  \"311\": 17,\\n  \"312\": 17,\\n  \"313\": 17,\\n  \"314\": 17,\\n  \"315\": 17,\\n  \"316\": 17,\\n  \"317\": 17,\\n  \"318\": 17,\\n  \"319\": 17,\\n  \"320\": 17,\\n  \"321\": 17,\\n  \"322\": 17,\\n  \"323\": 17,\\n  \"324\": 18,\\n  \"325\": 18,\\n  \"326\": 18,\\n  \"327\": 18,\\n  \"328\": 18,\\n  \"329\": 18,\\n  \"330\": 18,\\n  \"331\": 18,\\n  \"332\": 18,\\n  \"333\": 18,\\n  \"334\": 18,\\n  \"335\": 18,\\n  \"336\": 18,\\n  \"337\": 18,\\n  \"338\": 18,\\n  \"339\": 18,\\n  \"340\": 18,\\n  \"341\": 18,\\n  \"342\": 18,\\n  \"343\": 18,\\n  \"344\": 18,\\n  \"345\": 18,\\n  \"346\": 18,\\n  \"347\": 18,\\n  \"348\": 18,\\n  \"349\": 18,\\n  \"350\": 18,\\n  \"351\": 18,\\n  \"352\": 18,\\n  \"353\": 18,\\n  \"354\": 18,\\n  \"355\": 18,\\n  \"356\": 18,\\n  \"357\": 18,\\n  \"358\": 18,\\n  \"359\": 18,\\n  \"360\": 18,\\n  \"361\": 19,\\n  \"362\": 19,\\n  \"363\": 19,\\n  \"364\": 19,\\n  \"365\": 19,\\n  \"366\": 19,\\n  \"367\": 19,\\n  \"368\": 19,\\n  \"369\": 19,\\n  \"370\": 19,\\n  \"371\": 19,\\n  \"372\": 19,\\n  \"373\": 19,\\n  \"374\": 19,\\n  \"375\": 19,\\n  \"376\": 19,\\n  \"377\": 19,\\n  \"378\": 19,\\n  \"379\": 19,\\n  \"380\": 19,\\n  \"381\": 19,\\n  \"382\": 19,\\n  \"383\": 19,\\n  \"384\": 19,\\n  \"385\": 19,\\n  \"386\": 19,\\n  \"387\": 19,\\n  \"388\": 19,\\n  \"389\": 19,\\n  \"390\": 19,\\n  \"391\": 19,\\n  \"392\": 19,\\n  \"393\": 19,\\n  \"394\": 19,\\n  \"395\": 19,\\n  \"396\": 19,\\n  \"397\": 19,\\n  \"398\": 19,\\n  \"399\": 19,\\n  \"400\": 20,\\n  \"401\": 20,\\n  \"402\": 20,\\n  \"403\": 20,\\n  \"404\": 20,\\n  \"405\": 20,\\n  \"406\": 20,\\n  \"407\": 20,\\n  \"408\": 20,\\n  \"409\": 20,\\n  \"410\": 20,\\n  \"411\": 20,\\n  \"412\": 20,\\n  \"413\": 20,\\n  \"414\": 20,\\n  \"415\": 20,\\n  \"416\": 20,\\n  \"417\": 20,\\n  \"418\": 20,\\n  \"419\": 20,\\n  \"420\": 20,\\n  \"421\": 20,\\n  \"422\": 20,\\n  \"423\": 20,\\n  \"424\": 20,\\n  \"425\": 20,\\n  \"426\": 20,\\n  \"427\": 20,\\n  \"428\": 20,\\n  \"429\": 20,\\n  \"430\": 20,\\n  \"431\": 20,\\n  \"432\": 20,\\n  \"433\": 20,\\n  \"434\": 20,\\n  \"435\": 20,\\n  \"436\": 20,\\n  \"437\": 20,\\n  \"438\": 20,\\n  \"439\": 20,\\n  \"440\": 20,\\n  \"441\": 21,\\n  \"442\": 21,\\n  \"443\": 21,\\n  \"444\": 21,\\n  \"445\": 21,\\n  \"446\": 21,\\n  \"447\": 21,\\n  \"448\": 21,\\n  \"449\": 21,\\n  \"450\": 21,\\n  \"451\": 21,\\n  \"452\": 21,\\n  \"453\": 21,\\n  \"454\": 21,\\n  \"455\": 21,\\n  \"456\": 21,\\n  \"457\": 21,\\n  \"458\": 21,\\n  \"459\": 21,\\n  \"460\": 21,\\n  \"461\": 21,\\n  \"462\": 21,\\n  \"463\": 21,\\n  \"464\": 21,\\n  \"465\": 21,\\n  \"466\": 21,\\n  \"467\": 21,\\n  \"468\": 21,\\n  \"469\": 21,\\n  \"470\": 21,\\n  \"471\": 21,\\n  \"472\": 21,\\n  \"473\": 21,\\n  \"474\": 21,\\n  \"475\": 21,\\n  \"476\": 21,\\n  \"477\": 21,\\n  \"478\": 21,\\n  \"479\": 21,\\n  \"480\": 21,\\n  \"481\": 21,\\n  \"482\": 21,\\n  \"483\": 21,\\n  \"484\": 22,\\n  \"485\": 22,\\n  \"486\": 22,\\n  \"487\": 22,\\n  \"488\": 22,\\n  \"489\": 22,\\n  \"490\": 22,\\n  \"491\": 22,\\n  \"492\": 22,\\n  \"493\": 22,\\n  \"494\": 22,\\n  \"495\": 22,\\n  \"496\": 22,\\n  \"497\": 22,\\n  \"498\": 22,\\n  \"499\": 22,\\n  \"500\": 22,\\n  \"501\": 22,\\n  \"502\": 22,\\n  \"503\": 22,\\n  \"504\": 22,\\n  \"505\": 22,\\n  \"506\": 22,\\n  \"507\": 22,\\n  \"508\": 22,\\n  \"509\": 22,\\n  \"510\": 22,\\n  \"511\": 22,\\n  \"512\": 22,\\n  \"513\": 22,\\n  \"514\": 22,\\n  \"515\": 22,\\n  \"516\": 22,\\n  \"517\": 22,\\n  \"518\": 22,\\n  \"519\": 22,\\n  \"520\": 22,\\n  \"521\": 22,\\n  \"522\": 22,\\n  \"523\": 22,\\n  \"524\": 22,\\n  \"525\": 22,\\n  \"526\": 22,\\n  \"527\": 22,\\n  \"528\": 22,\\n  \"529\": 23,\\n  \"530\": 23,\\n  \"531\": 23,\\n  \"532\": 23,\\n  \"533\": 23,\\n  \"534\": 23,\\n  \"535\": 23,\\n  \"536\": 23,\\n  \"537\": 23,\\n  \"538\": 23,\\n  \"539\": 23,\\n  \"540\": 23,\\n  \"541\": 23,\\n  \"542\": 23,\\n  \"543\": 23,\\n  \"544\": 23,\\n  \"545\": 23,\\n  \"546\": 23,\\n  \"547\": 23,\\n  \"548\": 23,\\n  \"549\": 23,\\n  \"550\": 23,\\n  \"551\": 23,\\n  \"552\": 23,\\n  \"553\": 23,\\n  \"554\": 23,\\n  \"555\": 23,\\n  \"556\": 23,\\n  \"557\": 23,\\n  \"558\": 23,\\n  \"559\": 23,\\n  \"560\": 23,\\n  \"561\": 23,\\n  \"562\": 23,\\n  \"563\": 23,\\n  \"564\": 23,\\n  \"565\": 23,\\n  \"566\": 23,\\n  \"567\": 23,\\n  \"568\": 23,\\n  \"569\": 23,\\n  \"570\": 23,\\n  \"571\": 23,\\n  \"572\": 23,\\n  \"573\": 23,\\n  \"574\": 23,\\n  \"575\": 23,\\n  \"576\": 24,\\n  \"577\": 24,\\n  \"578\": 24,\\n  \"579\": 24,\\n  \"580\": 24,\\n  \"581\": 24,\\n  \"582\": 24,\\n  \"583\": 24,\\n  \"584\": 24,\\n  \"585\": 24,\\n  \"586\": 24,\\n  \"587\": 24,\\n  \"588\": 24,\\n  \"589\": 24,\\n  \"590\": 24,\\n  \"591\": 24,\\n  \"592\": 24,\\n  \"593\": 24,\\n  \"594\": 24,\\n  \"595\": 24,\\n  \"596\": 24,\\n  \"597\": 24,\\n  \"598\": 24,\\n  \"599\": 24,\\n  \"600\": 24,\\n  \"601\": 24,\\n  \"602\": 24,\\n  \"603\": 24,\\n  \"604\": 24,\\n  \"605\": 24,\\n  \"606\": 24,\\n  \"607\": 24,\\n  \"608\": 24,\\n  \"609\": 24,\\n  \"610\": 24,\\n  \"611\": 24,\\n  \"612\": 24,\\n  \"613\": 24,\\n  \"614\": 24,\\n  \"615\": 24,\\n  \"616\": 24,\\n  \"617\": 24,\\n  \"618\": 24,\\n  \"619\": 24,\\n  \"620\": 24,\\n  \"621\": 24,\\n  \"622\": 24,\\n  \"623\": 24,\\n  \"624\": 24,\\n  \"625\": 25,\\n  \"626\": 25,\\n  \"627\": 25,\\n  \"628\": 25,\\n  \"629\": 25,\\n  \"630\": 25,\\n  \"631\": 25,\\n  \"632\": 25,\\n  \"633\": 25,\\n  \"634\": 25,\\n  \"635\": 25,\\n  \"636\": 25,\\n  \"637\": 25,\\n  \"638\": 25,\\n  \"639\": 25,\\n  \"640\": 25,\\n  \"641\": 25,\\n  \"642\": 25,\\n  \"643\": 25,\\n  \"644\": 25,\\n  \"645\": 25,\\n  \"646\": 25,\\n  \"647\": 25,\\n  \"648\": 25,\\n  \"649\": 25,\\n  \"650\": 25,\\n  \"651\": 25,\\n  \"652\": 25,\\n  \"653\": 25,\\n  \"654\": 25,\\n  \"655\": 25,\\n  \"656\": 25,\\n  \"657\": 25,\\n  \"658\": 25,\\n  \"659\": 25,\\n  \"660\": 25,\\n  \"661\": 25,\\n  \"662\": 25,\\n  \"663\": 25,\\n  \"664\": 25,\\n  \"665\": 25,\\n  \"666\": 25,\\n  \"667\": 25,\\n  \"668\": 25,\\n  \"669\": 25,\\n  \"670\": 25,\\n  \"671\": 25,\\n  \"672\": 25,\\n  \"673\": 25,\\n  \"674\": 25,\\n  \"675\": 25,\\n  \"676\": 26,\\n  \"677\": 26,\\n  \"678\": 26,\\n  \"679\": 26,\\n  \"680\": 26,\\n  \"681\": 26,\\n  \"682\": 26,\\n  \"683\": 26,\\n  \"684\": 26,\\n  \"685\": 26,\\n  \"686\": 26,\\n  \"687\": 26,\\n  \"688\": 26,\\n  \"689\": 26,\\n  \"690\": 26,\\n  \"691\": 26,\\n  \"692\": 26,\\n  \"693\": 26,\\n  \"694\": 26,\\n  \"695\": 26,\\n  \"696\": 26,\\n  \"697\": 26,\\n  \"698\": 26,\\n  \"699\": 26,\\n  \"700\": 26,\\n  \"701\": 26,\\n  \"702\": 26,\\n  \"703\": 26,\\n  \"704\": 26,\\n  \"705\": 26,\\n  \"706\": 26,\\n  \"707\": 26,\\n  \"708\": 26,\\n  \"709\": 26,\\n  \"710\": 26,\\n  \"711\": 26,\\n  \"712\": 26,\\n  \"713\": 26,\\n  \"714\": 26,\\n  \"715\": 26,\\n  \"716\": 26,\\n  \"717\": 26,\\n  \"718\": 26,\\n  \"719\": 26,\\n  \"720\": 26,\\n  \"721\": 26,\\n  \"722\": 26,\\n  \"723\": 26,\\n  \"724\": 26,\\n  \"725\": 26,\\n  \"726\": 26,\\n  \"727\": 26,\\n  \"728\": 26,\\n  \"729\": 27,\\n  \"730\": 27,\\n  \"731\": 27,\\n  \"732\": 27,\\n  \"733\": 27,\\n  \"734\": 27,\\n  \"735\": 27,\\n  \"736\": 27,\\n  \"737\": 27,\\n  \"738\": 27,\\n  \"739\": 27,\\n  \"740\": 27,\\n  \"741\": 27,\\n  \"742\": 27,\\n  \"743\": 27,\\n  \"744\": 27,\\n  \"745\": 27,\\n  \"746\": 27,\\n  \"747\": 27,\\n  \"748\": 27,\\n  \"749\": 27,\\n  \"750\": 27,\\n  \"751\": 27,\\n  \"752\": 27,\\n  \"753\": 27,\\n  \"754\": 27,\\n  \"755\": 27,\\n  \"756\": 27,\\n  \"757\": 27,\\n  \"758\": 27,\\n  \"759\": 27,\\n  \"760\": 27,\\n  \"761\": 27,\\n  \"762\": 27,\\n  \"763\": 27,\\n  \"764\": 27,\\n  \"765\": 27,\\n  \"766\": 27,\\n  \"767\": 27,\\n  \"768\": 27,\\n  \"769\": 27,\\n  \"770\": 27,\\n  \"771\": 27,\\n  \"772\": 27,\\n  \"773\": 27,\\n  \"774\": 27,\\n  \"775\": 27,\\n  \"776\": 27,\\n  \"777\": 27,\\n  \"778\": 27,\\n  \"779\": 27,\\n  \"780\": 27,\\n  \"781\": 27,\\n  \"782\": 27,\\n  \"783\": 27,\\n  \"784\": 28,\\n  \"785\": 28,\\n  \"786\": 28,\\n  \"787\": 28,\\n  \"788\": 28,\\n  \"789\": 28,\\n  \"790\": 28,\\n  \"791\": 28,\\n  \"792\": 28,\\n  \"793\": 28,\\n  \"794\": 28,\\n  \"795\": 28,\\n  \"796\": 28,\\n  \"797\": 28,\\n  \"798\": 28,\\n  \"799\": 28,\\n  \"800\": 28,\\n  \"801\": 28,\\n  \"802\": 28,\\n  \"803\": 28,\\n  \"804\": 28,\\n  \"805\": 28,\\n  \"806\": 28,\\n  \"807\": 28,\\n  \"808\": 28,\\n  \"809\": 28,\\n  \"810\": 28,\\n  \"811\": 28,\\n  \"812\": 28,\\n  \"813\": 28,\\n  \"814\": 28,\\n  \"815\": 28,\\n  \"816\": 28,\\n  \"817\": 28,\\n  \"818\": 28,\\n  \"819\": 28,\\n  \"820\": 28,\\n  \"821\": 28,\\n  \"822\": 28,\\n  \"823\": 28,\\n  \"824\": 28,\\n  \"825\": 28,\\n  \"826\": 28,\\n  \"827\": 28,\\n  \"828\": 28,\\n  \"829\": 28,\\n  \"830\": 28,\\n  \"831\": 28,\\n  \"832\": 28,\\n  \"833\": 28,\\n  \"834\": 28,\\n  \"835\": 28,\\n  \"836\": 28,\\n  \"837\": 28,\\n  \"838\": 28,\\n  \"839\": 28,\\n  \"840\": 28,\\n  \"841\": 29,\\n  \"842\": 29,\\n  \"843\": 29,\\n  \"844\": 29,\\n  \"845\": 29,\\n  \"846\": 29,\\n  \"847\": 29,\\n  \"848\": 29,\\n  \"849\": 29,\\n  \"850\": 29,\\n  \"851\": 29,\\n  \"852\": 29,\\n  \"853\": 29,\\n  \"854\": 29,\\n  \"855\": 29,\\n  \"856\": 29,\\n  \"857\": 29,\\n  \"858\": 29,\\n  \"859\": 29,\\n  \"860\": 29,\\n  \"861\": 29,\\n  \"862\": 29,\\n  \"863\": 29,\\n  \"864\": 29,\\n  \"865\": 29,\\n  \"866\": 29,\\n  \"867\": 29,\\n  \"868\": 29,\\n  \"869\": 29,\\n  \"870\": 29,\\n  \"871\": 29,\\n  \"872\": 29,\\n  \"873\": 29,\\n  \"874\": 29,\\n  \"875\": 29,\\n  \"876\": 29,\\n  \"877\": 29,\\n  \"878\": 29,\\n  \"879\": 29,\\n  \"880\": 29,\\n  \"881\": 29,\\n  \"882\": 29,\\n  \"883\": 29,\\n  \"884\": 29,\\n  \"885\": 29,\\n  \"886\": 29,\\n  \"887\": 29,\\n  \"888\": 29,\\n  \"889\": 29,\\n  \"890\": 29,\\n  \"891\": 29,\\n  \"892\": 29,\\n  \"893\": 29,\\n  \"894\": 29,\\n  \"895\": 29,\\n  \"896\": 29,\\n  \"897\": 29,\\n  \"898\": 29,\\n  \"899\": 29,\\n  \"900\": 30,\\n  \"901\": 30,\\n  \"902\": 30,\\n  \"903\": 30,\\n  \"904\": 30,\\n  \"905\": 30,\\n  \"906\": 30,\\n  \"907\": 30,\\n  \"908\": 30,\\n  \"909\": 30,\\n  \"910\": 30,\\n  \"911\": 30,\\n  \"912\": 30,\\n  \"913\": 30,\\n  \"914\": 30,\\n  \"915\": 30,\\n  \"916\": 30,\\n  \"917\": 30,\\n  \"918\": 30,\\n  \"919\": 30,\\n  \"920\": 30,\\n  \"921\": 30,\\n  \"922\": 30,\\n  \"923\": 30,\\n  \"924\": 30,\\n  \"925\": 30,\\n  \"926\": 30,\\n  \"927\": 30,\\n  \"928\": 30,\\n  \"929\": 30,\\n  \"930\": 30,\\n  \"931\": 30,\\n  \"932\": 30,\\n  \"933\": 30,\\n  \"934\": 30,\\n  \"935\": 30,\\n  \"936\": 30,\\n  \"937\": 30,\\n  \"938\": 30,\\n  \"939\": 30,\\n  \"940\": 30,\\n  \"941\": 30,\\n  \"942\": 30,\\n  \"943\": 30,\\n  \"944\": 30,\\n  \"945\": 30,\\n  \"946\": 30,\\n  \"947\": 30,\\n  \"948\": 30,\\n  \"949\": 30,\\n  \"950\": 30,\\n  \"951\": 30,\\n  \"952\": 30,\\n  \"953\": 30,\\n  \"954\": 30,\\n  \"955\": 30,\\n  \"956\": 30,\\n  \"957\": 30,\\n  \"958\": 30,\\n  \"959\": 30,\\n  \"960\": 30,\\n  \"961\": 31,\\n  \"962\": 31,\\n  \"963\": 31,\\n  \"964\": 31,\\n  \"965\": 31,\\n  \"966\": 31,\\n  \"967\": 31,\\n  \"968\": 31,\\n  \"969\": 31,\\n  \"970\": 31,\\n  \"971\": 31,\\n  \"972\": 31,\\n  \"973\": 31,\\n  \"974\": 31,\\n  \"975\": 31,\\n  \"976\": 31,\\n  \"977\": 31,\\n  \"978\": 31,\\n  \"979\": 31,\\n  \"980\": 31,\\n  \"981\": 31,\\n  \"982\": 31,\\n  \"983\": 31,\\n  \"984\": 31,\\n  \"985\": 31,\\n  \"986\": 31,\\n  \"987\": 31,\\n  \"988\": 31,\\n  \"989\": 31,\\n  \"990\": 31,\\n  \"991\": 31,\\n  \"992\": 31,\\n  \"993\": 31,\\n  \"994\": 31,\\n  \"995\": 31,\\n  \"996\": 31,\\n  \"997\": 31,\\n  \"998\": 31,\\n  \"999\": 31,\\n  \"1000\": 31,\\n  \"1001\": 31,\\n  \"1002\": 31,\\n  \"1003\": 31,\\n  \"1004\": 31,\\n  \"1005\": 31,\\n  \"1006\": 31,\\n  \"1007\": 31,\\n  \"1008\": 31,\\n  \"1009\": 31,\\n  \"1010\": 31,\\n  \"1011\": 31,\\n  \"1012\": 31,\\n  \"1013\": 31,\\n  \"1014\": 31,\\n  \"1015\": 31,\\n  \"1016\": 31,\\n  \"1017\": 31,\\n  \"1018\": 31,\\n  \"1019\": 31,\\n  \"1020\": 31,\\n  \"1021\": 31,\\n  \"1022\": 31,\\n  \"1023\": 31,\\n  \"1024\": 32,\\n  \"1025\": 32,\\n  \"1026\": 32,\\n  \"1027\": 32,\\n  \"1028\": 32,\\n  \"1029\": 32,\\n  \"1030\": 32,\\n  \"1031\": 32,\\n  \"1032\": 32,\\n  \"1033\": 32,\\n  \"1034\": 32,\\n  \"1035\": 32,\\n  \"1036\": 32,\\n  \"1037\": 32,\\n  \"1038\": 32,\\n  \"1039\": 32,\\n  \"1040\": 32,\\n  \"1041\": 32,\\n  \"1042\": 32,\\n  \"1043\": 32,\\n  \"1044\": 32,\\n  \"1045\": 32,\\n  \"1046\": 32,\\n  \"1047\": 32,\\n  \"1048\": 32,\\n  \"1049\": 32,\\n  \"1050\": 32,\\n  \"1051\": 32,\\n  \"1052\": 32,\\n  \"1053\": 32,\\n  \"1054\": 32,\\n  \"1055\": 32,\\n  \"1056\": 32,\\n  \"1057\": 32,\\n  \"1058\": 32,\\n  \"1059\": 32,\\n  \"1060\": 32,\\n  \"1061\": 32,\\n  \"1062\": 32,\\n  \"1063\": 32,\\n  \"1064\": 32,\\n  \"1065\": 32,\\n  \"1066\": 32,\\n  \"1067\": 32,\\n  \"1068\": 32,\\n  \"1069\": 32,\\n  \"1070\": 32,\\n  \"1071\": 32,\\n  \"1072\": 32,\\n  \"1073\": 32,\\n  \"1074\": 32,\\n  \"1075\": 32,\\n  \"1076\": 32,\\n  \"1077\": 32,\\n  \"1078\": 32,\\n  \"1079\": 32,\\n  \"1080\": 32,\\n  \"1081\": 32,\\n  \"1082\": 32,\\n  \"1083\": 32,\\n  \"1084\": 32,\\n  \"1085\": 32,\\n  \"1086\": 32,\\n  \"1087\": 32,\\n  \"1088\": 32,\\n  \"1089\": 33,\\n  \"1090\": 33,\\n  \"1091\": 33,\\n  \"1092\": 33,\\n  \"1093\": 33,\\n  \"1094\": 33,\\n  \"1095\": 33,\\n  \"1096\": 33,\\n  \"1097\": 33,\\n  \"1098\": 33,\\n  \"1099\": 33,\\n  \"1100\": 33,\\n  \"1101\": 33,\\n  \"1102\": 33,\\n  \"1103\": 33,\\n  \"1104\": 33,\\n  \"1105\": 33,\\n  \"1106\": 33,\\n  \"1107\": 33,\\n  \"1108\": 33,\\n  \"1109\": 33,\\n  \"1110\": 33,\\n  \"1111\": 33,\\n  \"1112\": 33,\\n  \"1113\": 33,\\n  \"1114\": 33,\\n  \"1115\": 33,\\n  \"1116\": 33,\\n  \"1117\": 33,\\n  \"1118\": 33,\\n  \"1119\": 33,\\n  \"1120\": 33,\\n  \"1121\": 33,\\n  \"1122\": 33,\\n  \"1123\": 33,\\n  \"1124\": 33,\\n  \"1125\": 33,\\n  \"1126\": 33,\\n  \"1127\": 33,\\n  \"1128\": 33,\\n  \"1129\": 33,\\n  \"1130\": 33,\\n  \"1131\": 33,\\n  \"1132\": 33,\\n  \"1133\": 33,\\n  \"1134\": 33,\\n  \"1135\": 33,\\n  \"1136\": 33,\\n  \"1137\": 33,\\n  \"1138\": 33,\\n  \"1139\": 33,\\n  \"1140\": 33,\\n  \"1141\": 33,\\n  \"1142\": 33,\\n  \"1143\": 33,\\n  \"1144\": 33,\\n  \"1145\": 33,\\n  \"1146\": 33,\\n  \"1147\": 33,\\n  \"1148\": 33,\\n  \"1149\": 33,\\n  \"1150\": 33,\\n  \"1151\": 33,\\n  \"1152\": 33,\\n  \"1153\": 33,\\n  \"1154\": 33,\\n  \"1155\": 33,\\n  \"1156\": 34,\\n  \"1157\": 34,\\n  \"1158\": 34,\\n  \"1159\": 34,\\n  \"1160\": 34,\\n  \"1161\": 34,\\n  \"1162\": 34,\\n  \"1163\": 34,\\n  \"1164\": 34,\\n  \"1165\": 34,\\n  \"1166\": 34,\\n  \"1167\": 34,\\n  \"1168\": 34,\\n  \"1169\": 34,\\n  \"1170\": 34,\\n  \"1171\": 34,\\n  \"1172\": 34,\\n  \"1173\": 34,\\n  \"1174\": 34,\\n  \"1175\": 34,\\n  \"1176\": 34,\\n  \"1177\": 34,\\n  \"1178\": 34,\\n  \"1179\": 34,\\n  \"1180\": 34,\\n  \"1181\": 34,\\n  \"1182\": 34,\\n  \"1183\": 34,\\n  \"1184\": 34,\\n  \"1185\": 34,\\n  \"1186\": 34,\\n  \"1187\": 34,\\n  \"1188\": 34,\\n  \"1189\": 34,\\n  \"1190\": 34,\\n  \"1191\": 34,\\n  \"1192\": 34,\\n  \"1193\": 34,\\n  \"1194\": 34,\\n  \"1195\": 34,\\n  \"1196\": 34,\\n  \"1197\": 34,\\n  \"1198\": 34,\\n  \"1199\": 34,\\n  \"1200\": 34,\\n  \"1201\": 34,\\n  \"1202\": 34,\\n  \"1203\": 34,\\n  \"1204\": 34,\\n  \"1205\": 34,\\n  \"1206\": 34,\\n  \"1207\": 34,\\n  \"1208\": 34,\\n  \"1209\": 34,\\n  \"1210\": 34,\\n  \"1211\": 34,\\n  \"1212\": 34,\\n  \"1213\": 34,\\n  \"1214\": 34,\\n  \"1215\": 34,\\n  \"1216\": 34,\\n  \"1217\": 34,\\n  \"1218\": 34,\\n  \"1219\": 34,\\n  \"1220\": 34,\\n  \"1221\": 34,\\n  \"1222\": 34,\\n  \"1223\": 34,\\n  \"1224\": 34,\\n  \"1225\": 35,\\n  \"1226\": 35,\\n  \"1227\": 35,\\n  \"1228\": 35,\\n  \"1229\": 35,\\n  \"1230\": 35,\\n  \"1231\": 35,\\n  \"1232\": 35,\\n  \"1233\": 35,\\n  \"1234\": 35,\\n  \"1235\": 35,\\n  \"1236\": 35,\\n  \"1237\": 35,\\n  \"1238\": 35,\\n  \"1239\": 35,\\n  \"1240\": 35,\\n  \"1241\": 35,\\n  \"1242\": 35,\\n  \"1243\": 35,\\n  \"1244\": 35,\\n  \"1245\": 35,\\n  \"1246\": 35,\\n  \"1247\": 35,\\n  \"1248\": 35,\\n  \"1249\": 35,\\n  \"1250\": 35,\\n  \"1251\": 35,\\n  \"1252\": 35,\\n  \"1253\": 35,\\n  \"1254\": 35,\\n  \"1255\": 35,\\n  \"1256\": 35,\\n  \"1257\": 35,\\n  \"1258\": 35,\\n  \"1259\": 35,\\n  \"1260\": 35,\\n  \"1261\": 35,\\n  \"1262\": 35,\\n  \"1263\": 35,\\n  \"1264\": 35,\\n  \"1265\": 35,\\n  \"1266\": 35,\\n  \"1267\": 35,\\n  \"1268\": 35,\\n  \"1269\": 35,\\n  \"1270\": 35,\\n  \"1271\": 35,\\n  \"1272\": 35,\\n  \"1273\": 35,\\n  \"1274\": 35,\\n  \"1275\": 35,\\n  \"1276\": 35,\\n  \"1277\": 35,\\n  \"1278\": 35,\\n  \"1279\": 35,\\n  \"1280\": 35,\\n  \"1281\": 35,\\n  \"1282\": 35,\\n  \"1283\": 35,\\n  \"1284\": 35,\\n  \"1285\": 35,\\n  \"1286\": 35,\\n  \"1287\": 35,\\n  \"1288\": 35,\\n  \"1289\": 35,\\n  \"1290\": 35,\\n  \"1291\": 35,\\n  \"1292\": 35,\\n  \"1293\": 35,\\n  \"1294\": 35,\\n  \"1295\": 35,\\n  \"1296\": 36,\\n  \"1297\": 36,\\n  \"1298\": 36,\\n  \"1299\": 36,\\n  \"1300\": 36,\\n  \"1301\": 36,\\n  \"1302\": 36,\\n  \"1303\": 36,\\n  \"1304\": 36,\\n  \"1305\": 36,\\n  \"1306\": 36,\\n  \"1307\": 36,\\n  \"1308\": 36,\\n  \"1309\": 36,\\n  \"1310\": 36,\\n  \"1311\": 36,\\n  \"1312\": 36,\\n  \"1313\": 36,\\n  \"1314\": 36,\\n  \"1315\": 36,\\n  \"1316\": 36,\\n  \"1317\": 36,\\n  \"1318\": 36,\\n  \"1319\": 36,\\n  \"1320\": 36,\\n  \"1321\": 36,\\n  \"1322\": 36,\\n  \"1323\": 36,\\n  \"1324\": 36,\\n  \"1325\": 36,\\n  \"1326\": 36,\\n  \"1327\": 36,\\n  \"1328\": 36,\\n  \"1329\": 36,\\n  \"1330\": 36,\\n  \"1331\": 36,\\n  \"1332\": 36,\\n  \"1333\": 36,\\n  \"1334\": 36,\\n  \"1335\": 36,\\n  \"1336\": 36,\\n  \"1337\": 36,\\n  \"1338\": 36,\\n  \"1339\": 36,\\n  \"1340\": 36,\\n  \"1341\": 36,\\n  \"1342\": 36,\\n  \"1343\": 36,\\n  \"1344\": 36,\\n  \"1345\": 36,\\n  \"1346\": 36,\\n  \"1347\": 36,\\n  \"1348\": 36,\\n  \"1349\": 36,\\n  \"1350\": 36,\\n  \"1351\": 36,\\n  \"1352\": 36,\\n  \"1353\": 36,\\n  \"1354\": 36,\\n  \"1355\": 36,\\n  \"1356\": 36,\\n  \"1357\": 36,\\n  \"1358\": 36,\\n  \"1359\": 36,\\n  \"1360\": 36,\\n  \"1361\": 36,\\n  \"1362\": 36,\\n  \"1363\": 36,\\n  \"1364\": 36,\\n  \"1365\": 36,\\n  \"1366\": 36,\\n  \"1367\": 36,\\n  \"1368\": 36,\\n  \"1369\": 37,\\n  \"1370\": 37,\\n  \"1371\": 37,\\n  \"1372\": 37,\\n  \"1373\": 37,\\n  \"1374\": 37,\\n  \"1375\": 37,\\n  \"1376\": 37,\\n  \"1377\": 37,\\n  \"1378\": 37,\\n  \"1379\": 37,\\n  \"1380\": 37,\\n  \"1381\": 37,\\n  \"1382\": 37,\\n  \"1383\": 37,\\n  \"1384\": 37,\\n  \"1385\": 37,\\n  \"1386\": 37,\\n  \"1387\": 37,\\n  \"1388\": 37,\\n  \"1389\": 37,\\n  \"1390\": 37,\\n  \"1391\": 37,\\n  \"1392\": 37,\\n  \"1393\": 37,\\n  \"1394\": 37,\\n  \"1395\": 37,\\n  \"1396\": 37,\\n  \"1397\": 37,\\n  \"1398\": 37,\\n  \"1399\": 37,\\n  \"1400\": 37,\\n  \"1401\": 37,\\n  \"1402\": 37,\\n  \"1403\": 37,\\n  \"1404\": 37,\\n  \"1405\": 37,\\n  \"1406\": 37,\\n  \"1407\": 37,\\n  \"1408\": 37,\\n  \"1409\": 37,\\n  \"1410\": 37,\\n  \"1411\": 37,\\n  \"1412\": 37,\\n  \"1413\": 37,\\n  \"1414\": 37,\\n  \"1415\": 37,\\n  \"1416\": 37,\\n  \"1417\": 37,\\n  \"1418\": 37,\\n  \"1419\": 37,\\n  \"1420\": 37,\\n  \"1421\": 37,\\n  \"1422\": 37,\\n  \"1423\": 37,\\n  \"1424\": 37,\\n  \"1425\": 37,\\n  \"1426\": 37,\\n  \"1427\": 37,\\n  \"1428\": 37,\\n  \"1429\": 37,\\n  \"1430\": 37,\\n  \"1431\": 37,\\n  \"1432\": 37,\\n  \"1433\": 37,\\n  \"1434\": 37,\\n  \"1435\": 37,\\n  \"1436\": 37,\\n  \"1437\": 37,\\n  \"1438\": 37,\\n  \"1439\": 37,\\n  \"1440\": 37,\\n  \"1441\": 37,\\n  \"1442\": 37,\\n  \"1443\": 37,\\n  \"1444\": 38,\\n  \"1445\": 38,\\n  \"1446\": 38,\\n  \"1447\": 38,\\n  \"1448\": 38,\\n  \"1449\": 38,\\n  \"1450\": 38,\\n  \"1451\": 38,\\n  \"1452\": 38,\\n  \"1453\": 38,\\n  \"1454\": 38,\\n  \"1455\": 38,\\n  \"1456\": 38,\\n  \"1457\": 38,\\n  \"1458\": 38,\\n  \"1459\": 38,\\n  \"1460\": 38,\\n  \"1461\": 38,\\n  \"1462\": 38,\\n  \"1463\": 38,\\n  \"1464\": 38,\\n  \"1465\": 38,\\n  \"1466\": 38,\\n  \"1467\": 38,\\n  \"1468\": 38,\\n  \"1469\": 38,\\n  \"1470\": 38,\\n  \"1471\": 38,\\n  \"1472\": 38,\\n  \"1473\": 38,\\n  \"1474\": 38,\\n  \"1475\": 38,\\n  \"1476\": 38,\\n  \"1477\": 38,\\n  \"1478\": 38,\\n  \"1479\": 38,\\n  \"1480\": 38,\\n  \"1481\": 38,\\n  \"1482\": 38,\\n  \"1483\": 38,\\n  \"1484\": 38,\\n  \"1485\": 38,\\n  \"1486\": 38,\\n  \"1487\": 38,\\n  \"1488\": 38,\\n  \"1489\": 38,\\n  \"1490\": 38,\\n  \"1491\": 38,\\n  \"1492\": 38,\\n  \"1493\": 38,\\n  \"1494\": 38,\\n  \"1495\": 38,\\n  \"1496\": 38,\\n  \"1497\": 38,\\n  \"1498\": 38,\\n  \"1499\": 38,\\n  \"1500\": 38,\\n  \"1501\": 38,\\n  \"1502\": 38,\\n  \"1503\": 38,\\n  \"1504\": 38,\\n  \"1505\": 38,\\n  \"1506\": 38,\\n  \"1507\": 38,\\n  \"1508\": 38,\\n  \"1509\": 38,\\n  \"1510\": 38,\\n  \"1511\": 38,\\n  \"1512\": 38,\\n  \"1513\": 38,\\n  \"1514\": 38,\\n  \"1515\": 38,\\n  \"1516\": 38,\\n  \"1517\": 38,\\n  \"1518\": 38,\\n  \"1519\": 38,\\n  \"1520\": 38,\\n  \"1521\": 39,\\n  \"1522\": 39,\\n  \"1523\": 39,\\n  \"1524\": 39,\\n  \"1525\": 39,\\n  \"1526\": 39,\\n  \"1527\": 39,\\n  \"1528\": 39,\\n  \"1529\": 39,\\n  \"1530\": 39,\\n  \"1531\": 39,\\n  \"1532\": 39,\\n  \"1533\": 39,\\n  \"1534\": 39,\\n  \"1535\": 39,\\n  \"1536\": 39,\\n  \"1537\": 39,\\n  \"1538\": 39,\\n  \"1539\": 39,\\n  \"1540\": 39,\\n  \"1541\": 39,\\n  \"1542\": 39,\\n  \"1543\": 39,\\n  \"1544\": 39,\\n  \"1545\": 39,\\n  \"1546\": 39,\\n  \"1547\": 39,\\n  \"1548\": 39,\\n  \"1549\": 39,\\n  \"1550\": 39,\\n  \"1551\": 39,\\n  \"1552\": 39,\\n  \"1553\": 39,\\n  \"1554\": 39,\\n  \"1555\": 39,\\n  \"1556\": 39,\\n  \"1557\": 39,\\n  \"1558\": 39,\\n  \"1559\": 39,\\n  \"1560\": 39,\\n  \"1561\": 39,\\n  \"1562\": 39,\\n  \"1563\": 39,\\n  \"1564\": 39,\\n  \"1565\": 39,\\n  \"1566\": 39,\\n  \"1567\": 39,\\n  \"1568\": 39,\\n  \"1569\": 39,\\n  \"1570\": 39,\\n  \"1571\": 39,\\n  \"1572\": 39,\\n  \"1573\": 39,\\n  \"1574\": 39,\\n  \"1575\": 39,\\n  \"1576\": 39,\\n  \"1577\": 39,\\n  \"1578\": 39,\\n  \"1579\": 39,\\n  \"1580\": 39,\\n  \"1581\": 39,\\n  \"1582\": 39,\\n  \"1583\": 39,\\n  \"1584\": 39,\\n  \"1585\": 39,\\n  \"1586\": 39,\\n  \"1587\": 39,\\n  \"1588\": 39,\\n  \"1589\": 39,\\n  \"1590\": 39,\\n  \"1591\": 39,\\n  \"1592\": 39,\\n  \"1593\": 39,\\n  \"1594\": 39,\\n  \"1595\": 39,\\n  \"1596\": 39,\\n  \"1597\": 39,\\n  \"1598\": 39,\\n  \"1599\": 39,\\n  \"1600\": 40,\\n  \"1601\": 40,\\n  \"1602\": 40,\\n  \"1603\": 40,\\n  \"1604\": 40,\\n  \"1605\": 40,\\n  \"1606\": 40,\\n  \"1607\": 40,\\n  \"1608\": 40,\\n  \"1609\": 40,\\n  \"1610\": 40,\\n  \"1611\": 40,\\n  \"1612\": 40,\\n  \"1613\": 40,\\n  \"1614\": 40,\\n  \"1615\": 40,\\n  \"1616\": 40\\n}\\n\\nvar mySqrt = function(x) {\\n  return preCalc[x] || parseInt(Math.sqrt(x))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165257,
                "title": "a-newton-iteration-solution-beat-100",
                "content": "If we want to solve a given equation f(x)=x^2-a, it is pretty easy to solve it via Newton Iteration.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/xiderowg/image_1535699152.png)\\n\\nfrom above picture we can see that if we choose a number x0 arbitarily, the intersection of the tangent of the f(x) past the point (x0,f(x0)) and the x-axis,which is (x1,0), is much closer to the real solution (x*,0). After n times iterations, the intersection point (xn,0) will be very close to (x*,0). In this question, we don\\'t need to calculate the very real solution of sqrt(a), so I give a error range, if it is within the range, just return the intersection point, here\\'s the code.\\n```\\npublic class Solution {\\n    public int MySqrt (int x) {\\n        if (x <= 1)\\n            return x;\\n        double assume = x / 2, err = 0.01;\\n        while (Math.Abs (Math.Pow (assume, 2) - x) > err) {\\n            assume = (assume + x / assume) / 2;\\n        }\\n        return (int) Math.Floor (assume);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MySqrt (int x) {\\n        if (x <= 1)\\n            return x;\\n        double assume = x / 2, err = 0.01;\\n        while (Math.Abs (Math.Pow (assume, 2) - x) > err) {\\n            assume = (assume + x / assume) / 2;\\n        }\\n        return (int) Math.Floor (assume);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 129247,
                "title": "extension-how-to-find-a-root-of-any-number",
                "content": "We know how to get square root, but what about cube root ( x ^ 1/3 )? or arbitary number of root ?\\nThis is the code using tangent line approximation` f(xn+1) ~= f(xn) + f\\'(xn) (xn+1 \\u2212 xn))` to find root of `f(x) = x^n - a ` iteratively\\n\\nFor more info about this method plz read [Square Roots via Newton\\u2019s Method](https://math.mit.edu/~stevenj/18.335/newton-sqrt.pdf)\\n\\n```\\ndef getRoot(a, n = 2):\\n  if a * n == 0: return 0\\n  x0, x1 = a, 0\\n  while x0 > a / (x0 ** (n - 1)): # prevent overflow\\n    x1 = x0 - (x0 ** n - a) / (n * x0 ** (n - 1))\\n    if x0 == x1: break\\n    x0 = x1\\n  return x0\\n\\n>>getRoot(16, 4)\\n>>2\\n>>getRoot(7, 3)\\n>>1.7320508075688772\\n```",
                "solutionTags": [],
                "code": "```\\ndef getRoot(a, n = 2):\\n  if a * n == 0: return 0\\n  x0, x1 = a, 0\\n  while x0 > a / (x0 ** (n - 1)): # prevent overflow\\n    x1 = x0 - (x0 ** n - a) / (n * x0 ** (n - 1))\\n    if x0 == x1: break\\n    x0 = x1\\n  return x0\\n\\n>>getRoot(16, 4)\\n>>2\\n>>getRoot(7, 3)\\n>>1.7320508075688772\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 25172,
                "title": "o-logn-java-generic-binary-search-solution",
                "content": "Generic binary search, `int mid = lo + (hi - lo) / 2 + 1;` gives preference on right value, so this way we are searching for the largest mid value that satisfy the condition, which is what sqrt(x) requires.\\n\\n    public int mySqrt(int x) {\\n        int lo = 1, hi = x;\\n        while(lo < hi) {\\n            int mid = lo + (hi - lo) / 2 + 1;\\n            if(mid > x / mid) {\\n                hi = mid - 1;\\n            } else {\\n                lo = mid;\\n            }\\n        }\\n        return hi;\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "Generic binary search, `int mid = lo + (hi - lo) / 2 + 1;` gives preference on right value, so this way we are searching for the largest mid value that satisfy the condition, which is what sqrt(x) requires.\\n\\n    public int mySqrt(int x) {\\n        int lo = 1, hi = x;\\n        while(lo < hi) {\\n            int mid = lo + (hi - lo) / 2 + 1;\\n            if(mid > x / mid) {\\n                hi = mid - 1;\\n            } else {\\n                lo = mid;\\n            }\\n        }\\n        return hi;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 25261,
                "title": "my-python-solution-cost-77ms",
                "content": "The main thought of my algorithm is binary search. Cost 77ms.\\n\\n    class Solution:\\n        # @param x, an integer\\n        # @return an integer\\n        def sqrt(self, x):\\n            if x == 0:\\n                return 0\\n            low = 1\\n            high = x\\n            mark = 1\\n            while low != high - 1:\\n                mid = (high + low) / 2\\n                if mid * mid > x:\\n                    high = mid\\n                elif mid * mid < x:\\n                    mark = mid\\n                    low = mid\\n                else:\\n                    return mid\\n            return mark\\n\\nAnd I changed **yuyibestman** and **tyuan73**'s java codes which using math method  into python and improved a little bit. Cost 79ms.\\n\\n    class Solution:\\n        # @param x, an integer\\n        # @return an integer\\n        def sqrt(self, x):\\n            ans = 0\\n            bit = 1l << 15\\n            while bit > 0:\\n                ans |= bit\\n                if ans * ans > x:\\n                    ans ^= bit\\n                bit >>= 1\\n            return int(ans)\\n\\nWish these codes can help you.",
                "solutionTags": [
                    "Python"
                ],
                "code": "The main thought of my algorithm is binary search. Cost 77ms.\\n\\n    class Solution:\\n        # @param x, an integer\\n        # @return an integer\\n        def sqrt(self, x):\\n            if x == 0:\\n                return 0\\n            low = 1\\n            high = x\\n            mark = 1\\n            while low != high - 1:\\n                mid = (high + low) / 2\\n                if mid * mid > x:\\n                    high = mid\\n                elif mid * mid < x:\\n                    mark = mid\\n                    low = mid\\n                else:\\n                    return mid\\n            return mark\\n\\nAnd I changed **yuyibestman** and **tyuan73**'s java codes which using math method  into python and improved a little bit. Cost 79ms.\\n\\n    class Solution:\\n        # @param x, an integer\\n        # @return an integer\\n        def sqrt(self, x):\\n            ans = 0\\n            bit = 1l << 15\\n            while bit > 0:\\n                ans |= bit\\n                if ans * ans > x:\\n                    ans ^= bit\\n                bit >>= 1\\n            return int(ans)\\n\\nWish these codes can help you.",
                "codeTag": "Java"
            },
            {
                "id": 3895581,
                "title": "babylonian-method",
                "content": "# Intuition\\nBabylonian method(learn calculus..!)\\n\\n# Approach\\nseries of function An+1=0.5*(An+x/An) to be iterated 50 times to get approx value of sqrt(x) \\n50 iterations is lower bound and might increase for higher values.\\n\\n# Complexity\\n- Time complexity:O(1)\\n\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\ndouble mySqrt(double x){\\n    double n=1.0;\\n    if (x!=0)\\n    {\\n        for(int i=0;i<50;i++)\\n        {\\n            n=0.5*(n+x/n);\\n        }\\n        return n;\\n    }\\n    else \\n    return 0;\\n    \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ndouble mySqrt(double x){\\n    double n=1.0;\\n    if (x!=0)\\n    {\\n        for(int i=0;i<50;i++)\\n        {\\n            n=0.5*(n+x/n);\\n        }\\n        return n;\\n    }\\n    else \\n    return 0;\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3097751,
                "title": "newton-raphson-method-93-beats",
                "content": "\\n# Code\\n```\\nfunction mySqrt(x: number): number {\\n    let result = x;\\n    let precision = 0.00001;\\n    while (Math.abs(x - result * result) > precision) {\\n        result = (result + x / result) / 2\\n    }\\n    return Math.floor(result)\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Math"
                ],
                "code": "```\\nfunction mySqrt(x: number): number {\\n    let result = x;\\n    let precision = 0.00001;\\n    while (Math.abs(x - result * result) > precision) {\\n        result = (result + x / result) / 2\\n    }\\n    return Math.floor(result)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2914629,
                "title": "binary-search-simple-sol-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbinary search needed\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int mySqrt(int x) {\\n         if(x==0){\\n          return 0;\\n         }\\n          int low=1,high=x,ans=0;\\n             while(low<=high){\\n             \\n             int mid=(low+high)/2;\\n             \\n             if(mid<=x/mid){\\n                 ans=mid;\\n                 low=mid+1;\\n                }\\n             else\\n             high=mid-1; \\n            }\\n        return ans;\\n    }\\n}\\n \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mySqrt(int x) {\\n         if(x==0){\\n          return 0;\\n         }\\n          int low=1,high=x,ans=0;\\n             while(low<=high){\\n             \\n             int mid=(low+high)/2;\\n             \\n             if(mid<=x/mid){\\n                 ans=mid;\\n                 low=mid+1;\\n                }\\n             else\\n             high=mid-1; \\n            }\\n        return ans;\\n    }\\n}\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2866992,
                "title": "rust-solution-without-overflow-checks-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use a binary search algorithm that checks perfect squares and comparing them to $x$. For this we need to define a lower and upper bound, which would sensibly be at least $\\\\bigl[0, x\\\\bigr]$. However, we can do a little better and get a way smaller search interval.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nWe know that the square root can at most be $x / 2$ so that would be the most intuitive upper bound. However, using $x/2$ can quickly result in overflows if $x$ is too large, which is the case in some of the test cases. To solve this problem, we can define a maximum upper bound by using the maximum integer root $\\\\lfloor\\\\sqrt{2^{31}-1}\\\\rfloor = 46340$.\\n\\nTo be optimal, we then choose our upper bound as $\\\\text{upper} = \\\\min\\\\{x/2, 46340\\\\}$. We end up with a binary search on the interval $\\\\bigl[2, \\\\min\\\\{x/2, 46340\\\\}\\\\bigr]$.\\n\\n# Complexity\\n- Time complexity: $$O(\\\\log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::cmp::Ordering;\\n\\nimpl Solution {\\n    pub fn my_sqrt(x: i32) -> i32 {\\n        if x == 0 { // non-negative => 0 is allowed\\n            return 0;\\n        }\\n\\n        let mut lower = 2;\\n        let mut higher = 46340.min(x / 2); // max possible root sqrt(i32::MAX)\\n\\n        // Boundary conditions for optimization\\n\\n        if x <= 3 {\\n            return 1;\\n        }\\n\\n        if x >= higher * higher {\\n            return higher;\\n        }\\n\\n        // Binary search the correct perfect square\\n\\n        while higher - lower > 1 {\\n            let mid = (higher + lower) / 2;\\n            let pow = mid * mid;\\n            match pow.cmp(&x) {\\n                Ordering::Less => {\\n                    lower = mid;\\n                }\\n                Ordering::Greater => {\\n                    higher = mid;\\n                }\\n                _ => {\\n                    return mid;\\n                }\\n            }\\n        }\\n\\n        // In the edge case that the number is between 2 values,\\n        // we take the lower which is equivalent to taking the floored mean\\n        lower\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nuse std::cmp::Ordering;\\n\\nimpl Solution {\\n    pub fn my_sqrt(x: i32) -> i32 {\\n        if x == 0 { // non-negative => 0 is allowed\\n            return 0;\\n        }\\n\\n        let mut lower = 2;\\n        let mut higher = 46340.min(x / 2); // max possible root sqrt(i32::MAX)\\n\\n        // Boundary conditions for optimization\\n\\n        if x <= 3 {\\n            return 1;\\n        }\\n\\n        if x >= higher * higher {\\n            return higher;\\n        }\\n\\n        // Binary search the correct perfect square\\n\\n        while higher - lower > 1 {\\n            let mid = (higher + lower) / 2;\\n            let pow = mid * mid;\\n            match pow.cmp(&x) {\\n                Ordering::Less => {\\n                    lower = mid;\\n                }\\n                Ordering::Greater => {\\n                    higher = mid;\\n                }\\n                _ => {\\n                    return mid;\\n                }\\n            }\\n        }\\n\\n        // In the edge case that the number is between 2 values,\\n        // we take the lower which is equivalent to taking the floored mean\\n        lower\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2667045,
                "title": "c-newton-s-method",
                "content": "```cpp\\n// Given a non-negative integer, returns the square root of x.\\n// The decimal digits are truncated in the result.\\nint mySqrt(int x) {\\n  double t = x;  // start with x\\n  // update until the error is acceptable\\n  // the diff is between t * t and x rather than t_k and t_k+1 which can be\\n  // really small 1e-2\\n  while (t * t - x >= 1) t = 0.5 * (t + x / t);\\n  return t;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// Given a non-negative integer, returns the square root of x.\\n// The decimal digits are truncated in the result.\\nint mySqrt(int x) {\\n  double t = x;  // start with x\\n  // update until the error is acceptable\\n  // the diff is between t * t and x rather than t_k and t_k+1 which can be\\n  // really small 1e-2\\n  while (t * t - x >= 1) t = 0.5 * (t + x / t);\\n  return t;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2383861,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        long answer = 0;\\n        while (answer * answer <= x) {\\n            answer += 1;\\n        }\\n        return (int)answer - 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        long answer = 0;\\n        while (answer * answer <= x) {\\n            answer += 1;\\n        }\\n        return (int)answer - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205898,
                "title": "c-easy-explained-binary-search",
                "content": "**Idea :** We will use Binary Search in the range [1, X/2]\\n* Upper Bound will be X/2 as for any number X, its Square root is always less than x/2. \\n\\nUpvote the solution if you find it useful :)\\n\\n```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        if(x < 2) return x;\\n        long long l = 1, r = x/2;\\n        \\n        while(l<r){\\n            long long mid = (l+r)/2;\\n            if(mid*mid == x) return mid;\\n            else if(mid*mid > x) r=mid-1;\\n            else l = mid+1;\\n        }\\n        return (l*l <= x) ? l : l-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        if(x < 2) return x;\\n        long long l = 1, r = x/2;\\n        \\n        while(l<r){\\n            long long mid = (l+r)/2;\\n            if(mid*mid == x) return mid;\\n            else if(mid*mid > x) r=mid-1;\\n            else l = mid+1;\\n        }\\n        return (l*l <= x) ? l : l-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2160206,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        index = 1\\n        while index*index <= x:\\n            index += 1\\n        return index-1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        index = 1\\n        while index*index <= x:\\n            index += 1\\n        return index-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2117654,
                "title": "square-root-using-binary-search-efficient-o-logn",
                "content": "class Solution {\\npublic:\\n    int mySqrt(int x) {\\n        int low =  0;\\n        int high = x;\\n        int ans = 1;\\n        while(low<=high){\\n            long long mid =  low + (high- low)/2;\\n            if(mid*mid <= x){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\npls upvote if useful",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int mySqrt(int x) {\\n        int low =  0;\\n        int high = x;\\n        int ans = 1;\\n        while(low<=high){\\n            long long mid =  low + (high- low)/2;\\n            if(mid*mid <= x){\\n                ans = mid;\\n                low = mid+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1925796,
                "title": "super-easy-solution-based-on-primary-school-maths",
                "content": "Since we only need to know integer part of the result we can use Repeated Subtraction Method which is normally used for perfect squares and assume that since sqrt() is an ascending funciton result will be correct till next perfect square\\n\\n```\\nclass Solution(object):\\n    def mySqrt(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: int\\n        \"\"\"\\n        i = 1\\n        j = 0\\n        while x - i >= 0:\\n            x = x - i\\n            i += 2\\n            j += 1\\n            \\n        return j\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def mySqrt(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: int\\n        \"\"\"\\n        i = 1\\n        j = 0\\n        while x - i >= 0:\\n            x = x - i\\n            i += 2\\n            j += 1\\n            \\n        return j\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867232,
                "title": "4-approaches-brute-force-exponent-binary-search-and-the-newton-s-method",
                "content": "[Leetcode](https://leetcode.com/) [69. Sqrt(x)](https://leetcode.com/problems/sqrtx).\\n\\n***By Frank Luo***\\n\\nHere shows $4$ approaches for finding the square root of a number: Brute Force, Exponent, **Binary Search** and the **Newton\\'s Iteration Method**.\\n\\nGiven an integer $N$ and a tolerance level $L$, the task is to find the square root of that number.\\n\\n# Brute Force\\n\\nThe Brute Force way is very easy, just enumerate a value from $0$ to $x$, check the product $i^2$ and target, return the answer.\\n\\n```java\\n    public static int mySqrt(int x) {\\n        if (x == 0 || x == 1) {\\n            return x;\\n        }\\n\\n        for (int i = 0; i < x; i++) {\\n            long sum = i * i;\\n            long bigger = (long) (i + 1) * (i + 1);\\n            if (sum == x) {\\n                return i;\\n            } else if (sum < x && bigger > x) {\\n                return i;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(1)$.\\n\\n# Exponent \\n\\nNoted that: \\n\\n$$\\n\\\\sqrt{x} = x^{1/2} = (e ^ {\\\\ln x})^{1/2} = e^{\\\\frac{1}{2} \\\\ln x}\\n$$\\n\\nSo we can use the exponent $\\\\exp$ and logarithm $\\\\ln$ to calculate the square root of the number $\\\\sqrt{x}$. \\n\\nIt\\'s really a fast and simple way!\\n\\nNote: Since the computer can\\'t store the exact value of the float number, and the parameters and return values of the exponential function and logarithmic function are float numbers, so the result may be wrong. \\n\\nFor example, when $x = 2147395600$, the result of $e^{\\\\frac{1}{2} \\\\ln x}$ is $10^{-11}$ from the correct value of $46340$, so when taking the integer part of the result, you will get the wrong result of $46339$.\\n\\nSo after getting the integer part $\\\\textit{ans}$ of the result, we should find out which of $\\\\textit{ans}$ and $\\\\textit{ans} + 1$ is the real answer.\\n\\n```java\\n    // Exp O(1) O(1)\\n    public static int mySqrt_exp(int x) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n        int ans = (int) Math.exp(0.5 * Math.log(x));\\n        return (long) (ans + 1) * (ans + 1) <= x ? ans + 1 : ans;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(1)$\\n- **Space Complexity**: $O(1)$.\\n\\n# Binary Search\\n\\nWe can use Binary Search to solve this problem.\\n\\nLet the square root of $x$ is $k$, $k^2 \\\\leq x$. The lower bound is $0$, and the upper bound is $x$. In each step, we need to compare the middle element $mid^2 \\\\leq x$ or $mid^2 > x$, adjust the range of the upper and lower bounds. \\n\\nSince all our operations are integer operations, there is no error, so after getting the final answer $\\\\textit{ans}$, there is no need to try $\\\\textit{ans} + 1$ again.\\n\\n```java\\n    public static int mySqrt_bs_opt(int x) {\\n        if (x <= 1) {\\n            return x;\\n        }\\n\\n        int left = 1;\\n        int right = x / 2;\\n        while (left < right) {\\n            int mid = left + (right - left + 1) / 2;\\n            if (mid > x / mid) {\\n                right = mid - 1;\\n            } else {\\n                left = mid;\\n            }\\n        }\\n\\n        return left;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(\\\\log x)$\\n- **Space Complexity**: $O(1)$.\\n\\n# Newton\\'s Method\\n\\nThe **Newton\\'s Method** is:\\n\\nLet $N$ be any number then the square root of $N$ can be given by the formula:\\n\\n$$\\nroot = 0.5 \\\\times (X + (N / X))\\n$$\\n\\nwhere $X$ is any guess which can be assumed to be $N$ or $1$. \\n\\n1. In the above formula, $X$ is any assumed square root of $N$ and root is the correct square root of $N$.\\n2. **Tolerance limit** is the maximum difference between $X$ and root allowed.\\n\\nBut how to understand this method?\\n\\nIf we want to find the **square root** of the integer $N$. Obviously, the square root of $N$ is the function $y = f(x) = x^2 - N$ of zero.\\n\\n![Newton Iteration Method](https://assets.leetcode.com/users/images/fa60c623-19d9-4c11-9265-6caf7d713124_1647778616.7749531.png)\\n\\nWe take any $x_n$ as an initial value, at each iteration of the step. We find the point $(x_n, f(x_n))$ on the image of the function, make a slope through this point, the derivative of this point $f\\'(x_n)$, the intersection with the horizontal axis is denoted as $x_{n+1}$ compared to $x_n$. It\\'s closer to zero. \\n\\nThe equation of the straight line is:\\n\\n$$\\n2 \\\\times x_n = (x_n^2 - N) / (x_n - x)\\n$$\\n\\nThe intersection with the horizontal axis is the equation:\\n\\n$$\\n2 \\\\times x_n \\\\times x - (x_n^2 + N) = 0\\n$$\\n\\nwhich is the new iteration result $x_{n+1}$:\\n\\n$$\\nx_{n+1} = 0.5 \\\\times (x_n + N / x_n)\\n$$\\n\\nAfter iterations, the value of the true zero point $sqrt(N)$ is close enough to be an answer.\\n\\nThere comes two questions:\\n1. Which initial value do we assign?\\n2. When does the iteration end?\\n\\n### Initial value\\n\\nAs mentioned **rule 1**, we assign $X$ to the $N$ itself because we want to find the  positive $sqrt(N)$ and $N$ is surely larger than $sqrt(N)$.\\n\\n### Ending iteration \\n\\nAfter each iteration, the answer is closer to the zero point. So when the intersection obtained from two adjacent iterations is very close, we can conclude that the result at this time is enough for us to get the answer. \\n\\nAs mentioned **rule 2**, if the calculated root comes inside the tolerance allowed then break out of the loop. \\n\\nIn general, it can be judged whether the difference between the results of two adjacent iterations is less than a very small non-negative number.\\n\\n```java\\n    public static int mySqrt_newton(int x) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        double N = x;\\n        double x0 = x;\\n        while (true) {\\n            double xi = 0.5 * (x0 + N / x0);\\n            if (Math.abs(x0 - xi) < 1e-7) {\\n                break;\\n            }\\n            x0 = xi;\\n        }\\n\\n        return (int) x0;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(\\\\log x)$\\n- **Space Complexity**: $O(1)$.\\n\\n--------------------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Binary Search"
                ],
                "code": "```java\\n    public static int mySqrt(int x) {\\n        if (x == 0 || x == 1) {\\n            return x;\\n        }\\n\\n        for (int i = 0; i < x; i++) {\\n            long sum = i * i;\\n            long bigger = (long) (i + 1) * (i + 1);\\n            if (sum == x) {\\n                return i;\\n            } else if (sum < x && bigger > x) {\\n                return i;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n```\n```java\\n    // Exp O(1) O(1)\\n    public static int mySqrt_exp(int x) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n        int ans = (int) Math.exp(0.5 * Math.log(x));\\n        return (long) (ans + 1) * (ans + 1) <= x ? ans + 1 : ans;\\n    }\\n```\n```java\\n    public static int mySqrt_bs_opt(int x) {\\n        if (x <= 1) {\\n            return x;\\n        }\\n\\n        int left = 1;\\n        int right = x / 2;\\n        while (left < right) {\\n            int mid = left + (right - left + 1) / 2;\\n            if (mid > x / mid) {\\n                right = mid - 1;\\n            } else {\\n                left = mid;\\n            }\\n        }\\n\\n        return left;\\n    }\\n```\n```java\\n    public static int mySqrt_newton(int x) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        double N = x;\\n        double x0 = x;\\n        while (true) {\\n            double xi = 0.5 * (x0 + N / x0);\\n            if (Math.abs(x0 - xi) < 1e-7) {\\n                break;\\n            }\\n            x0 = xi;\\n        }\\n\\n        return (int) x0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1731478,
                "title": "java-binary-search-solution",
                "content": "```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        /*\\n        * We will be using binary search approach in this solution\\n        * For example, if we have to find the square root of number 38\\n        * the sqrt of number 38 will be lying somewhere between 0-38 only\\n        * and this is in sorted form so we simply keep applying the binary search\\n        * and keep storing the closest possible if acurate result is not available\\n        * for that number\\n        */\\n        if(x==1) {\\n            return 1;\\n        }\\n        int low=0, high=x-1, ans=0;\\n        while(low<=high) {\\n            long mid = low + (high-low)/2;\\n            if(mid*mid == x) {\\n                return (int)mid;\\n            }\\n            else if(mid*mid < x) {\\n                ans = (int)mid;\\n                low = (int)mid+1;\\n            }\\n            else {\\n                high = (int)mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        /*\\n        * We will be using binary search approach in this solution\\n        * For example, if we have to find the square root of number 38\\n        * the sqrt of number 38 will be lying somewhere between 0-38 only\\n        * and this is in sorted form so we simply keep applying the binary search\\n        * and keep storing the closest possible if acurate result is not available\\n        * for that number\\n        */\\n        if(x==1) {\\n            return 1;\\n        }\\n        int low=0, high=x-1, ans=0;\\n        while(low<=high) {\\n            long mid = low + (high-low)/2;\\n            if(mid*mid == x) {\\n                return (int)mid;\\n            }\\n            else if(mid*mid < x) {\\n                ans = (int)mid;\\n                low = (int)mid+1;\\n            }\\n            else {\\n                high = (int)mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725673,
                "title": "java-why-binary-search-explanation",
                "content": "##  Why Binary Search ?\\n    \\n    As we know realtion between x and x*x increase monotonically\\n\\t(i.e always increasing in nature) so the intution is as follows.\\n    \\n    The square root of number would lie between 0<= (Square Root)< x \\n\\t(where x is number itself) so we can apply BS where start =0 and end =x\\n    calculate mid and if(mid*mid == x) then mid is ans and if(mid*mid < x)\\n\\tthen it is sure that all number\\'s square before mid would be smaller than x \\n\\t, Hence we would search in right hand side of mid i.e start = mid+1.\\n    Notice , But mid could be posible ans too ( For Example condider x = 8) so \\n\\tstore mid in ans variable\\n    \\n    In case when mid*mid > x then we would search in left hand side of mid by doing this \\n\\t: end = mid-1;\\n\\t\\n\\t```\\n\\t\\n    public int mySqrt(int x) {\\n        if(x == 0 )\\n            return 0;\\n        if(x == 1 )\\n            return 1;\\n        int ans = BinarySearch(x);\\n        return ans;\\n    }\\n    public int BinarySearch(int x)\\n    {\\n        long start = 0;\\n        long end = x;\\n        long ans =0;\\n        \\n        while(start <= end)\\n        {\\n            long mid = start +(end-start)/2;\\n            \\n            if(mid == x/mid)\\n            {\\n                return (int)mid;\\n            }\\n            else if(mid < x/mid)\\n            {\\n                ans = mid;\\n                start =mid+1;\\n            }\\n            else{\\n                end = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n        \\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "##  Why Binary Search ?\\n    \\n    As we know realtion between x and x*x increase monotonically\\n\\t(i.e always increasing in nature) so the intution is as follows.\\n    \\n    The square root of number would lie between 0<= (Square Root)< x \\n\\t(where x is number itself) so we can apply BS where start =0 and end =x\\n    calculate mid and if(mid*mid == x) then mid is ans and if(mid*mid < x)\\n\\tthen it is sure that all number\\'s square before mid would be smaller than x \\n\\t, Hence we would search in right hand side of mid i.e start = mid+1.\\n    Notice , But mid could be posible ans too ( For Example condider x = 8) so \\n\\tstore mid in ans variable\\n    \\n    In case when mid*mid > x then we would search in left hand side of mid by doing this \\n\\t: end = mid-1;\\n\\t\\n\\t```\\n\\t\\n    public int mySqrt(int x) {\\n        if(x == 0 )\\n            return 0;\\n        if(x == 1 )\\n            return 1;\\n        int ans = BinarySearch(x);\\n        return ans;\\n    }\\n    public int BinarySearch(int x)\\n    {\\n        long start = 0;\\n        long end = x;\\n        long ans =0;\\n        \\n        while(start <= end)\\n        {\\n            long mid = start +(end-start)/2;\\n            \\n            if(mid == x/mid)\\n            {\\n                return (int)mid;\\n            }\\n            else if(mid < x/mid)\\n            {\\n                ans = mid;\\n                start =mid+1;\\n            }\\n            else{\\n                end = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1668392,
                "title": "python-easy-o-log-number-solution",
                "content": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x <= 1:\\n            return x\\n        \\n        l, r = 0, x\\n        ans = 0\\n        while l < r:\\n            mid = (l+r)//2\\n            if mid*mid <= x:\\n                ans = mid\\n                l = mid + 1\\n            else:\\n                r = mid\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x <= 1:\\n            return x\\n        \\n        l, r = 0, x\\n        ans = 0\\n        while l < r:\\n            mid = (l+r)//2\\n            if mid*mid <= x:\\n                ans = mid\\n                l = mid + 1\\n            else:\\n                r = mid\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537772,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        if(x <= 1)\\n            return x;\\n\\n        int lo = 1, hi = x / 2, ans;\\n\\n        while(lo <= hi) {\\n            int mid = (lo + hi) >> 1;\\n\\n            if(mid <= x / mid)\\n                ans = mid, lo = mid + 1;\\n            else\\n                hi = mid - 1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        if(x <= 1)\\n            return x;\\n\\n        int lo = 1, hi = x / 2, ans;\\n\\n        while(lo <= hi) {\\n            int mid = (lo + hi) >> 1;\\n\\n            if(mid <= x / mid)\\n                ans = mid, lo = mid + 1;\\n            else\\n                hi = mid - 1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490446,
                "title": "99-26-faster-using-binary-search-sqrt-x",
                "content": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        low=0\\n        high=x\\n        while(low<=high):\\n            mid=low+(high-low)//2\\n            if (mid*mid<=x and (mid+1)*(mid+1)>x):\\n                return mid\\n            elif mid*mid<x:\\n                low=mid+1\\n            else:\\n                high=mid-1\\n        return low\\n```\\nFor any doubts or suggestion : comment\\nUpvote if you liked the solution",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        low=0\\n        high=x\\n        while(low<=high):\\n            mid=low+(high-low)//2\\n            if (mid*mid<=x and (mid+1)*(mid+1)>x):\\n                return mid\\n            elif mid*mid<x:\\n                low=mid+1\\n            else:\\n                high=mid-1\\n        return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358659,
                "title": "cpp-easy-soltuion-two-approaches",
                "content": "```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n//        basically we want value of y such that y*y<=x where y is max value\\n//         Method 1 (Linear Seacrh)\\n//         TC=o(sqrt(n));\\n        \\n//         long long y=1;\\n        \\n//         while(y*y<=x){\\n//             y++;\\n//         }\\n        \\n//         return y-1;\\n        \\n//         Method 2 (Binary Search)\\n        \\n        long long  low=0;\\n        long long high=INT_MAX,ans=0;\\n        \\n        while(low<=high){\\n            \\n        long long mid=low+(high-low)/2;\\n            if(mid*mid<=x){\\n                ans=mid; \\n//                 one of the possible ans so storing it\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        \\n    }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int mySqrt(int x) {\\n//        basically we want value of y such that y*y<=x where y is max value\\n//         Method 1 (Linear Seacrh)\\n//         TC=o(sqrt(n));\\n        \\n//         long long y=1;\\n        \\n//         while(y*y<=x){\\n//             y++;\\n//         }",
                "codeTag": "Java"
            },
            {
                "id": 1197298,
                "title": "weeb-does-python-2-methods",
                "content": "\\n\\tfrom math import sqrt, floor\\n\\tclass Solution:\\n\\t\\tdef mySqrt(self, x: int) -> int:\\n\\t\\t\\tif x == 0: return 0\\n\\t\\t\\tif x == 1: return 1\\n\\t\\t\\tlow, high = 0, x\\n\\n\\t\\t\\twhile low<high:\\n\\t\\t\\t\\tmid = low + (high-low)//2\\n\\n\\t\\t\\t\\tif mid ** 2 <= x:\\n\\t\\t\\t\\t\\tlow = mid + 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\thigh = mid\\n\\n\\t\\t\\treturn low-1\\n\\t\\t\\t# method2, which is faster and better bruh\\n\\t\\t\\t\"\"\"\\n\\t\\t\\treturn floor(sqrt(x))\\n\\t\\t\\t\"\"\"\\n\\nAight coders, its time for some anime recommendations\\nThis time, try checking out **Ansatsu Ky\\u014Dshitsu(Assassination Classroom)**\\n\\n# Episodes: 47 + 1 OVA \\n# Genres: Action fiction, Comedy, Science Fiction\\n\\nWanna watch an overpowered octopus? Then check this out",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "\\n\\tfrom math import sqrt, floor\\n\\tclass Solution:\\n\\t\\tdef mySqrt(self, x: int) -> int:\\n\\t\\t\\tif x == 0: return 0\\n\\t\\t\\tif x == 1: return 1\\n\\t\\t\\tlow, high = 0, x\\n\\n\\t\\t\\twhile low<high:\\n\\t\\t\\t\\tmid = low + (high-low)//2\\n\\n\\t\\t\\t\\tif mid ** 2 <= x:\\n\\t\\t\\t\\t\\tlow = mid + 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\thigh = mid\\n\\n\\t\\t\\treturn low-1\\n\\t\\t\\t# method2, which is faster and better bruh\\n\\t\\t\\t\"\"\"\\n\\t\\t\\treturn floor(sqrt(x))\\n\\t\\t\\t\"\"\"\\n\\nAight coders, its time for some anime recommendations\\nThis time, try checking out **Ansatsu Ky\\u014Dshitsu(Assassination Classroom)**\\n\\n# Episodes: 47 + 1 OVA \\n# Genres: Action fiction, Comedy, Science Fiction\\n\\nWanna watch an overpowered octopus? Then check this out",
                "codeTag": "Java"
            },
            {
                "id": 1133794,
                "title": "binary-search-solution-with-explanation",
                "content": "You can use different methods to solve it;\\n1) sqrt(x) :P\\n2) linear search\\n3) binary search\\n4) any other searching algorithm\\n\\n```\\n// space O(1)\\n// time O(log(n))\\n\\nclass Solution \\n{\\npublic:\\n    int mySqrt(int x) \\n    {\\n        int l=1;    // dont use 0, it will cause divide by 0 error\\n        int h=x;    // this will be the maximum possible value\\n        int m;      // calculate middle    \\n        \\n        while ( l<=h ) {            // binary search\\n            m = l + (h-l)/2;        // use this to avoid integer overflow\\n            if ( m == x/m ) {       // instead of m*m == x, use this to avoid overflow\\n                return m;\\n            }\\n            else if ( m > x/m ) {   // if the m*m is bigger than x, then move to smaller numbers\\n                h = m-1;\\n            }\\n            else {                  // move to bigger numbers\\n                l = m+1;\\n            }\\n        }\\n        \\n        return l-1;                 // display low-1\\n    }\\n};\\n```\\n\\n**If this answer was helpful, please upvote it!**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n// space O(1)\\n// time O(log(n))\\n\\nclass Solution \\n{\\npublic:\\n    int mySqrt(int x) \\n    {\\n        int l=1;    // dont use 0, it will cause divide by 0 error\\n        int h=x;    // this will be the maximum possible value\\n        int m;      // calculate middle    \\n        \\n        while ( l<=h ) {            // binary search\\n            m = l + (h-l)/2;        // use this to avoid integer overflow\\n            if ( m == x/m ) {       // instead of m*m == x, use this to avoid overflow\\n                return m;\\n            }\\n            else if ( m > x/m ) {   // if the m*m is bigger than x, then move to smaller numbers\\n                h = m-1;\\n            }\\n            else {                  // move to bigger numbers\\n                l = m+1;\\n            }\\n        }\\n        \\n        return l-1;                 // display low-1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1041705,
                "title": "c-solution-100-faster-two-approaches",
                "content": "Naive solution by simple checking\\nTime complexity = O(N) \\n```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        if(x==0) return 0;\\n        if(x<4) return 1;\\n        int ans;\\n        for(long long int i=2; i<=x/2+1; i++) {\\n            if(i*i==x || i+1<=x/2+1 && (i*i<x && (i+1)*(i+1)>x)) {\\n                ans= i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nEfficient soution using Binary search\\nTime complexity= O(logN)\\n```\\nclass Solution {\\npublic:\\n    long long binarySearch(int x) {\\n        long long  s=2, e=x/2+1, mid;        \\n        while(s<=e) {\\n            mid= s+(e-s)/2;\\n            if(mid*mid==x || mid*mid<x && (mid+1)*(mid+1)>x) break;\\n            else if(mid*mid>x) e=mid-1;\\n            else s=mid+1;\\n        }\\n        return mid;\\n    }\\n    \\n    int mySqrt(int x) {\\n        if(x==0) return 0;\\n        if(x<4) return 1;        \\n        return binarySearch(x);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        if(x==0) return 0;\\n        if(x<4) return 1;\\n        int ans;\\n        for(long long int i=2; i<=x/2+1; i++) {\\n            if(i*i==x || i+1<=x/2+1 && (i*i<x && (i+1)*(i+1)>x)) {\\n                ans= i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941615,
                "title": "python-a-nice-and-short-binary-search",
                "content": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        l = 1\\n        r = x\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if mid * mid <= x:\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n                \\n        return l - 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        l = 1\\n        r = x\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if mid * mid <= x:\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n                \\n        return l - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208955,
                "title": "solution-in-swift",
                "content": "```\\nfunc mySqrt(_ x: Int) -> Int {\\n        var i = 0\\n        while i*i <= x {\\n            i += 1\\n        }\\n        \\n        return i-1\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfunc mySqrt(_ x: Int) -> Int {\\n        var i = 0\\n        while i*i <= x {\\n            i += 1\\n        }\\n        \\n        return i-1\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25053,
                "title": "here-is-my-c-solution-by-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        \\n        if(x == 1)\\n            return 1;\\n        int start = 1, end = x/2; \\n        while(start <= end){\\n            int mid = (start+end)/2;\\n            if(mid == x/mid)\\n                return mid;\\n            else if(mid < x/mid)\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        \\n        return end;\\n        //0 1 2 3 4 5   3\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        \\n        if(x == 1)\\n            return 1;\\n        int start = 1, end = x/2; \\n        while(start <= end){\\n            int mid = (start+end)/2;\\n            if(mid == x/mid)\\n                return mid;\\n            else if(mid < x/mid)\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        \\n        return end;\\n        //0 1 2 3 4 5   3\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25173,
                "title": "9-line-python-solution-binary-search",
                "content": "    def mySqrt(self, x):\\n        left, right = 0, x\\n        while left <= right:\\n            mid = (left + right) / 2\\n            if mid ** 2 <= x < (mid + 1) ** 2:\\n                return mid\\n            if mid ** 2 > x:\\n                right = mid - 1\\n            else:\\n                left = mid + 1",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "    def mySqrt(self, x):\\n        left, right = 0, x\\n        while left <= right:\\n            mid = (left + right) / 2\\n            if mid ** 2 <= x < (mid + 1) ** 2:\\n                return mid\\n            if mid ** 2 > x:\\n                right = mid - 1\\n            else:\\n                left = mid + 1",
                "codeTag": "Python3"
            },
            {
                "id": 25256,
                "title": "my-c-5ms-solution-using-something-like-binary-search",
                "content": "    int mySqrt(int x) {\\n        if (x<=1) return x;\\n        long long lb=1, rb=x, md;\\n        while(rb-lb>1)\\n        {\\n            md = (rb+lb)/2;\\n            if (md*md==x)\\n                return md;\\n            if (md*md>x)\\n                rb=md;\\n            else\\n                lb=md;\\n        }\\n        if (rb*rb==x)\\n            return rb;\\n        return lb;\\n    }",
                "solutionTags": [],
                "code": "    int mySqrt(int x) {\\n        if (x<=1) return x;\\n        long long lb=1, rb=x, md;\\n        while(rb-lb>1)\\n        {\\n            md = (rb+lb)/2;\\n            if (md*md==x)\\n                return md;\\n            if (md*md>x)\\n                rb=md;\\n            else\\n                lb=md;\\n        }\\n        if (rb*rb==x)\\n            return rb;\\n        return lb;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 25275,
                "title": "how-to-deal-with-long-overflow",
                "content": "I've been struggling with this for quite a while. I want to solve it using a binary search, and my code is quite straightforward, and I think, correct:\\n\\n              if (x < 0) {\\n    \\t\\t\\treturn -1;\\n              }\\n    \\t\\tif (x == 0 || x == 1) {\\n    \\t\\t\\treturn x;\\n    \\t\\t}\\n    \\t    int start = 1;\\n    \\t    int end = x;\\n    \\t    while (start<=end) {\\n    \\t        int mid = start+ (end-start)/2;\\n    \\t        if (mid*mid<=x && (mid+1)*(mid+1)>x) return mid;\\n    \\t        if(mid*mid>x) {\\n    \\t            end = mid-1;\\n    \\t        } else {\\n    \\t            start = mid+1;\\n    \\t        }\\n    \\t    }\\n    \\t    return 0;\\n        \\nOf course, it fails for 2147483647 case, because `mid*mid` causes integer overflow. I've tried dealing with `long` instead:\\n\\n    long tmp = mid*mid;\\n    long tmp1 = (mid+1)*(mid+1)\\n    if (tmp<=x && tmp1>x) return mid;\\n\\nHowever, I get time limit exceeded, because even that overflows.\\nHow to deal with situations like this? What am I missing?",
                "solutionTags": [],
                "code": "I've been struggling with this for quite a while. I want to solve it using a binary search, and my code is quite straightforward, and I think, correct:\\n\\n              if (x < 0) {\\n    \\t\\t\\treturn -1;\\n              }\\n    \\t\\tif (x == 0 || x == 1) {\\n    \\t\\t\\treturn x;\\n    \\t\\t}\\n    \\t    int start = 1;\\n    \\t    int end = x;\\n    \\t    while (start<=end) {\\n    \\t        int mid = start+ (end-start)/2;\\n    \\t        if (mid*mid<=x && (mid+1)*(mid+1)>x) return mid;\\n    \\t        if(mid*mid>x) {\\n    \\t            end = mid-1;\\n    \\t        } else {\\n    \\t            start = mid+1;\\n    \\t        }\\n    \\t    }\\n    \\t    return 0;\\n        \\nOf course, it fails for 2147483647 case, because `mid*mid` causes integer overflow. I've tried dealing with `long` instead:\\n\\n    long tmp = mid*mid;\\n    long tmp1 = (mid+1)*(mid+1)\\n    if (tmp<=x && tmp1>x) return mid;\\n\\nHowever, I get time limit exceeded, because even that overflows.\\nHow to deal with situations like this? What am I missing?",
                "codeTag": "Unknown"
            },
            {
                "id": 3773220,
                "title": "c-hinglish-easy-explanation-binary-search-interview-prep",
                "content": "# Intuition & Approach\\n- Explained in the code\\n\\n# Code\\n```\\nclass Solution\\n{\\n    // LOGIC\\n   \\t// 1. x diya hain uska sqaure root nikalna hain, if decimal then round it nearest integer.\\n   \\t// 2. isme directly nahin nikalna so we will use Binary Search.\\n\\n   \\t// WHY BINARY SEARCH?\\n   \\t// 3. jo bhi no ans hoga wo[1,x] ke beech ka hoga.\\n   \\t// 4. 1 to x sab sorted hain.\\n   \\t// 5. So we can check by taking mid . Id mid^2 is either<=> x so we can change low and high.\\n    // 6. Agar mid^2==x ho gaya the ans = mid else this is a decimal case so return high.\\n    // 7. Returning high because while iterations high will reach very close to the rounded integer. \\n   \\t// 8. Here Exponential Function is nothing special just for comparison.\\n\\n   \\t// ALTERNATIVE\\n   \\t// Alternative was Linear Search but usme time jyada lagta\\n   \\t// Usme bhi 1 to x ham loop chalate aur i ko sqare karke dekhte ki kahin wo eqaul hain ya bada hain x se.\\n   \\t// In that we can use the concept of Power Exponentiation.\\n\\n    //TC - O(log(x)) Binary Search\\n    //SC - O(1)\\n    public:\\n        int Exponential(int m, double mid)\\n        {\\n            long long ans = 1;\\n            for (int i = 1; i <= 2; i++)\\n            {\\n                ans = ans * mid;\\n                if (ans > m)\\n                   \\t//Ans m se bada hua matlab high mid-1 hoga\\n                    return 2;\\n            }\\n            if (ans == m)\\n               \\t//Barabar mil gaya\\n                return 0;\\n            else\\n               \\t//Low mid+1 hoga\\n                return 1;\\n        }\\n    int mySqrt(int x)\\n    {\\n        long long low = 1;\\n        long long high = x;\\n        long long mid;\\n        while (low <= high)\\n        {\\n            mid = (low + high) / 2;\\n            int expoResult = Exponential(x, mid);\\t//Comparison result\\n            if (expoResult == 0)\\t//equal\\n                return mid;\\n            else if (expoResult == 1)\\t//ans < x\\n                low = mid + 1;\\n            else\\n                high = mid - 1;\\t//ans>x\\n        }\\n        return high;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $O(logx)$ Binary Search applied on numbers from 1 to x.\\n\\n- Space complexity: $O(1)$\\n\\nIf you *like* \\uD83D\\uDC4D this solution do *upvote* \\u2B06\\uFE0F and if there is any *improvement or suggestion* do mention it in the *comment* section \\uD83D\\uDE0A.\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/1b604300-df68-46aa-a267-71f38463bb89_1684820402.7869222.jpeg\" width=\\'350\\' alt=\"Upvote Image\">\\n</p>",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution\\n{\\n    // LOGIC\\n   \\t// 1. x diya hain uska sqaure root nikalna hain, if decimal then round it nearest integer.\\n   \\t// 2. isme directly nahin nikalna so we will use Binary Search.\\n\\n   \\t// WHY BINARY SEARCH?\\n   \\t// 3. jo bhi no ans hoga wo[1,x] ke beech ka hoga.\\n   \\t// 4. 1 to x sab sorted hain.\\n   \\t// 5. So we can check by taking mid . Id mid^2 is either<=> x so we can change low and high.\\n    // 6. Agar mid^2==x ho gaya the ans = mid else this is a decimal case so return high.\\n    // 7. Returning high because while iterations high will reach very close to the rounded integer. \\n   \\t// 8. Here Exponential Function is nothing special just for comparison.\\n\\n   \\t// ALTERNATIVE\\n   \\t// Alternative was Linear Search but usme time jyada lagta\\n   \\t// Usme bhi 1 to x ham loop chalate aur i ko sqare karke dekhte ki kahin wo eqaul hain ya bada hain x se.\\n   \\t// In that we can use the concept of Power Exponentiation.\\n\\n    //TC - O(log(x)) Binary Search\\n    //SC - O(1)\\n    public:\\n        int Exponential(int m, double mid)\\n        {\\n            long long ans = 1;\\n            for (int i = 1; i <= 2; i++)\\n            {\\n                ans = ans * mid;\\n                if (ans > m)\\n                   \\t//Ans m se bada hua matlab high mid-1 hoga\\n                    return 2;\\n            }\\n            if (ans == m)\\n               \\t//Barabar mil gaya\\n                return 0;\\n            else\\n               \\t//Low mid+1 hoga\\n                return 1;\\n        }\\n    int mySqrt(int x)\\n    {\\n        long long low = 1;\\n        long long high = x;\\n        long long mid;\\n        while (low <= high)\\n        {\\n            mid = (low + high) / 2;\\n            int expoResult = Exponential(x, mid);\\t//Comparison result\\n            if (expoResult == 0)\\t//equal\\n                return mid;\\n            else if (expoResult == 1)\\t//ans < x\\n                low = mid + 1;\\n            else\\n                high = mid - 1;\\t//ans>x\\n        }\\n        return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467166,
                "title": "python-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x==0:\\n            return 0\\n        if x==1:\\n            return 1\\n        for i in range(1,x+1):\\n            if i*i > x:\\n                return i-1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x==0:\\n            return 0\\n        if x==1:\\n            return 1\\n        for i in range(1,x+1):\\n            if i*i > x:\\n                return i-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462789,
                "title": "java-code-beats-100-runtime",
                "content": "By using Binary Search Approach\\nT.C: O(logn)\\n\\n# Code\\n```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        \\n        int low = 1, high = x;\\n        if((x==0)||(x==1)){\\n            return x;\\n        }\\n\\n        while (low<=high) {\\n            int mid = (low+high)/2;\\n            if(x/mid==mid){\\n                return mid;\\n            }\\n            else if(x/mid<mid){\\n                high=mid-1;\\n            }\\n            else if(x/mid>mid){\\n                low=mid+1;\\n            }\\n            \\n        }\\n        return high;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        \\n        int low = 1, high = x;\\n        if((x==0)||(x==1)){\\n            return x;\\n        }\\n\\n        while (low<=high) {\\n            int mid = (low+high)/2;\\n            if(x/mid==mid){\\n                return mid;\\n            }\\n            else if(x/mid<mid){\\n                high=mid-1;\\n            }\\n            else if(x/mid>mid){\\n                low=mid+1;\\n            }\\n            \\n        }\\n        return high;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314231,
                "title": "python-3-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x < 2:\\n            return x;\\n        low, high = 1, x\\n        while low <= high:\\n            mid = (low + high) // 2\\n            if mid * mid == x:\\n                return mid\\n            elif mid * mid < x:\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return high\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x < 2:\\n            return x;\\n        low, high = 1, x\\n        while low <= high:\\n            mid = (low + high) // 2\\n            if mid * mid == x:\\n                return mid\\n            elif mid * mid < x:\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return high\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118551,
                "title": "php-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\n    /**\\n     * @param Integer $x\\n     * @return Integer\\n     */\\n    function mySqrt($x) {\\n        $result = 0;\\n        $start = 0;\\n        $end = $x;\\n\\n        while ($start <= $end) {\\n            $mid = (int)(($start + $end) / 2);\\n\\n            if ($mid * $mid === $x) {\\n                return $mid;\\n            } elseif ($mid * $mid < $x) {\\n                $start = $mid + 1;\\n                $result = $mid;\\n            } else {\\n                $end = $mid - 1;\\n            }\\n        }\\n\\n        return $result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    /**\\n     * @param Integer $x\\n     * @return Integer\\n     */\\n    function mySqrt($x) {\\n        $result = 0;\\n        $start = 0;\\n        $end = $x;\\n\\n        while ($start <= $end) {\\n            $mid = (int)(($start + $end) / 2);\\n\\n            if ($mid * $mid === $x) {\\n                return $mid;\\n            } elseif ($mid * $mid < $x) {\\n                $start = $mid + 1;\\n                $result = $mid;\\n            } else {\\n                $end = $mid - 1;\\n            }\\n        }\\n\\n        return $result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080248,
                "title": "simple-java-o-n-beginners-helpful",
                "content": "# Intuition\\nGeekster Platform\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBinary Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mySqrt(int n) {\\n        // By Binary Approach\\n        long st = 1 , end = n ,  mid = (st + end) / 2;\\n        while(st <= end) {\\n            if(mid * mid == n) {\\n                break;\\n            }else if (mid * mid > n) {\\n                end = mid - 1;\\n            }else {\\n                st = mid + 1;\\n            }\\n            mid = (st + end) / 2;\\n        }\\n        return (int)mid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mySqrt(int n) {\\n        // By Binary Approach\\n        long st = 1 , end = n ,  mid = (st + end) / 2;\\n        while(st <= end) {\\n            if(mid * mid == n) {\\n                break;\\n            }else if (mid * mid > n) {\\n                end = mid - 1;\\n            }else {\\n                st = mid + 1;\\n            }\\n            mid = (st + end) / 2;\\n        }\\n        return (int)mid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946396,
                "title": "java-easy-solution-beats-100-with-o-log-n",
                "content": "\\n# Code\\n```\\n\\n// ******Bineary searh approach*******\\nclass Solution {\\n    public int mySqrt(int x) {\\n          if(x < 2) return x;\\n         else {\\n            int start = 0;\\n            int end = x;\\n            while (start <= end) {\\n                int mid = start + (end - start) / 2;\\n                long multiply = (long) mid * mid;\\n                if (multiply > x) {\\n                    end = mid - 1;\\n                } else if (multiply < x) {\\n                    start = mid + 1;\\n                } else {\\n                    return mid;\\n                }\\n            }\\n        return end;\\n     }\\n}\\n\\n}\\n\\n// ******Brute Force*******\\n\\nApproach 1\\n// class Solution {\\n//     public int mySqrt(int x) {\\n//         int ans = 0;\\n//         for(int i =1; i<=x;i++){\\n//           if(i*i>x){\\n//           ans=i-1;\\n//           break;\\n//           }\\n//           if(i*i==x){\\n//           ans=i;\\n//           break;\\n//           }\\n//         }\\n//         return ans;\\n//     }\\n// }\\n\\nApproach 2\\n// class Solution {\\n//     public int mySqrt(int x) {\\n//         int l = 1, h = x, ans = 1;\\n//         int mid = (int)Math.ceil(x/2);\\n//         while(mid*mid>=x){\\n//              mid = (int)Math.ceil(x/2);\\n//         }\\n//        return mid;\\n//     }\\n// }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n// ******Bineary searh approach*******\\nclass Solution {\\n    public int mySqrt(int x) {\\n          if(x < 2) return x;\\n         else {\\n            int start = 0;\\n            int end = x;\\n            while (start <= end) {\\n                int mid = start + (end - start) / 2;\\n                long multiply = (long) mid * mid;\\n                if (multiply > x) {\\n                    end = mid - 1;\\n                } else if (multiply < x) {\\n                    start = mid + 1;\\n                } else {\\n                    return mid;\\n                }\\n            }\\n        return end;\\n     }\\n}\\n\\n}\\n\\n// ******Brute Force*******\\n\\nApproach 1\\n// class Solution {\\n//     public int mySqrt(int x) {\\n//         int ans = 0;\\n//         for(int i =1; i<=x;i++){\\n//           if(i*i>x){\\n//           ans=i-1;\\n//           break;\\n//           }\\n//           if(i*i==x){\\n//           ans=i;\\n//           break;\\n//           }\\n//         }\\n//         return ans;\\n//     }\\n// }\\n\\nApproach 2\\n// class Solution {\\n//     public int mySqrt(int x) {\\n//         int l = 1, h = x, ans = 1;\\n//         int mid = (int)Math.ceil(x/2);\\n//         while(mid*mid>=x){\\n//              mid = (int)Math.ceil(x/2);\\n//         }\\n//        return mid;\\n//     }\\n// }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711702,
                "title": "python-easy-solution-faster-than-93-39-using-binary-search",
                "content": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        l=0\\n        h=x\\n        m=(l+h)>>1\\n        while l<=h:\\n            if m*m==x:\\n                return m\\n            elif m*m>x:\\n                h=m-1\\n            else:\\n                l=m+1\\n            m=(l+h)>>1\\n        return m\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        l=0\\n        h=x\\n        m=(l+h)>>1\\n        while l<=h:\\n            if m*m==x:\\n                return m\\n            elif m*m>x:\\n                h=m-1\\n            else:\\n                l=m+1\\n            m=(l+h)>>1\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659529,
                "title": "faster-than-100-binary-search",
                "content": "```\\nint mySqrt(int x) {\\n        int s=0;\\n        int e=x;\\n        int ans;\\n        \\n        while(s<=e){\\n            long long mid = s+(e-s)/2;\\n            \\n            if(mid*mid == x){\\n                return mid;\\n            }\\n            else if(mid*mid < x){\\n                s = mid+1;\\n                ans = mid;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint mySqrt(int x) {\\n        int s=0;\\n        int e=x;\\n        int ans;\\n        \\n        while(s<=e){\\n            long long mid = s+(e-s)/2;\\n            \\n            if(mid*mid == x){\\n                return mid;\\n            }\\n            else if(mid*mid < x){\\n                s = mid+1;\\n                ans = mid;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2642495,
                "title": "java-easy-solution",
                "content": "my solution :\\nclass Solution {\\n    public int mySqrt(int x) {\\n        x=(int)Math.sqrt(x);\\n        int res = (int)Math.floor(x);\\n        return res;  \\n    }\\n}\\n\\nPLEASE upvote",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int mySqrt(int x) {\\n        x=(int)Math.sqrt(x);\\n        int res = (int)Math.floor(x);\\n        return res;  \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2627755,
                "title": "very-easy-c",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        for( long int i=0;i<=x/2;i++){\\n            if(i*i==x||(x>i*i&&x<(i+1)*(i+1))){\\n                return i;\\n            }\\n        }\\n        return 1;//return anything;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int mySqrt(int x) {\\n        for( long int i=0;i<=x/2;i++){\\n            if(i*i==x||(x>i*i&&x<(i+1)*(i+1))){\\n                return i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2504649,
                "title": "c-solution-100-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        long long strt = 0,end = x,ans=0;\\n        while(strt<=end){\\n             long long mid = (strt + end)/2;\\n            if(mid*mid <= x) ans=mid,strt = mid+1;\\n            else end = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        long long strt = 0,end = x,ans=0;\\n        while(strt<=end){\\n             long long mid = (strt + end)/2;\\n            if(mid*mid <= x) ans=mid,strt = mid+1;\\n            else end = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2408261,
                "title": "java-easy-to-understand-self-explanatory-with-and-without-binary-search",
                "content": "This is a self explanatory code so try to read it ;\\n\\nwithout using binary search ;\\n\\n```\\n  int i = 1;\\n        \\n //because 0 is a perfect square ;\\n        if(x == 0){\\n            return 0 ;\\n        }\\n        \\n        // we used the INT_MAX condition here because\\n        //integer has a defined value that it can store so after doubling it \\n        // we can reach past that value so we use this to just break out of loop if that situation comes;\\n        \\n        while(i<=x && i < Integer.MAX_VALUE/i ){\\n            // what we did is we checked each integer starting from\\n            //1 to x(given in the question) after doubling it if it is\\n            // equall to given x or not ;\\n        if(i*i == x){\\n            return i ;\\n            // if it is less than the given x then we increment the value of x ;\\n        }else if (i*i < x){\\n            i ++ ;\\n        }else{\\n            //otherwise we break the loop\\n            break ;\\n          }\\n        }\\n        //we returned i -1 because i will be incremented before breaking out of the loop ;\\n        return i-1 ;\\n```\\n\\nWith binary search ;\\n\\n```\\n//using binary search ;-\\n        \\n        if(x == 0){\\n            return 0 ;\\n            //as answer for 0 will be 0 ;\\n        }\\n        \\n        int start = 1 ;\\n        int end = x;\\n        //we will search our answer in pooootential answers from 1 to the number we are given ;\\n        \\n        int mid = start + (end - start)/2 ;\\n        //for middle ;\\n        \\n        int ans = 0 ;\\n        //a variable in which we will be storing our answer ;\\n        \\n        \\n        while(start<=end ){\\n            \\n             mid = start + (end - start)/2 ;\\n            \\n            if(mid < x / mid){\\n                start = mid + 1;\\n                //as if we don\\'t store our mid in the answer it will get changed before breaking out of the loop ;\\n                ans = mid ;\\n                \\n            }else if(mid > x / mid ){\\n                end = mid -1;\\n                //we did\\'t store our answer here because our potential answer is always <= the x so this middle \\n                //is obviously not our potential answer ;\\n            \\n            }else{\\n                return mid;\\n            }\\n            \\n        }\\n        \\n        return ans  ;\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\n  int i = 1;\\n        \\n //because 0 is a perfect square ;\\n        if(x == 0){\\n            return 0 ;\\n        }\\n        \\n        // we used the INT_MAX condition here because\\n        //integer has a defined value that it can store so after doubling it \\n        // we can reach past that value so we use this to just break out of loop if that situation comes;\\n        \\n        while(i<=x && i < Integer.MAX_VALUE/i ){\\n            // what we did is we checked each integer starting from\\n            //1 to x(given in the question) after doubling it if it is\\n            // equall to given x or not ;\\n        if(i*i == x){\\n            return i ;\\n            // if it is less than the given x then we increment the value of x ;\\n        }else if (i*i < x){\\n            i ++ ;\\n        }else{\\n            //otherwise we break the loop\\n            break ;\\n          }\\n        }\\n        //we returned i -1 because i will be incremented before breaking out of the loop ;\\n        return i-1 ;\\n```\n```\\n//using binary search ;-\\n        \\n        if(x == 0){\\n            return 0 ;\\n            //as answer for 0 will be 0 ;\\n        }\\n        \\n        int start = 1 ;\\n        int end = x;\\n        //we will search our answer in pooootential answers from 1 to the number we are given ;\\n        \\n        int mid = start + (end - start)/2 ;\\n        //for middle ;\\n        \\n        int ans = 0 ;\\n        //a variable in which we will be storing our answer ;\\n        \\n        \\n        while(start<=end ){\\n            \\n             mid = start + (end - start)/2 ;\\n            \\n            if(mid < x / mid){\\n                start = mid + 1;\\n                //as if we don\\'t store our mid in the answer it will get changed before breaking out of the loop ;\\n                ans = mid ;\\n                \\n            }else if(mid > x / mid ){\\n                end = mid -1;\\n                //we did\\'t store our answer here because our potential answer is always <= the x so this middle \\n                //is obviously not our potential answer ;\\n            \\n            }else{\\n                return mid;\\n            }\\n            \\n        }\\n        \\n        return ans  ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2299274,
                "title": "java-linear-search-solution-binary-search-solution",
                "content": "1. First we solve this problem using linear search, we have to find the sqrt(x)\\n\\there y^2 = x, so we need to find the value y i.e (y*y <= x)\\n ```\\n class Solution {\\n    public int mySqrt(int x) {\\n        long y=0;\\n        while(y*y<=x)\\n            y++;\\n        return (int)y-1;\\n    }\\n}\\n```\\nTime Complexity in case of linear search will be O(x).\\n\\n2. Using Binary Search\\n\\t* we search sqrt(x) in range 1 to x/2, so low=1;\\n\\t* Value of sqrt(x) will never be grater than x/2, so we will take high=x/2;\\n```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        if(x==0)\\n            return 0;\\n        long l=1, h=x/2;\\n        int output=1;\\n        while(l<=h){\\n            long mid = l+(h-l)/2;\\n            long sqrt = mid*mid;\\n            if(sqrt == x)\\n                return (int)mid;\\n            else if(sqrt<x){\\n                output=(int)mid;\\n                l=mid+1;\\n            }\\n            else\\n                h=mid-1;\\n        } \\n        return output;\\n    }\\n}\\n```\\n\\nTime Complexity using binary search would be log(x).\\nPS: If there is any improvement that we can do in the code, please do let me know in the comments below :)",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n class Solution {\\n    public int mySqrt(int x) {\\n        long y=0;\\n        while(y*y<=x)\\n            y++;\\n        return (int)y-1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int mySqrt(int x) {\\n        if(x==0)\\n            return 0;\\n        long l=1, h=x/2;\\n        int output=1;\\n        while(l<=h){\\n            long mid = l+(h-l)/2;\\n            long sqrt = mid*mid;\\n            if(sqrt == x)\\n                return (int)mid;\\n            else if(sqrt<x){\\n                output=(int)mid;\\n                l=mid+1;\\n            }\\n            else\\n                h=mid-1;\\n        } \\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570842,
                "content": [
                    {
                        "username": "onedaywillmake",
                        "content": "This is a great beginner question, however the addition of values such as `2147395600` which cause an integer overflow take away from spirit of the question which is to find the algorithm. \\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm. \\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Questions is labelled \"easy\"\\nHas dumb and frustrating edge cases to handle\\nOk, I might be dumb but it\\'s seems like I am not the only one complaining..."
                    },
                    {
                        "username": "md_isa",
                        "content": "Totally agree with you. Took the fun out of it as I had to return separately for 0 and 1, as x+1 which was my right bound for edge case like 1, also overflowed and turned into negative."
                    },
                    {
                        "username": "tka8edd",
                        "content": "if you are solving it in O(n), you don\\'t need to cast to long and there is no overflow."
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "agree with you"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah its frustating when overflow happens and also it isnt mentioned in problem for beginners!!"
                    },
                    {
                        "username": "10alan0712",
                        "content": "fiercely upvote"
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "[@jiayipaulwang](/jiayipaulwang) However, my solution is too add \"break\" within the loop when you find the desired answer."
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "why there\\'s an integer overflow issue? I thought that wasn\\'t a thing in python"
                    },
                    {
                        "username": "mkohar",
                        "content": "\\n[@SeaShanty](/SeaShanty).  [@onedaywillmake](/onedaywillmake)\\nHow to bypass overflow without using long? Try this:\\n1. use:  mid = low +(high-low)//2. \\n instead of mid =(high+low)//2\\n\\n2. Use   if(mid==x/mid) return mid\\n  instead of:   if(mid*mid==x)\\n\\nsmall things like this go long way in interview \\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": "typedef long long ll;\\nuse this simple easy"
                    },
                    {
                        "username": "valer0n3",
                        "content": "[@SeaShanty](/SeaShanty) Just consider that the solution can\\'t be more than x/2. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "OMG thank u so much for letting me know this was a case of integer overflow. I was stuck on this testcase and was making changes in my code multiple times thinking my approach was wrong. My approach works well for smaller testcases. How to handle the  214739500 testcase? Thank you "
                    },
                    {
                        "username": "Twitnithegirl",
                        "content": "\"You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\"\\n\\nWhat is the practical application of not using the standard library of the language you work in?"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "You\\'re so right. You should say that to the interviewer."
                    },
                    {
                        "username": "mepradeepkr",
                        "content": "Agree!!Bro"
                    },
                    {
                        "username": "h4ytham",
                        "content": "[@martynov-94](/martynov-94) well why would you bench press in a warehouse? You\\'re \"in a warehouse\" (using python) so bench pressing is redundant"
                    },
                    {
                        "username": "martynov-94",
                        "content": "Why bench press in the gym when you can just use a forklift?"
                    },
                    {
                        "username": "__Simamina__",
                        "content": "They say you can\\'t use it but you actually can(like, what the heck)"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "To understand how someone implemented the standard library you are sitting on. So you can improve as a coder knowing how something is behind the curtains and to have more knowledge to extend the default/standard of things. If we all took as a premisse that all ships must sail in water, we would never have created rocket ships. "
                    },
                    {
                        "username": "d4mir",
                        "content": "I guess logic and understanding the function and being able to work without using it. The same with in-built quicksort in Java (Arrays.sort()), we have it in the standard library, but we still learn it in the course as well as other sortings."
                    },
                    {
                        "username": "kuelf",
                        "content": "It\\'s a challenge "
                    },
                    {
                        "username": "niklas5559",
                        "content": "Python3\\nFeel free to ask questions if the code is too complex\\n\\n`return int(x ** 0.5)`"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "I don\\'t get it. You can still just make it 1 line in Java without using an exponent operator (nor importing any library).\\n```\\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\\n```"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My questions : Did you read the description carrefully?"
                    },
                    {
                        "username": "nodejk",
                        "content": "fyi for all the people who take things way too seriously, this is a joke."
                    },
                    {
                        "username": "milii048_leetcode",
                        "content": "Man, you must think you\\'re special right? Read the rules of the question before you post something dumb like this"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "dumbest answer ever"
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@mihir2310](/mihir2310) \\nYou are correct. I am not certain, but OP may be criticizing the fact that the auto-grader cannot detect that you are violating those rules. That, or they didn\\'t read the rules and are a bit too snarky. Or the problem statement changed over time."
                    },
                    {
                        "username": "mihir2310",
                        "content": "they said you can\\'t use that ** operation"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "\\tif (x <= 1) return x;\\n\\tlong i = 1;\\n\\tlong sq = i * i;\\n\\twhile (x >= sq) {\\n\\t\\ti++;\\n\\t\\tsq = i * i;\\n\\t}\\n\\treturn (int) (i - 1);"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "```\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\n```"
                    },
                    {
                        "username": "Gilbertttt",
                        "content": "Please can you break this down i\\'m having trouble understanding this\\n"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "BOOM baby! This is it. After Googling and reviewing the definition of square root, I came to the same solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "SeraphNiu",
                        "content": "![image](https://assets.leetcode.com/users/images/4d8f6ebd-d3a8-4cd7-8223-7ff4ecb2de52_1628032236.8164496.png)\\n"
                    },
                    {
                        "username": "itmevic",
                        "content": "why are u posting solution here? do u know how to read?"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "How are you using the value of \\'lo\\' without initialising it first?"
                    },
                    {
                        "username": "hu.cao1",
                        "content": "that will make sense. How do you expect the sqrt of 2 is  integer too?"
                    },
                    {
                        "username": "chinmayjain096",
                        "content": "but in question they mention about the integer value of number not the decimal of number.\\nu can right code also too get precious ans put which decimal u want in vs code/any compiler"
                    },
                    {
                        "username": "AbhiLeet",
                        "content": "May be I am missing something here, but the upper bound on the srqrt(x)  for any positive integer x cannot be more that x/2   (in fact its x/2 ONLY for number from 4-8) for any integer > 8, the upper bound on the sqrt is strictly < x/2.   So that makes me wonder - why are so many folks taking such a huge upper bound (INT_MX) for this problem ?"
                    },
                    {
                        "username": "artofhuman",
                        "content": "In binary search it saves one operation, it does not matter "
                    },
                    {
                        "username": "shubhamkeshari04",
                        "content": "why i m getting wrong answer for input x=2147395599\\n pls help"
                    },
                    {
                        "username": "stardust-skg",
                        "content": "[@rglamazda](/rglamazda) It\\'s better to use int properly :) "
                    },
                    {
                        "username": "Kromydas",
                        "content": "as [@rglamazda] has said, use long. A even better ideal is to use long long. And watch out for x = 0, and use while loops. (they are better in this scenario because they are conditional on different things, easier for beginners). It also makes your code slightly faster depending on what conditions you put in a for loop"
                    },
                    {
                        "username": "TheoW03",
                        "content": "[@TheoW03](/TheoW03) exactly. not 46369\\n"
                    },
                    {
                        "username": "TheoW03",
                        "content": "no its right the sqrt of (2147395599) is 46340"
                    },
                    {
                        "username": "Dest1ni",
                        "content": "This is a great beginner question, however the addition of values such as 2147395600 which cause an integer overflow take away from spirit of the question which is to find the algorithm.\\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm.\\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "rglamazda",
                        "content": "try to use long instead int"
                    },
                    {
                        "username": "user2354Mw",
                        "content": "\\tr = x\\n\\n\\tif x == 0:\\n\\t\\treturn 0\\n\\n\\tfor i in range(20):\\n\\t\\tr = (r + x / r) / 2\\n\\n\\treturn math.floor(r)"
                    },
                    {
                        "username": "anish_kr23",
                        "content": "[@nguyentuan67](/nguyentuan67)  i also not understand why he uses like this function.??????\\n"
                    },
                    {
                        "username": "d4mir",
                        "content": "[@nguyentuan67](/nguyentuan67) It\\'s a Newton-Raphson method"
                    },
                    {
                        "username": "wangchao426",
                        "content": "[@nguyentuan67](/nguyentuan67) ordinary least squares"
                    },
                    {
                        "username": "nguyentuan67",
                        "content": "why r = (r + x / r) / 2 ? i don\\'t understand."
                    },
                    {
                        "username": "waerte",
                        "content": "Kindly provide hint for implementing your own sqrt.\\nthanks!"
                    },
                    {
                        "username": "NerdPai",
                        "content": "https://en.wikipedia.org/wiki/Newton%27s_method"
                    }
                ]
            },
            {
                "id": 1575948,
                "content": [
                    {
                        "username": "onedaywillmake",
                        "content": "This is a great beginner question, however the addition of values such as `2147395600` which cause an integer overflow take away from spirit of the question which is to find the algorithm. \\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm. \\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Questions is labelled \"easy\"\\nHas dumb and frustrating edge cases to handle\\nOk, I might be dumb but it\\'s seems like I am not the only one complaining..."
                    },
                    {
                        "username": "md_isa",
                        "content": "Totally agree with you. Took the fun out of it as I had to return separately for 0 and 1, as x+1 which was my right bound for edge case like 1, also overflowed and turned into negative."
                    },
                    {
                        "username": "tka8edd",
                        "content": "if you are solving it in O(n), you don\\'t need to cast to long and there is no overflow."
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "agree with you"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah its frustating when overflow happens and also it isnt mentioned in problem for beginners!!"
                    },
                    {
                        "username": "10alan0712",
                        "content": "fiercely upvote"
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "[@jiayipaulwang](/jiayipaulwang) However, my solution is too add \"break\" within the loop when you find the desired answer."
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "why there\\'s an integer overflow issue? I thought that wasn\\'t a thing in python"
                    },
                    {
                        "username": "mkohar",
                        "content": "\\n[@SeaShanty](/SeaShanty).  [@onedaywillmake](/onedaywillmake)\\nHow to bypass overflow without using long? Try this:\\n1. use:  mid = low +(high-low)//2. \\n instead of mid =(high+low)//2\\n\\n2. Use   if(mid==x/mid) return mid\\n  instead of:   if(mid*mid==x)\\n\\nsmall things like this go long way in interview \\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": "typedef long long ll;\\nuse this simple easy"
                    },
                    {
                        "username": "valer0n3",
                        "content": "[@SeaShanty](/SeaShanty) Just consider that the solution can\\'t be more than x/2. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "OMG thank u so much for letting me know this was a case of integer overflow. I was stuck on this testcase and was making changes in my code multiple times thinking my approach was wrong. My approach works well for smaller testcases. How to handle the  214739500 testcase? Thank you "
                    },
                    {
                        "username": "Twitnithegirl",
                        "content": "\"You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\"\\n\\nWhat is the practical application of not using the standard library of the language you work in?"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "You\\'re so right. You should say that to the interviewer."
                    },
                    {
                        "username": "mepradeepkr",
                        "content": "Agree!!Bro"
                    },
                    {
                        "username": "h4ytham",
                        "content": "[@martynov-94](/martynov-94) well why would you bench press in a warehouse? You\\'re \"in a warehouse\" (using python) so bench pressing is redundant"
                    },
                    {
                        "username": "martynov-94",
                        "content": "Why bench press in the gym when you can just use a forklift?"
                    },
                    {
                        "username": "__Simamina__",
                        "content": "They say you can\\'t use it but you actually can(like, what the heck)"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "To understand how someone implemented the standard library you are sitting on. So you can improve as a coder knowing how something is behind the curtains and to have more knowledge to extend the default/standard of things. If we all took as a premisse that all ships must sail in water, we would never have created rocket ships. "
                    },
                    {
                        "username": "d4mir",
                        "content": "I guess logic and understanding the function and being able to work without using it. The same with in-built quicksort in Java (Arrays.sort()), we have it in the standard library, but we still learn it in the course as well as other sortings."
                    },
                    {
                        "username": "kuelf",
                        "content": "It\\'s a challenge "
                    },
                    {
                        "username": "niklas5559",
                        "content": "Python3\\nFeel free to ask questions if the code is too complex\\n\\n`return int(x ** 0.5)`"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "I don\\'t get it. You can still just make it 1 line in Java without using an exponent operator (nor importing any library).\\n```\\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\\n```"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My questions : Did you read the description carrefully?"
                    },
                    {
                        "username": "nodejk",
                        "content": "fyi for all the people who take things way too seriously, this is a joke."
                    },
                    {
                        "username": "milii048_leetcode",
                        "content": "Man, you must think you\\'re special right? Read the rules of the question before you post something dumb like this"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "dumbest answer ever"
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@mihir2310](/mihir2310) \\nYou are correct. I am not certain, but OP may be criticizing the fact that the auto-grader cannot detect that you are violating those rules. That, or they didn\\'t read the rules and are a bit too snarky. Or the problem statement changed over time."
                    },
                    {
                        "username": "mihir2310",
                        "content": "they said you can\\'t use that ** operation"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "\\tif (x <= 1) return x;\\n\\tlong i = 1;\\n\\tlong sq = i * i;\\n\\twhile (x >= sq) {\\n\\t\\ti++;\\n\\t\\tsq = i * i;\\n\\t}\\n\\treturn (int) (i - 1);"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "```\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\n```"
                    },
                    {
                        "username": "Gilbertttt",
                        "content": "Please can you break this down i\\'m having trouble understanding this\\n"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "BOOM baby! This is it. After Googling and reviewing the definition of square root, I came to the same solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "SeraphNiu",
                        "content": "![image](https://assets.leetcode.com/users/images/4d8f6ebd-d3a8-4cd7-8223-7ff4ecb2de52_1628032236.8164496.png)\\n"
                    },
                    {
                        "username": "itmevic",
                        "content": "why are u posting solution here? do u know how to read?"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "How are you using the value of \\'lo\\' without initialising it first?"
                    },
                    {
                        "username": "hu.cao1",
                        "content": "that will make sense. How do you expect the sqrt of 2 is  integer too?"
                    },
                    {
                        "username": "chinmayjain096",
                        "content": "but in question they mention about the integer value of number not the decimal of number.\\nu can right code also too get precious ans put which decimal u want in vs code/any compiler"
                    },
                    {
                        "username": "AbhiLeet",
                        "content": "May be I am missing something here, but the upper bound on the srqrt(x)  for any positive integer x cannot be more that x/2   (in fact its x/2 ONLY for number from 4-8) for any integer > 8, the upper bound on the sqrt is strictly < x/2.   So that makes me wonder - why are so many folks taking such a huge upper bound (INT_MX) for this problem ?"
                    },
                    {
                        "username": "artofhuman",
                        "content": "In binary search it saves one operation, it does not matter "
                    },
                    {
                        "username": "shubhamkeshari04",
                        "content": "why i m getting wrong answer for input x=2147395599\\n pls help"
                    },
                    {
                        "username": "stardust-skg",
                        "content": "[@rglamazda](/rglamazda) It\\'s better to use int properly :) "
                    },
                    {
                        "username": "Kromydas",
                        "content": "as [@rglamazda] has said, use long. A even better ideal is to use long long. And watch out for x = 0, and use while loops. (they are better in this scenario because they are conditional on different things, easier for beginners). It also makes your code slightly faster depending on what conditions you put in a for loop"
                    },
                    {
                        "username": "TheoW03",
                        "content": "[@TheoW03](/TheoW03) exactly. not 46369\\n"
                    },
                    {
                        "username": "TheoW03",
                        "content": "no its right the sqrt of (2147395599) is 46340"
                    },
                    {
                        "username": "Dest1ni",
                        "content": "This is a great beginner question, however the addition of values such as 2147395600 which cause an integer overflow take away from spirit of the question which is to find the algorithm.\\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm.\\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "rglamazda",
                        "content": "try to use long instead int"
                    },
                    {
                        "username": "user2354Mw",
                        "content": "\\tr = x\\n\\n\\tif x == 0:\\n\\t\\treturn 0\\n\\n\\tfor i in range(20):\\n\\t\\tr = (r + x / r) / 2\\n\\n\\treturn math.floor(r)"
                    },
                    {
                        "username": "anish_kr23",
                        "content": "[@nguyentuan67](/nguyentuan67)  i also not understand why he uses like this function.??????\\n"
                    },
                    {
                        "username": "d4mir",
                        "content": "[@nguyentuan67](/nguyentuan67) It\\'s a Newton-Raphson method"
                    },
                    {
                        "username": "wangchao426",
                        "content": "[@nguyentuan67](/nguyentuan67) ordinary least squares"
                    },
                    {
                        "username": "nguyentuan67",
                        "content": "why r = (r + x / r) / 2 ? i don\\'t understand."
                    },
                    {
                        "username": "waerte",
                        "content": "Kindly provide hint for implementing your own sqrt.\\nthanks!"
                    },
                    {
                        "username": "NerdPai",
                        "content": "https://en.wikipedia.org/wiki/Newton%27s_method"
                    }
                ]
            },
            {
                "id": 1573187,
                "content": [
                    {
                        "username": "onedaywillmake",
                        "content": "This is a great beginner question, however the addition of values such as `2147395600` which cause an integer overflow take away from spirit of the question which is to find the algorithm. \\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm. \\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Questions is labelled \"easy\"\\nHas dumb and frustrating edge cases to handle\\nOk, I might be dumb but it\\'s seems like I am not the only one complaining..."
                    },
                    {
                        "username": "md_isa",
                        "content": "Totally agree with you. Took the fun out of it as I had to return separately for 0 and 1, as x+1 which was my right bound for edge case like 1, also overflowed and turned into negative."
                    },
                    {
                        "username": "tka8edd",
                        "content": "if you are solving it in O(n), you don\\'t need to cast to long and there is no overflow."
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "agree with you"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah its frustating when overflow happens and also it isnt mentioned in problem for beginners!!"
                    },
                    {
                        "username": "10alan0712",
                        "content": "fiercely upvote"
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "[@jiayipaulwang](/jiayipaulwang) However, my solution is too add \"break\" within the loop when you find the desired answer."
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "why there\\'s an integer overflow issue? I thought that wasn\\'t a thing in python"
                    },
                    {
                        "username": "mkohar",
                        "content": "\\n[@SeaShanty](/SeaShanty).  [@onedaywillmake](/onedaywillmake)\\nHow to bypass overflow without using long? Try this:\\n1. use:  mid = low +(high-low)//2. \\n instead of mid =(high+low)//2\\n\\n2. Use   if(mid==x/mid) return mid\\n  instead of:   if(mid*mid==x)\\n\\nsmall things like this go long way in interview \\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": "typedef long long ll;\\nuse this simple easy"
                    },
                    {
                        "username": "valer0n3",
                        "content": "[@SeaShanty](/SeaShanty) Just consider that the solution can\\'t be more than x/2. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "OMG thank u so much for letting me know this was a case of integer overflow. I was stuck on this testcase and was making changes in my code multiple times thinking my approach was wrong. My approach works well for smaller testcases. How to handle the  214739500 testcase? Thank you "
                    },
                    {
                        "username": "Twitnithegirl",
                        "content": "\"You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\"\\n\\nWhat is the practical application of not using the standard library of the language you work in?"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "You\\'re so right. You should say that to the interviewer."
                    },
                    {
                        "username": "mepradeepkr",
                        "content": "Agree!!Bro"
                    },
                    {
                        "username": "h4ytham",
                        "content": "[@martynov-94](/martynov-94) well why would you bench press in a warehouse? You\\'re \"in a warehouse\" (using python) so bench pressing is redundant"
                    },
                    {
                        "username": "martynov-94",
                        "content": "Why bench press in the gym when you can just use a forklift?"
                    },
                    {
                        "username": "__Simamina__",
                        "content": "They say you can\\'t use it but you actually can(like, what the heck)"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "To understand how someone implemented the standard library you are sitting on. So you can improve as a coder knowing how something is behind the curtains and to have more knowledge to extend the default/standard of things. If we all took as a premisse that all ships must sail in water, we would never have created rocket ships. "
                    },
                    {
                        "username": "d4mir",
                        "content": "I guess logic and understanding the function and being able to work without using it. The same with in-built quicksort in Java (Arrays.sort()), we have it in the standard library, but we still learn it in the course as well as other sortings."
                    },
                    {
                        "username": "kuelf",
                        "content": "It\\'s a challenge "
                    },
                    {
                        "username": "niklas5559",
                        "content": "Python3\\nFeel free to ask questions if the code is too complex\\n\\n`return int(x ** 0.5)`"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "I don\\'t get it. You can still just make it 1 line in Java without using an exponent operator (nor importing any library).\\n```\\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\\n```"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My questions : Did you read the description carrefully?"
                    },
                    {
                        "username": "nodejk",
                        "content": "fyi for all the people who take things way too seriously, this is a joke."
                    },
                    {
                        "username": "milii048_leetcode",
                        "content": "Man, you must think you\\'re special right? Read the rules of the question before you post something dumb like this"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "dumbest answer ever"
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@mihir2310](/mihir2310) \\nYou are correct. I am not certain, but OP may be criticizing the fact that the auto-grader cannot detect that you are violating those rules. That, or they didn\\'t read the rules and are a bit too snarky. Or the problem statement changed over time."
                    },
                    {
                        "username": "mihir2310",
                        "content": "they said you can\\'t use that ** operation"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "\\tif (x <= 1) return x;\\n\\tlong i = 1;\\n\\tlong sq = i * i;\\n\\twhile (x >= sq) {\\n\\t\\ti++;\\n\\t\\tsq = i * i;\\n\\t}\\n\\treturn (int) (i - 1);"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "```\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\n```"
                    },
                    {
                        "username": "Gilbertttt",
                        "content": "Please can you break this down i\\'m having trouble understanding this\\n"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "BOOM baby! This is it. After Googling and reviewing the definition of square root, I came to the same solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "SeraphNiu",
                        "content": "![image](https://assets.leetcode.com/users/images/4d8f6ebd-d3a8-4cd7-8223-7ff4ecb2de52_1628032236.8164496.png)\\n"
                    },
                    {
                        "username": "itmevic",
                        "content": "why are u posting solution here? do u know how to read?"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "How are you using the value of \\'lo\\' without initialising it first?"
                    },
                    {
                        "username": "hu.cao1",
                        "content": "that will make sense. How do you expect the sqrt of 2 is  integer too?"
                    },
                    {
                        "username": "chinmayjain096",
                        "content": "but in question they mention about the integer value of number not the decimal of number.\\nu can right code also too get precious ans put which decimal u want in vs code/any compiler"
                    },
                    {
                        "username": "AbhiLeet",
                        "content": "May be I am missing something here, but the upper bound on the srqrt(x)  for any positive integer x cannot be more that x/2   (in fact its x/2 ONLY for number from 4-8) for any integer > 8, the upper bound on the sqrt is strictly < x/2.   So that makes me wonder - why are so many folks taking such a huge upper bound (INT_MX) for this problem ?"
                    },
                    {
                        "username": "artofhuman",
                        "content": "In binary search it saves one operation, it does not matter "
                    },
                    {
                        "username": "shubhamkeshari04",
                        "content": "why i m getting wrong answer for input x=2147395599\\n pls help"
                    },
                    {
                        "username": "stardust-skg",
                        "content": "[@rglamazda](/rglamazda) It\\'s better to use int properly :) "
                    },
                    {
                        "username": "Kromydas",
                        "content": "as [@rglamazda] has said, use long. A even better ideal is to use long long. And watch out for x = 0, and use while loops. (they are better in this scenario because they are conditional on different things, easier for beginners). It also makes your code slightly faster depending on what conditions you put in a for loop"
                    },
                    {
                        "username": "TheoW03",
                        "content": "[@TheoW03](/TheoW03) exactly. not 46369\\n"
                    },
                    {
                        "username": "TheoW03",
                        "content": "no its right the sqrt of (2147395599) is 46340"
                    },
                    {
                        "username": "Dest1ni",
                        "content": "This is a great beginner question, however the addition of values such as 2147395600 which cause an integer overflow take away from spirit of the question which is to find the algorithm.\\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm.\\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "rglamazda",
                        "content": "try to use long instead int"
                    },
                    {
                        "username": "user2354Mw",
                        "content": "\\tr = x\\n\\n\\tif x == 0:\\n\\t\\treturn 0\\n\\n\\tfor i in range(20):\\n\\t\\tr = (r + x / r) / 2\\n\\n\\treturn math.floor(r)"
                    },
                    {
                        "username": "anish_kr23",
                        "content": "[@nguyentuan67](/nguyentuan67)  i also not understand why he uses like this function.??????\\n"
                    },
                    {
                        "username": "d4mir",
                        "content": "[@nguyentuan67](/nguyentuan67) It\\'s a Newton-Raphson method"
                    },
                    {
                        "username": "wangchao426",
                        "content": "[@nguyentuan67](/nguyentuan67) ordinary least squares"
                    },
                    {
                        "username": "nguyentuan67",
                        "content": "why r = (r + x / r) / 2 ? i don\\'t understand."
                    },
                    {
                        "username": "waerte",
                        "content": "Kindly provide hint for implementing your own sqrt.\\nthanks!"
                    },
                    {
                        "username": "NerdPai",
                        "content": "https://en.wikipedia.org/wiki/Newton%27s_method"
                    }
                ]
            },
            {
                "id": 1566625,
                "content": [
                    {
                        "username": "onedaywillmake",
                        "content": "This is a great beginner question, however the addition of values such as `2147395600` which cause an integer overflow take away from spirit of the question which is to find the algorithm. \\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm. \\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Questions is labelled \"easy\"\\nHas dumb and frustrating edge cases to handle\\nOk, I might be dumb but it\\'s seems like I am not the only one complaining..."
                    },
                    {
                        "username": "md_isa",
                        "content": "Totally agree with you. Took the fun out of it as I had to return separately for 0 and 1, as x+1 which was my right bound for edge case like 1, also overflowed and turned into negative."
                    },
                    {
                        "username": "tka8edd",
                        "content": "if you are solving it in O(n), you don\\'t need to cast to long and there is no overflow."
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "agree with you"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah its frustating when overflow happens and also it isnt mentioned in problem for beginners!!"
                    },
                    {
                        "username": "10alan0712",
                        "content": "fiercely upvote"
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "[@jiayipaulwang](/jiayipaulwang) However, my solution is too add \"break\" within the loop when you find the desired answer."
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "why there\\'s an integer overflow issue? I thought that wasn\\'t a thing in python"
                    },
                    {
                        "username": "mkohar",
                        "content": "\\n[@SeaShanty](/SeaShanty).  [@onedaywillmake](/onedaywillmake)\\nHow to bypass overflow without using long? Try this:\\n1. use:  mid = low +(high-low)//2. \\n instead of mid =(high+low)//2\\n\\n2. Use   if(mid==x/mid) return mid\\n  instead of:   if(mid*mid==x)\\n\\nsmall things like this go long way in interview \\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": "typedef long long ll;\\nuse this simple easy"
                    },
                    {
                        "username": "valer0n3",
                        "content": "[@SeaShanty](/SeaShanty) Just consider that the solution can\\'t be more than x/2. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "OMG thank u so much for letting me know this was a case of integer overflow. I was stuck on this testcase and was making changes in my code multiple times thinking my approach was wrong. My approach works well for smaller testcases. How to handle the  214739500 testcase? Thank you "
                    },
                    {
                        "username": "Twitnithegirl",
                        "content": "\"You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\"\\n\\nWhat is the practical application of not using the standard library of the language you work in?"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "You\\'re so right. You should say that to the interviewer."
                    },
                    {
                        "username": "mepradeepkr",
                        "content": "Agree!!Bro"
                    },
                    {
                        "username": "h4ytham",
                        "content": "[@martynov-94](/martynov-94) well why would you bench press in a warehouse? You\\'re \"in a warehouse\" (using python) so bench pressing is redundant"
                    },
                    {
                        "username": "martynov-94",
                        "content": "Why bench press in the gym when you can just use a forklift?"
                    },
                    {
                        "username": "__Simamina__",
                        "content": "They say you can\\'t use it but you actually can(like, what the heck)"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "To understand how someone implemented the standard library you are sitting on. So you can improve as a coder knowing how something is behind the curtains and to have more knowledge to extend the default/standard of things. If we all took as a premisse that all ships must sail in water, we would never have created rocket ships. "
                    },
                    {
                        "username": "d4mir",
                        "content": "I guess logic and understanding the function and being able to work without using it. The same with in-built quicksort in Java (Arrays.sort()), we have it in the standard library, but we still learn it in the course as well as other sortings."
                    },
                    {
                        "username": "kuelf",
                        "content": "It\\'s a challenge "
                    },
                    {
                        "username": "niklas5559",
                        "content": "Python3\\nFeel free to ask questions if the code is too complex\\n\\n`return int(x ** 0.5)`"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "I don\\'t get it. You can still just make it 1 line in Java without using an exponent operator (nor importing any library).\\n```\\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\\n```"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My questions : Did you read the description carrefully?"
                    },
                    {
                        "username": "nodejk",
                        "content": "fyi for all the people who take things way too seriously, this is a joke."
                    },
                    {
                        "username": "milii048_leetcode",
                        "content": "Man, you must think you\\'re special right? Read the rules of the question before you post something dumb like this"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "dumbest answer ever"
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@mihir2310](/mihir2310) \\nYou are correct. I am not certain, but OP may be criticizing the fact that the auto-grader cannot detect that you are violating those rules. That, or they didn\\'t read the rules and are a bit too snarky. Or the problem statement changed over time."
                    },
                    {
                        "username": "mihir2310",
                        "content": "they said you can\\'t use that ** operation"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "\\tif (x <= 1) return x;\\n\\tlong i = 1;\\n\\tlong sq = i * i;\\n\\twhile (x >= sq) {\\n\\t\\ti++;\\n\\t\\tsq = i * i;\\n\\t}\\n\\treturn (int) (i - 1);"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "```\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\n```"
                    },
                    {
                        "username": "Gilbertttt",
                        "content": "Please can you break this down i\\'m having trouble understanding this\\n"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "BOOM baby! This is it. After Googling and reviewing the definition of square root, I came to the same solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "SeraphNiu",
                        "content": "![image](https://assets.leetcode.com/users/images/4d8f6ebd-d3a8-4cd7-8223-7ff4ecb2de52_1628032236.8164496.png)\\n"
                    },
                    {
                        "username": "itmevic",
                        "content": "why are u posting solution here? do u know how to read?"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "How are you using the value of \\'lo\\' without initialising it first?"
                    },
                    {
                        "username": "hu.cao1",
                        "content": "that will make sense. How do you expect the sqrt of 2 is  integer too?"
                    },
                    {
                        "username": "chinmayjain096",
                        "content": "but in question they mention about the integer value of number not the decimal of number.\\nu can right code also too get precious ans put which decimal u want in vs code/any compiler"
                    },
                    {
                        "username": "AbhiLeet",
                        "content": "May be I am missing something here, but the upper bound on the srqrt(x)  for any positive integer x cannot be more that x/2   (in fact its x/2 ONLY for number from 4-8) for any integer > 8, the upper bound on the sqrt is strictly < x/2.   So that makes me wonder - why are so many folks taking such a huge upper bound (INT_MX) for this problem ?"
                    },
                    {
                        "username": "artofhuman",
                        "content": "In binary search it saves one operation, it does not matter "
                    },
                    {
                        "username": "shubhamkeshari04",
                        "content": "why i m getting wrong answer for input x=2147395599\\n pls help"
                    },
                    {
                        "username": "stardust-skg",
                        "content": "[@rglamazda](/rglamazda) It\\'s better to use int properly :) "
                    },
                    {
                        "username": "Kromydas",
                        "content": "as [@rglamazda] has said, use long. A even better ideal is to use long long. And watch out for x = 0, and use while loops. (they are better in this scenario because they are conditional on different things, easier for beginners). It also makes your code slightly faster depending on what conditions you put in a for loop"
                    },
                    {
                        "username": "TheoW03",
                        "content": "[@TheoW03](/TheoW03) exactly. not 46369\\n"
                    },
                    {
                        "username": "TheoW03",
                        "content": "no its right the sqrt of (2147395599) is 46340"
                    },
                    {
                        "username": "Dest1ni",
                        "content": "This is a great beginner question, however the addition of values such as 2147395600 which cause an integer overflow take away from spirit of the question which is to find the algorithm.\\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm.\\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "rglamazda",
                        "content": "try to use long instead int"
                    },
                    {
                        "username": "user2354Mw",
                        "content": "\\tr = x\\n\\n\\tif x == 0:\\n\\t\\treturn 0\\n\\n\\tfor i in range(20):\\n\\t\\tr = (r + x / r) / 2\\n\\n\\treturn math.floor(r)"
                    },
                    {
                        "username": "anish_kr23",
                        "content": "[@nguyentuan67](/nguyentuan67)  i also not understand why he uses like this function.??????\\n"
                    },
                    {
                        "username": "d4mir",
                        "content": "[@nguyentuan67](/nguyentuan67) It\\'s a Newton-Raphson method"
                    },
                    {
                        "username": "wangchao426",
                        "content": "[@nguyentuan67](/nguyentuan67) ordinary least squares"
                    },
                    {
                        "username": "nguyentuan67",
                        "content": "why r = (r + x / r) / 2 ? i don\\'t understand."
                    },
                    {
                        "username": "waerte",
                        "content": "Kindly provide hint for implementing your own sqrt.\\nthanks!"
                    },
                    {
                        "username": "NerdPai",
                        "content": "https://en.wikipedia.org/wiki/Newton%27s_method"
                    }
                ]
            },
            {
                "id": 1575605,
                "content": [
                    {
                        "username": "onedaywillmake",
                        "content": "This is a great beginner question, however the addition of values such as `2147395600` which cause an integer overflow take away from spirit of the question which is to find the algorithm. \\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm. \\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Questions is labelled \"easy\"\\nHas dumb and frustrating edge cases to handle\\nOk, I might be dumb but it\\'s seems like I am not the only one complaining..."
                    },
                    {
                        "username": "md_isa",
                        "content": "Totally agree with you. Took the fun out of it as I had to return separately for 0 and 1, as x+1 which was my right bound for edge case like 1, also overflowed and turned into negative."
                    },
                    {
                        "username": "tka8edd",
                        "content": "if you are solving it in O(n), you don\\'t need to cast to long and there is no overflow."
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "agree with you"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah its frustating when overflow happens and also it isnt mentioned in problem for beginners!!"
                    },
                    {
                        "username": "10alan0712",
                        "content": "fiercely upvote"
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "[@jiayipaulwang](/jiayipaulwang) However, my solution is too add \"break\" within the loop when you find the desired answer."
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "why there\\'s an integer overflow issue? I thought that wasn\\'t a thing in python"
                    },
                    {
                        "username": "mkohar",
                        "content": "\\n[@SeaShanty](/SeaShanty).  [@onedaywillmake](/onedaywillmake)\\nHow to bypass overflow without using long? Try this:\\n1. use:  mid = low +(high-low)//2. \\n instead of mid =(high+low)//2\\n\\n2. Use   if(mid==x/mid) return mid\\n  instead of:   if(mid*mid==x)\\n\\nsmall things like this go long way in interview \\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": "typedef long long ll;\\nuse this simple easy"
                    },
                    {
                        "username": "valer0n3",
                        "content": "[@SeaShanty](/SeaShanty) Just consider that the solution can\\'t be more than x/2. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "OMG thank u so much for letting me know this was a case of integer overflow. I was stuck on this testcase and was making changes in my code multiple times thinking my approach was wrong. My approach works well for smaller testcases. How to handle the  214739500 testcase? Thank you "
                    },
                    {
                        "username": "Twitnithegirl",
                        "content": "\"You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\"\\n\\nWhat is the practical application of not using the standard library of the language you work in?"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "You\\'re so right. You should say that to the interviewer."
                    },
                    {
                        "username": "mepradeepkr",
                        "content": "Agree!!Bro"
                    },
                    {
                        "username": "h4ytham",
                        "content": "[@martynov-94](/martynov-94) well why would you bench press in a warehouse? You\\'re \"in a warehouse\" (using python) so bench pressing is redundant"
                    },
                    {
                        "username": "martynov-94",
                        "content": "Why bench press in the gym when you can just use a forklift?"
                    },
                    {
                        "username": "__Simamina__",
                        "content": "They say you can\\'t use it but you actually can(like, what the heck)"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "To understand how someone implemented the standard library you are sitting on. So you can improve as a coder knowing how something is behind the curtains and to have more knowledge to extend the default/standard of things. If we all took as a premisse that all ships must sail in water, we would never have created rocket ships. "
                    },
                    {
                        "username": "d4mir",
                        "content": "I guess logic and understanding the function and being able to work without using it. The same with in-built quicksort in Java (Arrays.sort()), we have it in the standard library, but we still learn it in the course as well as other sortings."
                    },
                    {
                        "username": "kuelf",
                        "content": "It\\'s a challenge "
                    },
                    {
                        "username": "niklas5559",
                        "content": "Python3\\nFeel free to ask questions if the code is too complex\\n\\n`return int(x ** 0.5)`"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "I don\\'t get it. You can still just make it 1 line in Java without using an exponent operator (nor importing any library).\\n```\\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\\n```"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My questions : Did you read the description carrefully?"
                    },
                    {
                        "username": "nodejk",
                        "content": "fyi for all the people who take things way too seriously, this is a joke."
                    },
                    {
                        "username": "milii048_leetcode",
                        "content": "Man, you must think you\\'re special right? Read the rules of the question before you post something dumb like this"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "dumbest answer ever"
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@mihir2310](/mihir2310) \\nYou are correct. I am not certain, but OP may be criticizing the fact that the auto-grader cannot detect that you are violating those rules. That, or they didn\\'t read the rules and are a bit too snarky. Or the problem statement changed over time."
                    },
                    {
                        "username": "mihir2310",
                        "content": "they said you can\\'t use that ** operation"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "\\tif (x <= 1) return x;\\n\\tlong i = 1;\\n\\tlong sq = i * i;\\n\\twhile (x >= sq) {\\n\\t\\ti++;\\n\\t\\tsq = i * i;\\n\\t}\\n\\treturn (int) (i - 1);"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "```\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\n```"
                    },
                    {
                        "username": "Gilbertttt",
                        "content": "Please can you break this down i\\'m having trouble understanding this\\n"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "BOOM baby! This is it. After Googling and reviewing the definition of square root, I came to the same solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "SeraphNiu",
                        "content": "![image](https://assets.leetcode.com/users/images/4d8f6ebd-d3a8-4cd7-8223-7ff4ecb2de52_1628032236.8164496.png)\\n"
                    },
                    {
                        "username": "itmevic",
                        "content": "why are u posting solution here? do u know how to read?"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "How are you using the value of \\'lo\\' without initialising it first?"
                    },
                    {
                        "username": "hu.cao1",
                        "content": "that will make sense. How do you expect the sqrt of 2 is  integer too?"
                    },
                    {
                        "username": "chinmayjain096",
                        "content": "but in question they mention about the integer value of number not the decimal of number.\\nu can right code also too get precious ans put which decimal u want in vs code/any compiler"
                    },
                    {
                        "username": "AbhiLeet",
                        "content": "May be I am missing something here, but the upper bound on the srqrt(x)  for any positive integer x cannot be more that x/2   (in fact its x/2 ONLY for number from 4-8) for any integer > 8, the upper bound on the sqrt is strictly < x/2.   So that makes me wonder - why are so many folks taking such a huge upper bound (INT_MX) for this problem ?"
                    },
                    {
                        "username": "artofhuman",
                        "content": "In binary search it saves one operation, it does not matter "
                    },
                    {
                        "username": "shubhamkeshari04",
                        "content": "why i m getting wrong answer for input x=2147395599\\n pls help"
                    },
                    {
                        "username": "stardust-skg",
                        "content": "[@rglamazda](/rglamazda) It\\'s better to use int properly :) "
                    },
                    {
                        "username": "Kromydas",
                        "content": "as [@rglamazda] has said, use long. A even better ideal is to use long long. And watch out for x = 0, and use while loops. (they are better in this scenario because they are conditional on different things, easier for beginners). It also makes your code slightly faster depending on what conditions you put in a for loop"
                    },
                    {
                        "username": "TheoW03",
                        "content": "[@TheoW03](/TheoW03) exactly. not 46369\\n"
                    },
                    {
                        "username": "TheoW03",
                        "content": "no its right the sqrt of (2147395599) is 46340"
                    },
                    {
                        "username": "Dest1ni",
                        "content": "This is a great beginner question, however the addition of values such as 2147395600 which cause an integer overflow take away from spirit of the question which is to find the algorithm.\\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm.\\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "rglamazda",
                        "content": "try to use long instead int"
                    },
                    {
                        "username": "user2354Mw",
                        "content": "\\tr = x\\n\\n\\tif x == 0:\\n\\t\\treturn 0\\n\\n\\tfor i in range(20):\\n\\t\\tr = (r + x / r) / 2\\n\\n\\treturn math.floor(r)"
                    },
                    {
                        "username": "anish_kr23",
                        "content": "[@nguyentuan67](/nguyentuan67)  i also not understand why he uses like this function.??????\\n"
                    },
                    {
                        "username": "d4mir",
                        "content": "[@nguyentuan67](/nguyentuan67) It\\'s a Newton-Raphson method"
                    },
                    {
                        "username": "wangchao426",
                        "content": "[@nguyentuan67](/nguyentuan67) ordinary least squares"
                    },
                    {
                        "username": "nguyentuan67",
                        "content": "why r = (r + x / r) / 2 ? i don\\'t understand."
                    },
                    {
                        "username": "waerte",
                        "content": "Kindly provide hint for implementing your own sqrt.\\nthanks!"
                    },
                    {
                        "username": "NerdPai",
                        "content": "https://en.wikipedia.org/wiki/Newton%27s_method"
                    }
                ]
            },
            {
                "id": 1565250,
                "content": [
                    {
                        "username": "onedaywillmake",
                        "content": "This is a great beginner question, however the addition of values such as `2147395600` which cause an integer overflow take away from spirit of the question which is to find the algorithm. \\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm. \\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Questions is labelled \"easy\"\\nHas dumb and frustrating edge cases to handle\\nOk, I might be dumb but it\\'s seems like I am not the only one complaining..."
                    },
                    {
                        "username": "md_isa",
                        "content": "Totally agree with you. Took the fun out of it as I had to return separately for 0 and 1, as x+1 which was my right bound for edge case like 1, also overflowed and turned into negative."
                    },
                    {
                        "username": "tka8edd",
                        "content": "if you are solving it in O(n), you don\\'t need to cast to long and there is no overflow."
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "agree with you"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah its frustating when overflow happens and also it isnt mentioned in problem for beginners!!"
                    },
                    {
                        "username": "10alan0712",
                        "content": "fiercely upvote"
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "[@jiayipaulwang](/jiayipaulwang) However, my solution is too add \"break\" within the loop when you find the desired answer."
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "why there\\'s an integer overflow issue? I thought that wasn\\'t a thing in python"
                    },
                    {
                        "username": "mkohar",
                        "content": "\\n[@SeaShanty](/SeaShanty).  [@onedaywillmake](/onedaywillmake)\\nHow to bypass overflow without using long? Try this:\\n1. use:  mid = low +(high-low)//2. \\n instead of mid =(high+low)//2\\n\\n2. Use   if(mid==x/mid) return mid\\n  instead of:   if(mid*mid==x)\\n\\nsmall things like this go long way in interview \\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": "typedef long long ll;\\nuse this simple easy"
                    },
                    {
                        "username": "valer0n3",
                        "content": "[@SeaShanty](/SeaShanty) Just consider that the solution can\\'t be more than x/2. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "OMG thank u so much for letting me know this was a case of integer overflow. I was stuck on this testcase and was making changes in my code multiple times thinking my approach was wrong. My approach works well for smaller testcases. How to handle the  214739500 testcase? Thank you "
                    },
                    {
                        "username": "Twitnithegirl",
                        "content": "\"You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\"\\n\\nWhat is the practical application of not using the standard library of the language you work in?"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "You\\'re so right. You should say that to the interviewer."
                    },
                    {
                        "username": "mepradeepkr",
                        "content": "Agree!!Bro"
                    },
                    {
                        "username": "h4ytham",
                        "content": "[@martynov-94](/martynov-94) well why would you bench press in a warehouse? You\\'re \"in a warehouse\" (using python) so bench pressing is redundant"
                    },
                    {
                        "username": "martynov-94",
                        "content": "Why bench press in the gym when you can just use a forklift?"
                    },
                    {
                        "username": "__Simamina__",
                        "content": "They say you can\\'t use it but you actually can(like, what the heck)"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "To understand how someone implemented the standard library you are sitting on. So you can improve as a coder knowing how something is behind the curtains and to have more knowledge to extend the default/standard of things. If we all took as a premisse that all ships must sail in water, we would never have created rocket ships. "
                    },
                    {
                        "username": "d4mir",
                        "content": "I guess logic and understanding the function and being able to work without using it. The same with in-built quicksort in Java (Arrays.sort()), we have it in the standard library, but we still learn it in the course as well as other sortings."
                    },
                    {
                        "username": "kuelf",
                        "content": "It\\'s a challenge "
                    },
                    {
                        "username": "niklas5559",
                        "content": "Python3\\nFeel free to ask questions if the code is too complex\\n\\n`return int(x ** 0.5)`"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "I don\\'t get it. You can still just make it 1 line in Java without using an exponent operator (nor importing any library).\\n```\\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\\n```"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My questions : Did you read the description carrefully?"
                    },
                    {
                        "username": "nodejk",
                        "content": "fyi for all the people who take things way too seriously, this is a joke."
                    },
                    {
                        "username": "milii048_leetcode",
                        "content": "Man, you must think you\\'re special right? Read the rules of the question before you post something dumb like this"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "dumbest answer ever"
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@mihir2310](/mihir2310) \\nYou are correct. I am not certain, but OP may be criticizing the fact that the auto-grader cannot detect that you are violating those rules. That, or they didn\\'t read the rules and are a bit too snarky. Or the problem statement changed over time."
                    },
                    {
                        "username": "mihir2310",
                        "content": "they said you can\\'t use that ** operation"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "\\tif (x <= 1) return x;\\n\\tlong i = 1;\\n\\tlong sq = i * i;\\n\\twhile (x >= sq) {\\n\\t\\ti++;\\n\\t\\tsq = i * i;\\n\\t}\\n\\treturn (int) (i - 1);"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "```\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\n```"
                    },
                    {
                        "username": "Gilbertttt",
                        "content": "Please can you break this down i\\'m having trouble understanding this\\n"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "BOOM baby! This is it. After Googling and reviewing the definition of square root, I came to the same solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "SeraphNiu",
                        "content": "![image](https://assets.leetcode.com/users/images/4d8f6ebd-d3a8-4cd7-8223-7ff4ecb2de52_1628032236.8164496.png)\\n"
                    },
                    {
                        "username": "itmevic",
                        "content": "why are u posting solution here? do u know how to read?"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "How are you using the value of \\'lo\\' without initialising it first?"
                    },
                    {
                        "username": "hu.cao1",
                        "content": "that will make sense. How do you expect the sqrt of 2 is  integer too?"
                    },
                    {
                        "username": "chinmayjain096",
                        "content": "but in question they mention about the integer value of number not the decimal of number.\\nu can right code also too get precious ans put which decimal u want in vs code/any compiler"
                    },
                    {
                        "username": "AbhiLeet",
                        "content": "May be I am missing something here, but the upper bound on the srqrt(x)  for any positive integer x cannot be more that x/2   (in fact its x/2 ONLY for number from 4-8) for any integer > 8, the upper bound on the sqrt is strictly < x/2.   So that makes me wonder - why are so many folks taking such a huge upper bound (INT_MX) for this problem ?"
                    },
                    {
                        "username": "artofhuman",
                        "content": "In binary search it saves one operation, it does not matter "
                    },
                    {
                        "username": "shubhamkeshari04",
                        "content": "why i m getting wrong answer for input x=2147395599\\n pls help"
                    },
                    {
                        "username": "stardust-skg",
                        "content": "[@rglamazda](/rglamazda) It\\'s better to use int properly :) "
                    },
                    {
                        "username": "Kromydas",
                        "content": "as [@rglamazda] has said, use long. A even better ideal is to use long long. And watch out for x = 0, and use while loops. (they are better in this scenario because they are conditional on different things, easier for beginners). It also makes your code slightly faster depending on what conditions you put in a for loop"
                    },
                    {
                        "username": "TheoW03",
                        "content": "[@TheoW03](/TheoW03) exactly. not 46369\\n"
                    },
                    {
                        "username": "TheoW03",
                        "content": "no its right the sqrt of (2147395599) is 46340"
                    },
                    {
                        "username": "Dest1ni",
                        "content": "This is a great beginner question, however the addition of values such as 2147395600 which cause an integer overflow take away from spirit of the question which is to find the algorithm.\\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm.\\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "rglamazda",
                        "content": "try to use long instead int"
                    },
                    {
                        "username": "user2354Mw",
                        "content": "\\tr = x\\n\\n\\tif x == 0:\\n\\t\\treturn 0\\n\\n\\tfor i in range(20):\\n\\t\\tr = (r + x / r) / 2\\n\\n\\treturn math.floor(r)"
                    },
                    {
                        "username": "anish_kr23",
                        "content": "[@nguyentuan67](/nguyentuan67)  i also not understand why he uses like this function.??????\\n"
                    },
                    {
                        "username": "d4mir",
                        "content": "[@nguyentuan67](/nguyentuan67) It\\'s a Newton-Raphson method"
                    },
                    {
                        "username": "wangchao426",
                        "content": "[@nguyentuan67](/nguyentuan67) ordinary least squares"
                    },
                    {
                        "username": "nguyentuan67",
                        "content": "why r = (r + x / r) / 2 ? i don\\'t understand."
                    },
                    {
                        "username": "waerte",
                        "content": "Kindly provide hint for implementing your own sqrt.\\nthanks!"
                    },
                    {
                        "username": "NerdPai",
                        "content": "https://en.wikipedia.org/wiki/Newton%27s_method"
                    }
                ]
            },
            {
                "id": 1568890,
                "content": [
                    {
                        "username": "onedaywillmake",
                        "content": "This is a great beginner question, however the addition of values such as `2147395600` which cause an integer overflow take away from spirit of the question which is to find the algorithm. \\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm. \\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Questions is labelled \"easy\"\\nHas dumb and frustrating edge cases to handle\\nOk, I might be dumb but it\\'s seems like I am not the only one complaining..."
                    },
                    {
                        "username": "md_isa",
                        "content": "Totally agree with you. Took the fun out of it as I had to return separately for 0 and 1, as x+1 which was my right bound for edge case like 1, also overflowed and turned into negative."
                    },
                    {
                        "username": "tka8edd",
                        "content": "if you are solving it in O(n), you don\\'t need to cast to long and there is no overflow."
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "agree with you"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah its frustating when overflow happens and also it isnt mentioned in problem for beginners!!"
                    },
                    {
                        "username": "10alan0712",
                        "content": "fiercely upvote"
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "[@jiayipaulwang](/jiayipaulwang) However, my solution is too add \"break\" within the loop when you find the desired answer."
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "why there\\'s an integer overflow issue? I thought that wasn\\'t a thing in python"
                    },
                    {
                        "username": "mkohar",
                        "content": "\\n[@SeaShanty](/SeaShanty).  [@onedaywillmake](/onedaywillmake)\\nHow to bypass overflow without using long? Try this:\\n1. use:  mid = low +(high-low)//2. \\n instead of mid =(high+low)//2\\n\\n2. Use   if(mid==x/mid) return mid\\n  instead of:   if(mid*mid==x)\\n\\nsmall things like this go long way in interview \\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": "typedef long long ll;\\nuse this simple easy"
                    },
                    {
                        "username": "valer0n3",
                        "content": "[@SeaShanty](/SeaShanty) Just consider that the solution can\\'t be more than x/2. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "OMG thank u so much for letting me know this was a case of integer overflow. I was stuck on this testcase and was making changes in my code multiple times thinking my approach was wrong. My approach works well for smaller testcases. How to handle the  214739500 testcase? Thank you "
                    },
                    {
                        "username": "Twitnithegirl",
                        "content": "\"You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\"\\n\\nWhat is the practical application of not using the standard library of the language you work in?"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "You\\'re so right. You should say that to the interviewer."
                    },
                    {
                        "username": "mepradeepkr",
                        "content": "Agree!!Bro"
                    },
                    {
                        "username": "h4ytham",
                        "content": "[@martynov-94](/martynov-94) well why would you bench press in a warehouse? You\\'re \"in a warehouse\" (using python) so bench pressing is redundant"
                    },
                    {
                        "username": "martynov-94",
                        "content": "Why bench press in the gym when you can just use a forklift?"
                    },
                    {
                        "username": "__Simamina__",
                        "content": "They say you can\\'t use it but you actually can(like, what the heck)"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "To understand how someone implemented the standard library you are sitting on. So you can improve as a coder knowing how something is behind the curtains and to have more knowledge to extend the default/standard of things. If we all took as a premisse that all ships must sail in water, we would never have created rocket ships. "
                    },
                    {
                        "username": "d4mir",
                        "content": "I guess logic and understanding the function and being able to work without using it. The same with in-built quicksort in Java (Arrays.sort()), we have it in the standard library, but we still learn it in the course as well as other sortings."
                    },
                    {
                        "username": "kuelf",
                        "content": "It\\'s a challenge "
                    },
                    {
                        "username": "niklas5559",
                        "content": "Python3\\nFeel free to ask questions if the code is too complex\\n\\n`return int(x ** 0.5)`"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "I don\\'t get it. You can still just make it 1 line in Java without using an exponent operator (nor importing any library).\\n```\\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\\n```"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My questions : Did you read the description carrefully?"
                    },
                    {
                        "username": "nodejk",
                        "content": "fyi for all the people who take things way too seriously, this is a joke."
                    },
                    {
                        "username": "milii048_leetcode",
                        "content": "Man, you must think you\\'re special right? Read the rules of the question before you post something dumb like this"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "dumbest answer ever"
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@mihir2310](/mihir2310) \\nYou are correct. I am not certain, but OP may be criticizing the fact that the auto-grader cannot detect that you are violating those rules. That, or they didn\\'t read the rules and are a bit too snarky. Or the problem statement changed over time."
                    },
                    {
                        "username": "mihir2310",
                        "content": "they said you can\\'t use that ** operation"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "\\tif (x <= 1) return x;\\n\\tlong i = 1;\\n\\tlong sq = i * i;\\n\\twhile (x >= sq) {\\n\\t\\ti++;\\n\\t\\tsq = i * i;\\n\\t}\\n\\treturn (int) (i - 1);"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "```\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\n```"
                    },
                    {
                        "username": "Gilbertttt",
                        "content": "Please can you break this down i\\'m having trouble understanding this\\n"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "BOOM baby! This is it. After Googling and reviewing the definition of square root, I came to the same solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "SeraphNiu",
                        "content": "![image](https://assets.leetcode.com/users/images/4d8f6ebd-d3a8-4cd7-8223-7ff4ecb2de52_1628032236.8164496.png)\\n"
                    },
                    {
                        "username": "itmevic",
                        "content": "why are u posting solution here? do u know how to read?"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "How are you using the value of \\'lo\\' without initialising it first?"
                    },
                    {
                        "username": "hu.cao1",
                        "content": "that will make sense. How do you expect the sqrt of 2 is  integer too?"
                    },
                    {
                        "username": "chinmayjain096",
                        "content": "but in question they mention about the integer value of number not the decimal of number.\\nu can right code also too get precious ans put which decimal u want in vs code/any compiler"
                    },
                    {
                        "username": "AbhiLeet",
                        "content": "May be I am missing something here, but the upper bound on the srqrt(x)  for any positive integer x cannot be more that x/2   (in fact its x/2 ONLY for number from 4-8) for any integer > 8, the upper bound on the sqrt is strictly < x/2.   So that makes me wonder - why are so many folks taking such a huge upper bound (INT_MX) for this problem ?"
                    },
                    {
                        "username": "artofhuman",
                        "content": "In binary search it saves one operation, it does not matter "
                    },
                    {
                        "username": "shubhamkeshari04",
                        "content": "why i m getting wrong answer for input x=2147395599\\n pls help"
                    },
                    {
                        "username": "stardust-skg",
                        "content": "[@rglamazda](/rglamazda) It\\'s better to use int properly :) "
                    },
                    {
                        "username": "Kromydas",
                        "content": "as [@rglamazda] has said, use long. A even better ideal is to use long long. And watch out for x = 0, and use while loops. (they are better in this scenario because they are conditional on different things, easier for beginners). It also makes your code slightly faster depending on what conditions you put in a for loop"
                    },
                    {
                        "username": "TheoW03",
                        "content": "[@TheoW03](/TheoW03) exactly. not 46369\\n"
                    },
                    {
                        "username": "TheoW03",
                        "content": "no its right the sqrt of (2147395599) is 46340"
                    },
                    {
                        "username": "Dest1ni",
                        "content": "This is a great beginner question, however the addition of values such as 2147395600 which cause an integer overflow take away from spirit of the question which is to find the algorithm.\\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm.\\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "rglamazda",
                        "content": "try to use long instead int"
                    },
                    {
                        "username": "user2354Mw",
                        "content": "\\tr = x\\n\\n\\tif x == 0:\\n\\t\\treturn 0\\n\\n\\tfor i in range(20):\\n\\t\\tr = (r + x / r) / 2\\n\\n\\treturn math.floor(r)"
                    },
                    {
                        "username": "anish_kr23",
                        "content": "[@nguyentuan67](/nguyentuan67)  i also not understand why he uses like this function.??????\\n"
                    },
                    {
                        "username": "d4mir",
                        "content": "[@nguyentuan67](/nguyentuan67) It\\'s a Newton-Raphson method"
                    },
                    {
                        "username": "wangchao426",
                        "content": "[@nguyentuan67](/nguyentuan67) ordinary least squares"
                    },
                    {
                        "username": "nguyentuan67",
                        "content": "why r = (r + x / r) / 2 ? i don\\'t understand."
                    },
                    {
                        "username": "waerte",
                        "content": "Kindly provide hint for implementing your own sqrt.\\nthanks!"
                    },
                    {
                        "username": "NerdPai",
                        "content": "https://en.wikipedia.org/wiki/Newton%27s_method"
                    }
                ]
            },
            {
                "id": 1576429,
                "content": [
                    {
                        "username": "onedaywillmake",
                        "content": "This is a great beginner question, however the addition of values such as `2147395600` which cause an integer overflow take away from spirit of the question which is to find the algorithm. \\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm. \\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Questions is labelled \"easy\"\\nHas dumb and frustrating edge cases to handle\\nOk, I might be dumb but it\\'s seems like I am not the only one complaining..."
                    },
                    {
                        "username": "md_isa",
                        "content": "Totally agree with you. Took the fun out of it as I had to return separately for 0 and 1, as x+1 which was my right bound for edge case like 1, also overflowed and turned into negative."
                    },
                    {
                        "username": "tka8edd",
                        "content": "if you are solving it in O(n), you don\\'t need to cast to long and there is no overflow."
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "agree with you"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah its frustating when overflow happens and also it isnt mentioned in problem for beginners!!"
                    },
                    {
                        "username": "10alan0712",
                        "content": "fiercely upvote"
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "[@jiayipaulwang](/jiayipaulwang) However, my solution is too add \"break\" within the loop when you find the desired answer."
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "why there\\'s an integer overflow issue? I thought that wasn\\'t a thing in python"
                    },
                    {
                        "username": "mkohar",
                        "content": "\\n[@SeaShanty](/SeaShanty).  [@onedaywillmake](/onedaywillmake)\\nHow to bypass overflow without using long? Try this:\\n1. use:  mid = low +(high-low)//2. \\n instead of mid =(high+low)//2\\n\\n2. Use   if(mid==x/mid) return mid\\n  instead of:   if(mid*mid==x)\\n\\nsmall things like this go long way in interview \\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": "typedef long long ll;\\nuse this simple easy"
                    },
                    {
                        "username": "valer0n3",
                        "content": "[@SeaShanty](/SeaShanty) Just consider that the solution can\\'t be more than x/2. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "OMG thank u so much for letting me know this was a case of integer overflow. I was stuck on this testcase and was making changes in my code multiple times thinking my approach was wrong. My approach works well for smaller testcases. How to handle the  214739500 testcase? Thank you "
                    },
                    {
                        "username": "Twitnithegirl",
                        "content": "\"You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\"\\n\\nWhat is the practical application of not using the standard library of the language you work in?"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "You\\'re so right. You should say that to the interviewer."
                    },
                    {
                        "username": "mepradeepkr",
                        "content": "Agree!!Bro"
                    },
                    {
                        "username": "h4ytham",
                        "content": "[@martynov-94](/martynov-94) well why would you bench press in a warehouse? You\\'re \"in a warehouse\" (using python) so bench pressing is redundant"
                    },
                    {
                        "username": "martynov-94",
                        "content": "Why bench press in the gym when you can just use a forklift?"
                    },
                    {
                        "username": "__Simamina__",
                        "content": "They say you can\\'t use it but you actually can(like, what the heck)"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "To understand how someone implemented the standard library you are sitting on. So you can improve as a coder knowing how something is behind the curtains and to have more knowledge to extend the default/standard of things. If we all took as a premisse that all ships must sail in water, we would never have created rocket ships. "
                    },
                    {
                        "username": "d4mir",
                        "content": "I guess logic and understanding the function and being able to work without using it. The same with in-built quicksort in Java (Arrays.sort()), we have it in the standard library, but we still learn it in the course as well as other sortings."
                    },
                    {
                        "username": "kuelf",
                        "content": "It\\'s a challenge "
                    },
                    {
                        "username": "niklas5559",
                        "content": "Python3\\nFeel free to ask questions if the code is too complex\\n\\n`return int(x ** 0.5)`"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "I don\\'t get it. You can still just make it 1 line in Java without using an exponent operator (nor importing any library).\\n```\\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\\n```"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My questions : Did you read the description carrefully?"
                    },
                    {
                        "username": "nodejk",
                        "content": "fyi for all the people who take things way too seriously, this is a joke."
                    },
                    {
                        "username": "milii048_leetcode",
                        "content": "Man, you must think you\\'re special right? Read the rules of the question before you post something dumb like this"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "dumbest answer ever"
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@mihir2310](/mihir2310) \\nYou are correct. I am not certain, but OP may be criticizing the fact that the auto-grader cannot detect that you are violating those rules. That, or they didn\\'t read the rules and are a bit too snarky. Or the problem statement changed over time."
                    },
                    {
                        "username": "mihir2310",
                        "content": "they said you can\\'t use that ** operation"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "\\tif (x <= 1) return x;\\n\\tlong i = 1;\\n\\tlong sq = i * i;\\n\\twhile (x >= sq) {\\n\\t\\ti++;\\n\\t\\tsq = i * i;\\n\\t}\\n\\treturn (int) (i - 1);"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "```\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\n```"
                    },
                    {
                        "username": "Gilbertttt",
                        "content": "Please can you break this down i\\'m having trouble understanding this\\n"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "BOOM baby! This is it. After Googling and reviewing the definition of square root, I came to the same solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "SeraphNiu",
                        "content": "![image](https://assets.leetcode.com/users/images/4d8f6ebd-d3a8-4cd7-8223-7ff4ecb2de52_1628032236.8164496.png)\\n"
                    },
                    {
                        "username": "itmevic",
                        "content": "why are u posting solution here? do u know how to read?"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "How are you using the value of \\'lo\\' without initialising it first?"
                    },
                    {
                        "username": "hu.cao1",
                        "content": "that will make sense. How do you expect the sqrt of 2 is  integer too?"
                    },
                    {
                        "username": "chinmayjain096",
                        "content": "but in question they mention about the integer value of number not the decimal of number.\\nu can right code also too get precious ans put which decimal u want in vs code/any compiler"
                    },
                    {
                        "username": "AbhiLeet",
                        "content": "May be I am missing something here, but the upper bound on the srqrt(x)  for any positive integer x cannot be more that x/2   (in fact its x/2 ONLY for number from 4-8) for any integer > 8, the upper bound on the sqrt is strictly < x/2.   So that makes me wonder - why are so many folks taking such a huge upper bound (INT_MX) for this problem ?"
                    },
                    {
                        "username": "artofhuman",
                        "content": "In binary search it saves one operation, it does not matter "
                    },
                    {
                        "username": "shubhamkeshari04",
                        "content": "why i m getting wrong answer for input x=2147395599\\n pls help"
                    },
                    {
                        "username": "stardust-skg",
                        "content": "[@rglamazda](/rglamazda) It\\'s better to use int properly :) "
                    },
                    {
                        "username": "Kromydas",
                        "content": "as [@rglamazda] has said, use long. A even better ideal is to use long long. And watch out for x = 0, and use while loops. (they are better in this scenario because they are conditional on different things, easier for beginners). It also makes your code slightly faster depending on what conditions you put in a for loop"
                    },
                    {
                        "username": "TheoW03",
                        "content": "[@TheoW03](/TheoW03) exactly. not 46369\\n"
                    },
                    {
                        "username": "TheoW03",
                        "content": "no its right the sqrt of (2147395599) is 46340"
                    },
                    {
                        "username": "Dest1ni",
                        "content": "This is a great beginner question, however the addition of values such as 2147395600 which cause an integer overflow take away from spirit of the question which is to find the algorithm.\\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm.\\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "rglamazda",
                        "content": "try to use long instead int"
                    },
                    {
                        "username": "user2354Mw",
                        "content": "\\tr = x\\n\\n\\tif x == 0:\\n\\t\\treturn 0\\n\\n\\tfor i in range(20):\\n\\t\\tr = (r + x / r) / 2\\n\\n\\treturn math.floor(r)"
                    },
                    {
                        "username": "anish_kr23",
                        "content": "[@nguyentuan67](/nguyentuan67)  i also not understand why he uses like this function.??????\\n"
                    },
                    {
                        "username": "d4mir",
                        "content": "[@nguyentuan67](/nguyentuan67) It\\'s a Newton-Raphson method"
                    },
                    {
                        "username": "wangchao426",
                        "content": "[@nguyentuan67](/nguyentuan67) ordinary least squares"
                    },
                    {
                        "username": "nguyentuan67",
                        "content": "why r = (r + x / r) / 2 ? i don\\'t understand."
                    },
                    {
                        "username": "waerte",
                        "content": "Kindly provide hint for implementing your own sqrt.\\nthanks!"
                    },
                    {
                        "username": "NerdPai",
                        "content": "https://en.wikipedia.org/wiki/Newton%27s_method"
                    }
                ]
            },
            {
                "id": 1575669,
                "content": [
                    {
                        "username": "onedaywillmake",
                        "content": "This is a great beginner question, however the addition of values such as `2147395600` which cause an integer overflow take away from spirit of the question which is to find the algorithm. \\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm. \\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Questions is labelled \"easy\"\\nHas dumb and frustrating edge cases to handle\\nOk, I might be dumb but it\\'s seems like I am not the only one complaining..."
                    },
                    {
                        "username": "md_isa",
                        "content": "Totally agree with you. Took the fun out of it as I had to return separately for 0 and 1, as x+1 which was my right bound for edge case like 1, also overflowed and turned into negative."
                    },
                    {
                        "username": "tka8edd",
                        "content": "if you are solving it in O(n), you don\\'t need to cast to long and there is no overflow."
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "agree with you"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah its frustating when overflow happens and also it isnt mentioned in problem for beginners!!"
                    },
                    {
                        "username": "10alan0712",
                        "content": "fiercely upvote"
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "[@jiayipaulwang](/jiayipaulwang) However, my solution is too add \"break\" within the loop when you find the desired answer."
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "why there\\'s an integer overflow issue? I thought that wasn\\'t a thing in python"
                    },
                    {
                        "username": "mkohar",
                        "content": "\\n[@SeaShanty](/SeaShanty).  [@onedaywillmake](/onedaywillmake)\\nHow to bypass overflow without using long? Try this:\\n1. use:  mid = low +(high-low)//2. \\n instead of mid =(high+low)//2\\n\\n2. Use   if(mid==x/mid) return mid\\n  instead of:   if(mid*mid==x)\\n\\nsmall things like this go long way in interview \\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": "typedef long long ll;\\nuse this simple easy"
                    },
                    {
                        "username": "valer0n3",
                        "content": "[@SeaShanty](/SeaShanty) Just consider that the solution can\\'t be more than x/2. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "OMG thank u so much for letting me know this was a case of integer overflow. I was stuck on this testcase and was making changes in my code multiple times thinking my approach was wrong. My approach works well for smaller testcases. How to handle the  214739500 testcase? Thank you "
                    },
                    {
                        "username": "Twitnithegirl",
                        "content": "\"You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\"\\n\\nWhat is the practical application of not using the standard library of the language you work in?"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "You\\'re so right. You should say that to the interviewer."
                    },
                    {
                        "username": "mepradeepkr",
                        "content": "Agree!!Bro"
                    },
                    {
                        "username": "h4ytham",
                        "content": "[@martynov-94](/martynov-94) well why would you bench press in a warehouse? You\\'re \"in a warehouse\" (using python) so bench pressing is redundant"
                    },
                    {
                        "username": "martynov-94",
                        "content": "Why bench press in the gym when you can just use a forklift?"
                    },
                    {
                        "username": "__Simamina__",
                        "content": "They say you can\\'t use it but you actually can(like, what the heck)"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "To understand how someone implemented the standard library you are sitting on. So you can improve as a coder knowing how something is behind the curtains and to have more knowledge to extend the default/standard of things. If we all took as a premisse that all ships must sail in water, we would never have created rocket ships. "
                    },
                    {
                        "username": "d4mir",
                        "content": "I guess logic and understanding the function and being able to work without using it. The same with in-built quicksort in Java (Arrays.sort()), we have it in the standard library, but we still learn it in the course as well as other sortings."
                    },
                    {
                        "username": "kuelf",
                        "content": "It\\'s a challenge "
                    },
                    {
                        "username": "niklas5559",
                        "content": "Python3\\nFeel free to ask questions if the code is too complex\\n\\n`return int(x ** 0.5)`"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "I don\\'t get it. You can still just make it 1 line in Java without using an exponent operator (nor importing any library).\\n```\\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\\n```"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My questions : Did you read the description carrefully?"
                    },
                    {
                        "username": "nodejk",
                        "content": "fyi for all the people who take things way too seriously, this is a joke."
                    },
                    {
                        "username": "milii048_leetcode",
                        "content": "Man, you must think you\\'re special right? Read the rules of the question before you post something dumb like this"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "dumbest answer ever"
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@mihir2310](/mihir2310) \\nYou are correct. I am not certain, but OP may be criticizing the fact that the auto-grader cannot detect that you are violating those rules. That, or they didn\\'t read the rules and are a bit too snarky. Or the problem statement changed over time."
                    },
                    {
                        "username": "mihir2310",
                        "content": "they said you can\\'t use that ** operation"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "\\tif (x <= 1) return x;\\n\\tlong i = 1;\\n\\tlong sq = i * i;\\n\\twhile (x >= sq) {\\n\\t\\ti++;\\n\\t\\tsq = i * i;\\n\\t}\\n\\treturn (int) (i - 1);"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "```\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\n```"
                    },
                    {
                        "username": "Gilbertttt",
                        "content": "Please can you break this down i\\'m having trouble understanding this\\n"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "BOOM baby! This is it. After Googling and reviewing the definition of square root, I came to the same solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "SeraphNiu",
                        "content": "![image](https://assets.leetcode.com/users/images/4d8f6ebd-d3a8-4cd7-8223-7ff4ecb2de52_1628032236.8164496.png)\\n"
                    },
                    {
                        "username": "itmevic",
                        "content": "why are u posting solution here? do u know how to read?"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "How are you using the value of \\'lo\\' without initialising it first?"
                    },
                    {
                        "username": "hu.cao1",
                        "content": "that will make sense. How do you expect the sqrt of 2 is  integer too?"
                    },
                    {
                        "username": "chinmayjain096",
                        "content": "but in question they mention about the integer value of number not the decimal of number.\\nu can right code also too get precious ans put which decimal u want in vs code/any compiler"
                    },
                    {
                        "username": "AbhiLeet",
                        "content": "May be I am missing something here, but the upper bound on the srqrt(x)  for any positive integer x cannot be more that x/2   (in fact its x/2 ONLY for number from 4-8) for any integer > 8, the upper bound on the sqrt is strictly < x/2.   So that makes me wonder - why are so many folks taking such a huge upper bound (INT_MX) for this problem ?"
                    },
                    {
                        "username": "artofhuman",
                        "content": "In binary search it saves one operation, it does not matter "
                    },
                    {
                        "username": "shubhamkeshari04",
                        "content": "why i m getting wrong answer for input x=2147395599\\n pls help"
                    },
                    {
                        "username": "stardust-skg",
                        "content": "[@rglamazda](/rglamazda) It\\'s better to use int properly :) "
                    },
                    {
                        "username": "Kromydas",
                        "content": "as [@rglamazda] has said, use long. A even better ideal is to use long long. And watch out for x = 0, and use while loops. (they are better in this scenario because they are conditional on different things, easier for beginners). It also makes your code slightly faster depending on what conditions you put in a for loop"
                    },
                    {
                        "username": "TheoW03",
                        "content": "[@TheoW03](/TheoW03) exactly. not 46369\\n"
                    },
                    {
                        "username": "TheoW03",
                        "content": "no its right the sqrt of (2147395599) is 46340"
                    },
                    {
                        "username": "Dest1ni",
                        "content": "This is a great beginner question, however the addition of values such as 2147395600 which cause an integer overflow take away from spirit of the question which is to find the algorithm.\\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm.\\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "rglamazda",
                        "content": "try to use long instead int"
                    },
                    {
                        "username": "user2354Mw",
                        "content": "\\tr = x\\n\\n\\tif x == 0:\\n\\t\\treturn 0\\n\\n\\tfor i in range(20):\\n\\t\\tr = (r + x / r) / 2\\n\\n\\treturn math.floor(r)"
                    },
                    {
                        "username": "anish_kr23",
                        "content": "[@nguyentuan67](/nguyentuan67)  i also not understand why he uses like this function.??????\\n"
                    },
                    {
                        "username": "d4mir",
                        "content": "[@nguyentuan67](/nguyentuan67) It\\'s a Newton-Raphson method"
                    },
                    {
                        "username": "wangchao426",
                        "content": "[@nguyentuan67](/nguyentuan67) ordinary least squares"
                    },
                    {
                        "username": "nguyentuan67",
                        "content": "why r = (r + x / r) / 2 ? i don\\'t understand."
                    },
                    {
                        "username": "waerte",
                        "content": "Kindly provide hint for implementing your own sqrt.\\nthanks!"
                    },
                    {
                        "username": "NerdPai",
                        "content": "https://en.wikipedia.org/wiki/Newton%27s_method"
                    }
                ]
            },
            {
                "id": 1571169,
                "content": [
                    {
                        "username": "onedaywillmake",
                        "content": "This is a great beginner question, however the addition of values such as `2147395600` which cause an integer overflow take away from spirit of the question which is to find the algorithm. \\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm. \\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Questions is labelled \"easy\"\\nHas dumb and frustrating edge cases to handle\\nOk, I might be dumb but it\\'s seems like I am not the only one complaining..."
                    },
                    {
                        "username": "md_isa",
                        "content": "Totally agree with you. Took the fun out of it as I had to return separately for 0 and 1, as x+1 which was my right bound for edge case like 1, also overflowed and turned into negative."
                    },
                    {
                        "username": "tka8edd",
                        "content": "if you are solving it in O(n), you don\\'t need to cast to long and there is no overflow."
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "agree with you"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah its frustating when overflow happens and also it isnt mentioned in problem for beginners!!"
                    },
                    {
                        "username": "10alan0712",
                        "content": "fiercely upvote"
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "[@jiayipaulwang](/jiayipaulwang) However, my solution is too add \"break\" within the loop when you find the desired answer."
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "why there\\'s an integer overflow issue? I thought that wasn\\'t a thing in python"
                    },
                    {
                        "username": "mkohar",
                        "content": "\\n[@SeaShanty](/SeaShanty).  [@onedaywillmake](/onedaywillmake)\\nHow to bypass overflow without using long? Try this:\\n1. use:  mid = low +(high-low)//2. \\n instead of mid =(high+low)//2\\n\\n2. Use   if(mid==x/mid) return mid\\n  instead of:   if(mid*mid==x)\\n\\nsmall things like this go long way in interview \\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": "typedef long long ll;\\nuse this simple easy"
                    },
                    {
                        "username": "valer0n3",
                        "content": "[@SeaShanty](/SeaShanty) Just consider that the solution can\\'t be more than x/2. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "OMG thank u so much for letting me know this was a case of integer overflow. I was stuck on this testcase and was making changes in my code multiple times thinking my approach was wrong. My approach works well for smaller testcases. How to handle the  214739500 testcase? Thank you "
                    },
                    {
                        "username": "Twitnithegirl",
                        "content": "\"You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\"\\n\\nWhat is the practical application of not using the standard library of the language you work in?"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "You\\'re so right. You should say that to the interviewer."
                    },
                    {
                        "username": "mepradeepkr",
                        "content": "Agree!!Bro"
                    },
                    {
                        "username": "h4ytham",
                        "content": "[@martynov-94](/martynov-94) well why would you bench press in a warehouse? You\\'re \"in a warehouse\" (using python) so bench pressing is redundant"
                    },
                    {
                        "username": "martynov-94",
                        "content": "Why bench press in the gym when you can just use a forklift?"
                    },
                    {
                        "username": "__Simamina__",
                        "content": "They say you can\\'t use it but you actually can(like, what the heck)"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "To understand how someone implemented the standard library you are sitting on. So you can improve as a coder knowing how something is behind the curtains and to have more knowledge to extend the default/standard of things. If we all took as a premisse that all ships must sail in water, we would never have created rocket ships. "
                    },
                    {
                        "username": "d4mir",
                        "content": "I guess logic and understanding the function and being able to work without using it. The same with in-built quicksort in Java (Arrays.sort()), we have it in the standard library, but we still learn it in the course as well as other sortings."
                    },
                    {
                        "username": "kuelf",
                        "content": "It\\'s a challenge "
                    },
                    {
                        "username": "niklas5559",
                        "content": "Python3\\nFeel free to ask questions if the code is too complex\\n\\n`return int(x ** 0.5)`"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "I don\\'t get it. You can still just make it 1 line in Java without using an exponent operator (nor importing any library).\\n```\\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\\n```"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My questions : Did you read the description carrefully?"
                    },
                    {
                        "username": "nodejk",
                        "content": "fyi for all the people who take things way too seriously, this is a joke."
                    },
                    {
                        "username": "milii048_leetcode",
                        "content": "Man, you must think you\\'re special right? Read the rules of the question before you post something dumb like this"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "dumbest answer ever"
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@mihir2310](/mihir2310) \\nYou are correct. I am not certain, but OP may be criticizing the fact that the auto-grader cannot detect that you are violating those rules. That, or they didn\\'t read the rules and are a bit too snarky. Or the problem statement changed over time."
                    },
                    {
                        "username": "mihir2310",
                        "content": "they said you can\\'t use that ** operation"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "\\tif (x <= 1) return x;\\n\\tlong i = 1;\\n\\tlong sq = i * i;\\n\\twhile (x >= sq) {\\n\\t\\ti++;\\n\\t\\tsq = i * i;\\n\\t}\\n\\treturn (int) (i - 1);"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "```\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\n```"
                    },
                    {
                        "username": "Gilbertttt",
                        "content": "Please can you break this down i\\'m having trouble understanding this\\n"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "BOOM baby! This is it. After Googling and reviewing the definition of square root, I came to the same solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "SeraphNiu",
                        "content": "![image](https://assets.leetcode.com/users/images/4d8f6ebd-d3a8-4cd7-8223-7ff4ecb2de52_1628032236.8164496.png)\\n"
                    },
                    {
                        "username": "itmevic",
                        "content": "why are u posting solution here? do u know how to read?"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "How are you using the value of \\'lo\\' without initialising it first?"
                    },
                    {
                        "username": "hu.cao1",
                        "content": "that will make sense. How do you expect the sqrt of 2 is  integer too?"
                    },
                    {
                        "username": "chinmayjain096",
                        "content": "but in question they mention about the integer value of number not the decimal of number.\\nu can right code also too get precious ans put which decimal u want in vs code/any compiler"
                    },
                    {
                        "username": "AbhiLeet",
                        "content": "May be I am missing something here, but the upper bound on the srqrt(x)  for any positive integer x cannot be more that x/2   (in fact its x/2 ONLY for number from 4-8) for any integer > 8, the upper bound on the sqrt is strictly < x/2.   So that makes me wonder - why are so many folks taking such a huge upper bound (INT_MX) for this problem ?"
                    },
                    {
                        "username": "artofhuman",
                        "content": "In binary search it saves one operation, it does not matter "
                    },
                    {
                        "username": "shubhamkeshari04",
                        "content": "why i m getting wrong answer for input x=2147395599\\n pls help"
                    },
                    {
                        "username": "stardust-skg",
                        "content": "[@rglamazda](/rglamazda) It\\'s better to use int properly :) "
                    },
                    {
                        "username": "Kromydas",
                        "content": "as [@rglamazda] has said, use long. A even better ideal is to use long long. And watch out for x = 0, and use while loops. (they are better in this scenario because they are conditional on different things, easier for beginners). It also makes your code slightly faster depending on what conditions you put in a for loop"
                    },
                    {
                        "username": "TheoW03",
                        "content": "[@TheoW03](/TheoW03) exactly. not 46369\\n"
                    },
                    {
                        "username": "TheoW03",
                        "content": "no its right the sqrt of (2147395599) is 46340"
                    },
                    {
                        "username": "Dest1ni",
                        "content": "This is a great beginner question, however the addition of values such as 2147395600 which cause an integer overflow take away from spirit of the question which is to find the algorithm.\\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm.\\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "rglamazda",
                        "content": "try to use long instead int"
                    },
                    {
                        "username": "user2354Mw",
                        "content": "\\tr = x\\n\\n\\tif x == 0:\\n\\t\\treturn 0\\n\\n\\tfor i in range(20):\\n\\t\\tr = (r + x / r) / 2\\n\\n\\treturn math.floor(r)"
                    },
                    {
                        "username": "anish_kr23",
                        "content": "[@nguyentuan67](/nguyentuan67)  i also not understand why he uses like this function.??????\\n"
                    },
                    {
                        "username": "d4mir",
                        "content": "[@nguyentuan67](/nguyentuan67) It\\'s a Newton-Raphson method"
                    },
                    {
                        "username": "wangchao426",
                        "content": "[@nguyentuan67](/nguyentuan67) ordinary least squares"
                    },
                    {
                        "username": "nguyentuan67",
                        "content": "why r = (r + x / r) / 2 ? i don\\'t understand."
                    },
                    {
                        "username": "waerte",
                        "content": "Kindly provide hint for implementing your own sqrt.\\nthanks!"
                    },
                    {
                        "username": "NerdPai",
                        "content": "https://en.wikipedia.org/wiki/Newton%27s_method"
                    }
                ]
            },
            {
                "id": 1570842,
                "content": [
                    {
                        "username": "onedaywillmake",
                        "content": "This is a great beginner question, however the addition of values such as `2147395600` which cause an integer overflow take away from spirit of the question which is to find the algorithm. \\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm. \\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Questions is labelled \"easy\"\\nHas dumb and frustrating edge cases to handle\\nOk, I might be dumb but it\\'s seems like I am not the only one complaining..."
                    },
                    {
                        "username": "md_isa",
                        "content": "Totally agree with you. Took the fun out of it as I had to return separately for 0 and 1, as x+1 which was my right bound for edge case like 1, also overflowed and turned into negative."
                    },
                    {
                        "username": "tka8edd",
                        "content": "if you are solving it in O(n), you don\\'t need to cast to long and there is no overflow."
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "agree with you"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah its frustating when overflow happens and also it isnt mentioned in problem for beginners!!"
                    },
                    {
                        "username": "10alan0712",
                        "content": "fiercely upvote"
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "[@jiayipaulwang](/jiayipaulwang) However, my solution is too add \"break\" within the loop when you find the desired answer."
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "why there\\'s an integer overflow issue? I thought that wasn\\'t a thing in python"
                    },
                    {
                        "username": "mkohar",
                        "content": "\\n[@SeaShanty](/SeaShanty).  [@onedaywillmake](/onedaywillmake)\\nHow to bypass overflow without using long? Try this:\\n1. use:  mid = low +(high-low)//2. \\n instead of mid =(high+low)//2\\n\\n2. Use   if(mid==x/mid) return mid\\n  instead of:   if(mid*mid==x)\\n\\nsmall things like this go long way in interview \\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": "typedef long long ll;\\nuse this simple easy"
                    },
                    {
                        "username": "valer0n3",
                        "content": "[@SeaShanty](/SeaShanty) Just consider that the solution can\\'t be more than x/2. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "OMG thank u so much for letting me know this was a case of integer overflow. I was stuck on this testcase and was making changes in my code multiple times thinking my approach was wrong. My approach works well for smaller testcases. How to handle the  214739500 testcase? Thank you "
                    },
                    {
                        "username": "Twitnithegirl",
                        "content": "\"You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\"\\n\\nWhat is the practical application of not using the standard library of the language you work in?"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "You\\'re so right. You should say that to the interviewer."
                    },
                    {
                        "username": "mepradeepkr",
                        "content": "Agree!!Bro"
                    },
                    {
                        "username": "h4ytham",
                        "content": "[@martynov-94](/martynov-94) well why would you bench press in a warehouse? You\\'re \"in a warehouse\" (using python) so bench pressing is redundant"
                    },
                    {
                        "username": "martynov-94",
                        "content": "Why bench press in the gym when you can just use a forklift?"
                    },
                    {
                        "username": "__Simamina__",
                        "content": "They say you can\\'t use it but you actually can(like, what the heck)"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "To understand how someone implemented the standard library you are sitting on. So you can improve as a coder knowing how something is behind the curtains and to have more knowledge to extend the default/standard of things. If we all took as a premisse that all ships must sail in water, we would never have created rocket ships. "
                    },
                    {
                        "username": "d4mir",
                        "content": "I guess logic and understanding the function and being able to work without using it. The same with in-built quicksort in Java (Arrays.sort()), we have it in the standard library, but we still learn it in the course as well as other sortings."
                    },
                    {
                        "username": "kuelf",
                        "content": "It\\'s a challenge "
                    },
                    {
                        "username": "niklas5559",
                        "content": "Python3\\nFeel free to ask questions if the code is too complex\\n\\n`return int(x ** 0.5)`"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "I don\\'t get it. You can still just make it 1 line in Java without using an exponent operator (nor importing any library).\\n```\\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\\n```"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My questions : Did you read the description carrefully?"
                    },
                    {
                        "username": "nodejk",
                        "content": "fyi for all the people who take things way too seriously, this is a joke."
                    },
                    {
                        "username": "milii048_leetcode",
                        "content": "Man, you must think you\\'re special right? Read the rules of the question before you post something dumb like this"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "dumbest answer ever"
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@mihir2310](/mihir2310) \\nYou are correct. I am not certain, but OP may be criticizing the fact that the auto-grader cannot detect that you are violating those rules. That, or they didn\\'t read the rules and are a bit too snarky. Or the problem statement changed over time."
                    },
                    {
                        "username": "mihir2310",
                        "content": "they said you can\\'t use that ** operation"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "\\tif (x <= 1) return x;\\n\\tlong i = 1;\\n\\tlong sq = i * i;\\n\\twhile (x >= sq) {\\n\\t\\ti++;\\n\\t\\tsq = i * i;\\n\\t}\\n\\treturn (int) (i - 1);"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "```\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\n```"
                    },
                    {
                        "username": "Gilbertttt",
                        "content": "Please can you break this down i\\'m having trouble understanding this\\n"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "BOOM baby! This is it. After Googling and reviewing the definition of square root, I came to the same solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "SeraphNiu",
                        "content": "![image](https://assets.leetcode.com/users/images/4d8f6ebd-d3a8-4cd7-8223-7ff4ecb2de52_1628032236.8164496.png)\\n"
                    },
                    {
                        "username": "itmevic",
                        "content": "why are u posting solution here? do u know how to read?"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "How are you using the value of \\'lo\\' without initialising it first?"
                    },
                    {
                        "username": "hu.cao1",
                        "content": "that will make sense. How do you expect the sqrt of 2 is  integer too?"
                    },
                    {
                        "username": "chinmayjain096",
                        "content": "but in question they mention about the integer value of number not the decimal of number.\\nu can right code also too get precious ans put which decimal u want in vs code/any compiler"
                    },
                    {
                        "username": "AbhiLeet",
                        "content": "May be I am missing something here, but the upper bound on the srqrt(x)  for any positive integer x cannot be more that x/2   (in fact its x/2 ONLY for number from 4-8) for any integer > 8, the upper bound on the sqrt is strictly < x/2.   So that makes me wonder - why are so many folks taking such a huge upper bound (INT_MX) for this problem ?"
                    },
                    {
                        "username": "artofhuman",
                        "content": "In binary search it saves one operation, it does not matter "
                    },
                    {
                        "username": "shubhamkeshari04",
                        "content": "why i m getting wrong answer for input x=2147395599\\n pls help"
                    },
                    {
                        "username": "stardust-skg",
                        "content": "[@rglamazda](/rglamazda) It\\'s better to use int properly :) "
                    },
                    {
                        "username": "Kromydas",
                        "content": "as [@rglamazda] has said, use long. A even better ideal is to use long long. And watch out for x = 0, and use while loops. (they are better in this scenario because they are conditional on different things, easier for beginners). It also makes your code slightly faster depending on what conditions you put in a for loop"
                    },
                    {
                        "username": "TheoW03",
                        "content": "[@TheoW03](/TheoW03) exactly. not 46369\\n"
                    },
                    {
                        "username": "TheoW03",
                        "content": "no its right the sqrt of (2147395599) is 46340"
                    },
                    {
                        "username": "Dest1ni",
                        "content": "This is a great beginner question, however the addition of values such as 2147395600 which cause an integer overflow take away from spirit of the question which is to find the algorithm.\\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm.\\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "rglamazda",
                        "content": "try to use long instead int"
                    },
                    {
                        "username": "user2354Mw",
                        "content": "\\tr = x\\n\\n\\tif x == 0:\\n\\t\\treturn 0\\n\\n\\tfor i in range(20):\\n\\t\\tr = (r + x / r) / 2\\n\\n\\treturn math.floor(r)"
                    },
                    {
                        "username": "anish_kr23",
                        "content": "[@nguyentuan67](/nguyentuan67)  i also not understand why he uses like this function.??????\\n"
                    },
                    {
                        "username": "d4mir",
                        "content": "[@nguyentuan67](/nguyentuan67) It\\'s a Newton-Raphson method"
                    },
                    {
                        "username": "wangchao426",
                        "content": "[@nguyentuan67](/nguyentuan67) ordinary least squares"
                    },
                    {
                        "username": "nguyentuan67",
                        "content": "why r = (r + x / r) / 2 ? i don\\'t understand."
                    },
                    {
                        "username": "waerte",
                        "content": "Kindly provide hint for implementing your own sqrt.\\nthanks!"
                    },
                    {
                        "username": "NerdPai",
                        "content": "https://en.wikipedia.org/wiki/Newton%27s_method"
                    }
                ]
            },
            {
                "id": 1575948,
                "content": [
                    {
                        "username": "onedaywillmake",
                        "content": "This is a great beginner question, however the addition of values such as `2147395600` which cause an integer overflow take away from spirit of the question which is to find the algorithm. \\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm. \\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Questions is labelled \"easy\"\\nHas dumb and frustrating edge cases to handle\\nOk, I might be dumb but it\\'s seems like I am not the only one complaining..."
                    },
                    {
                        "username": "md_isa",
                        "content": "Totally agree with you. Took the fun out of it as I had to return separately for 0 and 1, as x+1 which was my right bound for edge case like 1, also overflowed and turned into negative."
                    },
                    {
                        "username": "tka8edd",
                        "content": "if you are solving it in O(n), you don\\'t need to cast to long and there is no overflow."
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "agree with you"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah its frustating when overflow happens and also it isnt mentioned in problem for beginners!!"
                    },
                    {
                        "username": "10alan0712",
                        "content": "fiercely upvote"
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "[@jiayipaulwang](/jiayipaulwang) However, my solution is too add \"break\" within the loop when you find the desired answer."
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "why there\\'s an integer overflow issue? I thought that wasn\\'t a thing in python"
                    },
                    {
                        "username": "mkohar",
                        "content": "\\n[@SeaShanty](/SeaShanty).  [@onedaywillmake](/onedaywillmake)\\nHow to bypass overflow without using long? Try this:\\n1. use:  mid = low +(high-low)//2. \\n instead of mid =(high+low)//2\\n\\n2. Use   if(mid==x/mid) return mid\\n  instead of:   if(mid*mid==x)\\n\\nsmall things like this go long way in interview \\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": "typedef long long ll;\\nuse this simple easy"
                    },
                    {
                        "username": "valer0n3",
                        "content": "[@SeaShanty](/SeaShanty) Just consider that the solution can\\'t be more than x/2. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "OMG thank u so much for letting me know this was a case of integer overflow. I was stuck on this testcase and was making changes in my code multiple times thinking my approach was wrong. My approach works well for smaller testcases. How to handle the  214739500 testcase? Thank you "
                    },
                    {
                        "username": "Twitnithegirl",
                        "content": "\"You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\"\\n\\nWhat is the practical application of not using the standard library of the language you work in?"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "You\\'re so right. You should say that to the interviewer."
                    },
                    {
                        "username": "mepradeepkr",
                        "content": "Agree!!Bro"
                    },
                    {
                        "username": "h4ytham",
                        "content": "[@martynov-94](/martynov-94) well why would you bench press in a warehouse? You\\'re \"in a warehouse\" (using python) so bench pressing is redundant"
                    },
                    {
                        "username": "martynov-94",
                        "content": "Why bench press in the gym when you can just use a forklift?"
                    },
                    {
                        "username": "__Simamina__",
                        "content": "They say you can\\'t use it but you actually can(like, what the heck)"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "To understand how someone implemented the standard library you are sitting on. So you can improve as a coder knowing how something is behind the curtains and to have more knowledge to extend the default/standard of things. If we all took as a premisse that all ships must sail in water, we would never have created rocket ships. "
                    },
                    {
                        "username": "d4mir",
                        "content": "I guess logic and understanding the function and being able to work without using it. The same with in-built quicksort in Java (Arrays.sort()), we have it in the standard library, but we still learn it in the course as well as other sortings."
                    },
                    {
                        "username": "kuelf",
                        "content": "It\\'s a challenge "
                    },
                    {
                        "username": "niklas5559",
                        "content": "Python3\\nFeel free to ask questions if the code is too complex\\n\\n`return int(x ** 0.5)`"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "I don\\'t get it. You can still just make it 1 line in Java without using an exponent operator (nor importing any library).\\n```\\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\\n```"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My questions : Did you read the description carrefully?"
                    },
                    {
                        "username": "nodejk",
                        "content": "fyi for all the people who take things way too seriously, this is a joke."
                    },
                    {
                        "username": "milii048_leetcode",
                        "content": "Man, you must think you\\'re special right? Read the rules of the question before you post something dumb like this"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "dumbest answer ever"
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@mihir2310](/mihir2310) \\nYou are correct. I am not certain, but OP may be criticizing the fact that the auto-grader cannot detect that you are violating those rules. That, or they didn\\'t read the rules and are a bit too snarky. Or the problem statement changed over time."
                    },
                    {
                        "username": "mihir2310",
                        "content": "they said you can\\'t use that ** operation"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "\\tif (x <= 1) return x;\\n\\tlong i = 1;\\n\\tlong sq = i * i;\\n\\twhile (x >= sq) {\\n\\t\\ti++;\\n\\t\\tsq = i * i;\\n\\t}\\n\\treturn (int) (i - 1);"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "```\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\n```"
                    },
                    {
                        "username": "Gilbertttt",
                        "content": "Please can you break this down i\\'m having trouble understanding this\\n"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "BOOM baby! This is it. After Googling and reviewing the definition of square root, I came to the same solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "SeraphNiu",
                        "content": "![image](https://assets.leetcode.com/users/images/4d8f6ebd-d3a8-4cd7-8223-7ff4ecb2de52_1628032236.8164496.png)\\n"
                    },
                    {
                        "username": "itmevic",
                        "content": "why are u posting solution here? do u know how to read?"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "How are you using the value of \\'lo\\' without initialising it first?"
                    },
                    {
                        "username": "hu.cao1",
                        "content": "that will make sense. How do you expect the sqrt of 2 is  integer too?"
                    },
                    {
                        "username": "chinmayjain096",
                        "content": "but in question they mention about the integer value of number not the decimal of number.\\nu can right code also too get precious ans put which decimal u want in vs code/any compiler"
                    },
                    {
                        "username": "AbhiLeet",
                        "content": "May be I am missing something here, but the upper bound on the srqrt(x)  for any positive integer x cannot be more that x/2   (in fact its x/2 ONLY for number from 4-8) for any integer > 8, the upper bound on the sqrt is strictly < x/2.   So that makes me wonder - why are so many folks taking such a huge upper bound (INT_MX) for this problem ?"
                    },
                    {
                        "username": "artofhuman",
                        "content": "In binary search it saves one operation, it does not matter "
                    },
                    {
                        "username": "shubhamkeshari04",
                        "content": "why i m getting wrong answer for input x=2147395599\\n pls help"
                    },
                    {
                        "username": "stardust-skg",
                        "content": "[@rglamazda](/rglamazda) It\\'s better to use int properly :) "
                    },
                    {
                        "username": "Kromydas",
                        "content": "as [@rglamazda] has said, use long. A even better ideal is to use long long. And watch out for x = 0, and use while loops. (they are better in this scenario because they are conditional on different things, easier for beginners). It also makes your code slightly faster depending on what conditions you put in a for loop"
                    },
                    {
                        "username": "TheoW03",
                        "content": "[@TheoW03](/TheoW03) exactly. not 46369\\n"
                    },
                    {
                        "username": "TheoW03",
                        "content": "no its right the sqrt of (2147395599) is 46340"
                    },
                    {
                        "username": "Dest1ni",
                        "content": "This is a great beginner question, however the addition of values such as 2147395600 which cause an integer overflow take away from spirit of the question which is to find the algorithm.\\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm.\\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "rglamazda",
                        "content": "try to use long instead int"
                    },
                    {
                        "username": "user2354Mw",
                        "content": "\\tr = x\\n\\n\\tif x == 0:\\n\\t\\treturn 0\\n\\n\\tfor i in range(20):\\n\\t\\tr = (r + x / r) / 2\\n\\n\\treturn math.floor(r)"
                    },
                    {
                        "username": "anish_kr23",
                        "content": "[@nguyentuan67](/nguyentuan67)  i also not understand why he uses like this function.??????\\n"
                    },
                    {
                        "username": "d4mir",
                        "content": "[@nguyentuan67](/nguyentuan67) It\\'s a Newton-Raphson method"
                    },
                    {
                        "username": "wangchao426",
                        "content": "[@nguyentuan67](/nguyentuan67) ordinary least squares"
                    },
                    {
                        "username": "nguyentuan67",
                        "content": "why r = (r + x / r) / 2 ? i don\\'t understand."
                    },
                    {
                        "username": "waerte",
                        "content": "Kindly provide hint for implementing your own sqrt.\\nthanks!"
                    },
                    {
                        "username": "NerdPai",
                        "content": "https://en.wikipedia.org/wiki/Newton%27s_method"
                    }
                ]
            },
            {
                "id": 1573187,
                "content": [
                    {
                        "username": "onedaywillmake",
                        "content": "This is a great beginner question, however the addition of values such as `2147395600` which cause an integer overflow take away from spirit of the question which is to find the algorithm. \\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm. \\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Questions is labelled \"easy\"\\nHas dumb and frustrating edge cases to handle\\nOk, I might be dumb but it\\'s seems like I am not the only one complaining..."
                    },
                    {
                        "username": "md_isa",
                        "content": "Totally agree with you. Took the fun out of it as I had to return separately for 0 and 1, as x+1 which was my right bound for edge case like 1, also overflowed and turned into negative."
                    },
                    {
                        "username": "tka8edd",
                        "content": "if you are solving it in O(n), you don\\'t need to cast to long and there is no overflow."
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "agree with you"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah its frustating when overflow happens and also it isnt mentioned in problem for beginners!!"
                    },
                    {
                        "username": "10alan0712",
                        "content": "fiercely upvote"
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "[@jiayipaulwang](/jiayipaulwang) However, my solution is too add \"break\" within the loop when you find the desired answer."
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "why there\\'s an integer overflow issue? I thought that wasn\\'t a thing in python"
                    },
                    {
                        "username": "mkohar",
                        "content": "\\n[@SeaShanty](/SeaShanty).  [@onedaywillmake](/onedaywillmake)\\nHow to bypass overflow without using long? Try this:\\n1. use:  mid = low +(high-low)//2. \\n instead of mid =(high+low)//2\\n\\n2. Use   if(mid==x/mid) return mid\\n  instead of:   if(mid*mid==x)\\n\\nsmall things like this go long way in interview \\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": "typedef long long ll;\\nuse this simple easy"
                    },
                    {
                        "username": "valer0n3",
                        "content": "[@SeaShanty](/SeaShanty) Just consider that the solution can\\'t be more than x/2. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "OMG thank u so much for letting me know this was a case of integer overflow. I was stuck on this testcase and was making changes in my code multiple times thinking my approach was wrong. My approach works well for smaller testcases. How to handle the  214739500 testcase? Thank you "
                    },
                    {
                        "username": "Twitnithegirl",
                        "content": "\"You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\"\\n\\nWhat is the practical application of not using the standard library of the language you work in?"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "You\\'re so right. You should say that to the interviewer."
                    },
                    {
                        "username": "mepradeepkr",
                        "content": "Agree!!Bro"
                    },
                    {
                        "username": "h4ytham",
                        "content": "[@martynov-94](/martynov-94) well why would you bench press in a warehouse? You\\'re \"in a warehouse\" (using python) so bench pressing is redundant"
                    },
                    {
                        "username": "martynov-94",
                        "content": "Why bench press in the gym when you can just use a forklift?"
                    },
                    {
                        "username": "__Simamina__",
                        "content": "They say you can\\'t use it but you actually can(like, what the heck)"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "To understand how someone implemented the standard library you are sitting on. So you can improve as a coder knowing how something is behind the curtains and to have more knowledge to extend the default/standard of things. If we all took as a premisse that all ships must sail in water, we would never have created rocket ships. "
                    },
                    {
                        "username": "d4mir",
                        "content": "I guess logic and understanding the function and being able to work without using it. The same with in-built quicksort in Java (Arrays.sort()), we have it in the standard library, but we still learn it in the course as well as other sortings."
                    },
                    {
                        "username": "kuelf",
                        "content": "It\\'s a challenge "
                    },
                    {
                        "username": "niklas5559",
                        "content": "Python3\\nFeel free to ask questions if the code is too complex\\n\\n`return int(x ** 0.5)`"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "I don\\'t get it. You can still just make it 1 line in Java without using an exponent operator (nor importing any library).\\n```\\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\\n```"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My questions : Did you read the description carrefully?"
                    },
                    {
                        "username": "nodejk",
                        "content": "fyi for all the people who take things way too seriously, this is a joke."
                    },
                    {
                        "username": "milii048_leetcode",
                        "content": "Man, you must think you\\'re special right? Read the rules of the question before you post something dumb like this"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "dumbest answer ever"
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@mihir2310](/mihir2310) \\nYou are correct. I am not certain, but OP may be criticizing the fact that the auto-grader cannot detect that you are violating those rules. That, or they didn\\'t read the rules and are a bit too snarky. Or the problem statement changed over time."
                    },
                    {
                        "username": "mihir2310",
                        "content": "they said you can\\'t use that ** operation"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "\\tif (x <= 1) return x;\\n\\tlong i = 1;\\n\\tlong sq = i * i;\\n\\twhile (x >= sq) {\\n\\t\\ti++;\\n\\t\\tsq = i * i;\\n\\t}\\n\\treturn (int) (i - 1);"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "```\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\n```"
                    },
                    {
                        "username": "Gilbertttt",
                        "content": "Please can you break this down i\\'m having trouble understanding this\\n"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "BOOM baby! This is it. After Googling and reviewing the definition of square root, I came to the same solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "SeraphNiu",
                        "content": "![image](https://assets.leetcode.com/users/images/4d8f6ebd-d3a8-4cd7-8223-7ff4ecb2de52_1628032236.8164496.png)\\n"
                    },
                    {
                        "username": "itmevic",
                        "content": "why are u posting solution here? do u know how to read?"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "How are you using the value of \\'lo\\' without initialising it first?"
                    },
                    {
                        "username": "hu.cao1",
                        "content": "that will make sense. How do you expect the sqrt of 2 is  integer too?"
                    },
                    {
                        "username": "chinmayjain096",
                        "content": "but in question they mention about the integer value of number not the decimal of number.\\nu can right code also too get precious ans put which decimal u want in vs code/any compiler"
                    },
                    {
                        "username": "AbhiLeet",
                        "content": "May be I am missing something here, but the upper bound on the srqrt(x)  for any positive integer x cannot be more that x/2   (in fact its x/2 ONLY for number from 4-8) for any integer > 8, the upper bound on the sqrt is strictly < x/2.   So that makes me wonder - why are so many folks taking such a huge upper bound (INT_MX) for this problem ?"
                    },
                    {
                        "username": "artofhuman",
                        "content": "In binary search it saves one operation, it does not matter "
                    },
                    {
                        "username": "shubhamkeshari04",
                        "content": "why i m getting wrong answer for input x=2147395599\\n pls help"
                    },
                    {
                        "username": "stardust-skg",
                        "content": "[@rglamazda](/rglamazda) It\\'s better to use int properly :) "
                    },
                    {
                        "username": "Kromydas",
                        "content": "as [@rglamazda] has said, use long. A even better ideal is to use long long. And watch out for x = 0, and use while loops. (they are better in this scenario because they are conditional on different things, easier for beginners). It also makes your code slightly faster depending on what conditions you put in a for loop"
                    },
                    {
                        "username": "TheoW03",
                        "content": "[@TheoW03](/TheoW03) exactly. not 46369\\n"
                    },
                    {
                        "username": "TheoW03",
                        "content": "no its right the sqrt of (2147395599) is 46340"
                    },
                    {
                        "username": "Dest1ni",
                        "content": "This is a great beginner question, however the addition of values such as 2147395600 which cause an integer overflow take away from spirit of the question which is to find the algorithm.\\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm.\\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "rglamazda",
                        "content": "try to use long instead int"
                    },
                    {
                        "username": "user2354Mw",
                        "content": "\\tr = x\\n\\n\\tif x == 0:\\n\\t\\treturn 0\\n\\n\\tfor i in range(20):\\n\\t\\tr = (r + x / r) / 2\\n\\n\\treturn math.floor(r)"
                    },
                    {
                        "username": "anish_kr23",
                        "content": "[@nguyentuan67](/nguyentuan67)  i also not understand why he uses like this function.??????\\n"
                    },
                    {
                        "username": "d4mir",
                        "content": "[@nguyentuan67](/nguyentuan67) It\\'s a Newton-Raphson method"
                    },
                    {
                        "username": "wangchao426",
                        "content": "[@nguyentuan67](/nguyentuan67) ordinary least squares"
                    },
                    {
                        "username": "nguyentuan67",
                        "content": "why r = (r + x / r) / 2 ? i don\\'t understand."
                    },
                    {
                        "username": "waerte",
                        "content": "Kindly provide hint for implementing your own sqrt.\\nthanks!"
                    },
                    {
                        "username": "NerdPai",
                        "content": "https://en.wikipedia.org/wiki/Newton%27s_method"
                    }
                ]
            },
            {
                "id": 1566625,
                "content": [
                    {
                        "username": "onedaywillmake",
                        "content": "This is a great beginner question, however the addition of values such as `2147395600` which cause an integer overflow take away from spirit of the question which is to find the algorithm. \\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm. \\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Questions is labelled \"easy\"\\nHas dumb and frustrating edge cases to handle\\nOk, I might be dumb but it\\'s seems like I am not the only one complaining..."
                    },
                    {
                        "username": "md_isa",
                        "content": "Totally agree with you. Took the fun out of it as I had to return separately for 0 and 1, as x+1 which was my right bound for edge case like 1, also overflowed and turned into negative."
                    },
                    {
                        "username": "tka8edd",
                        "content": "if you are solving it in O(n), you don\\'t need to cast to long and there is no overflow."
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "agree with you"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah its frustating when overflow happens and also it isnt mentioned in problem for beginners!!"
                    },
                    {
                        "username": "10alan0712",
                        "content": "fiercely upvote"
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "[@jiayipaulwang](/jiayipaulwang) However, my solution is too add \"break\" within the loop when you find the desired answer."
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "why there\\'s an integer overflow issue? I thought that wasn\\'t a thing in python"
                    },
                    {
                        "username": "mkohar",
                        "content": "\\n[@SeaShanty](/SeaShanty).  [@onedaywillmake](/onedaywillmake)\\nHow to bypass overflow without using long? Try this:\\n1. use:  mid = low +(high-low)//2. \\n instead of mid =(high+low)//2\\n\\n2. Use   if(mid==x/mid) return mid\\n  instead of:   if(mid*mid==x)\\n\\nsmall things like this go long way in interview \\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": "typedef long long ll;\\nuse this simple easy"
                    },
                    {
                        "username": "valer0n3",
                        "content": "[@SeaShanty](/SeaShanty) Just consider that the solution can\\'t be more than x/2. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "OMG thank u so much for letting me know this was a case of integer overflow. I was stuck on this testcase and was making changes in my code multiple times thinking my approach was wrong. My approach works well for smaller testcases. How to handle the  214739500 testcase? Thank you "
                    },
                    {
                        "username": "Twitnithegirl",
                        "content": "\"You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\"\\n\\nWhat is the practical application of not using the standard library of the language you work in?"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "You\\'re so right. You should say that to the interviewer."
                    },
                    {
                        "username": "mepradeepkr",
                        "content": "Agree!!Bro"
                    },
                    {
                        "username": "h4ytham",
                        "content": "[@martynov-94](/martynov-94) well why would you bench press in a warehouse? You\\'re \"in a warehouse\" (using python) so bench pressing is redundant"
                    },
                    {
                        "username": "martynov-94",
                        "content": "Why bench press in the gym when you can just use a forklift?"
                    },
                    {
                        "username": "__Simamina__",
                        "content": "They say you can\\'t use it but you actually can(like, what the heck)"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "To understand how someone implemented the standard library you are sitting on. So you can improve as a coder knowing how something is behind the curtains and to have more knowledge to extend the default/standard of things. If we all took as a premisse that all ships must sail in water, we would never have created rocket ships. "
                    },
                    {
                        "username": "d4mir",
                        "content": "I guess logic and understanding the function and being able to work without using it. The same with in-built quicksort in Java (Arrays.sort()), we have it in the standard library, but we still learn it in the course as well as other sortings."
                    },
                    {
                        "username": "kuelf",
                        "content": "It\\'s a challenge "
                    },
                    {
                        "username": "niklas5559",
                        "content": "Python3\\nFeel free to ask questions if the code is too complex\\n\\n`return int(x ** 0.5)`"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "I don\\'t get it. You can still just make it 1 line in Java without using an exponent operator (nor importing any library).\\n```\\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\\n```"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My questions : Did you read the description carrefully?"
                    },
                    {
                        "username": "nodejk",
                        "content": "fyi for all the people who take things way too seriously, this is a joke."
                    },
                    {
                        "username": "milii048_leetcode",
                        "content": "Man, you must think you\\'re special right? Read the rules of the question before you post something dumb like this"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "dumbest answer ever"
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@mihir2310](/mihir2310) \\nYou are correct. I am not certain, but OP may be criticizing the fact that the auto-grader cannot detect that you are violating those rules. That, or they didn\\'t read the rules and are a bit too snarky. Or the problem statement changed over time."
                    },
                    {
                        "username": "mihir2310",
                        "content": "they said you can\\'t use that ** operation"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "\\tif (x <= 1) return x;\\n\\tlong i = 1;\\n\\tlong sq = i * i;\\n\\twhile (x >= sq) {\\n\\t\\ti++;\\n\\t\\tsq = i * i;\\n\\t}\\n\\treturn (int) (i - 1);"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "```\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\n```"
                    },
                    {
                        "username": "Gilbertttt",
                        "content": "Please can you break this down i\\'m having trouble understanding this\\n"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "BOOM baby! This is it. After Googling and reviewing the definition of square root, I came to the same solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "SeraphNiu",
                        "content": "![image](https://assets.leetcode.com/users/images/4d8f6ebd-d3a8-4cd7-8223-7ff4ecb2de52_1628032236.8164496.png)\\n"
                    },
                    {
                        "username": "itmevic",
                        "content": "why are u posting solution here? do u know how to read?"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "How are you using the value of \\'lo\\' without initialising it first?"
                    },
                    {
                        "username": "hu.cao1",
                        "content": "that will make sense. How do you expect the sqrt of 2 is  integer too?"
                    },
                    {
                        "username": "chinmayjain096",
                        "content": "but in question they mention about the integer value of number not the decimal of number.\\nu can right code also too get precious ans put which decimal u want in vs code/any compiler"
                    },
                    {
                        "username": "AbhiLeet",
                        "content": "May be I am missing something here, but the upper bound on the srqrt(x)  for any positive integer x cannot be more that x/2   (in fact its x/2 ONLY for number from 4-8) for any integer > 8, the upper bound on the sqrt is strictly < x/2.   So that makes me wonder - why are so many folks taking such a huge upper bound (INT_MX) for this problem ?"
                    },
                    {
                        "username": "artofhuman",
                        "content": "In binary search it saves one operation, it does not matter "
                    },
                    {
                        "username": "shubhamkeshari04",
                        "content": "why i m getting wrong answer for input x=2147395599\\n pls help"
                    },
                    {
                        "username": "stardust-skg",
                        "content": "[@rglamazda](/rglamazda) It\\'s better to use int properly :) "
                    },
                    {
                        "username": "Kromydas",
                        "content": "as [@rglamazda] has said, use long. A even better ideal is to use long long. And watch out for x = 0, and use while loops. (they are better in this scenario because they are conditional on different things, easier for beginners). It also makes your code slightly faster depending on what conditions you put in a for loop"
                    },
                    {
                        "username": "TheoW03",
                        "content": "[@TheoW03](/TheoW03) exactly. not 46369\\n"
                    },
                    {
                        "username": "TheoW03",
                        "content": "no its right the sqrt of (2147395599) is 46340"
                    },
                    {
                        "username": "Dest1ni",
                        "content": "This is a great beginner question, however the addition of values such as 2147395600 which cause an integer overflow take away from spirit of the question which is to find the algorithm.\\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm.\\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "rglamazda",
                        "content": "try to use long instead int"
                    },
                    {
                        "username": "user2354Mw",
                        "content": "\\tr = x\\n\\n\\tif x == 0:\\n\\t\\treturn 0\\n\\n\\tfor i in range(20):\\n\\t\\tr = (r + x / r) / 2\\n\\n\\treturn math.floor(r)"
                    },
                    {
                        "username": "anish_kr23",
                        "content": "[@nguyentuan67](/nguyentuan67)  i also not understand why he uses like this function.??????\\n"
                    },
                    {
                        "username": "d4mir",
                        "content": "[@nguyentuan67](/nguyentuan67) It\\'s a Newton-Raphson method"
                    },
                    {
                        "username": "wangchao426",
                        "content": "[@nguyentuan67](/nguyentuan67) ordinary least squares"
                    },
                    {
                        "username": "nguyentuan67",
                        "content": "why r = (r + x / r) / 2 ? i don\\'t understand."
                    },
                    {
                        "username": "waerte",
                        "content": "Kindly provide hint for implementing your own sqrt.\\nthanks!"
                    },
                    {
                        "username": "NerdPai",
                        "content": "https://en.wikipedia.org/wiki/Newton%27s_method"
                    }
                ]
            },
            {
                "id": 1575605,
                "content": [
                    {
                        "username": "onedaywillmake",
                        "content": "This is a great beginner question, however the addition of values such as `2147395600` which cause an integer overflow take away from spirit of the question which is to find the algorithm. \\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm. \\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Questions is labelled \"easy\"\\nHas dumb and frustrating edge cases to handle\\nOk, I might be dumb but it\\'s seems like I am not the only one complaining..."
                    },
                    {
                        "username": "md_isa",
                        "content": "Totally agree with you. Took the fun out of it as I had to return separately for 0 and 1, as x+1 which was my right bound for edge case like 1, also overflowed and turned into negative."
                    },
                    {
                        "username": "tka8edd",
                        "content": "if you are solving it in O(n), you don\\'t need to cast to long and there is no overflow."
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "agree with you"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah its frustating when overflow happens and also it isnt mentioned in problem for beginners!!"
                    },
                    {
                        "username": "10alan0712",
                        "content": "fiercely upvote"
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "[@jiayipaulwang](/jiayipaulwang) However, my solution is too add \"break\" within the loop when you find the desired answer."
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "why there\\'s an integer overflow issue? I thought that wasn\\'t a thing in python"
                    },
                    {
                        "username": "mkohar",
                        "content": "\\n[@SeaShanty](/SeaShanty).  [@onedaywillmake](/onedaywillmake)\\nHow to bypass overflow without using long? Try this:\\n1. use:  mid = low +(high-low)//2. \\n instead of mid =(high+low)//2\\n\\n2. Use   if(mid==x/mid) return mid\\n  instead of:   if(mid*mid==x)\\n\\nsmall things like this go long way in interview \\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": "typedef long long ll;\\nuse this simple easy"
                    },
                    {
                        "username": "valer0n3",
                        "content": "[@SeaShanty](/SeaShanty) Just consider that the solution can\\'t be more than x/2. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "OMG thank u so much for letting me know this was a case of integer overflow. I was stuck on this testcase and was making changes in my code multiple times thinking my approach was wrong. My approach works well for smaller testcases. How to handle the  214739500 testcase? Thank you "
                    },
                    {
                        "username": "Twitnithegirl",
                        "content": "\"You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\"\\n\\nWhat is the practical application of not using the standard library of the language you work in?"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "You\\'re so right. You should say that to the interviewer."
                    },
                    {
                        "username": "mepradeepkr",
                        "content": "Agree!!Bro"
                    },
                    {
                        "username": "h4ytham",
                        "content": "[@martynov-94](/martynov-94) well why would you bench press in a warehouse? You\\'re \"in a warehouse\" (using python) so bench pressing is redundant"
                    },
                    {
                        "username": "martynov-94",
                        "content": "Why bench press in the gym when you can just use a forklift?"
                    },
                    {
                        "username": "__Simamina__",
                        "content": "They say you can\\'t use it but you actually can(like, what the heck)"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "To understand how someone implemented the standard library you are sitting on. So you can improve as a coder knowing how something is behind the curtains and to have more knowledge to extend the default/standard of things. If we all took as a premisse that all ships must sail in water, we would never have created rocket ships. "
                    },
                    {
                        "username": "d4mir",
                        "content": "I guess logic and understanding the function and being able to work without using it. The same with in-built quicksort in Java (Arrays.sort()), we have it in the standard library, but we still learn it in the course as well as other sortings."
                    },
                    {
                        "username": "kuelf",
                        "content": "It\\'s a challenge "
                    },
                    {
                        "username": "niklas5559",
                        "content": "Python3\\nFeel free to ask questions if the code is too complex\\n\\n`return int(x ** 0.5)`"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "I don\\'t get it. You can still just make it 1 line in Java without using an exponent operator (nor importing any library).\\n```\\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\\n```"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My questions : Did you read the description carrefully?"
                    },
                    {
                        "username": "nodejk",
                        "content": "fyi for all the people who take things way too seriously, this is a joke."
                    },
                    {
                        "username": "milii048_leetcode",
                        "content": "Man, you must think you\\'re special right? Read the rules of the question before you post something dumb like this"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "dumbest answer ever"
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@mihir2310](/mihir2310) \\nYou are correct. I am not certain, but OP may be criticizing the fact that the auto-grader cannot detect that you are violating those rules. That, or they didn\\'t read the rules and are a bit too snarky. Or the problem statement changed over time."
                    },
                    {
                        "username": "mihir2310",
                        "content": "they said you can\\'t use that ** operation"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "\\tif (x <= 1) return x;\\n\\tlong i = 1;\\n\\tlong sq = i * i;\\n\\twhile (x >= sq) {\\n\\t\\ti++;\\n\\t\\tsq = i * i;\\n\\t}\\n\\treturn (int) (i - 1);"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "```\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\n```"
                    },
                    {
                        "username": "Gilbertttt",
                        "content": "Please can you break this down i\\'m having trouble understanding this\\n"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "BOOM baby! This is it. After Googling and reviewing the definition of square root, I came to the same solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "SeraphNiu",
                        "content": "![image](https://assets.leetcode.com/users/images/4d8f6ebd-d3a8-4cd7-8223-7ff4ecb2de52_1628032236.8164496.png)\\n"
                    },
                    {
                        "username": "itmevic",
                        "content": "why are u posting solution here? do u know how to read?"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "How are you using the value of \\'lo\\' without initialising it first?"
                    },
                    {
                        "username": "hu.cao1",
                        "content": "that will make sense. How do you expect the sqrt of 2 is  integer too?"
                    },
                    {
                        "username": "chinmayjain096",
                        "content": "but in question they mention about the integer value of number not the decimal of number.\\nu can right code also too get precious ans put which decimal u want in vs code/any compiler"
                    },
                    {
                        "username": "AbhiLeet",
                        "content": "May be I am missing something here, but the upper bound on the srqrt(x)  for any positive integer x cannot be more that x/2   (in fact its x/2 ONLY for number from 4-8) for any integer > 8, the upper bound on the sqrt is strictly < x/2.   So that makes me wonder - why are so many folks taking such a huge upper bound (INT_MX) for this problem ?"
                    },
                    {
                        "username": "artofhuman",
                        "content": "In binary search it saves one operation, it does not matter "
                    },
                    {
                        "username": "shubhamkeshari04",
                        "content": "why i m getting wrong answer for input x=2147395599\\n pls help"
                    },
                    {
                        "username": "stardust-skg",
                        "content": "[@rglamazda](/rglamazda) It\\'s better to use int properly :) "
                    },
                    {
                        "username": "Kromydas",
                        "content": "as [@rglamazda] has said, use long. A even better ideal is to use long long. And watch out for x = 0, and use while loops. (they are better in this scenario because they are conditional on different things, easier for beginners). It also makes your code slightly faster depending on what conditions you put in a for loop"
                    },
                    {
                        "username": "TheoW03",
                        "content": "[@TheoW03](/TheoW03) exactly. not 46369\\n"
                    },
                    {
                        "username": "TheoW03",
                        "content": "no its right the sqrt of (2147395599) is 46340"
                    },
                    {
                        "username": "Dest1ni",
                        "content": "This is a great beginner question, however the addition of values such as 2147395600 which cause an integer overflow take away from spirit of the question which is to find the algorithm.\\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm.\\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "rglamazda",
                        "content": "try to use long instead int"
                    },
                    {
                        "username": "user2354Mw",
                        "content": "\\tr = x\\n\\n\\tif x == 0:\\n\\t\\treturn 0\\n\\n\\tfor i in range(20):\\n\\t\\tr = (r + x / r) / 2\\n\\n\\treturn math.floor(r)"
                    },
                    {
                        "username": "anish_kr23",
                        "content": "[@nguyentuan67](/nguyentuan67)  i also not understand why he uses like this function.??????\\n"
                    },
                    {
                        "username": "d4mir",
                        "content": "[@nguyentuan67](/nguyentuan67) It\\'s a Newton-Raphson method"
                    },
                    {
                        "username": "wangchao426",
                        "content": "[@nguyentuan67](/nguyentuan67) ordinary least squares"
                    },
                    {
                        "username": "nguyentuan67",
                        "content": "why r = (r + x / r) / 2 ? i don\\'t understand."
                    },
                    {
                        "username": "waerte",
                        "content": "Kindly provide hint for implementing your own sqrt.\\nthanks!"
                    },
                    {
                        "username": "NerdPai",
                        "content": "https://en.wikipedia.org/wiki/Newton%27s_method"
                    }
                ]
            },
            {
                "id": 1565250,
                "content": [
                    {
                        "username": "onedaywillmake",
                        "content": "This is a great beginner question, however the addition of values such as `2147395600` which cause an integer overflow take away from spirit of the question which is to find the algorithm. \\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm. \\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Questions is labelled \"easy\"\\nHas dumb and frustrating edge cases to handle\\nOk, I might be dumb but it\\'s seems like I am not the only one complaining..."
                    },
                    {
                        "username": "md_isa",
                        "content": "Totally agree with you. Took the fun out of it as I had to return separately for 0 and 1, as x+1 which was my right bound for edge case like 1, also overflowed and turned into negative."
                    },
                    {
                        "username": "tka8edd",
                        "content": "if you are solving it in O(n), you don\\'t need to cast to long and there is no overflow."
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "agree with you"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah its frustating when overflow happens and also it isnt mentioned in problem for beginners!!"
                    },
                    {
                        "username": "10alan0712",
                        "content": "fiercely upvote"
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "[@jiayipaulwang](/jiayipaulwang) However, my solution is too add \"break\" within the loop when you find the desired answer."
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "why there\\'s an integer overflow issue? I thought that wasn\\'t a thing in python"
                    },
                    {
                        "username": "mkohar",
                        "content": "\\n[@SeaShanty](/SeaShanty).  [@onedaywillmake](/onedaywillmake)\\nHow to bypass overflow without using long? Try this:\\n1. use:  mid = low +(high-low)//2. \\n instead of mid =(high+low)//2\\n\\n2. Use   if(mid==x/mid) return mid\\n  instead of:   if(mid*mid==x)\\n\\nsmall things like this go long way in interview \\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": "typedef long long ll;\\nuse this simple easy"
                    },
                    {
                        "username": "valer0n3",
                        "content": "[@SeaShanty](/SeaShanty) Just consider that the solution can\\'t be more than x/2. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "OMG thank u so much for letting me know this was a case of integer overflow. I was stuck on this testcase and was making changes in my code multiple times thinking my approach was wrong. My approach works well for smaller testcases. How to handle the  214739500 testcase? Thank you "
                    },
                    {
                        "username": "Twitnithegirl",
                        "content": "\"You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\"\\n\\nWhat is the practical application of not using the standard library of the language you work in?"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "You\\'re so right. You should say that to the interviewer."
                    },
                    {
                        "username": "mepradeepkr",
                        "content": "Agree!!Bro"
                    },
                    {
                        "username": "h4ytham",
                        "content": "[@martynov-94](/martynov-94) well why would you bench press in a warehouse? You\\'re \"in a warehouse\" (using python) so bench pressing is redundant"
                    },
                    {
                        "username": "martynov-94",
                        "content": "Why bench press in the gym when you can just use a forklift?"
                    },
                    {
                        "username": "__Simamina__",
                        "content": "They say you can\\'t use it but you actually can(like, what the heck)"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "To understand how someone implemented the standard library you are sitting on. So you can improve as a coder knowing how something is behind the curtains and to have more knowledge to extend the default/standard of things. If we all took as a premisse that all ships must sail in water, we would never have created rocket ships. "
                    },
                    {
                        "username": "d4mir",
                        "content": "I guess logic and understanding the function and being able to work without using it. The same with in-built quicksort in Java (Arrays.sort()), we have it in the standard library, but we still learn it in the course as well as other sortings."
                    },
                    {
                        "username": "kuelf",
                        "content": "It\\'s a challenge "
                    },
                    {
                        "username": "niklas5559",
                        "content": "Python3\\nFeel free to ask questions if the code is too complex\\n\\n`return int(x ** 0.5)`"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "I don\\'t get it. You can still just make it 1 line in Java without using an exponent operator (nor importing any library).\\n```\\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\\n```"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My questions : Did you read the description carrefully?"
                    },
                    {
                        "username": "nodejk",
                        "content": "fyi for all the people who take things way too seriously, this is a joke."
                    },
                    {
                        "username": "milii048_leetcode",
                        "content": "Man, you must think you\\'re special right? Read the rules of the question before you post something dumb like this"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "dumbest answer ever"
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@mihir2310](/mihir2310) \\nYou are correct. I am not certain, but OP may be criticizing the fact that the auto-grader cannot detect that you are violating those rules. That, or they didn\\'t read the rules and are a bit too snarky. Or the problem statement changed over time."
                    },
                    {
                        "username": "mihir2310",
                        "content": "they said you can\\'t use that ** operation"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "\\tif (x <= 1) return x;\\n\\tlong i = 1;\\n\\tlong sq = i * i;\\n\\twhile (x >= sq) {\\n\\t\\ti++;\\n\\t\\tsq = i * i;\\n\\t}\\n\\treturn (int) (i - 1);"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "```\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\n```"
                    },
                    {
                        "username": "Gilbertttt",
                        "content": "Please can you break this down i\\'m having trouble understanding this\\n"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "BOOM baby! This is it. After Googling and reviewing the definition of square root, I came to the same solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "SeraphNiu",
                        "content": "![image](https://assets.leetcode.com/users/images/4d8f6ebd-d3a8-4cd7-8223-7ff4ecb2de52_1628032236.8164496.png)\\n"
                    },
                    {
                        "username": "itmevic",
                        "content": "why are u posting solution here? do u know how to read?"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "How are you using the value of \\'lo\\' without initialising it first?"
                    },
                    {
                        "username": "hu.cao1",
                        "content": "that will make sense. How do you expect the sqrt of 2 is  integer too?"
                    },
                    {
                        "username": "chinmayjain096",
                        "content": "but in question they mention about the integer value of number not the decimal of number.\\nu can right code also too get precious ans put which decimal u want in vs code/any compiler"
                    },
                    {
                        "username": "AbhiLeet",
                        "content": "May be I am missing something here, but the upper bound on the srqrt(x)  for any positive integer x cannot be more that x/2   (in fact its x/2 ONLY for number from 4-8) for any integer > 8, the upper bound on the sqrt is strictly < x/2.   So that makes me wonder - why are so many folks taking such a huge upper bound (INT_MX) for this problem ?"
                    },
                    {
                        "username": "artofhuman",
                        "content": "In binary search it saves one operation, it does not matter "
                    },
                    {
                        "username": "shubhamkeshari04",
                        "content": "why i m getting wrong answer for input x=2147395599\\n pls help"
                    },
                    {
                        "username": "stardust-skg",
                        "content": "[@rglamazda](/rglamazda) It\\'s better to use int properly :) "
                    },
                    {
                        "username": "Kromydas",
                        "content": "as [@rglamazda] has said, use long. A even better ideal is to use long long. And watch out for x = 0, and use while loops. (they are better in this scenario because they are conditional on different things, easier for beginners). It also makes your code slightly faster depending on what conditions you put in a for loop"
                    },
                    {
                        "username": "TheoW03",
                        "content": "[@TheoW03](/TheoW03) exactly. not 46369\\n"
                    },
                    {
                        "username": "TheoW03",
                        "content": "no its right the sqrt of (2147395599) is 46340"
                    },
                    {
                        "username": "Dest1ni",
                        "content": "This is a great beginner question, however the addition of values such as 2147395600 which cause an integer overflow take away from spirit of the question which is to find the algorithm.\\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm.\\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "rglamazda",
                        "content": "try to use long instead int"
                    },
                    {
                        "username": "user2354Mw",
                        "content": "\\tr = x\\n\\n\\tif x == 0:\\n\\t\\treturn 0\\n\\n\\tfor i in range(20):\\n\\t\\tr = (r + x / r) / 2\\n\\n\\treturn math.floor(r)"
                    },
                    {
                        "username": "anish_kr23",
                        "content": "[@nguyentuan67](/nguyentuan67)  i also not understand why he uses like this function.??????\\n"
                    },
                    {
                        "username": "d4mir",
                        "content": "[@nguyentuan67](/nguyentuan67) It\\'s a Newton-Raphson method"
                    },
                    {
                        "username": "wangchao426",
                        "content": "[@nguyentuan67](/nguyentuan67) ordinary least squares"
                    },
                    {
                        "username": "nguyentuan67",
                        "content": "why r = (r + x / r) / 2 ? i don\\'t understand."
                    },
                    {
                        "username": "waerte",
                        "content": "Kindly provide hint for implementing your own sqrt.\\nthanks!"
                    },
                    {
                        "username": "NerdPai",
                        "content": "https://en.wikipedia.org/wiki/Newton%27s_method"
                    }
                ]
            },
            {
                "id": 1568890,
                "content": [
                    {
                        "username": "onedaywillmake",
                        "content": "This is a great beginner question, however the addition of values such as `2147395600` which cause an integer overflow take away from spirit of the question which is to find the algorithm. \\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm. \\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Questions is labelled \"easy\"\\nHas dumb and frustrating edge cases to handle\\nOk, I might be dumb but it\\'s seems like I am not the only one complaining..."
                    },
                    {
                        "username": "md_isa",
                        "content": "Totally agree with you. Took the fun out of it as I had to return separately for 0 and 1, as x+1 which was my right bound for edge case like 1, also overflowed and turned into negative."
                    },
                    {
                        "username": "tka8edd",
                        "content": "if you are solving it in O(n), you don\\'t need to cast to long and there is no overflow."
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "agree with you"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah its frustating when overflow happens and also it isnt mentioned in problem for beginners!!"
                    },
                    {
                        "username": "10alan0712",
                        "content": "fiercely upvote"
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "[@jiayipaulwang](/jiayipaulwang) However, my solution is too add \"break\" within the loop when you find the desired answer."
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "why there\\'s an integer overflow issue? I thought that wasn\\'t a thing in python"
                    },
                    {
                        "username": "mkohar",
                        "content": "\\n[@SeaShanty](/SeaShanty).  [@onedaywillmake](/onedaywillmake)\\nHow to bypass overflow without using long? Try this:\\n1. use:  mid = low +(high-low)//2. \\n instead of mid =(high+low)//2\\n\\n2. Use   if(mid==x/mid) return mid\\n  instead of:   if(mid*mid==x)\\n\\nsmall things like this go long way in interview \\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": "typedef long long ll;\\nuse this simple easy"
                    },
                    {
                        "username": "valer0n3",
                        "content": "[@SeaShanty](/SeaShanty) Just consider that the solution can\\'t be more than x/2. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "OMG thank u so much for letting me know this was a case of integer overflow. I was stuck on this testcase and was making changes in my code multiple times thinking my approach was wrong. My approach works well for smaller testcases. How to handle the  214739500 testcase? Thank you "
                    },
                    {
                        "username": "Twitnithegirl",
                        "content": "\"You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\"\\n\\nWhat is the practical application of not using the standard library of the language you work in?"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "You\\'re so right. You should say that to the interviewer."
                    },
                    {
                        "username": "mepradeepkr",
                        "content": "Agree!!Bro"
                    },
                    {
                        "username": "h4ytham",
                        "content": "[@martynov-94](/martynov-94) well why would you bench press in a warehouse? You\\'re \"in a warehouse\" (using python) so bench pressing is redundant"
                    },
                    {
                        "username": "martynov-94",
                        "content": "Why bench press in the gym when you can just use a forklift?"
                    },
                    {
                        "username": "__Simamina__",
                        "content": "They say you can\\'t use it but you actually can(like, what the heck)"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "To understand how someone implemented the standard library you are sitting on. So you can improve as a coder knowing how something is behind the curtains and to have more knowledge to extend the default/standard of things. If we all took as a premisse that all ships must sail in water, we would never have created rocket ships. "
                    },
                    {
                        "username": "d4mir",
                        "content": "I guess logic and understanding the function and being able to work without using it. The same with in-built quicksort in Java (Arrays.sort()), we have it in the standard library, but we still learn it in the course as well as other sortings."
                    },
                    {
                        "username": "kuelf",
                        "content": "It\\'s a challenge "
                    },
                    {
                        "username": "niklas5559",
                        "content": "Python3\\nFeel free to ask questions if the code is too complex\\n\\n`return int(x ** 0.5)`"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "I don\\'t get it. You can still just make it 1 line in Java without using an exponent operator (nor importing any library).\\n```\\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\\n```"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My questions : Did you read the description carrefully?"
                    },
                    {
                        "username": "nodejk",
                        "content": "fyi for all the people who take things way too seriously, this is a joke."
                    },
                    {
                        "username": "milii048_leetcode",
                        "content": "Man, you must think you\\'re special right? Read the rules of the question before you post something dumb like this"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "dumbest answer ever"
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@mihir2310](/mihir2310) \\nYou are correct. I am not certain, but OP may be criticizing the fact that the auto-grader cannot detect that you are violating those rules. That, or they didn\\'t read the rules and are a bit too snarky. Or the problem statement changed over time."
                    },
                    {
                        "username": "mihir2310",
                        "content": "they said you can\\'t use that ** operation"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "\\tif (x <= 1) return x;\\n\\tlong i = 1;\\n\\tlong sq = i * i;\\n\\twhile (x >= sq) {\\n\\t\\ti++;\\n\\t\\tsq = i * i;\\n\\t}\\n\\treturn (int) (i - 1);"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "```\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\n```"
                    },
                    {
                        "username": "Gilbertttt",
                        "content": "Please can you break this down i\\'m having trouble understanding this\\n"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "BOOM baby! This is it. After Googling and reviewing the definition of square root, I came to the same solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "SeraphNiu",
                        "content": "![image](https://assets.leetcode.com/users/images/4d8f6ebd-d3a8-4cd7-8223-7ff4ecb2de52_1628032236.8164496.png)\\n"
                    },
                    {
                        "username": "itmevic",
                        "content": "why are u posting solution here? do u know how to read?"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "How are you using the value of \\'lo\\' without initialising it first?"
                    },
                    {
                        "username": "hu.cao1",
                        "content": "that will make sense. How do you expect the sqrt of 2 is  integer too?"
                    },
                    {
                        "username": "chinmayjain096",
                        "content": "but in question they mention about the integer value of number not the decimal of number.\\nu can right code also too get precious ans put which decimal u want in vs code/any compiler"
                    },
                    {
                        "username": "AbhiLeet",
                        "content": "May be I am missing something here, but the upper bound on the srqrt(x)  for any positive integer x cannot be more that x/2   (in fact its x/2 ONLY for number from 4-8) for any integer > 8, the upper bound on the sqrt is strictly < x/2.   So that makes me wonder - why are so many folks taking such a huge upper bound (INT_MX) for this problem ?"
                    },
                    {
                        "username": "artofhuman",
                        "content": "In binary search it saves one operation, it does not matter "
                    },
                    {
                        "username": "shubhamkeshari04",
                        "content": "why i m getting wrong answer for input x=2147395599\\n pls help"
                    },
                    {
                        "username": "stardust-skg",
                        "content": "[@rglamazda](/rglamazda) It\\'s better to use int properly :) "
                    },
                    {
                        "username": "Kromydas",
                        "content": "as [@rglamazda] has said, use long. A even better ideal is to use long long. And watch out for x = 0, and use while loops. (they are better in this scenario because they are conditional on different things, easier for beginners). It also makes your code slightly faster depending on what conditions you put in a for loop"
                    },
                    {
                        "username": "TheoW03",
                        "content": "[@TheoW03](/TheoW03) exactly. not 46369\\n"
                    },
                    {
                        "username": "TheoW03",
                        "content": "no its right the sqrt of (2147395599) is 46340"
                    },
                    {
                        "username": "Dest1ni",
                        "content": "This is a great beginner question, however the addition of values such as 2147395600 which cause an integer overflow take away from spirit of the question which is to find the algorithm.\\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm.\\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "rglamazda",
                        "content": "try to use long instead int"
                    },
                    {
                        "username": "user2354Mw",
                        "content": "\\tr = x\\n\\n\\tif x == 0:\\n\\t\\treturn 0\\n\\n\\tfor i in range(20):\\n\\t\\tr = (r + x / r) / 2\\n\\n\\treturn math.floor(r)"
                    },
                    {
                        "username": "anish_kr23",
                        "content": "[@nguyentuan67](/nguyentuan67)  i also not understand why he uses like this function.??????\\n"
                    },
                    {
                        "username": "d4mir",
                        "content": "[@nguyentuan67](/nguyentuan67) It\\'s a Newton-Raphson method"
                    },
                    {
                        "username": "wangchao426",
                        "content": "[@nguyentuan67](/nguyentuan67) ordinary least squares"
                    },
                    {
                        "username": "nguyentuan67",
                        "content": "why r = (r + x / r) / 2 ? i don\\'t understand."
                    },
                    {
                        "username": "waerte",
                        "content": "Kindly provide hint for implementing your own sqrt.\\nthanks!"
                    },
                    {
                        "username": "NerdPai",
                        "content": "https://en.wikipedia.org/wiki/Newton%27s_method"
                    }
                ]
            },
            {
                "id": 1576429,
                "content": [
                    {
                        "username": "onedaywillmake",
                        "content": "This is a great beginner question, however the addition of values such as `2147395600` which cause an integer overflow take away from spirit of the question which is to find the algorithm. \\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm. \\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Questions is labelled \"easy\"\\nHas dumb and frustrating edge cases to handle\\nOk, I might be dumb but it\\'s seems like I am not the only one complaining..."
                    },
                    {
                        "username": "md_isa",
                        "content": "Totally agree with you. Took the fun out of it as I had to return separately for 0 and 1, as x+1 which was my right bound for edge case like 1, also overflowed and turned into negative."
                    },
                    {
                        "username": "tka8edd",
                        "content": "if you are solving it in O(n), you don\\'t need to cast to long and there is no overflow."
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "agree with you"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah its frustating when overflow happens and also it isnt mentioned in problem for beginners!!"
                    },
                    {
                        "username": "10alan0712",
                        "content": "fiercely upvote"
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "[@jiayipaulwang](/jiayipaulwang) However, my solution is too add \"break\" within the loop when you find the desired answer."
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "why there\\'s an integer overflow issue? I thought that wasn\\'t a thing in python"
                    },
                    {
                        "username": "mkohar",
                        "content": "\\n[@SeaShanty](/SeaShanty).  [@onedaywillmake](/onedaywillmake)\\nHow to bypass overflow without using long? Try this:\\n1. use:  mid = low +(high-low)//2. \\n instead of mid =(high+low)//2\\n\\n2. Use   if(mid==x/mid) return mid\\n  instead of:   if(mid*mid==x)\\n\\nsmall things like this go long way in interview \\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": "typedef long long ll;\\nuse this simple easy"
                    },
                    {
                        "username": "valer0n3",
                        "content": "[@SeaShanty](/SeaShanty) Just consider that the solution can\\'t be more than x/2. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "OMG thank u so much for letting me know this was a case of integer overflow. I was stuck on this testcase and was making changes in my code multiple times thinking my approach was wrong. My approach works well for smaller testcases. How to handle the  214739500 testcase? Thank you "
                    },
                    {
                        "username": "Twitnithegirl",
                        "content": "\"You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\"\\n\\nWhat is the practical application of not using the standard library of the language you work in?"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "You\\'re so right. You should say that to the interviewer."
                    },
                    {
                        "username": "mepradeepkr",
                        "content": "Agree!!Bro"
                    },
                    {
                        "username": "h4ytham",
                        "content": "[@martynov-94](/martynov-94) well why would you bench press in a warehouse? You\\'re \"in a warehouse\" (using python) so bench pressing is redundant"
                    },
                    {
                        "username": "martynov-94",
                        "content": "Why bench press in the gym when you can just use a forklift?"
                    },
                    {
                        "username": "__Simamina__",
                        "content": "They say you can\\'t use it but you actually can(like, what the heck)"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "To understand how someone implemented the standard library you are sitting on. So you can improve as a coder knowing how something is behind the curtains and to have more knowledge to extend the default/standard of things. If we all took as a premisse that all ships must sail in water, we would never have created rocket ships. "
                    },
                    {
                        "username": "d4mir",
                        "content": "I guess logic and understanding the function and being able to work without using it. The same with in-built quicksort in Java (Arrays.sort()), we have it in the standard library, but we still learn it in the course as well as other sortings."
                    },
                    {
                        "username": "kuelf",
                        "content": "It\\'s a challenge "
                    },
                    {
                        "username": "niklas5559",
                        "content": "Python3\\nFeel free to ask questions if the code is too complex\\n\\n`return int(x ** 0.5)`"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "I don\\'t get it. You can still just make it 1 line in Java without using an exponent operator (nor importing any library).\\n```\\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\\n```"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My questions : Did you read the description carrefully?"
                    },
                    {
                        "username": "nodejk",
                        "content": "fyi for all the people who take things way too seriously, this is a joke."
                    },
                    {
                        "username": "milii048_leetcode",
                        "content": "Man, you must think you\\'re special right? Read the rules of the question before you post something dumb like this"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "dumbest answer ever"
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@mihir2310](/mihir2310) \\nYou are correct. I am not certain, but OP may be criticizing the fact that the auto-grader cannot detect that you are violating those rules. That, or they didn\\'t read the rules and are a bit too snarky. Or the problem statement changed over time."
                    },
                    {
                        "username": "mihir2310",
                        "content": "they said you can\\'t use that ** operation"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "\\tif (x <= 1) return x;\\n\\tlong i = 1;\\n\\tlong sq = i * i;\\n\\twhile (x >= sq) {\\n\\t\\ti++;\\n\\t\\tsq = i * i;\\n\\t}\\n\\treturn (int) (i - 1);"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "```\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\n```"
                    },
                    {
                        "username": "Gilbertttt",
                        "content": "Please can you break this down i\\'m having trouble understanding this\\n"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "BOOM baby! This is it. After Googling and reviewing the definition of square root, I came to the same solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "SeraphNiu",
                        "content": "![image](https://assets.leetcode.com/users/images/4d8f6ebd-d3a8-4cd7-8223-7ff4ecb2de52_1628032236.8164496.png)\\n"
                    },
                    {
                        "username": "itmevic",
                        "content": "why are u posting solution here? do u know how to read?"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "How are you using the value of \\'lo\\' without initialising it first?"
                    },
                    {
                        "username": "hu.cao1",
                        "content": "that will make sense. How do you expect the sqrt of 2 is  integer too?"
                    },
                    {
                        "username": "chinmayjain096",
                        "content": "but in question they mention about the integer value of number not the decimal of number.\\nu can right code also too get precious ans put which decimal u want in vs code/any compiler"
                    },
                    {
                        "username": "AbhiLeet",
                        "content": "May be I am missing something here, but the upper bound on the srqrt(x)  for any positive integer x cannot be more that x/2   (in fact its x/2 ONLY for number from 4-8) for any integer > 8, the upper bound on the sqrt is strictly < x/2.   So that makes me wonder - why are so many folks taking such a huge upper bound (INT_MX) for this problem ?"
                    },
                    {
                        "username": "artofhuman",
                        "content": "In binary search it saves one operation, it does not matter "
                    },
                    {
                        "username": "shubhamkeshari04",
                        "content": "why i m getting wrong answer for input x=2147395599\\n pls help"
                    },
                    {
                        "username": "stardust-skg",
                        "content": "[@rglamazda](/rglamazda) It\\'s better to use int properly :) "
                    },
                    {
                        "username": "Kromydas",
                        "content": "as [@rglamazda] has said, use long. A even better ideal is to use long long. And watch out for x = 0, and use while loops. (they are better in this scenario because they are conditional on different things, easier for beginners). It also makes your code slightly faster depending on what conditions you put in a for loop"
                    },
                    {
                        "username": "TheoW03",
                        "content": "[@TheoW03](/TheoW03) exactly. not 46369\\n"
                    },
                    {
                        "username": "TheoW03",
                        "content": "no its right the sqrt of (2147395599) is 46340"
                    },
                    {
                        "username": "Dest1ni",
                        "content": "This is a great beginner question, however the addition of values such as 2147395600 which cause an integer overflow take away from spirit of the question which is to find the algorithm.\\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm.\\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "rglamazda",
                        "content": "try to use long instead int"
                    },
                    {
                        "username": "user2354Mw",
                        "content": "\\tr = x\\n\\n\\tif x == 0:\\n\\t\\treturn 0\\n\\n\\tfor i in range(20):\\n\\t\\tr = (r + x / r) / 2\\n\\n\\treturn math.floor(r)"
                    },
                    {
                        "username": "anish_kr23",
                        "content": "[@nguyentuan67](/nguyentuan67)  i also not understand why he uses like this function.??????\\n"
                    },
                    {
                        "username": "d4mir",
                        "content": "[@nguyentuan67](/nguyentuan67) It\\'s a Newton-Raphson method"
                    },
                    {
                        "username": "wangchao426",
                        "content": "[@nguyentuan67](/nguyentuan67) ordinary least squares"
                    },
                    {
                        "username": "nguyentuan67",
                        "content": "why r = (r + x / r) / 2 ? i don\\'t understand."
                    },
                    {
                        "username": "waerte",
                        "content": "Kindly provide hint for implementing your own sqrt.\\nthanks!"
                    },
                    {
                        "username": "NerdPai",
                        "content": "https://en.wikipedia.org/wiki/Newton%27s_method"
                    }
                ]
            },
            {
                "id": 1575669,
                "content": [
                    {
                        "username": "onedaywillmake",
                        "content": "This is a great beginner question, however the addition of values such as `2147395600` which cause an integer overflow take away from spirit of the question which is to find the algorithm. \\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm. \\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Questions is labelled \"easy\"\\nHas dumb and frustrating edge cases to handle\\nOk, I might be dumb but it\\'s seems like I am not the only one complaining..."
                    },
                    {
                        "username": "md_isa",
                        "content": "Totally agree with you. Took the fun out of it as I had to return separately for 0 and 1, as x+1 which was my right bound for edge case like 1, also overflowed and turned into negative."
                    },
                    {
                        "username": "tka8edd",
                        "content": "if you are solving it in O(n), you don\\'t need to cast to long and there is no overflow."
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "agree with you"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah its frustating when overflow happens and also it isnt mentioned in problem for beginners!!"
                    },
                    {
                        "username": "10alan0712",
                        "content": "fiercely upvote"
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "[@jiayipaulwang](/jiayipaulwang) However, my solution is too add \"break\" within the loop when you find the desired answer."
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "why there\\'s an integer overflow issue? I thought that wasn\\'t a thing in python"
                    },
                    {
                        "username": "mkohar",
                        "content": "\\n[@SeaShanty](/SeaShanty).  [@onedaywillmake](/onedaywillmake)\\nHow to bypass overflow without using long? Try this:\\n1. use:  mid = low +(high-low)//2. \\n instead of mid =(high+low)//2\\n\\n2. Use   if(mid==x/mid) return mid\\n  instead of:   if(mid*mid==x)\\n\\nsmall things like this go long way in interview \\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": "typedef long long ll;\\nuse this simple easy"
                    },
                    {
                        "username": "valer0n3",
                        "content": "[@SeaShanty](/SeaShanty) Just consider that the solution can\\'t be more than x/2. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "OMG thank u so much for letting me know this was a case of integer overflow. I was stuck on this testcase and was making changes in my code multiple times thinking my approach was wrong. My approach works well for smaller testcases. How to handle the  214739500 testcase? Thank you "
                    },
                    {
                        "username": "Twitnithegirl",
                        "content": "\"You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\"\\n\\nWhat is the practical application of not using the standard library of the language you work in?"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "You\\'re so right. You should say that to the interviewer."
                    },
                    {
                        "username": "mepradeepkr",
                        "content": "Agree!!Bro"
                    },
                    {
                        "username": "h4ytham",
                        "content": "[@martynov-94](/martynov-94) well why would you bench press in a warehouse? You\\'re \"in a warehouse\" (using python) so bench pressing is redundant"
                    },
                    {
                        "username": "martynov-94",
                        "content": "Why bench press in the gym when you can just use a forklift?"
                    },
                    {
                        "username": "__Simamina__",
                        "content": "They say you can\\'t use it but you actually can(like, what the heck)"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "To understand how someone implemented the standard library you are sitting on. So you can improve as a coder knowing how something is behind the curtains and to have more knowledge to extend the default/standard of things. If we all took as a premisse that all ships must sail in water, we would never have created rocket ships. "
                    },
                    {
                        "username": "d4mir",
                        "content": "I guess logic and understanding the function and being able to work without using it. The same with in-built quicksort in Java (Arrays.sort()), we have it in the standard library, but we still learn it in the course as well as other sortings."
                    },
                    {
                        "username": "kuelf",
                        "content": "It\\'s a challenge "
                    },
                    {
                        "username": "niklas5559",
                        "content": "Python3\\nFeel free to ask questions if the code is too complex\\n\\n`return int(x ** 0.5)`"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "I don\\'t get it. You can still just make it 1 line in Java without using an exponent operator (nor importing any library).\\n```\\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\\n```"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My questions : Did you read the description carrefully?"
                    },
                    {
                        "username": "nodejk",
                        "content": "fyi for all the people who take things way too seriously, this is a joke."
                    },
                    {
                        "username": "milii048_leetcode",
                        "content": "Man, you must think you\\'re special right? Read the rules of the question before you post something dumb like this"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "dumbest answer ever"
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@mihir2310](/mihir2310) \\nYou are correct. I am not certain, but OP may be criticizing the fact that the auto-grader cannot detect that you are violating those rules. That, or they didn\\'t read the rules and are a bit too snarky. Or the problem statement changed over time."
                    },
                    {
                        "username": "mihir2310",
                        "content": "they said you can\\'t use that ** operation"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "\\tif (x <= 1) return x;\\n\\tlong i = 1;\\n\\tlong sq = i * i;\\n\\twhile (x >= sq) {\\n\\t\\ti++;\\n\\t\\tsq = i * i;\\n\\t}\\n\\treturn (int) (i - 1);"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "```\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\n```"
                    },
                    {
                        "username": "Gilbertttt",
                        "content": "Please can you break this down i\\'m having trouble understanding this\\n"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "BOOM baby! This is it. After Googling and reviewing the definition of square root, I came to the same solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "SeraphNiu",
                        "content": "![image](https://assets.leetcode.com/users/images/4d8f6ebd-d3a8-4cd7-8223-7ff4ecb2de52_1628032236.8164496.png)\\n"
                    },
                    {
                        "username": "itmevic",
                        "content": "why are u posting solution here? do u know how to read?"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "How are you using the value of \\'lo\\' without initialising it first?"
                    },
                    {
                        "username": "hu.cao1",
                        "content": "that will make sense. How do you expect the sqrt of 2 is  integer too?"
                    },
                    {
                        "username": "chinmayjain096",
                        "content": "but in question they mention about the integer value of number not the decimal of number.\\nu can right code also too get precious ans put which decimal u want in vs code/any compiler"
                    },
                    {
                        "username": "AbhiLeet",
                        "content": "May be I am missing something here, but the upper bound on the srqrt(x)  for any positive integer x cannot be more that x/2   (in fact its x/2 ONLY for number from 4-8) for any integer > 8, the upper bound on the sqrt is strictly < x/2.   So that makes me wonder - why are so many folks taking such a huge upper bound (INT_MX) for this problem ?"
                    },
                    {
                        "username": "artofhuman",
                        "content": "In binary search it saves one operation, it does not matter "
                    },
                    {
                        "username": "shubhamkeshari04",
                        "content": "why i m getting wrong answer for input x=2147395599\\n pls help"
                    },
                    {
                        "username": "stardust-skg",
                        "content": "[@rglamazda](/rglamazda) It\\'s better to use int properly :) "
                    },
                    {
                        "username": "Kromydas",
                        "content": "as [@rglamazda] has said, use long. A even better ideal is to use long long. And watch out for x = 0, and use while loops. (they are better in this scenario because they are conditional on different things, easier for beginners). It also makes your code slightly faster depending on what conditions you put in a for loop"
                    },
                    {
                        "username": "TheoW03",
                        "content": "[@TheoW03](/TheoW03) exactly. not 46369\\n"
                    },
                    {
                        "username": "TheoW03",
                        "content": "no its right the sqrt of (2147395599) is 46340"
                    },
                    {
                        "username": "Dest1ni",
                        "content": "This is a great beginner question, however the addition of values such as 2147395600 which cause an integer overflow take away from spirit of the question which is to find the algorithm.\\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm.\\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "rglamazda",
                        "content": "try to use long instead int"
                    },
                    {
                        "username": "user2354Mw",
                        "content": "\\tr = x\\n\\n\\tif x == 0:\\n\\t\\treturn 0\\n\\n\\tfor i in range(20):\\n\\t\\tr = (r + x / r) / 2\\n\\n\\treturn math.floor(r)"
                    },
                    {
                        "username": "anish_kr23",
                        "content": "[@nguyentuan67](/nguyentuan67)  i also not understand why he uses like this function.??????\\n"
                    },
                    {
                        "username": "d4mir",
                        "content": "[@nguyentuan67](/nguyentuan67) It\\'s a Newton-Raphson method"
                    },
                    {
                        "username": "wangchao426",
                        "content": "[@nguyentuan67](/nguyentuan67) ordinary least squares"
                    },
                    {
                        "username": "nguyentuan67",
                        "content": "why r = (r + x / r) / 2 ? i don\\'t understand."
                    },
                    {
                        "username": "waerte",
                        "content": "Kindly provide hint for implementing your own sqrt.\\nthanks!"
                    },
                    {
                        "username": "NerdPai",
                        "content": "https://en.wikipedia.org/wiki/Newton%27s_method"
                    }
                ]
            },
            {
                "id": 1571169,
                "content": [
                    {
                        "username": "onedaywillmake",
                        "content": "This is a great beginner question, however the addition of values such as `2147395600` which cause an integer overflow take away from spirit of the question which is to find the algorithm. \\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm. \\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "Rimberse",
                        "content": "Questions is labelled \"easy\"\\nHas dumb and frustrating edge cases to handle\\nOk, I might be dumb but it\\'s seems like I am not the only one complaining..."
                    },
                    {
                        "username": "md_isa",
                        "content": "Totally agree with you. Took the fun out of it as I had to return separately for 0 and 1, as x+1 which was my right bound for edge case like 1, also overflowed and turned into negative."
                    },
                    {
                        "username": "tka8edd",
                        "content": "if you are solving it in O(n), you don\\'t need to cast to long and there is no overflow."
                    },
                    {
                        "username": "palakgupta1712",
                        "content": "agree with you"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "yeah its frustating when overflow happens and also it isnt mentioned in problem for beginners!!"
                    },
                    {
                        "username": "10alan0712",
                        "content": "fiercely upvote"
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "[@jiayipaulwang](/jiayipaulwang) However, my solution is too add \"break\" within the loop when you find the desired answer."
                    },
                    {
                        "username": "jiayipaulwang",
                        "content": "why there\\'s an integer overflow issue? I thought that wasn\\'t a thing in python"
                    },
                    {
                        "username": "mkohar",
                        "content": "\\n[@SeaShanty](/SeaShanty).  [@onedaywillmake](/onedaywillmake)\\nHow to bypass overflow without using long? Try this:\\n1. use:  mid = low +(high-low)//2. \\n instead of mid =(high+low)//2\\n\\n2. Use   if(mid==x/mid) return mid\\n  instead of:   if(mid*mid==x)\\n\\nsmall things like this go long way in interview \\n"
                    },
                    {
                        "username": "deepak130797",
                        "content": "typedef long long ll;\\nuse this simple easy"
                    },
                    {
                        "username": "valer0n3",
                        "content": "[@SeaShanty](/SeaShanty) Just consider that the solution can\\'t be more than x/2. "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "OMG thank u so much for letting me know this was a case of integer overflow. I was stuck on this testcase and was making changes in my code multiple times thinking my approach was wrong. My approach works well for smaller testcases. How to handle the  214739500 testcase? Thank you "
                    },
                    {
                        "username": "Twitnithegirl",
                        "content": "\"You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5.\"\\n\\nWhat is the practical application of not using the standard library of the language you work in?"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "You\\'re so right. You should say that to the interviewer."
                    },
                    {
                        "username": "mepradeepkr",
                        "content": "Agree!!Bro"
                    },
                    {
                        "username": "h4ytham",
                        "content": "[@martynov-94](/martynov-94) well why would you bench press in a warehouse? You\\'re \"in a warehouse\" (using python) so bench pressing is redundant"
                    },
                    {
                        "username": "martynov-94",
                        "content": "Why bench press in the gym when you can just use a forklift?"
                    },
                    {
                        "username": "__Simamina__",
                        "content": "They say you can\\'t use it but you actually can(like, what the heck)"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "To understand how someone implemented the standard library you are sitting on. So you can improve as a coder knowing how something is behind the curtains and to have more knowledge to extend the default/standard of things. If we all took as a premisse that all ships must sail in water, we would never have created rocket ships. "
                    },
                    {
                        "username": "d4mir",
                        "content": "I guess logic and understanding the function and being able to work without using it. The same with in-built quicksort in Java (Arrays.sort()), we have it in the standard library, but we still learn it in the course as well as other sortings."
                    },
                    {
                        "username": "kuelf",
                        "content": "It\\'s a challenge "
                    },
                    {
                        "username": "niklas5559",
                        "content": "Python3\\nFeel free to ask questions if the code is too complex\\n\\n`return int(x ** 0.5)`"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "I don\\'t get it. You can still just make it 1 line in Java without using an exponent operator (nor importing any library).\\n```\\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\\n```"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "My questions : Did you read the description carrefully?"
                    },
                    {
                        "username": "nodejk",
                        "content": "fyi for all the people who take things way too seriously, this is a joke."
                    },
                    {
                        "username": "milii048_leetcode",
                        "content": "Man, you must think you\\'re special right? Read the rules of the question before you post something dumb like this"
                    },
                    {
                        "username": "Pranav-2103",
                        "content": "dumbest answer ever"
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@mihir2310](/mihir2310) \\nYou are correct. I am not certain, but OP may be criticizing the fact that the auto-grader cannot detect that you are violating those rules. That, or they didn\\'t read the rules and are a bit too snarky. Or the problem statement changed over time."
                    },
                    {
                        "username": "mihir2310",
                        "content": "they said you can\\'t use that ** operation"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "\\tif (x <= 1) return x;\\n\\tlong i = 1;\\n\\tlong sq = i * i;\\n\\twhile (x >= sq) {\\n\\t\\ti++;\\n\\t\\tsq = i * i;\\n\\t}\\n\\treturn (int) (i - 1);"
                    },
                    {
                        "username": "brendanbdev",
                        "content": "```\nfor(int i=0;true;i++)if(i*i>x||i*i<0)return i-1;\n```"
                    },
                    {
                        "username": "Gilbertttt",
                        "content": "Please can you break this down i\\'m having trouble understanding this\\n"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "BOOM baby! This is it. After Googling and reviewing the definition of square root, I came to the same solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "SeraphNiu",
                        "content": "![image](https://assets.leetcode.com/users/images/4d8f6ebd-d3a8-4cd7-8223-7ff4ecb2de52_1628032236.8164496.png)\\n"
                    },
                    {
                        "username": "itmevic",
                        "content": "why are u posting solution here? do u know how to read?"
                    },
                    {
                        "username": "sjrj0604",
                        "content": "How are you using the value of \\'lo\\' without initialising it first?"
                    },
                    {
                        "username": "hu.cao1",
                        "content": "that will make sense. How do you expect the sqrt of 2 is  integer too?"
                    },
                    {
                        "username": "chinmayjain096",
                        "content": "but in question they mention about the integer value of number not the decimal of number.\\nu can right code also too get precious ans put which decimal u want in vs code/any compiler"
                    },
                    {
                        "username": "AbhiLeet",
                        "content": "May be I am missing something here, but the upper bound on the srqrt(x)  for any positive integer x cannot be more that x/2   (in fact its x/2 ONLY for number from 4-8) for any integer > 8, the upper bound on the sqrt is strictly < x/2.   So that makes me wonder - why are so many folks taking such a huge upper bound (INT_MX) for this problem ?"
                    },
                    {
                        "username": "artofhuman",
                        "content": "In binary search it saves one operation, it does not matter "
                    },
                    {
                        "username": "shubhamkeshari04",
                        "content": "why i m getting wrong answer for input x=2147395599\\n pls help"
                    },
                    {
                        "username": "stardust-skg",
                        "content": "[@rglamazda](/rglamazda) It\\'s better to use int properly :) "
                    },
                    {
                        "username": "Kromydas",
                        "content": "as [@rglamazda] has said, use long. A even better ideal is to use long long. And watch out for x = 0, and use while loops. (they are better in this scenario because they are conditional on different things, easier for beginners). It also makes your code slightly faster depending on what conditions you put in a for loop"
                    },
                    {
                        "username": "TheoW03",
                        "content": "[@TheoW03](/TheoW03) exactly. not 46369\\n"
                    },
                    {
                        "username": "TheoW03",
                        "content": "no its right the sqrt of (2147395599) is 46340"
                    },
                    {
                        "username": "Dest1ni",
                        "content": "This is a great beginner question, however the addition of values such as 2147395600 which cause an integer overflow take away from spirit of the question which is to find the algorithm.\\n\\nMany users would not expect having to cast things to long in an question labeled \"beginner\", I\\'ve seen a lot of frustration for users thinking their approach is wrong and throwing it away thinking it must be something wrong with their algorithm.\\n\\nRemove those extreme edge cases, or let\\'s call the question at least a \\'medium\\' level - or add a note about integer overflow"
                    },
                    {
                        "username": "rglamazda",
                        "content": "try to use long instead int"
                    },
                    {
                        "username": "user2354Mw",
                        "content": "\\tr = x\\n\\n\\tif x == 0:\\n\\t\\treturn 0\\n\\n\\tfor i in range(20):\\n\\t\\tr = (r + x / r) / 2\\n\\n\\treturn math.floor(r)"
                    },
                    {
                        "username": "anish_kr23",
                        "content": "[@nguyentuan67](/nguyentuan67)  i also not understand why he uses like this function.??????\\n"
                    },
                    {
                        "username": "d4mir",
                        "content": "[@nguyentuan67](/nguyentuan67) It\\'s a Newton-Raphson method"
                    },
                    {
                        "username": "wangchao426",
                        "content": "[@nguyentuan67](/nguyentuan67) ordinary least squares"
                    },
                    {
                        "username": "nguyentuan67",
                        "content": "why r = (r + x / r) / 2 ? i don\\'t understand."
                    },
                    {
                        "username": "waerte",
                        "content": "Kindly provide hint for implementing your own sqrt.\\nthanks!"
                    },
                    {
                        "username": "NerdPai",
                        "content": "https://en.wikipedia.org/wiki/Newton%27s_method"
                    }
                ]
            },
            {
                "id": 1752649,
                "content": [
                    {
                        "username": "sakethbhardwajV",
                        "content": "this problem has an edge cases where it causes integer overflow..\\nso instead of checking `(mid * mid == x)` which causes integer overflow write the condition as `(x / mid == mid)` and similar condition for else if cases... "
                    },
                    {
                        "username": "bradwick21",
                        "content": "thanks man"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 beginner\\'s tip :: just a binary search application"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Sorry for a newbie question...\\nCan we use Binary search for this problem? \\nCan we use Binary search on integers ?\\n"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "ya definitely\\n"
                    },
                    {
                        "username": "_ast0",
                        "content": "![image](https://assets.leetcode.com/users/images/cb663b54-6011-4ef8-9e5b-b904151e90c0_1604983977.0130923.png)\\n"
                    },
                    {
                        "username": "9902699141a",
                        "content": "upvote creative way doing but we need write our own algo."
                    },
                    {
                        "username": "mayank-goyal",
                        "content": "What are you getting by submitting pre-defined functions?"
                    },
                    {
                        "username": "chognzi",
                        "content": "![image](https://assets.leetcode.com/users/chognzi/image_1570974209.png)\\n894427 should be the correct answer!"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "With 2 as input, \"Expected answer\" gives 1;\\nWith -1 as input, \"Expected answer\" gives -2147483648;\\n\\nThe input should be non-negative, otherwise it's meaningless.\\nThe output should be double, sqrt(2) should return 1.414... (until the double precision)"
                    },
                    {
                        "username": "akshat005",
                        "content": "Under root of negative number is a complex number! maybe that\\'s why we are not getting accurate answer!"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using simple binary search based on the explanation at \\n[Square Root Using Binary Search ](https://algotree.org/algorithms/binary_search/squareroot/)"
                    },
                    {
                        "username": "turbocv",
                        "content": "Actually, I think this problem needs more explanations.\\nX is not the perfect square number, besides, we want to find the closest int which is smaller than or equals to exact sqrt(x)."
                    },
                    {
                        "username": "kgyanender4",
                        "content": "`class Solution:\\n    def mySqrt(self, x: int) -> int:\\n        low=1\\n        high=x\\n        ans=-1\\n        while(low<=high):\\n            mid=(low+high)//2\\n            midsq=mid*mid\\n            if midsq==x:\\n                return mid\\n            elif midsq<x:\\n                low=mid+1\\n            else:\\n                high=mid-1\\n                ans=mid\\n        return ans          `\\n\\nI used Binary Search Concept to solve this but Case 2 said its wrong \\nx=8\\nmy output=3\\nexpected = 2\\nPlease help"
                    },
                    {
                        "username": "mohiwalla",
                        "content": "Two minutes of silence for the Python and JavaScript users. :)"
                    }
                ]
            },
            {
                "id": 1984354,
                "content": [
                    {
                        "username": "sakethbhardwajV",
                        "content": "this problem has an edge cases where it causes integer overflow..\\nso instead of checking `(mid * mid == x)` which causes integer overflow write the condition as `(x / mid == mid)` and similar condition for else if cases... "
                    },
                    {
                        "username": "bradwick21",
                        "content": "thanks man"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 beginner\\'s tip :: just a binary search application"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Sorry for a newbie question...\\nCan we use Binary search for this problem? \\nCan we use Binary search on integers ?\\n"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "ya definitely\\n"
                    },
                    {
                        "username": "_ast0",
                        "content": "![image](https://assets.leetcode.com/users/images/cb663b54-6011-4ef8-9e5b-b904151e90c0_1604983977.0130923.png)\\n"
                    },
                    {
                        "username": "9902699141a",
                        "content": "upvote creative way doing but we need write our own algo."
                    },
                    {
                        "username": "mayank-goyal",
                        "content": "What are you getting by submitting pre-defined functions?"
                    },
                    {
                        "username": "chognzi",
                        "content": "![image](https://assets.leetcode.com/users/chognzi/image_1570974209.png)\\n894427 should be the correct answer!"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "With 2 as input, \"Expected answer\" gives 1;\\nWith -1 as input, \"Expected answer\" gives -2147483648;\\n\\nThe input should be non-negative, otherwise it's meaningless.\\nThe output should be double, sqrt(2) should return 1.414... (until the double precision)"
                    },
                    {
                        "username": "akshat005",
                        "content": "Under root of negative number is a complex number! maybe that\\'s why we are not getting accurate answer!"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using simple binary search based on the explanation at \\n[Square Root Using Binary Search ](https://algotree.org/algorithms/binary_search/squareroot/)"
                    },
                    {
                        "username": "turbocv",
                        "content": "Actually, I think this problem needs more explanations.\\nX is not the perfect square number, besides, we want to find the closest int which is smaller than or equals to exact sqrt(x)."
                    },
                    {
                        "username": "kgyanender4",
                        "content": "`class Solution:\\n    def mySqrt(self, x: int) -> int:\\n        low=1\\n        high=x\\n        ans=-1\\n        while(low<=high):\\n            mid=(low+high)//2\\n            midsq=mid*mid\\n            if midsq==x:\\n                return mid\\n            elif midsq<x:\\n                low=mid+1\\n            else:\\n                high=mid-1\\n                ans=mid\\n        return ans          `\\n\\nI used Binary Search Concept to solve this but Case 2 said its wrong \\nx=8\\nmy output=3\\nexpected = 2\\nPlease help"
                    },
                    {
                        "username": "mohiwalla",
                        "content": "Two minutes of silence for the Python and JavaScript users. :)"
                    }
                ]
            },
            {
                "id": 1815448,
                "content": [
                    {
                        "username": "sakethbhardwajV",
                        "content": "this problem has an edge cases where it causes integer overflow..\\nso instead of checking `(mid * mid == x)` which causes integer overflow write the condition as `(x / mid == mid)` and similar condition for else if cases... "
                    },
                    {
                        "username": "bradwick21",
                        "content": "thanks man"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 beginner\\'s tip :: just a binary search application"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Sorry for a newbie question...\\nCan we use Binary search for this problem? \\nCan we use Binary search on integers ?\\n"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "ya definitely\\n"
                    },
                    {
                        "username": "_ast0",
                        "content": "![image](https://assets.leetcode.com/users/images/cb663b54-6011-4ef8-9e5b-b904151e90c0_1604983977.0130923.png)\\n"
                    },
                    {
                        "username": "9902699141a",
                        "content": "upvote creative way doing but we need write our own algo."
                    },
                    {
                        "username": "mayank-goyal",
                        "content": "What are you getting by submitting pre-defined functions?"
                    },
                    {
                        "username": "chognzi",
                        "content": "![image](https://assets.leetcode.com/users/chognzi/image_1570974209.png)\\n894427 should be the correct answer!"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "With 2 as input, \"Expected answer\" gives 1;\\nWith -1 as input, \"Expected answer\" gives -2147483648;\\n\\nThe input should be non-negative, otherwise it's meaningless.\\nThe output should be double, sqrt(2) should return 1.414... (until the double precision)"
                    },
                    {
                        "username": "akshat005",
                        "content": "Under root of negative number is a complex number! maybe that\\'s why we are not getting accurate answer!"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using simple binary search based on the explanation at \\n[Square Root Using Binary Search ](https://algotree.org/algorithms/binary_search/squareroot/)"
                    },
                    {
                        "username": "turbocv",
                        "content": "Actually, I think this problem needs more explanations.\\nX is not the perfect square number, besides, we want to find the closest int which is smaller than or equals to exact sqrt(x)."
                    },
                    {
                        "username": "kgyanender4",
                        "content": "`class Solution:\\n    def mySqrt(self, x: int) -> int:\\n        low=1\\n        high=x\\n        ans=-1\\n        while(low<=high):\\n            mid=(low+high)//2\\n            midsq=mid*mid\\n            if midsq==x:\\n                return mid\\n            elif midsq<x:\\n                low=mid+1\\n            else:\\n                high=mid-1\\n                ans=mid\\n        return ans          `\\n\\nI used Binary Search Concept to solve this but Case 2 said its wrong \\nx=8\\nmy output=3\\nexpected = 2\\nPlease help"
                    },
                    {
                        "username": "mohiwalla",
                        "content": "Two minutes of silence for the Python and JavaScript users. :)"
                    }
                ]
            },
            {
                "id": 1574586,
                "content": [
                    {
                        "username": "sakethbhardwajV",
                        "content": "this problem has an edge cases where it causes integer overflow..\\nso instead of checking `(mid * mid == x)` which causes integer overflow write the condition as `(x / mid == mid)` and similar condition for else if cases... "
                    },
                    {
                        "username": "bradwick21",
                        "content": "thanks man"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 beginner\\'s tip :: just a binary search application"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Sorry for a newbie question...\\nCan we use Binary search for this problem? \\nCan we use Binary search on integers ?\\n"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "ya definitely\\n"
                    },
                    {
                        "username": "_ast0",
                        "content": "![image](https://assets.leetcode.com/users/images/cb663b54-6011-4ef8-9e5b-b904151e90c0_1604983977.0130923.png)\\n"
                    },
                    {
                        "username": "9902699141a",
                        "content": "upvote creative way doing but we need write our own algo."
                    },
                    {
                        "username": "mayank-goyal",
                        "content": "What are you getting by submitting pre-defined functions?"
                    },
                    {
                        "username": "chognzi",
                        "content": "![image](https://assets.leetcode.com/users/chognzi/image_1570974209.png)\\n894427 should be the correct answer!"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "With 2 as input, \"Expected answer\" gives 1;\\nWith -1 as input, \"Expected answer\" gives -2147483648;\\n\\nThe input should be non-negative, otherwise it's meaningless.\\nThe output should be double, sqrt(2) should return 1.414... (until the double precision)"
                    },
                    {
                        "username": "akshat005",
                        "content": "Under root of negative number is a complex number! maybe that\\'s why we are not getting accurate answer!"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using simple binary search based on the explanation at \\n[Square Root Using Binary Search ](https://algotree.org/algorithms/binary_search/squareroot/)"
                    },
                    {
                        "username": "turbocv",
                        "content": "Actually, I think this problem needs more explanations.\\nX is not the perfect square number, besides, we want to find the closest int which is smaller than or equals to exact sqrt(x)."
                    },
                    {
                        "username": "kgyanender4",
                        "content": "`class Solution:\\n    def mySqrt(self, x: int) -> int:\\n        low=1\\n        high=x\\n        ans=-1\\n        while(low<=high):\\n            mid=(low+high)//2\\n            midsq=mid*mid\\n            if midsq==x:\\n                return mid\\n            elif midsq<x:\\n                low=mid+1\\n            else:\\n                high=mid-1\\n                ans=mid\\n        return ans          `\\n\\nI used Binary Search Concept to solve this but Case 2 said its wrong \\nx=8\\nmy output=3\\nexpected = 2\\nPlease help"
                    },
                    {
                        "username": "mohiwalla",
                        "content": "Two minutes of silence for the Python and JavaScript users. :)"
                    }
                ]
            },
            {
                "id": 1573102,
                "content": [
                    {
                        "username": "sakethbhardwajV",
                        "content": "this problem has an edge cases where it causes integer overflow..\\nso instead of checking `(mid * mid == x)` which causes integer overflow write the condition as `(x / mid == mid)` and similar condition for else if cases... "
                    },
                    {
                        "username": "bradwick21",
                        "content": "thanks man"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 beginner\\'s tip :: just a binary search application"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Sorry for a newbie question...\\nCan we use Binary search for this problem? \\nCan we use Binary search on integers ?\\n"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "ya definitely\\n"
                    },
                    {
                        "username": "_ast0",
                        "content": "![image](https://assets.leetcode.com/users/images/cb663b54-6011-4ef8-9e5b-b904151e90c0_1604983977.0130923.png)\\n"
                    },
                    {
                        "username": "9902699141a",
                        "content": "upvote creative way doing but we need write our own algo."
                    },
                    {
                        "username": "mayank-goyal",
                        "content": "What are you getting by submitting pre-defined functions?"
                    },
                    {
                        "username": "chognzi",
                        "content": "![image](https://assets.leetcode.com/users/chognzi/image_1570974209.png)\\n894427 should be the correct answer!"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "With 2 as input, \"Expected answer\" gives 1;\\nWith -1 as input, \"Expected answer\" gives -2147483648;\\n\\nThe input should be non-negative, otherwise it's meaningless.\\nThe output should be double, sqrt(2) should return 1.414... (until the double precision)"
                    },
                    {
                        "username": "akshat005",
                        "content": "Under root of negative number is a complex number! maybe that\\'s why we are not getting accurate answer!"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using simple binary search based on the explanation at \\n[Square Root Using Binary Search ](https://algotree.org/algorithms/binary_search/squareroot/)"
                    },
                    {
                        "username": "turbocv",
                        "content": "Actually, I think this problem needs more explanations.\\nX is not the perfect square number, besides, we want to find the closest int which is smaller than or equals to exact sqrt(x)."
                    },
                    {
                        "username": "kgyanender4",
                        "content": "`class Solution:\\n    def mySqrt(self, x: int) -> int:\\n        low=1\\n        high=x\\n        ans=-1\\n        while(low<=high):\\n            mid=(low+high)//2\\n            midsq=mid*mid\\n            if midsq==x:\\n                return mid\\n            elif midsq<x:\\n                low=mid+1\\n            else:\\n                high=mid-1\\n                ans=mid\\n        return ans          `\\n\\nI used Binary Search Concept to solve this but Case 2 said its wrong \\nx=8\\nmy output=3\\nexpected = 2\\nPlease help"
                    },
                    {
                        "username": "mohiwalla",
                        "content": "Two minutes of silence for the Python and JavaScript users. :)"
                    }
                ]
            },
            {
                "id": 1567185,
                "content": [
                    {
                        "username": "sakethbhardwajV",
                        "content": "this problem has an edge cases where it causes integer overflow..\\nso instead of checking `(mid * mid == x)` which causes integer overflow write the condition as `(x / mid == mid)` and similar condition for else if cases... "
                    },
                    {
                        "username": "bradwick21",
                        "content": "thanks man"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 beginner\\'s tip :: just a binary search application"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Sorry for a newbie question...\\nCan we use Binary search for this problem? \\nCan we use Binary search on integers ?\\n"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "ya definitely\\n"
                    },
                    {
                        "username": "_ast0",
                        "content": "![image](https://assets.leetcode.com/users/images/cb663b54-6011-4ef8-9e5b-b904151e90c0_1604983977.0130923.png)\\n"
                    },
                    {
                        "username": "9902699141a",
                        "content": "upvote creative way doing but we need write our own algo."
                    },
                    {
                        "username": "mayank-goyal",
                        "content": "What are you getting by submitting pre-defined functions?"
                    },
                    {
                        "username": "chognzi",
                        "content": "![image](https://assets.leetcode.com/users/chognzi/image_1570974209.png)\\n894427 should be the correct answer!"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "With 2 as input, \"Expected answer\" gives 1;\\nWith -1 as input, \"Expected answer\" gives -2147483648;\\n\\nThe input should be non-negative, otherwise it's meaningless.\\nThe output should be double, sqrt(2) should return 1.414... (until the double precision)"
                    },
                    {
                        "username": "akshat005",
                        "content": "Under root of negative number is a complex number! maybe that\\'s why we are not getting accurate answer!"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using simple binary search based on the explanation at \\n[Square Root Using Binary Search ](https://algotree.org/algorithms/binary_search/squareroot/)"
                    },
                    {
                        "username": "turbocv",
                        "content": "Actually, I think this problem needs more explanations.\\nX is not the perfect square number, besides, we want to find the closest int which is smaller than or equals to exact sqrt(x)."
                    },
                    {
                        "username": "kgyanender4",
                        "content": "`class Solution:\\n    def mySqrt(self, x: int) -> int:\\n        low=1\\n        high=x\\n        ans=-1\\n        while(low<=high):\\n            mid=(low+high)//2\\n            midsq=mid*mid\\n            if midsq==x:\\n                return mid\\n            elif midsq<x:\\n                low=mid+1\\n            else:\\n                high=mid-1\\n                ans=mid\\n        return ans          `\\n\\nI used Binary Search Concept to solve this but Case 2 said its wrong \\nx=8\\nmy output=3\\nexpected = 2\\nPlease help"
                    },
                    {
                        "username": "mohiwalla",
                        "content": "Two minutes of silence for the Python and JavaScript users. :)"
                    }
                ]
            },
            {
                "id": 1574875,
                "content": [
                    {
                        "username": "sakethbhardwajV",
                        "content": "this problem has an edge cases where it causes integer overflow..\\nso instead of checking `(mid * mid == x)` which causes integer overflow write the condition as `(x / mid == mid)` and similar condition for else if cases... "
                    },
                    {
                        "username": "bradwick21",
                        "content": "thanks man"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 beginner\\'s tip :: just a binary search application"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Sorry for a newbie question...\\nCan we use Binary search for this problem? \\nCan we use Binary search on integers ?\\n"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "ya definitely\\n"
                    },
                    {
                        "username": "_ast0",
                        "content": "![image](https://assets.leetcode.com/users/images/cb663b54-6011-4ef8-9e5b-b904151e90c0_1604983977.0130923.png)\\n"
                    },
                    {
                        "username": "9902699141a",
                        "content": "upvote creative way doing but we need write our own algo."
                    },
                    {
                        "username": "mayank-goyal",
                        "content": "What are you getting by submitting pre-defined functions?"
                    },
                    {
                        "username": "chognzi",
                        "content": "![image](https://assets.leetcode.com/users/chognzi/image_1570974209.png)\\n894427 should be the correct answer!"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "With 2 as input, \"Expected answer\" gives 1;\\nWith -1 as input, \"Expected answer\" gives -2147483648;\\n\\nThe input should be non-negative, otherwise it's meaningless.\\nThe output should be double, sqrt(2) should return 1.414... (until the double precision)"
                    },
                    {
                        "username": "akshat005",
                        "content": "Under root of negative number is a complex number! maybe that\\'s why we are not getting accurate answer!"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using simple binary search based on the explanation at \\n[Square Root Using Binary Search ](https://algotree.org/algorithms/binary_search/squareroot/)"
                    },
                    {
                        "username": "turbocv",
                        "content": "Actually, I think this problem needs more explanations.\\nX is not the perfect square number, besides, we want to find the closest int which is smaller than or equals to exact sqrt(x)."
                    },
                    {
                        "username": "kgyanender4",
                        "content": "`class Solution:\\n    def mySqrt(self, x: int) -> int:\\n        low=1\\n        high=x\\n        ans=-1\\n        while(low<=high):\\n            mid=(low+high)//2\\n            midsq=mid*mid\\n            if midsq==x:\\n                return mid\\n            elif midsq<x:\\n                low=mid+1\\n            else:\\n                high=mid-1\\n                ans=mid\\n        return ans          `\\n\\nI used Binary Search Concept to solve this but Case 2 said its wrong \\nx=8\\nmy output=3\\nexpected = 2\\nPlease help"
                    },
                    {
                        "username": "mohiwalla",
                        "content": "Two minutes of silence for the Python and JavaScript users. :)"
                    }
                ]
            },
            {
                "id": 1567838,
                "content": [
                    {
                        "username": "sakethbhardwajV",
                        "content": "this problem has an edge cases where it causes integer overflow..\\nso instead of checking `(mid * mid == x)` which causes integer overflow write the condition as `(x / mid == mid)` and similar condition for else if cases... "
                    },
                    {
                        "username": "bradwick21",
                        "content": "thanks man"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 beginner\\'s tip :: just a binary search application"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Sorry for a newbie question...\\nCan we use Binary search for this problem? \\nCan we use Binary search on integers ?\\n"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "ya definitely\\n"
                    },
                    {
                        "username": "_ast0",
                        "content": "![image](https://assets.leetcode.com/users/images/cb663b54-6011-4ef8-9e5b-b904151e90c0_1604983977.0130923.png)\\n"
                    },
                    {
                        "username": "9902699141a",
                        "content": "upvote creative way doing but we need write our own algo."
                    },
                    {
                        "username": "mayank-goyal",
                        "content": "What are you getting by submitting pre-defined functions?"
                    },
                    {
                        "username": "chognzi",
                        "content": "![image](https://assets.leetcode.com/users/chognzi/image_1570974209.png)\\n894427 should be the correct answer!"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "With 2 as input, \"Expected answer\" gives 1;\\nWith -1 as input, \"Expected answer\" gives -2147483648;\\n\\nThe input should be non-negative, otherwise it's meaningless.\\nThe output should be double, sqrt(2) should return 1.414... (until the double precision)"
                    },
                    {
                        "username": "akshat005",
                        "content": "Under root of negative number is a complex number! maybe that\\'s why we are not getting accurate answer!"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using simple binary search based on the explanation at \\n[Square Root Using Binary Search ](https://algotree.org/algorithms/binary_search/squareroot/)"
                    },
                    {
                        "username": "turbocv",
                        "content": "Actually, I think this problem needs more explanations.\\nX is not the perfect square number, besides, we want to find the closest int which is smaller than or equals to exact sqrt(x)."
                    },
                    {
                        "username": "kgyanender4",
                        "content": "`class Solution:\\n    def mySqrt(self, x: int) -> int:\\n        low=1\\n        high=x\\n        ans=-1\\n        while(low<=high):\\n            mid=(low+high)//2\\n            midsq=mid*mid\\n            if midsq==x:\\n                return mid\\n            elif midsq<x:\\n                low=mid+1\\n            else:\\n                high=mid-1\\n                ans=mid\\n        return ans          `\\n\\nI used Binary Search Concept to solve this but Case 2 said its wrong \\nx=8\\nmy output=3\\nexpected = 2\\nPlease help"
                    },
                    {
                        "username": "mohiwalla",
                        "content": "Two minutes of silence for the Python and JavaScript users. :)"
                    }
                ]
            },
            {
                "id": 2016911,
                "content": [
                    {
                        "username": "sakethbhardwajV",
                        "content": "this problem has an edge cases where it causes integer overflow..\\nso instead of checking `(mid * mid == x)` which causes integer overflow write the condition as `(x / mid == mid)` and similar condition for else if cases... "
                    },
                    {
                        "username": "bradwick21",
                        "content": "thanks man"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 beginner\\'s tip :: just a binary search application"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Sorry for a newbie question...\\nCan we use Binary search for this problem? \\nCan we use Binary search on integers ?\\n"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "ya definitely\\n"
                    },
                    {
                        "username": "_ast0",
                        "content": "![image](https://assets.leetcode.com/users/images/cb663b54-6011-4ef8-9e5b-b904151e90c0_1604983977.0130923.png)\\n"
                    },
                    {
                        "username": "9902699141a",
                        "content": "upvote creative way doing but we need write our own algo."
                    },
                    {
                        "username": "mayank-goyal",
                        "content": "What are you getting by submitting pre-defined functions?"
                    },
                    {
                        "username": "chognzi",
                        "content": "![image](https://assets.leetcode.com/users/chognzi/image_1570974209.png)\\n894427 should be the correct answer!"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "With 2 as input, \"Expected answer\" gives 1;\\nWith -1 as input, \"Expected answer\" gives -2147483648;\\n\\nThe input should be non-negative, otherwise it's meaningless.\\nThe output should be double, sqrt(2) should return 1.414... (until the double precision)"
                    },
                    {
                        "username": "akshat005",
                        "content": "Under root of negative number is a complex number! maybe that\\'s why we are not getting accurate answer!"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using simple binary search based on the explanation at \\n[Square Root Using Binary Search ](https://algotree.org/algorithms/binary_search/squareroot/)"
                    },
                    {
                        "username": "turbocv",
                        "content": "Actually, I think this problem needs more explanations.\\nX is not the perfect square number, besides, we want to find the closest int which is smaller than or equals to exact sqrt(x)."
                    },
                    {
                        "username": "kgyanender4",
                        "content": "`class Solution:\\n    def mySqrt(self, x: int) -> int:\\n        low=1\\n        high=x\\n        ans=-1\\n        while(low<=high):\\n            mid=(low+high)//2\\n            midsq=mid*mid\\n            if midsq==x:\\n                return mid\\n            elif midsq<x:\\n                low=mid+1\\n            else:\\n                high=mid-1\\n                ans=mid\\n        return ans          `\\n\\nI used Binary Search Concept to solve this but Case 2 said its wrong \\nx=8\\nmy output=3\\nexpected = 2\\nPlease help"
                    },
                    {
                        "username": "mohiwalla",
                        "content": "Two minutes of silence for the Python and JavaScript users. :)"
                    }
                ]
            },
            {
                "id": 2006507,
                "content": [
                    {
                        "username": "sakethbhardwajV",
                        "content": "this problem has an edge cases where it causes integer overflow..\\nso instead of checking `(mid * mid == x)` which causes integer overflow write the condition as `(x / mid == mid)` and similar condition for else if cases... "
                    },
                    {
                        "username": "bradwick21",
                        "content": "thanks man"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 beginner\\'s tip :: just a binary search application"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Sorry for a newbie question...\\nCan we use Binary search for this problem? \\nCan we use Binary search on integers ?\\n"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "ya definitely\\n"
                    },
                    {
                        "username": "_ast0",
                        "content": "![image](https://assets.leetcode.com/users/images/cb663b54-6011-4ef8-9e5b-b904151e90c0_1604983977.0130923.png)\\n"
                    },
                    {
                        "username": "9902699141a",
                        "content": "upvote creative way doing but we need write our own algo."
                    },
                    {
                        "username": "mayank-goyal",
                        "content": "What are you getting by submitting pre-defined functions?"
                    },
                    {
                        "username": "chognzi",
                        "content": "![image](https://assets.leetcode.com/users/chognzi/image_1570974209.png)\\n894427 should be the correct answer!"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "With 2 as input, \"Expected answer\" gives 1;\\nWith -1 as input, \"Expected answer\" gives -2147483648;\\n\\nThe input should be non-negative, otherwise it's meaningless.\\nThe output should be double, sqrt(2) should return 1.414... (until the double precision)"
                    },
                    {
                        "username": "akshat005",
                        "content": "Under root of negative number is a complex number! maybe that\\'s why we are not getting accurate answer!"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using simple binary search based on the explanation at \\n[Square Root Using Binary Search ](https://algotree.org/algorithms/binary_search/squareroot/)"
                    },
                    {
                        "username": "turbocv",
                        "content": "Actually, I think this problem needs more explanations.\\nX is not the perfect square number, besides, we want to find the closest int which is smaller than or equals to exact sqrt(x)."
                    },
                    {
                        "username": "kgyanender4",
                        "content": "`class Solution:\\n    def mySqrt(self, x: int) -> int:\\n        low=1\\n        high=x\\n        ans=-1\\n        while(low<=high):\\n            mid=(low+high)//2\\n            midsq=mid*mid\\n            if midsq==x:\\n                return mid\\n            elif midsq<x:\\n                low=mid+1\\n            else:\\n                high=mid-1\\n                ans=mid\\n        return ans          `\\n\\nI used Binary Search Concept to solve this but Case 2 said its wrong \\nx=8\\nmy output=3\\nexpected = 2\\nPlease help"
                    },
                    {
                        "username": "mohiwalla",
                        "content": "Two minutes of silence for the Python and JavaScript users. :)"
                    }
                ]
            },
            {
                "id": 2002368,
                "content": [
                    {
                        "username": "bhuppidhamii",
                        "content": "I love 69."
                    },
                    {
                        "username": "sitanggang",
                        "content": "var mySqrt = function(x) {\n    let num = 0;\n\n    while(num * num <= x){\n      num++\n    }\n    return num-1\n};"
                    },
                    {
                        "username": "vinnnu",
                        "content": "hint: binary search"
                    },
                    {
                        "username": "riyaJH",
                        "content": "can anyone tell me what\\'s wrong with my code?\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int low = 1;\\n        int high = x;\\n        int res = 0;\\n        while(low<=high){         \\n            int mid = low + (high - low)/2;\\n            int msq = mid*mid;\\n            if(msq==x)\\n            return mid;\\n\\n            else if(msq<x){\\n            res = mid;\\n            low = mid+1;}\\n\\n            else\\n            high = mid-1;\\n        }\\n        return res;\\n    }\\n}\\n\\nOUTPUT:\\nInput\\nx =\\n2147395599\\n14 / 1017 testcases passed\\nOutput\\n2147395599\\nExpected\\n46339"
                    },
                    {
                        "username": "G_HoST-1008",
                        "content": "use long long int data type instead of int, in res and msq"
                    },
                    {
                        "username": "Anup_303030",
                        "content": "error is comming up\n Error is : time limit Exceeded\n\nclass Solution {\n    public int mySqrt(int x) {\n\n              int low = 1;\n              int high = x;\n              int ans = 0;\n\n              while (low<= high)\n              {\n                 int mid = (low + high)/2;\n                int sqr = mid*mid;\n\n                if(sqr == x)\n                {\n                   return mid;\n\n                }\n                else if(sqr < x)\n                {\n                    ans = mid;\n                    low = mid+1;\n                }\n                else\n                {\n                    high = mid -1;\n                }\n                \n              }\n                    return ans;\n    }\n    \n    \n}\n\nerror is comming up\n Error is : time limit Exceeded"
                    },
                    {
                        "username": "leap2014",
                        "content": "sqrt(3) = 1.732. So it makes more sense that the result is 2 instead of 1."
                    },
                    {
                        "username": "sainath81061",
                        "content": "//Use  this code in c#  \\npublic int MySqrt(int x) {\\n        long n =1,sum;\\n        sum =  n * n;\\n      if(x != 1){\\n      while (x >= sum)\\n        {\\n            n++;\\n            sum = n * n;\\n           \\n        }\\n      }else\\n        {\\n           return (int)n;\\n        }      \\n        return (int) (n -1);  \\n    }"
                    },
                    {
                        "username": "arnavjain",
                        "content": "return math.floor(sqrt(x))"
                    },
                    {
                        "username": "byte101",
                        "content": "Here we use the binary search, because \\n1. num are sorted exam 9 -> {1,2,3,4,5,6,7,8,9}\\n2. and the answer will always  <= to mid\\nlet\\'s take an example (sqrt(9))\\nand the answer belongs to half of the array {1,2,3,4}\\n\\nTime Complexity - O(log(n/2))\\nSpace - O(1)"
                    },
                    {
                        "username": "user4173R",
                        "content": "math.sqrt() function in python is not violating any requirements, so i guess it would suffice"
                    },
                    {
                        "username": "laxxy",
                        "content": "```cpp\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if(x==0){\n            return 0;\n        }\n        if(x==1 || x==2 || x==3){\n            return 1;\n        }\n        for(int i=1;i<=x/2;i++){\n            if(x/i==i){\n                return i;\n            }\n            else if(x/i<i+1){\n                return i-1;\n            }\n        } \n        return -1;\n    }\n};\n```\nhow is this solution?"
                    }
                ]
            },
            {
                "id": 1973644,
                "content": [
                    {
                        "username": "bhuppidhamii",
                        "content": "I love 69."
                    },
                    {
                        "username": "sitanggang",
                        "content": "var mySqrt = function(x) {\n    let num = 0;\n\n    while(num * num <= x){\n      num++\n    }\n    return num-1\n};"
                    },
                    {
                        "username": "vinnnu",
                        "content": "hint: binary search"
                    },
                    {
                        "username": "riyaJH",
                        "content": "can anyone tell me what\\'s wrong with my code?\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int low = 1;\\n        int high = x;\\n        int res = 0;\\n        while(low<=high){         \\n            int mid = low + (high - low)/2;\\n            int msq = mid*mid;\\n            if(msq==x)\\n            return mid;\\n\\n            else if(msq<x){\\n            res = mid;\\n            low = mid+1;}\\n\\n            else\\n            high = mid-1;\\n        }\\n        return res;\\n    }\\n}\\n\\nOUTPUT:\\nInput\\nx =\\n2147395599\\n14 / 1017 testcases passed\\nOutput\\n2147395599\\nExpected\\n46339"
                    },
                    {
                        "username": "G_HoST-1008",
                        "content": "use long long int data type instead of int, in res and msq"
                    },
                    {
                        "username": "Anup_303030",
                        "content": "error is comming up\n Error is : time limit Exceeded\n\nclass Solution {\n    public int mySqrt(int x) {\n\n              int low = 1;\n              int high = x;\n              int ans = 0;\n\n              while (low<= high)\n              {\n                 int mid = (low + high)/2;\n                int sqr = mid*mid;\n\n                if(sqr == x)\n                {\n                   return mid;\n\n                }\n                else if(sqr < x)\n                {\n                    ans = mid;\n                    low = mid+1;\n                }\n                else\n                {\n                    high = mid -1;\n                }\n                \n              }\n                    return ans;\n    }\n    \n    \n}\n\nerror is comming up\n Error is : time limit Exceeded"
                    },
                    {
                        "username": "leap2014",
                        "content": "sqrt(3) = 1.732. So it makes more sense that the result is 2 instead of 1."
                    },
                    {
                        "username": "sainath81061",
                        "content": "//Use  this code in c#  \\npublic int MySqrt(int x) {\\n        long n =1,sum;\\n        sum =  n * n;\\n      if(x != 1){\\n      while (x >= sum)\\n        {\\n            n++;\\n            sum = n * n;\\n           \\n        }\\n      }else\\n        {\\n           return (int)n;\\n        }      \\n        return (int) (n -1);  \\n    }"
                    },
                    {
                        "username": "arnavjain",
                        "content": "return math.floor(sqrt(x))"
                    },
                    {
                        "username": "byte101",
                        "content": "Here we use the binary search, because \\n1. num are sorted exam 9 -> {1,2,3,4,5,6,7,8,9}\\n2. and the answer will always  <= to mid\\nlet\\'s take an example (sqrt(9))\\nand the answer belongs to half of the array {1,2,3,4}\\n\\nTime Complexity - O(log(n/2))\\nSpace - O(1)"
                    },
                    {
                        "username": "user4173R",
                        "content": "math.sqrt() function in python is not violating any requirements, so i guess it would suffice"
                    },
                    {
                        "username": "laxxy",
                        "content": "```cpp\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if(x==0){\n            return 0;\n        }\n        if(x==1 || x==2 || x==3){\n            return 1;\n        }\n        for(int i=1;i<=x/2;i++){\n            if(x/i==i){\n                return i;\n            }\n            else if(x/i<i+1){\n                return i-1;\n            }\n        } \n        return -1;\n    }\n};\n```\nhow is this solution?"
                    }
                ]
            },
            {
                "id": 1870945,
                "content": [
                    {
                        "username": "bhuppidhamii",
                        "content": "I love 69."
                    },
                    {
                        "username": "sitanggang",
                        "content": "var mySqrt = function(x) {\n    let num = 0;\n\n    while(num * num <= x){\n      num++\n    }\n    return num-1\n};"
                    },
                    {
                        "username": "vinnnu",
                        "content": "hint: binary search"
                    },
                    {
                        "username": "riyaJH",
                        "content": "can anyone tell me what\\'s wrong with my code?\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int low = 1;\\n        int high = x;\\n        int res = 0;\\n        while(low<=high){         \\n            int mid = low + (high - low)/2;\\n            int msq = mid*mid;\\n            if(msq==x)\\n            return mid;\\n\\n            else if(msq<x){\\n            res = mid;\\n            low = mid+1;}\\n\\n            else\\n            high = mid-1;\\n        }\\n        return res;\\n    }\\n}\\n\\nOUTPUT:\\nInput\\nx =\\n2147395599\\n14 / 1017 testcases passed\\nOutput\\n2147395599\\nExpected\\n46339"
                    },
                    {
                        "username": "G_HoST-1008",
                        "content": "use long long int data type instead of int, in res and msq"
                    },
                    {
                        "username": "Anup_303030",
                        "content": "error is comming up\n Error is : time limit Exceeded\n\nclass Solution {\n    public int mySqrt(int x) {\n\n              int low = 1;\n              int high = x;\n              int ans = 0;\n\n              while (low<= high)\n              {\n                 int mid = (low + high)/2;\n                int sqr = mid*mid;\n\n                if(sqr == x)\n                {\n                   return mid;\n\n                }\n                else if(sqr < x)\n                {\n                    ans = mid;\n                    low = mid+1;\n                }\n                else\n                {\n                    high = mid -1;\n                }\n                \n              }\n                    return ans;\n    }\n    \n    \n}\n\nerror is comming up\n Error is : time limit Exceeded"
                    },
                    {
                        "username": "leap2014",
                        "content": "sqrt(3) = 1.732. So it makes more sense that the result is 2 instead of 1."
                    },
                    {
                        "username": "sainath81061",
                        "content": "//Use  this code in c#  \\npublic int MySqrt(int x) {\\n        long n =1,sum;\\n        sum =  n * n;\\n      if(x != 1){\\n      while (x >= sum)\\n        {\\n            n++;\\n            sum = n * n;\\n           \\n        }\\n      }else\\n        {\\n           return (int)n;\\n        }      \\n        return (int) (n -1);  \\n    }"
                    },
                    {
                        "username": "arnavjain",
                        "content": "return math.floor(sqrt(x))"
                    },
                    {
                        "username": "byte101",
                        "content": "Here we use the binary search, because \\n1. num are sorted exam 9 -> {1,2,3,4,5,6,7,8,9}\\n2. and the answer will always  <= to mid\\nlet\\'s take an example (sqrt(9))\\nand the answer belongs to half of the array {1,2,3,4}\\n\\nTime Complexity - O(log(n/2))\\nSpace - O(1)"
                    },
                    {
                        "username": "user4173R",
                        "content": "math.sqrt() function in python is not violating any requirements, so i guess it would suffice"
                    },
                    {
                        "username": "laxxy",
                        "content": "```cpp\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if(x==0){\n            return 0;\n        }\n        if(x==1 || x==2 || x==3){\n            return 1;\n        }\n        for(int i=1;i<=x/2;i++){\n            if(x/i==i){\n                return i;\n            }\n            else if(x/i<i+1){\n                return i-1;\n            }\n        } \n        return -1;\n    }\n};\n```\nhow is this solution?"
                    }
                ]
            },
            {
                "id": 1783110,
                "content": [
                    {
                        "username": "bhuppidhamii",
                        "content": "I love 69."
                    },
                    {
                        "username": "sitanggang",
                        "content": "var mySqrt = function(x) {\n    let num = 0;\n\n    while(num * num <= x){\n      num++\n    }\n    return num-1\n};"
                    },
                    {
                        "username": "vinnnu",
                        "content": "hint: binary search"
                    },
                    {
                        "username": "riyaJH",
                        "content": "can anyone tell me what\\'s wrong with my code?\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int low = 1;\\n        int high = x;\\n        int res = 0;\\n        while(low<=high){         \\n            int mid = low + (high - low)/2;\\n            int msq = mid*mid;\\n            if(msq==x)\\n            return mid;\\n\\n            else if(msq<x){\\n            res = mid;\\n            low = mid+1;}\\n\\n            else\\n            high = mid-1;\\n        }\\n        return res;\\n    }\\n}\\n\\nOUTPUT:\\nInput\\nx =\\n2147395599\\n14 / 1017 testcases passed\\nOutput\\n2147395599\\nExpected\\n46339"
                    },
                    {
                        "username": "G_HoST-1008",
                        "content": "use long long int data type instead of int, in res and msq"
                    },
                    {
                        "username": "Anup_303030",
                        "content": "error is comming up\n Error is : time limit Exceeded\n\nclass Solution {\n    public int mySqrt(int x) {\n\n              int low = 1;\n              int high = x;\n              int ans = 0;\n\n              while (low<= high)\n              {\n                 int mid = (low + high)/2;\n                int sqr = mid*mid;\n\n                if(sqr == x)\n                {\n                   return mid;\n\n                }\n                else if(sqr < x)\n                {\n                    ans = mid;\n                    low = mid+1;\n                }\n                else\n                {\n                    high = mid -1;\n                }\n                \n              }\n                    return ans;\n    }\n    \n    \n}\n\nerror is comming up\n Error is : time limit Exceeded"
                    },
                    {
                        "username": "leap2014",
                        "content": "sqrt(3) = 1.732. So it makes more sense that the result is 2 instead of 1."
                    },
                    {
                        "username": "sainath81061",
                        "content": "//Use  this code in c#  \\npublic int MySqrt(int x) {\\n        long n =1,sum;\\n        sum =  n * n;\\n      if(x != 1){\\n      while (x >= sum)\\n        {\\n            n++;\\n            sum = n * n;\\n           \\n        }\\n      }else\\n        {\\n           return (int)n;\\n        }      \\n        return (int) (n -1);  \\n    }"
                    },
                    {
                        "username": "arnavjain",
                        "content": "return math.floor(sqrt(x))"
                    },
                    {
                        "username": "byte101",
                        "content": "Here we use the binary search, because \\n1. num are sorted exam 9 -> {1,2,3,4,5,6,7,8,9}\\n2. and the answer will always  <= to mid\\nlet\\'s take an example (sqrt(9))\\nand the answer belongs to half of the array {1,2,3,4}\\n\\nTime Complexity - O(log(n/2))\\nSpace - O(1)"
                    },
                    {
                        "username": "user4173R",
                        "content": "math.sqrt() function in python is not violating any requirements, so i guess it would suffice"
                    },
                    {
                        "username": "laxxy",
                        "content": "```cpp\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if(x==0){\n            return 0;\n        }\n        if(x==1 || x==2 || x==3){\n            return 1;\n        }\n        for(int i=1;i<=x/2;i++){\n            if(x/i==i){\n                return i;\n            }\n            else if(x/i<i+1){\n                return i-1;\n            }\n        } \n        return -1;\n    }\n};\n```\nhow is this solution?"
                    }
                ]
            },
            {
                "id": 1718056,
                "content": [
                    {
                        "username": "bhuppidhamii",
                        "content": "I love 69."
                    },
                    {
                        "username": "sitanggang",
                        "content": "var mySqrt = function(x) {\n    let num = 0;\n\n    while(num * num <= x){\n      num++\n    }\n    return num-1\n};"
                    },
                    {
                        "username": "vinnnu",
                        "content": "hint: binary search"
                    },
                    {
                        "username": "riyaJH",
                        "content": "can anyone tell me what\\'s wrong with my code?\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int low = 1;\\n        int high = x;\\n        int res = 0;\\n        while(low<=high){         \\n            int mid = low + (high - low)/2;\\n            int msq = mid*mid;\\n            if(msq==x)\\n            return mid;\\n\\n            else if(msq<x){\\n            res = mid;\\n            low = mid+1;}\\n\\n            else\\n            high = mid-1;\\n        }\\n        return res;\\n    }\\n}\\n\\nOUTPUT:\\nInput\\nx =\\n2147395599\\n14 / 1017 testcases passed\\nOutput\\n2147395599\\nExpected\\n46339"
                    },
                    {
                        "username": "G_HoST-1008",
                        "content": "use long long int data type instead of int, in res and msq"
                    },
                    {
                        "username": "Anup_303030",
                        "content": "error is comming up\n Error is : time limit Exceeded\n\nclass Solution {\n    public int mySqrt(int x) {\n\n              int low = 1;\n              int high = x;\n              int ans = 0;\n\n              while (low<= high)\n              {\n                 int mid = (low + high)/2;\n                int sqr = mid*mid;\n\n                if(sqr == x)\n                {\n                   return mid;\n\n                }\n                else if(sqr < x)\n                {\n                    ans = mid;\n                    low = mid+1;\n                }\n                else\n                {\n                    high = mid -1;\n                }\n                \n              }\n                    return ans;\n    }\n    \n    \n}\n\nerror is comming up\n Error is : time limit Exceeded"
                    },
                    {
                        "username": "leap2014",
                        "content": "sqrt(3) = 1.732. So it makes more sense that the result is 2 instead of 1."
                    },
                    {
                        "username": "sainath81061",
                        "content": "//Use  this code in c#  \\npublic int MySqrt(int x) {\\n        long n =1,sum;\\n        sum =  n * n;\\n      if(x != 1){\\n      while (x >= sum)\\n        {\\n            n++;\\n            sum = n * n;\\n           \\n        }\\n      }else\\n        {\\n           return (int)n;\\n        }      \\n        return (int) (n -1);  \\n    }"
                    },
                    {
                        "username": "arnavjain",
                        "content": "return math.floor(sqrt(x))"
                    },
                    {
                        "username": "byte101",
                        "content": "Here we use the binary search, because \\n1. num are sorted exam 9 -> {1,2,3,4,5,6,7,8,9}\\n2. and the answer will always  <= to mid\\nlet\\'s take an example (sqrt(9))\\nand the answer belongs to half of the array {1,2,3,4}\\n\\nTime Complexity - O(log(n/2))\\nSpace - O(1)"
                    },
                    {
                        "username": "user4173R",
                        "content": "math.sqrt() function in python is not violating any requirements, so i guess it would suffice"
                    },
                    {
                        "username": "laxxy",
                        "content": "```cpp\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if(x==0){\n            return 0;\n        }\n        if(x==1 || x==2 || x==3){\n            return 1;\n        }\n        for(int i=1;i<=x/2;i++){\n            if(x/i==i){\n                return i;\n            }\n            else if(x/i<i+1){\n                return i-1;\n            }\n        } \n        return -1;\n    }\n};\n```\nhow is this solution?"
                    }
                ]
            },
            {
                "id": 1571168,
                "content": [
                    {
                        "username": "bhuppidhamii",
                        "content": "I love 69."
                    },
                    {
                        "username": "sitanggang",
                        "content": "var mySqrt = function(x) {\n    let num = 0;\n\n    while(num * num <= x){\n      num++\n    }\n    return num-1\n};"
                    },
                    {
                        "username": "vinnnu",
                        "content": "hint: binary search"
                    },
                    {
                        "username": "riyaJH",
                        "content": "can anyone tell me what\\'s wrong with my code?\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int low = 1;\\n        int high = x;\\n        int res = 0;\\n        while(low<=high){         \\n            int mid = low + (high - low)/2;\\n            int msq = mid*mid;\\n            if(msq==x)\\n            return mid;\\n\\n            else if(msq<x){\\n            res = mid;\\n            low = mid+1;}\\n\\n            else\\n            high = mid-1;\\n        }\\n        return res;\\n    }\\n}\\n\\nOUTPUT:\\nInput\\nx =\\n2147395599\\n14 / 1017 testcases passed\\nOutput\\n2147395599\\nExpected\\n46339"
                    },
                    {
                        "username": "G_HoST-1008",
                        "content": "use long long int data type instead of int, in res and msq"
                    },
                    {
                        "username": "Anup_303030",
                        "content": "error is comming up\n Error is : time limit Exceeded\n\nclass Solution {\n    public int mySqrt(int x) {\n\n              int low = 1;\n              int high = x;\n              int ans = 0;\n\n              while (low<= high)\n              {\n                 int mid = (low + high)/2;\n                int sqr = mid*mid;\n\n                if(sqr == x)\n                {\n                   return mid;\n\n                }\n                else if(sqr < x)\n                {\n                    ans = mid;\n                    low = mid+1;\n                }\n                else\n                {\n                    high = mid -1;\n                }\n                \n              }\n                    return ans;\n    }\n    \n    \n}\n\nerror is comming up\n Error is : time limit Exceeded"
                    },
                    {
                        "username": "leap2014",
                        "content": "sqrt(3) = 1.732. So it makes more sense that the result is 2 instead of 1."
                    },
                    {
                        "username": "sainath81061",
                        "content": "//Use  this code in c#  \\npublic int MySqrt(int x) {\\n        long n =1,sum;\\n        sum =  n * n;\\n      if(x != 1){\\n      while (x >= sum)\\n        {\\n            n++;\\n            sum = n * n;\\n           \\n        }\\n      }else\\n        {\\n           return (int)n;\\n        }      \\n        return (int) (n -1);  \\n    }"
                    },
                    {
                        "username": "arnavjain",
                        "content": "return math.floor(sqrt(x))"
                    },
                    {
                        "username": "byte101",
                        "content": "Here we use the binary search, because \\n1. num are sorted exam 9 -> {1,2,3,4,5,6,7,8,9}\\n2. and the answer will always  <= to mid\\nlet\\'s take an example (sqrt(9))\\nand the answer belongs to half of the array {1,2,3,4}\\n\\nTime Complexity - O(log(n/2))\\nSpace - O(1)"
                    },
                    {
                        "username": "user4173R",
                        "content": "math.sqrt() function in python is not violating any requirements, so i guess it would suffice"
                    },
                    {
                        "username": "laxxy",
                        "content": "```cpp\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if(x==0){\n            return 0;\n        }\n        if(x==1 || x==2 || x==3){\n            return 1;\n        }\n        for(int i=1;i<=x/2;i++){\n            if(x/i==i){\n                return i;\n            }\n            else if(x/i<i+1){\n                return i-1;\n            }\n        } \n        return -1;\n    }\n};\n```\nhow is this solution?"
                    }
                ]
            },
            {
                "id": 1573549,
                "content": [
                    {
                        "username": "bhuppidhamii",
                        "content": "I love 69."
                    },
                    {
                        "username": "sitanggang",
                        "content": "var mySqrt = function(x) {\n    let num = 0;\n\n    while(num * num <= x){\n      num++\n    }\n    return num-1\n};"
                    },
                    {
                        "username": "vinnnu",
                        "content": "hint: binary search"
                    },
                    {
                        "username": "riyaJH",
                        "content": "can anyone tell me what\\'s wrong with my code?\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int low = 1;\\n        int high = x;\\n        int res = 0;\\n        while(low<=high){         \\n            int mid = low + (high - low)/2;\\n            int msq = mid*mid;\\n            if(msq==x)\\n            return mid;\\n\\n            else if(msq<x){\\n            res = mid;\\n            low = mid+1;}\\n\\n            else\\n            high = mid-1;\\n        }\\n        return res;\\n    }\\n}\\n\\nOUTPUT:\\nInput\\nx =\\n2147395599\\n14 / 1017 testcases passed\\nOutput\\n2147395599\\nExpected\\n46339"
                    },
                    {
                        "username": "G_HoST-1008",
                        "content": "use long long int data type instead of int, in res and msq"
                    },
                    {
                        "username": "Anup_303030",
                        "content": "error is comming up\n Error is : time limit Exceeded\n\nclass Solution {\n    public int mySqrt(int x) {\n\n              int low = 1;\n              int high = x;\n              int ans = 0;\n\n              while (low<= high)\n              {\n                 int mid = (low + high)/2;\n                int sqr = mid*mid;\n\n                if(sqr == x)\n                {\n                   return mid;\n\n                }\n                else if(sqr < x)\n                {\n                    ans = mid;\n                    low = mid+1;\n                }\n                else\n                {\n                    high = mid -1;\n                }\n                \n              }\n                    return ans;\n    }\n    \n    \n}\n\nerror is comming up\n Error is : time limit Exceeded"
                    },
                    {
                        "username": "leap2014",
                        "content": "sqrt(3) = 1.732. So it makes more sense that the result is 2 instead of 1."
                    },
                    {
                        "username": "sainath81061",
                        "content": "//Use  this code in c#  \\npublic int MySqrt(int x) {\\n        long n =1,sum;\\n        sum =  n * n;\\n      if(x != 1){\\n      while (x >= sum)\\n        {\\n            n++;\\n            sum = n * n;\\n           \\n        }\\n      }else\\n        {\\n           return (int)n;\\n        }      \\n        return (int) (n -1);  \\n    }"
                    },
                    {
                        "username": "arnavjain",
                        "content": "return math.floor(sqrt(x))"
                    },
                    {
                        "username": "byte101",
                        "content": "Here we use the binary search, because \\n1. num are sorted exam 9 -> {1,2,3,4,5,6,7,8,9}\\n2. and the answer will always  <= to mid\\nlet\\'s take an example (sqrt(9))\\nand the answer belongs to half of the array {1,2,3,4}\\n\\nTime Complexity - O(log(n/2))\\nSpace - O(1)"
                    },
                    {
                        "username": "user4173R",
                        "content": "math.sqrt() function in python is not violating any requirements, so i guess it would suffice"
                    },
                    {
                        "username": "laxxy",
                        "content": "```cpp\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if(x==0){\n            return 0;\n        }\n        if(x==1 || x==2 || x==3){\n            return 1;\n        }\n        for(int i=1;i<=x/2;i++){\n            if(x/i==i){\n                return i;\n            }\n            else if(x/i<i+1){\n                return i-1;\n            }\n        } \n        return -1;\n    }\n};\n```\nhow is this solution?"
                    }
                ]
            },
            {
                "id": 2071559,
                "content": [
                    {
                        "username": "bhuppidhamii",
                        "content": "I love 69."
                    },
                    {
                        "username": "sitanggang",
                        "content": "var mySqrt = function(x) {\n    let num = 0;\n\n    while(num * num <= x){\n      num++\n    }\n    return num-1\n};"
                    },
                    {
                        "username": "vinnnu",
                        "content": "hint: binary search"
                    },
                    {
                        "username": "riyaJH",
                        "content": "can anyone tell me what\\'s wrong with my code?\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int low = 1;\\n        int high = x;\\n        int res = 0;\\n        while(low<=high){         \\n            int mid = low + (high - low)/2;\\n            int msq = mid*mid;\\n            if(msq==x)\\n            return mid;\\n\\n            else if(msq<x){\\n            res = mid;\\n            low = mid+1;}\\n\\n            else\\n            high = mid-1;\\n        }\\n        return res;\\n    }\\n}\\n\\nOUTPUT:\\nInput\\nx =\\n2147395599\\n14 / 1017 testcases passed\\nOutput\\n2147395599\\nExpected\\n46339"
                    },
                    {
                        "username": "G_HoST-1008",
                        "content": "use long long int data type instead of int, in res and msq"
                    },
                    {
                        "username": "Anup_303030",
                        "content": "error is comming up\n Error is : time limit Exceeded\n\nclass Solution {\n    public int mySqrt(int x) {\n\n              int low = 1;\n              int high = x;\n              int ans = 0;\n\n              while (low<= high)\n              {\n                 int mid = (low + high)/2;\n                int sqr = mid*mid;\n\n                if(sqr == x)\n                {\n                   return mid;\n\n                }\n                else if(sqr < x)\n                {\n                    ans = mid;\n                    low = mid+1;\n                }\n                else\n                {\n                    high = mid -1;\n                }\n                \n              }\n                    return ans;\n    }\n    \n    \n}\n\nerror is comming up\n Error is : time limit Exceeded"
                    },
                    {
                        "username": "leap2014",
                        "content": "sqrt(3) = 1.732. So it makes more sense that the result is 2 instead of 1."
                    },
                    {
                        "username": "sainath81061",
                        "content": "//Use  this code in c#  \\npublic int MySqrt(int x) {\\n        long n =1,sum;\\n        sum =  n * n;\\n      if(x != 1){\\n      while (x >= sum)\\n        {\\n            n++;\\n            sum = n * n;\\n           \\n        }\\n      }else\\n        {\\n           return (int)n;\\n        }      \\n        return (int) (n -1);  \\n    }"
                    },
                    {
                        "username": "arnavjain",
                        "content": "return math.floor(sqrt(x))"
                    },
                    {
                        "username": "byte101",
                        "content": "Here we use the binary search, because \\n1. num are sorted exam 9 -> {1,2,3,4,5,6,7,8,9}\\n2. and the answer will always  <= to mid\\nlet\\'s take an example (sqrt(9))\\nand the answer belongs to half of the array {1,2,3,4}\\n\\nTime Complexity - O(log(n/2))\\nSpace - O(1)"
                    },
                    {
                        "username": "user4173R",
                        "content": "math.sqrt() function in python is not violating any requirements, so i guess it would suffice"
                    },
                    {
                        "username": "laxxy",
                        "content": "```cpp\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if(x==0){\n            return 0;\n        }\n        if(x==1 || x==2 || x==3){\n            return 1;\n        }\n        for(int i=1;i<=x/2;i++){\n            if(x/i==i){\n                return i;\n            }\n            else if(x/i<i+1){\n                return i-1;\n            }\n        } \n        return -1;\n    }\n};\n```\nhow is this solution?"
                    }
                ]
            },
            {
                "id": 2068128,
                "content": [
                    {
                        "username": "bhuppidhamii",
                        "content": "I love 69."
                    },
                    {
                        "username": "sitanggang",
                        "content": "var mySqrt = function(x) {\n    let num = 0;\n\n    while(num * num <= x){\n      num++\n    }\n    return num-1\n};"
                    },
                    {
                        "username": "vinnnu",
                        "content": "hint: binary search"
                    },
                    {
                        "username": "riyaJH",
                        "content": "can anyone tell me what\\'s wrong with my code?\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int low = 1;\\n        int high = x;\\n        int res = 0;\\n        while(low<=high){         \\n            int mid = low + (high - low)/2;\\n            int msq = mid*mid;\\n            if(msq==x)\\n            return mid;\\n\\n            else if(msq<x){\\n            res = mid;\\n            low = mid+1;}\\n\\n            else\\n            high = mid-1;\\n        }\\n        return res;\\n    }\\n}\\n\\nOUTPUT:\\nInput\\nx =\\n2147395599\\n14 / 1017 testcases passed\\nOutput\\n2147395599\\nExpected\\n46339"
                    },
                    {
                        "username": "G_HoST-1008",
                        "content": "use long long int data type instead of int, in res and msq"
                    },
                    {
                        "username": "Anup_303030",
                        "content": "error is comming up\n Error is : time limit Exceeded\n\nclass Solution {\n    public int mySqrt(int x) {\n\n              int low = 1;\n              int high = x;\n              int ans = 0;\n\n              while (low<= high)\n              {\n                 int mid = (low + high)/2;\n                int sqr = mid*mid;\n\n                if(sqr == x)\n                {\n                   return mid;\n\n                }\n                else if(sqr < x)\n                {\n                    ans = mid;\n                    low = mid+1;\n                }\n                else\n                {\n                    high = mid -1;\n                }\n                \n              }\n                    return ans;\n    }\n    \n    \n}\n\nerror is comming up\n Error is : time limit Exceeded"
                    },
                    {
                        "username": "leap2014",
                        "content": "sqrt(3) = 1.732. So it makes more sense that the result is 2 instead of 1."
                    },
                    {
                        "username": "sainath81061",
                        "content": "//Use  this code in c#  \\npublic int MySqrt(int x) {\\n        long n =1,sum;\\n        sum =  n * n;\\n      if(x != 1){\\n      while (x >= sum)\\n        {\\n            n++;\\n            sum = n * n;\\n           \\n        }\\n      }else\\n        {\\n           return (int)n;\\n        }      \\n        return (int) (n -1);  \\n    }"
                    },
                    {
                        "username": "arnavjain",
                        "content": "return math.floor(sqrt(x))"
                    },
                    {
                        "username": "byte101",
                        "content": "Here we use the binary search, because \\n1. num are sorted exam 9 -> {1,2,3,4,5,6,7,8,9}\\n2. and the answer will always  <= to mid\\nlet\\'s take an example (sqrt(9))\\nand the answer belongs to half of the array {1,2,3,4}\\n\\nTime Complexity - O(log(n/2))\\nSpace - O(1)"
                    },
                    {
                        "username": "user4173R",
                        "content": "math.sqrt() function in python is not violating any requirements, so i guess it would suffice"
                    },
                    {
                        "username": "laxxy",
                        "content": "```cpp\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if(x==0){\n            return 0;\n        }\n        if(x==1 || x==2 || x==3){\n            return 1;\n        }\n        for(int i=1;i<=x/2;i++){\n            if(x/i==i){\n                return i;\n            }\n            else if(x/i<i+1){\n                return i-1;\n            }\n        } \n        return -1;\n    }\n};\n```\nhow is this solution?"
                    }
                ]
            },
            {
                "id": 2055978,
                "content": [
                    {
                        "username": "bhuppidhamii",
                        "content": "I love 69."
                    },
                    {
                        "username": "sitanggang",
                        "content": "var mySqrt = function(x) {\n    let num = 0;\n\n    while(num * num <= x){\n      num++\n    }\n    return num-1\n};"
                    },
                    {
                        "username": "vinnnu",
                        "content": "hint: binary search"
                    },
                    {
                        "username": "riyaJH",
                        "content": "can anyone tell me what\\'s wrong with my code?\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int low = 1;\\n        int high = x;\\n        int res = 0;\\n        while(low<=high){         \\n            int mid = low + (high - low)/2;\\n            int msq = mid*mid;\\n            if(msq==x)\\n            return mid;\\n\\n            else if(msq<x){\\n            res = mid;\\n            low = mid+1;}\\n\\n            else\\n            high = mid-1;\\n        }\\n        return res;\\n    }\\n}\\n\\nOUTPUT:\\nInput\\nx =\\n2147395599\\n14 / 1017 testcases passed\\nOutput\\n2147395599\\nExpected\\n46339"
                    },
                    {
                        "username": "G_HoST-1008",
                        "content": "use long long int data type instead of int, in res and msq"
                    },
                    {
                        "username": "Anup_303030",
                        "content": "error is comming up\n Error is : time limit Exceeded\n\nclass Solution {\n    public int mySqrt(int x) {\n\n              int low = 1;\n              int high = x;\n              int ans = 0;\n\n              while (low<= high)\n              {\n                 int mid = (low + high)/2;\n                int sqr = mid*mid;\n\n                if(sqr == x)\n                {\n                   return mid;\n\n                }\n                else if(sqr < x)\n                {\n                    ans = mid;\n                    low = mid+1;\n                }\n                else\n                {\n                    high = mid -1;\n                }\n                \n              }\n                    return ans;\n    }\n    \n    \n}\n\nerror is comming up\n Error is : time limit Exceeded"
                    },
                    {
                        "username": "leap2014",
                        "content": "sqrt(3) = 1.732. So it makes more sense that the result is 2 instead of 1."
                    },
                    {
                        "username": "sainath81061",
                        "content": "//Use  this code in c#  \\npublic int MySqrt(int x) {\\n        long n =1,sum;\\n        sum =  n * n;\\n      if(x != 1){\\n      while (x >= sum)\\n        {\\n            n++;\\n            sum = n * n;\\n           \\n        }\\n      }else\\n        {\\n           return (int)n;\\n        }      \\n        return (int) (n -1);  \\n    }"
                    },
                    {
                        "username": "arnavjain",
                        "content": "return math.floor(sqrt(x))"
                    },
                    {
                        "username": "byte101",
                        "content": "Here we use the binary search, because \\n1. num are sorted exam 9 -> {1,2,3,4,5,6,7,8,9}\\n2. and the answer will always  <= to mid\\nlet\\'s take an example (sqrt(9))\\nand the answer belongs to half of the array {1,2,3,4}\\n\\nTime Complexity - O(log(n/2))\\nSpace - O(1)"
                    },
                    {
                        "username": "user4173R",
                        "content": "math.sqrt() function in python is not violating any requirements, so i guess it would suffice"
                    },
                    {
                        "username": "laxxy",
                        "content": "```cpp\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if(x==0){\n            return 0;\n        }\n        if(x==1 || x==2 || x==3){\n            return 1;\n        }\n        for(int i=1;i<=x/2;i++){\n            if(x/i==i){\n                return i;\n            }\n            else if(x/i<i+1){\n                return i-1;\n            }\n        } \n        return -1;\n    }\n};\n```\nhow is this solution?"
                    }
                ]
            },
            {
                "id": 2054504,
                "content": [
                    {
                        "username": "devanshsharma07",
                        "content": "I guess there is a bug in this program. When we talk about nearest integer it should be rouned to nearest integer. If square root of 8 is 2.82 then it should be rounded to 3 as it is the nearest one not to 2."
                    },
                    {
                        "username": "kamrun",
                        "content": "why we are not using decimal values here? I understand we want integer result but during the process why we are not considering decimal value?"
                    },
                    {
                        "username": "sasibunny31",
                        "content": "the given x is of integer type and it stores the 2123643174314 test case but it sqrt number is not storing why????????"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "can we use return sqrt(x);??\\n"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "you can\\'t, in description it self they mentioned, You must not use any built-in exponent function or operator."
                    },
                    {
                        "username": "SAMUDRA_069",
                        "content": "int s=floor(sqrt(n));\n    return s;\ncan i use pre-defined function in coding round?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Why this doesn\\'t work?\\n\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        ans = x\\n        l, r = 0, x\\n        while l <= r:\\n            mid = int(l + (r-l)/2)\\n            if (mid*mid) > x:\\n                r = mid - 1\\n            elif (mid*mid) < x:\\n                ans = l\\n                l = mid + 1\\n            else:\\n                return mid\\n        return ans"
                    },
                    {
                        "username": "SenWang666",
                        "content": "Shouldn\\'t the nearest integer of 2.82842 be 3 instead of 2?"
                    },
                    {
                        "username": "krishnu9",
                        "content": "I hate this problem. Having TCs like 2147483647 causing integer overflow take away the fun from solving algorithmic problems."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me - this problem presents an interesting application of the binary search algorithm. It demonstrates how binary search can be applied to problems beyond searching in a sorted array. Also this problem teaches the concept of avoiding integer overflow."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "How is this easy..."
                    }
                ]
            },
            {
                "id": 2044339,
                "content": [
                    {
                        "username": "devanshsharma07",
                        "content": "I guess there is a bug in this program. When we talk about nearest integer it should be rouned to nearest integer. If square root of 8 is 2.82 then it should be rounded to 3 as it is the nearest one not to 2."
                    },
                    {
                        "username": "kamrun",
                        "content": "why we are not using decimal values here? I understand we want integer result but during the process why we are not considering decimal value?"
                    },
                    {
                        "username": "sasibunny31",
                        "content": "the given x is of integer type and it stores the 2123643174314 test case but it sqrt number is not storing why????????"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "can we use return sqrt(x);??\\n"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "you can\\'t, in description it self they mentioned, You must not use any built-in exponent function or operator."
                    },
                    {
                        "username": "SAMUDRA_069",
                        "content": "int s=floor(sqrt(n));\n    return s;\ncan i use pre-defined function in coding round?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Why this doesn\\'t work?\\n\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        ans = x\\n        l, r = 0, x\\n        while l <= r:\\n            mid = int(l + (r-l)/2)\\n            if (mid*mid) > x:\\n                r = mid - 1\\n            elif (mid*mid) < x:\\n                ans = l\\n                l = mid + 1\\n            else:\\n                return mid\\n        return ans"
                    },
                    {
                        "username": "SenWang666",
                        "content": "Shouldn\\'t the nearest integer of 2.82842 be 3 instead of 2?"
                    },
                    {
                        "username": "krishnu9",
                        "content": "I hate this problem. Having TCs like 2147483647 causing integer overflow take away the fun from solving algorithmic problems."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me - this problem presents an interesting application of the binary search algorithm. It demonstrates how binary search can be applied to problems beyond searching in a sorted array. Also this problem teaches the concept of avoiding integer overflow."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "How is this easy..."
                    }
                ]
            },
            {
                "id": 2023840,
                "content": [
                    {
                        "username": "devanshsharma07",
                        "content": "I guess there is a bug in this program. When we talk about nearest integer it should be rouned to nearest integer. If square root of 8 is 2.82 then it should be rounded to 3 as it is the nearest one not to 2."
                    },
                    {
                        "username": "kamrun",
                        "content": "why we are not using decimal values here? I understand we want integer result but during the process why we are not considering decimal value?"
                    },
                    {
                        "username": "sasibunny31",
                        "content": "the given x is of integer type and it stores the 2123643174314 test case but it sqrt number is not storing why????????"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "can we use return sqrt(x);??\\n"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "you can\\'t, in description it self they mentioned, You must not use any built-in exponent function or operator."
                    },
                    {
                        "username": "SAMUDRA_069",
                        "content": "int s=floor(sqrt(n));\n    return s;\ncan i use pre-defined function in coding round?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Why this doesn\\'t work?\\n\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        ans = x\\n        l, r = 0, x\\n        while l <= r:\\n            mid = int(l + (r-l)/2)\\n            if (mid*mid) > x:\\n                r = mid - 1\\n            elif (mid*mid) < x:\\n                ans = l\\n                l = mid + 1\\n            else:\\n                return mid\\n        return ans"
                    },
                    {
                        "username": "SenWang666",
                        "content": "Shouldn\\'t the nearest integer of 2.82842 be 3 instead of 2?"
                    },
                    {
                        "username": "krishnu9",
                        "content": "I hate this problem. Having TCs like 2147483647 causing integer overflow take away the fun from solving algorithmic problems."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me - this problem presents an interesting application of the binary search algorithm. It demonstrates how binary search can be applied to problems beyond searching in a sorted array. Also this problem teaches the concept of avoiding integer overflow."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "How is this easy..."
                    }
                ]
            },
            {
                "id": 2016650,
                "content": [
                    {
                        "username": "devanshsharma07",
                        "content": "I guess there is a bug in this program. When we talk about nearest integer it should be rouned to nearest integer. If square root of 8 is 2.82 then it should be rounded to 3 as it is the nearest one not to 2."
                    },
                    {
                        "username": "kamrun",
                        "content": "why we are not using decimal values here? I understand we want integer result but during the process why we are not considering decimal value?"
                    },
                    {
                        "username": "sasibunny31",
                        "content": "the given x is of integer type and it stores the 2123643174314 test case but it sqrt number is not storing why????????"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "can we use return sqrt(x);??\\n"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "you can\\'t, in description it self they mentioned, You must not use any built-in exponent function or operator."
                    },
                    {
                        "username": "SAMUDRA_069",
                        "content": "int s=floor(sqrt(n));\n    return s;\ncan i use pre-defined function in coding round?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Why this doesn\\'t work?\\n\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        ans = x\\n        l, r = 0, x\\n        while l <= r:\\n            mid = int(l + (r-l)/2)\\n            if (mid*mid) > x:\\n                r = mid - 1\\n            elif (mid*mid) < x:\\n                ans = l\\n                l = mid + 1\\n            else:\\n                return mid\\n        return ans"
                    },
                    {
                        "username": "SenWang666",
                        "content": "Shouldn\\'t the nearest integer of 2.82842 be 3 instead of 2?"
                    },
                    {
                        "username": "krishnu9",
                        "content": "I hate this problem. Having TCs like 2147483647 causing integer overflow take away the fun from solving algorithmic problems."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me - this problem presents an interesting application of the binary search algorithm. It demonstrates how binary search can be applied to problems beyond searching in a sorted array. Also this problem teaches the concept of avoiding integer overflow."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "How is this easy..."
                    }
                ]
            },
            {
                "id": 2007495,
                "content": [
                    {
                        "username": "devanshsharma07",
                        "content": "I guess there is a bug in this program. When we talk about nearest integer it should be rouned to nearest integer. If square root of 8 is 2.82 then it should be rounded to 3 as it is the nearest one not to 2."
                    },
                    {
                        "username": "kamrun",
                        "content": "why we are not using decimal values here? I understand we want integer result but during the process why we are not considering decimal value?"
                    },
                    {
                        "username": "sasibunny31",
                        "content": "the given x is of integer type and it stores the 2123643174314 test case but it sqrt number is not storing why????????"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "can we use return sqrt(x);??\\n"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "you can\\'t, in description it self they mentioned, You must not use any built-in exponent function or operator."
                    },
                    {
                        "username": "SAMUDRA_069",
                        "content": "int s=floor(sqrt(n));\n    return s;\ncan i use pre-defined function in coding round?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Why this doesn\\'t work?\\n\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        ans = x\\n        l, r = 0, x\\n        while l <= r:\\n            mid = int(l + (r-l)/2)\\n            if (mid*mid) > x:\\n                r = mid - 1\\n            elif (mid*mid) < x:\\n                ans = l\\n                l = mid + 1\\n            else:\\n                return mid\\n        return ans"
                    },
                    {
                        "username": "SenWang666",
                        "content": "Shouldn\\'t the nearest integer of 2.82842 be 3 instead of 2?"
                    },
                    {
                        "username": "krishnu9",
                        "content": "I hate this problem. Having TCs like 2147483647 causing integer overflow take away the fun from solving algorithmic problems."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me - this problem presents an interesting application of the binary search algorithm. It demonstrates how binary search can be applied to problems beyond searching in a sorted array. Also this problem teaches the concept of avoiding integer overflow."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "How is this easy..."
                    }
                ]
            },
            {
                "id": 2004227,
                "content": [
                    {
                        "username": "devanshsharma07",
                        "content": "I guess there is a bug in this program. When we talk about nearest integer it should be rouned to nearest integer. If square root of 8 is 2.82 then it should be rounded to 3 as it is the nearest one not to 2."
                    },
                    {
                        "username": "kamrun",
                        "content": "why we are not using decimal values here? I understand we want integer result but during the process why we are not considering decimal value?"
                    },
                    {
                        "username": "sasibunny31",
                        "content": "the given x is of integer type and it stores the 2123643174314 test case but it sqrt number is not storing why????????"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "can we use return sqrt(x);??\\n"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "you can\\'t, in description it self they mentioned, You must not use any built-in exponent function or operator."
                    },
                    {
                        "username": "SAMUDRA_069",
                        "content": "int s=floor(sqrt(n));\n    return s;\ncan i use pre-defined function in coding round?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Why this doesn\\'t work?\\n\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        ans = x\\n        l, r = 0, x\\n        while l <= r:\\n            mid = int(l + (r-l)/2)\\n            if (mid*mid) > x:\\n                r = mid - 1\\n            elif (mid*mid) < x:\\n                ans = l\\n                l = mid + 1\\n            else:\\n                return mid\\n        return ans"
                    },
                    {
                        "username": "SenWang666",
                        "content": "Shouldn\\'t the nearest integer of 2.82842 be 3 instead of 2?"
                    },
                    {
                        "username": "krishnu9",
                        "content": "I hate this problem. Having TCs like 2147483647 causing integer overflow take away the fun from solving algorithmic problems."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me - this problem presents an interesting application of the binary search algorithm. It demonstrates how binary search can be applied to problems beyond searching in a sorted array. Also this problem teaches the concept of avoiding integer overflow."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "How is this easy..."
                    }
                ]
            },
            {
                "id": 2003535,
                "content": [
                    {
                        "username": "devanshsharma07",
                        "content": "I guess there is a bug in this program. When we talk about nearest integer it should be rouned to nearest integer. If square root of 8 is 2.82 then it should be rounded to 3 as it is the nearest one not to 2."
                    },
                    {
                        "username": "kamrun",
                        "content": "why we are not using decimal values here? I understand we want integer result but during the process why we are not considering decimal value?"
                    },
                    {
                        "username": "sasibunny31",
                        "content": "the given x is of integer type and it stores the 2123643174314 test case but it sqrt number is not storing why????????"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "can we use return sqrt(x);??\\n"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "you can\\'t, in description it self they mentioned, You must not use any built-in exponent function or operator."
                    },
                    {
                        "username": "SAMUDRA_069",
                        "content": "int s=floor(sqrt(n));\n    return s;\ncan i use pre-defined function in coding round?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Why this doesn\\'t work?\\n\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        ans = x\\n        l, r = 0, x\\n        while l <= r:\\n            mid = int(l + (r-l)/2)\\n            if (mid*mid) > x:\\n                r = mid - 1\\n            elif (mid*mid) < x:\\n                ans = l\\n                l = mid + 1\\n            else:\\n                return mid\\n        return ans"
                    },
                    {
                        "username": "SenWang666",
                        "content": "Shouldn\\'t the nearest integer of 2.82842 be 3 instead of 2?"
                    },
                    {
                        "username": "krishnu9",
                        "content": "I hate this problem. Having TCs like 2147483647 causing integer overflow take away the fun from solving algorithmic problems."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me - this problem presents an interesting application of the binary search algorithm. It demonstrates how binary search can be applied to problems beyond searching in a sorted array. Also this problem teaches the concept of avoiding integer overflow."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "How is this easy..."
                    }
                ]
            },
            {
                "id": 1997101,
                "content": [
                    {
                        "username": "devanshsharma07",
                        "content": "I guess there is a bug in this program. When we talk about nearest integer it should be rouned to nearest integer. If square root of 8 is 2.82 then it should be rounded to 3 as it is the nearest one not to 2."
                    },
                    {
                        "username": "kamrun",
                        "content": "why we are not using decimal values here? I understand we want integer result but during the process why we are not considering decimal value?"
                    },
                    {
                        "username": "sasibunny31",
                        "content": "the given x is of integer type and it stores the 2123643174314 test case but it sqrt number is not storing why????????"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "can we use return sqrt(x);??\\n"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "you can\\'t, in description it self they mentioned, You must not use any built-in exponent function or operator."
                    },
                    {
                        "username": "SAMUDRA_069",
                        "content": "int s=floor(sqrt(n));\n    return s;\ncan i use pre-defined function in coding round?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Why this doesn\\'t work?\\n\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        ans = x\\n        l, r = 0, x\\n        while l <= r:\\n            mid = int(l + (r-l)/2)\\n            if (mid*mid) > x:\\n                r = mid - 1\\n            elif (mid*mid) < x:\\n                ans = l\\n                l = mid + 1\\n            else:\\n                return mid\\n        return ans"
                    },
                    {
                        "username": "SenWang666",
                        "content": "Shouldn\\'t the nearest integer of 2.82842 be 3 instead of 2?"
                    },
                    {
                        "username": "krishnu9",
                        "content": "I hate this problem. Having TCs like 2147483647 causing integer overflow take away the fun from solving algorithmic problems."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me - this problem presents an interesting application of the binary search algorithm. It demonstrates how binary search can be applied to problems beyond searching in a sorted array. Also this problem teaches the concept of avoiding integer overflow."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "How is this easy..."
                    }
                ]
            },
            {
                "id": 1994972,
                "content": [
                    {
                        "username": "devanshsharma07",
                        "content": "I guess there is a bug in this program. When we talk about nearest integer it should be rouned to nearest integer. If square root of 8 is 2.82 then it should be rounded to 3 as it is the nearest one not to 2."
                    },
                    {
                        "username": "kamrun",
                        "content": "why we are not using decimal values here? I understand we want integer result but during the process why we are not considering decimal value?"
                    },
                    {
                        "username": "sasibunny31",
                        "content": "the given x is of integer type and it stores the 2123643174314 test case but it sqrt number is not storing why????????"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "can we use return sqrt(x);??\\n"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "you can\\'t, in description it self they mentioned, You must not use any built-in exponent function or operator."
                    },
                    {
                        "username": "SAMUDRA_069",
                        "content": "int s=floor(sqrt(n));\n    return s;\ncan i use pre-defined function in coding round?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Why this doesn\\'t work?\\n\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        ans = x\\n        l, r = 0, x\\n        while l <= r:\\n            mid = int(l + (r-l)/2)\\n            if (mid*mid) > x:\\n                r = mid - 1\\n            elif (mid*mid) < x:\\n                ans = l\\n                l = mid + 1\\n            else:\\n                return mid\\n        return ans"
                    },
                    {
                        "username": "SenWang666",
                        "content": "Shouldn\\'t the nearest integer of 2.82842 be 3 instead of 2?"
                    },
                    {
                        "username": "krishnu9",
                        "content": "I hate this problem. Having TCs like 2147483647 causing integer overflow take away the fun from solving algorithmic problems."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me - this problem presents an interesting application of the binary search algorithm. It demonstrates how binary search can be applied to problems beyond searching in a sorted array. Also this problem teaches the concept of avoiding integer overflow."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "How is this easy..."
                    }
                ]
            },
            {
                "id": 1980617,
                "content": [
                    {
                        "username": "devanshsharma07",
                        "content": "I guess there is a bug in this program. When we talk about nearest integer it should be rouned to nearest integer. If square root of 8 is 2.82 then it should be rounded to 3 as it is the nearest one not to 2."
                    },
                    {
                        "username": "kamrun",
                        "content": "why we are not using decimal values here? I understand we want integer result but during the process why we are not considering decimal value?"
                    },
                    {
                        "username": "sasibunny31",
                        "content": "the given x is of integer type and it stores the 2123643174314 test case but it sqrt number is not storing why????????"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "can we use return sqrt(x);??\\n"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "you can\\'t, in description it self they mentioned, You must not use any built-in exponent function or operator."
                    },
                    {
                        "username": "SAMUDRA_069",
                        "content": "int s=floor(sqrt(n));\n    return s;\ncan i use pre-defined function in coding round?"
                    },
                    {
                        "username": "AnkitModak",
                        "content": "Why this doesn\\'t work?\\n\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        ans = x\\n        l, r = 0, x\\n        while l <= r:\\n            mid = int(l + (r-l)/2)\\n            if (mid*mid) > x:\\n                r = mid - 1\\n            elif (mid*mid) < x:\\n                ans = l\\n                l = mid + 1\\n            else:\\n                return mid\\n        return ans"
                    },
                    {
                        "username": "SenWang666",
                        "content": "Shouldn\\'t the nearest integer of 2.82842 be 3 instead of 2?"
                    },
                    {
                        "username": "krishnu9",
                        "content": "I hate this problem. Having TCs like 2147483647 causing integer overflow take away the fun from solving algorithmic problems."
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "To me - this problem presents an interesting application of the binary search algorithm. It demonstrates how binary search can be applied to problems beyond searching in a sorted array. Also this problem teaches the concept of avoiding integer overflow."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "How is this easy..."
                    }
                ]
            },
            {
                "id": 1980327,
                "content": [
                    {
                        "username": "lifehacks2004",
                        "content": "how is the square root of 8, 4 instead of 2. seems kind of wrong"
                    },
                    {
                        "username": "ayushdhn",
                        "content": "class Solution {\\n    public int mySqrt(int x) {\\n        if(x<0)\\n            x=(-1)*x;\\n        int res=0;\\n        for(int i=1;i<x;i++){\\n            if(i*i>=x){\\n                res=i;\\n                break;\\n                }\\n            }\\n        return res-1;\\n    }\\n}\\n\\ncan anyone help me\\nit has passed 1008 out of 1017 cases\\nerror is coming in x=4"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    int mySqrt(int x) {\\n        int s = 0;\\n        int e = x;\\n        long long int mid = s+(e-s)/2;\\n        long long int ans = -1;\\n        while(s<=e){\\n            long long int sqr = mid*mid;\\n            if(sqr == x)\\n            return mid;\\n        if(sqr<x){\\n        ans = mid;\\n        s= mid+1;\\n        }\\n        else{\\n            e = mid-1;\\n        }\\n        mid = s+(e-s)/2;\\n    \\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "CDelisa",
                        "content": "Is the question worded poorly? It\\'s not square root, it\\'s nth root. Wrong answer. Input x = 8. Expected = 2. That\\'s a cubic root, not square root."
                    },
                    {
                        "username": "iamrathoreanuj",
                        "content": "for x =2147395599\\n\\nRESULT     time limit exceeded \\nbut why?"
                    },
                    {
                        "username": "Kira_Rapota",
                        "content": "return int(math.sqrt(x))"
                    },
                    {
                        "username": "goldfishfish",
                        "content": "why does binary search work in this problem? "
                    },
                    {
                        "username": "anusha_ghosh_",
                        "content": "My code (which is as follows) is going wrong in the test case of x = 2147385600. I don\\'t understand where I am going wrong, can someone help? Thank you.\\n\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int i = 0, sqrt = 0;\\n        while((i*i)<=x){\\n            sqrt = i;\\n            i++;\\n        }\\n        return sqrt;\\n    }\\n}"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "for some test case it is out of int bounds so use long and return int using typecasting\\n"
                    },
                    {
                        "username": "snowden1007",
                        "content": "try using long lont int "
                    },
                    {
                        "username": "thedabbinggamer894",
                        "content": "Would binary search be vaild here, or is it too slow?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple python code by bruteforcing class Solution:\\n    def mySqrt(self, n: int) -> int:\\n        index = 0\\n        a = 1\\n        square_root = 0\\n\\n        for j in range(n):\\n        \\n            index += a\\n           \\n            a += 2\\n            square_root += 1\\n\\n            if index > n:\\n                square_root-=1\\n\\n                break\\n            elif index==n:\\n                break\\n            \\n            \\n       \\n        return square_root\\n"
                    }
                ]
            },
            {
                "id": 1979697,
                "content": [
                    {
                        "username": "lifehacks2004",
                        "content": "how is the square root of 8, 4 instead of 2. seems kind of wrong"
                    },
                    {
                        "username": "ayushdhn",
                        "content": "class Solution {\\n    public int mySqrt(int x) {\\n        if(x<0)\\n            x=(-1)*x;\\n        int res=0;\\n        for(int i=1;i<x;i++){\\n            if(i*i>=x){\\n                res=i;\\n                break;\\n                }\\n            }\\n        return res-1;\\n    }\\n}\\n\\ncan anyone help me\\nit has passed 1008 out of 1017 cases\\nerror is coming in x=4"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    int mySqrt(int x) {\\n        int s = 0;\\n        int e = x;\\n        long long int mid = s+(e-s)/2;\\n        long long int ans = -1;\\n        while(s<=e){\\n            long long int sqr = mid*mid;\\n            if(sqr == x)\\n            return mid;\\n        if(sqr<x){\\n        ans = mid;\\n        s= mid+1;\\n        }\\n        else{\\n            e = mid-1;\\n        }\\n        mid = s+(e-s)/2;\\n    \\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "CDelisa",
                        "content": "Is the question worded poorly? It\\'s not square root, it\\'s nth root. Wrong answer. Input x = 8. Expected = 2. That\\'s a cubic root, not square root."
                    },
                    {
                        "username": "iamrathoreanuj",
                        "content": "for x =2147395599\\n\\nRESULT     time limit exceeded \\nbut why?"
                    },
                    {
                        "username": "Kira_Rapota",
                        "content": "return int(math.sqrt(x))"
                    },
                    {
                        "username": "goldfishfish",
                        "content": "why does binary search work in this problem? "
                    },
                    {
                        "username": "anusha_ghosh_",
                        "content": "My code (which is as follows) is going wrong in the test case of x = 2147385600. I don\\'t understand where I am going wrong, can someone help? Thank you.\\n\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int i = 0, sqrt = 0;\\n        while((i*i)<=x){\\n            sqrt = i;\\n            i++;\\n        }\\n        return sqrt;\\n    }\\n}"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "for some test case it is out of int bounds so use long and return int using typecasting\\n"
                    },
                    {
                        "username": "snowden1007",
                        "content": "try using long lont int "
                    },
                    {
                        "username": "thedabbinggamer894",
                        "content": "Would binary search be vaild here, or is it too slow?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple python code by bruteforcing class Solution:\\n    def mySqrt(self, n: int) -> int:\\n        index = 0\\n        a = 1\\n        square_root = 0\\n\\n        for j in range(n):\\n        \\n            index += a\\n           \\n            a += 2\\n            square_root += 1\\n\\n            if index > n:\\n                square_root-=1\\n\\n                break\\n            elif index==n:\\n                break\\n            \\n            \\n       \\n        return square_root\\n"
                    }
                ]
            },
            {
                "id": 1978379,
                "content": [
                    {
                        "username": "lifehacks2004",
                        "content": "how is the square root of 8, 4 instead of 2. seems kind of wrong"
                    },
                    {
                        "username": "ayushdhn",
                        "content": "class Solution {\\n    public int mySqrt(int x) {\\n        if(x<0)\\n            x=(-1)*x;\\n        int res=0;\\n        for(int i=1;i<x;i++){\\n            if(i*i>=x){\\n                res=i;\\n                break;\\n                }\\n            }\\n        return res-1;\\n    }\\n}\\n\\ncan anyone help me\\nit has passed 1008 out of 1017 cases\\nerror is coming in x=4"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    int mySqrt(int x) {\\n        int s = 0;\\n        int e = x;\\n        long long int mid = s+(e-s)/2;\\n        long long int ans = -1;\\n        while(s<=e){\\n            long long int sqr = mid*mid;\\n            if(sqr == x)\\n            return mid;\\n        if(sqr<x){\\n        ans = mid;\\n        s= mid+1;\\n        }\\n        else{\\n            e = mid-1;\\n        }\\n        mid = s+(e-s)/2;\\n    \\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "CDelisa",
                        "content": "Is the question worded poorly? It\\'s not square root, it\\'s nth root. Wrong answer. Input x = 8. Expected = 2. That\\'s a cubic root, not square root."
                    },
                    {
                        "username": "iamrathoreanuj",
                        "content": "for x =2147395599\\n\\nRESULT     time limit exceeded \\nbut why?"
                    },
                    {
                        "username": "Kira_Rapota",
                        "content": "return int(math.sqrt(x))"
                    },
                    {
                        "username": "goldfishfish",
                        "content": "why does binary search work in this problem? "
                    },
                    {
                        "username": "anusha_ghosh_",
                        "content": "My code (which is as follows) is going wrong in the test case of x = 2147385600. I don\\'t understand where I am going wrong, can someone help? Thank you.\\n\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int i = 0, sqrt = 0;\\n        while((i*i)<=x){\\n            sqrt = i;\\n            i++;\\n        }\\n        return sqrt;\\n    }\\n}"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "for some test case it is out of int bounds so use long and return int using typecasting\\n"
                    },
                    {
                        "username": "snowden1007",
                        "content": "try using long lont int "
                    },
                    {
                        "username": "thedabbinggamer894",
                        "content": "Would binary search be vaild here, or is it too slow?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple python code by bruteforcing class Solution:\\n    def mySqrt(self, n: int) -> int:\\n        index = 0\\n        a = 1\\n        square_root = 0\\n\\n        for j in range(n):\\n        \\n            index += a\\n           \\n            a += 2\\n            square_root += 1\\n\\n            if index > n:\\n                square_root-=1\\n\\n                break\\n            elif index==n:\\n                break\\n            \\n            \\n       \\n        return square_root\\n"
                    }
                ]
            },
            {
                "id": 1975065,
                "content": [
                    {
                        "username": "lifehacks2004",
                        "content": "how is the square root of 8, 4 instead of 2. seems kind of wrong"
                    },
                    {
                        "username": "ayushdhn",
                        "content": "class Solution {\\n    public int mySqrt(int x) {\\n        if(x<0)\\n            x=(-1)*x;\\n        int res=0;\\n        for(int i=1;i<x;i++){\\n            if(i*i>=x){\\n                res=i;\\n                break;\\n                }\\n            }\\n        return res-1;\\n    }\\n}\\n\\ncan anyone help me\\nit has passed 1008 out of 1017 cases\\nerror is coming in x=4"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    int mySqrt(int x) {\\n        int s = 0;\\n        int e = x;\\n        long long int mid = s+(e-s)/2;\\n        long long int ans = -1;\\n        while(s<=e){\\n            long long int sqr = mid*mid;\\n            if(sqr == x)\\n            return mid;\\n        if(sqr<x){\\n        ans = mid;\\n        s= mid+1;\\n        }\\n        else{\\n            e = mid-1;\\n        }\\n        mid = s+(e-s)/2;\\n    \\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "CDelisa",
                        "content": "Is the question worded poorly? It\\'s not square root, it\\'s nth root. Wrong answer. Input x = 8. Expected = 2. That\\'s a cubic root, not square root."
                    },
                    {
                        "username": "iamrathoreanuj",
                        "content": "for x =2147395599\\n\\nRESULT     time limit exceeded \\nbut why?"
                    },
                    {
                        "username": "Kira_Rapota",
                        "content": "return int(math.sqrt(x))"
                    },
                    {
                        "username": "goldfishfish",
                        "content": "why does binary search work in this problem? "
                    },
                    {
                        "username": "anusha_ghosh_",
                        "content": "My code (which is as follows) is going wrong in the test case of x = 2147385600. I don\\'t understand where I am going wrong, can someone help? Thank you.\\n\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int i = 0, sqrt = 0;\\n        while((i*i)<=x){\\n            sqrt = i;\\n            i++;\\n        }\\n        return sqrt;\\n    }\\n}"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "for some test case it is out of int bounds so use long and return int using typecasting\\n"
                    },
                    {
                        "username": "snowden1007",
                        "content": "try using long lont int "
                    },
                    {
                        "username": "thedabbinggamer894",
                        "content": "Would binary search be vaild here, or is it too slow?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple python code by bruteforcing class Solution:\\n    def mySqrt(self, n: int) -> int:\\n        index = 0\\n        a = 1\\n        square_root = 0\\n\\n        for j in range(n):\\n        \\n            index += a\\n           \\n            a += 2\\n            square_root += 1\\n\\n            if index > n:\\n                square_root-=1\\n\\n                break\\n            elif index==n:\\n                break\\n            \\n            \\n       \\n        return square_root\\n"
                    }
                ]
            },
            {
                "id": 1969141,
                "content": [
                    {
                        "username": "lifehacks2004",
                        "content": "how is the square root of 8, 4 instead of 2. seems kind of wrong"
                    },
                    {
                        "username": "ayushdhn",
                        "content": "class Solution {\\n    public int mySqrt(int x) {\\n        if(x<0)\\n            x=(-1)*x;\\n        int res=0;\\n        for(int i=1;i<x;i++){\\n            if(i*i>=x){\\n                res=i;\\n                break;\\n                }\\n            }\\n        return res-1;\\n    }\\n}\\n\\ncan anyone help me\\nit has passed 1008 out of 1017 cases\\nerror is coming in x=4"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    int mySqrt(int x) {\\n        int s = 0;\\n        int e = x;\\n        long long int mid = s+(e-s)/2;\\n        long long int ans = -1;\\n        while(s<=e){\\n            long long int sqr = mid*mid;\\n            if(sqr == x)\\n            return mid;\\n        if(sqr<x){\\n        ans = mid;\\n        s= mid+1;\\n        }\\n        else{\\n            e = mid-1;\\n        }\\n        mid = s+(e-s)/2;\\n    \\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "CDelisa",
                        "content": "Is the question worded poorly? It\\'s not square root, it\\'s nth root. Wrong answer. Input x = 8. Expected = 2. That\\'s a cubic root, not square root."
                    },
                    {
                        "username": "iamrathoreanuj",
                        "content": "for x =2147395599\\n\\nRESULT     time limit exceeded \\nbut why?"
                    },
                    {
                        "username": "Kira_Rapota",
                        "content": "return int(math.sqrt(x))"
                    },
                    {
                        "username": "goldfishfish",
                        "content": "why does binary search work in this problem? "
                    },
                    {
                        "username": "anusha_ghosh_",
                        "content": "My code (which is as follows) is going wrong in the test case of x = 2147385600. I don\\'t understand where I am going wrong, can someone help? Thank you.\\n\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int i = 0, sqrt = 0;\\n        while((i*i)<=x){\\n            sqrt = i;\\n            i++;\\n        }\\n        return sqrt;\\n    }\\n}"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "for some test case it is out of int bounds so use long and return int using typecasting\\n"
                    },
                    {
                        "username": "snowden1007",
                        "content": "try using long lont int "
                    },
                    {
                        "username": "thedabbinggamer894",
                        "content": "Would binary search be vaild here, or is it too slow?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple python code by bruteforcing class Solution:\\n    def mySqrt(self, n: int) -> int:\\n        index = 0\\n        a = 1\\n        square_root = 0\\n\\n        for j in range(n):\\n        \\n            index += a\\n           \\n            a += 2\\n            square_root += 1\\n\\n            if index > n:\\n                square_root-=1\\n\\n                break\\n            elif index==n:\\n                break\\n            \\n            \\n       \\n        return square_root\\n"
                    }
                ]
            },
            {
                "id": 1966266,
                "content": [
                    {
                        "username": "lifehacks2004",
                        "content": "how is the square root of 8, 4 instead of 2. seems kind of wrong"
                    },
                    {
                        "username": "ayushdhn",
                        "content": "class Solution {\\n    public int mySqrt(int x) {\\n        if(x<0)\\n            x=(-1)*x;\\n        int res=0;\\n        for(int i=1;i<x;i++){\\n            if(i*i>=x){\\n                res=i;\\n                break;\\n                }\\n            }\\n        return res-1;\\n    }\\n}\\n\\ncan anyone help me\\nit has passed 1008 out of 1017 cases\\nerror is coming in x=4"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    int mySqrt(int x) {\\n        int s = 0;\\n        int e = x;\\n        long long int mid = s+(e-s)/2;\\n        long long int ans = -1;\\n        while(s<=e){\\n            long long int sqr = mid*mid;\\n            if(sqr == x)\\n            return mid;\\n        if(sqr<x){\\n        ans = mid;\\n        s= mid+1;\\n        }\\n        else{\\n            e = mid-1;\\n        }\\n        mid = s+(e-s)/2;\\n    \\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "CDelisa",
                        "content": "Is the question worded poorly? It\\'s not square root, it\\'s nth root. Wrong answer. Input x = 8. Expected = 2. That\\'s a cubic root, not square root."
                    },
                    {
                        "username": "iamrathoreanuj",
                        "content": "for x =2147395599\\n\\nRESULT     time limit exceeded \\nbut why?"
                    },
                    {
                        "username": "Kira_Rapota",
                        "content": "return int(math.sqrt(x))"
                    },
                    {
                        "username": "goldfishfish",
                        "content": "why does binary search work in this problem? "
                    },
                    {
                        "username": "anusha_ghosh_",
                        "content": "My code (which is as follows) is going wrong in the test case of x = 2147385600. I don\\'t understand where I am going wrong, can someone help? Thank you.\\n\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int i = 0, sqrt = 0;\\n        while((i*i)<=x){\\n            sqrt = i;\\n            i++;\\n        }\\n        return sqrt;\\n    }\\n}"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "for some test case it is out of int bounds so use long and return int using typecasting\\n"
                    },
                    {
                        "username": "snowden1007",
                        "content": "try using long lont int "
                    },
                    {
                        "username": "thedabbinggamer894",
                        "content": "Would binary search be vaild here, or is it too slow?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple python code by bruteforcing class Solution:\\n    def mySqrt(self, n: int) -> int:\\n        index = 0\\n        a = 1\\n        square_root = 0\\n\\n        for j in range(n):\\n        \\n            index += a\\n           \\n            a += 2\\n            square_root += 1\\n\\n            if index > n:\\n                square_root-=1\\n\\n                break\\n            elif index==n:\\n                break\\n            \\n            \\n       \\n        return square_root\\n"
                    }
                ]
            },
            {
                "id": 1960566,
                "content": [
                    {
                        "username": "lifehacks2004",
                        "content": "how is the square root of 8, 4 instead of 2. seems kind of wrong"
                    },
                    {
                        "username": "ayushdhn",
                        "content": "class Solution {\\n    public int mySqrt(int x) {\\n        if(x<0)\\n            x=(-1)*x;\\n        int res=0;\\n        for(int i=1;i<x;i++){\\n            if(i*i>=x){\\n                res=i;\\n                break;\\n                }\\n            }\\n        return res-1;\\n    }\\n}\\n\\ncan anyone help me\\nit has passed 1008 out of 1017 cases\\nerror is coming in x=4"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    int mySqrt(int x) {\\n        int s = 0;\\n        int e = x;\\n        long long int mid = s+(e-s)/2;\\n        long long int ans = -1;\\n        while(s<=e){\\n            long long int sqr = mid*mid;\\n            if(sqr == x)\\n            return mid;\\n        if(sqr<x){\\n        ans = mid;\\n        s= mid+1;\\n        }\\n        else{\\n            e = mid-1;\\n        }\\n        mid = s+(e-s)/2;\\n    \\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "CDelisa",
                        "content": "Is the question worded poorly? It\\'s not square root, it\\'s nth root. Wrong answer. Input x = 8. Expected = 2. That\\'s a cubic root, not square root."
                    },
                    {
                        "username": "iamrathoreanuj",
                        "content": "for x =2147395599\\n\\nRESULT     time limit exceeded \\nbut why?"
                    },
                    {
                        "username": "Kira_Rapota",
                        "content": "return int(math.sqrt(x))"
                    },
                    {
                        "username": "goldfishfish",
                        "content": "why does binary search work in this problem? "
                    },
                    {
                        "username": "anusha_ghosh_",
                        "content": "My code (which is as follows) is going wrong in the test case of x = 2147385600. I don\\'t understand where I am going wrong, can someone help? Thank you.\\n\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int i = 0, sqrt = 0;\\n        while((i*i)<=x){\\n            sqrt = i;\\n            i++;\\n        }\\n        return sqrt;\\n    }\\n}"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "for some test case it is out of int bounds so use long and return int using typecasting\\n"
                    },
                    {
                        "username": "snowden1007",
                        "content": "try using long lont int "
                    },
                    {
                        "username": "thedabbinggamer894",
                        "content": "Would binary search be vaild here, or is it too slow?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple python code by bruteforcing class Solution:\\n    def mySqrt(self, n: int) -> int:\\n        index = 0\\n        a = 1\\n        square_root = 0\\n\\n        for j in range(n):\\n        \\n            index += a\\n           \\n            a += 2\\n            square_root += 1\\n\\n            if index > n:\\n                square_root-=1\\n\\n                break\\n            elif index==n:\\n                break\\n            \\n            \\n       \\n        return square_root\\n"
                    }
                ]
            },
            {
                "id": 1950048,
                "content": [
                    {
                        "username": "lifehacks2004",
                        "content": "how is the square root of 8, 4 instead of 2. seems kind of wrong"
                    },
                    {
                        "username": "ayushdhn",
                        "content": "class Solution {\\n    public int mySqrt(int x) {\\n        if(x<0)\\n            x=(-1)*x;\\n        int res=0;\\n        for(int i=1;i<x;i++){\\n            if(i*i>=x){\\n                res=i;\\n                break;\\n                }\\n            }\\n        return res-1;\\n    }\\n}\\n\\ncan anyone help me\\nit has passed 1008 out of 1017 cases\\nerror is coming in x=4"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    int mySqrt(int x) {\\n        int s = 0;\\n        int e = x;\\n        long long int mid = s+(e-s)/2;\\n        long long int ans = -1;\\n        while(s<=e){\\n            long long int sqr = mid*mid;\\n            if(sqr == x)\\n            return mid;\\n        if(sqr<x){\\n        ans = mid;\\n        s= mid+1;\\n        }\\n        else{\\n            e = mid-1;\\n        }\\n        mid = s+(e-s)/2;\\n    \\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "CDelisa",
                        "content": "Is the question worded poorly? It\\'s not square root, it\\'s nth root. Wrong answer. Input x = 8. Expected = 2. That\\'s a cubic root, not square root."
                    },
                    {
                        "username": "iamrathoreanuj",
                        "content": "for x =2147395599\\n\\nRESULT     time limit exceeded \\nbut why?"
                    },
                    {
                        "username": "Kira_Rapota",
                        "content": "return int(math.sqrt(x))"
                    },
                    {
                        "username": "goldfishfish",
                        "content": "why does binary search work in this problem? "
                    },
                    {
                        "username": "anusha_ghosh_",
                        "content": "My code (which is as follows) is going wrong in the test case of x = 2147385600. I don\\'t understand where I am going wrong, can someone help? Thank you.\\n\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int i = 0, sqrt = 0;\\n        while((i*i)<=x){\\n            sqrt = i;\\n            i++;\\n        }\\n        return sqrt;\\n    }\\n}"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "for some test case it is out of int bounds so use long and return int using typecasting\\n"
                    },
                    {
                        "username": "snowden1007",
                        "content": "try using long lont int "
                    },
                    {
                        "username": "thedabbinggamer894",
                        "content": "Would binary search be vaild here, or is it too slow?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple python code by bruteforcing class Solution:\\n    def mySqrt(self, n: int) -> int:\\n        index = 0\\n        a = 1\\n        square_root = 0\\n\\n        for j in range(n):\\n        \\n            index += a\\n           \\n            a += 2\\n            square_root += 1\\n\\n            if index > n:\\n                square_root-=1\\n\\n                break\\n            elif index==n:\\n                break\\n            \\n            \\n       \\n        return square_root\\n"
                    }
                ]
            },
            {
                "id": 1947700,
                "content": [
                    {
                        "username": "lifehacks2004",
                        "content": "how is the square root of 8, 4 instead of 2. seems kind of wrong"
                    },
                    {
                        "username": "ayushdhn",
                        "content": "class Solution {\\n    public int mySqrt(int x) {\\n        if(x<0)\\n            x=(-1)*x;\\n        int res=0;\\n        for(int i=1;i<x;i++){\\n            if(i*i>=x){\\n                res=i;\\n                break;\\n                }\\n            }\\n        return res-1;\\n    }\\n}\\n\\ncan anyone help me\\nit has passed 1008 out of 1017 cases\\nerror is coming in x=4"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    int mySqrt(int x) {\\n        int s = 0;\\n        int e = x;\\n        long long int mid = s+(e-s)/2;\\n        long long int ans = -1;\\n        while(s<=e){\\n            long long int sqr = mid*mid;\\n            if(sqr == x)\\n            return mid;\\n        if(sqr<x){\\n        ans = mid;\\n        s= mid+1;\\n        }\\n        else{\\n            e = mid-1;\\n        }\\n        mid = s+(e-s)/2;\\n    \\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "CDelisa",
                        "content": "Is the question worded poorly? It\\'s not square root, it\\'s nth root. Wrong answer. Input x = 8. Expected = 2. That\\'s a cubic root, not square root."
                    },
                    {
                        "username": "iamrathoreanuj",
                        "content": "for x =2147395599\\n\\nRESULT     time limit exceeded \\nbut why?"
                    },
                    {
                        "username": "Kira_Rapota",
                        "content": "return int(math.sqrt(x))"
                    },
                    {
                        "username": "goldfishfish",
                        "content": "why does binary search work in this problem? "
                    },
                    {
                        "username": "anusha_ghosh_",
                        "content": "My code (which is as follows) is going wrong in the test case of x = 2147385600. I don\\'t understand where I am going wrong, can someone help? Thank you.\\n\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int i = 0, sqrt = 0;\\n        while((i*i)<=x){\\n            sqrt = i;\\n            i++;\\n        }\\n        return sqrt;\\n    }\\n}"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "for some test case it is out of int bounds so use long and return int using typecasting\\n"
                    },
                    {
                        "username": "snowden1007",
                        "content": "try using long lont int "
                    },
                    {
                        "username": "thedabbinggamer894",
                        "content": "Would binary search be vaild here, or is it too slow?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple python code by bruteforcing class Solution:\\n    def mySqrt(self, n: int) -> int:\\n        index = 0\\n        a = 1\\n        square_root = 0\\n\\n        for j in range(n):\\n        \\n            index += a\\n           \\n            a += 2\\n            square_root += 1\\n\\n            if index > n:\\n                square_root-=1\\n\\n                break\\n            elif index==n:\\n                break\\n            \\n            \\n       \\n        return square_root\\n"
                    }
                ]
            },
            {
                "id": 1946277,
                "content": [
                    {
                        "username": "lifehacks2004",
                        "content": "how is the square root of 8, 4 instead of 2. seems kind of wrong"
                    },
                    {
                        "username": "ayushdhn",
                        "content": "class Solution {\\n    public int mySqrt(int x) {\\n        if(x<0)\\n            x=(-1)*x;\\n        int res=0;\\n        for(int i=1;i<x;i++){\\n            if(i*i>=x){\\n                res=i;\\n                break;\\n                }\\n            }\\n        return res-1;\\n    }\\n}\\n\\ncan anyone help me\\nit has passed 1008 out of 1017 cases\\nerror is coming in x=4"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    int mySqrt(int x) {\\n        int s = 0;\\n        int e = x;\\n        long long int mid = s+(e-s)/2;\\n        long long int ans = -1;\\n        while(s<=e){\\n            long long int sqr = mid*mid;\\n            if(sqr == x)\\n            return mid;\\n        if(sqr<x){\\n        ans = mid;\\n        s= mid+1;\\n        }\\n        else{\\n            e = mid-1;\\n        }\\n        mid = s+(e-s)/2;\\n    \\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "CDelisa",
                        "content": "Is the question worded poorly? It\\'s not square root, it\\'s nth root. Wrong answer. Input x = 8. Expected = 2. That\\'s a cubic root, not square root."
                    },
                    {
                        "username": "iamrathoreanuj",
                        "content": "for x =2147395599\\n\\nRESULT     time limit exceeded \\nbut why?"
                    },
                    {
                        "username": "Kira_Rapota",
                        "content": "return int(math.sqrt(x))"
                    },
                    {
                        "username": "goldfishfish",
                        "content": "why does binary search work in this problem? "
                    },
                    {
                        "username": "anusha_ghosh_",
                        "content": "My code (which is as follows) is going wrong in the test case of x = 2147385600. I don\\'t understand where I am going wrong, can someone help? Thank you.\\n\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int i = 0, sqrt = 0;\\n        while((i*i)<=x){\\n            sqrt = i;\\n            i++;\\n        }\\n        return sqrt;\\n    }\\n}"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "for some test case it is out of int bounds so use long and return int using typecasting\\n"
                    },
                    {
                        "username": "snowden1007",
                        "content": "try using long lont int "
                    },
                    {
                        "username": "thedabbinggamer894",
                        "content": "Would binary search be vaild here, or is it too slow?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "simple python code by bruteforcing class Solution:\\n    def mySqrt(self, n: int) -> int:\\n        index = 0\\n        a = 1\\n        square_root = 0\\n\\n        for j in range(n):\\n        \\n            index += a\\n           \\n            a += 2\\n            square_root += 1\\n\\n            if index > n:\\n                square_root-=1\\n\\n                break\\n            elif index==n:\\n                break\\n            \\n            \\n       \\n        return square_root\\n"
                    }
                ]
            },
            {
                "id": 1941278,
                "content": [
                    {
                        "username": "palakgupta1712",
                        "content": "I have used binary search approach to solve this question and I also used long long  int to store the values.  It\\'s still showing TLE for the value 2147395600. Also the constraints are 0 <= x <= 2^31 - 1 , how is this justified please help!"
                    },
                    {
                        "username": "wadhwanichirag93",
                        "content": "its because you must have used (int) try to use long for calculations and typecast to int while returning the answer.\\n "
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "Always getting \\nTime Limit Exceeded\\nany one knows why?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "same"
                    },
                    {
                        "username": "Lunar-Eclipse",
                        "content": "simple question use sqrt(abs(x)), in cpp"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "not to use built in function bro just read the question\\n"
                    },
                    {
                        "username": "darkling23",
                        "content": "class Solution {\\npublic:\\nlong long int binarysearch(int n){\\n    int s =0;\\n    int e = n-1;\\n    long long int mid = s + (e-s)/2;\\n\\n    long long int ans = -1;\\n    while(s<=e){\\n\\n        long long int square = mid*mid;\\n        if (mid == square){\\n            return mid;\\n        }\\n\\n        else if (square<n){\\n            ans = mid;\\n            s = mid+1;\\n        }\\n\\n        else{\\n            e = mid-1;\\n        }\\n        mid = s + (e-s)/2;\\n    }\\n\\n}\\n\\n\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n    }\\n};\\nCan someone please say whats wrong with this code cuz its throwing me this sort of error:\\n\"Line 27: Char 1: error: non-void function does not return a value in all control paths [-Werror,-Wreturn-type]\\n}\\n^\\n1 error generated.\""
                    },
                    {
                        "username": "Kromydas",
                        "content": "You did not return a value in your code. Your binary search function is a long long int, so you are expected to return a long long int. Instead, you did not return anything. \\n\\nTo fix this error, just do `return ans;` in your binary search function after the while loop. (This is based off of how I understand your code). "
                    },
                    {
                        "username": "devTabasco",
                        "content": "There are no specific constraints mentioned regarding the time complexity. However, if exhaustive search is used, it will lead to a runtime error, making the problem unsolvable."
                    },
                    {
                        "username": "Kromydas",
                        "content": "As a helpful hint to all of the beginners, beware of edge cases such as when x = 0. And if you are planning on doing this the brute force way, use while loops, not for loops. If you do for (int i = 0; i < x; i++), this will achieve Time Limit Exceeded. \\n\\nInstead of using for loops, have a while loop with a condition such as while (i * i <= x) {}. This will make it faster, just enough to barely solve the problem. \\n\\nAnother thing to note is that you can\\'t just abs(x - i * i), you have to consider the possibilities under x. Ie if x = 8, you can\\'t consider 9, although it is the closest to 8. You have to consider the one under it, or 4. \\n\\nUsing this method helps you down the line as well. When you return you don\\'t need to separate the perfect square cases and the ones that aren\\'t prefect squares, as I\\'ve seen some solutions do. You only need to return i, not i - 1 or something. \\n\\nP.S use long long int or long long. Otherwise some test cases may fail because of overflow. "
                    },
                    {
                        "username": "alessandromarchesin",
                        "content": "What part of \"1. Please don\\'t post any solutions in this discussion.\" you do not understand?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "me coming into the problem - \"37.5% acceptance rate on an easy?  pfft!\"\\n3 wrong submissions later - \"oh i see...\""
                    },
                    {
                        "username": "digital-idiot",
                        "content": "Why expected output is `2` for the input `8`?\\n\\n`sqrt(8)` is `2.8284271247461903`, when rounded to nearest integer it is `3`."
                    },
                    {
                        "username": "liebrynth",
                        "content": "because its not round up but int and when we convert decimal value to int it will ignore all the decimal after that. That\\'s why answer is 2"
                    },
                    {
                        "username": "TheoW03",
                        "content": "but a better solution I have found. is quick inv sqrt. you run \\n(or the quake 3 algorithm)\\n\\n  x = x * (1.5f - (xhalf * x * x));\\n3 times. \\nand to get the sqrt\\nyou multiply by \\n\\nfloat y = (int)(x*fastInverseSqrt(x)+0.01f);\\n\\nthey are some draw backs. quick_inv_sqrt is not accurate, its an approximation. and it will kill you bc of rounding errors. but its the I believe O(1) solution. and quicker then the stuff the Math libraries offer in C. about 4 times I read. "
                    }
                ]
            },
            {
                "id": 1936243,
                "content": [
                    {
                        "username": "palakgupta1712",
                        "content": "I have used binary search approach to solve this question and I also used long long  int to store the values.  It\\'s still showing TLE for the value 2147395600. Also the constraints are 0 <= x <= 2^31 - 1 , how is this justified please help!"
                    },
                    {
                        "username": "wadhwanichirag93",
                        "content": "its because you must have used (int) try to use long for calculations and typecast to int while returning the answer.\\n "
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "Always getting \\nTime Limit Exceeded\\nany one knows why?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "same"
                    },
                    {
                        "username": "Lunar-Eclipse",
                        "content": "simple question use sqrt(abs(x)), in cpp"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "not to use built in function bro just read the question\\n"
                    },
                    {
                        "username": "darkling23",
                        "content": "class Solution {\\npublic:\\nlong long int binarysearch(int n){\\n    int s =0;\\n    int e = n-1;\\n    long long int mid = s + (e-s)/2;\\n\\n    long long int ans = -1;\\n    while(s<=e){\\n\\n        long long int square = mid*mid;\\n        if (mid == square){\\n            return mid;\\n        }\\n\\n        else if (square<n){\\n            ans = mid;\\n            s = mid+1;\\n        }\\n\\n        else{\\n            e = mid-1;\\n        }\\n        mid = s + (e-s)/2;\\n    }\\n\\n}\\n\\n\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n    }\\n};\\nCan someone please say whats wrong with this code cuz its throwing me this sort of error:\\n\"Line 27: Char 1: error: non-void function does not return a value in all control paths [-Werror,-Wreturn-type]\\n}\\n^\\n1 error generated.\""
                    },
                    {
                        "username": "Kromydas",
                        "content": "You did not return a value in your code. Your binary search function is a long long int, so you are expected to return a long long int. Instead, you did not return anything. \\n\\nTo fix this error, just do `return ans;` in your binary search function after the while loop. (This is based off of how I understand your code). "
                    },
                    {
                        "username": "devTabasco",
                        "content": "There are no specific constraints mentioned regarding the time complexity. However, if exhaustive search is used, it will lead to a runtime error, making the problem unsolvable."
                    },
                    {
                        "username": "Kromydas",
                        "content": "As a helpful hint to all of the beginners, beware of edge cases such as when x = 0. And if you are planning on doing this the brute force way, use while loops, not for loops. If you do for (int i = 0; i < x; i++), this will achieve Time Limit Exceeded. \\n\\nInstead of using for loops, have a while loop with a condition such as while (i * i <= x) {}. This will make it faster, just enough to barely solve the problem. \\n\\nAnother thing to note is that you can\\'t just abs(x - i * i), you have to consider the possibilities under x. Ie if x = 8, you can\\'t consider 9, although it is the closest to 8. You have to consider the one under it, or 4. \\n\\nUsing this method helps you down the line as well. When you return you don\\'t need to separate the perfect square cases and the ones that aren\\'t prefect squares, as I\\'ve seen some solutions do. You only need to return i, not i - 1 or something. \\n\\nP.S use long long int or long long. Otherwise some test cases may fail because of overflow. "
                    },
                    {
                        "username": "alessandromarchesin",
                        "content": "What part of \"1. Please don\\'t post any solutions in this discussion.\" you do not understand?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "me coming into the problem - \"37.5% acceptance rate on an easy?  pfft!\"\\n3 wrong submissions later - \"oh i see...\""
                    },
                    {
                        "username": "digital-idiot",
                        "content": "Why expected output is `2` for the input `8`?\\n\\n`sqrt(8)` is `2.8284271247461903`, when rounded to nearest integer it is `3`."
                    },
                    {
                        "username": "liebrynth",
                        "content": "because its not round up but int and when we convert decimal value to int it will ignore all the decimal after that. That\\'s why answer is 2"
                    },
                    {
                        "username": "TheoW03",
                        "content": "but a better solution I have found. is quick inv sqrt. you run \\n(or the quake 3 algorithm)\\n\\n  x = x * (1.5f - (xhalf * x * x));\\n3 times. \\nand to get the sqrt\\nyou multiply by \\n\\nfloat y = (int)(x*fastInverseSqrt(x)+0.01f);\\n\\nthey are some draw backs. quick_inv_sqrt is not accurate, its an approximation. and it will kill you bc of rounding errors. but its the I believe O(1) solution. and quicker then the stuff the Math libraries offer in C. about 4 times I read. "
                    }
                ]
            },
            {
                "id": 1930368,
                "content": [
                    {
                        "username": "palakgupta1712",
                        "content": "I have used binary search approach to solve this question and I also used long long  int to store the values.  It\\'s still showing TLE for the value 2147395600. Also the constraints are 0 <= x <= 2^31 - 1 , how is this justified please help!"
                    },
                    {
                        "username": "wadhwanichirag93",
                        "content": "its because you must have used (int) try to use long for calculations and typecast to int while returning the answer.\\n "
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "Always getting \\nTime Limit Exceeded\\nany one knows why?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "same"
                    },
                    {
                        "username": "Lunar-Eclipse",
                        "content": "simple question use sqrt(abs(x)), in cpp"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "not to use built in function bro just read the question\\n"
                    },
                    {
                        "username": "darkling23",
                        "content": "class Solution {\\npublic:\\nlong long int binarysearch(int n){\\n    int s =0;\\n    int e = n-1;\\n    long long int mid = s + (e-s)/2;\\n\\n    long long int ans = -1;\\n    while(s<=e){\\n\\n        long long int square = mid*mid;\\n        if (mid == square){\\n            return mid;\\n        }\\n\\n        else if (square<n){\\n            ans = mid;\\n            s = mid+1;\\n        }\\n\\n        else{\\n            e = mid-1;\\n        }\\n        mid = s + (e-s)/2;\\n    }\\n\\n}\\n\\n\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n    }\\n};\\nCan someone please say whats wrong with this code cuz its throwing me this sort of error:\\n\"Line 27: Char 1: error: non-void function does not return a value in all control paths [-Werror,-Wreturn-type]\\n}\\n^\\n1 error generated.\""
                    },
                    {
                        "username": "Kromydas",
                        "content": "You did not return a value in your code. Your binary search function is a long long int, so you are expected to return a long long int. Instead, you did not return anything. \\n\\nTo fix this error, just do `return ans;` in your binary search function after the while loop. (This is based off of how I understand your code). "
                    },
                    {
                        "username": "devTabasco",
                        "content": "There are no specific constraints mentioned regarding the time complexity. However, if exhaustive search is used, it will lead to a runtime error, making the problem unsolvable."
                    },
                    {
                        "username": "Kromydas",
                        "content": "As a helpful hint to all of the beginners, beware of edge cases such as when x = 0. And if you are planning on doing this the brute force way, use while loops, not for loops. If you do for (int i = 0; i < x; i++), this will achieve Time Limit Exceeded. \\n\\nInstead of using for loops, have a while loop with a condition such as while (i * i <= x) {}. This will make it faster, just enough to barely solve the problem. \\n\\nAnother thing to note is that you can\\'t just abs(x - i * i), you have to consider the possibilities under x. Ie if x = 8, you can\\'t consider 9, although it is the closest to 8. You have to consider the one under it, or 4. \\n\\nUsing this method helps you down the line as well. When you return you don\\'t need to separate the perfect square cases and the ones that aren\\'t prefect squares, as I\\'ve seen some solutions do. You only need to return i, not i - 1 or something. \\n\\nP.S use long long int or long long. Otherwise some test cases may fail because of overflow. "
                    },
                    {
                        "username": "alessandromarchesin",
                        "content": "What part of \"1. Please don\\'t post any solutions in this discussion.\" you do not understand?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "me coming into the problem - \"37.5% acceptance rate on an easy?  pfft!\"\\n3 wrong submissions later - \"oh i see...\""
                    },
                    {
                        "username": "digital-idiot",
                        "content": "Why expected output is `2` for the input `8`?\\n\\n`sqrt(8)` is `2.8284271247461903`, when rounded to nearest integer it is `3`."
                    },
                    {
                        "username": "liebrynth",
                        "content": "because its not round up but int and when we convert decimal value to int it will ignore all the decimal after that. That\\'s why answer is 2"
                    },
                    {
                        "username": "TheoW03",
                        "content": "but a better solution I have found. is quick inv sqrt. you run \\n(or the quake 3 algorithm)\\n\\n  x = x * (1.5f - (xhalf * x * x));\\n3 times. \\nand to get the sqrt\\nyou multiply by \\n\\nfloat y = (int)(x*fastInverseSqrt(x)+0.01f);\\n\\nthey are some draw backs. quick_inv_sqrt is not accurate, its an approximation. and it will kill you bc of rounding errors. but its the I believe O(1) solution. and quicker then the stuff the Math libraries offer in C. about 4 times I read. "
                    }
                ]
            },
            {
                "id": 1922230,
                "content": [
                    {
                        "username": "palakgupta1712",
                        "content": "I have used binary search approach to solve this question and I also used long long  int to store the values.  It\\'s still showing TLE for the value 2147395600. Also the constraints are 0 <= x <= 2^31 - 1 , how is this justified please help!"
                    },
                    {
                        "username": "wadhwanichirag93",
                        "content": "its because you must have used (int) try to use long for calculations and typecast to int while returning the answer.\\n "
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "Always getting \\nTime Limit Exceeded\\nany one knows why?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "same"
                    },
                    {
                        "username": "Lunar-Eclipse",
                        "content": "simple question use sqrt(abs(x)), in cpp"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "not to use built in function bro just read the question\\n"
                    },
                    {
                        "username": "darkling23",
                        "content": "class Solution {\\npublic:\\nlong long int binarysearch(int n){\\n    int s =0;\\n    int e = n-1;\\n    long long int mid = s + (e-s)/2;\\n\\n    long long int ans = -1;\\n    while(s<=e){\\n\\n        long long int square = mid*mid;\\n        if (mid == square){\\n            return mid;\\n        }\\n\\n        else if (square<n){\\n            ans = mid;\\n            s = mid+1;\\n        }\\n\\n        else{\\n            e = mid-1;\\n        }\\n        mid = s + (e-s)/2;\\n    }\\n\\n}\\n\\n\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n    }\\n};\\nCan someone please say whats wrong with this code cuz its throwing me this sort of error:\\n\"Line 27: Char 1: error: non-void function does not return a value in all control paths [-Werror,-Wreturn-type]\\n}\\n^\\n1 error generated.\""
                    },
                    {
                        "username": "Kromydas",
                        "content": "You did not return a value in your code. Your binary search function is a long long int, so you are expected to return a long long int. Instead, you did not return anything. \\n\\nTo fix this error, just do `return ans;` in your binary search function after the while loop. (This is based off of how I understand your code). "
                    },
                    {
                        "username": "devTabasco",
                        "content": "There are no specific constraints mentioned regarding the time complexity. However, if exhaustive search is used, it will lead to a runtime error, making the problem unsolvable."
                    },
                    {
                        "username": "Kromydas",
                        "content": "As a helpful hint to all of the beginners, beware of edge cases such as when x = 0. And if you are planning on doing this the brute force way, use while loops, not for loops. If you do for (int i = 0; i < x; i++), this will achieve Time Limit Exceeded. \\n\\nInstead of using for loops, have a while loop with a condition such as while (i * i <= x) {}. This will make it faster, just enough to barely solve the problem. \\n\\nAnother thing to note is that you can\\'t just abs(x - i * i), you have to consider the possibilities under x. Ie if x = 8, you can\\'t consider 9, although it is the closest to 8. You have to consider the one under it, or 4. \\n\\nUsing this method helps you down the line as well. When you return you don\\'t need to separate the perfect square cases and the ones that aren\\'t prefect squares, as I\\'ve seen some solutions do. You only need to return i, not i - 1 or something. \\n\\nP.S use long long int or long long. Otherwise some test cases may fail because of overflow. "
                    },
                    {
                        "username": "alessandromarchesin",
                        "content": "What part of \"1. Please don\\'t post any solutions in this discussion.\" you do not understand?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "me coming into the problem - \"37.5% acceptance rate on an easy?  pfft!\"\\n3 wrong submissions later - \"oh i see...\""
                    },
                    {
                        "username": "digital-idiot",
                        "content": "Why expected output is `2` for the input `8`?\\n\\n`sqrt(8)` is `2.8284271247461903`, when rounded to nearest integer it is `3`."
                    },
                    {
                        "username": "liebrynth",
                        "content": "because its not round up but int and when we convert decimal value to int it will ignore all the decimal after that. That\\'s why answer is 2"
                    },
                    {
                        "username": "TheoW03",
                        "content": "but a better solution I have found. is quick inv sqrt. you run \\n(or the quake 3 algorithm)\\n\\n  x = x * (1.5f - (xhalf * x * x));\\n3 times. \\nand to get the sqrt\\nyou multiply by \\n\\nfloat y = (int)(x*fastInverseSqrt(x)+0.01f);\\n\\nthey are some draw backs. quick_inv_sqrt is not accurate, its an approximation. and it will kill you bc of rounding errors. but its the I believe O(1) solution. and quicker then the stuff the Math libraries offer in C. about 4 times I read. "
                    }
                ]
            },
            {
                "id": 1920838,
                "content": [
                    {
                        "username": "palakgupta1712",
                        "content": "I have used binary search approach to solve this question and I also used long long  int to store the values.  It\\'s still showing TLE for the value 2147395600. Also the constraints are 0 <= x <= 2^31 - 1 , how is this justified please help!"
                    },
                    {
                        "username": "wadhwanichirag93",
                        "content": "its because you must have used (int) try to use long for calculations and typecast to int while returning the answer.\\n "
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "Always getting \\nTime Limit Exceeded\\nany one knows why?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "same"
                    },
                    {
                        "username": "Lunar-Eclipse",
                        "content": "simple question use sqrt(abs(x)), in cpp"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "not to use built in function bro just read the question\\n"
                    },
                    {
                        "username": "darkling23",
                        "content": "class Solution {\\npublic:\\nlong long int binarysearch(int n){\\n    int s =0;\\n    int e = n-1;\\n    long long int mid = s + (e-s)/2;\\n\\n    long long int ans = -1;\\n    while(s<=e){\\n\\n        long long int square = mid*mid;\\n        if (mid == square){\\n            return mid;\\n        }\\n\\n        else if (square<n){\\n            ans = mid;\\n            s = mid+1;\\n        }\\n\\n        else{\\n            e = mid-1;\\n        }\\n        mid = s + (e-s)/2;\\n    }\\n\\n}\\n\\n\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n    }\\n};\\nCan someone please say whats wrong with this code cuz its throwing me this sort of error:\\n\"Line 27: Char 1: error: non-void function does not return a value in all control paths [-Werror,-Wreturn-type]\\n}\\n^\\n1 error generated.\""
                    },
                    {
                        "username": "Kromydas",
                        "content": "You did not return a value in your code. Your binary search function is a long long int, so you are expected to return a long long int. Instead, you did not return anything. \\n\\nTo fix this error, just do `return ans;` in your binary search function after the while loop. (This is based off of how I understand your code). "
                    },
                    {
                        "username": "devTabasco",
                        "content": "There are no specific constraints mentioned regarding the time complexity. However, if exhaustive search is used, it will lead to a runtime error, making the problem unsolvable."
                    },
                    {
                        "username": "Kromydas",
                        "content": "As a helpful hint to all of the beginners, beware of edge cases such as when x = 0. And if you are planning on doing this the brute force way, use while loops, not for loops. If you do for (int i = 0; i < x; i++), this will achieve Time Limit Exceeded. \\n\\nInstead of using for loops, have a while loop with a condition such as while (i * i <= x) {}. This will make it faster, just enough to barely solve the problem. \\n\\nAnother thing to note is that you can\\'t just abs(x - i * i), you have to consider the possibilities under x. Ie if x = 8, you can\\'t consider 9, although it is the closest to 8. You have to consider the one under it, or 4. \\n\\nUsing this method helps you down the line as well. When you return you don\\'t need to separate the perfect square cases and the ones that aren\\'t prefect squares, as I\\'ve seen some solutions do. You only need to return i, not i - 1 or something. \\n\\nP.S use long long int or long long. Otherwise some test cases may fail because of overflow. "
                    },
                    {
                        "username": "alessandromarchesin",
                        "content": "What part of \"1. Please don\\'t post any solutions in this discussion.\" you do not understand?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "me coming into the problem - \"37.5% acceptance rate on an easy?  pfft!\"\\n3 wrong submissions later - \"oh i see...\""
                    },
                    {
                        "username": "digital-idiot",
                        "content": "Why expected output is `2` for the input `8`?\\n\\n`sqrt(8)` is `2.8284271247461903`, when rounded to nearest integer it is `3`."
                    },
                    {
                        "username": "liebrynth",
                        "content": "because its not round up but int and when we convert decimal value to int it will ignore all the decimal after that. That\\'s why answer is 2"
                    },
                    {
                        "username": "TheoW03",
                        "content": "but a better solution I have found. is quick inv sqrt. you run \\n(or the quake 3 algorithm)\\n\\n  x = x * (1.5f - (xhalf * x * x));\\n3 times. \\nand to get the sqrt\\nyou multiply by \\n\\nfloat y = (int)(x*fastInverseSqrt(x)+0.01f);\\n\\nthey are some draw backs. quick_inv_sqrt is not accurate, its an approximation. and it will kill you bc of rounding errors. but its the I believe O(1) solution. and quicker then the stuff the Math libraries offer in C. about 4 times I read. "
                    }
                ]
            },
            {
                "id": 1913630,
                "content": [
                    {
                        "username": "palakgupta1712",
                        "content": "I have used binary search approach to solve this question and I also used long long  int to store the values.  It\\'s still showing TLE for the value 2147395600. Also the constraints are 0 <= x <= 2^31 - 1 , how is this justified please help!"
                    },
                    {
                        "username": "wadhwanichirag93",
                        "content": "its because you must have used (int) try to use long for calculations and typecast to int while returning the answer.\\n "
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "Always getting \\nTime Limit Exceeded\\nany one knows why?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "same"
                    },
                    {
                        "username": "Lunar-Eclipse",
                        "content": "simple question use sqrt(abs(x)), in cpp"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "not to use built in function bro just read the question\\n"
                    },
                    {
                        "username": "darkling23",
                        "content": "class Solution {\\npublic:\\nlong long int binarysearch(int n){\\n    int s =0;\\n    int e = n-1;\\n    long long int mid = s + (e-s)/2;\\n\\n    long long int ans = -1;\\n    while(s<=e){\\n\\n        long long int square = mid*mid;\\n        if (mid == square){\\n            return mid;\\n        }\\n\\n        else if (square<n){\\n            ans = mid;\\n            s = mid+1;\\n        }\\n\\n        else{\\n            e = mid-1;\\n        }\\n        mid = s + (e-s)/2;\\n    }\\n\\n}\\n\\n\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n    }\\n};\\nCan someone please say whats wrong with this code cuz its throwing me this sort of error:\\n\"Line 27: Char 1: error: non-void function does not return a value in all control paths [-Werror,-Wreturn-type]\\n}\\n^\\n1 error generated.\""
                    },
                    {
                        "username": "Kromydas",
                        "content": "You did not return a value in your code. Your binary search function is a long long int, so you are expected to return a long long int. Instead, you did not return anything. \\n\\nTo fix this error, just do `return ans;` in your binary search function after the while loop. (This is based off of how I understand your code). "
                    },
                    {
                        "username": "devTabasco",
                        "content": "There are no specific constraints mentioned regarding the time complexity. However, if exhaustive search is used, it will lead to a runtime error, making the problem unsolvable."
                    },
                    {
                        "username": "Kromydas",
                        "content": "As a helpful hint to all of the beginners, beware of edge cases such as when x = 0. And if you are planning on doing this the brute force way, use while loops, not for loops. If you do for (int i = 0; i < x; i++), this will achieve Time Limit Exceeded. \\n\\nInstead of using for loops, have a while loop with a condition such as while (i * i <= x) {}. This will make it faster, just enough to barely solve the problem. \\n\\nAnother thing to note is that you can\\'t just abs(x - i * i), you have to consider the possibilities under x. Ie if x = 8, you can\\'t consider 9, although it is the closest to 8. You have to consider the one under it, or 4. \\n\\nUsing this method helps you down the line as well. When you return you don\\'t need to separate the perfect square cases and the ones that aren\\'t prefect squares, as I\\'ve seen some solutions do. You only need to return i, not i - 1 or something. \\n\\nP.S use long long int or long long. Otherwise some test cases may fail because of overflow. "
                    },
                    {
                        "username": "alessandromarchesin",
                        "content": "What part of \"1. Please don\\'t post any solutions in this discussion.\" you do not understand?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "me coming into the problem - \"37.5% acceptance rate on an easy?  pfft!\"\\n3 wrong submissions later - \"oh i see...\""
                    },
                    {
                        "username": "digital-idiot",
                        "content": "Why expected output is `2` for the input `8`?\\n\\n`sqrt(8)` is `2.8284271247461903`, when rounded to nearest integer it is `3`."
                    },
                    {
                        "username": "liebrynth",
                        "content": "because its not round up but int and when we convert decimal value to int it will ignore all the decimal after that. That\\'s why answer is 2"
                    },
                    {
                        "username": "TheoW03",
                        "content": "but a better solution I have found. is quick inv sqrt. you run \\n(or the quake 3 algorithm)\\n\\n  x = x * (1.5f - (xhalf * x * x));\\n3 times. \\nand to get the sqrt\\nyou multiply by \\n\\nfloat y = (int)(x*fastInverseSqrt(x)+0.01f);\\n\\nthey are some draw backs. quick_inv_sqrt is not accurate, its an approximation. and it will kill you bc of rounding errors. but its the I believe O(1) solution. and quicker then the stuff the Math libraries offer in C. about 4 times I read. "
                    }
                ]
            },
            {
                "id": 1912030,
                "content": [
                    {
                        "username": "palakgupta1712",
                        "content": "I have used binary search approach to solve this question and I also used long long  int to store the values.  It\\'s still showing TLE for the value 2147395600. Also the constraints are 0 <= x <= 2^31 - 1 , how is this justified please help!"
                    },
                    {
                        "username": "wadhwanichirag93",
                        "content": "its because you must have used (int) try to use long for calculations and typecast to int while returning the answer.\\n "
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "Always getting \\nTime Limit Exceeded\\nany one knows why?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "same"
                    },
                    {
                        "username": "Lunar-Eclipse",
                        "content": "simple question use sqrt(abs(x)), in cpp"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "not to use built in function bro just read the question\\n"
                    },
                    {
                        "username": "darkling23",
                        "content": "class Solution {\\npublic:\\nlong long int binarysearch(int n){\\n    int s =0;\\n    int e = n-1;\\n    long long int mid = s + (e-s)/2;\\n\\n    long long int ans = -1;\\n    while(s<=e){\\n\\n        long long int square = mid*mid;\\n        if (mid == square){\\n            return mid;\\n        }\\n\\n        else if (square<n){\\n            ans = mid;\\n            s = mid+1;\\n        }\\n\\n        else{\\n            e = mid-1;\\n        }\\n        mid = s + (e-s)/2;\\n    }\\n\\n}\\n\\n\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n    }\\n};\\nCan someone please say whats wrong with this code cuz its throwing me this sort of error:\\n\"Line 27: Char 1: error: non-void function does not return a value in all control paths [-Werror,-Wreturn-type]\\n}\\n^\\n1 error generated.\""
                    },
                    {
                        "username": "Kromydas",
                        "content": "You did not return a value in your code. Your binary search function is a long long int, so you are expected to return a long long int. Instead, you did not return anything. \\n\\nTo fix this error, just do `return ans;` in your binary search function after the while loop. (This is based off of how I understand your code). "
                    },
                    {
                        "username": "devTabasco",
                        "content": "There are no specific constraints mentioned regarding the time complexity. However, if exhaustive search is used, it will lead to a runtime error, making the problem unsolvable."
                    },
                    {
                        "username": "Kromydas",
                        "content": "As a helpful hint to all of the beginners, beware of edge cases such as when x = 0. And if you are planning on doing this the brute force way, use while loops, not for loops. If you do for (int i = 0; i < x; i++), this will achieve Time Limit Exceeded. \\n\\nInstead of using for loops, have a while loop with a condition such as while (i * i <= x) {}. This will make it faster, just enough to barely solve the problem. \\n\\nAnother thing to note is that you can\\'t just abs(x - i * i), you have to consider the possibilities under x. Ie if x = 8, you can\\'t consider 9, although it is the closest to 8. You have to consider the one under it, or 4. \\n\\nUsing this method helps you down the line as well. When you return you don\\'t need to separate the perfect square cases and the ones that aren\\'t prefect squares, as I\\'ve seen some solutions do. You only need to return i, not i - 1 or something. \\n\\nP.S use long long int or long long. Otherwise some test cases may fail because of overflow. "
                    },
                    {
                        "username": "alessandromarchesin",
                        "content": "What part of \"1. Please don\\'t post any solutions in this discussion.\" you do not understand?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "me coming into the problem - \"37.5% acceptance rate on an easy?  pfft!\"\\n3 wrong submissions later - \"oh i see...\""
                    },
                    {
                        "username": "digital-idiot",
                        "content": "Why expected output is `2` for the input `8`?\\n\\n`sqrt(8)` is `2.8284271247461903`, when rounded to nearest integer it is `3`."
                    },
                    {
                        "username": "liebrynth",
                        "content": "because its not round up but int and when we convert decimal value to int it will ignore all the decimal after that. That\\'s why answer is 2"
                    },
                    {
                        "username": "TheoW03",
                        "content": "but a better solution I have found. is quick inv sqrt. you run \\n(or the quake 3 algorithm)\\n\\n  x = x * (1.5f - (xhalf * x * x));\\n3 times. \\nand to get the sqrt\\nyou multiply by \\n\\nfloat y = (int)(x*fastInverseSqrt(x)+0.01f);\\n\\nthey are some draw backs. quick_inv_sqrt is not accurate, its an approximation. and it will kill you bc of rounding errors. but its the I believe O(1) solution. and quicker then the stuff the Math libraries offer in C. about 4 times I read. "
                    }
                ]
            },
            {
                "id": 1895498,
                "content": [
                    {
                        "username": "palakgupta1712",
                        "content": "I have used binary search approach to solve this question and I also used long long  int to store the values.  It\\'s still showing TLE for the value 2147395600. Also the constraints are 0 <= x <= 2^31 - 1 , how is this justified please help!"
                    },
                    {
                        "username": "wadhwanichirag93",
                        "content": "its because you must have used (int) try to use long for calculations and typecast to int while returning the answer.\\n "
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "Always getting \\nTime Limit Exceeded\\nany one knows why?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "same"
                    },
                    {
                        "username": "Lunar-Eclipse",
                        "content": "simple question use sqrt(abs(x)), in cpp"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "not to use built in function bro just read the question\\n"
                    },
                    {
                        "username": "darkling23",
                        "content": "class Solution {\\npublic:\\nlong long int binarysearch(int n){\\n    int s =0;\\n    int e = n-1;\\n    long long int mid = s + (e-s)/2;\\n\\n    long long int ans = -1;\\n    while(s<=e){\\n\\n        long long int square = mid*mid;\\n        if (mid == square){\\n            return mid;\\n        }\\n\\n        else if (square<n){\\n            ans = mid;\\n            s = mid+1;\\n        }\\n\\n        else{\\n            e = mid-1;\\n        }\\n        mid = s + (e-s)/2;\\n    }\\n\\n}\\n\\n\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n    }\\n};\\nCan someone please say whats wrong with this code cuz its throwing me this sort of error:\\n\"Line 27: Char 1: error: non-void function does not return a value in all control paths [-Werror,-Wreturn-type]\\n}\\n^\\n1 error generated.\""
                    },
                    {
                        "username": "Kromydas",
                        "content": "You did not return a value in your code. Your binary search function is a long long int, so you are expected to return a long long int. Instead, you did not return anything. \\n\\nTo fix this error, just do `return ans;` in your binary search function after the while loop. (This is based off of how I understand your code). "
                    },
                    {
                        "username": "devTabasco",
                        "content": "There are no specific constraints mentioned regarding the time complexity. However, if exhaustive search is used, it will lead to a runtime error, making the problem unsolvable."
                    },
                    {
                        "username": "Kromydas",
                        "content": "As a helpful hint to all of the beginners, beware of edge cases such as when x = 0. And if you are planning on doing this the brute force way, use while loops, not for loops. If you do for (int i = 0; i < x; i++), this will achieve Time Limit Exceeded. \\n\\nInstead of using for loops, have a while loop with a condition such as while (i * i <= x) {}. This will make it faster, just enough to barely solve the problem. \\n\\nAnother thing to note is that you can\\'t just abs(x - i * i), you have to consider the possibilities under x. Ie if x = 8, you can\\'t consider 9, although it is the closest to 8. You have to consider the one under it, or 4. \\n\\nUsing this method helps you down the line as well. When you return you don\\'t need to separate the perfect square cases and the ones that aren\\'t prefect squares, as I\\'ve seen some solutions do. You only need to return i, not i - 1 or something. \\n\\nP.S use long long int or long long. Otherwise some test cases may fail because of overflow. "
                    },
                    {
                        "username": "alessandromarchesin",
                        "content": "What part of \"1. Please don\\'t post any solutions in this discussion.\" you do not understand?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "me coming into the problem - \"37.5% acceptance rate on an easy?  pfft!\"\\n3 wrong submissions later - \"oh i see...\""
                    },
                    {
                        "username": "digital-idiot",
                        "content": "Why expected output is `2` for the input `8`?\\n\\n`sqrt(8)` is `2.8284271247461903`, when rounded to nearest integer it is `3`."
                    },
                    {
                        "username": "liebrynth",
                        "content": "because its not round up but int and when we convert decimal value to int it will ignore all the decimal after that. That\\'s why answer is 2"
                    },
                    {
                        "username": "TheoW03",
                        "content": "but a better solution I have found. is quick inv sqrt. you run \\n(or the quake 3 algorithm)\\n\\n  x = x * (1.5f - (xhalf * x * x));\\n3 times. \\nand to get the sqrt\\nyou multiply by \\n\\nfloat y = (int)(x*fastInverseSqrt(x)+0.01f);\\n\\nthey are some draw backs. quick_inv_sqrt is not accurate, its an approximation. and it will kill you bc of rounding errors. but its the I believe O(1) solution. and quicker then the stuff the Math libraries offer in C. about 4 times I read. "
                    }
                ]
            },
            {
                "id": 1885107,
                "content": [
                    {
                        "username": "palakgupta1712",
                        "content": "I have used binary search approach to solve this question and I also used long long  int to store the values.  It\\'s still showing TLE for the value 2147395600. Also the constraints are 0 <= x <= 2^31 - 1 , how is this justified please help!"
                    },
                    {
                        "username": "wadhwanichirag93",
                        "content": "its because you must have used (int) try to use long for calculations and typecast to int while returning the answer.\\n "
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "Always getting \\nTime Limit Exceeded\\nany one knows why?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "same"
                    },
                    {
                        "username": "Lunar-Eclipse",
                        "content": "simple question use sqrt(abs(x)), in cpp"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "not to use built in function bro just read the question\\n"
                    },
                    {
                        "username": "darkling23",
                        "content": "class Solution {\\npublic:\\nlong long int binarysearch(int n){\\n    int s =0;\\n    int e = n-1;\\n    long long int mid = s + (e-s)/2;\\n\\n    long long int ans = -1;\\n    while(s<=e){\\n\\n        long long int square = mid*mid;\\n        if (mid == square){\\n            return mid;\\n        }\\n\\n        else if (square<n){\\n            ans = mid;\\n            s = mid+1;\\n        }\\n\\n        else{\\n            e = mid-1;\\n        }\\n        mid = s + (e-s)/2;\\n    }\\n\\n}\\n\\n\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n    }\\n};\\nCan someone please say whats wrong with this code cuz its throwing me this sort of error:\\n\"Line 27: Char 1: error: non-void function does not return a value in all control paths [-Werror,-Wreturn-type]\\n}\\n^\\n1 error generated.\""
                    },
                    {
                        "username": "Kromydas",
                        "content": "You did not return a value in your code. Your binary search function is a long long int, so you are expected to return a long long int. Instead, you did not return anything. \\n\\nTo fix this error, just do `return ans;` in your binary search function after the while loop. (This is based off of how I understand your code). "
                    },
                    {
                        "username": "devTabasco",
                        "content": "There are no specific constraints mentioned regarding the time complexity. However, if exhaustive search is used, it will lead to a runtime error, making the problem unsolvable."
                    },
                    {
                        "username": "Kromydas",
                        "content": "As a helpful hint to all of the beginners, beware of edge cases such as when x = 0. And if you are planning on doing this the brute force way, use while loops, not for loops. If you do for (int i = 0; i < x; i++), this will achieve Time Limit Exceeded. \\n\\nInstead of using for loops, have a while loop with a condition such as while (i * i <= x) {}. This will make it faster, just enough to barely solve the problem. \\n\\nAnother thing to note is that you can\\'t just abs(x - i * i), you have to consider the possibilities under x. Ie if x = 8, you can\\'t consider 9, although it is the closest to 8. You have to consider the one under it, or 4. \\n\\nUsing this method helps you down the line as well. When you return you don\\'t need to separate the perfect square cases and the ones that aren\\'t prefect squares, as I\\'ve seen some solutions do. You only need to return i, not i - 1 or something. \\n\\nP.S use long long int or long long. Otherwise some test cases may fail because of overflow. "
                    },
                    {
                        "username": "alessandromarchesin",
                        "content": "What part of \"1. Please don\\'t post any solutions in this discussion.\" you do not understand?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "me coming into the problem - \"37.5% acceptance rate on an easy?  pfft!\"\\n3 wrong submissions later - \"oh i see...\""
                    },
                    {
                        "username": "digital-idiot",
                        "content": "Why expected output is `2` for the input `8`?\\n\\n`sqrt(8)` is `2.8284271247461903`, when rounded to nearest integer it is `3`."
                    },
                    {
                        "username": "liebrynth",
                        "content": "because its not round up but int and when we convert decimal value to int it will ignore all the decimal after that. That\\'s why answer is 2"
                    },
                    {
                        "username": "TheoW03",
                        "content": "but a better solution I have found. is quick inv sqrt. you run \\n(or the quake 3 algorithm)\\n\\n  x = x * (1.5f - (xhalf * x * x));\\n3 times. \\nand to get the sqrt\\nyou multiply by \\n\\nfloat y = (int)(x*fastInverseSqrt(x)+0.01f);\\n\\nthey are some draw backs. quick_inv_sqrt is not accurate, its an approximation. and it will kill you bc of rounding errors. but its the I believe O(1) solution. and quicker then the stuff the Math libraries offer in C. about 4 times I read. "
                    }
                ]
            },
            {
                "id": 1876400,
                "content": [
                    {
                        "username": "palakgupta1712",
                        "content": "I have used binary search approach to solve this question and I also used long long  int to store the values.  It\\'s still showing TLE for the value 2147395600. Also the constraints are 0 <= x <= 2^31 - 1 , how is this justified please help!"
                    },
                    {
                        "username": "wadhwanichirag93",
                        "content": "its because you must have used (int) try to use long for calculations and typecast to int while returning the answer.\\n "
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "Always getting \\nTime Limit Exceeded\\nany one knows why?"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "same"
                    },
                    {
                        "username": "Lunar-Eclipse",
                        "content": "simple question use sqrt(abs(x)), in cpp"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "not to use built in function bro just read the question\\n"
                    },
                    {
                        "username": "darkling23",
                        "content": "class Solution {\\npublic:\\nlong long int binarysearch(int n){\\n    int s =0;\\n    int e = n-1;\\n    long long int mid = s + (e-s)/2;\\n\\n    long long int ans = -1;\\n    while(s<=e){\\n\\n        long long int square = mid*mid;\\n        if (mid == square){\\n            return mid;\\n        }\\n\\n        else if (square<n){\\n            ans = mid;\\n            s = mid+1;\\n        }\\n\\n        else{\\n            e = mid-1;\\n        }\\n        mid = s + (e-s)/2;\\n    }\\n\\n}\\n\\n\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n    }\\n};\\nCan someone please say whats wrong with this code cuz its throwing me this sort of error:\\n\"Line 27: Char 1: error: non-void function does not return a value in all control paths [-Werror,-Wreturn-type]\\n}\\n^\\n1 error generated.\""
                    },
                    {
                        "username": "Kromydas",
                        "content": "You did not return a value in your code. Your binary search function is a long long int, so you are expected to return a long long int. Instead, you did not return anything. \\n\\nTo fix this error, just do `return ans;` in your binary search function after the while loop. (This is based off of how I understand your code). "
                    },
                    {
                        "username": "devTabasco",
                        "content": "There are no specific constraints mentioned regarding the time complexity. However, if exhaustive search is used, it will lead to a runtime error, making the problem unsolvable."
                    },
                    {
                        "username": "Kromydas",
                        "content": "As a helpful hint to all of the beginners, beware of edge cases such as when x = 0. And if you are planning on doing this the brute force way, use while loops, not for loops. If you do for (int i = 0; i < x; i++), this will achieve Time Limit Exceeded. \\n\\nInstead of using for loops, have a while loop with a condition such as while (i * i <= x) {}. This will make it faster, just enough to barely solve the problem. \\n\\nAnother thing to note is that you can\\'t just abs(x - i * i), you have to consider the possibilities under x. Ie if x = 8, you can\\'t consider 9, although it is the closest to 8. You have to consider the one under it, or 4. \\n\\nUsing this method helps you down the line as well. When you return you don\\'t need to separate the perfect square cases and the ones that aren\\'t prefect squares, as I\\'ve seen some solutions do. You only need to return i, not i - 1 or something. \\n\\nP.S use long long int or long long. Otherwise some test cases may fail because of overflow. "
                    },
                    {
                        "username": "alessandromarchesin",
                        "content": "What part of \"1. Please don\\'t post any solutions in this discussion.\" you do not understand?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "me coming into the problem - \"37.5% acceptance rate on an easy?  pfft!\"\\n3 wrong submissions later - \"oh i see...\""
                    },
                    {
                        "username": "digital-idiot",
                        "content": "Why expected output is `2` for the input `8`?\\n\\n`sqrt(8)` is `2.8284271247461903`, when rounded to nearest integer it is `3`."
                    },
                    {
                        "username": "liebrynth",
                        "content": "because its not round up but int and when we convert decimal value to int it will ignore all the decimal after that. That\\'s why answer is 2"
                    },
                    {
                        "username": "TheoW03",
                        "content": "but a better solution I have found. is quick inv sqrt. you run \\n(or the quake 3 algorithm)\\n\\n  x = x * (1.5f - (xhalf * x * x));\\n3 times. \\nand to get the sqrt\\nyou multiply by \\n\\nfloat y = (int)(x*fastInverseSqrt(x)+0.01f);\\n\\nthey are some draw backs. quick_inv_sqrt is not accurate, its an approximation. and it will kill you bc of rounding errors. but its the I believe O(1) solution. and quicker then the stuff the Math libraries offer in C. about 4 times I read. "
                    }
                ]
            },
            {
                "id": 1876395,
                "content": [
                    {
                        "username": "TheoW03",
                        "content": "sqrt(2147395599) = 46340 \\n\\nnot 46339"
                    },
                    {
                        "username": "DowdyJ",
                        "content": "I ran into this. The square root is more precisely \"46339.9999892\". As floats may not be accurate enough to represent this, switching to double solves the issue."
                    },
                    {
                        "username": "iam_sandeep_maddheshiya",
                        "content": "What\\'s wrong in my code ? 1012/1017 test cases passes only...\\n\\n\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int i=1;\\n        for(int j=1;j<=x/2;j++){\\n            long sq=i*i;\\n            if((int)sq==x){\\n                return i;\\n            }\\n            else if((int)sq>x)\\n            {\\n                return i-1;\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "slisnychyi",
                        "content": "it would be better that to have `long` as return value"
                    },
                    {
                        "username": "Isaiahorekan",
                        "content": "Interesting question"
                    },
                    {
                        "username": "IrenaXiao",
                        "content": "A quick way to find square root is the repeat subtraction method. While it will not produce the fastest code, it is however much easier to write and understand for a newbie like me."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "In problem statement it is mentioned that \"return nearest rounded integer\". Then how come round(2.858) is 2 not 3. And round(2.858) is 3.  As 3 is nearest integer to 2.858.\\nSo Either problem statement is wrong or test cases are rigged.\\nIf in test cases they want floor value then in problem statement they should strictly mention \" return floor value\".\\nBecause floor != round. "
                    },
                    {
                        "username": "gupta_arpita",
                        "content": "Error in TC : 2147395599\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if (x==0 || x ==1)\n            return x;\n\n        int first = 1;\n        int last = x;\n        int mid = (first+last)/2;\n        int pre_mid = mid;\n        int count = 0;\n        unsigned long long int temp =0;\n        while(first<last)\n        {\n            \n\n            if (count !=0 && pre_mid == mid)\n                return mid;\n            temp = mid*mid;\n            if (temp == x)\n                return mid;\n            else if (temp < x)\n                first = mid;\n            else last = mid;\n\n            pre_mid = mid;  \n\n            mid = (first+last)/2; \n            \n            count ++;\n\n                    \n        } \n\n        return mid;   \n    }\n};\n\n\nRuntime Error\n14 / 1017 testcases passed\nLine 19: Char 23: runtime error: signed integer overflow: 1073697800 * 1073697800 cannot be represented in type 'int' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:23\nLast Executed Input\nUse Testcase\nx =\n2147395599\n\n"
                    },
                    {
                        "username": "hirithik05",
                        "content": "\\n#JAVA\\n `class Solution {\\n\\n    long search(int n){\\n        int start =0;\\n        int end = n;\\n        int mid = start+(end-start)/2;\\n        long ans = 0;\\n        while(start<=end){\\n            long square = (long)mid * (long)mid;\\n            if(square == n){\\n                return mid;\\n            }\\n            else if(square>n){\\n                end = mid-1;\\n            }\\n            else{\\n                ans = mid;\\n                start = mid +1;\\n            }mid = start+(end-start)/2;\\n        }return ans;\\n    }\\n    public int mySqrt(int x) {\\n        return (int)search(x);\\n    }\\n}`"
                    },
                    {
                        "username": "sudeepmk45",
                        "content": "how the solution is approached"
                    },
                    {
                        "username": "elkinef84",
                        "content": "Repeated Subtraction Method + recursion have passed here."
                    }
                ]
            },
            {
                "id": 1876039,
                "content": [
                    {
                        "username": "TheoW03",
                        "content": "sqrt(2147395599) = 46340 \\n\\nnot 46339"
                    },
                    {
                        "username": "DowdyJ",
                        "content": "I ran into this. The square root is more precisely \"46339.9999892\". As floats may not be accurate enough to represent this, switching to double solves the issue."
                    },
                    {
                        "username": "iam_sandeep_maddheshiya",
                        "content": "What\\'s wrong in my code ? 1012/1017 test cases passes only...\\n\\n\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int i=1;\\n        for(int j=1;j<=x/2;j++){\\n            long sq=i*i;\\n            if((int)sq==x){\\n                return i;\\n            }\\n            else if((int)sq>x)\\n            {\\n                return i-1;\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "slisnychyi",
                        "content": "it would be better that to have `long` as return value"
                    },
                    {
                        "username": "Isaiahorekan",
                        "content": "Interesting question"
                    },
                    {
                        "username": "IrenaXiao",
                        "content": "A quick way to find square root is the repeat subtraction method. While it will not produce the fastest code, it is however much easier to write and understand for a newbie like me."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "In problem statement it is mentioned that \"return nearest rounded integer\". Then how come round(2.858) is 2 not 3. And round(2.858) is 3.  As 3 is nearest integer to 2.858.\\nSo Either problem statement is wrong or test cases are rigged.\\nIf in test cases they want floor value then in problem statement they should strictly mention \" return floor value\".\\nBecause floor != round. "
                    },
                    {
                        "username": "gupta_arpita",
                        "content": "Error in TC : 2147395599\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if (x==0 || x ==1)\n            return x;\n\n        int first = 1;\n        int last = x;\n        int mid = (first+last)/2;\n        int pre_mid = mid;\n        int count = 0;\n        unsigned long long int temp =0;\n        while(first<last)\n        {\n            \n\n            if (count !=0 && pre_mid == mid)\n                return mid;\n            temp = mid*mid;\n            if (temp == x)\n                return mid;\n            else if (temp < x)\n                first = mid;\n            else last = mid;\n\n            pre_mid = mid;  \n\n            mid = (first+last)/2; \n            \n            count ++;\n\n                    \n        } \n\n        return mid;   \n    }\n};\n\n\nRuntime Error\n14 / 1017 testcases passed\nLine 19: Char 23: runtime error: signed integer overflow: 1073697800 * 1073697800 cannot be represented in type 'int' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:23\nLast Executed Input\nUse Testcase\nx =\n2147395599\n\n"
                    },
                    {
                        "username": "hirithik05",
                        "content": "\\n#JAVA\\n `class Solution {\\n\\n    long search(int n){\\n        int start =0;\\n        int end = n;\\n        int mid = start+(end-start)/2;\\n        long ans = 0;\\n        while(start<=end){\\n            long square = (long)mid * (long)mid;\\n            if(square == n){\\n                return mid;\\n            }\\n            else if(square>n){\\n                end = mid-1;\\n            }\\n            else{\\n                ans = mid;\\n                start = mid +1;\\n            }mid = start+(end-start)/2;\\n        }return ans;\\n    }\\n    public int mySqrt(int x) {\\n        return (int)search(x);\\n    }\\n}`"
                    },
                    {
                        "username": "sudeepmk45",
                        "content": "how the solution is approached"
                    },
                    {
                        "username": "elkinef84",
                        "content": "Repeated Subtraction Method + recursion have passed here."
                    }
                ]
            },
            {
                "id": 1875181,
                "content": [
                    {
                        "username": "TheoW03",
                        "content": "sqrt(2147395599) = 46340 \\n\\nnot 46339"
                    },
                    {
                        "username": "DowdyJ",
                        "content": "I ran into this. The square root is more precisely \"46339.9999892\". As floats may not be accurate enough to represent this, switching to double solves the issue."
                    },
                    {
                        "username": "iam_sandeep_maddheshiya",
                        "content": "What\\'s wrong in my code ? 1012/1017 test cases passes only...\\n\\n\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int i=1;\\n        for(int j=1;j<=x/2;j++){\\n            long sq=i*i;\\n            if((int)sq==x){\\n                return i;\\n            }\\n            else if((int)sq>x)\\n            {\\n                return i-1;\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "slisnychyi",
                        "content": "it would be better that to have `long` as return value"
                    },
                    {
                        "username": "Isaiahorekan",
                        "content": "Interesting question"
                    },
                    {
                        "username": "IrenaXiao",
                        "content": "A quick way to find square root is the repeat subtraction method. While it will not produce the fastest code, it is however much easier to write and understand for a newbie like me."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "In problem statement it is mentioned that \"return nearest rounded integer\". Then how come round(2.858) is 2 not 3. And round(2.858) is 3.  As 3 is nearest integer to 2.858.\\nSo Either problem statement is wrong or test cases are rigged.\\nIf in test cases they want floor value then in problem statement they should strictly mention \" return floor value\".\\nBecause floor != round. "
                    },
                    {
                        "username": "gupta_arpita",
                        "content": "Error in TC : 2147395599\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if (x==0 || x ==1)\n            return x;\n\n        int first = 1;\n        int last = x;\n        int mid = (first+last)/2;\n        int pre_mid = mid;\n        int count = 0;\n        unsigned long long int temp =0;\n        while(first<last)\n        {\n            \n\n            if (count !=0 && pre_mid == mid)\n                return mid;\n            temp = mid*mid;\n            if (temp == x)\n                return mid;\n            else if (temp < x)\n                first = mid;\n            else last = mid;\n\n            pre_mid = mid;  \n\n            mid = (first+last)/2; \n            \n            count ++;\n\n                    \n        } \n\n        return mid;   \n    }\n};\n\n\nRuntime Error\n14 / 1017 testcases passed\nLine 19: Char 23: runtime error: signed integer overflow: 1073697800 * 1073697800 cannot be represented in type 'int' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:23\nLast Executed Input\nUse Testcase\nx =\n2147395599\n\n"
                    },
                    {
                        "username": "hirithik05",
                        "content": "\\n#JAVA\\n `class Solution {\\n\\n    long search(int n){\\n        int start =0;\\n        int end = n;\\n        int mid = start+(end-start)/2;\\n        long ans = 0;\\n        while(start<=end){\\n            long square = (long)mid * (long)mid;\\n            if(square == n){\\n                return mid;\\n            }\\n            else if(square>n){\\n                end = mid-1;\\n            }\\n            else{\\n                ans = mid;\\n                start = mid +1;\\n            }mid = start+(end-start)/2;\\n        }return ans;\\n    }\\n    public int mySqrt(int x) {\\n        return (int)search(x);\\n    }\\n}`"
                    },
                    {
                        "username": "sudeepmk45",
                        "content": "how the solution is approached"
                    },
                    {
                        "username": "elkinef84",
                        "content": "Repeated Subtraction Method + recursion have passed here."
                    }
                ]
            },
            {
                "id": 1873010,
                "content": [
                    {
                        "username": "TheoW03",
                        "content": "sqrt(2147395599) = 46340 \\n\\nnot 46339"
                    },
                    {
                        "username": "DowdyJ",
                        "content": "I ran into this. The square root is more precisely \"46339.9999892\". As floats may not be accurate enough to represent this, switching to double solves the issue."
                    },
                    {
                        "username": "iam_sandeep_maddheshiya",
                        "content": "What\\'s wrong in my code ? 1012/1017 test cases passes only...\\n\\n\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int i=1;\\n        for(int j=1;j<=x/2;j++){\\n            long sq=i*i;\\n            if((int)sq==x){\\n                return i;\\n            }\\n            else if((int)sq>x)\\n            {\\n                return i-1;\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "slisnychyi",
                        "content": "it would be better that to have `long` as return value"
                    },
                    {
                        "username": "Isaiahorekan",
                        "content": "Interesting question"
                    },
                    {
                        "username": "IrenaXiao",
                        "content": "A quick way to find square root is the repeat subtraction method. While it will not produce the fastest code, it is however much easier to write and understand for a newbie like me."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "In problem statement it is mentioned that \"return nearest rounded integer\". Then how come round(2.858) is 2 not 3. And round(2.858) is 3.  As 3 is nearest integer to 2.858.\\nSo Either problem statement is wrong or test cases are rigged.\\nIf in test cases they want floor value then in problem statement they should strictly mention \" return floor value\".\\nBecause floor != round. "
                    },
                    {
                        "username": "gupta_arpita",
                        "content": "Error in TC : 2147395599\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if (x==0 || x ==1)\n            return x;\n\n        int first = 1;\n        int last = x;\n        int mid = (first+last)/2;\n        int pre_mid = mid;\n        int count = 0;\n        unsigned long long int temp =0;\n        while(first<last)\n        {\n            \n\n            if (count !=0 && pre_mid == mid)\n                return mid;\n            temp = mid*mid;\n            if (temp == x)\n                return mid;\n            else if (temp < x)\n                first = mid;\n            else last = mid;\n\n            pre_mid = mid;  \n\n            mid = (first+last)/2; \n            \n            count ++;\n\n                    \n        } \n\n        return mid;   \n    }\n};\n\n\nRuntime Error\n14 / 1017 testcases passed\nLine 19: Char 23: runtime error: signed integer overflow: 1073697800 * 1073697800 cannot be represented in type 'int' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:23\nLast Executed Input\nUse Testcase\nx =\n2147395599\n\n"
                    },
                    {
                        "username": "hirithik05",
                        "content": "\\n#JAVA\\n `class Solution {\\n\\n    long search(int n){\\n        int start =0;\\n        int end = n;\\n        int mid = start+(end-start)/2;\\n        long ans = 0;\\n        while(start<=end){\\n            long square = (long)mid * (long)mid;\\n            if(square == n){\\n                return mid;\\n            }\\n            else if(square>n){\\n                end = mid-1;\\n            }\\n            else{\\n                ans = mid;\\n                start = mid +1;\\n            }mid = start+(end-start)/2;\\n        }return ans;\\n    }\\n    public int mySqrt(int x) {\\n        return (int)search(x);\\n    }\\n}`"
                    },
                    {
                        "username": "sudeepmk45",
                        "content": "how the solution is approached"
                    },
                    {
                        "username": "elkinef84",
                        "content": "Repeated Subtraction Method + recursion have passed here."
                    }
                ]
            },
            {
                "id": 1871645,
                "content": [
                    {
                        "username": "TheoW03",
                        "content": "sqrt(2147395599) = 46340 \\n\\nnot 46339"
                    },
                    {
                        "username": "DowdyJ",
                        "content": "I ran into this. The square root is more precisely \"46339.9999892\". As floats may not be accurate enough to represent this, switching to double solves the issue."
                    },
                    {
                        "username": "iam_sandeep_maddheshiya",
                        "content": "What\\'s wrong in my code ? 1012/1017 test cases passes only...\\n\\n\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int i=1;\\n        for(int j=1;j<=x/2;j++){\\n            long sq=i*i;\\n            if((int)sq==x){\\n                return i;\\n            }\\n            else if((int)sq>x)\\n            {\\n                return i-1;\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "slisnychyi",
                        "content": "it would be better that to have `long` as return value"
                    },
                    {
                        "username": "Isaiahorekan",
                        "content": "Interesting question"
                    },
                    {
                        "username": "IrenaXiao",
                        "content": "A quick way to find square root is the repeat subtraction method. While it will not produce the fastest code, it is however much easier to write and understand for a newbie like me."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "In problem statement it is mentioned that \"return nearest rounded integer\". Then how come round(2.858) is 2 not 3. And round(2.858) is 3.  As 3 is nearest integer to 2.858.\\nSo Either problem statement is wrong or test cases are rigged.\\nIf in test cases they want floor value then in problem statement they should strictly mention \" return floor value\".\\nBecause floor != round. "
                    },
                    {
                        "username": "gupta_arpita",
                        "content": "Error in TC : 2147395599\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if (x==0 || x ==1)\n            return x;\n\n        int first = 1;\n        int last = x;\n        int mid = (first+last)/2;\n        int pre_mid = mid;\n        int count = 0;\n        unsigned long long int temp =0;\n        while(first<last)\n        {\n            \n\n            if (count !=0 && pre_mid == mid)\n                return mid;\n            temp = mid*mid;\n            if (temp == x)\n                return mid;\n            else if (temp < x)\n                first = mid;\n            else last = mid;\n\n            pre_mid = mid;  \n\n            mid = (first+last)/2; \n            \n            count ++;\n\n                    \n        } \n\n        return mid;   \n    }\n};\n\n\nRuntime Error\n14 / 1017 testcases passed\nLine 19: Char 23: runtime error: signed integer overflow: 1073697800 * 1073697800 cannot be represented in type 'int' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:23\nLast Executed Input\nUse Testcase\nx =\n2147395599\n\n"
                    },
                    {
                        "username": "hirithik05",
                        "content": "\\n#JAVA\\n `class Solution {\\n\\n    long search(int n){\\n        int start =0;\\n        int end = n;\\n        int mid = start+(end-start)/2;\\n        long ans = 0;\\n        while(start<=end){\\n            long square = (long)mid * (long)mid;\\n            if(square == n){\\n                return mid;\\n            }\\n            else if(square>n){\\n                end = mid-1;\\n            }\\n            else{\\n                ans = mid;\\n                start = mid +1;\\n            }mid = start+(end-start)/2;\\n        }return ans;\\n    }\\n    public int mySqrt(int x) {\\n        return (int)search(x);\\n    }\\n}`"
                    },
                    {
                        "username": "sudeepmk45",
                        "content": "how the solution is approached"
                    },
                    {
                        "username": "elkinef84",
                        "content": "Repeated Subtraction Method + recursion have passed here."
                    }
                ]
            },
            {
                "id": 1866008,
                "content": [
                    {
                        "username": "TheoW03",
                        "content": "sqrt(2147395599) = 46340 \\n\\nnot 46339"
                    },
                    {
                        "username": "DowdyJ",
                        "content": "I ran into this. The square root is more precisely \"46339.9999892\". As floats may not be accurate enough to represent this, switching to double solves the issue."
                    },
                    {
                        "username": "iam_sandeep_maddheshiya",
                        "content": "What\\'s wrong in my code ? 1012/1017 test cases passes only...\\n\\n\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int i=1;\\n        for(int j=1;j<=x/2;j++){\\n            long sq=i*i;\\n            if((int)sq==x){\\n                return i;\\n            }\\n            else if((int)sq>x)\\n            {\\n                return i-1;\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "slisnychyi",
                        "content": "it would be better that to have `long` as return value"
                    },
                    {
                        "username": "Isaiahorekan",
                        "content": "Interesting question"
                    },
                    {
                        "username": "IrenaXiao",
                        "content": "A quick way to find square root is the repeat subtraction method. While it will not produce the fastest code, it is however much easier to write and understand for a newbie like me."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "In problem statement it is mentioned that \"return nearest rounded integer\". Then how come round(2.858) is 2 not 3. And round(2.858) is 3.  As 3 is nearest integer to 2.858.\\nSo Either problem statement is wrong or test cases are rigged.\\nIf in test cases they want floor value then in problem statement they should strictly mention \" return floor value\".\\nBecause floor != round. "
                    },
                    {
                        "username": "gupta_arpita",
                        "content": "Error in TC : 2147395599\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if (x==0 || x ==1)\n            return x;\n\n        int first = 1;\n        int last = x;\n        int mid = (first+last)/2;\n        int pre_mid = mid;\n        int count = 0;\n        unsigned long long int temp =0;\n        while(first<last)\n        {\n            \n\n            if (count !=0 && pre_mid == mid)\n                return mid;\n            temp = mid*mid;\n            if (temp == x)\n                return mid;\n            else if (temp < x)\n                first = mid;\n            else last = mid;\n\n            pre_mid = mid;  \n\n            mid = (first+last)/2; \n            \n            count ++;\n\n                    \n        } \n\n        return mid;   \n    }\n};\n\n\nRuntime Error\n14 / 1017 testcases passed\nLine 19: Char 23: runtime error: signed integer overflow: 1073697800 * 1073697800 cannot be represented in type 'int' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:23\nLast Executed Input\nUse Testcase\nx =\n2147395599\n\n"
                    },
                    {
                        "username": "hirithik05",
                        "content": "\\n#JAVA\\n `class Solution {\\n\\n    long search(int n){\\n        int start =0;\\n        int end = n;\\n        int mid = start+(end-start)/2;\\n        long ans = 0;\\n        while(start<=end){\\n            long square = (long)mid * (long)mid;\\n            if(square == n){\\n                return mid;\\n            }\\n            else if(square>n){\\n                end = mid-1;\\n            }\\n            else{\\n                ans = mid;\\n                start = mid +1;\\n            }mid = start+(end-start)/2;\\n        }return ans;\\n    }\\n    public int mySqrt(int x) {\\n        return (int)search(x);\\n    }\\n}`"
                    },
                    {
                        "username": "sudeepmk45",
                        "content": "how the solution is approached"
                    },
                    {
                        "username": "elkinef84",
                        "content": "Repeated Subtraction Method + recursion have passed here."
                    }
                ]
            },
            {
                "id": 1852338,
                "content": [
                    {
                        "username": "TheoW03",
                        "content": "sqrt(2147395599) = 46340 \\n\\nnot 46339"
                    },
                    {
                        "username": "DowdyJ",
                        "content": "I ran into this. The square root is more precisely \"46339.9999892\". As floats may not be accurate enough to represent this, switching to double solves the issue."
                    },
                    {
                        "username": "iam_sandeep_maddheshiya",
                        "content": "What\\'s wrong in my code ? 1012/1017 test cases passes only...\\n\\n\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int i=1;\\n        for(int j=1;j<=x/2;j++){\\n            long sq=i*i;\\n            if((int)sq==x){\\n                return i;\\n            }\\n            else if((int)sq>x)\\n            {\\n                return i-1;\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "slisnychyi",
                        "content": "it would be better that to have `long` as return value"
                    },
                    {
                        "username": "Isaiahorekan",
                        "content": "Interesting question"
                    },
                    {
                        "username": "IrenaXiao",
                        "content": "A quick way to find square root is the repeat subtraction method. While it will not produce the fastest code, it is however much easier to write and understand for a newbie like me."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "In problem statement it is mentioned that \"return nearest rounded integer\". Then how come round(2.858) is 2 not 3. And round(2.858) is 3.  As 3 is nearest integer to 2.858.\\nSo Either problem statement is wrong or test cases are rigged.\\nIf in test cases they want floor value then in problem statement they should strictly mention \" return floor value\".\\nBecause floor != round. "
                    },
                    {
                        "username": "gupta_arpita",
                        "content": "Error in TC : 2147395599\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if (x==0 || x ==1)\n            return x;\n\n        int first = 1;\n        int last = x;\n        int mid = (first+last)/2;\n        int pre_mid = mid;\n        int count = 0;\n        unsigned long long int temp =0;\n        while(first<last)\n        {\n            \n\n            if (count !=0 && pre_mid == mid)\n                return mid;\n            temp = mid*mid;\n            if (temp == x)\n                return mid;\n            else if (temp < x)\n                first = mid;\n            else last = mid;\n\n            pre_mid = mid;  \n\n            mid = (first+last)/2; \n            \n            count ++;\n\n                    \n        } \n\n        return mid;   \n    }\n};\n\n\nRuntime Error\n14 / 1017 testcases passed\nLine 19: Char 23: runtime error: signed integer overflow: 1073697800 * 1073697800 cannot be represented in type 'int' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:23\nLast Executed Input\nUse Testcase\nx =\n2147395599\n\n"
                    },
                    {
                        "username": "hirithik05",
                        "content": "\\n#JAVA\\n `class Solution {\\n\\n    long search(int n){\\n        int start =0;\\n        int end = n;\\n        int mid = start+(end-start)/2;\\n        long ans = 0;\\n        while(start<=end){\\n            long square = (long)mid * (long)mid;\\n            if(square == n){\\n                return mid;\\n            }\\n            else if(square>n){\\n                end = mid-1;\\n            }\\n            else{\\n                ans = mid;\\n                start = mid +1;\\n            }mid = start+(end-start)/2;\\n        }return ans;\\n    }\\n    public int mySqrt(int x) {\\n        return (int)search(x);\\n    }\\n}`"
                    },
                    {
                        "username": "sudeepmk45",
                        "content": "how the solution is approached"
                    },
                    {
                        "username": "elkinef84",
                        "content": "Repeated Subtraction Method + recursion have passed here."
                    }
                ]
            },
            {
                "id": 1847857,
                "content": [
                    {
                        "username": "TheoW03",
                        "content": "sqrt(2147395599) = 46340 \\n\\nnot 46339"
                    },
                    {
                        "username": "DowdyJ",
                        "content": "I ran into this. The square root is more precisely \"46339.9999892\". As floats may not be accurate enough to represent this, switching to double solves the issue."
                    },
                    {
                        "username": "iam_sandeep_maddheshiya",
                        "content": "What\\'s wrong in my code ? 1012/1017 test cases passes only...\\n\\n\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int i=1;\\n        for(int j=1;j<=x/2;j++){\\n            long sq=i*i;\\n            if((int)sq==x){\\n                return i;\\n            }\\n            else if((int)sq>x)\\n            {\\n                return i-1;\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "slisnychyi",
                        "content": "it would be better that to have `long` as return value"
                    },
                    {
                        "username": "Isaiahorekan",
                        "content": "Interesting question"
                    },
                    {
                        "username": "IrenaXiao",
                        "content": "A quick way to find square root is the repeat subtraction method. While it will not produce the fastest code, it is however much easier to write and understand for a newbie like me."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "In problem statement it is mentioned that \"return nearest rounded integer\". Then how come round(2.858) is 2 not 3. And round(2.858) is 3.  As 3 is nearest integer to 2.858.\\nSo Either problem statement is wrong or test cases are rigged.\\nIf in test cases they want floor value then in problem statement they should strictly mention \" return floor value\".\\nBecause floor != round. "
                    },
                    {
                        "username": "gupta_arpita",
                        "content": "Error in TC : 2147395599\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if (x==0 || x ==1)\n            return x;\n\n        int first = 1;\n        int last = x;\n        int mid = (first+last)/2;\n        int pre_mid = mid;\n        int count = 0;\n        unsigned long long int temp =0;\n        while(first<last)\n        {\n            \n\n            if (count !=0 && pre_mid == mid)\n                return mid;\n            temp = mid*mid;\n            if (temp == x)\n                return mid;\n            else if (temp < x)\n                first = mid;\n            else last = mid;\n\n            pre_mid = mid;  \n\n            mid = (first+last)/2; \n            \n            count ++;\n\n                    \n        } \n\n        return mid;   \n    }\n};\n\n\nRuntime Error\n14 / 1017 testcases passed\nLine 19: Char 23: runtime error: signed integer overflow: 1073697800 * 1073697800 cannot be represented in type 'int' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:23\nLast Executed Input\nUse Testcase\nx =\n2147395599\n\n"
                    },
                    {
                        "username": "hirithik05",
                        "content": "\\n#JAVA\\n `class Solution {\\n\\n    long search(int n){\\n        int start =0;\\n        int end = n;\\n        int mid = start+(end-start)/2;\\n        long ans = 0;\\n        while(start<=end){\\n            long square = (long)mid * (long)mid;\\n            if(square == n){\\n                return mid;\\n            }\\n            else if(square>n){\\n                end = mid-1;\\n            }\\n            else{\\n                ans = mid;\\n                start = mid +1;\\n            }mid = start+(end-start)/2;\\n        }return ans;\\n    }\\n    public int mySqrt(int x) {\\n        return (int)search(x);\\n    }\\n}`"
                    },
                    {
                        "username": "sudeepmk45",
                        "content": "how the solution is approached"
                    },
                    {
                        "username": "elkinef84",
                        "content": "Repeated Subtraction Method + recursion have passed here."
                    }
                ]
            },
            {
                "id": 1847116,
                "content": [
                    {
                        "username": "TheoW03",
                        "content": "sqrt(2147395599) = 46340 \\n\\nnot 46339"
                    },
                    {
                        "username": "DowdyJ",
                        "content": "I ran into this. The square root is more precisely \"46339.9999892\". As floats may not be accurate enough to represent this, switching to double solves the issue."
                    },
                    {
                        "username": "iam_sandeep_maddheshiya",
                        "content": "What\\'s wrong in my code ? 1012/1017 test cases passes only...\\n\\n\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int i=1;\\n        for(int j=1;j<=x/2;j++){\\n            long sq=i*i;\\n            if((int)sq==x){\\n                return i;\\n            }\\n            else if((int)sq>x)\\n            {\\n                return i-1;\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "slisnychyi",
                        "content": "it would be better that to have `long` as return value"
                    },
                    {
                        "username": "Isaiahorekan",
                        "content": "Interesting question"
                    },
                    {
                        "username": "IrenaXiao",
                        "content": "A quick way to find square root is the repeat subtraction method. While it will not produce the fastest code, it is however much easier to write and understand for a newbie like me."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "In problem statement it is mentioned that \"return nearest rounded integer\". Then how come round(2.858) is 2 not 3. And round(2.858) is 3.  As 3 is nearest integer to 2.858.\\nSo Either problem statement is wrong or test cases are rigged.\\nIf in test cases they want floor value then in problem statement they should strictly mention \" return floor value\".\\nBecause floor != round. "
                    },
                    {
                        "username": "gupta_arpita",
                        "content": "Error in TC : 2147395599\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if (x==0 || x ==1)\n            return x;\n\n        int first = 1;\n        int last = x;\n        int mid = (first+last)/2;\n        int pre_mid = mid;\n        int count = 0;\n        unsigned long long int temp =0;\n        while(first<last)\n        {\n            \n\n            if (count !=0 && pre_mid == mid)\n                return mid;\n            temp = mid*mid;\n            if (temp == x)\n                return mid;\n            else if (temp < x)\n                first = mid;\n            else last = mid;\n\n            pre_mid = mid;  \n\n            mid = (first+last)/2; \n            \n            count ++;\n\n                    \n        } \n\n        return mid;   \n    }\n};\n\n\nRuntime Error\n14 / 1017 testcases passed\nLine 19: Char 23: runtime error: signed integer overflow: 1073697800 * 1073697800 cannot be represented in type 'int' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:23\nLast Executed Input\nUse Testcase\nx =\n2147395599\n\n"
                    },
                    {
                        "username": "hirithik05",
                        "content": "\\n#JAVA\\n `class Solution {\\n\\n    long search(int n){\\n        int start =0;\\n        int end = n;\\n        int mid = start+(end-start)/2;\\n        long ans = 0;\\n        while(start<=end){\\n            long square = (long)mid * (long)mid;\\n            if(square == n){\\n                return mid;\\n            }\\n            else if(square>n){\\n                end = mid-1;\\n            }\\n            else{\\n                ans = mid;\\n                start = mid +1;\\n            }mid = start+(end-start)/2;\\n        }return ans;\\n    }\\n    public int mySqrt(int x) {\\n        return (int)search(x);\\n    }\\n}`"
                    },
                    {
                        "username": "sudeepmk45",
                        "content": "how the solution is approached"
                    },
                    {
                        "username": "elkinef84",
                        "content": "Repeated Subtraction Method + recursion have passed here."
                    }
                ]
            },
            {
                "id": 1837537,
                "content": [
                    {
                        "username": "TheoW03",
                        "content": "sqrt(2147395599) = 46340 \\n\\nnot 46339"
                    },
                    {
                        "username": "DowdyJ",
                        "content": "I ran into this. The square root is more precisely \"46339.9999892\". As floats may not be accurate enough to represent this, switching to double solves the issue."
                    },
                    {
                        "username": "iam_sandeep_maddheshiya",
                        "content": "What\\'s wrong in my code ? 1012/1017 test cases passes only...\\n\\n\\nclass Solution {\\n    public int mySqrt(int x) {\\n        int i=1;\\n        for(int j=1;j<=x/2;j++){\\n            long sq=i*i;\\n            if((int)sq==x){\\n                return i;\\n            }\\n            else if((int)sq>x)\\n            {\\n                return i-1;\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n}"
                    },
                    {
                        "username": "slisnychyi",
                        "content": "it would be better that to have `long` as return value"
                    },
                    {
                        "username": "Isaiahorekan",
                        "content": "Interesting question"
                    },
                    {
                        "username": "IrenaXiao",
                        "content": "A quick way to find square root is the repeat subtraction method. While it will not produce the fastest code, it is however much easier to write and understand for a newbie like me."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "In problem statement it is mentioned that \"return nearest rounded integer\". Then how come round(2.858) is 2 not 3. And round(2.858) is 3.  As 3 is nearest integer to 2.858.\\nSo Either problem statement is wrong or test cases are rigged.\\nIf in test cases they want floor value then in problem statement they should strictly mention \" return floor value\".\\nBecause floor != round. "
                    },
                    {
                        "username": "gupta_arpita",
                        "content": "Error in TC : 2147395599\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if (x==0 || x ==1)\n            return x;\n\n        int first = 1;\n        int last = x;\n        int mid = (first+last)/2;\n        int pre_mid = mid;\n        int count = 0;\n        unsigned long long int temp =0;\n        while(first<last)\n        {\n            \n\n            if (count !=0 && pre_mid == mid)\n                return mid;\n            temp = mid*mid;\n            if (temp == x)\n                return mid;\n            else if (temp < x)\n                first = mid;\n            else last = mid;\n\n            pre_mid = mid;  \n\n            mid = (first+last)/2; \n            \n            count ++;\n\n                    \n        } \n\n        return mid;   \n    }\n};\n\n\nRuntime Error\n14 / 1017 testcases passed\nLine 19: Char 23: runtime error: signed integer overflow: 1073697800 * 1073697800 cannot be represented in type 'int' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:28:23\nLast Executed Input\nUse Testcase\nx =\n2147395599\n\n"
                    },
                    {
                        "username": "hirithik05",
                        "content": "\\n#JAVA\\n `class Solution {\\n\\n    long search(int n){\\n        int start =0;\\n        int end = n;\\n        int mid = start+(end-start)/2;\\n        long ans = 0;\\n        while(start<=end){\\n            long square = (long)mid * (long)mid;\\n            if(square == n){\\n                return mid;\\n            }\\n            else if(square>n){\\n                end = mid-1;\\n            }\\n            else{\\n                ans = mid;\\n                start = mid +1;\\n            }mid = start+(end-start)/2;\\n        }return ans;\\n    }\\n    public int mySqrt(int x) {\\n        return (int)search(x);\\n    }\\n}`"
                    },
                    {
                        "username": "sudeepmk45",
                        "content": "how the solution is approached"
                    },
                    {
                        "username": "elkinef84",
                        "content": "Repeated Subtraction Method + recursion have passed here."
                    }
                ]
            },
            {
                "id": 1836039,
                "content": [
                    {
                        "username": "imsumit_17",
                        "content": "guys what problem we will get if we directly use sqrt function in c++ will it be considered as bad coding practice?"
                    },
                    {
                        "username": "radek4128",
                        "content": "If the description says that we can\\'t use any built-in exponent function, why submissions with them are accepted?"
                    },
                    {
                        "username": "Keremovsky",
                        "content": "don\\'t use mid = (first + last) / 2 for find middle value\\nuse mid = first + (last - first) / 2 so you don\\'t have to deal with 2147395600"
                    },
                    {
                        "username": "Sanjeevan-S",
                        "content": " `int i=1;\\n        if(x>=0 && x<1){`\\n           ` return 0;`\\n       ` }`\\n       ` else{`\\n           ` while (i <= x/i) {`\\n           ` i++;`\\n          `  }`\\n       ` }`\\n       ` return i-1;`\\n\\ncouldnt think of the binary search solution, this is what i was able to come up with"
                    },
                    {
                        "username": "thatsiddharth",
                        "content": "what if i directly do \\nclass Solution {\\n    public int mySqrt(int x) {\\n       return (int)Math.sqrt(x);\\n    }\\n}"
                    },
                    {
                        "username": "CyberMaestro",
                        "content": "return int(math.sqrt(x))"
                    },
                    {
                        "username": "akashshaw01",
                        "content": "hint - data type of mid will be long long beacause mid * mid be overflow the limit of the int.\\n\\n\\n\\nmy code - https://leetcode.com/problems/sqrtx/solutions/3216039/c-simple-binary-search-o-log-n-beginner-friendly/?orderBy=most_votes"
                    },
                    {
                        "username": "BachusPL",
                        "content": "Is this the simplest problem in Leetcode?"
                    },
                    {
                        "username": "kumarprashant82061",
                        "content": "class Solution {\\npublic:\\n    int mySqrt(int x) {\\n         if(x <= 1)\\n        return x;\\n\\n        return floor(sqrt(x));\\n    }\\n};"
                    },
                    {
                        "username": "Shankhadeep2017",
                        "content": "In Python Its very simple to solve, There is a in build function Import math \\njust used math.squer() and whats value return just convert into a integer .solved the problem.\\nexample:\\nimport math\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        ans = math.sqrt(x)\\n        return int(ans)\\n\\n"
                    },
                    {
                        "username": "Alex230103",
                        "content": "the whole point of this problem is to not use build in functions"
                    }
                ]
            },
            {
                "id": 1835019,
                "content": [
                    {
                        "username": "imsumit_17",
                        "content": "guys what problem we will get if we directly use sqrt function in c++ will it be considered as bad coding practice?"
                    },
                    {
                        "username": "radek4128",
                        "content": "If the description says that we can\\'t use any built-in exponent function, why submissions with them are accepted?"
                    },
                    {
                        "username": "Keremovsky",
                        "content": "don\\'t use mid = (first + last) / 2 for find middle value\\nuse mid = first + (last - first) / 2 so you don\\'t have to deal with 2147395600"
                    },
                    {
                        "username": "Sanjeevan-S",
                        "content": " `int i=1;\\n        if(x>=0 && x<1){`\\n           ` return 0;`\\n       ` }`\\n       ` else{`\\n           ` while (i <= x/i) {`\\n           ` i++;`\\n          `  }`\\n       ` }`\\n       ` return i-1;`\\n\\ncouldnt think of the binary search solution, this is what i was able to come up with"
                    },
                    {
                        "username": "thatsiddharth",
                        "content": "what if i directly do \\nclass Solution {\\n    public int mySqrt(int x) {\\n       return (int)Math.sqrt(x);\\n    }\\n}"
                    },
                    {
                        "username": "CyberMaestro",
                        "content": "return int(math.sqrt(x))"
                    },
                    {
                        "username": "akashshaw01",
                        "content": "hint - data type of mid will be long long beacause mid * mid be overflow the limit of the int.\\n\\n\\n\\nmy code - https://leetcode.com/problems/sqrtx/solutions/3216039/c-simple-binary-search-o-log-n-beginner-friendly/?orderBy=most_votes"
                    },
                    {
                        "username": "BachusPL",
                        "content": "Is this the simplest problem in Leetcode?"
                    },
                    {
                        "username": "kumarprashant82061",
                        "content": "class Solution {\\npublic:\\n    int mySqrt(int x) {\\n         if(x <= 1)\\n        return x;\\n\\n        return floor(sqrt(x));\\n    }\\n};"
                    },
                    {
                        "username": "Shankhadeep2017",
                        "content": "In Python Its very simple to solve, There is a in build function Import math \\njust used math.squer() and whats value return just convert into a integer .solved the problem.\\nexample:\\nimport math\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        ans = math.sqrt(x)\\n        return int(ans)\\n\\n"
                    },
                    {
                        "username": "Alex230103",
                        "content": "the whole point of this problem is to not use build in functions"
                    }
                ]
            },
            {
                "id": 1832165,
                "content": [
                    {
                        "username": "imsumit_17",
                        "content": "guys what problem we will get if we directly use sqrt function in c++ will it be considered as bad coding practice?"
                    },
                    {
                        "username": "radek4128",
                        "content": "If the description says that we can\\'t use any built-in exponent function, why submissions with them are accepted?"
                    },
                    {
                        "username": "Keremovsky",
                        "content": "don\\'t use mid = (first + last) / 2 for find middle value\\nuse mid = first + (last - first) / 2 so you don\\'t have to deal with 2147395600"
                    },
                    {
                        "username": "Sanjeevan-S",
                        "content": " `int i=1;\\n        if(x>=0 && x<1){`\\n           ` return 0;`\\n       ` }`\\n       ` else{`\\n           ` while (i <= x/i) {`\\n           ` i++;`\\n          `  }`\\n       ` }`\\n       ` return i-1;`\\n\\ncouldnt think of the binary search solution, this is what i was able to come up with"
                    },
                    {
                        "username": "thatsiddharth",
                        "content": "what if i directly do \\nclass Solution {\\n    public int mySqrt(int x) {\\n       return (int)Math.sqrt(x);\\n    }\\n}"
                    },
                    {
                        "username": "CyberMaestro",
                        "content": "return int(math.sqrt(x))"
                    },
                    {
                        "username": "akashshaw01",
                        "content": "hint - data type of mid will be long long beacause mid * mid be overflow the limit of the int.\\n\\n\\n\\nmy code - https://leetcode.com/problems/sqrtx/solutions/3216039/c-simple-binary-search-o-log-n-beginner-friendly/?orderBy=most_votes"
                    },
                    {
                        "username": "BachusPL",
                        "content": "Is this the simplest problem in Leetcode?"
                    },
                    {
                        "username": "kumarprashant82061",
                        "content": "class Solution {\\npublic:\\n    int mySqrt(int x) {\\n         if(x <= 1)\\n        return x;\\n\\n        return floor(sqrt(x));\\n    }\\n};"
                    },
                    {
                        "username": "Shankhadeep2017",
                        "content": "In Python Its very simple to solve, There is a in build function Import math \\njust used math.squer() and whats value return just convert into a integer .solved the problem.\\nexample:\\nimport math\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        ans = math.sqrt(x)\\n        return int(ans)\\n\\n"
                    },
                    {
                        "username": "Alex230103",
                        "content": "the whole point of this problem is to not use build in functions"
                    }
                ]
            },
            {
                "id": 1824213,
                "content": [
                    {
                        "username": "imsumit_17",
                        "content": "guys what problem we will get if we directly use sqrt function in c++ will it be considered as bad coding practice?"
                    },
                    {
                        "username": "radek4128",
                        "content": "If the description says that we can\\'t use any built-in exponent function, why submissions with them are accepted?"
                    },
                    {
                        "username": "Keremovsky",
                        "content": "don\\'t use mid = (first + last) / 2 for find middle value\\nuse mid = first + (last - first) / 2 so you don\\'t have to deal with 2147395600"
                    },
                    {
                        "username": "Sanjeevan-S",
                        "content": " `int i=1;\\n        if(x>=0 && x<1){`\\n           ` return 0;`\\n       ` }`\\n       ` else{`\\n           ` while (i <= x/i) {`\\n           ` i++;`\\n          `  }`\\n       ` }`\\n       ` return i-1;`\\n\\ncouldnt think of the binary search solution, this is what i was able to come up with"
                    },
                    {
                        "username": "thatsiddharth",
                        "content": "what if i directly do \\nclass Solution {\\n    public int mySqrt(int x) {\\n       return (int)Math.sqrt(x);\\n    }\\n}"
                    },
                    {
                        "username": "CyberMaestro",
                        "content": "return int(math.sqrt(x))"
                    },
                    {
                        "username": "akashshaw01",
                        "content": "hint - data type of mid will be long long beacause mid * mid be overflow the limit of the int.\\n\\n\\n\\nmy code - https://leetcode.com/problems/sqrtx/solutions/3216039/c-simple-binary-search-o-log-n-beginner-friendly/?orderBy=most_votes"
                    },
                    {
                        "username": "BachusPL",
                        "content": "Is this the simplest problem in Leetcode?"
                    },
                    {
                        "username": "kumarprashant82061",
                        "content": "class Solution {\\npublic:\\n    int mySqrt(int x) {\\n         if(x <= 1)\\n        return x;\\n\\n        return floor(sqrt(x));\\n    }\\n};"
                    },
                    {
                        "username": "Shankhadeep2017",
                        "content": "In Python Its very simple to solve, There is a in build function Import math \\njust used math.squer() and whats value return just convert into a integer .solved the problem.\\nexample:\\nimport math\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        ans = math.sqrt(x)\\n        return int(ans)\\n\\n"
                    },
                    {
                        "username": "Alex230103",
                        "content": "the whole point of this problem is to not use build in functions"
                    }
                ]
            },
            {
                "id": 1816537,
                "content": [
                    {
                        "username": "imsumit_17",
                        "content": "guys what problem we will get if we directly use sqrt function in c++ will it be considered as bad coding practice?"
                    },
                    {
                        "username": "radek4128",
                        "content": "If the description says that we can\\'t use any built-in exponent function, why submissions with them are accepted?"
                    },
                    {
                        "username": "Keremovsky",
                        "content": "don\\'t use mid = (first + last) / 2 for find middle value\\nuse mid = first + (last - first) / 2 so you don\\'t have to deal with 2147395600"
                    },
                    {
                        "username": "Sanjeevan-S",
                        "content": " `int i=1;\\n        if(x>=0 && x<1){`\\n           ` return 0;`\\n       ` }`\\n       ` else{`\\n           ` while (i <= x/i) {`\\n           ` i++;`\\n          `  }`\\n       ` }`\\n       ` return i-1;`\\n\\ncouldnt think of the binary search solution, this is what i was able to come up with"
                    },
                    {
                        "username": "thatsiddharth",
                        "content": "what if i directly do \\nclass Solution {\\n    public int mySqrt(int x) {\\n       return (int)Math.sqrt(x);\\n    }\\n}"
                    },
                    {
                        "username": "CyberMaestro",
                        "content": "return int(math.sqrt(x))"
                    },
                    {
                        "username": "akashshaw01",
                        "content": "hint - data type of mid will be long long beacause mid * mid be overflow the limit of the int.\\n\\n\\n\\nmy code - https://leetcode.com/problems/sqrtx/solutions/3216039/c-simple-binary-search-o-log-n-beginner-friendly/?orderBy=most_votes"
                    },
                    {
                        "username": "BachusPL",
                        "content": "Is this the simplest problem in Leetcode?"
                    },
                    {
                        "username": "kumarprashant82061",
                        "content": "class Solution {\\npublic:\\n    int mySqrt(int x) {\\n         if(x <= 1)\\n        return x;\\n\\n        return floor(sqrt(x));\\n    }\\n};"
                    },
                    {
                        "username": "Shankhadeep2017",
                        "content": "In Python Its very simple to solve, There is a in build function Import math \\njust used math.squer() and whats value return just convert into a integer .solved the problem.\\nexample:\\nimport math\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        ans = math.sqrt(x)\\n        return int(ans)\\n\\n"
                    },
                    {
                        "username": "Alex230103",
                        "content": "the whole point of this problem is to not use build in functions"
                    }
                ]
            },
            {
                "id": 1811160,
                "content": [
                    {
                        "username": "imsumit_17",
                        "content": "guys what problem we will get if we directly use sqrt function in c++ will it be considered as bad coding practice?"
                    },
                    {
                        "username": "radek4128",
                        "content": "If the description says that we can\\'t use any built-in exponent function, why submissions with them are accepted?"
                    },
                    {
                        "username": "Keremovsky",
                        "content": "don\\'t use mid = (first + last) / 2 for find middle value\\nuse mid = first + (last - first) / 2 so you don\\'t have to deal with 2147395600"
                    },
                    {
                        "username": "Sanjeevan-S",
                        "content": " `int i=1;\\n        if(x>=0 && x<1){`\\n           ` return 0;`\\n       ` }`\\n       ` else{`\\n           ` while (i <= x/i) {`\\n           ` i++;`\\n          `  }`\\n       ` }`\\n       ` return i-1;`\\n\\ncouldnt think of the binary search solution, this is what i was able to come up with"
                    },
                    {
                        "username": "thatsiddharth",
                        "content": "what if i directly do \\nclass Solution {\\n    public int mySqrt(int x) {\\n       return (int)Math.sqrt(x);\\n    }\\n}"
                    },
                    {
                        "username": "CyberMaestro",
                        "content": "return int(math.sqrt(x))"
                    },
                    {
                        "username": "akashshaw01",
                        "content": "hint - data type of mid will be long long beacause mid * mid be overflow the limit of the int.\\n\\n\\n\\nmy code - https://leetcode.com/problems/sqrtx/solutions/3216039/c-simple-binary-search-o-log-n-beginner-friendly/?orderBy=most_votes"
                    },
                    {
                        "username": "BachusPL",
                        "content": "Is this the simplest problem in Leetcode?"
                    },
                    {
                        "username": "kumarprashant82061",
                        "content": "class Solution {\\npublic:\\n    int mySqrt(int x) {\\n         if(x <= 1)\\n        return x;\\n\\n        return floor(sqrt(x));\\n    }\\n};"
                    },
                    {
                        "username": "Shankhadeep2017",
                        "content": "In Python Its very simple to solve, There is a in build function Import math \\njust used math.squer() and whats value return just convert into a integer .solved the problem.\\nexample:\\nimport math\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        ans = math.sqrt(x)\\n        return int(ans)\\n\\n"
                    },
                    {
                        "username": "Alex230103",
                        "content": "the whole point of this problem is to not use build in functions"
                    }
                ]
            },
            {
                "id": 1809886,
                "content": [
                    {
                        "username": "imsumit_17",
                        "content": "guys what problem we will get if we directly use sqrt function in c++ will it be considered as bad coding practice?"
                    },
                    {
                        "username": "radek4128",
                        "content": "If the description says that we can\\'t use any built-in exponent function, why submissions with them are accepted?"
                    },
                    {
                        "username": "Keremovsky",
                        "content": "don\\'t use mid = (first + last) / 2 for find middle value\\nuse mid = first + (last - first) / 2 so you don\\'t have to deal with 2147395600"
                    },
                    {
                        "username": "Sanjeevan-S",
                        "content": " `int i=1;\\n        if(x>=0 && x<1){`\\n           ` return 0;`\\n       ` }`\\n       ` else{`\\n           ` while (i <= x/i) {`\\n           ` i++;`\\n          `  }`\\n       ` }`\\n       ` return i-1;`\\n\\ncouldnt think of the binary search solution, this is what i was able to come up with"
                    },
                    {
                        "username": "thatsiddharth",
                        "content": "what if i directly do \\nclass Solution {\\n    public int mySqrt(int x) {\\n       return (int)Math.sqrt(x);\\n    }\\n}"
                    },
                    {
                        "username": "CyberMaestro",
                        "content": "return int(math.sqrt(x))"
                    },
                    {
                        "username": "akashshaw01",
                        "content": "hint - data type of mid will be long long beacause mid * mid be overflow the limit of the int.\\n\\n\\n\\nmy code - https://leetcode.com/problems/sqrtx/solutions/3216039/c-simple-binary-search-o-log-n-beginner-friendly/?orderBy=most_votes"
                    },
                    {
                        "username": "BachusPL",
                        "content": "Is this the simplest problem in Leetcode?"
                    },
                    {
                        "username": "kumarprashant82061",
                        "content": "class Solution {\\npublic:\\n    int mySqrt(int x) {\\n         if(x <= 1)\\n        return x;\\n\\n        return floor(sqrt(x));\\n    }\\n};"
                    },
                    {
                        "username": "Shankhadeep2017",
                        "content": "In Python Its very simple to solve, There is a in build function Import math \\njust used math.squer() and whats value return just convert into a integer .solved the problem.\\nexample:\\nimport math\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        ans = math.sqrt(x)\\n        return int(ans)\\n\\n"
                    },
                    {
                        "username": "Alex230103",
                        "content": "the whole point of this problem is to not use build in functions"
                    }
                ]
            },
            {
                "id": 1807248,
                "content": [
                    {
                        "username": "imsumit_17",
                        "content": "guys what problem we will get if we directly use sqrt function in c++ will it be considered as bad coding practice?"
                    },
                    {
                        "username": "radek4128",
                        "content": "If the description says that we can\\'t use any built-in exponent function, why submissions with them are accepted?"
                    },
                    {
                        "username": "Keremovsky",
                        "content": "don\\'t use mid = (first + last) / 2 for find middle value\\nuse mid = first + (last - first) / 2 so you don\\'t have to deal with 2147395600"
                    },
                    {
                        "username": "Sanjeevan-S",
                        "content": " `int i=1;\\n        if(x>=0 && x<1){`\\n           ` return 0;`\\n       ` }`\\n       ` else{`\\n           ` while (i <= x/i) {`\\n           ` i++;`\\n          `  }`\\n       ` }`\\n       ` return i-1;`\\n\\ncouldnt think of the binary search solution, this is what i was able to come up with"
                    },
                    {
                        "username": "thatsiddharth",
                        "content": "what if i directly do \\nclass Solution {\\n    public int mySqrt(int x) {\\n       return (int)Math.sqrt(x);\\n    }\\n}"
                    },
                    {
                        "username": "CyberMaestro",
                        "content": "return int(math.sqrt(x))"
                    },
                    {
                        "username": "akashshaw01",
                        "content": "hint - data type of mid will be long long beacause mid * mid be overflow the limit of the int.\\n\\n\\n\\nmy code - https://leetcode.com/problems/sqrtx/solutions/3216039/c-simple-binary-search-o-log-n-beginner-friendly/?orderBy=most_votes"
                    },
                    {
                        "username": "BachusPL",
                        "content": "Is this the simplest problem in Leetcode?"
                    },
                    {
                        "username": "kumarprashant82061",
                        "content": "class Solution {\\npublic:\\n    int mySqrt(int x) {\\n         if(x <= 1)\\n        return x;\\n\\n        return floor(sqrt(x));\\n    }\\n};"
                    },
                    {
                        "username": "Shankhadeep2017",
                        "content": "In Python Its very simple to solve, There is a in build function Import math \\njust used math.squer() and whats value return just convert into a integer .solved the problem.\\nexample:\\nimport math\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        ans = math.sqrt(x)\\n        return int(ans)\\n\\n"
                    },
                    {
                        "username": "Alex230103",
                        "content": "the whole point of this problem is to not use build in functions"
                    }
                ]
            },
            {
                "id": 1803248,
                "content": [
                    {
                        "username": "imsumit_17",
                        "content": "guys what problem we will get if we directly use sqrt function in c++ will it be considered as bad coding practice?"
                    },
                    {
                        "username": "radek4128",
                        "content": "If the description says that we can\\'t use any built-in exponent function, why submissions with them are accepted?"
                    },
                    {
                        "username": "Keremovsky",
                        "content": "don\\'t use mid = (first + last) / 2 for find middle value\\nuse mid = first + (last - first) / 2 so you don\\'t have to deal with 2147395600"
                    },
                    {
                        "username": "Sanjeevan-S",
                        "content": " `int i=1;\\n        if(x>=0 && x<1){`\\n           ` return 0;`\\n       ` }`\\n       ` else{`\\n           ` while (i <= x/i) {`\\n           ` i++;`\\n          `  }`\\n       ` }`\\n       ` return i-1;`\\n\\ncouldnt think of the binary search solution, this is what i was able to come up with"
                    },
                    {
                        "username": "thatsiddharth",
                        "content": "what if i directly do \\nclass Solution {\\n    public int mySqrt(int x) {\\n       return (int)Math.sqrt(x);\\n    }\\n}"
                    },
                    {
                        "username": "CyberMaestro",
                        "content": "return int(math.sqrt(x))"
                    },
                    {
                        "username": "akashshaw01",
                        "content": "hint - data type of mid will be long long beacause mid * mid be overflow the limit of the int.\\n\\n\\n\\nmy code - https://leetcode.com/problems/sqrtx/solutions/3216039/c-simple-binary-search-o-log-n-beginner-friendly/?orderBy=most_votes"
                    },
                    {
                        "username": "BachusPL",
                        "content": "Is this the simplest problem in Leetcode?"
                    },
                    {
                        "username": "kumarprashant82061",
                        "content": "class Solution {\\npublic:\\n    int mySqrt(int x) {\\n         if(x <= 1)\\n        return x;\\n\\n        return floor(sqrt(x));\\n    }\\n};"
                    },
                    {
                        "username": "Shankhadeep2017",
                        "content": "In Python Its very simple to solve, There is a in build function Import math \\njust used math.squer() and whats value return just convert into a integer .solved the problem.\\nexample:\\nimport math\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        ans = math.sqrt(x)\\n        return int(ans)\\n\\n"
                    },
                    {
                        "username": "Alex230103",
                        "content": "the whole point of this problem is to not use build in functions"
                    }
                ]
            },
            {
                "id": 1793886,
                "content": [
                    {
                        "username": "imsumit_17",
                        "content": "guys what problem we will get if we directly use sqrt function in c++ will it be considered as bad coding practice?"
                    },
                    {
                        "username": "radek4128",
                        "content": "If the description says that we can\\'t use any built-in exponent function, why submissions with them are accepted?"
                    },
                    {
                        "username": "Keremovsky",
                        "content": "don\\'t use mid = (first + last) / 2 for find middle value\\nuse mid = first + (last - first) / 2 so you don\\'t have to deal with 2147395600"
                    },
                    {
                        "username": "Sanjeevan-S",
                        "content": " `int i=1;\\n        if(x>=0 && x<1){`\\n           ` return 0;`\\n       ` }`\\n       ` else{`\\n           ` while (i <= x/i) {`\\n           ` i++;`\\n          `  }`\\n       ` }`\\n       ` return i-1;`\\n\\ncouldnt think of the binary search solution, this is what i was able to come up with"
                    },
                    {
                        "username": "thatsiddharth",
                        "content": "what if i directly do \\nclass Solution {\\n    public int mySqrt(int x) {\\n       return (int)Math.sqrt(x);\\n    }\\n}"
                    },
                    {
                        "username": "CyberMaestro",
                        "content": "return int(math.sqrt(x))"
                    },
                    {
                        "username": "akashshaw01",
                        "content": "hint - data type of mid will be long long beacause mid * mid be overflow the limit of the int.\\n\\n\\n\\nmy code - https://leetcode.com/problems/sqrtx/solutions/3216039/c-simple-binary-search-o-log-n-beginner-friendly/?orderBy=most_votes"
                    },
                    {
                        "username": "BachusPL",
                        "content": "Is this the simplest problem in Leetcode?"
                    },
                    {
                        "username": "kumarprashant82061",
                        "content": "class Solution {\\npublic:\\n    int mySqrt(int x) {\\n         if(x <= 1)\\n        return x;\\n\\n        return floor(sqrt(x));\\n    }\\n};"
                    },
                    {
                        "username": "Shankhadeep2017",
                        "content": "In Python Its very simple to solve, There is a in build function Import math \\njust used math.squer() and whats value return just convert into a integer .solved the problem.\\nexample:\\nimport math\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        ans = math.sqrt(x)\\n        return int(ans)\\n\\n"
                    },
                    {
                        "username": "Alex230103",
                        "content": "the whole point of this problem is to not use build in functions"
                    }
                ]
            },
            {
                "id": 1792889,
                "content": [
                    {
                        "username": "rishavm",
                        "content": "Solution which has time complexity of O(1). have used built-in functions which clearly mentioned in the problem description not allowed.\\nStill they are getting accepted and being ranked at the top."
                    },
                    {
                        "username": "snowden1007",
                        "content": "class Solution {\npublic:\n    int mySqrt(int x) {\n\n        int ans = pow(x , 0.5);\n        return ans;\n        \n    }\n};"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "can anyone give me through explanation why this code worked for long but not for int (It is humble request ,  don\\'t use very professional words please keep the explanation simple) "
                    },
                    {
                        "username": "landong",
                        "content": "you are using python or python3? long is no longer supported in python3"
                    },
                    {
                        "username": "RaikotaPavansai",
                        "content": "it is showing time limit exceeded what this mean?\\n"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I found a math way to make this calculation. It is not the best but it works well. It is based on this farmula\n1 + 3 + 5 + 7 + 9 +  + (2n  1) = n\n\n def mySqrt(self, x: int) -> int:\n        num = 1\n        counter = 0\n        while num <= x:\n            x = x - num\n            num = num + 2\n            counter = counter+1\n        return counter"
                    },
                    {
                        "username": "Satyam_Singh_01",
                        "content": "I am new at leetcode and whenever i run my code \" error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) { \" this compilation error pops up. Can someone please tell me what am I doing wrong.\\n"
                    },
                    {
                        "username": "mdude",
                        "content": "Using Binary Search solution\\nAll the provided solutions assume that `if(mid * mid < x) start = mid + 1`\\nWhat if the input was `x = 8`, then we could by mistake skip the 2 as `2 * 2 < 8` and the new start will be 3\\nSo shouldn\\'t it be `start = mid` ?"
                    },
                    {
                        "username": "shru20",
                        "content": "class Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x==0:\\n            return 0\\n        n=1\\n        while n**2<=x:\\n            n+=1\\n        return n-1\\n"
                    },
                    {
                        "username": "Aman3107",
                        "content": "Simplest solution is here.........\n\n\n     \n        int count=0;\n        for(int i=1;i<=x;i+=2){\n            x=x-i;\n            count++;\n        }\n        return count;\n\n"
                    },
                    {
                        "username": "omsky8",
                        "content": "[@brbamcoding](/brbamcoding) it is O(log N) as the we are not traversing till n. The value of x is getting reduced and also the step size is 2 for i."
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This is not O(log N), is it?"
                    },
                    {
                        "username": "liqingzhao",
                        "content": "if you use x * x  to compare,it will result it integer overflow.So the right way is to use x / mid or (long) mid * mid"
                    }
                ]
            },
            {
                "id": 1786950,
                "content": [
                    {
                        "username": "rishavm",
                        "content": "Solution which has time complexity of O(1). have used built-in functions which clearly mentioned in the problem description not allowed.\\nStill they are getting accepted and being ranked at the top."
                    },
                    {
                        "username": "snowden1007",
                        "content": "class Solution {\npublic:\n    int mySqrt(int x) {\n\n        int ans = pow(x , 0.5);\n        return ans;\n        \n    }\n};"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "can anyone give me through explanation why this code worked for long but not for int (It is humble request ,  don\\'t use very professional words please keep the explanation simple) "
                    },
                    {
                        "username": "landong",
                        "content": "you are using python or python3? long is no longer supported in python3"
                    },
                    {
                        "username": "RaikotaPavansai",
                        "content": "it is showing time limit exceeded what this mean?\\n"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I found a math way to make this calculation. It is not the best but it works well. It is based on this farmula\n1 + 3 + 5 + 7 + 9 +  + (2n  1) = n\n\n def mySqrt(self, x: int) -> int:\n        num = 1\n        counter = 0\n        while num <= x:\n            x = x - num\n            num = num + 2\n            counter = counter+1\n        return counter"
                    },
                    {
                        "username": "Satyam_Singh_01",
                        "content": "I am new at leetcode and whenever i run my code \" error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) { \" this compilation error pops up. Can someone please tell me what am I doing wrong.\\n"
                    },
                    {
                        "username": "mdude",
                        "content": "Using Binary Search solution\\nAll the provided solutions assume that `if(mid * mid < x) start = mid + 1`\\nWhat if the input was `x = 8`, then we could by mistake skip the 2 as `2 * 2 < 8` and the new start will be 3\\nSo shouldn\\'t it be `start = mid` ?"
                    },
                    {
                        "username": "shru20",
                        "content": "class Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x==0:\\n            return 0\\n        n=1\\n        while n**2<=x:\\n            n+=1\\n        return n-1\\n"
                    },
                    {
                        "username": "Aman3107",
                        "content": "Simplest solution is here.........\n\n\n     \n        int count=0;\n        for(int i=1;i<=x;i+=2){\n            x=x-i;\n            count++;\n        }\n        return count;\n\n"
                    },
                    {
                        "username": "omsky8",
                        "content": "[@brbamcoding](/brbamcoding) it is O(log N) as the we are not traversing till n. The value of x is getting reduced and also the step size is 2 for i."
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This is not O(log N), is it?"
                    },
                    {
                        "username": "liqingzhao",
                        "content": "if you use x * x  to compare,it will result it integer overflow.So the right way is to use x / mid or (long) mid * mid"
                    }
                ]
            },
            {
                "id": 1785206,
                "content": [
                    {
                        "username": "rishavm",
                        "content": "Solution which has time complexity of O(1). have used built-in functions which clearly mentioned in the problem description not allowed.\\nStill they are getting accepted and being ranked at the top."
                    },
                    {
                        "username": "snowden1007",
                        "content": "class Solution {\npublic:\n    int mySqrt(int x) {\n\n        int ans = pow(x , 0.5);\n        return ans;\n        \n    }\n};"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "can anyone give me through explanation why this code worked for long but not for int (It is humble request ,  don\\'t use very professional words please keep the explanation simple) "
                    },
                    {
                        "username": "landong",
                        "content": "you are using python or python3? long is no longer supported in python3"
                    },
                    {
                        "username": "RaikotaPavansai",
                        "content": "it is showing time limit exceeded what this mean?\\n"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I found a math way to make this calculation. It is not the best but it works well. It is based on this farmula\n1 + 3 + 5 + 7 + 9 +  + (2n  1) = n\n\n def mySqrt(self, x: int) -> int:\n        num = 1\n        counter = 0\n        while num <= x:\n            x = x - num\n            num = num + 2\n            counter = counter+1\n        return counter"
                    },
                    {
                        "username": "Satyam_Singh_01",
                        "content": "I am new at leetcode and whenever i run my code \" error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) { \" this compilation error pops up. Can someone please tell me what am I doing wrong.\\n"
                    },
                    {
                        "username": "mdude",
                        "content": "Using Binary Search solution\\nAll the provided solutions assume that `if(mid * mid < x) start = mid + 1`\\nWhat if the input was `x = 8`, then we could by mistake skip the 2 as `2 * 2 < 8` and the new start will be 3\\nSo shouldn\\'t it be `start = mid` ?"
                    },
                    {
                        "username": "shru20",
                        "content": "class Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x==0:\\n            return 0\\n        n=1\\n        while n**2<=x:\\n            n+=1\\n        return n-1\\n"
                    },
                    {
                        "username": "Aman3107",
                        "content": "Simplest solution is here.........\n\n\n     \n        int count=0;\n        for(int i=1;i<=x;i+=2){\n            x=x-i;\n            count++;\n        }\n        return count;\n\n"
                    },
                    {
                        "username": "omsky8",
                        "content": "[@brbamcoding](/brbamcoding) it is O(log N) as the we are not traversing till n. The value of x is getting reduced and also the step size is 2 for i."
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This is not O(log N), is it?"
                    },
                    {
                        "username": "liqingzhao",
                        "content": "if you use x * x  to compare,it will result it integer overflow.So the right way is to use x / mid or (long) mid * mid"
                    }
                ]
            },
            {
                "id": 1782936,
                "content": [
                    {
                        "username": "rishavm",
                        "content": "Solution which has time complexity of O(1). have used built-in functions which clearly mentioned in the problem description not allowed.\\nStill they are getting accepted and being ranked at the top."
                    },
                    {
                        "username": "snowden1007",
                        "content": "class Solution {\npublic:\n    int mySqrt(int x) {\n\n        int ans = pow(x , 0.5);\n        return ans;\n        \n    }\n};"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "can anyone give me through explanation why this code worked for long but not for int (It is humble request ,  don\\'t use very professional words please keep the explanation simple) "
                    },
                    {
                        "username": "landong",
                        "content": "you are using python or python3? long is no longer supported in python3"
                    },
                    {
                        "username": "RaikotaPavansai",
                        "content": "it is showing time limit exceeded what this mean?\\n"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I found a math way to make this calculation. It is not the best but it works well. It is based on this farmula\n1 + 3 + 5 + 7 + 9 +  + (2n  1) = n\n\n def mySqrt(self, x: int) -> int:\n        num = 1\n        counter = 0\n        while num <= x:\n            x = x - num\n            num = num + 2\n            counter = counter+1\n        return counter"
                    },
                    {
                        "username": "Satyam_Singh_01",
                        "content": "I am new at leetcode and whenever i run my code \" error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) { \" this compilation error pops up. Can someone please tell me what am I doing wrong.\\n"
                    },
                    {
                        "username": "mdude",
                        "content": "Using Binary Search solution\\nAll the provided solutions assume that `if(mid * mid < x) start = mid + 1`\\nWhat if the input was `x = 8`, then we could by mistake skip the 2 as `2 * 2 < 8` and the new start will be 3\\nSo shouldn\\'t it be `start = mid` ?"
                    },
                    {
                        "username": "shru20",
                        "content": "class Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x==0:\\n            return 0\\n        n=1\\n        while n**2<=x:\\n            n+=1\\n        return n-1\\n"
                    },
                    {
                        "username": "Aman3107",
                        "content": "Simplest solution is here.........\n\n\n     \n        int count=0;\n        for(int i=1;i<=x;i+=2){\n            x=x-i;\n            count++;\n        }\n        return count;\n\n"
                    },
                    {
                        "username": "omsky8",
                        "content": "[@brbamcoding](/brbamcoding) it is O(log N) as the we are not traversing till n. The value of x is getting reduced and also the step size is 2 for i."
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This is not O(log N), is it?"
                    },
                    {
                        "username": "liqingzhao",
                        "content": "if you use x * x  to compare,it will result it integer overflow.So the right way is to use x / mid or (long) mid * mid"
                    }
                ]
            },
            {
                "id": 1782173,
                "content": [
                    {
                        "username": "rishavm",
                        "content": "Solution which has time complexity of O(1). have used built-in functions which clearly mentioned in the problem description not allowed.\\nStill they are getting accepted and being ranked at the top."
                    },
                    {
                        "username": "snowden1007",
                        "content": "class Solution {\npublic:\n    int mySqrt(int x) {\n\n        int ans = pow(x , 0.5);\n        return ans;\n        \n    }\n};"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "can anyone give me through explanation why this code worked for long but not for int (It is humble request ,  don\\'t use very professional words please keep the explanation simple) "
                    },
                    {
                        "username": "landong",
                        "content": "you are using python or python3? long is no longer supported in python3"
                    },
                    {
                        "username": "RaikotaPavansai",
                        "content": "it is showing time limit exceeded what this mean?\\n"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I found a math way to make this calculation. It is not the best but it works well. It is based on this farmula\n1 + 3 + 5 + 7 + 9 +  + (2n  1) = n\n\n def mySqrt(self, x: int) -> int:\n        num = 1\n        counter = 0\n        while num <= x:\n            x = x - num\n            num = num + 2\n            counter = counter+1\n        return counter"
                    },
                    {
                        "username": "Satyam_Singh_01",
                        "content": "I am new at leetcode and whenever i run my code \" error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) { \" this compilation error pops up. Can someone please tell me what am I doing wrong.\\n"
                    },
                    {
                        "username": "mdude",
                        "content": "Using Binary Search solution\\nAll the provided solutions assume that `if(mid * mid < x) start = mid + 1`\\nWhat if the input was `x = 8`, then we could by mistake skip the 2 as `2 * 2 < 8` and the new start will be 3\\nSo shouldn\\'t it be `start = mid` ?"
                    },
                    {
                        "username": "shru20",
                        "content": "class Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x==0:\\n            return 0\\n        n=1\\n        while n**2<=x:\\n            n+=1\\n        return n-1\\n"
                    },
                    {
                        "username": "Aman3107",
                        "content": "Simplest solution is here.........\n\n\n     \n        int count=0;\n        for(int i=1;i<=x;i+=2){\n            x=x-i;\n            count++;\n        }\n        return count;\n\n"
                    },
                    {
                        "username": "omsky8",
                        "content": "[@brbamcoding](/brbamcoding) it is O(log N) as the we are not traversing till n. The value of x is getting reduced and also the step size is 2 for i."
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This is not O(log N), is it?"
                    },
                    {
                        "username": "liqingzhao",
                        "content": "if you use x * x  to compare,it will result it integer overflow.So the right way is to use x / mid or (long) mid * mid"
                    }
                ]
            },
            {
                "id": 1772992,
                "content": [
                    {
                        "username": "rishavm",
                        "content": "Solution which has time complexity of O(1). have used built-in functions which clearly mentioned in the problem description not allowed.\\nStill they are getting accepted and being ranked at the top."
                    },
                    {
                        "username": "snowden1007",
                        "content": "class Solution {\npublic:\n    int mySqrt(int x) {\n\n        int ans = pow(x , 0.5);\n        return ans;\n        \n    }\n};"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "can anyone give me through explanation why this code worked for long but not for int (It is humble request ,  don\\'t use very professional words please keep the explanation simple) "
                    },
                    {
                        "username": "landong",
                        "content": "you are using python or python3? long is no longer supported in python3"
                    },
                    {
                        "username": "RaikotaPavansai",
                        "content": "it is showing time limit exceeded what this mean?\\n"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I found a math way to make this calculation. It is not the best but it works well. It is based on this farmula\n1 + 3 + 5 + 7 + 9 +  + (2n  1) = n\n\n def mySqrt(self, x: int) -> int:\n        num = 1\n        counter = 0\n        while num <= x:\n            x = x - num\n            num = num + 2\n            counter = counter+1\n        return counter"
                    },
                    {
                        "username": "Satyam_Singh_01",
                        "content": "I am new at leetcode and whenever i run my code \" error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) { \" this compilation error pops up. Can someone please tell me what am I doing wrong.\\n"
                    },
                    {
                        "username": "mdude",
                        "content": "Using Binary Search solution\\nAll the provided solutions assume that `if(mid * mid < x) start = mid + 1`\\nWhat if the input was `x = 8`, then we could by mistake skip the 2 as `2 * 2 < 8` and the new start will be 3\\nSo shouldn\\'t it be `start = mid` ?"
                    },
                    {
                        "username": "shru20",
                        "content": "class Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x==0:\\n            return 0\\n        n=1\\n        while n**2<=x:\\n            n+=1\\n        return n-1\\n"
                    },
                    {
                        "username": "Aman3107",
                        "content": "Simplest solution is here.........\n\n\n     \n        int count=0;\n        for(int i=1;i<=x;i+=2){\n            x=x-i;\n            count++;\n        }\n        return count;\n\n"
                    },
                    {
                        "username": "omsky8",
                        "content": "[@brbamcoding](/brbamcoding) it is O(log N) as the we are not traversing till n. The value of x is getting reduced and also the step size is 2 for i."
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This is not O(log N), is it?"
                    },
                    {
                        "username": "liqingzhao",
                        "content": "if you use x * x  to compare,it will result it integer overflow.So the right way is to use x / mid or (long) mid * mid"
                    }
                ]
            },
            {
                "id": 1760907,
                "content": [
                    {
                        "username": "rishavm",
                        "content": "Solution which has time complexity of O(1). have used built-in functions which clearly mentioned in the problem description not allowed.\\nStill they are getting accepted and being ranked at the top."
                    },
                    {
                        "username": "snowden1007",
                        "content": "class Solution {\npublic:\n    int mySqrt(int x) {\n\n        int ans = pow(x , 0.5);\n        return ans;\n        \n    }\n};"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "can anyone give me through explanation why this code worked for long but not for int (It is humble request ,  don\\'t use very professional words please keep the explanation simple) "
                    },
                    {
                        "username": "landong",
                        "content": "you are using python or python3? long is no longer supported in python3"
                    },
                    {
                        "username": "RaikotaPavansai",
                        "content": "it is showing time limit exceeded what this mean?\\n"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I found a math way to make this calculation. It is not the best but it works well. It is based on this farmula\n1 + 3 + 5 + 7 + 9 +  + (2n  1) = n\n\n def mySqrt(self, x: int) -> int:\n        num = 1\n        counter = 0\n        while num <= x:\n            x = x - num\n            num = num + 2\n            counter = counter+1\n        return counter"
                    },
                    {
                        "username": "Satyam_Singh_01",
                        "content": "I am new at leetcode and whenever i run my code \" error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) { \" this compilation error pops up. Can someone please tell me what am I doing wrong.\\n"
                    },
                    {
                        "username": "mdude",
                        "content": "Using Binary Search solution\\nAll the provided solutions assume that `if(mid * mid < x) start = mid + 1`\\nWhat if the input was `x = 8`, then we could by mistake skip the 2 as `2 * 2 < 8` and the new start will be 3\\nSo shouldn\\'t it be `start = mid` ?"
                    },
                    {
                        "username": "shru20",
                        "content": "class Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x==0:\\n            return 0\\n        n=1\\n        while n**2<=x:\\n            n+=1\\n        return n-1\\n"
                    },
                    {
                        "username": "Aman3107",
                        "content": "Simplest solution is here.........\n\n\n     \n        int count=0;\n        for(int i=1;i<=x;i+=2){\n            x=x-i;\n            count++;\n        }\n        return count;\n\n"
                    },
                    {
                        "username": "omsky8",
                        "content": "[@brbamcoding](/brbamcoding) it is O(log N) as the we are not traversing till n. The value of x is getting reduced and also the step size is 2 for i."
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This is not O(log N), is it?"
                    },
                    {
                        "username": "liqingzhao",
                        "content": "if you use x * x  to compare,it will result it integer overflow.So the right way is to use x / mid or (long) mid * mid"
                    }
                ]
            },
            {
                "id": 1757994,
                "content": [
                    {
                        "username": "rishavm",
                        "content": "Solution which has time complexity of O(1). have used built-in functions which clearly mentioned in the problem description not allowed.\\nStill they are getting accepted and being ranked at the top."
                    },
                    {
                        "username": "snowden1007",
                        "content": "class Solution {\npublic:\n    int mySqrt(int x) {\n\n        int ans = pow(x , 0.5);\n        return ans;\n        \n    }\n};"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "can anyone give me through explanation why this code worked for long but not for int (It is humble request ,  don\\'t use very professional words please keep the explanation simple) "
                    },
                    {
                        "username": "landong",
                        "content": "you are using python or python3? long is no longer supported in python3"
                    },
                    {
                        "username": "RaikotaPavansai",
                        "content": "it is showing time limit exceeded what this mean?\\n"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I found a math way to make this calculation. It is not the best but it works well. It is based on this farmula\n1 + 3 + 5 + 7 + 9 +  + (2n  1) = n\n\n def mySqrt(self, x: int) -> int:\n        num = 1\n        counter = 0\n        while num <= x:\n            x = x - num\n            num = num + 2\n            counter = counter+1\n        return counter"
                    },
                    {
                        "username": "Satyam_Singh_01",
                        "content": "I am new at leetcode and whenever i run my code \" error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) { \" this compilation error pops up. Can someone please tell me what am I doing wrong.\\n"
                    },
                    {
                        "username": "mdude",
                        "content": "Using Binary Search solution\\nAll the provided solutions assume that `if(mid * mid < x) start = mid + 1`\\nWhat if the input was `x = 8`, then we could by mistake skip the 2 as `2 * 2 < 8` and the new start will be 3\\nSo shouldn\\'t it be `start = mid` ?"
                    },
                    {
                        "username": "shru20",
                        "content": "class Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x==0:\\n            return 0\\n        n=1\\n        while n**2<=x:\\n            n+=1\\n        return n-1\\n"
                    },
                    {
                        "username": "Aman3107",
                        "content": "Simplest solution is here.........\n\n\n     \n        int count=0;\n        for(int i=1;i<=x;i+=2){\n            x=x-i;\n            count++;\n        }\n        return count;\n\n"
                    },
                    {
                        "username": "omsky8",
                        "content": "[@brbamcoding](/brbamcoding) it is O(log N) as the we are not traversing till n. The value of x is getting reduced and also the step size is 2 for i."
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This is not O(log N), is it?"
                    },
                    {
                        "username": "liqingzhao",
                        "content": "if you use x * x  to compare,it will result it integer overflow.So the right way is to use x / mid or (long) mid * mid"
                    }
                ]
            },
            {
                "id": 1756312,
                "content": [
                    {
                        "username": "rishavm",
                        "content": "Solution which has time complexity of O(1). have used built-in functions which clearly mentioned in the problem description not allowed.\\nStill they are getting accepted and being ranked at the top."
                    },
                    {
                        "username": "snowden1007",
                        "content": "class Solution {\npublic:\n    int mySqrt(int x) {\n\n        int ans = pow(x , 0.5);\n        return ans;\n        \n    }\n};"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "can anyone give me through explanation why this code worked for long but not for int (It is humble request ,  don\\'t use very professional words please keep the explanation simple) "
                    },
                    {
                        "username": "landong",
                        "content": "you are using python or python3? long is no longer supported in python3"
                    },
                    {
                        "username": "RaikotaPavansai",
                        "content": "it is showing time limit exceeded what this mean?\\n"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I found a math way to make this calculation. It is not the best but it works well. It is based on this farmula\n1 + 3 + 5 + 7 + 9 +  + (2n  1) = n\n\n def mySqrt(self, x: int) -> int:\n        num = 1\n        counter = 0\n        while num <= x:\n            x = x - num\n            num = num + 2\n            counter = counter+1\n        return counter"
                    },
                    {
                        "username": "Satyam_Singh_01",
                        "content": "I am new at leetcode and whenever i run my code \" error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) { \" this compilation error pops up. Can someone please tell me what am I doing wrong.\\n"
                    },
                    {
                        "username": "mdude",
                        "content": "Using Binary Search solution\\nAll the provided solutions assume that `if(mid * mid < x) start = mid + 1`\\nWhat if the input was `x = 8`, then we could by mistake skip the 2 as `2 * 2 < 8` and the new start will be 3\\nSo shouldn\\'t it be `start = mid` ?"
                    },
                    {
                        "username": "shru20",
                        "content": "class Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x==0:\\n            return 0\\n        n=1\\n        while n**2<=x:\\n            n+=1\\n        return n-1\\n"
                    },
                    {
                        "username": "Aman3107",
                        "content": "Simplest solution is here.........\n\n\n     \n        int count=0;\n        for(int i=1;i<=x;i+=2){\n            x=x-i;\n            count++;\n        }\n        return count;\n\n"
                    },
                    {
                        "username": "omsky8",
                        "content": "[@brbamcoding](/brbamcoding) it is O(log N) as the we are not traversing till n. The value of x is getting reduced and also the step size is 2 for i."
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This is not O(log N), is it?"
                    },
                    {
                        "username": "liqingzhao",
                        "content": "if you use x * x  to compare,it will result it integer overflow.So the right way is to use x / mid or (long) mid * mid"
                    }
                ]
            },
            {
                "id": 1752384,
                "content": [
                    {
                        "username": "rishavm",
                        "content": "Solution which has time complexity of O(1). have used built-in functions which clearly mentioned in the problem description not allowed.\\nStill they are getting accepted and being ranked at the top."
                    },
                    {
                        "username": "snowden1007",
                        "content": "class Solution {\npublic:\n    int mySqrt(int x) {\n\n        int ans = pow(x , 0.5);\n        return ans;\n        \n    }\n};"
                    },
                    {
                        "username": "SurajXXh",
                        "content": "can anyone give me through explanation why this code worked for long but not for int (It is humble request ,  don\\'t use very professional words please keep the explanation simple) "
                    },
                    {
                        "username": "landong",
                        "content": "you are using python or python3? long is no longer supported in python3"
                    },
                    {
                        "username": "RaikotaPavansai",
                        "content": "it is showing time limit exceeded what this mean?\\n"
                    },
                    {
                        "username": "aydin_akbuga",
                        "content": "I found a math way to make this calculation. It is not the best but it works well. It is based on this farmula\n1 + 3 + 5 + 7 + 9 +  + (2n  1) = n\n\n def mySqrt(self, x: int) -> int:\n        num = 1\n        counter = 0\n        while num <= x:\n            x = x - num\n            num = num + 2\n            counter = counter+1\n        return counter"
                    },
                    {
                        "username": "Satyam_Singh_01",
                        "content": "I am new at leetcode and whenever i run my code \" error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) { \" this compilation error pops up. Can someone please tell me what am I doing wrong.\\n"
                    },
                    {
                        "username": "mdude",
                        "content": "Using Binary Search solution\\nAll the provided solutions assume that `if(mid * mid < x) start = mid + 1`\\nWhat if the input was `x = 8`, then we could by mistake skip the 2 as `2 * 2 < 8` and the new start will be 3\\nSo shouldn\\'t it be `start = mid` ?"
                    },
                    {
                        "username": "shru20",
                        "content": "class Solution:\\n    def mySqrt(self, x: int) -> int:\\n        if x==0:\\n            return 0\\n        n=1\\n        while n**2<=x:\\n            n+=1\\n        return n-1\\n"
                    },
                    {
                        "username": "Aman3107",
                        "content": "Simplest solution is here.........\n\n\n     \n        int count=0;\n        for(int i=1;i<=x;i+=2){\n            x=x-i;\n            count++;\n        }\n        return count;\n\n"
                    },
                    {
                        "username": "omsky8",
                        "content": "[@brbamcoding](/brbamcoding) it is O(log N) as the we are not traversing till n. The value of x is getting reduced and also the step size is 2 for i."
                    },
                    {
                        "username": "brbamcoding",
                        "content": "This is not O(log N), is it?"
                    },
                    {
                        "username": "liqingzhao",
                        "content": "if you use x * x  to compare,it will result it integer overflow.So the right way is to use x / mid or (long) mid * mid"
                    }
                ]
            },
            {
                "id": 1744286,
                "content": [
                    {
                        "username": "AjayUpadhyay",
                        "content": "why  mid * mid is overflowing we are not storing the mid * mid we are just comparing it with x then also why overflow is occuring ? anyone"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "It should get stored somewhere in memory to hold good for the comparison. This is probably why it happens eve n if we explicitly don\\'t allot a variable for it."
                    },
                    {
                        "username": "AjayUpadhyay",
                        "content": "why  mid*mid is overflowing we are not storing the mid*mid anywhere  we are just comparing it with x then also why overflow is occuring ? anyone"
                    },
                    {
                        "username": "avishekgop5833",
                        "content": " `class Solution {\\n    public int mySqrt(int x) {\\n         long y = 0 ;\\n        while(y*y<=x)y++;\\n        return y-1.0;\\n    }\\n}`\\n\\nLine 5: error: incompatible types: possible lossy conversion from double to int\\n        return y-1.0;  plz help me"
                    },
                    {
                        "username": "Preadator_Dp",
                        "content": "one line code\\n#include<bits/stdc++.h>\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n       int ans =sqrt(x);\\n       return ans;\\n    }\\n};"
                    },
                    {
                        "username": "psrij",
                        "content": "return pow(x,0.5);   \nQuick and easy c++ solution\nis there any other solution other that this \nif yes then pls reply"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "ParagBagga",
                        "content": "public class Solution {\\n    public int MySqrt(int x) {\\n         int low = 1;\\n            int high = x;\\n            int mid = (low + high) / 2;\\n\\n            while (low <= high)\\n            {\\n                if (mid  > x/mid)\\n                {\\n                    high = mid - 1;\\n                    mid = (low + high) / 2;\\n                }\\n                else if (mid < x/mid)\\n                {\\n                    low = mid + 1;\\n                    mid = (low + high) / 2;\\n                }\\n                else if (mid == x/mid)\\n                {\\n                    return mid;\\n                }\\n            }\\n\\n            return high;\\n    }\\n}"
                    },
                    {
                        "username": "aritrabasu2002",
                        "content": "#include<iostream>\\n#include<cmath>\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        double result;\\n        result=pow(x,0.5);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "omuksa007",
                        "content": "why it gives o/p of 0 for i/p of 4?\\nplease tell me.....\\n\\n int mySqrt(int x) {\\n        if(x==1){\\n            return 1;\\n        }\\n        for(int i=1;i<x/2;i++){\\n            if((i*i) == x){\\n                return i;\\n            }\\n            else if((i+1)*(i+1)>x && (i*i) < x){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "Abu_Daud",
                        "content": "using math formula \\nWe can consider mathematical term (\\u221Ax-\\u221Ax)2  = 0.\\nReplacing one of the \\u221Ax\\u2018s with y, then the equation becomes (y-\\u221Ax)2 => y2 \\u2013 2y\\u221Ax + x = 0\\n=> \\u221Ax = (y2 + x) / 2y\\n=> \\u221Ax = (y + x/y) / 2"
                    }
                ]
            },
            {
                "id": 1744285,
                "content": [
                    {
                        "username": "AjayUpadhyay",
                        "content": "why  mid * mid is overflowing we are not storing the mid * mid we are just comparing it with x then also why overflow is occuring ? anyone"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "It should get stored somewhere in memory to hold good for the comparison. This is probably why it happens eve n if we explicitly don\\'t allot a variable for it."
                    },
                    {
                        "username": "AjayUpadhyay",
                        "content": "why  mid*mid is overflowing we are not storing the mid*mid anywhere  we are just comparing it with x then also why overflow is occuring ? anyone"
                    },
                    {
                        "username": "avishekgop5833",
                        "content": " `class Solution {\\n    public int mySqrt(int x) {\\n         long y = 0 ;\\n        while(y*y<=x)y++;\\n        return y-1.0;\\n    }\\n}`\\n\\nLine 5: error: incompatible types: possible lossy conversion from double to int\\n        return y-1.0;  plz help me"
                    },
                    {
                        "username": "Preadator_Dp",
                        "content": "one line code\\n#include<bits/stdc++.h>\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n       int ans =sqrt(x);\\n       return ans;\\n    }\\n};"
                    },
                    {
                        "username": "psrij",
                        "content": "return pow(x,0.5);   \nQuick and easy c++ solution\nis there any other solution other that this \nif yes then pls reply"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "ParagBagga",
                        "content": "public class Solution {\\n    public int MySqrt(int x) {\\n         int low = 1;\\n            int high = x;\\n            int mid = (low + high) / 2;\\n\\n            while (low <= high)\\n            {\\n                if (mid  > x/mid)\\n                {\\n                    high = mid - 1;\\n                    mid = (low + high) / 2;\\n                }\\n                else if (mid < x/mid)\\n                {\\n                    low = mid + 1;\\n                    mid = (low + high) / 2;\\n                }\\n                else if (mid == x/mid)\\n                {\\n                    return mid;\\n                }\\n            }\\n\\n            return high;\\n    }\\n}"
                    },
                    {
                        "username": "aritrabasu2002",
                        "content": "#include<iostream>\\n#include<cmath>\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        double result;\\n        result=pow(x,0.5);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "omuksa007",
                        "content": "why it gives o/p of 0 for i/p of 4?\\nplease tell me.....\\n\\n int mySqrt(int x) {\\n        if(x==1){\\n            return 1;\\n        }\\n        for(int i=1;i<x/2;i++){\\n            if((i*i) == x){\\n                return i;\\n            }\\n            else if((i+1)*(i+1)>x && (i*i) < x){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "Abu_Daud",
                        "content": "using math formula \\nWe can consider mathematical term (\\u221Ax-\\u221Ax)2  = 0.\\nReplacing one of the \\u221Ax\\u2018s with y, then the equation becomes (y-\\u221Ax)2 => y2 \\u2013 2y\\u221Ax + x = 0\\n=> \\u221Ax = (y2 + x) / 2y\\n=> \\u221Ax = (y + x/y) / 2"
                    }
                ]
            },
            {
                "id": 1740811,
                "content": [
                    {
                        "username": "AjayUpadhyay",
                        "content": "why  mid * mid is overflowing we are not storing the mid * mid we are just comparing it with x then also why overflow is occuring ? anyone"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "It should get stored somewhere in memory to hold good for the comparison. This is probably why it happens eve n if we explicitly don\\'t allot a variable for it."
                    },
                    {
                        "username": "AjayUpadhyay",
                        "content": "why  mid*mid is overflowing we are not storing the mid*mid anywhere  we are just comparing it with x then also why overflow is occuring ? anyone"
                    },
                    {
                        "username": "avishekgop5833",
                        "content": " `class Solution {\\n    public int mySqrt(int x) {\\n         long y = 0 ;\\n        while(y*y<=x)y++;\\n        return y-1.0;\\n    }\\n}`\\n\\nLine 5: error: incompatible types: possible lossy conversion from double to int\\n        return y-1.0;  plz help me"
                    },
                    {
                        "username": "Preadator_Dp",
                        "content": "one line code\\n#include<bits/stdc++.h>\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n       int ans =sqrt(x);\\n       return ans;\\n    }\\n};"
                    },
                    {
                        "username": "psrij",
                        "content": "return pow(x,0.5);   \nQuick and easy c++ solution\nis there any other solution other that this \nif yes then pls reply"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "ParagBagga",
                        "content": "public class Solution {\\n    public int MySqrt(int x) {\\n         int low = 1;\\n            int high = x;\\n            int mid = (low + high) / 2;\\n\\n            while (low <= high)\\n            {\\n                if (mid  > x/mid)\\n                {\\n                    high = mid - 1;\\n                    mid = (low + high) / 2;\\n                }\\n                else if (mid < x/mid)\\n                {\\n                    low = mid + 1;\\n                    mid = (low + high) / 2;\\n                }\\n                else if (mid == x/mid)\\n                {\\n                    return mid;\\n                }\\n            }\\n\\n            return high;\\n    }\\n}"
                    },
                    {
                        "username": "aritrabasu2002",
                        "content": "#include<iostream>\\n#include<cmath>\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        double result;\\n        result=pow(x,0.5);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "omuksa007",
                        "content": "why it gives o/p of 0 for i/p of 4?\\nplease tell me.....\\n\\n int mySqrt(int x) {\\n        if(x==1){\\n            return 1;\\n        }\\n        for(int i=1;i<x/2;i++){\\n            if((i*i) == x){\\n                return i;\\n            }\\n            else if((i+1)*(i+1)>x && (i*i) < x){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "Abu_Daud",
                        "content": "using math formula \\nWe can consider mathematical term (\\u221Ax-\\u221Ax)2  = 0.\\nReplacing one of the \\u221Ax\\u2018s with y, then the equation becomes (y-\\u221Ax)2 => y2 \\u2013 2y\\u221Ax + x = 0\\n=> \\u221Ax = (y2 + x) / 2y\\n=> \\u221Ax = (y + x/y) / 2"
                    }
                ]
            },
            {
                "id": 1739981,
                "content": [
                    {
                        "username": "AjayUpadhyay",
                        "content": "why  mid * mid is overflowing we are not storing the mid * mid we are just comparing it with x then also why overflow is occuring ? anyone"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "It should get stored somewhere in memory to hold good for the comparison. This is probably why it happens eve n if we explicitly don\\'t allot a variable for it."
                    },
                    {
                        "username": "AjayUpadhyay",
                        "content": "why  mid*mid is overflowing we are not storing the mid*mid anywhere  we are just comparing it with x then also why overflow is occuring ? anyone"
                    },
                    {
                        "username": "avishekgop5833",
                        "content": " `class Solution {\\n    public int mySqrt(int x) {\\n         long y = 0 ;\\n        while(y*y<=x)y++;\\n        return y-1.0;\\n    }\\n}`\\n\\nLine 5: error: incompatible types: possible lossy conversion from double to int\\n        return y-1.0;  plz help me"
                    },
                    {
                        "username": "Preadator_Dp",
                        "content": "one line code\\n#include<bits/stdc++.h>\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n       int ans =sqrt(x);\\n       return ans;\\n    }\\n};"
                    },
                    {
                        "username": "psrij",
                        "content": "return pow(x,0.5);   \nQuick and easy c++ solution\nis there any other solution other that this \nif yes then pls reply"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "ParagBagga",
                        "content": "public class Solution {\\n    public int MySqrt(int x) {\\n         int low = 1;\\n            int high = x;\\n            int mid = (low + high) / 2;\\n\\n            while (low <= high)\\n            {\\n                if (mid  > x/mid)\\n                {\\n                    high = mid - 1;\\n                    mid = (low + high) / 2;\\n                }\\n                else if (mid < x/mid)\\n                {\\n                    low = mid + 1;\\n                    mid = (low + high) / 2;\\n                }\\n                else if (mid == x/mid)\\n                {\\n                    return mid;\\n                }\\n            }\\n\\n            return high;\\n    }\\n}"
                    },
                    {
                        "username": "aritrabasu2002",
                        "content": "#include<iostream>\\n#include<cmath>\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        double result;\\n        result=pow(x,0.5);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "omuksa007",
                        "content": "why it gives o/p of 0 for i/p of 4?\\nplease tell me.....\\n\\n int mySqrt(int x) {\\n        if(x==1){\\n            return 1;\\n        }\\n        for(int i=1;i<x/2;i++){\\n            if((i*i) == x){\\n                return i;\\n            }\\n            else if((i+1)*(i+1)>x && (i*i) < x){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "Abu_Daud",
                        "content": "using math formula \\nWe can consider mathematical term (\\u221Ax-\\u221Ax)2  = 0.\\nReplacing one of the \\u221Ax\\u2018s with y, then the equation becomes (y-\\u221Ax)2 => y2 \\u2013 2y\\u221Ax + x = 0\\n=> \\u221Ax = (y2 + x) / 2y\\n=> \\u221Ax = (y + x/y) / 2"
                    }
                ]
            },
            {
                "id": 1739905,
                "content": [
                    {
                        "username": "AjayUpadhyay",
                        "content": "why  mid * mid is overflowing we are not storing the mid * mid we are just comparing it with x then also why overflow is occuring ? anyone"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "It should get stored somewhere in memory to hold good for the comparison. This is probably why it happens eve n if we explicitly don\\'t allot a variable for it."
                    },
                    {
                        "username": "AjayUpadhyay",
                        "content": "why  mid*mid is overflowing we are not storing the mid*mid anywhere  we are just comparing it with x then also why overflow is occuring ? anyone"
                    },
                    {
                        "username": "avishekgop5833",
                        "content": " `class Solution {\\n    public int mySqrt(int x) {\\n         long y = 0 ;\\n        while(y*y<=x)y++;\\n        return y-1.0;\\n    }\\n}`\\n\\nLine 5: error: incompatible types: possible lossy conversion from double to int\\n        return y-1.0;  plz help me"
                    },
                    {
                        "username": "Preadator_Dp",
                        "content": "one line code\\n#include<bits/stdc++.h>\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n       int ans =sqrt(x);\\n       return ans;\\n    }\\n};"
                    },
                    {
                        "username": "psrij",
                        "content": "return pow(x,0.5);   \nQuick and easy c++ solution\nis there any other solution other that this \nif yes then pls reply"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "ParagBagga",
                        "content": "public class Solution {\\n    public int MySqrt(int x) {\\n         int low = 1;\\n            int high = x;\\n            int mid = (low + high) / 2;\\n\\n            while (low <= high)\\n            {\\n                if (mid  > x/mid)\\n                {\\n                    high = mid - 1;\\n                    mid = (low + high) / 2;\\n                }\\n                else if (mid < x/mid)\\n                {\\n                    low = mid + 1;\\n                    mid = (low + high) / 2;\\n                }\\n                else if (mid == x/mid)\\n                {\\n                    return mid;\\n                }\\n            }\\n\\n            return high;\\n    }\\n}"
                    },
                    {
                        "username": "aritrabasu2002",
                        "content": "#include<iostream>\\n#include<cmath>\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        double result;\\n        result=pow(x,0.5);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "omuksa007",
                        "content": "why it gives o/p of 0 for i/p of 4?\\nplease tell me.....\\n\\n int mySqrt(int x) {\\n        if(x==1){\\n            return 1;\\n        }\\n        for(int i=1;i<x/2;i++){\\n            if((i*i) == x){\\n                return i;\\n            }\\n            else if((i+1)*(i+1)>x && (i*i) < x){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "Abu_Daud",
                        "content": "using math formula \\nWe can consider mathematical term (\\u221Ax-\\u221Ax)2  = 0.\\nReplacing one of the \\u221Ax\\u2018s with y, then the equation becomes (y-\\u221Ax)2 => y2 \\u2013 2y\\u221Ax + x = 0\\n=> \\u221Ax = (y2 + x) / 2y\\n=> \\u221Ax = (y + x/y) / 2"
                    }
                ]
            },
            {
                "id": 1733539,
                "content": [
                    {
                        "username": "AjayUpadhyay",
                        "content": "why  mid * mid is overflowing we are not storing the mid * mid we are just comparing it with x then also why overflow is occuring ? anyone"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "It should get stored somewhere in memory to hold good for the comparison. This is probably why it happens eve n if we explicitly don\\'t allot a variable for it."
                    },
                    {
                        "username": "AjayUpadhyay",
                        "content": "why  mid*mid is overflowing we are not storing the mid*mid anywhere  we are just comparing it with x then also why overflow is occuring ? anyone"
                    },
                    {
                        "username": "avishekgop5833",
                        "content": " `class Solution {\\n    public int mySqrt(int x) {\\n         long y = 0 ;\\n        while(y*y<=x)y++;\\n        return y-1.0;\\n    }\\n}`\\n\\nLine 5: error: incompatible types: possible lossy conversion from double to int\\n        return y-1.0;  plz help me"
                    },
                    {
                        "username": "Preadator_Dp",
                        "content": "one line code\\n#include<bits/stdc++.h>\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n       int ans =sqrt(x);\\n       return ans;\\n    }\\n};"
                    },
                    {
                        "username": "psrij",
                        "content": "return pow(x,0.5);   \nQuick and easy c++ solution\nis there any other solution other that this \nif yes then pls reply"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "ParagBagga",
                        "content": "public class Solution {\\n    public int MySqrt(int x) {\\n         int low = 1;\\n            int high = x;\\n            int mid = (low + high) / 2;\\n\\n            while (low <= high)\\n            {\\n                if (mid  > x/mid)\\n                {\\n                    high = mid - 1;\\n                    mid = (low + high) / 2;\\n                }\\n                else if (mid < x/mid)\\n                {\\n                    low = mid + 1;\\n                    mid = (low + high) / 2;\\n                }\\n                else if (mid == x/mid)\\n                {\\n                    return mid;\\n                }\\n            }\\n\\n            return high;\\n    }\\n}"
                    },
                    {
                        "username": "aritrabasu2002",
                        "content": "#include<iostream>\\n#include<cmath>\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        double result;\\n        result=pow(x,0.5);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "omuksa007",
                        "content": "why it gives o/p of 0 for i/p of 4?\\nplease tell me.....\\n\\n int mySqrt(int x) {\\n        if(x==1){\\n            return 1;\\n        }\\n        for(int i=1;i<x/2;i++){\\n            if((i*i) == x){\\n                return i;\\n            }\\n            else if((i+1)*(i+1)>x && (i*i) < x){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "Abu_Daud",
                        "content": "using math formula \\nWe can consider mathematical term (\\u221Ax-\\u221Ax)2  = 0.\\nReplacing one of the \\u221Ax\\u2018s with y, then the equation becomes (y-\\u221Ax)2 => y2 \\u2013 2y\\u221Ax + x = 0\\n=> \\u221Ax = (y2 + x) / 2y\\n=> \\u221Ax = (y + x/y) / 2"
                    }
                ]
            },
            {
                "id": 1733479,
                "content": [
                    {
                        "username": "AjayUpadhyay",
                        "content": "why  mid * mid is overflowing we are not storing the mid * mid we are just comparing it with x then also why overflow is occuring ? anyone"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "It should get stored somewhere in memory to hold good for the comparison. This is probably why it happens eve n if we explicitly don\\'t allot a variable for it."
                    },
                    {
                        "username": "AjayUpadhyay",
                        "content": "why  mid*mid is overflowing we are not storing the mid*mid anywhere  we are just comparing it with x then also why overflow is occuring ? anyone"
                    },
                    {
                        "username": "avishekgop5833",
                        "content": " `class Solution {\\n    public int mySqrt(int x) {\\n         long y = 0 ;\\n        while(y*y<=x)y++;\\n        return y-1.0;\\n    }\\n}`\\n\\nLine 5: error: incompatible types: possible lossy conversion from double to int\\n        return y-1.0;  plz help me"
                    },
                    {
                        "username": "Preadator_Dp",
                        "content": "one line code\\n#include<bits/stdc++.h>\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n       int ans =sqrt(x);\\n       return ans;\\n    }\\n};"
                    },
                    {
                        "username": "psrij",
                        "content": "return pow(x,0.5);   \nQuick and easy c++ solution\nis there any other solution other that this \nif yes then pls reply"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "ParagBagga",
                        "content": "public class Solution {\\n    public int MySqrt(int x) {\\n         int low = 1;\\n            int high = x;\\n            int mid = (low + high) / 2;\\n\\n            while (low <= high)\\n            {\\n                if (mid  > x/mid)\\n                {\\n                    high = mid - 1;\\n                    mid = (low + high) / 2;\\n                }\\n                else if (mid < x/mid)\\n                {\\n                    low = mid + 1;\\n                    mid = (low + high) / 2;\\n                }\\n                else if (mid == x/mid)\\n                {\\n                    return mid;\\n                }\\n            }\\n\\n            return high;\\n    }\\n}"
                    },
                    {
                        "username": "aritrabasu2002",
                        "content": "#include<iostream>\\n#include<cmath>\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        double result;\\n        result=pow(x,0.5);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "omuksa007",
                        "content": "why it gives o/p of 0 for i/p of 4?\\nplease tell me.....\\n\\n int mySqrt(int x) {\\n        if(x==1){\\n            return 1;\\n        }\\n        for(int i=1;i<x/2;i++){\\n            if((i*i) == x){\\n                return i;\\n            }\\n            else if((i+1)*(i+1)>x && (i*i) < x){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "Abu_Daud",
                        "content": "using math formula \\nWe can consider mathematical term (\\u221Ax-\\u221Ax)2  = 0.\\nReplacing one of the \\u221Ax\\u2018s with y, then the equation becomes (y-\\u221Ax)2 => y2 \\u2013 2y\\u221Ax + x = 0\\n=> \\u221Ax = (y2 + x) / 2y\\n=> \\u221Ax = (y + x/y) / 2"
                    }
                ]
            },
            {
                "id": 1733108,
                "content": [
                    {
                        "username": "AjayUpadhyay",
                        "content": "why  mid * mid is overflowing we are not storing the mid * mid we are just comparing it with x then also why overflow is occuring ? anyone"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "It should get stored somewhere in memory to hold good for the comparison. This is probably why it happens eve n if we explicitly don\\'t allot a variable for it."
                    },
                    {
                        "username": "AjayUpadhyay",
                        "content": "why  mid*mid is overflowing we are not storing the mid*mid anywhere  we are just comparing it with x then also why overflow is occuring ? anyone"
                    },
                    {
                        "username": "avishekgop5833",
                        "content": " `class Solution {\\n    public int mySqrt(int x) {\\n         long y = 0 ;\\n        while(y*y<=x)y++;\\n        return y-1.0;\\n    }\\n}`\\n\\nLine 5: error: incompatible types: possible lossy conversion from double to int\\n        return y-1.0;  plz help me"
                    },
                    {
                        "username": "Preadator_Dp",
                        "content": "one line code\\n#include<bits/stdc++.h>\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n       int ans =sqrt(x);\\n       return ans;\\n    }\\n};"
                    },
                    {
                        "username": "psrij",
                        "content": "return pow(x,0.5);   \nQuick and easy c++ solution\nis there any other solution other that this \nif yes then pls reply"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "ParagBagga",
                        "content": "public class Solution {\\n    public int MySqrt(int x) {\\n         int low = 1;\\n            int high = x;\\n            int mid = (low + high) / 2;\\n\\n            while (low <= high)\\n            {\\n                if (mid  > x/mid)\\n                {\\n                    high = mid - 1;\\n                    mid = (low + high) / 2;\\n                }\\n                else if (mid < x/mid)\\n                {\\n                    low = mid + 1;\\n                    mid = (low + high) / 2;\\n                }\\n                else if (mid == x/mid)\\n                {\\n                    return mid;\\n                }\\n            }\\n\\n            return high;\\n    }\\n}"
                    },
                    {
                        "username": "aritrabasu2002",
                        "content": "#include<iostream>\\n#include<cmath>\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        double result;\\n        result=pow(x,0.5);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "omuksa007",
                        "content": "why it gives o/p of 0 for i/p of 4?\\nplease tell me.....\\n\\n int mySqrt(int x) {\\n        if(x==1){\\n            return 1;\\n        }\\n        for(int i=1;i<x/2;i++){\\n            if((i*i) == x){\\n                return i;\\n            }\\n            else if((i+1)*(i+1)>x && (i*i) < x){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "Abu_Daud",
                        "content": "using math formula \\nWe can consider mathematical term (\\u221Ax-\\u221Ax)2  = 0.\\nReplacing one of the \\u221Ax\\u2018s with y, then the equation becomes (y-\\u221Ax)2 => y2 \\u2013 2y\\u221Ax + x = 0\\n=> \\u221Ax = (y2 + x) / 2y\\n=> \\u221Ax = (y + x/y) / 2"
                    }
                ]
            },
            {
                "id": 1729077,
                "content": [
                    {
                        "username": "AjayUpadhyay",
                        "content": "why  mid * mid is overflowing we are not storing the mid * mid we are just comparing it with x then also why overflow is occuring ? anyone"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "It should get stored somewhere in memory to hold good for the comparison. This is probably why it happens eve n if we explicitly don\\'t allot a variable for it."
                    },
                    {
                        "username": "AjayUpadhyay",
                        "content": "why  mid*mid is overflowing we are not storing the mid*mid anywhere  we are just comparing it with x then also why overflow is occuring ? anyone"
                    },
                    {
                        "username": "avishekgop5833",
                        "content": " `class Solution {\\n    public int mySqrt(int x) {\\n         long y = 0 ;\\n        while(y*y<=x)y++;\\n        return y-1.0;\\n    }\\n}`\\n\\nLine 5: error: incompatible types: possible lossy conversion from double to int\\n        return y-1.0;  plz help me"
                    },
                    {
                        "username": "Preadator_Dp",
                        "content": "one line code\\n#include<bits/stdc++.h>\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n       int ans =sqrt(x);\\n       return ans;\\n    }\\n};"
                    },
                    {
                        "username": "psrij",
                        "content": "return pow(x,0.5);   \nQuick and easy c++ solution\nis there any other solution other that this \nif yes then pls reply"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "ParagBagga",
                        "content": "public class Solution {\\n    public int MySqrt(int x) {\\n         int low = 1;\\n            int high = x;\\n            int mid = (low + high) / 2;\\n\\n            while (low <= high)\\n            {\\n                if (mid  > x/mid)\\n                {\\n                    high = mid - 1;\\n                    mid = (low + high) / 2;\\n                }\\n                else if (mid < x/mid)\\n                {\\n                    low = mid + 1;\\n                    mid = (low + high) / 2;\\n                }\\n                else if (mid == x/mid)\\n                {\\n                    return mid;\\n                }\\n            }\\n\\n            return high;\\n    }\\n}"
                    },
                    {
                        "username": "aritrabasu2002",
                        "content": "#include<iostream>\\n#include<cmath>\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        double result;\\n        result=pow(x,0.5);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "omuksa007",
                        "content": "why it gives o/p of 0 for i/p of 4?\\nplease tell me.....\\n\\n int mySqrt(int x) {\\n        if(x==1){\\n            return 1;\\n        }\\n        for(int i=1;i<x/2;i++){\\n            if((i*i) == x){\\n                return i;\\n            }\\n            else if((i+1)*(i+1)>x && (i*i) < x){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "Abu_Daud",
                        "content": "using math formula \\nWe can consider mathematical term (\\u221Ax-\\u221Ax)2  = 0.\\nReplacing one of the \\u221Ax\\u2018s with y, then the equation becomes (y-\\u221Ax)2 => y2 \\u2013 2y\\u221Ax + x = 0\\n=> \\u221Ax = (y2 + x) / 2y\\n=> \\u221Ax = (y + x/y) / 2"
                    }
                ]
            },
            {
                "id": 1724157,
                "content": [
                    {
                        "username": "AjayUpadhyay",
                        "content": "why  mid * mid is overflowing we are not storing the mid * mid we are just comparing it with x then also why overflow is occuring ? anyone"
                    },
                    {
                        "username": "brbamcoding",
                        "content": "It should get stored somewhere in memory to hold good for the comparison. This is probably why it happens eve n if we explicitly don\\'t allot a variable for it."
                    },
                    {
                        "username": "AjayUpadhyay",
                        "content": "why  mid*mid is overflowing we are not storing the mid*mid anywhere  we are just comparing it with x then also why overflow is occuring ? anyone"
                    },
                    {
                        "username": "avishekgop5833",
                        "content": " `class Solution {\\n    public int mySqrt(int x) {\\n         long y = 0 ;\\n        while(y*y<=x)y++;\\n        return y-1.0;\\n    }\\n}`\\n\\nLine 5: error: incompatible types: possible lossy conversion from double to int\\n        return y-1.0;  plz help me"
                    },
                    {
                        "username": "Preadator_Dp",
                        "content": "one line code\\n#include<bits/stdc++.h>\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n       int ans =sqrt(x);\\n       return ans;\\n    }\\n};"
                    },
                    {
                        "username": "psrij",
                        "content": "return pow(x,0.5);   \nQuick and easy c++ solution\nis there any other solution other that this \nif yes then pls reply"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "ParagBagga",
                        "content": "public class Solution {\\n    public int MySqrt(int x) {\\n         int low = 1;\\n            int high = x;\\n            int mid = (low + high) / 2;\\n\\n            while (low <= high)\\n            {\\n                if (mid  > x/mid)\\n                {\\n                    high = mid - 1;\\n                    mid = (low + high) / 2;\\n                }\\n                else if (mid < x/mid)\\n                {\\n                    low = mid + 1;\\n                    mid = (low + high) / 2;\\n                }\\n                else if (mid == x/mid)\\n                {\\n                    return mid;\\n                }\\n            }\\n\\n            return high;\\n    }\\n}"
                    },
                    {
                        "username": "aritrabasu2002",
                        "content": "#include<iostream>\\n#include<cmath>\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int x) {\\n        double result;\\n        result=pow(x,0.5);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "omuksa007",
                        "content": "why it gives o/p of 0 for i/p of 4?\\nplease tell me.....\\n\\n int mySqrt(int x) {\\n        if(x==1){\\n            return 1;\\n        }\\n        for(int i=1;i<x/2;i++){\\n            if((i*i) == x){\\n                return i;\\n            }\\n            else if((i+1)*(i+1)>x && (i*i) < x){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "Abu_Daud",
                        "content": "using math formula \\nWe can consider mathematical term (\\u221Ax-\\u221Ax)2  = 0.\\nReplacing one of the \\u221Ax\\u2018s with y, then the equation becomes (y-\\u221Ax)2 => y2 \\u2013 2y\\u221Ax + x = 0\\n=> \\u221Ax = (y2 + x) / 2y\\n=> \\u221Ax = (y + x/y) / 2"
                    }
                ]
            },
            {
                "id": 1719021,
                "content": [
                    {
                        "username": "Rawan_Rababah",
                        "content": "TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 42 in _driver (Solution.py)\\n    _driver()\\nLine 48 in <module> (Solution.py)\\n\\n\\nthe run is accepted but when i click om submit , the massage above show ??\\nwho know the solution >??"
                    },
                    {
                        "username": "hegdeanirudh2003",
                        "content": "what is time complexity for this solution:\\nimport math\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        return int(math.sqrt(x))"
                    },
                    {
                        "username": "user9177eE",
                        "content": "Why this solution is correct?\\nclass Solution {\\npublic:\\n\\n    long long int binarySearch(int x){\\n        \\n\\n        int s = 0;\\n        int e = x;\\n        long long int mid = s + (e-s)/2;\\n\\n        long long int ans = -1;\\n\\n        while(s<=e){\\n            long long int z = mid*mid;\\n\\n            if(z == x){\\n                return mid;\\n            }\\n            else if(z<x){\\n                s = mid+1;\\n                ans = mid;\\n            }\\n            else{\\n                e = mid-1;\\n            }\\n\\n            mid = s + (e-s)/2;\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n    int mySqrt(int x) {\\n        return binarySearch(x);\\n    }\\n};\\n\\n\\nI mean there is no even array in the code to apply binary search on .\\n\\n\\nWhereas I have written this code on my vs code(ignore that long long int thing), but atleast it has proper logic.\\n#include<iostream>\\nusing namespace std;\\n\\nint searchSpace(int a){\\n    int arr[a+1];\\n    for(int i=0; i<=a; i++){\\n        arr[i]=i;\\n    }\\n\\n    int s=0;\\n    int e=a;\\n    int mid = s + (e-s)/2;\\n\\n    while(s<=e){\\n        int x = mid*mid;\\n\\n        if(x == a){\\n            return arr[mid];\\n            \\n        }\\n        \\n        else if(x<a){\\n            s = mid+1;\\n        }\\n\\n        else{\\n            e = mid-1;\\n        }\\n\\n        mid = s + (e-s)/2;\\n    }\\n\\n    return arr[mid-1];\\n\\n}\\n\\n\\nint main(){\\n\\n    int a;\\n    cout<<\"Enter a number: \";\\n    cin>>a;\\n\\n    cout<<\"Square root of \"<<a<<\" is \"<<searchSpace(a)<<\".\\\\n\"<<endl;\\n\\n}\\n"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "int mySqrt(int x) {\n        int i=1;\n        if(x==0)\n            return 0;\n        while(i<=x){\n            if(x==i*i)\n                return i;\n            else if(x>(i*i) && x<(i+1)*(i+1))\n                return i;\n            else\n                i++;\n        }\n    \n    return -1;\n    }\n\n**How to rectify the signed integer overflow problem??\n"
                    },
                    {
                        "username": "kaustubhrajput",
                        "content": "Bruteforce gave O(N) while when we used Binary Search we got O(log n).\\nThis is the application of Binary search."
                    },
                    {
                        "username": "nachiket-s",
                        "content": "Can someone pls suggest me the syntax to use recursion in python. I am familiar with recursion in regular python code but \\'class solution(object)\\' and usage of \\'self\\' for function confuses me"
                    },
                    {
                        "username": "sharmamuskan296",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    long long int binarysearch(int n ){\\n        int s = 0;\\n        int e = n;\\n        long long int m = s+(e-s)/2;\\n        long long int ans = -1;\\n\\n        while (s<=e){\\n            long long int sq = m * m; //range fatt gyi \\n            if (sq == n){\\n                return m;\\n            }\\n            if (sq < n){\\n                ans = m;\\n                s = m + 1;\\n            }\\n            else {\\n                e = m - 1;\\n            }\\n        m = s + (e - s) / 2;\\n        }\\n    return ans ;\\n    }\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "Sorry I am cringe\n\n    def mySqrt(self, x: int) -> int:\n        return int(sqrt(x))"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "very very easy for beginner or senior"
                    },
                    {
                        "username": "dzhang1238",
                        "content": "class Solution {\\n    public int mySqrt(int x) {\\n        int mid_num = x/2;\\n\\n        while ( (mid_num * mid_num) > x){\\n            mid_num /= 2;\\n        }\\n\\n        while ( (mid_num * mid_num) <= x ){\\n            mid_num += 1;\\n        }\\n\\n        return mid_num-1;\\n    }\\n}\\n\\nIs it because the integer overflow so it won\\'t work?"
                    }
                ]
            },
            {
                "id": 1717758,
                "content": [
                    {
                        "username": "Rawan_Rababah",
                        "content": "TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 42 in _driver (Solution.py)\\n    _driver()\\nLine 48 in <module> (Solution.py)\\n\\n\\nthe run is accepted but when i click om submit , the massage above show ??\\nwho know the solution >??"
                    },
                    {
                        "username": "hegdeanirudh2003",
                        "content": "what is time complexity for this solution:\\nimport math\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        return int(math.sqrt(x))"
                    },
                    {
                        "username": "user9177eE",
                        "content": "Why this solution is correct?\\nclass Solution {\\npublic:\\n\\n    long long int binarySearch(int x){\\n        \\n\\n        int s = 0;\\n        int e = x;\\n        long long int mid = s + (e-s)/2;\\n\\n        long long int ans = -1;\\n\\n        while(s<=e){\\n            long long int z = mid*mid;\\n\\n            if(z == x){\\n                return mid;\\n            }\\n            else if(z<x){\\n                s = mid+1;\\n                ans = mid;\\n            }\\n            else{\\n                e = mid-1;\\n            }\\n\\n            mid = s + (e-s)/2;\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n    int mySqrt(int x) {\\n        return binarySearch(x);\\n    }\\n};\\n\\n\\nI mean there is no even array in the code to apply binary search on .\\n\\n\\nWhereas I have written this code on my vs code(ignore that long long int thing), but atleast it has proper logic.\\n#include<iostream>\\nusing namespace std;\\n\\nint searchSpace(int a){\\n    int arr[a+1];\\n    for(int i=0; i<=a; i++){\\n        arr[i]=i;\\n    }\\n\\n    int s=0;\\n    int e=a;\\n    int mid = s + (e-s)/2;\\n\\n    while(s<=e){\\n        int x = mid*mid;\\n\\n        if(x == a){\\n            return arr[mid];\\n            \\n        }\\n        \\n        else if(x<a){\\n            s = mid+1;\\n        }\\n\\n        else{\\n            e = mid-1;\\n        }\\n\\n        mid = s + (e-s)/2;\\n    }\\n\\n    return arr[mid-1];\\n\\n}\\n\\n\\nint main(){\\n\\n    int a;\\n    cout<<\"Enter a number: \";\\n    cin>>a;\\n\\n    cout<<\"Square root of \"<<a<<\" is \"<<searchSpace(a)<<\".\\\\n\"<<endl;\\n\\n}\\n"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "int mySqrt(int x) {\n        int i=1;\n        if(x==0)\n            return 0;\n        while(i<=x){\n            if(x==i*i)\n                return i;\n            else if(x>(i*i) && x<(i+1)*(i+1))\n                return i;\n            else\n                i++;\n        }\n    \n    return -1;\n    }\n\n**How to rectify the signed integer overflow problem??\n"
                    },
                    {
                        "username": "kaustubhrajput",
                        "content": "Bruteforce gave O(N) while when we used Binary Search we got O(log n).\\nThis is the application of Binary search."
                    },
                    {
                        "username": "nachiket-s",
                        "content": "Can someone pls suggest me the syntax to use recursion in python. I am familiar with recursion in regular python code but \\'class solution(object)\\' and usage of \\'self\\' for function confuses me"
                    },
                    {
                        "username": "sharmamuskan296",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    long long int binarysearch(int n ){\\n        int s = 0;\\n        int e = n;\\n        long long int m = s+(e-s)/2;\\n        long long int ans = -1;\\n\\n        while (s<=e){\\n            long long int sq = m * m; //range fatt gyi \\n            if (sq == n){\\n                return m;\\n            }\\n            if (sq < n){\\n                ans = m;\\n                s = m + 1;\\n            }\\n            else {\\n                e = m - 1;\\n            }\\n        m = s + (e - s) / 2;\\n        }\\n    return ans ;\\n    }\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "Sorry I am cringe\n\n    def mySqrt(self, x: int) -> int:\n        return int(sqrt(x))"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "very very easy for beginner or senior"
                    },
                    {
                        "username": "dzhang1238",
                        "content": "class Solution {\\n    public int mySqrt(int x) {\\n        int mid_num = x/2;\\n\\n        while ( (mid_num * mid_num) > x){\\n            mid_num /= 2;\\n        }\\n\\n        while ( (mid_num * mid_num) <= x ){\\n            mid_num += 1;\\n        }\\n\\n        return mid_num-1;\\n    }\\n}\\n\\nIs it because the integer overflow so it won\\'t work?"
                    }
                ]
            },
            {
                "id": 1716996,
                "content": [
                    {
                        "username": "Rawan_Rababah",
                        "content": "TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 42 in _driver (Solution.py)\\n    _driver()\\nLine 48 in <module> (Solution.py)\\n\\n\\nthe run is accepted but when i click om submit , the massage above show ??\\nwho know the solution >??"
                    },
                    {
                        "username": "hegdeanirudh2003",
                        "content": "what is time complexity for this solution:\\nimport math\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        return int(math.sqrt(x))"
                    },
                    {
                        "username": "user9177eE",
                        "content": "Why this solution is correct?\\nclass Solution {\\npublic:\\n\\n    long long int binarySearch(int x){\\n        \\n\\n        int s = 0;\\n        int e = x;\\n        long long int mid = s + (e-s)/2;\\n\\n        long long int ans = -1;\\n\\n        while(s<=e){\\n            long long int z = mid*mid;\\n\\n            if(z == x){\\n                return mid;\\n            }\\n            else if(z<x){\\n                s = mid+1;\\n                ans = mid;\\n            }\\n            else{\\n                e = mid-1;\\n            }\\n\\n            mid = s + (e-s)/2;\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n    int mySqrt(int x) {\\n        return binarySearch(x);\\n    }\\n};\\n\\n\\nI mean there is no even array in the code to apply binary search on .\\n\\n\\nWhereas I have written this code on my vs code(ignore that long long int thing), but atleast it has proper logic.\\n#include<iostream>\\nusing namespace std;\\n\\nint searchSpace(int a){\\n    int arr[a+1];\\n    for(int i=0; i<=a; i++){\\n        arr[i]=i;\\n    }\\n\\n    int s=0;\\n    int e=a;\\n    int mid = s + (e-s)/2;\\n\\n    while(s<=e){\\n        int x = mid*mid;\\n\\n        if(x == a){\\n            return arr[mid];\\n            \\n        }\\n        \\n        else if(x<a){\\n            s = mid+1;\\n        }\\n\\n        else{\\n            e = mid-1;\\n        }\\n\\n        mid = s + (e-s)/2;\\n    }\\n\\n    return arr[mid-1];\\n\\n}\\n\\n\\nint main(){\\n\\n    int a;\\n    cout<<\"Enter a number: \";\\n    cin>>a;\\n\\n    cout<<\"Square root of \"<<a<<\" is \"<<searchSpace(a)<<\".\\\\n\"<<endl;\\n\\n}\\n"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "int mySqrt(int x) {\n        int i=1;\n        if(x==0)\n            return 0;\n        while(i<=x){\n            if(x==i*i)\n                return i;\n            else if(x>(i*i) && x<(i+1)*(i+1))\n                return i;\n            else\n                i++;\n        }\n    \n    return -1;\n    }\n\n**How to rectify the signed integer overflow problem??\n"
                    },
                    {
                        "username": "kaustubhrajput",
                        "content": "Bruteforce gave O(N) while when we used Binary Search we got O(log n).\\nThis is the application of Binary search."
                    },
                    {
                        "username": "nachiket-s",
                        "content": "Can someone pls suggest me the syntax to use recursion in python. I am familiar with recursion in regular python code but \\'class solution(object)\\' and usage of \\'self\\' for function confuses me"
                    },
                    {
                        "username": "sharmamuskan296",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    long long int binarysearch(int n ){\\n        int s = 0;\\n        int e = n;\\n        long long int m = s+(e-s)/2;\\n        long long int ans = -1;\\n\\n        while (s<=e){\\n            long long int sq = m * m; //range fatt gyi \\n            if (sq == n){\\n                return m;\\n            }\\n            if (sq < n){\\n                ans = m;\\n                s = m + 1;\\n            }\\n            else {\\n                e = m - 1;\\n            }\\n        m = s + (e - s) / 2;\\n        }\\n    return ans ;\\n    }\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "Sorry I am cringe\n\n    def mySqrt(self, x: int) -> int:\n        return int(sqrt(x))"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "very very easy for beginner or senior"
                    },
                    {
                        "username": "dzhang1238",
                        "content": "class Solution {\\n    public int mySqrt(int x) {\\n        int mid_num = x/2;\\n\\n        while ( (mid_num * mid_num) > x){\\n            mid_num /= 2;\\n        }\\n\\n        while ( (mid_num * mid_num) <= x ){\\n            mid_num += 1;\\n        }\\n\\n        return mid_num-1;\\n    }\\n}\\n\\nIs it because the integer overflow so it won\\'t work?"
                    }
                ]
            },
            {
                "id": 1708965,
                "content": [
                    {
                        "username": "Rawan_Rababah",
                        "content": "TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 42 in _driver (Solution.py)\\n    _driver()\\nLine 48 in <module> (Solution.py)\\n\\n\\nthe run is accepted but when i click om submit , the massage above show ??\\nwho know the solution >??"
                    },
                    {
                        "username": "hegdeanirudh2003",
                        "content": "what is time complexity for this solution:\\nimport math\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        return int(math.sqrt(x))"
                    },
                    {
                        "username": "user9177eE",
                        "content": "Why this solution is correct?\\nclass Solution {\\npublic:\\n\\n    long long int binarySearch(int x){\\n        \\n\\n        int s = 0;\\n        int e = x;\\n        long long int mid = s + (e-s)/2;\\n\\n        long long int ans = -1;\\n\\n        while(s<=e){\\n            long long int z = mid*mid;\\n\\n            if(z == x){\\n                return mid;\\n            }\\n            else if(z<x){\\n                s = mid+1;\\n                ans = mid;\\n            }\\n            else{\\n                e = mid-1;\\n            }\\n\\n            mid = s + (e-s)/2;\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n    int mySqrt(int x) {\\n        return binarySearch(x);\\n    }\\n};\\n\\n\\nI mean there is no even array in the code to apply binary search on .\\n\\n\\nWhereas I have written this code on my vs code(ignore that long long int thing), but atleast it has proper logic.\\n#include<iostream>\\nusing namespace std;\\n\\nint searchSpace(int a){\\n    int arr[a+1];\\n    for(int i=0; i<=a; i++){\\n        arr[i]=i;\\n    }\\n\\n    int s=0;\\n    int e=a;\\n    int mid = s + (e-s)/2;\\n\\n    while(s<=e){\\n        int x = mid*mid;\\n\\n        if(x == a){\\n            return arr[mid];\\n            \\n        }\\n        \\n        else if(x<a){\\n            s = mid+1;\\n        }\\n\\n        else{\\n            e = mid-1;\\n        }\\n\\n        mid = s + (e-s)/2;\\n    }\\n\\n    return arr[mid-1];\\n\\n}\\n\\n\\nint main(){\\n\\n    int a;\\n    cout<<\"Enter a number: \";\\n    cin>>a;\\n\\n    cout<<\"Square root of \"<<a<<\" is \"<<searchSpace(a)<<\".\\\\n\"<<endl;\\n\\n}\\n"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "int mySqrt(int x) {\n        int i=1;\n        if(x==0)\n            return 0;\n        while(i<=x){\n            if(x==i*i)\n                return i;\n            else if(x>(i*i) && x<(i+1)*(i+1))\n                return i;\n            else\n                i++;\n        }\n    \n    return -1;\n    }\n\n**How to rectify the signed integer overflow problem??\n"
                    },
                    {
                        "username": "kaustubhrajput",
                        "content": "Bruteforce gave O(N) while when we used Binary Search we got O(log n).\\nThis is the application of Binary search."
                    },
                    {
                        "username": "nachiket-s",
                        "content": "Can someone pls suggest me the syntax to use recursion in python. I am familiar with recursion in regular python code but \\'class solution(object)\\' and usage of \\'self\\' for function confuses me"
                    },
                    {
                        "username": "sharmamuskan296",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    long long int binarysearch(int n ){\\n        int s = 0;\\n        int e = n;\\n        long long int m = s+(e-s)/2;\\n        long long int ans = -1;\\n\\n        while (s<=e){\\n            long long int sq = m * m; //range fatt gyi \\n            if (sq == n){\\n                return m;\\n            }\\n            if (sq < n){\\n                ans = m;\\n                s = m + 1;\\n            }\\n            else {\\n                e = m - 1;\\n            }\\n        m = s + (e - s) / 2;\\n        }\\n    return ans ;\\n    }\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "Sorry I am cringe\n\n    def mySqrt(self, x: int) -> int:\n        return int(sqrt(x))"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "very very easy for beginner or senior"
                    },
                    {
                        "username": "dzhang1238",
                        "content": "class Solution {\\n    public int mySqrt(int x) {\\n        int mid_num = x/2;\\n\\n        while ( (mid_num * mid_num) > x){\\n            mid_num /= 2;\\n        }\\n\\n        while ( (mid_num * mid_num) <= x ){\\n            mid_num += 1;\\n        }\\n\\n        return mid_num-1;\\n    }\\n}\\n\\nIs it because the integer overflow so it won\\'t work?"
                    }
                ]
            },
            {
                "id": 1708535,
                "content": [
                    {
                        "username": "Rawan_Rababah",
                        "content": "TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 42 in _driver (Solution.py)\\n    _driver()\\nLine 48 in <module> (Solution.py)\\n\\n\\nthe run is accepted but when i click om submit , the massage above show ??\\nwho know the solution >??"
                    },
                    {
                        "username": "hegdeanirudh2003",
                        "content": "what is time complexity for this solution:\\nimport math\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        return int(math.sqrt(x))"
                    },
                    {
                        "username": "user9177eE",
                        "content": "Why this solution is correct?\\nclass Solution {\\npublic:\\n\\n    long long int binarySearch(int x){\\n        \\n\\n        int s = 0;\\n        int e = x;\\n        long long int mid = s + (e-s)/2;\\n\\n        long long int ans = -1;\\n\\n        while(s<=e){\\n            long long int z = mid*mid;\\n\\n            if(z == x){\\n                return mid;\\n            }\\n            else if(z<x){\\n                s = mid+1;\\n                ans = mid;\\n            }\\n            else{\\n                e = mid-1;\\n            }\\n\\n            mid = s + (e-s)/2;\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n    int mySqrt(int x) {\\n        return binarySearch(x);\\n    }\\n};\\n\\n\\nI mean there is no even array in the code to apply binary search on .\\n\\n\\nWhereas I have written this code on my vs code(ignore that long long int thing), but atleast it has proper logic.\\n#include<iostream>\\nusing namespace std;\\n\\nint searchSpace(int a){\\n    int arr[a+1];\\n    for(int i=0; i<=a; i++){\\n        arr[i]=i;\\n    }\\n\\n    int s=0;\\n    int e=a;\\n    int mid = s + (e-s)/2;\\n\\n    while(s<=e){\\n        int x = mid*mid;\\n\\n        if(x == a){\\n            return arr[mid];\\n            \\n        }\\n        \\n        else if(x<a){\\n            s = mid+1;\\n        }\\n\\n        else{\\n            e = mid-1;\\n        }\\n\\n        mid = s + (e-s)/2;\\n    }\\n\\n    return arr[mid-1];\\n\\n}\\n\\n\\nint main(){\\n\\n    int a;\\n    cout<<\"Enter a number: \";\\n    cin>>a;\\n\\n    cout<<\"Square root of \"<<a<<\" is \"<<searchSpace(a)<<\".\\\\n\"<<endl;\\n\\n}\\n"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "int mySqrt(int x) {\n        int i=1;\n        if(x==0)\n            return 0;\n        while(i<=x){\n            if(x==i*i)\n                return i;\n            else if(x>(i*i) && x<(i+1)*(i+1))\n                return i;\n            else\n                i++;\n        }\n    \n    return -1;\n    }\n\n**How to rectify the signed integer overflow problem??\n"
                    },
                    {
                        "username": "kaustubhrajput",
                        "content": "Bruteforce gave O(N) while when we used Binary Search we got O(log n).\\nThis is the application of Binary search."
                    },
                    {
                        "username": "nachiket-s",
                        "content": "Can someone pls suggest me the syntax to use recursion in python. I am familiar with recursion in regular python code but \\'class solution(object)\\' and usage of \\'self\\' for function confuses me"
                    },
                    {
                        "username": "sharmamuskan296",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    long long int binarysearch(int n ){\\n        int s = 0;\\n        int e = n;\\n        long long int m = s+(e-s)/2;\\n        long long int ans = -1;\\n\\n        while (s<=e){\\n            long long int sq = m * m; //range fatt gyi \\n            if (sq == n){\\n                return m;\\n            }\\n            if (sq < n){\\n                ans = m;\\n                s = m + 1;\\n            }\\n            else {\\n                e = m - 1;\\n            }\\n        m = s + (e - s) / 2;\\n        }\\n    return ans ;\\n    }\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "Sorry I am cringe\n\n    def mySqrt(self, x: int) -> int:\n        return int(sqrt(x))"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "very very easy for beginner or senior"
                    },
                    {
                        "username": "dzhang1238",
                        "content": "class Solution {\\n    public int mySqrt(int x) {\\n        int mid_num = x/2;\\n\\n        while ( (mid_num * mid_num) > x){\\n            mid_num /= 2;\\n        }\\n\\n        while ( (mid_num * mid_num) <= x ){\\n            mid_num += 1;\\n        }\\n\\n        return mid_num-1;\\n    }\\n}\\n\\nIs it because the integer overflow so it won\\'t work?"
                    }
                ]
            },
            {
                "id": 1707636,
                "content": [
                    {
                        "username": "Rawan_Rababah",
                        "content": "TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 42 in _driver (Solution.py)\\n    _driver()\\nLine 48 in <module> (Solution.py)\\n\\n\\nthe run is accepted but when i click om submit , the massage above show ??\\nwho know the solution >??"
                    },
                    {
                        "username": "hegdeanirudh2003",
                        "content": "what is time complexity for this solution:\\nimport math\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        return int(math.sqrt(x))"
                    },
                    {
                        "username": "user9177eE",
                        "content": "Why this solution is correct?\\nclass Solution {\\npublic:\\n\\n    long long int binarySearch(int x){\\n        \\n\\n        int s = 0;\\n        int e = x;\\n        long long int mid = s + (e-s)/2;\\n\\n        long long int ans = -1;\\n\\n        while(s<=e){\\n            long long int z = mid*mid;\\n\\n            if(z == x){\\n                return mid;\\n            }\\n            else if(z<x){\\n                s = mid+1;\\n                ans = mid;\\n            }\\n            else{\\n                e = mid-1;\\n            }\\n\\n            mid = s + (e-s)/2;\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n    int mySqrt(int x) {\\n        return binarySearch(x);\\n    }\\n};\\n\\n\\nI mean there is no even array in the code to apply binary search on .\\n\\n\\nWhereas I have written this code on my vs code(ignore that long long int thing), but atleast it has proper logic.\\n#include<iostream>\\nusing namespace std;\\n\\nint searchSpace(int a){\\n    int arr[a+1];\\n    for(int i=0; i<=a; i++){\\n        arr[i]=i;\\n    }\\n\\n    int s=0;\\n    int e=a;\\n    int mid = s + (e-s)/2;\\n\\n    while(s<=e){\\n        int x = mid*mid;\\n\\n        if(x == a){\\n            return arr[mid];\\n            \\n        }\\n        \\n        else if(x<a){\\n            s = mid+1;\\n        }\\n\\n        else{\\n            e = mid-1;\\n        }\\n\\n        mid = s + (e-s)/2;\\n    }\\n\\n    return arr[mid-1];\\n\\n}\\n\\n\\nint main(){\\n\\n    int a;\\n    cout<<\"Enter a number: \";\\n    cin>>a;\\n\\n    cout<<\"Square root of \"<<a<<\" is \"<<searchSpace(a)<<\".\\\\n\"<<endl;\\n\\n}\\n"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "int mySqrt(int x) {\n        int i=1;\n        if(x==0)\n            return 0;\n        while(i<=x){\n            if(x==i*i)\n                return i;\n            else if(x>(i*i) && x<(i+1)*(i+1))\n                return i;\n            else\n                i++;\n        }\n    \n    return -1;\n    }\n\n**How to rectify the signed integer overflow problem??\n"
                    },
                    {
                        "username": "kaustubhrajput",
                        "content": "Bruteforce gave O(N) while when we used Binary Search we got O(log n).\\nThis is the application of Binary search."
                    },
                    {
                        "username": "nachiket-s",
                        "content": "Can someone pls suggest me the syntax to use recursion in python. I am familiar with recursion in regular python code but \\'class solution(object)\\' and usage of \\'self\\' for function confuses me"
                    },
                    {
                        "username": "sharmamuskan296",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    long long int binarysearch(int n ){\\n        int s = 0;\\n        int e = n;\\n        long long int m = s+(e-s)/2;\\n        long long int ans = -1;\\n\\n        while (s<=e){\\n            long long int sq = m * m; //range fatt gyi \\n            if (sq == n){\\n                return m;\\n            }\\n            if (sq < n){\\n                ans = m;\\n                s = m + 1;\\n            }\\n            else {\\n                e = m - 1;\\n            }\\n        m = s + (e - s) / 2;\\n        }\\n    return ans ;\\n    }\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "Sorry I am cringe\n\n    def mySqrt(self, x: int) -> int:\n        return int(sqrt(x))"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "very very easy for beginner or senior"
                    },
                    {
                        "username": "dzhang1238",
                        "content": "class Solution {\\n    public int mySqrt(int x) {\\n        int mid_num = x/2;\\n\\n        while ( (mid_num * mid_num) > x){\\n            mid_num /= 2;\\n        }\\n\\n        while ( (mid_num * mid_num) <= x ){\\n            mid_num += 1;\\n        }\\n\\n        return mid_num-1;\\n    }\\n}\\n\\nIs it because the integer overflow so it won\\'t work?"
                    }
                ]
            },
            {
                "id": 1707300,
                "content": [
                    {
                        "username": "Rawan_Rababah",
                        "content": "TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 42 in _driver (Solution.py)\\n    _driver()\\nLine 48 in <module> (Solution.py)\\n\\n\\nthe run is accepted but when i click om submit , the massage above show ??\\nwho know the solution >??"
                    },
                    {
                        "username": "hegdeanirudh2003",
                        "content": "what is time complexity for this solution:\\nimport math\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        return int(math.sqrt(x))"
                    },
                    {
                        "username": "user9177eE",
                        "content": "Why this solution is correct?\\nclass Solution {\\npublic:\\n\\n    long long int binarySearch(int x){\\n        \\n\\n        int s = 0;\\n        int e = x;\\n        long long int mid = s + (e-s)/2;\\n\\n        long long int ans = -1;\\n\\n        while(s<=e){\\n            long long int z = mid*mid;\\n\\n            if(z == x){\\n                return mid;\\n            }\\n            else if(z<x){\\n                s = mid+1;\\n                ans = mid;\\n            }\\n            else{\\n                e = mid-1;\\n            }\\n\\n            mid = s + (e-s)/2;\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n    int mySqrt(int x) {\\n        return binarySearch(x);\\n    }\\n};\\n\\n\\nI mean there is no even array in the code to apply binary search on .\\n\\n\\nWhereas I have written this code on my vs code(ignore that long long int thing), but atleast it has proper logic.\\n#include<iostream>\\nusing namespace std;\\n\\nint searchSpace(int a){\\n    int arr[a+1];\\n    for(int i=0; i<=a; i++){\\n        arr[i]=i;\\n    }\\n\\n    int s=0;\\n    int e=a;\\n    int mid = s + (e-s)/2;\\n\\n    while(s<=e){\\n        int x = mid*mid;\\n\\n        if(x == a){\\n            return arr[mid];\\n            \\n        }\\n        \\n        else if(x<a){\\n            s = mid+1;\\n        }\\n\\n        else{\\n            e = mid-1;\\n        }\\n\\n        mid = s + (e-s)/2;\\n    }\\n\\n    return arr[mid-1];\\n\\n}\\n\\n\\nint main(){\\n\\n    int a;\\n    cout<<\"Enter a number: \";\\n    cin>>a;\\n\\n    cout<<\"Square root of \"<<a<<\" is \"<<searchSpace(a)<<\".\\\\n\"<<endl;\\n\\n}\\n"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "int mySqrt(int x) {\n        int i=1;\n        if(x==0)\n            return 0;\n        while(i<=x){\n            if(x==i*i)\n                return i;\n            else if(x>(i*i) && x<(i+1)*(i+1))\n                return i;\n            else\n                i++;\n        }\n    \n    return -1;\n    }\n\n**How to rectify the signed integer overflow problem??\n"
                    },
                    {
                        "username": "kaustubhrajput",
                        "content": "Bruteforce gave O(N) while when we used Binary Search we got O(log n).\\nThis is the application of Binary search."
                    },
                    {
                        "username": "nachiket-s",
                        "content": "Can someone pls suggest me the syntax to use recursion in python. I am familiar with recursion in regular python code but \\'class solution(object)\\' and usage of \\'self\\' for function confuses me"
                    },
                    {
                        "username": "sharmamuskan296",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    long long int binarysearch(int n ){\\n        int s = 0;\\n        int e = n;\\n        long long int m = s+(e-s)/2;\\n        long long int ans = -1;\\n\\n        while (s<=e){\\n            long long int sq = m * m; //range fatt gyi \\n            if (sq == n){\\n                return m;\\n            }\\n            if (sq < n){\\n                ans = m;\\n                s = m + 1;\\n            }\\n            else {\\n                e = m - 1;\\n            }\\n        m = s + (e - s) / 2;\\n        }\\n    return ans ;\\n    }\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "Sorry I am cringe\n\n    def mySqrt(self, x: int) -> int:\n        return int(sqrt(x))"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "very very easy for beginner or senior"
                    },
                    {
                        "username": "dzhang1238",
                        "content": "class Solution {\\n    public int mySqrt(int x) {\\n        int mid_num = x/2;\\n\\n        while ( (mid_num * mid_num) > x){\\n            mid_num /= 2;\\n        }\\n\\n        while ( (mid_num * mid_num) <= x ){\\n            mid_num += 1;\\n        }\\n\\n        return mid_num-1;\\n    }\\n}\\n\\nIs it because the integer overflow so it won\\'t work?"
                    }
                ]
            },
            {
                "id": 1697020,
                "content": [
                    {
                        "username": "Rawan_Rababah",
                        "content": "TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 42 in _driver (Solution.py)\\n    _driver()\\nLine 48 in <module> (Solution.py)\\n\\n\\nthe run is accepted but when i click om submit , the massage above show ??\\nwho know the solution >??"
                    },
                    {
                        "username": "hegdeanirudh2003",
                        "content": "what is time complexity for this solution:\\nimport math\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        return int(math.sqrt(x))"
                    },
                    {
                        "username": "user9177eE",
                        "content": "Why this solution is correct?\\nclass Solution {\\npublic:\\n\\n    long long int binarySearch(int x){\\n        \\n\\n        int s = 0;\\n        int e = x;\\n        long long int mid = s + (e-s)/2;\\n\\n        long long int ans = -1;\\n\\n        while(s<=e){\\n            long long int z = mid*mid;\\n\\n            if(z == x){\\n                return mid;\\n            }\\n            else if(z<x){\\n                s = mid+1;\\n                ans = mid;\\n            }\\n            else{\\n                e = mid-1;\\n            }\\n\\n            mid = s + (e-s)/2;\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n    int mySqrt(int x) {\\n        return binarySearch(x);\\n    }\\n};\\n\\n\\nI mean there is no even array in the code to apply binary search on .\\n\\n\\nWhereas I have written this code on my vs code(ignore that long long int thing), but atleast it has proper logic.\\n#include<iostream>\\nusing namespace std;\\n\\nint searchSpace(int a){\\n    int arr[a+1];\\n    for(int i=0; i<=a; i++){\\n        arr[i]=i;\\n    }\\n\\n    int s=0;\\n    int e=a;\\n    int mid = s + (e-s)/2;\\n\\n    while(s<=e){\\n        int x = mid*mid;\\n\\n        if(x == a){\\n            return arr[mid];\\n            \\n        }\\n        \\n        else if(x<a){\\n            s = mid+1;\\n        }\\n\\n        else{\\n            e = mid-1;\\n        }\\n\\n        mid = s + (e-s)/2;\\n    }\\n\\n    return arr[mid-1];\\n\\n}\\n\\n\\nint main(){\\n\\n    int a;\\n    cout<<\"Enter a number: \";\\n    cin>>a;\\n\\n    cout<<\"Square root of \"<<a<<\" is \"<<searchSpace(a)<<\".\\\\n\"<<endl;\\n\\n}\\n"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "int mySqrt(int x) {\n        int i=1;\n        if(x==0)\n            return 0;\n        while(i<=x){\n            if(x==i*i)\n                return i;\n            else if(x>(i*i) && x<(i+1)*(i+1))\n                return i;\n            else\n                i++;\n        }\n    \n    return -1;\n    }\n\n**How to rectify the signed integer overflow problem??\n"
                    },
                    {
                        "username": "kaustubhrajput",
                        "content": "Bruteforce gave O(N) while when we used Binary Search we got O(log n).\\nThis is the application of Binary search."
                    },
                    {
                        "username": "nachiket-s",
                        "content": "Can someone pls suggest me the syntax to use recursion in python. I am familiar with recursion in regular python code but \\'class solution(object)\\' and usage of \\'self\\' for function confuses me"
                    },
                    {
                        "username": "sharmamuskan296",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    long long int binarysearch(int n ){\\n        int s = 0;\\n        int e = n;\\n        long long int m = s+(e-s)/2;\\n        long long int ans = -1;\\n\\n        while (s<=e){\\n            long long int sq = m * m; //range fatt gyi \\n            if (sq == n){\\n                return m;\\n            }\\n            if (sq < n){\\n                ans = m;\\n                s = m + 1;\\n            }\\n            else {\\n                e = m - 1;\\n            }\\n        m = s + (e - s) / 2;\\n        }\\n    return ans ;\\n    }\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "Sorry I am cringe\n\n    def mySqrt(self, x: int) -> int:\n        return int(sqrt(x))"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "very very easy for beginner or senior"
                    },
                    {
                        "username": "dzhang1238",
                        "content": "class Solution {\\n    public int mySqrt(int x) {\\n        int mid_num = x/2;\\n\\n        while ( (mid_num * mid_num) > x){\\n            mid_num /= 2;\\n        }\\n\\n        while ( (mid_num * mid_num) <= x ){\\n            mid_num += 1;\\n        }\\n\\n        return mid_num-1;\\n    }\\n}\\n\\nIs it because the integer overflow so it won\\'t work?"
                    }
                ]
            },
            {
                "id": 1696727,
                "content": [
                    {
                        "username": "Rawan_Rababah",
                        "content": "TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 42 in _driver (Solution.py)\\n    _driver()\\nLine 48 in <module> (Solution.py)\\n\\n\\nthe run is accepted but when i click om submit , the massage above show ??\\nwho know the solution >??"
                    },
                    {
                        "username": "hegdeanirudh2003",
                        "content": "what is time complexity for this solution:\\nimport math\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        return int(math.sqrt(x))"
                    },
                    {
                        "username": "user9177eE",
                        "content": "Why this solution is correct?\\nclass Solution {\\npublic:\\n\\n    long long int binarySearch(int x){\\n        \\n\\n        int s = 0;\\n        int e = x;\\n        long long int mid = s + (e-s)/2;\\n\\n        long long int ans = -1;\\n\\n        while(s<=e){\\n            long long int z = mid*mid;\\n\\n            if(z == x){\\n                return mid;\\n            }\\n            else if(z<x){\\n                s = mid+1;\\n                ans = mid;\\n            }\\n            else{\\n                e = mid-1;\\n            }\\n\\n            mid = s + (e-s)/2;\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n    int mySqrt(int x) {\\n        return binarySearch(x);\\n    }\\n};\\n\\n\\nI mean there is no even array in the code to apply binary search on .\\n\\n\\nWhereas I have written this code on my vs code(ignore that long long int thing), but atleast it has proper logic.\\n#include<iostream>\\nusing namespace std;\\n\\nint searchSpace(int a){\\n    int arr[a+1];\\n    for(int i=0; i<=a; i++){\\n        arr[i]=i;\\n    }\\n\\n    int s=0;\\n    int e=a;\\n    int mid = s + (e-s)/2;\\n\\n    while(s<=e){\\n        int x = mid*mid;\\n\\n        if(x == a){\\n            return arr[mid];\\n            \\n        }\\n        \\n        else if(x<a){\\n            s = mid+1;\\n        }\\n\\n        else{\\n            e = mid-1;\\n        }\\n\\n        mid = s + (e-s)/2;\\n    }\\n\\n    return arr[mid-1];\\n\\n}\\n\\n\\nint main(){\\n\\n    int a;\\n    cout<<\"Enter a number: \";\\n    cin>>a;\\n\\n    cout<<\"Square root of \"<<a<<\" is \"<<searchSpace(a)<<\".\\\\n\"<<endl;\\n\\n}\\n"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "int mySqrt(int x) {\n        int i=1;\n        if(x==0)\n            return 0;\n        while(i<=x){\n            if(x==i*i)\n                return i;\n            else if(x>(i*i) && x<(i+1)*(i+1))\n                return i;\n            else\n                i++;\n        }\n    \n    return -1;\n    }\n\n**How to rectify the signed integer overflow problem??\n"
                    },
                    {
                        "username": "kaustubhrajput",
                        "content": "Bruteforce gave O(N) while when we used Binary Search we got O(log n).\\nThis is the application of Binary search."
                    },
                    {
                        "username": "nachiket-s",
                        "content": "Can someone pls suggest me the syntax to use recursion in python. I am familiar with recursion in regular python code but \\'class solution(object)\\' and usage of \\'self\\' for function confuses me"
                    },
                    {
                        "username": "sharmamuskan296",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    long long int binarysearch(int n ){\\n        int s = 0;\\n        int e = n;\\n        long long int m = s+(e-s)/2;\\n        long long int ans = -1;\\n\\n        while (s<=e){\\n            long long int sq = m * m; //range fatt gyi \\n            if (sq == n){\\n                return m;\\n            }\\n            if (sq < n){\\n                ans = m;\\n                s = m + 1;\\n            }\\n            else {\\n                e = m - 1;\\n            }\\n        m = s + (e - s) / 2;\\n        }\\n    return ans ;\\n    }\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "Sorry I am cringe\n\n    def mySqrt(self, x: int) -> int:\n        return int(sqrt(x))"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "very very easy for beginner or senior"
                    },
                    {
                        "username": "dzhang1238",
                        "content": "class Solution {\\n    public int mySqrt(int x) {\\n        int mid_num = x/2;\\n\\n        while ( (mid_num * mid_num) > x){\\n            mid_num /= 2;\\n        }\\n\\n        while ( (mid_num * mid_num) <= x ){\\n            mid_num += 1;\\n        }\\n\\n        return mid_num-1;\\n    }\\n}\\n\\nIs it because the integer overflow so it won\\'t work?"
                    }
                ]
            },
            {
                "id": 1693401,
                "content": [
                    {
                        "username": "Rawan_Rababah",
                        "content": "TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 42 in _driver (Solution.py)\\n    _driver()\\nLine 48 in <module> (Solution.py)\\n\\n\\nthe run is accepted but when i click om submit , the massage above show ??\\nwho know the solution >??"
                    },
                    {
                        "username": "hegdeanirudh2003",
                        "content": "what is time complexity for this solution:\\nimport math\\nclass Solution:\\n    def mySqrt(self, x: int) -> int:\\n        return int(math.sqrt(x))"
                    },
                    {
                        "username": "user9177eE",
                        "content": "Why this solution is correct?\\nclass Solution {\\npublic:\\n\\n    long long int binarySearch(int x){\\n        \\n\\n        int s = 0;\\n        int e = x;\\n        long long int mid = s + (e-s)/2;\\n\\n        long long int ans = -1;\\n\\n        while(s<=e){\\n            long long int z = mid*mid;\\n\\n            if(z == x){\\n                return mid;\\n            }\\n            else if(z<x){\\n                s = mid+1;\\n                ans = mid;\\n            }\\n            else{\\n                e = mid-1;\\n            }\\n\\n            mid = s + (e-s)/2;\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n    int mySqrt(int x) {\\n        return binarySearch(x);\\n    }\\n};\\n\\n\\nI mean there is no even array in the code to apply binary search on .\\n\\n\\nWhereas I have written this code on my vs code(ignore that long long int thing), but atleast it has proper logic.\\n#include<iostream>\\nusing namespace std;\\n\\nint searchSpace(int a){\\n    int arr[a+1];\\n    for(int i=0; i<=a; i++){\\n        arr[i]=i;\\n    }\\n\\n    int s=0;\\n    int e=a;\\n    int mid = s + (e-s)/2;\\n\\n    while(s<=e){\\n        int x = mid*mid;\\n\\n        if(x == a){\\n            return arr[mid];\\n            \\n        }\\n        \\n        else if(x<a){\\n            s = mid+1;\\n        }\\n\\n        else{\\n            e = mid-1;\\n        }\\n\\n        mid = s + (e-s)/2;\\n    }\\n\\n    return arr[mid-1];\\n\\n}\\n\\n\\nint main(){\\n\\n    int a;\\n    cout<<\"Enter a number: \";\\n    cin>>a;\\n\\n    cout<<\"Square root of \"<<a<<\" is \"<<searchSpace(a)<<\".\\\\n\"<<endl;\\n\\n}\\n"
                    },
                    {
                        "username": "Jkpgiitian",
                        "content": "int mySqrt(int x) {\n        int i=1;\n        if(x==0)\n            return 0;\n        while(i<=x){\n            if(x==i*i)\n                return i;\n            else if(x>(i*i) && x<(i+1)*(i+1))\n                return i;\n            else\n                i++;\n        }\n    \n    return -1;\n    }\n\n**How to rectify the signed integer overflow problem??\n"
                    },
                    {
                        "username": "kaustubhrajput",
                        "content": "Bruteforce gave O(N) while when we used Binary Search we got O(log n).\\nThis is the application of Binary search."
                    },
                    {
                        "username": "nachiket-s",
                        "content": "Can someone pls suggest me the syntax to use recursion in python. I am familiar with recursion in regular python code but \\'class solution(object)\\' and usage of \\'self\\' for function confuses me"
                    },
                    {
                        "username": "sharmamuskan296",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    long long int binarysearch(int n ){\\n        int s = 0;\\n        int e = n;\\n        long long int m = s+(e-s)/2;\\n        long long int ans = -1;\\n\\n        while (s<=e){\\n            long long int sq = m * m; //range fatt gyi \\n            if (sq == n){\\n                return m;\\n            }\\n            if (sq < n){\\n                ans = m;\\n                s = m + 1;\\n            }\\n            else {\\n                e = m - 1;\\n            }\\n        m = s + (e - s) / 2;\\n        }\\n    return ans ;\\n    }\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shabareesharyan",
                        "content": "Sorry I am cringe\n\n    def mySqrt(self, x: int) -> int:\n        return int(sqrt(x))"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "very very easy for beginner or senior"
                    },
                    {
                        "username": "dzhang1238",
                        "content": "class Solution {\\n    public int mySqrt(int x) {\\n        int mid_num = x/2;\\n\\n        while ( (mid_num * mid_num) > x){\\n            mid_num /= 2;\\n        }\\n\\n        while ( (mid_num * mid_num) <= x ){\\n            mid_num += 1;\\n        }\\n\\n        return mid_num-1;\\n    }\\n}\\n\\nIs it because the integer overflow so it won\\'t work?"
                    }
                ]
            },
            {
                "id": 1692009,
                "content": [
                    {
                        "username": "anubhavnegi54",
                        "content": "Take care of integer overflow guys"
                    },
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def mySqrt(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: int\\n        \"\"\"\\n        result = float(x) ** (0.5)\\n        return int(result)"
                    },
                    {
                        "username": "Khushali_",
                        "content": "I  am unable to understand this behavior, when we give x as 2147395600 it gives output as 289398. How it is possible, as per the condition in the while loop. As it would exceed the value of x. \\n\\nCan anyone explain?\\n\\npublic static int mySqrt(int x) {\\n        int i = 1;\\n        if(x==1){\\n            return 1;\\n        }\\n\\n        while (i*i <= x){\\n            System.out.println(\"Square of \"+ i + \" :\" + i*i);\\n            i++;\\n        }\\n        return i-1;\\n    }"
                    },
                    {
                        "username": "thisisahtesham",
                        "content": "just use sqrt() in c++  :) easiest solution lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "akashdwivedi563",
                        "content": "HI here is my java solution using Binary search \\n`public int mySqrt(int x) {\\n        if (x < 2)\\n            return x;\\n        int end = x / 2;\\n        int start = 1;\\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n            if ((long) mid * mid > x) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return end;\\n    }`"
                    },
                    {
                        "username": "damacaner",
                        "content": "> You must not use any built-in exponent function or operator.\\n\\nYou must or you should? cause this works for GoLang kek.\\n `return int(math.Floor(math.Sqrt(float64(x))))`"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "Using BS\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int num) {\\n    int start = 0, end = num-1;\\n    long long int mid = start + (end-start)/2,ans=-1;\\n    if(num==0||num==1){\\n        return num;\\n    }\\n    while (start<=end)\\n    {\\n        if(mid*mid>num){\\n            end = mid-1;\\n        }\\n        else if(mid*mid<=num){\\n            ans = max(ans,mid);\\n            start = mid +1;\\n        }\\n       mid = start + (end-start)/2;\\n    }\\n     return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "soumyamaheshwari",
                        "content": "when mid*mid will be done it will go out of the range of int so that is why we will use long long int"
                    },
                    {
                        "username": "avnish39cs",
                        "content": "class Solution {\\npublic:\\nlong long int binarysearch(int n){\\n  int s=0,e=n;\\n        long long int mid=s+(e-s)/2;\\n        long long int ans=-1;\\n        while(s<=e){\\n            long long int square=mid*mid;\\n            if(square==n){\\n                return mid;\\n            }\\n            if(square<n){\\n                ans=mid;\\n                s=mid+1;            \\n        }\\n        else{\\n            e=mid-1;\\n        }\\n        mid=s+(e-s)/2;\\n        \\n    }\\n    return ans;\\n\\n}\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n    }\\n};\\n      "
                    }
                ]
            },
            {
                "id": 1691079,
                "content": [
                    {
                        "username": "anubhavnegi54",
                        "content": "Take care of integer overflow guys"
                    },
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def mySqrt(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: int\\n        \"\"\"\\n        result = float(x) ** (0.5)\\n        return int(result)"
                    },
                    {
                        "username": "Khushali_",
                        "content": "I  am unable to understand this behavior, when we give x as 2147395600 it gives output as 289398. How it is possible, as per the condition in the while loop. As it would exceed the value of x. \\n\\nCan anyone explain?\\n\\npublic static int mySqrt(int x) {\\n        int i = 1;\\n        if(x==1){\\n            return 1;\\n        }\\n\\n        while (i*i <= x){\\n            System.out.println(\"Square of \"+ i + \" :\" + i*i);\\n            i++;\\n        }\\n        return i-1;\\n    }"
                    },
                    {
                        "username": "thisisahtesham",
                        "content": "just use sqrt() in c++  :) easiest solution lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "akashdwivedi563",
                        "content": "HI here is my java solution using Binary search \\n`public int mySqrt(int x) {\\n        if (x < 2)\\n            return x;\\n        int end = x / 2;\\n        int start = 1;\\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n            if ((long) mid * mid > x) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return end;\\n    }`"
                    },
                    {
                        "username": "damacaner",
                        "content": "> You must not use any built-in exponent function or operator.\\n\\nYou must or you should? cause this works for GoLang kek.\\n `return int(math.Floor(math.Sqrt(float64(x))))`"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "Using BS\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int num) {\\n    int start = 0, end = num-1;\\n    long long int mid = start + (end-start)/2,ans=-1;\\n    if(num==0||num==1){\\n        return num;\\n    }\\n    while (start<=end)\\n    {\\n        if(mid*mid>num){\\n            end = mid-1;\\n        }\\n        else if(mid*mid<=num){\\n            ans = max(ans,mid);\\n            start = mid +1;\\n        }\\n       mid = start + (end-start)/2;\\n    }\\n     return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "soumyamaheshwari",
                        "content": "when mid*mid will be done it will go out of the range of int so that is why we will use long long int"
                    },
                    {
                        "username": "avnish39cs",
                        "content": "class Solution {\\npublic:\\nlong long int binarysearch(int n){\\n  int s=0,e=n;\\n        long long int mid=s+(e-s)/2;\\n        long long int ans=-1;\\n        while(s<=e){\\n            long long int square=mid*mid;\\n            if(square==n){\\n                return mid;\\n            }\\n            if(square<n){\\n                ans=mid;\\n                s=mid+1;            \\n        }\\n        else{\\n            e=mid-1;\\n        }\\n        mid=s+(e-s)/2;\\n        \\n    }\\n    return ans;\\n\\n}\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n    }\\n};\\n      "
                    }
                ]
            },
            {
                "id": 1687241,
                "content": [
                    {
                        "username": "anubhavnegi54",
                        "content": "Take care of integer overflow guys"
                    },
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def mySqrt(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: int\\n        \"\"\"\\n        result = float(x) ** (0.5)\\n        return int(result)"
                    },
                    {
                        "username": "Khushali_",
                        "content": "I  am unable to understand this behavior, when we give x as 2147395600 it gives output as 289398. How it is possible, as per the condition in the while loop. As it would exceed the value of x. \\n\\nCan anyone explain?\\n\\npublic static int mySqrt(int x) {\\n        int i = 1;\\n        if(x==1){\\n            return 1;\\n        }\\n\\n        while (i*i <= x){\\n            System.out.println(\"Square of \"+ i + \" :\" + i*i);\\n            i++;\\n        }\\n        return i-1;\\n    }"
                    },
                    {
                        "username": "thisisahtesham",
                        "content": "just use sqrt() in c++  :) easiest solution lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "akashdwivedi563",
                        "content": "HI here is my java solution using Binary search \\n`public int mySqrt(int x) {\\n        if (x < 2)\\n            return x;\\n        int end = x / 2;\\n        int start = 1;\\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n            if ((long) mid * mid > x) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return end;\\n    }`"
                    },
                    {
                        "username": "damacaner",
                        "content": "> You must not use any built-in exponent function or operator.\\n\\nYou must or you should? cause this works for GoLang kek.\\n `return int(math.Floor(math.Sqrt(float64(x))))`"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "Using BS\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int num) {\\n    int start = 0, end = num-1;\\n    long long int mid = start + (end-start)/2,ans=-1;\\n    if(num==0||num==1){\\n        return num;\\n    }\\n    while (start<=end)\\n    {\\n        if(mid*mid>num){\\n            end = mid-1;\\n        }\\n        else if(mid*mid<=num){\\n            ans = max(ans,mid);\\n            start = mid +1;\\n        }\\n       mid = start + (end-start)/2;\\n    }\\n     return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "soumyamaheshwari",
                        "content": "when mid*mid will be done it will go out of the range of int so that is why we will use long long int"
                    },
                    {
                        "username": "avnish39cs",
                        "content": "class Solution {\\npublic:\\nlong long int binarysearch(int n){\\n  int s=0,e=n;\\n        long long int mid=s+(e-s)/2;\\n        long long int ans=-1;\\n        while(s<=e){\\n            long long int square=mid*mid;\\n            if(square==n){\\n                return mid;\\n            }\\n            if(square<n){\\n                ans=mid;\\n                s=mid+1;            \\n        }\\n        else{\\n            e=mid-1;\\n        }\\n        mid=s+(e-s)/2;\\n        \\n    }\\n    return ans;\\n\\n}\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n    }\\n};\\n      "
                    }
                ]
            },
            {
                "id": 1686773,
                "content": [
                    {
                        "username": "anubhavnegi54",
                        "content": "Take care of integer overflow guys"
                    },
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def mySqrt(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: int\\n        \"\"\"\\n        result = float(x) ** (0.5)\\n        return int(result)"
                    },
                    {
                        "username": "Khushali_",
                        "content": "I  am unable to understand this behavior, when we give x as 2147395600 it gives output as 289398. How it is possible, as per the condition in the while loop. As it would exceed the value of x. \\n\\nCan anyone explain?\\n\\npublic static int mySqrt(int x) {\\n        int i = 1;\\n        if(x==1){\\n            return 1;\\n        }\\n\\n        while (i*i <= x){\\n            System.out.println(\"Square of \"+ i + \" :\" + i*i);\\n            i++;\\n        }\\n        return i-1;\\n    }"
                    },
                    {
                        "username": "thisisahtesham",
                        "content": "just use sqrt() in c++  :) easiest solution lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "akashdwivedi563",
                        "content": "HI here is my java solution using Binary search \\n`public int mySqrt(int x) {\\n        if (x < 2)\\n            return x;\\n        int end = x / 2;\\n        int start = 1;\\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n            if ((long) mid * mid > x) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return end;\\n    }`"
                    },
                    {
                        "username": "damacaner",
                        "content": "> You must not use any built-in exponent function or operator.\\n\\nYou must or you should? cause this works for GoLang kek.\\n `return int(math.Floor(math.Sqrt(float64(x))))`"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "Using BS\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int num) {\\n    int start = 0, end = num-1;\\n    long long int mid = start + (end-start)/2,ans=-1;\\n    if(num==0||num==1){\\n        return num;\\n    }\\n    while (start<=end)\\n    {\\n        if(mid*mid>num){\\n            end = mid-1;\\n        }\\n        else if(mid*mid<=num){\\n            ans = max(ans,mid);\\n            start = mid +1;\\n        }\\n       mid = start + (end-start)/2;\\n    }\\n     return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "soumyamaheshwari",
                        "content": "when mid*mid will be done it will go out of the range of int so that is why we will use long long int"
                    },
                    {
                        "username": "avnish39cs",
                        "content": "class Solution {\\npublic:\\nlong long int binarysearch(int n){\\n  int s=0,e=n;\\n        long long int mid=s+(e-s)/2;\\n        long long int ans=-1;\\n        while(s<=e){\\n            long long int square=mid*mid;\\n            if(square==n){\\n                return mid;\\n            }\\n            if(square<n){\\n                ans=mid;\\n                s=mid+1;            \\n        }\\n        else{\\n            e=mid-1;\\n        }\\n        mid=s+(e-s)/2;\\n        \\n    }\\n    return ans;\\n\\n}\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n    }\\n};\\n      "
                    }
                ]
            },
            {
                "id": 1684588,
                "content": [
                    {
                        "username": "anubhavnegi54",
                        "content": "Take care of integer overflow guys"
                    },
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def mySqrt(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: int\\n        \"\"\"\\n        result = float(x) ** (0.5)\\n        return int(result)"
                    },
                    {
                        "username": "Khushali_",
                        "content": "I  am unable to understand this behavior, when we give x as 2147395600 it gives output as 289398. How it is possible, as per the condition in the while loop. As it would exceed the value of x. \\n\\nCan anyone explain?\\n\\npublic static int mySqrt(int x) {\\n        int i = 1;\\n        if(x==1){\\n            return 1;\\n        }\\n\\n        while (i*i <= x){\\n            System.out.println(\"Square of \"+ i + \" :\" + i*i);\\n            i++;\\n        }\\n        return i-1;\\n    }"
                    },
                    {
                        "username": "thisisahtesham",
                        "content": "just use sqrt() in c++  :) easiest solution lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "akashdwivedi563",
                        "content": "HI here is my java solution using Binary search \\n`public int mySqrt(int x) {\\n        if (x < 2)\\n            return x;\\n        int end = x / 2;\\n        int start = 1;\\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n            if ((long) mid * mid > x) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return end;\\n    }`"
                    },
                    {
                        "username": "damacaner",
                        "content": "> You must not use any built-in exponent function or operator.\\n\\nYou must or you should? cause this works for GoLang kek.\\n `return int(math.Floor(math.Sqrt(float64(x))))`"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "Using BS\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int num) {\\n    int start = 0, end = num-1;\\n    long long int mid = start + (end-start)/2,ans=-1;\\n    if(num==0||num==1){\\n        return num;\\n    }\\n    while (start<=end)\\n    {\\n        if(mid*mid>num){\\n            end = mid-1;\\n        }\\n        else if(mid*mid<=num){\\n            ans = max(ans,mid);\\n            start = mid +1;\\n        }\\n       mid = start + (end-start)/2;\\n    }\\n     return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "soumyamaheshwari",
                        "content": "when mid*mid will be done it will go out of the range of int so that is why we will use long long int"
                    },
                    {
                        "username": "avnish39cs",
                        "content": "class Solution {\\npublic:\\nlong long int binarysearch(int n){\\n  int s=0,e=n;\\n        long long int mid=s+(e-s)/2;\\n        long long int ans=-1;\\n        while(s<=e){\\n            long long int square=mid*mid;\\n            if(square==n){\\n                return mid;\\n            }\\n            if(square<n){\\n                ans=mid;\\n                s=mid+1;            \\n        }\\n        else{\\n            e=mid-1;\\n        }\\n        mid=s+(e-s)/2;\\n        \\n    }\\n    return ans;\\n\\n}\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n    }\\n};\\n      "
                    }
                ]
            },
            {
                "id": 1684188,
                "content": [
                    {
                        "username": "anubhavnegi54",
                        "content": "Take care of integer overflow guys"
                    },
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def mySqrt(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: int\\n        \"\"\"\\n        result = float(x) ** (0.5)\\n        return int(result)"
                    },
                    {
                        "username": "Khushali_",
                        "content": "I  am unable to understand this behavior, when we give x as 2147395600 it gives output as 289398. How it is possible, as per the condition in the while loop. As it would exceed the value of x. \\n\\nCan anyone explain?\\n\\npublic static int mySqrt(int x) {\\n        int i = 1;\\n        if(x==1){\\n            return 1;\\n        }\\n\\n        while (i*i <= x){\\n            System.out.println(\"Square of \"+ i + \" :\" + i*i);\\n            i++;\\n        }\\n        return i-1;\\n    }"
                    },
                    {
                        "username": "thisisahtesham",
                        "content": "just use sqrt() in c++  :) easiest solution lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "akashdwivedi563",
                        "content": "HI here is my java solution using Binary search \\n`public int mySqrt(int x) {\\n        if (x < 2)\\n            return x;\\n        int end = x / 2;\\n        int start = 1;\\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n            if ((long) mid * mid > x) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return end;\\n    }`"
                    },
                    {
                        "username": "damacaner",
                        "content": "> You must not use any built-in exponent function or operator.\\n\\nYou must or you should? cause this works for GoLang kek.\\n `return int(math.Floor(math.Sqrt(float64(x))))`"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "Using BS\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int num) {\\n    int start = 0, end = num-1;\\n    long long int mid = start + (end-start)/2,ans=-1;\\n    if(num==0||num==1){\\n        return num;\\n    }\\n    while (start<=end)\\n    {\\n        if(mid*mid>num){\\n            end = mid-1;\\n        }\\n        else if(mid*mid<=num){\\n            ans = max(ans,mid);\\n            start = mid +1;\\n        }\\n       mid = start + (end-start)/2;\\n    }\\n     return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "soumyamaheshwari",
                        "content": "when mid*mid will be done it will go out of the range of int so that is why we will use long long int"
                    },
                    {
                        "username": "avnish39cs",
                        "content": "class Solution {\\npublic:\\nlong long int binarysearch(int n){\\n  int s=0,e=n;\\n        long long int mid=s+(e-s)/2;\\n        long long int ans=-1;\\n        while(s<=e){\\n            long long int square=mid*mid;\\n            if(square==n){\\n                return mid;\\n            }\\n            if(square<n){\\n                ans=mid;\\n                s=mid+1;            \\n        }\\n        else{\\n            e=mid-1;\\n        }\\n        mid=s+(e-s)/2;\\n        \\n    }\\n    return ans;\\n\\n}\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n    }\\n};\\n      "
                    }
                ]
            },
            {
                "id": 1667238,
                "content": [
                    {
                        "username": "anubhavnegi54",
                        "content": "Take care of integer overflow guys"
                    },
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def mySqrt(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: int\\n        \"\"\"\\n        result = float(x) ** (0.5)\\n        return int(result)"
                    },
                    {
                        "username": "Khushali_",
                        "content": "I  am unable to understand this behavior, when we give x as 2147395600 it gives output as 289398. How it is possible, as per the condition in the while loop. As it would exceed the value of x. \\n\\nCan anyone explain?\\n\\npublic static int mySqrt(int x) {\\n        int i = 1;\\n        if(x==1){\\n            return 1;\\n        }\\n\\n        while (i*i <= x){\\n            System.out.println(\"Square of \"+ i + \" :\" + i*i);\\n            i++;\\n        }\\n        return i-1;\\n    }"
                    },
                    {
                        "username": "thisisahtesham",
                        "content": "just use sqrt() in c++  :) easiest solution lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "akashdwivedi563",
                        "content": "HI here is my java solution using Binary search \\n`public int mySqrt(int x) {\\n        if (x < 2)\\n            return x;\\n        int end = x / 2;\\n        int start = 1;\\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n            if ((long) mid * mid > x) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return end;\\n    }`"
                    },
                    {
                        "username": "damacaner",
                        "content": "> You must not use any built-in exponent function or operator.\\n\\nYou must or you should? cause this works for GoLang kek.\\n `return int(math.Floor(math.Sqrt(float64(x))))`"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "Using BS\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int num) {\\n    int start = 0, end = num-1;\\n    long long int mid = start + (end-start)/2,ans=-1;\\n    if(num==0||num==1){\\n        return num;\\n    }\\n    while (start<=end)\\n    {\\n        if(mid*mid>num){\\n            end = mid-1;\\n        }\\n        else if(mid*mid<=num){\\n            ans = max(ans,mid);\\n            start = mid +1;\\n        }\\n       mid = start + (end-start)/2;\\n    }\\n     return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "soumyamaheshwari",
                        "content": "when mid*mid will be done it will go out of the range of int so that is why we will use long long int"
                    },
                    {
                        "username": "avnish39cs",
                        "content": "class Solution {\\npublic:\\nlong long int binarysearch(int n){\\n  int s=0,e=n;\\n        long long int mid=s+(e-s)/2;\\n        long long int ans=-1;\\n        while(s<=e){\\n            long long int square=mid*mid;\\n            if(square==n){\\n                return mid;\\n            }\\n            if(square<n){\\n                ans=mid;\\n                s=mid+1;            \\n        }\\n        else{\\n            e=mid-1;\\n        }\\n        mid=s+(e-s)/2;\\n        \\n    }\\n    return ans;\\n\\n}\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n    }\\n};\\n      "
                    }
                ]
            },
            {
                "id": 1644819,
                "content": [
                    {
                        "username": "anubhavnegi54",
                        "content": "Take care of integer overflow guys"
                    },
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def mySqrt(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: int\\n        \"\"\"\\n        result = float(x) ** (0.5)\\n        return int(result)"
                    },
                    {
                        "username": "Khushali_",
                        "content": "I  am unable to understand this behavior, when we give x as 2147395600 it gives output as 289398. How it is possible, as per the condition in the while loop. As it would exceed the value of x. \\n\\nCan anyone explain?\\n\\npublic static int mySqrt(int x) {\\n        int i = 1;\\n        if(x==1){\\n            return 1;\\n        }\\n\\n        while (i*i <= x){\\n            System.out.println(\"Square of \"+ i + \" :\" + i*i);\\n            i++;\\n        }\\n        return i-1;\\n    }"
                    },
                    {
                        "username": "thisisahtesham",
                        "content": "just use sqrt() in c++  :) easiest solution lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "akashdwivedi563",
                        "content": "HI here is my java solution using Binary search \\n`public int mySqrt(int x) {\\n        if (x < 2)\\n            return x;\\n        int end = x / 2;\\n        int start = 1;\\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n            if ((long) mid * mid > x) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return end;\\n    }`"
                    },
                    {
                        "username": "damacaner",
                        "content": "> You must not use any built-in exponent function or operator.\\n\\nYou must or you should? cause this works for GoLang kek.\\n `return int(math.Floor(math.Sqrt(float64(x))))`"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "Using BS\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int num) {\\n    int start = 0, end = num-1;\\n    long long int mid = start + (end-start)/2,ans=-1;\\n    if(num==0||num==1){\\n        return num;\\n    }\\n    while (start<=end)\\n    {\\n        if(mid*mid>num){\\n            end = mid-1;\\n        }\\n        else if(mid*mid<=num){\\n            ans = max(ans,mid);\\n            start = mid +1;\\n        }\\n       mid = start + (end-start)/2;\\n    }\\n     return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "soumyamaheshwari",
                        "content": "when mid*mid will be done it will go out of the range of int so that is why we will use long long int"
                    },
                    {
                        "username": "avnish39cs",
                        "content": "class Solution {\\npublic:\\nlong long int binarysearch(int n){\\n  int s=0,e=n;\\n        long long int mid=s+(e-s)/2;\\n        long long int ans=-1;\\n        while(s<=e){\\n            long long int square=mid*mid;\\n            if(square==n){\\n                return mid;\\n            }\\n            if(square<n){\\n                ans=mid;\\n                s=mid+1;            \\n        }\\n        else{\\n            e=mid-1;\\n        }\\n        mid=s+(e-s)/2;\\n        \\n    }\\n    return ans;\\n\\n}\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n    }\\n};\\n      "
                    }
                ]
            },
            {
                "id": 1638341,
                "content": [
                    {
                        "username": "anubhavnegi54",
                        "content": "Take care of integer overflow guys"
                    },
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def mySqrt(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: int\\n        \"\"\"\\n        result = float(x) ** (0.5)\\n        return int(result)"
                    },
                    {
                        "username": "Khushali_",
                        "content": "I  am unable to understand this behavior, when we give x as 2147395600 it gives output as 289398. How it is possible, as per the condition in the while loop. As it would exceed the value of x. \\n\\nCan anyone explain?\\n\\npublic static int mySqrt(int x) {\\n        int i = 1;\\n        if(x==1){\\n            return 1;\\n        }\\n\\n        while (i*i <= x){\\n            System.out.println(\"Square of \"+ i + \" :\" + i*i);\\n            i++;\\n        }\\n        return i-1;\\n    }"
                    },
                    {
                        "username": "thisisahtesham",
                        "content": "just use sqrt() in c++  :) easiest solution lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "akashdwivedi563",
                        "content": "HI here is my java solution using Binary search \\n`public int mySqrt(int x) {\\n        if (x < 2)\\n            return x;\\n        int end = x / 2;\\n        int start = 1;\\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n            if ((long) mid * mid > x) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return end;\\n    }`"
                    },
                    {
                        "username": "damacaner",
                        "content": "> You must not use any built-in exponent function or operator.\\n\\nYou must or you should? cause this works for GoLang kek.\\n `return int(math.Floor(math.Sqrt(float64(x))))`"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "Using BS\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int num) {\\n    int start = 0, end = num-1;\\n    long long int mid = start + (end-start)/2,ans=-1;\\n    if(num==0||num==1){\\n        return num;\\n    }\\n    while (start<=end)\\n    {\\n        if(mid*mid>num){\\n            end = mid-1;\\n        }\\n        else if(mid*mid<=num){\\n            ans = max(ans,mid);\\n            start = mid +1;\\n        }\\n       mid = start + (end-start)/2;\\n    }\\n     return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "soumyamaheshwari",
                        "content": "when mid*mid will be done it will go out of the range of int so that is why we will use long long int"
                    },
                    {
                        "username": "avnish39cs",
                        "content": "class Solution {\\npublic:\\nlong long int binarysearch(int n){\\n  int s=0,e=n;\\n        long long int mid=s+(e-s)/2;\\n        long long int ans=-1;\\n        while(s<=e){\\n            long long int square=mid*mid;\\n            if(square==n){\\n                return mid;\\n            }\\n            if(square<n){\\n                ans=mid;\\n                s=mid+1;            \\n        }\\n        else{\\n            e=mid-1;\\n        }\\n        mid=s+(e-s)/2;\\n        \\n    }\\n    return ans;\\n\\n}\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n    }\\n};\\n      "
                    }
                ]
            },
            {
                "id": 1633552,
                "content": [
                    {
                        "username": "anubhavnegi54",
                        "content": "Take care of integer overflow guys"
                    },
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def mySqrt(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: int\\n        \"\"\"\\n        result = float(x) ** (0.5)\\n        return int(result)"
                    },
                    {
                        "username": "Khushali_",
                        "content": "I  am unable to understand this behavior, when we give x as 2147395600 it gives output as 289398. How it is possible, as per the condition in the while loop. As it would exceed the value of x. \\n\\nCan anyone explain?\\n\\npublic static int mySqrt(int x) {\\n        int i = 1;\\n        if(x==1){\\n            return 1;\\n        }\\n\\n        while (i*i <= x){\\n            System.out.println(\"Square of \"+ i + \" :\" + i*i);\\n            i++;\\n        }\\n        return i-1;\\n    }"
                    },
                    {
                        "username": "thisisahtesham",
                        "content": "just use sqrt() in c++  :) easiest solution lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9[C++] FAANG \\uD83D\\uDE28 Interview Optimized code \\uD83D\\uDE31 INSANE\\nhttps://leetcode.com/problems/sqrtx/solutions/2266517/c-faang-interview-optimized-code-insane/"
                    },
                    {
                        "username": "akashdwivedi563",
                        "content": "HI here is my java solution using Binary search \\n`public int mySqrt(int x) {\\n        if (x < 2)\\n            return x;\\n        int end = x / 2;\\n        int start = 1;\\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n            if ((long) mid * mid > x) {\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return end;\\n    }`"
                    },
                    {
                        "username": "damacaner",
                        "content": "> You must not use any built-in exponent function or operator.\\n\\nYou must or you should? cause this works for GoLang kek.\\n `return int(math.Floor(math.Sqrt(float64(x))))`"
                    },
                    {
                        "username": "piratedjesus",
                        "content": "Using BS\\n\\nclass Solution {\\npublic:\\n    int mySqrt(int num) {\\n    int start = 0, end = num-1;\\n    long long int mid = start + (end-start)/2,ans=-1;\\n    if(num==0||num==1){\\n        return num;\\n    }\\n    while (start<=end)\\n    {\\n        if(mid*mid>num){\\n            end = mid-1;\\n        }\\n        else if(mid*mid<=num){\\n            ans = max(ans,mid);\\n            start = mid +1;\\n        }\\n       mid = start + (end-start)/2;\\n    }\\n     return ans;  \\n    }\\n};"
                    },
                    {
                        "username": "soumyamaheshwari",
                        "content": "when mid*mid will be done it will go out of the range of int so that is why we will use long long int"
                    },
                    {
                        "username": "avnish39cs",
                        "content": "class Solution {\\npublic:\\nlong long int binarysearch(int n){\\n  int s=0,e=n;\\n        long long int mid=s+(e-s)/2;\\n        long long int ans=-1;\\n        while(s<=e){\\n            long long int square=mid*mid;\\n            if(square==n){\\n                return mid;\\n            }\\n            if(square<n){\\n                ans=mid;\\n                s=mid+1;            \\n        }\\n        else{\\n            e=mid-1;\\n        }\\n        mid=s+(e-s)/2;\\n        \\n    }\\n    return ans;\\n\\n}\\n    int mySqrt(int x) {\\n        return binarysearch(x);\\n    }\\n};\\n      "
                    }
                ]
            }
        ]
    },
    {
        "title": "Majority Element",
        "question_content": "<p>Given an array <code>nums</code> of size <code>n</code>, return <em>the majority element</em>.</p>\n\n<p>The majority element is the element that appears more than <code>&lfloor;n / 2&rfloor;</code> times. You may assume that the majority element always exists in the array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [3,2,3]\n<strong>Output:</strong> 3\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [2,2,1,1,1,2,2]\n<strong>Output:</strong> 2\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow-up:</strong> Could you solve the problem in linear time and in <code>O(1)</code> space?",
        "solutions": [
            {
                "id": 51613,
                "title": "o-n-time-o-1-space-fastest-solution",
                "content": "    public class Solution {\\n        public int majorityElement(int[] num) {\\n\\n            int major=num[0], count = 1;\\n            for(int i=1; i<num.length;i++){\\n                if(count==0){\\n                    count++;\\n                    major=num[i];\\n                }else if(major==num[i]){\\n                    count++;\\n                }else count--;\\n                \\n            }\\n            return major;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int majorityElement(int[] num) {\\n\\n            int major=num[0], count = 1;\\n            for(int i=1; i<num.length;i++){\\n                if(count==0){\\n                    count++;\\n                    major=num[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 51612,
                "title": "c-6-solutions",
                "content": "**Hash Table**\\nCount the number of appearances for each distinct number in `nums`, once we see a number appear more than `n / 2` times, it is the majority element.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        unordered_map<int, int> counter;\\n        for (int num : nums) {\\n            if (++counter[num] > nums.size() / 2) {\\n                return num;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n**Sorting**\\nSince the majority element appears more than `n / 2` times, the `n / 2`-th element in the sorted `nums` must be the majority element. In this case, a partial sort by `nth_element` is enough.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        nth_element(nums.begin(), nums.begin() + nums.size() / 2, nums.end());\\n        return nums[nums.size() / 2];\\n    }\\n};\\n```\\n\\n**Randomization**\\nPick an element randomly and check whether it is the majority one.\\n\\n``` cpp\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int n = nums.size(), candidate, counter;\\n        srand(unsigned(time(NULL)));\\n        while (true) {\\n            candidate = nums[rand() % n], counter = 0;\\n            for (int num : nums) {\\n                if (num == candidate) {\\n                    counter++;\\n                }\\n            }\\n            if (counter > n / 2) {\\n                break;\\n            }\\n        }\\n        return candidate;\\n    }\\n};\\n```\\n\\n**Divide and Conquer**\\nRecursively find the majority in the two halves of `nums` and combine the results. The base case is that the majority element of a single-element array is just that element.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        return majority(nums, 0, nums.size() - 1);\\n    }\\nprivate:\\n    int majority(vector<int>& nums, int l, int r) {\\n        if (l == r) {\\n            return nums[l];\\n        }\\n        int m = l + (r - l) / 2, lm = majority(nums, l, m), rm = majority(nums, m + 1, r);\\n        if (lm == rm) {\\n            return lm;\\n        }\\n        return count(nums.begin() + l, nums.begin() + r + 1, lm) > count(nums.begin() + l, nums.begin() + r + 1, rm) ? lm : rm;\\n    }\\n}; \\n```\\n\\n**Moore Voting Algorithm**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int counter = 0, majority;\\n        for (int num : nums) {\\n            if (!counter) {\\n                majority = num;\\n            }\\n            counter += num == majority ? 1 : -1;\\n        }\\n        return majority;\\n    }\\n};\\n```\\n\\n**Bit Manipulation**\\nThe bits in the majority are just the majority bits of all numbers.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int majority = 0;\\n        for (unsigned int i = 0, mask = 1; i < 32; i++, mask <<= 1) {\\n            int bits = 0;\\n            for (int num : nums) {\\n                if (num & mask) {\\n                    bits++;\\n                }\\n            }\\n            if (bits > nums.size() / 2) {\\n                majority |= mask;\\n            }\\n        }\\n        return majority;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        unordered_map<int, int> counter;\\n        for (int num : nums) {\\n            if (++counter[num] > nums.size() / 2) {\\n                return num;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        nth_element(nums.begin(), nums.begin() + nums.size() / 2, nums.end());\\n        return nums[nums.size() / 2];\\n    }\\n};\\n```\n``` cpp\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int n = nums.size(), candidate, counter;\\n        srand(unsigned(time(NULL)));\\n        while (true) {\\n            candidate = nums[rand() % n], counter = 0;\\n            for (int num : nums) {\\n                if (num == candidate) {\\n                    counter++;\\n                }\\n            }\\n            if (counter > n / 2) {\\n                break;\\n            }\\n        }\\n        return candidate;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        return majority(nums, 0, nums.size() - 1);\\n    }\\nprivate:\\n    int majority(vector<int>& nums, int l, int r) {\\n        if (l == r) {\\n            return nums[l];\\n        }\\n        int m = l + (r - l) / 2, lm = majority(nums, l, m), rm = majority(nums, m + 1, r);\\n        if (lm == rm) {\\n            return lm;\\n        }\\n        return count(nums.begin() + l, nums.begin() + r + 1, lm) > count(nums.begin() + l, nums.begin() + r + 1, rm) ? lm : rm;\\n    }\\n}; \\n```\n```cpp\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int counter = 0, majority;\\n        for (int num : nums) {\\n            if (!counter) {\\n                majority = num;\\n            }\\n            counter += num == majority ? 1 : -1;\\n        }\\n        return majority;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int majority = 0;\\n        for (unsigned int i = 0, mask = 1; i < 32; i++, mask <<= 1) {\\n            int bits = 0;\\n            for (int num : nums) {\\n                if (num & mask) {\\n                    bits++;\\n                }\\n            }\\n            if (bits > nums.size() / 2) {\\n                majority |= mask;\\n            }\\n        }\\n        return majority;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676530,
                "title": "3-method-s-beats-100-c-java-python-beginner-friendly",
                "content": "# Approach 1: Sorting\\n\\n# Intuition:\\nThe intuition behind this approach is that if an element occurs more than n/2 times in the array (where n is the size of the array), it will always occupy the middle position when the array is sorted. Therefore, we can sort the array and return the element at index n/2.\\n\\n# Explanation:\\n1. The code begins by sorting the array `nums` in non-decreasing order using the `sort` function from the C++ Standard Library. This rearranges the elements such that identical elements are grouped together.\\n2. Once the array is sorted, the majority element will always be present at index `n/2`, where `n` is the size of the array.\\n   - This is because the majority element occurs more than n/2 times, and when the array is sorted, it will occupy the middle position.\\n3. The code returns the element at index `n/2` as the majority element.\\n\\nThe time complexity of this approach is O(n log n) since sorting an array of size n takes O(n log n) time.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        return nums[n/2];\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        return nums[n/2];\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        return nums[n//2]\\n```\\n\\n\\n# Approach 2: Hash Map\\n\\n# Intuition:\\nThe intuition behind using a hash map is to count the occurrences of each element in the array and then identify the element that occurs more than n/2 times. By storing the counts in a hash map, we can efficiently keep track of the occurrences of each element.\\n\\nExplanation:\\n1. The code begins by initializing a hash map `m` to store the count of occurrences of each element.\\n2. It then iterates through the array `nums` using a for loop.\\n3. For each element `nums[i]`, it increments its count in the hash map `m` by using the line `m[nums[i]]++;`.\\n   - If `nums[i]` is encountered for the first time, it will be added to the hash map with a count of 1.\\n   - If `nums[i]` has been encountered before, its count in the hash map will be incremented by 1.\\n4. After counting the occurrences of each element, the code updates `n` to be `n/2`, where `n` is the size of the array. This is done to check if an element occurs more than n/2 times, which is the criteria for being the majority element.\\n5. The code then iterates through the key-value pairs in the hash map using a range-based for loop.\\n   - For each key-value pair `(x.first, x.second)`, it checks if the count `x.second` is greater than `n`.\\n   - If the count is greater than `n`, it means that `x.first` occurs more than n/2 times, so it returns `x.first` as the majority element.\\n6. If no majority element is found in the hash map, the code returns 0 as the default value.\\n   - Note that this will only occur if the input array `nums` is empty or does not have a majority element.\\n\\nThe time complexity of this approach is O(n) because it iterates through the array once to count the occurrences and then iterates through the hash map, which has a maximum size of the number of distinct elements in the array.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> m;\\n        \\n        for(int i = 0; i < n; i++){\\n            m[nums[i]]++;\\n        }\\n        n = n/2;\\n        for(auto x: m){\\n            if(x.second > n){\\n                return x.first;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        int n = nums.length;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n        }\\n        \\n        n = n / 2;\\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            if (entry.getValue() > n) {\\n                return entry.getKey();\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = defaultdict(int)\\n        \\n        for num in nums:\\n            m[num] += 1\\n        \\n        n = n // 2\\n        for key, value in m.items():\\n            if value > n:\\n                return key\\n        \\n        return 0\\n```\\n\\n# Approach 3: Moore Voting Algorithm\\n\\n# Intuition:\\nThe intuition behind the Moore\\'s Voting Algorithm is based on the fact that if there is a majority element in an array, it will always remain in the lead, even after encountering other elements.\\n\\n# Explanation:\\n\\n**Algorithm:**\\n1. Initialize two variables: `count` and `candidate`. Set `count` to 0 and `candidate` to an arbitrary value.\\n2. Iterate through the array `nums`:\\n   a. If `count` is 0, assign the current element as the new `candidate` and increment `count` by 1.\\n   b. If the current element is the same as the `candidate`, increment `count` by 1.\\n   c. If the current element is different from the `candidate`, decrement `count` by 1.\\n3. After the iteration, the `candidate` variable will hold the majority element.\\n\\n**Explanation:**\\n1. The algorithm starts by assuming the first element as the majority candidate and sets the count to 1.\\n2. As it iterates through the array, it compares each element with the candidate:\\n   a. If the current element matches the candidate, it suggests that it reinforces the majority element because it appears again. Therefore, the count is incremented by 1.\\n   b. If the current element is different from the candidate, it suggests that there might be an equal number of occurrences of the majority element and other elements. Therefore, the count is decremented by 1.\\n      - Note that decrementing the count doesn\\'t change the fact that the majority element occurs more than n/2 times.\\n3. If the count becomes 0, it means that the current candidate is no longer a potential majority element. In this case, a new candidate is chosen from the remaining elements.\\n4. The algorithm continues this process until it has traversed the entire array.\\n5. The final value of the `candidate` variable will hold the majority element.\\n\\n**Explanation of Correctness:**\\nThe algorithm works on the basis of the assumption that the majority element occurs more than n/2 times in the array. This assumption guarantees that even if the count is reset to 0 by other elements, the majority element will eventually regain the lead.\\n\\nLet\\'s consider two cases:\\n1. If the majority element has more than n/2 occurrences:\\n   - The algorithm will ensure that the count remains positive for the majority element throughout the traversal, guaranteeing that it will be selected as the final candidate.\\n\\n2. If the majority element has exactly n/2 occurrences:\\n   - In this case, there will be an equal number of occurrences for the majority element and the remaining elements combined.\\n   - However, the majority element will still be selected as the final candidate because it will always have a lead over any other element.\\n\\nIn both cases, the algorithm will correctly identify the majority element.\\n\\nThe time complexity of the Moore\\'s Voting Algorithm is O(n) since it traverses the array once.\\n\\nThis approach is efficient compared to sorting as it requires only a single pass through the array and does not change the original order of the elements.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int count = 0;\\n        int candidate = 0;\\n        \\n        for (int num : nums) {\\n            if (count == 0) {\\n                candidate = num;\\n            }\\n            \\n            if (num == candidate) {\\n                count++;\\n            } else {\\n                count--;\\n            }\\n        }\\n        \\n        return candidate;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        int count = 0;\\n        int candidate = 0;\\n        \\n        for (int num : nums) {\\n            if (count == 0) {\\n                candidate = num;\\n            }\\n            \\n            if (num == candidate) {\\n                count++;\\n            } else {\\n                count--;\\n            }\\n        }\\n        \\n        return candidate;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        count = 0\\n        candidate = 0\\n        \\n        for num in nums:\\n            if count == 0:\\n                candidate = num\\n            \\n            if num == candidate:\\n                count += 1\\n            else:\\n                count -= 1\\n        \\n        return candidate\\n```\\n\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/bd8d22d6-112d-4472-86c8-d7bf24ee4744_1687598558.382908.png)\\n\\n**If you are a beginner solve these problems which makes concepts clear for future coding:**\\n1. [Two Sum](https://leetcode.com/problems/two-sum/solutions/3619262/3-method-s-c-java-python-beginner-friendly/)\\n2. [Roman to Integer](https://leetcode.com/problems/roman-to-integer/solutions/3651672/best-method-c-java-python-beginner-friendly/)\\n3. [Palindrome Number](https://leetcode.com/problems/palindrome-number/solutions/3651712/2-method-s-c-java-python-beginner-friendly/)\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/solutions/3666304/beats-100-c-java-python-beginner-friendly/)\\n5. [Remove Element](https://leetcode.com/problems/remove-element/solutions/3670940/best-100-c-java-python-beginner-friendly/)\\n6. [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/solutions/3672475/4-method-s-c-java-python-beginner-friendly/)\\n7. [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/solutions/3675747/beats-100-c-java-python-beginner-friendly/)\\n8. [Majority Element](https://leetcode.com/problems/majority-element/solutions/3676530/3-methods-beats-100-c-java-python-beginner-friendly/)\\n9. [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3676877/best-method-100-c-java-python-beginner-friendly/)\\n10. **Practice them in a row for better understanding and please Upvote the post for more questions.**\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        return nums[n/2];\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        return nums[n/2];\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        return nums[n//2]\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> m;\\n        \\n        for(int i = 0; i < n; i++){\\n            m[nums[i]]++;\\n        }\\n        n = n/2;\\n        for(auto x: m){\\n            if(x.second > n){\\n                return x.first;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        int n = nums.length;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n        }\\n        \\n        n = n / 2;\\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            if (entry.getValue() > n) {\\n                return entry.getKey();\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = defaultdict(int)\\n        \\n        for num in nums:\\n            m[num] += 1\\n        \\n        n = n // 2\\n        for key, value in m.items():\\n            if value > n:\\n                return key\\n        \\n        return 0\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int count = 0;\\n        int candidate = 0;\\n        \\n        for (int num : nums) {\\n            if (count == 0) {\\n                candidate = num;\\n            }\\n            \\n            if (num == candidate) {\\n                count++;\\n            } else {\\n                count--;\\n            }\\n        }\\n        \\n        return candidate;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        int count = 0;\\n        int candidate = 0;\\n        \\n        for (int num : nums) {\\n            if (count == 0) {\\n                candidate = num;\\n            }\\n            \\n            if (num == candidate) {\\n                count++;\\n            } else {\\n                count--;\\n            }\\n        }\\n        \\n        return candidate;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        count = 0\\n        candidate = 0\\n        \\n        for num in nums:\\n            if count == 0:\\n                candidate = num\\n            \\n            if num == candidate:\\n                count += 1\\n            else:\\n                count -= 1\\n        \\n        return candidate\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51611,
                "title": "java-solutions-sorting-hashmap-moore-voting-bit-manipulation",
                "content": "    \\n    // Sorting\\n    public int majorityElement1(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[nums.length/2];\\n    }\\n    \\n    // Hashtable \\n    public int majorityElement2(int[] nums) {\\n        Map<Integer, Integer> myMap = new HashMap<Integer, Integer>();\\n        //Hashtable<Integer, Integer> myMap = new Hashtable<Integer, Integer>();\\n        int ret=0;\\n        for (int num: nums) {\\n            if (!myMap.containsKey(num))\\n                myMap.put(num, 1);\\n            else\\n                myMap.put(num, myMap.get(num)+1);\\n            if (myMap.get(num)>nums.length/2) {\\n                ret = num;\\n                break;\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    // Moore voting algorithm\\n    public int majorityElement3(int[] nums) {\\n        int count=0, ret = 0;\\n        for (int num: nums) {\\n            if (count==0)\\n                ret = num;\\n            if (num!=ret)\\n                count--;\\n            else\\n                count++;\\n        }\\n        return ret;\\n    }\\n    \\n    // Bit manipulation \\n    public int majorityElement(int[] nums) {\\n        int[] bit = new int[32];\\n        for (int num: nums)\\n            for (int i=0; i<32; i++) \\n                if ((num>>(31-i) & 1) == 1)\\n                    bit[i]++;\\n        int ret=0;\\n        for (int i=0; i<32; i++) {\\n            bit[i]=bit[i]>nums.length/2?1:0;\\n            ret += bit[i]*(1<<(31-i));\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "    \\n    // Sorting\\n    public int majorityElement1(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[nums.length/2];\\n    }\\n    \\n    // Hashtable \\n    public int majorityElement2(int[] nums) {\\n        Map<Integer, Integer> myMap = new HashMap<Integer, Integer>();\\n        //Hashtable<Integer, Integer> myMap = new Hashtable<Integer, Integer>();\\n        int ret=0;\\n        for (int num: nums) {\\n            if (!myMap.containsKey(num))\\n                myMap.put(num, 1);\\n            else\\n                myMap.put(num, myMap.get(num)+1);\\n            if (myMap.get(num)>nums.length/2) {\\n                ret = num;\\n                break;\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    // Moore voting algorithm\\n    public int majorityElement3(int[] nums) {\\n        int count=0, ret = 0;\\n        for (int num: nums) {\\n            if (count==0)\\n                ret = num;\\n            if (num!=ret)\\n                count--;\\n            else\\n                count++;\\n        }\\n        return ret;\\n    }\\n    \\n    // Bit manipulation \\n    public int majorityElement(int[] nums) {\\n        int[] bit = new int[32];\\n        for (int num: nums)\\n            for (int i=0; i<32; i++) \\n                if ((num>>(31-i) & 1) == 1)\\n                    bit[i]++;\\n        int ret=0;\\n        for (int i=0; i<32; i++) {\\n            bit[i]=bit[i]>nums.length/2?1:0;\\n            ret += bit[i]*(1<<(31-i));\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1787619,
                "title": "c-multiple-approaches-hashmaps-sorting-votingalgo",
                "content": "**Somebody is intentionally downvoting the posts. Please if you can\\'t support then atleast don\\'t do this.**\\nHi , everybody. Today\\'s question is rather simple. There are multiple approaches discussed in the LEETCODE SOLUTION section , but I will explain the most obvious and the important ones. But do check out the rest of the approaches. \\n\\n**EXPLANATION : The question says that a vector has been provided and it consists of an element that appears more than half of the size of the array. We have to find and return this majority element.**\\n\\nThere are multiple approaches to this question. Here are a few of them.\\n\\n**APPROACH 1: BRUTE-FORCE**\\nFor every element , check its frequency in the array. Store the maximum_frequency_till_now in a variable and update it once you find out the frequency of each element.\\nThis approach involves nested loops : \\n1. Run a loop on the array.\\n2. In , the above loop run another loop on the array and count the frequency of the current element of the above array.\\n3. After calculating the frequency of current_element , update the maximum_frequency variable.\\n\\n**TC : O(N^2)**\\n**SC : O(1)**\\n\\nThis approach is not a good one as we are calculating the frequency of same element multiple times. \\n\\nInstead of doing that , can\\'t we simply store the frequency of each element in a container and return the element with maximum frequency ??\\n\\nNext approach is based on the same concept. \\n\\n#### APPROACH 2: USING HASHMAPS (UNORDERED_MAPS)\\nWhenever , there is a question involving the calculation of frequency , hashmaps and frequency arrays come handy. \\nIn this approach as well , we will :\\n* Evaluate the frequency of each element by storing it in a hashmap.\\n* Then we will traverse the hashmap and return the element with maximum frequency. \\n\\n**CODE :**\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        unordered_map<int,int> a;\\n        for(int i:nums)\\n            a[i]++;\\n        int maxval=nums[0];\\n        for(auto x:a)\\n        {\\n            if(x.second>a[maxval])\\n                maxval=x.first;\\n        }\\n        return maxval;\\n    }\\n};\\n```\\n**TC : O(N)**\\n**SC : O(N)**\\n\\nSo , far we have created solutions to find the majority element in the array. \\n**We haven\\'t made use of the fact , that the majority element will have a frequency >N/2.**\\n\\nNow , how do we use that to our advantage ?? \\nWell here is a small observation. \\nIf the array was rearranged such that **all the occurences of the majority element were put together**,  it will more than half of the array size. \\nThis means that if we sort the array ( which will bring all the occurences of majority element together) , the **(N/2 +1)th element will always be the majority element**. \\n\\nSo , implementing this in the 3rd approach , \\n\\n#### APPROACH 3 : USING SORTING \\n* Sort the array .\\n* Return the element at (N/2 + 1)th position (or (N/2)th index). \\n\\n**CODE :**\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        return nums[n/2];\\n    }\\n};\\n```\\n**TC : O(NlogN)**\\n**SC : O(1)**\\n\\nThe above approach is using the fact that the frequency of majority element is >N/2 . \\nBut , can we improve it so that our time complexity becomes linear ?? \\n\\nCan we implement the fact that the majority element has a frequency >N/2 ??\\n\\n#### APPROACH 4 : MOORE\\'S VOTING ALGORITHM \\n\\nThink of this array as a collection of votes from the voters for different political parties. \\nNow as we know the party which has >50% votes can form the government. \\n\\nSo , our above question is analogous to this situation. \\nNow , if we are certain that one party has > 50% votes . Then , if : \\n* We **increment a count variable every time we see the vote from the majority party** and **decrement it whenever a vote from some other party is occured** , we can guarantee that , \\n  **count>0.** \\n\\n  Using the above logic , \\n  1. Create a count=0 and a majority variable that stores the current majority element. \\n  2. Traverse the array , and if count =0 , then store the current element as the majority element and increment the count.\\n  3. Else , if the current element is equal to the current majority element , increment count , else decrement it. \\n  4. At the end return the majority element. \\n \\n This approach works because , \\n 1. We simply know that the majority element has a frequency greater than half of the total elements. \\n 2. So , the value of count > 0. \\n 3. But whenever it becomes 0 , it means that till now the majority element has either not occured , or if it has then the its frequency is equal to the sum of frequency of rest of the others. So , the next element will be the majority element till now . But eventually by the end , the final answer will always be the majority element of the array , as when the \"count\" becomes 0 for the final time , the next element will be the majority element. \\n\\n**CODE :**\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int majority,count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(count)\\n            {\\n                count+=(nums[i]==majority ? 1 : -1);\\n            }\\n            else\\n            {\\n                majority=nums[i];\\n                count=1;\\n            }\\n        }\\n        return majority;\\n    }\\n};\\n```\\n\\n**TC : O(N)**\\n**SC : O(1)**\\n\\nIF YOU FOUND THIS POST HELPFUL , DO UPVOTE AND COMMENT BELOW.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        unordered_map<int,int> a;\\n        for(int i:nums)\\n            a[i]++;\\n        int maxval=nums[0];\\n        for(auto x:a)\\n        {\\n            if(x.second>a[maxval])\\n                maxval=x.first;\\n        }\\n        return maxval;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        return nums[n/2];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int majority,count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(count)\\n            {\\n                count+=(nums[i]==majority ? 1 : -1);\\n            }\\n            else\\n            {\\n                majority=nums[i];\\n                count=1;\\n            }\\n        }\\n        return majority;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109595,
                "title": "100-faster-c-with-explanation-o-1-space",
                "content": "# Intuition \\nWe know that it is easily solvable by usng a map or something  but that requires space .So milion dollar  question is how to do it in constant space and linear time as well . So try to ponder on this observation which is: \\n  Discussed in appraoch section \\n# Approach\\nWE know there is an element which is present more than $$n/2$$ times so keep a counter and elemnt varaible which will track if element is same as previous then counter will be incremnted else decremented .\\nIf our counter becomes 0 somewhere we will change the element because its lead is over now we will take another element (give chance to other as well) and keep doing the same with it  but we will think that we might lost our element by taking the new element but no it will come again latter Since we know there is an element whose occurence is more than $$ n/2$$ times . So no matter What how many times will change the elemnt it will come again , either its counter will not become  zero or it will come agian in lead because rest elemnts can have max $$ n/2 -1$$ occurence so they can\\'t win form it.\\n\\n\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& arr) {\\n        int ele=arr[0];\\n        int count=0;\\n        for(int i=0;i<arr.size();i++){\\n            if(count==0)ele=arr[i];\\n            count+=(ele==arr[i])?1:-1;\\n        }\\n        return ele;\\n    }\\n};\\n```\\n# (HelpFull)?Upvote\\uD83D\\uDD3C:(\\u25CF\\'\\u25E1\\'\\u25CF)",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& arr) {\\n        int ele=arr[0];\\n        int count=0;\\n        for(int i=0;i<arr.size();i++){\\n            if(count==0)ele=arr[i];\\n            count+=(ele==arr[i])?1:-1;\\n        }\\n        return ele;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51712,
                "title": "python-different-solutions",
                "content": "```\\nclass Solution(object):\\n    def majorityElement1(self, nums):\\n        nums.sort()\\n        return nums[len(nums)//2]\\n    \\n    def majorityElement2(self, nums):\\n        m = {}\\n        for n in nums:\\n            m[n] = m.get(n, 0) + 1\\n            if m[n] > len(nums)//2:\\n                return n\\n            \\n    def majorityElement(self, nums):\\n        candidate, count = nums[0], 0\\n        for num in nums:\\n            if num == candidate:\\n                count += 1\\n            elif count == 0:\\n                candidate, count = num, 1\\n            else:\\n                count -= 1\\n        return candidate\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution(object):\\n    def majorityElement1(self, nums):\\n        nums.sort()\\n        return nums[len(nums)//2]\\n    \\n    def majorityElement2(self, nums):\\n        m = {}\\n        for n in nums:\\n            m[n] = m.get(n, 0) + 1\\n            if m[n] > len(nums)//2:\\n                return n\\n            \\n    def majorityElement(self, nums):\\n        candidate, count = nums[0], 0\\n        for num in nums:\\n            if num == candidate:\\n                count += 1\\n            elif count == 0:\\n                candidate, count = num, 1\\n            else:\\n                count -= 1\\n        return candidate\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176192,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n         int k = ceil(n/2);\\n\\n        unordered_map<int,int>m1;\\n        for(int i=0;i<nums.size();i++){\\n            m1[nums[i]]++;\\n        }\\n        int g=0;\\n        for(auto it:m1){\\n         if(it.second > k){\\n            g=it.first;\\n         }  \\n        }\\n        return g;\\n    }\\n};\\n```\\n\\n```Python3 []\\nimport statistics\\nf = open(\"user.out\", \\'w\\')\\nfor line in stdin:\\n    l = sorted(map(int, line.rstrip()[1:-1].split(\\',\\')))\\n    print(l[len(l) // 2], file=f)\\nexit(0)\\n```\\n\\n```Java []\\nclass Solution {\\n    public static int majorityElement(int[] nums) {\\n        return helper(nums,0,nums[0]);\\n    }static int helper(int[] nums, int si, int ref){\\n        int c=0;\\n        for(int i=si;i<nums.length;i++){\\n            if(nums[i]==ref)\\n                c++;\\n            else\\n                c--;\\n            if(c==-1)\\n                return helper(nums,i,nums[i]);\\n        }return ref;\\n    }\\n    public static void main(String[] args)throws Exception{\\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\\n        String[] s=br.readLine().split(\" \");\\n        int[] nums=new int[s.length];\\n        for(int i=0;i<s.length;i++){\\n            nums[i]=Integer.parseInt(s[i]);\\n        }majorityElement(nums);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n         int k = ceil(n/2);\\n\\n        unordered_map<int,int>m1;\\n        for(int i=0;i<nums.size();i++){\\n            m1[nums[i]]++;\\n        }\\n        int g=0;\\n        for(auto it:m1){\\n         if(it.second > k){\\n            g=it.first;\\n         }  \\n        }\\n        return g;\\n    }\\n};\\n```\n```Python3 []\\nimport statistics\\nf = open(\"user.out\", \\'w\\')\\nfor line in stdin:\\n    l = sorted(map(int, line.rstrip()[1:-1].split(\\',\\')))\\n    print(l[len(l) // 2], file=f)\\nexit(0)\\n```\n```Java []\\nclass Solution {\\n    public static int majorityElement(int[] nums) {\\n        return helper(nums,0,nums[0]);\\n    }static int helper(int[] nums, int si, int ref){\\n        int c=0;\\n        for(int i=si;i<nums.length;i++){\\n            if(nums[i]==ref)\\n                c++;\\n            else\\n                c--;\\n            if(c==-1)\\n                return helper(nums,i,nums[i]);\\n        }return ref;\\n    }\\n    public static void main(String[] args)throws Exception{\\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\\n        String[] s=br.readLine().split(\" \");\\n        int[] nums=new int[s.length];\\n        for(int i=0;i<s.length;i++){\\n            nums[i]=Integer.parseInt(s[i]);\\n        }majorityElement(nums);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51854,
                "title": "my-two-line-java-solution",
                "content": "\\n    public int majorityElement(int[] nums) {\\n         Arrays.sort(nums);\\n         return nums[nums.length/2];\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public int majorityElement(int[] nums) {\\n         Arrays.sort(nums);\\n         return nums[nums.length/2];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 543431,
                "title": "majority-vote-algorithm-explained-with-pictures",
                "content": "Unfortunately I could not solve the problem myself so the least I could do is to learn the algorithm (Boyer\\u2013Moore majority vote algorithm) and make sense of it. I hope my explanation will help the others <3\\n\\n**Solution:  Boyer\\u2013Moore majority vote algorithm `O(N), O(1)`**\\n```\\nint majorityElement(vector<int>& nums)\\n{\\n\\tint c{-1}, cnt{};               // c = candidate, cnt = counter\\n\\tfor(auto n: nums)\\n\\t{\\n\\t\\tif(cnt==0)\\n\\t\\t\\tc = n;\\n\\t\\tcnt += (n == c) ? 1 : -1;\\n\\t}\\n\\treturn c;\\n}\\n```\\n**If** we don\\'t know weither the majority element exists, the algorithm is two pass: the first one chooses the best candidate that can potentially be a majority element, the second pass confirms or rejects this guess.\\nOn the first pass we focus on one element (leader) at a time and maintain the counter that equals the number of occurrences of the leader minus the number of occurences of all the other elements. When the counter drops to` 0` we focus on the next element. The last elemet we were focused on will be the candidate to the title of the majority element. We need to confirm in a separate array traversal.\\n\\n**Explanation 1: runs of 50 %**\\n\\nIf we think about it our algorithm breaks our array into segments (I call them runs). In each run the first element (leader) of the run \"dominates\" all the other elements. \"Dominates\" means that it occurs more times than all the others elements in the run combined. We terminate the run when all the other elements combined occur as much times as the leader (`cnt == 0`). \\n<br>\\n![image](https://assets.leetcode.com/users/andriy111/image_1584534212.png)\\n<br>\\n\\nThis tells us that the leader as well as **every other element** occurs **50% of maybe less** in the run. The same is true if we consider few consecutive runs stacked together: in each of them every element can occur 50% or less that\\'s why in all of them combined the same is true. The last run can be unfinished. In all previous runs combined no element occured more than 50% that\\'s why **if** the array has the majority element this element necessarily **has to be** the leader of the last run and has to occupy **more** than 50% of it (otherwise the last run would not be the last or the array wouldn\\'t have the majority element). \\n<br>\\n![image](https://assets.leetcode.com/users/andriy111/image_1584543475.png)\\n<br>\\nSo in fact all the decisive staff occurs in the last run, but we have to do all the other runs to determine when the last runs starts and what element will be its leader\\n<br>\\n![image](https://assets.leetcode.com/users/andriy111/image_1584543732.png)\\n<br>\\nNote that there could be many small 2-element runs or one giant run\\n![image](https://assets.leetcode.com/users/andriy111/image_1584538411.png)\\nso we can\\'t say that we are reducing our problem into a smaller one. Breaking down into runs is kinda \\'magical\\' as at the end it leaves us with the run whose leader is majority element of the initial array (if it existed).\\n\\n\\n\\n**Explanation 2: pairing**\\n\\nThis point of view will be helpful for the generalisation of the problem [229. Majority Element II](https://leetcode.com/problems/majority-element-ii/).\\nSuppose we have an array of numbers and we want to make pairs of **different** elements. This means that a pair say `(1,2)`is valid while `(1,1)` is not.\\nIf all the elements in the array were unique we would traverse the array and pair up each element with the next one.\\n![image](https://assets.leetcode.com/users/andriy111/image_1584538862.png)\\n<br>\\nWe run into problem if the array has repeating elements. Now we have to \"save\" (using a stack perhaps) the excess element\\n![image](https://assets.leetcode.com/users/andriy111/image_1584539197.png)\\n\\nand fastforward to the element different from the saved one.\\n![image](https://assets.leetcode.com/users/andriy111/image_1584539429.png)\\n\\n\\nWe do this untill the stack containing excess element is empty, after that we can fill it with another excess element if we\\'ll encounter it.\\nIn fact the stack contains the same element multiple times so there\\'s actually no need in the stack: we can store the element and it\\'s abundance in two variables `c` and `cnt`.\\nThus with our algorithm we can maintain production of pairs of different elements, the `c` variable stores the element that is currently in excess and `cnt` stores the excess itself. Pairing of elements is useful because the leftover element after we reach the end of the array will be the majority element (if it exists). Let me explain why. All in all we will have `\\u230A n/2 \\u230B` pairs and even if majority element was present in each of them we would still have some of if left (by definition majority should occur **more** than `\\u230A n/2 \\u230B` times in the array). If majority occures not in each pair, we will have even more unpaired instances of it.\\n\\n\\n![image](https://assets.leetcode.com/users/andriy111/image_1584542483.png)\\n\\n\\n\\n\\n\\n\\n\\n\\nUseful links:\\nhttps://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\\nhttps://gregable.com/2013/10/majority-vote-algorithm-find-majority.html\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint majorityElement(vector<int>& nums)\\n{\\n\\tint c{-1}, cnt{};               // c = candidate, cnt = counter\\n\\tfor(auto n: nums)\\n\\t{\\n\\t\\tif(cnt==0)\\n\\t\\t\\tc = n;\\n\\t\\tcnt += (n == c) ? 1 : -1;\\n\\t}\\n\\treturn c;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51610,
                "title": "one-line-solution-in-python",
                "content": "NOTICE that the majority element **always** exist in the array,so that  the middle **always**  is the answer\\n\\n    return sorted(num)[len(num)/2]",
                "solutionTags": [
                    "Python"
                ],
                "code": "NOTICE that the majority element **always** exist in the array,so that  the middle **always**  is the answer\\n\\n    return sorted(num)[len(num)/2]",
                "codeTag": "Unknown"
            },
            {
                "id": 51828,
                "title": "c-solution-using-moore-s-voting-algorithm-o-n-runtime-comlexity-an-no-extra-array-or-hash-table",
                "content": "This can be solved by Moore's voting algorithm. Basic idea of the algorithm is if we cancel out each occurrence of an element e with all the other elements that are different from e then e will exist till end if it is a majority element. Below code loops through each element and maintains a count of the element that has the potential of being the majority element. If next element is same then increments the count, otherwise decrements the count. If the count reaches 0 then update the potential index to the current element and sets count to 1.\\n\\n    int majorityElement(vector<int> &num) {\\n        int majorityIndex = 0;\\n        for (int count = 1, i = 1; i < num.size(); i++) {\\n            num[majorityIndex] == num[i] ? count++ : count--;\\n            if (count == 0) {\\n                majorityIndex = i;\\n                count = 1;\\n            }\\n        }\\n            \\n        return num[majorityIndex];\\n    }",
                "solutionTags": [],
                "code": "This can be solved by Moore's voting algorithm. Basic idea of the algorithm is if we cancel out each occurrence of an element e with all the other elements that are different from e then e will exist till end if it is a majority element. Below code loops through each element and maintains a count of the element that has the potential of being the majority element. If next element is same then increments the count, otherwise decrements the count. If the count reaches 0 then update the potential index to the current element and sets count to 1.\\n\\n    int majorityElement(vector<int> &num) {\\n        int majorityIndex = 0;\\n        for (int count = 1, i = 1; i < num.size(); i++) {\\n            num[majorityIndex] == num[i] ? count++ : count--;\\n            if (count == 0) {\\n                majorityIndex = i;\\n                count = 1;\\n            }\\n        }\\n            \\n        return num[majorityIndex];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51649,
                "title": "share-my-solution-java-count-bits",
                "content": "Definitely not the fastest solution but I post it here for your reference since it's different from the rest I saw. The problem reminded me of the approach I followed at Single Number II (problem 137).\\n\\nWe can iterate over the bits of all numbers and for every position find out if ones outnumber the zeros (among all numbers). If this is the case, the corresponding bit of the ret variable (which holds the result) is set. We essentially \"construct\" the number we look for.\\n\\nThe following code is simple and should be easy to understand.\\n\\n    public int majorityElement(int[] num) {\\n\\n        int ret = 0;\\n\\n        for (int i = 0; i < 32; i++) {\\n\\n            int ones = 0, zeros = 0;\\n\\n            for (int j = 0; j < num.length; j++) {\\n                if ((num[j] & (1 << i)) != 0) {\\n                    ++ones;\\n                }\\n                else\\n                    ++zeros;\\n            }\\n\\n            if (ones > zeros)\\n                ret |= (1 << i);\\n        }\\n        \\n        return ret;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Definitely not the fastest solution but I post it here for your reference since it's different from the rest I saw. The problem reminded me of the approach I followed at Single Number II (problem 137).\\n\\nWe can iterate over the bits of all numbers and for every position find out if ones outnumber the zeros (among all numbers). If this is the case, the corresponding bit of the ret variable (which holds the result) is set. We essentially \"construct\" the number we look for.\\n\\nThe following code is simple and should be easy to understand.\\n\\n    public int majorityElement(int[] num) {\\n\\n        int ret = 0;\\n\\n        for (int i = 0; i < 32; i++) {\\n\\n            int ones = 0, zeros = 0;\\n\\n            for (int j = 0; j < num.length; j++) {\\n                if ((num[j] & (1 << i)) != 0) {\\n                    ++ones;\\n                }\\n                else\\n                    ++zeros;\\n            }\\n\\n            if (ones > zeros)\\n                ret |= (1 << i);\\n        }\\n        \\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2379248,
                "title": "very-easy-100-fully-explained-c-java-python-js-c-python3",
                "content": "# **C++ Solution (Using Moore\\u2019s Voting Algorithm):**\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        // Initialize sol and cnt to store the solution and its frequency for respective iterations...\\n        int sol = 0, cnt = 0;\\n        // For every element i in the array...\\n        for(int i = 0; i < nums.size(); i++ ) {\\n            // If cnt is equal to zero, update sol as sol = i\\n            if(cnt == 0){\\n                sol = nums[i];\\n                cnt = 1;\\n            }\\n            // If i is equal to candidate, increment cnt...\\n            else if(sol == nums[i]){\\n                cnt++;\\n            }\\n            // Otherwise, decrement cnt...\\n            else{\\n                cnt--;\\n            }\\n        }\\n        // Return & print the solution...\\n        return sol;\\n    }\\n};\\n```\\n\\n# **Java Solution (Using Sorting Method):**\\n```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        // Base case...\\n        if (nums.length == 1) {\\n\\t\\t    return nums[0];\\n\\t    }\\n        // Sort nums array...\\n        Arrays.sort(nums);\\n        // Since the majority element appears more than n / 2 times...\\n        // The n/2 -th element in the sorted nums must be the majority element...\\n\\t    return nums[nums.length / 2];\\n    }\\n}\\n```\\n\\n# **Python Solution (Using Moore\\u2019s Voting Algorithm):**\\n```\\nclass Solution(object):\\n    def majorityElement(self, nums):\\n        sol = None\\n        cnt = 0\\n        for i in nums:\\n            if cnt == 0:\\n                sol = i\\n            cnt += (1 if i == sol else -1)\\n        return sol\\n```\\n\\n# **JavaScript Solution:**\\n```\\nvar majorityElement = function(nums) {\\n    // Initialize sol and cnt to store the solution and its frequency for respective iterations...\\n    let sol = 0, cnt = 0;\\n    // For every element i in the array...\\n    for(let i = 0; i < nums.length; i++ ) {\\n        // If cnt is equal to zero, update sol as sol = i\\n        if(cnt == 0){\\n            sol = nums[i];\\n            cnt = 1;\\n        }\\n        // If i is equal to candidate, increment cnt...\\n        else if(sol == nums[i]){\\n            cnt++;\\n        }\\n        // Otherwise, decrement cnt...\\n        else{\\n            cnt--;\\n        }\\n    }\\n    // Return & print the solution...\\n    return sol;\\n};\\n```\\n\\n# **C Language:**\\n```\\nint majorityElement(int* nums, int numsSize){\\n    int sol = nums[0],\\n    cnt = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (cnt == 0) {\\n            sol = nums[i];\\n        }\\n        if (nums[i] == sol) {\\n            cnt++;\\n        } else {\\n            cnt--;\\n        } \\n    }        \\n    return sol;\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        sol = None\\n        cnt = 0\\n        for i in nums:\\n            if cnt == 0:\\n                sol = i\\n            cnt += (1 if i == sol else -1)\\n        return sol\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        // Initialize sol and cnt to store the solution and its frequency for respective iterations...\\n        int sol = 0, cnt = 0;\\n        // For every element i in the array...\\n        for(int i = 0; i < nums.size(); i++ ) {\\n            // If cnt is equal to zero, update sol as sol = i\\n            if(cnt == 0){\\n                sol = nums[i];\\n                cnt = 1;\\n            }\\n            // If i is equal to candidate, increment cnt...\\n            else if(sol == nums[i]){\\n                cnt++;\\n            }\\n            // Otherwise, decrement cnt...\\n            else{\\n                cnt--;\\n            }\\n        }\\n        // Return & print the solution...\\n        return sol;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        // Base case...\\n        if (nums.length == 1) {\\n\\t\\t    return nums[0];\\n\\t    }\\n        // Sort nums array...\\n        Arrays.sort(nums);\\n        // Since the majority element appears more than n / 2 times...\\n        // The n/2 -th element in the sorted nums must be the majority element...\\n\\t    return nums[nums.length / 2];\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def majorityElement(self, nums):\\n        sol = None\\n        cnt = 0\\n        for i in nums:\\n            if cnt == 0:\\n                sol = i\\n            cnt += (1 if i == sol else -1)\\n        return sol\\n```\n```\\nvar majorityElement = function(nums) {\\n    // Initialize sol and cnt to store the solution and its frequency for respective iterations...\\n    let sol = 0, cnt = 0;\\n    // For every element i in the array...\\n    for(let i = 0; i < nums.length; i++ ) {\\n        // If cnt is equal to zero, update sol as sol = i\\n        if(cnt == 0){\\n            sol = nums[i];\\n            cnt = 1;\\n        }\\n        // If i is equal to candidate, increment cnt...\\n        else if(sol == nums[i]){\\n            cnt++;\\n        }\\n        // Otherwise, decrement cnt...\\n        else{\\n            cnt--;\\n        }\\n    }\\n    // Return & print the solution...\\n    return sol;\\n};\\n```\n```\\nint majorityElement(int* nums, int numsSize){\\n    int sol = nums[0],\\n    cnt = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        if (cnt == 0) {\\n            sol = nums[i];\\n        }\\n        if (nums[i] == sol) {\\n            cnt++;\\n        } else {\\n            cnt--;\\n        } \\n    }        \\n    return sol;\\n}\\n```\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        sol = None\\n        cnt = 0\\n        for i in nums:\\n            if cnt == 0:\\n                sol = i\\n            cnt += (1 if i == sol else -1)\\n        return sol\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51949,
                "title": "my-c-solution-10ms",
                "content": "    int majorityElement(int num[], int n) {\\n        int cnt = 0, res;\\n        for (int i = 0; i < n; ++i) {\\n            if (cnt == 0) res = num[i];\\n            if (res == num[i]) ++cnt;\\n            else --cnt;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    int majorityElement(int num[], int n) {\\n        int cnt = 0, res;\\n        for (int i = 0; i < n; ++i) {\\n            if (cnt == 0) res = num[i];\\n            if (res == num[i]) ++cnt;\\n            else --cnt;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1427775,
                "title": "2-line-easy-and-clean-c-solution-explained",
                "content": "The definition of majority element in the question is, THE ELEMENT that occurs MORE THAN n/2 times. It means that MORE THAN HALF of the array is occupied by MAJORITY ELEMENT. It means that index n/2 (of sorted array) definitely contains the majority element. So will just return that.\\n\\nSo first of all we sort the array and return the element at index n/2. If you like the solution do upvote:) \\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\t\\n        sort(nums.begin(),nums.end());\\n\\t\\t\\n        return nums[n/2];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\t\\n        sort(nums.begin(),nums.end());\\n\\t\\t\\n        return nums[n/2];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714182,
                "title": "simple-solution-using-boyer-moore-majority-vote-algorithm-beats-100",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe goal of the \"Majority Element\" problem is to find the element that appears more than half of the time in the given list. We can use the Boyer-Moore Majority Vote Algorithm, which is an efficient way to find the majority element in a single pass through the list.\\n\\n# Approach\\n1. We\\'ll use two variables, \"count\" and \"majority,\" to keep track of the current majority candidate and its count.\\n1. We\\'ll start by assuming the first element in the list as our \"majority candidate\" and set the count to 1.\\n1. As we traverse through the list, we\\'ll compare each element with the current majority candidate.\\n1. If the current element is the same as the majority candidate, we\\'ll increment the count as we\\'ve found another occurrence of this element.\\n1. If the current element is different from the majority candidate, we\\'ll decrement the count as it\\'s like \"canceling out\" one occurrence of different elements.\\n1. Whenever the count becomes 0, we\\'ll update the majority candidate to the current element and reset the count to 1. This step ensures that we always have a majority candidate at any point in the loop.\\n1. By the end of this process, the majority candidate will hold the element that appears more than half of the time in the list.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe Boyer-Moore Majority Vote Algorithm goes through the list once, comparing and updating elements in constant time. Thus, the time complexity is $$O(N)$$, where N is the size of the input list.\\n\\n\\n- Space complexity:\\nThe algorithm uses only a constant amount of additional space for storing variables. Hence, the space complexity is $$O(1)$$.\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        // Initialize variables to keep track of the majority element and its occurrence count.\\n        int count = 0;\\n        int majority = 0;\\n\\n        // Loop through the array to find the majority element using Boyer-Moore Majority Vote Algorithm.\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            // If the count is 0 and the current majority candidate is not equal to the current element,\\n            // update the majority candidate to the current element and set count to 1.\\n            if (count == 0 && majority != nums[i]) {\\n                majority = nums[i];\\n                count = 1;\\n            } else if (majority == nums[i]) {\\n                // If the current element is equal to the majority candidate, increment the count.\\n                count++;\\n            } else {\\n                // If the current element is not equal to the majority candidate, decrement the count.\\n                count--;\\n            }\\n        }\\n\\n        // The majority variable will contain the element that appears more than \\u230An/2\\u230B times in the array.\\n        return majority;\\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def majorityElement(self, nums):\\n        # Initialize count and majority candidate\\n        count = 0\\n        majority = 0\\n\\n        # Traverse through the list\\n        for i in range(len(nums)):\\n            if count == 0 and majority != nums[i]:\\n                # If count is 0 and majority candidate is different from current element,\\n                # update the majority candidate and set count to 1\\n                majority = nums[i]\\n                count += 1\\n            elif majority == nums[i]:\\n                # If current element is the same as the majority candidate,\\n                # increment the count\\n                count += 1\\n            else:\\n                # If current element is different from the majority candidate,\\n                # decrement the count\\n                count -= 1\\n\\n        return majority\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        // Initialize count and majority candidate\\n        int count = 0;\\n        int majority = 0;\\n\\n        // Traverse through the list\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (count == 0 && majority != nums[i]) {\\n                // If count is 0 and majority candidate is different from current element,\\n                // update the majority candidate and set count to 1\\n                majority = nums[i];\\n                count++;\\n            }\\n            else if (majority == nums[i]) {\\n                // If current element is the same as the majority candidate,\\n                // increment the count\\n                count++;\\n            }\\n            else {\\n                // If current element is different from the majority candidate,\\n                // decrement the count\\n                count--;\\n            }\\n        }\\n\\n        return majority;\\n    }\\n};\\n```\\n## ***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/a8d0da0a-4072-4b6c-a99a-462f4c6682ba_1688407449.5591881.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Counting"
                ],
                "code": "```java []\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        // Initialize variables to keep track of the majority element and its occurrence count.\\n        int count = 0;\\n        int majority = 0;\\n\\n        // Loop through the array to find the majority element using Boyer-Moore Majority Vote Algorithm.\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            // If the count is 0 and the current majority candidate is not equal to the current element,\\n            // update the majority candidate to the current element and set count to 1.\\n            if (count == 0 && majority != nums[i]) {\\n                majority = nums[i];\\n                count = 1;\\n            } else if (majority == nums[i]) {\\n                // If the current element is equal to the majority candidate, increment the count.\\n                count++;\\n            } else {\\n                // If the current element is not equal to the majority candidate, decrement the count.\\n                count--;\\n            }\\n        }\\n\\n        // The majority variable will contain the element that appears more than \\u230An/2\\u230B times in the array.\\n        return majority;\\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def majorityElement(self, nums):\\n        # Initialize count and majority candidate\\n        count = 0\\n        majority = 0\\n\\n        # Traverse through the list\\n        for i in range(len(nums)):\\n            if count == 0 and majority != nums[i]:\\n                # If count is 0 and majority candidate is different from current element,\\n                # update the majority candidate and set count to 1\\n                majority = nums[i]\\n                count += 1\\n            elif majority == nums[i]:\\n                # If current element is the same as the majority candidate,\\n                # increment the count\\n                count += 1\\n            else:\\n                # If current element is different from the majority candidate,\\n                # decrement the count\\n                count -= 1\\n\\n        return majority\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        // Initialize count and majority candidate\\n        int count = 0;\\n        int majority = 0;\\n\\n        // Traverse through the list\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (count == 0 && majority != nums[i]) {\\n                // If count is 0 and majority candidate is different from current element,\\n                // update the majority candidate and set count to 1\\n                majority = nums[i];\\n                count++;\\n            }\\n            else if (majority == nums[i]) {\\n                // If current element is the same as the majority candidate,\\n                // increment the count\\n                count++;\\n            }\\n            else {\\n                // If current element is different from the majority candidate,\\n                // decrement the count\\n                count--;\\n            }\\n        }\\n\\n        return majority;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51711,
                "title": "an-easy-way-to-solve-the-problem-24ms",
                "content": "Every number in the vector votes for itself, the majority number gets the most votes. Different number offsets the votes.\\n\\n    int majorityElement(vector<int> &num) {\\n        \\n        int vote = num[0];\\n    \\tint count = 1;\\n    \\tint size = num.size();\\n    \\t//vote from the second number\\n    \\tfor( int i = 1; i < size; i++ )\\n    \\t{\\n    \\t\\tif( count == 0 ) { vote = num[i]; count++; }\\n    \\t\\telse if( vote == num[i] )\\tcount++;\\n    \\t\\telse count--;\\n    \\t}\\n    \\treturn vote;\\n        }",
                "solutionTags": [
                    "C++"
                ],
                "code": "Every number in the vector votes for itself, the majority number gets the most votes. Different number offsets the votes.\\n\\n    int majorityElement(vector<int> &num) {\\n        \\n        int vote = num[0];\\n    \\tint count = 1;\\n    \\tint size = num.size();\\n    \\t//vote from the second number\\n    \\tfor( int i = 1; i < size; i++ )\\n    \\t{\\n    \\t\\tif( count == 0 ) { vote = num[i]; count++; }\\n    \\t\\telse if( vote == num[i] )\\tcount++;\\n    \\t\\telse count--;\\n    \\t}\\n    \\treturn vote;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2686685,
                "title": "typescript-solution-o-n-time-o-1-space-explanation",
                "content": "\\nThere are actually a lot of possible solutions. Such as:\\n1. sorting the array and picking the `n/2`th element. O(nlogn) time\\n2. going over the array once and store in a hashmap the occurence count of each element. Then return the element from the hashmap that had the most occurences. That would take O(n) space and O(n) time.\\n3. brute force which is O(n^2)\\n\\n\\nHowever, using the [Boyer-Moore majority vote algorithm](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm) is the most optimal solution.\\n\\n```\\nfunction majorityElement(nums: number[]): number {\\n    let candidate;\\n    let count = 0;\\n    \\n    for (const num of nums) {\\n        if (count === 0) {\\n            candidate = num;\\n        }\\n        \\n        count += (num === candidate) ? 1 : -1\\n    }\\n    \\n    return candidate;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction majorityElement(nums: number[]): number {\\n    let candidate;\\n    let count = 0;\\n    \\n    for (const num of nums) {\\n        if (count === 0) {\\n            candidate = num;\\n        }\\n        \\n        count += (num === candidate) ? 1 : -1\\n    }\\n    \\n    return candidate;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51608,
                "title": "javascript-solution-without-sort",
                "content": "    var majorityElement = function(nums) {\\n        var obj = {};\\n        \\n        for(var i = 0; i < nums.length; i++){\\n            obj[nums[i]] = obj[nums[i]] + 1 || 1;\\n            if(obj[nums[i]] > nums.length / 2)  return nums[i];\\n        }\\n        \\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var majorityElement = function(nums) {\\n        var obj = {};\\n        \\n        for(var i = 0; i < nums.length; i++){\\n            obj[nums[i]] = obj[nums[i]] + 1 || 1;\\n            if(obj[nums[i]] > nums.length / 2)  return nums[i];\\n        }\\n        \\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 1788112,
                "title": "python-easy-solution-o-n-o-1-explained",
                "content": "The approach is very simple,\\nThink of a situation, \\nIf an elephant have a fight with any other elephant, both will die.\\n**King A** has **5** elephants, and **King B** has **4** elephants. If they\\'re in a war, **King A** will win. \\nSimilarly, In this question it was given that a number is in majority, So if we have fight with numbers majority will always win.\\n\\n``` Let me explain it very briefly```\\nIn a war, if any **King** have more than the total count of elephant , so even if rest of the **Kings** will unite and fight they can\\'t win because at the end of the battle, there will be atleast ```one elephant ``` left that will belong to the **King**  that has the majority.\\nBut we don\\'t know who has the majority, and that is what we need to find.\\n\\n```How to fight```\\nAt any iteration if any King has maximum alive elephants will get the Throne and the rest of the **Kings** will unite to de-throne him.\\nSo at the end of this continous war (list), the King that has throne will be the winner. \\n\\n```Exact code as per the exaplination```\\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        curr, count = nums[0], 1              # curr will store the current majority element, count will store the count of the majority\\n        for i in range(1,len(nums)):\\n            count += (1 if curr == nums[i] else -1)    # if i is equal to current majority, they\\'re in same team, hence added, else one current majority and i both will be dead\\n            if not count:                   # if count is 0 means King is de-throwned\\n                curr = nums[i+1] if i + 1 < len(nums) else None        # the next element is the new King\\n                count = 0         # starting it with 0 because we can\\'t increment the i of the for loop, the count will be 1 in next iteration, and again the battle continues after next iteration\\n        return curr\\n```\\n\\n**Further it can be simplified to:**\\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        curr, count = nums[0], 1                   # curr will store the current majority element, count will store the count of the majority\\n        for i in nums[1:]:\\n            count += (1 if curr == i else -1)      # if i is equal to current majority, they\\'re in same team, hence added, else one current majority and i both will be dead\\n            if not count:                          # if count of current majority is zero, then change the majority element, and start its count from 1\\n                curr = i\\n                count = 1\\n        return curr\\n``` \\n***If you have any questions with my explaination, please ask, also do let me know if I am wrong at any stage.***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` Let me explain it very briefly```\n```one elephant ```\n```How to fight```\n```Exact code as per the exaplination```\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        curr, count = nums[0], 1              # curr will store the current majority element, count will store the count of the majority\\n        for i in range(1,len(nums)):\\n            count += (1 if curr == nums[i] else -1)    # if i is equal to current majority, they\\'re in same team, hence added, else one current majority and i both will be dead\\n            if not count:                   # if count is 0 means King is de-throwned\\n                curr = nums[i+1] if i + 1 < len(nums) else None        # the next element is the new King\\n                count = 0         # starting it with 0 because we can\\'t increment the i of the for loop, the count will be 1 in next iteration, and again the battle continues after next iteration\\n        return curr\\n```\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        curr, count = nums[0], 1                   # curr will store the current majority element, count will store the count of the majority\\n        for i in nums[1:]:\\n            count += (1 if curr == i else -1)      # if i is equal to current majority, they\\'re in same team, hence added, else one current majority and i both will be dead\\n            if not count:                          # if count of current majority is zero, then change the majority element, and start its count from 1\\n                curr = i\\n                count = 1\\n        return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51906,
                "title": "my-o-n-time-and-o-1-space-solution-in-c",
                "content": "    class Solution {\\n    public:\\n        int majorityElement(vector<int>& nums) {\\n            int max;\\n            int count = 0;\\n            int n = nums.size();\\n            for(int i = 0; i < n; i++) {\\n                if (count == 0) {\\n                    max = nums[i];\\n                    count = 1;\\n                    continue;\\n                }\\n                if (max != nums[i]) {\\n                    count--;\\n                } else {\\n                    count++;\\n                }\\n            }\\n            return max;\\n        }\\n        \\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int majorityElement(vector<int>& nums) {\\n            int max;\\n            int count = 0;\\n            int n = nums.size();\\n            for(int i = 0; i < n; i++) {\\n                if (count == 0) {\\n                    max = nums[i];\\n                    count = 1;\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1519682,
                "title": "python-o-n-time-o-1-space-simple-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        \"\"\"\\n            Since the count of majority element will be atleast n//2 + 1 therefore, \\n            if we make a number as majorityElement and keep on incrementing the count if we encounter that element again and decrement the count if any other element is encountered then the majority element will have atleast 1 in count. Whenever the count becomes 0, reinitialise the majority element with current number.\\n            For example, nums = [2,2,1,1,1,2,2]\\n            Let\\'s say majorityElement is 2 therefore count will be 1.\\n            Nove move ahead and again 2 is encountered so count will be incremented and become 2.\\n            Now 1 is encountered so count will be decremented and become 1\\n            Now again 1 is encountered so count will be decremented and become 0\\n            Now 1 is encountered but count is 0 so initialize 1 as majority element and count to 1 again.\\n            Now 2 is encountered so count will be decremented and become 0\\n            Now again 2 is encountered but count is 0 so initialize 2 as majority element and count to 1 again.\\n            Now no more elements are left so just return the majprity element.\\n        \"\"\"\\n        count = 0\\n        majorElement = None\\n        for num in nums:\\n            if count == 0:\\n                majorElement = num\\n            count += 1 if majorElement == num else -1\\n        return majorElement\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        \"\"\"\\n            Since the count of majority element will be atleast n//2 + 1 therefore, \\n            if we make a number as majorityElement and keep on incrementing the count if we encounter that element again and decrement the count if any other element is encountered then the majority element will have atleast 1 in count. Whenever the count becomes 0, reinitialise the majority element with current number.\\n            For example, nums = [2,2,1,1,1,2,2]\\n            Let\\'s say majorityElement is 2 therefore count will be 1.\\n            Nove move ahead and again 2 is encountered so count will be incremented and become 2.\\n            Now 1 is encountered so count will be decremented and become 1\\n            Now again 1 is encountered so count will be decremented and become 0\\n            Now 1 is encountered but count is 0 so initialize 1 as majority element and count to 1 again.\\n            Now 2 is encountered so count will be decremented and become 0\\n            Now again 2 is encountered but count is 0 so initialize 2 as majority element and count to 1 again.\\n            Now no more elements are left so just return the majprity element.\\n        \"\"\"\\n        count = 0\\n        majorElement = None\\n        for num in nums:\\n            if count == 0:\\n                majorElement = num\\n            count += 1 if majorElement == num else -1\\n        return majorElement\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51924,
                "title": "o-n-time-o-1-space",
                "content": "        public int majorityElement(int[] num) {\\n    \\t\\tint count = 0; int major = num[0];\\n    \\t\\tfor(int i:num) {\\n    \\t\\t\\tif(count==0){ major=i; count++;\\t}\\n    \\t\\t\\telse if(i==major) count++;\\n    \\t\\t\\telse count--;\\n    \\t\\t}\\n    \\t\\treturn major;\\n    \\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "        public int majorityElement(int[] num) {\\n    \\t\\tint count = 0; int major = num[0];\\n    \\t\\tfor(int i:num) {\\n    \\t\\t\\tif(count==0){ major=i; count++;\\t}\\n    \\t\\t\\telse if(i==major) count++;\\n    \\t\\t\\telse count--;\\n    \\t\\t}\\n    \\t\\treturn major;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 51719,
                "title": "c-solution-o-n-computation-o-1-space-the-problem-can-be-extended-to-u230an-k-u230b-situation",
                "content": "Find k different element, and \"remove\" them as a group, the remaining element must be the element that appears more than \\u230an/k\\u230b times. (Detailed explanation is given in comment)\\n\\nIn this problem, k equals to 2.\\n\\nThus we \"remove\" each pair of 2 different elements, and the remaining element that do not have its counterpart is the desired element. \\n\\n    class Solution {\\n    public:\\n        int majorityElement(vector<int> &num) {\\n            int nTimes = 0;\\n            int candidate = 0;\\n            for(int i = 0; i < num.size(); i ++)\\n            {\\n                if(nTimes == 0)\\n                {\\n                    candidate = num[i];\\n                    nTimes = 1;\\n                }\\n                else\\n                {\\n                    if(candidate == num[i])\\n                        nTimes ++;\\n                    else\\n                        nTimes --;\\n                }\\n            }\\n            return candidate;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int majorityElement(vector<int> &num) {\\n            int nTimes = 0;\\n            int candidate = 0;\\n            for(int i = 0; i < num.size(); i ++)\\n            {\\n                if(nTimes == 0)\\n                {\\n                    candidate = num[i];\\n                    nTimes = 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2747050,
                "title": "2-lines-of-code-faster-than-94",
                "content": "Majority Element will have occurance >n/2 (n is length of array) . When sorted , majority element will lie in the middle .\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n\\t\\n        Arrays.sort(nums);\\n        return nums[(nums.length-1)/2];\\n\\t\\t\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int majorityElement(int[] nums) {\\n\\t\\n        Arrays.sort(nums);\\n        return nums[(nums.length-1)/2];\\n\\t\\t\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 51959,
                "title": "share-my-10ms-c-solution",
                "content": "    int majorityElement(int num[], int n) {\\n        int i = 0;\\n        int result = 0;\\n        int count = 0;\\n        for (;i < n; ++i) {\\n            if (count == 0 || result == num[i]) {\\n                result = num[i];\\n                count++;\\n            } else {\\n                count--;\\n            }\\n        } \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    int majorityElement(int num[], int n) {\\n        int i = 0;\\n        int result = 0;\\n        int count = 0;\\n        for (;i < n; ++i) {\\n            if (count == 0 || result == num[i]) {\\n                result = num[i];\\n                count++;\\n            } else {\\n                count--;\\n            }\\n        } \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3169296,
                "title": "best-c-5-solutions-hash-table-sorting-divide-and-conquer-brute-force-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches.\\n\\n1. Solved using Array(Two Nested Loops). Brute Force.\\n2. Solved using Array + Hash Table.\\n3. Solved using Array + Sorting.\\n4. Solved using Array + Counting + Divide and Conquer.\\n5. Solved using Boyer-Moore Voting Algorithm.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)\\n\\n**IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.**\\n\\n```\\n/*\\n\\n    Time Complexity : O(N^2), The brute force algorithm contains two nested for loops that each run for N\\n    iterations, adding up to quadratic time complexity. Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(1), Constant Space. \\n\\n    Solved using Array(Two Nested Loops). Brute Force.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int countMajority = nums.size()/2;\\n        for(auto num : nums){\\n            int count = 0;\\n            for(auto element : nums){\\n                if(element == num){\\n                    count++;\\n                }\\n            }\\n            if(count > countMajority){\\n                return num;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), We iterate over Array(nums) once and make a constant time HashMap(Unordered map)\\n    insertion on each iteration. Therefore, the algorithm runs in O(N) time. Where N is the size of the Array\\n    (nums).\\n\\n    Space Complexity : O(N), Unordered map space. \\n\\n    Solved using Array + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> map;\\n        for(auto it : nums){\\n            map[it]++;\\n        }\\n        for(auto it : map){\\n            if(map[it.first] > n/2){\\n                return it.first;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(NlogN), Sorting the array(nums) costs O(NlogN). Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(1), Constant Space. \\n\\n    Solved using Array + Sorting.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        return nums[nums.size()/2];\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(NlogN), Each recursive call to performs two recursive calls on subslices of size N/2\\n\\u200B    and two linear scans of length N. Therefore, the time complexity of the divide & conquer approach can be\\n    represented by the following recurrence relation: T(N)=2T(N/2)+2N. Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(logN), Recursion Stack Space. \\n\\n    Solved using Array + Counting + Divide and Conquer.\\n\\n*/\\n\\n\\n/***************************************** Approach 4 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    int countforRange(vector<int>& nums, int low, int high, int target){\\n        int count = 0;\\n        for(int i=low; i<=high; i++){\\n            if(nums[i] == target){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    int majorityElement(vector<int>& nums, int low, int high){\\n        if(low == high){\\n            return nums[low];\\n        }\\n        int mid = (low + high) >> 1;\\n        int leftAns = majorityElement(nums, low, mid);\\n        int rightAns = majorityElement(nums, mid+1, high);\\n\\n        if(leftAns == rightAns){\\n            return leftAns;\\n        }\\n        int leftCount = countforRange(nums, low, high, leftAns);\\n        int rightCount = countforRange(nums, low, high, rightAns);\\n\\n        return leftCount > rightCount ? leftAns : rightAns;\\n    }\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        return majorityElement(nums, 0, nums.size()-1);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Boyer-Moore performs constant work exactly N times, so the algorithm runs in\\n    linear time. Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(1), Constant Space. \\n\\n    Solved using Boyer-Moore Voting Algorithm.\\n\\n*/\\n\\n\\n/***************************************** Approach 5 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int count = 0;\\n        int candidate = 0;\\n        for(auto num : nums){\\n            if(count == 0){\\n                candidate = num;\\n            }\\n            if(candidate == num){\\n                count++;\\n            }\\n            else{\\n                count--;\\n            }\\n        }\\n        return candidate;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Divide and Conquer",
                    "Sorting"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^2), The brute force algorithm contains two nested for loops that each run for N\\n    iterations, adding up to quadratic time complexity. Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(1), Constant Space. \\n\\n    Solved using Array(Two Nested Loops). Brute Force.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int countMajority = nums.size()/2;\\n        for(auto num : nums){\\n            int count = 0;\\n            for(auto element : nums){\\n                if(element == num){\\n                    count++;\\n                }\\n            }\\n            if(count > countMajority){\\n                return num;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), We iterate over Array(nums) once and make a constant time HashMap(Unordered map)\\n    insertion on each iteration. Therefore, the algorithm runs in O(N) time. Where N is the size of the Array\\n    (nums).\\n\\n    Space Complexity : O(N), Unordered map space. \\n\\n    Solved using Array + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, int> map;\\n        for(auto it : nums){\\n            map[it]++;\\n        }\\n        for(auto it : map){\\n            if(map[it.first] > n/2){\\n                return it.first;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(NlogN), Sorting the array(nums) costs O(NlogN). Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(1), Constant Space. \\n\\n    Solved using Array + Sorting.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        return nums[nums.size()/2];\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(NlogN), Each recursive call to performs two recursive calls on subslices of size N/2\\n\\u200B    and two linear scans of length N. Therefore, the time complexity of the divide & conquer approach can be\\n    represented by the following recurrence relation: T(N)=2T(N/2)+2N. Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(logN), Recursion Stack Space. \\n\\n    Solved using Array + Counting + Divide and Conquer.\\n\\n*/\\n\\n\\n/***************************************** Approach 4 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    int countforRange(vector<int>& nums, int low, int high, int target){\\n        int count = 0;\\n        for(int i=low; i<=high; i++){\\n            if(nums[i] == target){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    int majorityElement(vector<int>& nums, int low, int high){\\n        if(low == high){\\n            return nums[low];\\n        }\\n        int mid = (low + high) >> 1;\\n        int leftAns = majorityElement(nums, low, mid);\\n        int rightAns = majorityElement(nums, mid+1, high);\\n\\n        if(leftAns == rightAns){\\n            return leftAns;\\n        }\\n        int leftCount = countforRange(nums, low, high, leftAns);\\n        int rightCount = countforRange(nums, low, high, rightAns);\\n\\n        return leftCount > rightCount ? leftAns : rightAns;\\n    }\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        return majorityElement(nums, 0, nums.size()-1);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Boyer-Moore performs constant work exactly N times, so the algorithm runs in\\n    linear time. Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(1), Constant Space. \\n\\n    Solved using Boyer-Moore Voting Algorithm.\\n\\n*/\\n\\n\\n/***************************************** Approach 5 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int count = 0;\\n        int candidate = 0;\\n        for(auto num : nums){\\n            if(count == 0){\\n                candidate = num;\\n            }\\n            if(candidate == num){\\n                count++;\\n            }\\n            else{\\n                count--;\\n            }\\n        }\\n        return candidate;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51684,
                "title": "intuitive-javascript-solution",
                "content": "```\\nvar majorityElement = function(nums) {\\n    // sort the array and the middle is the majority\\n    nums.sort((a,b) => a - b);\\n    return nums[Math.floor(nums.length/2)];\\n}; \\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nvar majorityElement = function(nums) {\\n    // sort the array and the middle is the majority\\n    nums.sort((a,b) => a - b);\\n    return nums[Math.floor(nums.length/2)];\\n}; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3574861,
                "title": "java-solution-using-moore-s-voting-algorithm-step-by-step-explanation",
                "content": "# Approach\\nLet\\'s go through the provided code step by step:\\n\\n1. The code defines a class called `Solution`.\\n\\n2. Inside the class, there is a public method called `majorityElement`, which takes an integer array `nums` as its parameter and returns an integer.\\n\\n3. The method initializes two variables: `count` and `maxElement`. `count` is used to keep track of the count of the current majority element, while `maxElement` stores the current majority element itself.\\n\\n4. The code then starts a for-each loop, iterating over each element `num` in the `nums` array.\\n\\n5. Inside the loop, there is an `if` statement that checks whether `count` is equal to 0. This condition indicates that we have encountered a new potential majority element.\\n\\n6. If `count` is indeed 0, the `maxElement` is updated to the current `num` value, as this new element could potentially be the majority element.\\n\\n7. Following that, there is another `if` statement that compares `num` with the `maxElement`. If they are equal, it means we have encountered an occurrence of the majority element. In this case, the `count` is incremented by 1.\\n\\n8. If `num` is not equal to `maxElement`, it means we have encountered a different element. In such a case, the `count` is decremented by 1. This effectively cancels out one occurrence of the majority element against one occurrence of a different element.\\n\\n9. The loop continues this process for each element in the `nums` array.\\n\\n10. Once the loop finishes, the method returns the `maxElement`, which should be the majority element based on the provided algorithm.\\n\\nTo summarize, the code finds the majority element in the `nums` array using a variation of the Boyer-Moore Majority Vote algorithm. It iterates through the array, updating the `maxElement` whenever `count` becomes 0, and incrementing or decrementing `count` based on whether the current element matches the `maxElement` or not. The final value of `maxElement` represents the majority element.\\n\\n# Code\\n```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        int count = 0, maxElement = 0;\\n\\t\\t\\t\\tfor(int num: nums) {\\n\\t\\t\\t\\t\\tif(count == 0) {\\n\\t\\t\\t\\t\\t\\tmaxElement = num;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(num == maxElement) {\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn maxElement;\\n    }\\n}\\n```\\n\\n```\\nPlease upvote if you like the solution.\\nHappy Coding! \\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        int count = 0, maxElement = 0;\\n\\t\\t\\t\\tfor(int num: nums) {\\n\\t\\t\\t\\t\\tif(count == 0) {\\n\\t\\t\\t\\t\\t\\tmaxElement = num;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(num == maxElement) {\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn maxElement;\\n    }\\n}\\n```\n```\\nPlease upvote if you like the solution.\\nHappy Coding! \\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974907,
                "title": "2-line-easiest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n//given the condition, if any element appear more than n/2 times are called majority\\n//then we know our mid element means (n-1/2) is also our majority element if satisfied the given condition.\\n//simply return mid element.\\n        return nums[(nums.size()-1)/2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n//given the condition, if any element appear more than n/2 times are called majority\\n//then we know our mid element means (n-1/2) is also our majority element if satisfied the given condition.\\n//simply return mid element.\\n        return nums[(nums.size()-1)/2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787715,
                "title": "c-hashmap-moore-s-voting-algorithm-o-n",
                "content": "**Someone is intentionally downvoting answer , if you cannot support please dont spread hate**\\n**Upvote if helpful**\\n\\n* **Approach 1** -- *Hashmap*\\n```\\n1. use a unordered map to store freq of each element \\n2. traverse the map and check if the freq of any element > [n/2]\\n3. return answer\\n\\nTC - O(n)\\nSC - O(n)\\n```\\n* **Code 1**\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& arr) {\\n    unordered_map<int,int> m;\\n        for(auto x : arr){\\n            m[x]++;\\n            if(m[x] > arr.size()/2){\\n                return x;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n* **Approach 2** -- *Moore Voting Algorithm*\\n```\\nStep 1 \\u2013 Find a candidate with the majority \\u2013\\n\\nInitialize a variable say i ,votes = 0, candidate =-1 \\nTraverse through the array using for loop\\nIf votes = 0, choose the candidate = arr[i] , make votes=1.\\nelse if the current element is the same as the candidate increment votes\\nelse decrement votes.\\n\\nStep 2 \\u2013 Check if the candidate has more than N/2 votes \\u2013\\n\\n/* For this case we dont need to check if count > N/2 because it is confirmed element is present */\\n\\nInitialize a variable count =0 and increment count if it is the same as the candidate.\\nIf the count is >N/2, return the candidate.\\nelse return -1.\\n\\nTC - O(n)\\nSC - O(1)\\n```\\n\\n* **Intuition**\\n```\\nWhen the elements are the same as the candidate element, votes are incremented when some other element is found not equal to the candidate element. We decreased the count. This actually means that we are decreasing the priority of winning ability of the selected candidate, since we know that if the candidate is a majority it occurs more than N/2 times and the remaining elements are less than N/2. We keep decreasing the votes since we found some different element than the candidate element. When votes become 0, this actually means that there are the same number of different elements, which should not be the case for the element to be the majority element. So the candidate element cannot be the majority, so we choose the present element as the candidate and continue the same till all the elements get finished. The final candidate would be our majority element. We check using the 2nd traversal to see whether its count is greater than N/2. If it is true, we consider it as the majority element.\\n```\\n\\n* **Code**\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& arr) {\\n        int candidate=0,count=0,n=arr.size();\\n        for(int i=0;i<n;i++){\\n            if(count==0){\\n                candidate=arr[i];\\n            }\\n        if(arr[i]==candidate) count++;\\n        else count--;\\n    } \\n    return candidate;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n1. use a unordered map to store freq of each element \\n2. traverse the map and check if the freq of any element > [n/2]\\n3. return answer\\n\\nTC - O(n)\\nSC - O(n)\\n```\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& arr) {\\n    unordered_map<int,int> m;\\n        for(auto x : arr){\\n            m[x]++;\\n            if(m[x] > arr.size()/2){\\n                return x;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\nStep 1 \\u2013 Find a candidate with the majority \\u2013\\n\\nInitialize a variable say i ,votes = 0, candidate =-1 \\nTraverse through the array using for loop\\nIf votes = 0, choose the candidate = arr[i] , make votes=1.\\nelse if the current element is the same as the candidate increment votes\\nelse decrement votes.\\n\\nStep 2 \\u2013 Check if the candidate has more than N/2 votes \\u2013\\n\\n/* For this case we dont need to check if count > N/2 because it is confirmed element is present */\\n\\nInitialize a variable count =0 and increment count if it is the same as the candidate.\\nIf the count is >N/2, return the candidate.\\nelse return -1.\\n\\nTC - O(n)\\nSC - O(1)\\n```\n```\\nWhen the elements are the same as the candidate element, votes are incremented when some other element is found not equal to the candidate element. We decreased the count. This actually means that we are decreasing the priority of winning ability of the selected candidate, since we know that if the candidate is a majority it occurs more than N/2 times and the remaining elements are less than N/2. We keep decreasing the votes since we found some different element than the candidate element. When votes become 0, this actually means that there are the same number of different elements, which should not be the case for the element to be the majority element. So the candidate element cannot be the majority, so we choose the present element as the candidate and continue the same till all the elements get finished. The final candidate would be our majority element. We check using the 2nd traversal to see whether its count is greater than N/2. If it is true, we consider it as the majority element.\\n```\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& arr) {\\n        int candidate=0,count=0,n=arr.size();\\n        for(int i=0;i<n;i++){\\n            if(count==0){\\n                candidate=arr[i];\\n            }\\n        if(arr[i]==candidate) count++;\\n        else count--;\\n    } \\n    return candidate;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51901,
                "title": "2-line-java-solution-with-explaination",
                "content": "Since the element which appears for more than n/2 times in the array, it should always appear at the middle of a sorted one. After we sort it, simply return the number in the middle will solve the problem.\\n\\n    \\n    public int majorityElement(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[nums.length/2];\\n    }",
                "solutionTags": [],
                "code": "Since the element which appears for more than n/2 times in the array, it should always appear at the middle of a sorted one. After we sort it, simply return the number in the middle will solve the problem.\\n\\n    \\n    public int majorityElement(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[nums.length/2];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51839,
                "title": "java-2ms-o-n-solution",
                "content": "    public class Solution {\\n        public int majorityElement(int[] nums) {\\n            int res = nums[0];\\n            int count = 1;\\n        \\n            for (int num : nums) {\\n                if (res == num) ++count;\\n                else --count;\\n            \\n                if (count == 0) {\\n                    res = num;\\n                    count = 1;\\n                }\\n            }\\n        \\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int majorityElement(int[] nums) {\\n            int res = nums[0];\\n            int count = 1;\\n        \\n            for (int num : nums) {\\n                if (res == num) ++count;\\n                else --count;\\n            \\n                if (count == 0) {\\n                    res = num;\\n                    count = 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 616285,
                "title": "169-explanation-of-moore-s-algorithm-ft-star-wars",
                "content": "There are multiple ways to approach this problem, let\\'s have a look at the intuition behind some of them.\\n\\n**The quick and dirty (albeit slow) approach: Life\\'s too short for more than 2 lines of code**\\nThe majority element appears more than n/2 times. So IF the array was sorted, it would look somewhat like this:\\n`[smallElement1, smallElement2, .., majorityElement, majorityElement, majorityElement, .., bigElement1, bigElement2]`\\nor\\n`[smallElement1, smallElement2, .., majorityElement, majorityElement, majorityElement, .., majorityElement, majorityElement]`\\nor\\n`[majorityElement, majorityElement, .., majorityElement, majorityElement, majorityElement, .., bigElement1, bigElement2]`\\nIn each of these cases, since the #times the majority element occurs more than n/2 times, it\\'ll always be the center element. So our solution looks somewhat like\\n\\n```\\nSort(nums)\\nreturn nums[n/2]\\n```\\n\\n**The fast but memory-heavy approach: In HashMaps we trust**\\nBut sorting is O(nlogn), and we can\\'t have that that kind of complexity in our lives. Again, we\\'re just looking for an element that occurs n/2 times or more. Why not store a count of these elements. And an easy way to do that would be a HashMap. Minor optimisation, only one element can have more than n/2 occurences at one point of time. Let\\'s exit as soon as we find that one.\\n\\n```\\nHashMap counts;\\nfor num in nums\\n\\tcounts[num]++\\n\\tif counts[num] > n/2\\n\\t\\treturn num\\n// or, iterate through the hashmap and return the num with the largest count.\\n```\\n\\nWhile linear, this eats up O(n) memory. We can probably do better.\\n\\n**The fast, no memory approach: Survival of the numerous**\\nAssume, for a moment there are only two kinds of elements in the array. Jedi and Sith. One Jedi and one Sith cancel each other out. We know from the problem statement that there is no balance in the force - there\\'s more of one than the other. So who wins?\\nLet\\'s see who comes to the battlefield first. It\\'s a Jedi. They\\'re currently winning. 5 more Jedi come in, taking the count to 6. The Sith lords send in 7 soldiers, destroying the Jedi. Now the Sith are winning with 1. How do we put this in code?\\n\\n```\\nint currentWinner, count = 0\\nfor num in nums:\\n\\t// empty battlefield\\n\\tif count == 0 \\n\\t\\t// the currently visible person is winning\\n\\t\\tcurrentWinner = num\\n\\t\\tcount++\\n\\telse\\n\\t\\t// the battle is already on\\n\\t\\t// opposing force\\n\\t\\tif num != currentWinner\\n\\t\\t\\tcount--\\n\\t\\t// reinforcements\\n\\t\\telse\\n\\t\\t\\tcount++\\n// last side standing\\nreturn currentWinner\\n```\\n\\nThe world isn\\'t black and white. There are different kinds of forces, each opposing each other. However, we know that the winning force is in majority with greater than half the troops. So, let\\'s extend the above to multiple kinds of numbers. Again, the current winner is the one who is visible on the battlefield. If they get reinforcements, they increase their count. If an opposing force comes in, they lose their count. At some point the field is empty and the first settler takes in the role of the current winner. \\nHow does this ensure that the last force standing is the majority element? Well, a number cannot nullify itself. But it can be nullified by others. Since there are more of the majority than any other number, the maximum number of majority elments that can be nullified is equal to the sum of all opposing numbers. And we\\'ll still have some of the majority left. Hence, the above algorithm stands.\\n\\nThis is of course the [Moore\\'s Majority Vote Algorithm](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm) and this is how I think about it. It\\'s linear in time and constant in space.",
                "solutionTags": [],
                "code": "```\\nSort(nums)\\nreturn nums[n/2]\\n```\n```\\nHashMap counts;\\nfor num in nums\\n\\tcounts[num]++\\n\\tif counts[num] > n/2\\n\\t\\treturn num\\n// or, iterate through the hashmap and return the num with the largest count.\\n```\n```\\nint currentWinner, count = 0\\nfor num in nums:\\n\\t// empty battlefield\\n\\tif count == 0 \\n\\t\\t// the currently visible person is winning\\n\\t\\tcurrentWinner = num\\n\\t\\tcount++\\n\\telse\\n\\t\\t// the battle is already on\\n\\t\\t// opposing force\\n\\t\\tif num != currentWinner\\n\\t\\t\\tcount--\\n\\t\\t// reinforcements\\n\\t\\telse\\n\\t\\t\\tcount++\\n// last side standing\\nreturn currentWinner\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3807158,
                "title": "smartest-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe know that The majority element is the element that appears more than \\u230An / 2\\u230B times that will fill more than half of a array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet Sort the Array and return the element at [n/2] because it will be the part of ans for sure if it exist on either left or right side of the sorted array it must consist element at [n/2] for having The majority element is the element that appears more than \\u230An / 2\\u230B times.\\n\\n# Request\\nPlease Do Upvote If You Understand Like The Solution\\'s Approach \\uD83D\\uDE4F\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        int n = nums.length; \\n        Arrays.sort(nums);\\n        return nums[n/2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        int n = nums.length; \\n        Arrays.sort(nums);\\n        return nums[n/2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288207,
                "title": "awesome-logic-moore-s-voting-algorithm-o-n-and-space-o-1",
                "content": "# 1.With Space \\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        dic=defaultdict(int)\\n        n=len(nums)\\n        for i in nums:\\n            dic[i]+=1\\n            if dic[i]>n/2:\\n                return i\\n```\\n\\n# 2. Moore\\'s Voting Algorithm\\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        count=0\\n        result=0\\n        for n in nums:\\n            if count==0:\\n                result=n\\n            if n==result:\\n                count+=1\\n            else:\\n                count-=1\\n        return result\\n```\\n# please upvote me it would encourage me alot\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        dic=defaultdict(int)\\n        n=len(nums)\\n        for i in nums:\\n            dic[i]+=1\\n            if dic[i]>n/2:\\n                return i\\n```\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        count=0\\n        result=0\\n        for n in nums:\\n            if count==0:\\n                result=n\\n            if n==result:\\n                count+=1\\n            else:\\n                count-=1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420139,
                "title": "javascript-boyer-moore-voting-algorithm-faster-than-98-19",
                "content": "```\\nvar majorityElement = function(nums) {\\n    \\n    // Boyer-Moore Voting Algorithm\\n    \\n    let count = 0, candidate = 0\\n    \\n    for (let num of nums) {\\n        if (count == 0) {\\n            candidate = num\\n        }\\n        count += num == candidate ? 1 : -1\\n    }\\n    \\n    return candidate\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar majorityElement = function(nums) {\\n    \\n    // Boyer-Moore Voting Algorithm\\n    \\n    let count = 0, candidate = 0\\n    \\n    for (let num of nums) {\\n        if (count == 0) {\\n            candidate = num\\n        }\\n        count += num == candidate ? 1 : -1\\n    }\\n    \\n    return candidate\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51868,
                "title": "easy-understand-and-shortest-code",
                "content": "    public int majorityElement(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[nums.length/2];\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int majorityElement(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[nums.length/2];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51864,
                "title": "python-solution-sorting-hashmap-moore-voting-bit-manipulation",
                "content": "Refer to https://leetcode.com/discuss/67340/java-solutions-sorting-hashmap-moore-voting-manipulation\\nBit manipulation is somewhat different because of the python's syntax\\n\\n\\n    class Solution(object):\\n        def majorityElement(self, nums):\\n            nums.sort()\\n            return nums[len(nums)/2]\\n    \\n        # Boyer\\u2013Moore majority vote algorithm. Refer to:\\n        # https://en.wikipedia.org/wiki/Boyer\\u2013Moore_majority_vote_algorithm\\n        def majorityElement_moore(self, nums):\\n            majority_num = 0\\n            count = 0\\n            for num in nums:\\n                if count == 0:\\n                    majority_num = num\\n                if majority_num != num:\\n                    count -= 1\\n                else:\\n                    count += 1\\n            return majority_num\\n    \\n        # Hash table\\n        def majorityElement_hash(self, nums):\\n            num_len = len(nums)\\n            num_hash = {}\\n            for num in nums:\\n                num_hash[num] = num_hash.get(num, 0) + 1\\n                if num_hash[num] > num_len/2:\\n                    return num\\n    \\n        # Bit manipulation\\n        # Pay attention: in python -2147483648 >> 31 = -1\\n        def majorityElement_bit(self, nums):\\n            bit_bucket = [0 for i in range(33)]\\n            for num in nums:\\n                bit_bucket[32] += (num >> 32) & 1\\n                for i in range(32):\\n                    bit_bucket[i] += (abs(num) >> i) & 1\\n    \\n            majority_num = 0\\n            nums_len = len(nums)\\n            for i in range(32):\\n                if bit_bucket[i] > nums_len / 2:\\n                    majority_num += 1 << i\\n            if bit_bucket[32] > nums_len / 2:\\n                majority_num *= -1\\n            return majority_num",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "class Solution(object):\\n        def majorityElement(self, nums):\\n            nums.sort()\\n            return nums[len(nums)/2]\\n    \\n        # Boyer\\u2013Moore majority vote algorithm. Refer to:\\n        # https://en.wikipedia.org/wiki/Boyer\\u2013Moore_majority_vote_algorithm\\n        def majorityElement_moore(self, nums):\\n            majority_num = 0\\n            count = 0\\n            for num in nums:\\n                if count == 0:\\n                    majority_num = num\\n                if majority_num != num:\\n                    count -= 1\\n                else:\\n                    count += 1\\n            return majority_num\\n    \\n        # Hash table\\n        def majorityElement_hash(self, nums):\\n            num_len = len(nums)\\n            num_hash = {}",
                "codeTag": "Java"
            },
            {
                "id": 51857,
                "title": "8-ms-c-code-0-n",
                "content": "    int majorityElement(int* nums, int numsSize) {\\n    int i,j,k,count=0;\\n        j=nums[0];\\n    for(i=0;i<numsSize;i++)\\n    {\\n        if(count==0)\\n        j=nums[i];\\n        if(nums[i]==j)\\n        count++;\\n        else\\n        count--;\\n    }\\n    return j;\\n    }",
                "solutionTags": [],
                "code": "    int majorityElement(int* nums, int numsSize) {\\n    int i,j,k,count=0;\\n        j=nums[0];\\n    for(i=0;i<numsSize;i++)\\n    {\\n        if(count==0)\\n        j=nums[i];\\n        if(nums[i]==j)\\n        count++;\\n        else\\n        count--;\\n    }\\n    return j;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51905,
                "title": "my-answer-to-majority-element-java",
                "content": "    public class Solution {\\n    public int majorityElement(int[] num) {\\n        Arrays.sort(num);\\n        return num[num.length / 2];\\n    }}\\n\\nIf to be considered majority element, a value has to occur at least N / 2 times in the array, then you can assume that if the array was to be sorted, the majority element would fill a contiguous block in the array up to (and potentially passed) the length of the array divided by 2.\\n\\nSo all I did was sort the array and return the element at the array position equal to the length of the array divided by 2. Very expressive code, since it's just 2 lines, but it still took about 240ms to do since the sort algorithm needed to take its time to complete.\\n\\nCaveat: This solution only works if you can guarantee every time that there will be a majority element according to the rules set (at least N / 2 occurrences relative to the size of the array). If you can neither guarantee a majority element at all nor have the N / 2 rule in place, then this will not be suitable. If that's the case, you'll need to move onto a for-loop recording occurrences into a hash map. I tried a hash map solution which would tolerate neither of the above predicates being true, and it added about 90ms onto the running time from this solution.\\n\\nInteresting problem.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int majorityElement(int[] num) {\\n        Arrays.sort(num);\\n        return num[num.length / 2];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 51825,
                "title": "share-my-3-line-java-solution",
                "content": "    public class Solution {\\n        public int majorityElement(int[] nums) {\\n            int len = nums.length;\\n            Arrays.sort(nums);\\n            return nums[len/2];\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int majorityElement(int[] nums) {\\n            int len = nums.length;\\n            Arrays.sort(nums);\\n            return nums[len/2];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 51800,
                "title": "java-hashmap-sorting-and-moore-s-majority-vote-solutions",
                "content": "        \\n    public int majorityElement1(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num: nums) {\\n            if (map.containsKey(num))\\n                map.put(num, map.get(num) + 1);\\n            else\\n                map.put(num, 1);\\n            if (map.containsKey(num) && map.get(num) > nums.length/2)\\n                return num;\\n        }\\n        return -1;\\n    }\\n    \\n    public int majorityElement2(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[nums.length/2];\\n    }\\n    \\n    // Moore's majority vote method\\n    public int majorityElement(int[] nums) {\\n        int majority = 0;\\n        int count = 0;\\n        for (int num: nums) {\\n            if (count == 0)\\n                majority = num;\\n            if (num == majority)\\n                count ++;\\n            else \\n                count--;\\n        }\\n        return majority;\\n    }",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "        \\n    public int majorityElement1(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num: nums) {\\n            if (map.containsKey(num))\\n                map.put(num, map.get(num) + 1);\\n            else\\n                map.put(num, 1);\\n            if (map.containsKey(num) && map.get(num) > nums.length/2)\\n                return num;\\n        }\\n        return -1;\\n    }\\n    \\n    public int majorityElement2(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[nums.length/2];\\n    }\\n    \\n    // Moore's majority vote method\\n    public int majorityElement(int[] nums) {\\n        int majority = 0;\\n        int count = 0;\\n        for (int num: nums) {\\n            if (count == 0)\\n                majority = num;\\n            if (num == majority)\\n                count ++;\\n            else \\n                count--;\\n        }\\n        return majority;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1440964,
                "title": "c-easy-solution-o-n-with-explanation",
                "content": "```\\n// Do **upvote** if you like the solutions it motivates me :)\\n```\\nSolution 1 :\\n\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n\\t\\t// sort the array\\n        sort(nums.begin(), nums.end());\\n\\t\\t\\n\\t\\t// count variable to count the occurrences\\n        int count = 1;\\n        int size = nums.size();\\n\\t\\t\\n\\t\\t// if size is one or two return the first element ( as per constraints that there is always one element present with more occurrences )\\n        if(size == 1 || size == 2){\\n            return nums[0];\\n        }\\n\\t\\t\\n\\t\\t// iterate over the array ( same elements will be together due to sorting )\\n        for(int i = 0; i < size; i++){\\n           if(nums[i] == nums[i+1]){\\n               count++;\\n           }else{\\n\\t\\t\\t   // check if size of count is more than half of the size of array\\n               if(count > (size/2)){\\n                   return nums[i];\\n               }\\n               count = 1;\\n           }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\nSolution 2:\\n```\\n// Solved using Moore voting algorithm\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n\\t\\t// Initialize count variable to count the occurrence and ele variable to keep track of element which is being counted\\n        int count = 0;\\n        int ele = 0;\\n        \\n\\t\\t\\n        for(int i = 0; i < nums.size(); i++){\\n\\t\\t\\t// if count is 0 then assign the current element to ele variable\\n            if(count == 0){\\n                ele = nums[i];\\n            }\\n            // if nums[i] equals to ele then increase the count or else decrease\\n            if(ele == nums[i]){\\n                count+= 1;\\n            }else{\\n                count-= 1;\\n            }\\n        }\\n        \\n        return ele;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Do **upvote** if you like the solutions it motivates me :)\\n```\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n\\t\\t// sort the array\\n        sort(nums.begin(), nums.end());\\n\\t\\t\\n\\t\\t// count variable to count the occurrences\\n        int count = 1;\\n        int size = nums.size();\\n\\t\\t\\n\\t\\t// if size is one or two return the first element ( as per constraints that there is always one element present with more occurrences )\\n        if(size == 1 || size == 2){\\n            return nums[0];\\n        }\\n\\t\\t\\n\\t\\t// iterate over the array ( same elements will be together due to sorting )\\n        for(int i = 0; i < size; i++){\\n           if(nums[i] == nums[i+1]){\\n               count++;\\n           }else{\\n\\t\\t\\t   // check if size of count is more than half of the size of array\\n               if(count > (size/2)){\\n                   return nums[i];\\n               }\\n               count = 1;\\n           }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\n```\\n// Solved using Moore voting algorithm\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n\\t\\t// Initialize count variable to count the occurrence and ele variable to keep track of element which is being counted\\n        int count = 0;\\n        int ele = 0;\\n        \\n\\t\\t\\n        for(int i = 0; i < nums.size(); i++){\\n\\t\\t\\t// if count is 0 then assign the current element to ele variable\\n            if(count == 0){\\n                ele = nums[i];\\n            }\\n            // if nums[i] equals to ele then increase the count or else decrease\\n            if(ele == nums[i]){\\n                count+= 1;\\n            }else{\\n                count-= 1;\\n            }\\n        }\\n        \\n        return ele;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51829,
                "title": "java-o-n-time-o-1-space-optimal-solution",
                "content": "    public class Solution {\\n        public int majorityElement(int[] nums) {\\n            int candidate = 0;\\n            int count = 0;\\n            for (int num : nums) {\\n                if (count == 0) {\\n                    candidate = num;\\n                    count++;\\n                } else if (candidate == num) {\\n                    count++;\\n                } else {\\n                    count--;\\n                }\\n            }\\n            return candidate;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int majorityElement(int[] nums) {\\n            int candidate = 0;\\n            int count = 0;\\n            for (int num : nums) {\\n                if (count == 0) {\\n                    candidate = num;\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1788466,
                "title": "python-3-different-solutions-explained-in-detail",
                "content": "**1) Hashmap - Time and Space = O(N)**\\n\\nThe first idea that would come up in our mind is to use a hashmap to store the frequency of every element present in nums. So we can use the Counter from collections library to simplify the process. \\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        return Counter(nums).most_common()[0][0]\\n```\\nNow, we can see the above solution uses extra space. Which the interviewer is always not a big fan of. So how can we do it in O(1) space.\\n\\n**2) Sorting and sliding window - Time = O(N log N), Space = O(1)**\\n\\nIf the given `nums = [2,2,3,2,3,4,2]`, if we sort it we get `nums = [2,2,2,2,3,3,4]`. We can see that we can use a siliding window techinique to increase our windows size and calculate the occurance of each element. \\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        nums.sort()\\n        maxi, ans = 0, 0\\n        N, i = len(nums), 1\\n        if N == 1: return nums[0]\\n        while i < N:\\n            cnt = 1\\n            while i < N and nums[i] == nums[i-1]:\\n                cnt += 1\\n                i += 1\\n            if cnt > maxi:\\n                maxi = cnt\\n                ans = nums[i-1]\\n            i += 1\\n            \\n        return ans\\n```\\n\\nOops, interview is now not happy with your time complexity :( \\n\\n**3) The best we can give - Time = O(N), Space = O(1)**\\n\\nNow, look at the question again closely. They have mentioned that we have to find a number which occurs more than N/2 times. Let us consider that number to be x. Now think that this array is voters data set. Each element tells who the person voted for, and we already know that x will be our winner. So in prespective of x, every entry in the array which is not equal to x, is a lose for him and every occurence of x is a gain to him. That\\'s the only logic we need to solve this problem. \\n\\nWe keep a global variable which keeps track of the votes for x. And we loop through each element in the nums. If the current iterated element == x, we increment our global vote variable by 1, else we decrease it by 1. Also whenever the gloabl vote varibale is zero, we keep track of the majority voted person, i.e., the first element we encounter when vote == 0. This indeed will be our answer.\\n\\nThis algorithm is commonly known as **Moore\\'s Majority Voting algorithm**\\n\\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        vote, majority = 0, None\\n        \\n        for n in nums:\\n            if vote == 0: majority = n\\n            vote += (1 if majority == n else -1)\\n        \\n        return majority\\n```\\n\\n***Upvote, if this helped***\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        return Counter(nums).most_common()[0][0]\\n```\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        nums.sort()\\n        maxi, ans = 0, 0\\n        N, i = len(nums), 1\\n        if N == 1: return nums[0]\\n        while i < N:\\n            cnt = 1\\n            while i < N and nums[i] == nums[i-1]:\\n                cnt += 1\\n                i += 1\\n            if cnt > maxi:\\n                maxi = cnt\\n                ans = nums[i-1]\\n            i += 1\\n            \\n        return ans\\n```\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        vote, majority = 0, None\\n        \\n        for n in nums:\\n            if vote == 0: majority = n\\n            vote += (1 if majority == n else -1)\\n        \\n        return majority\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242079,
                "title": "solution-swift-majority-element-test-cases",
                "content": "```swift\\nclass Solution {\\n    func majorityElement(_ nums: [Int]) -> Int {\\n        var candidate = 0, vote = 0\\n        nums.forEach { n in\\n            if vote == 0 { candidate = n }\\n            vote += n == candidate ? 1 : -1\\n        }\\n        return candidate\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 2 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.majorityElement([3,2,3])\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    func test1() {\\n        let value = solution.majorityElement([2,2,1,1,1,2,2])\\n        XCTAssertEqual(value, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func majorityElement(_ nums: [Int]) -> Int {\\n        var candidate = 0, vote = 0\\n        nums.forEach { n in\\n            if vote == 0 { candidate = n }\\n            vote += n == candidate ? 1 : -1\\n        }\\n        return candidate\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.majorityElement([3,2,3])\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    func test1() {\\n        let value = solution.majorityElement([2,2,1,1,1,2,2])\\n        XCTAssertEqual(value, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51963,
                "title": "share-my-25ms-c-solution-with-o-1-memory",
                "content": "The idea is to arrange the numbers in an order that no two successive numbers are same until all the remaining numbers are the same. Therefore, the last number will be the answer.\\n\\n    int majorityElement(vector<int> &num) {\\n        for (int i = 1, j = 1; j < num.size(); i++){\\n            if (num[i] == num[i - 1]){\\n                while (j < num.size() && num[j] == num[i]){\\n                    j++;\\n                }\\n                if (j < num.size()){\\n                    num[i] ^= num[j] ^= num[i] ^= num[j];\\n                }\\n            }else{\\n                j++;\\n            }\\n        }\\n        return num[num.size() - 1];\\n    }",
                "solutionTags": [],
                "code": "The idea is to arrange the numbers in an order that no two successive numbers are same until all the remaining numbers are the same. Therefore, the last number will be the answer.\\n\\n    int majorityElement(vector<int> &num) {\\n        for (int i = 1, j = 1; j < num.size(); i++){\\n            if (num[i] == num[i - 1]){\\n                while (j < num.size() && num[j] == num[i]){\\n                    j++;\\n                }\\n                if (j < num.size()){\\n                    num[i] ^= num[j] ^= num[i] ^= num[j];\\n                }\\n            }else{\\n                j++;\\n            }\\n        }\\n        return num[num.size() - 1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1664348,
                "title": "better-time-complexity-solution-with-full-explanation-in-c",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n## Explanation:\\n\\n### Solution 01\\n\\n- Basic idea is that we will sort the array and the element which is present more than size/2 time must appear at the mid of the vector.\\n- Return the middle element.\\n- **Time complexity:** O(nlogn).\\n\\n### Solution 02\\n\\n- As sorting takes nlogn time, so in this solution we won\\u2019t use sorting.\\n- The element will present more than n/2 times, so we start to count for any element ***(majority)*** thinking that is our answer.\\n- If the count is 0, we\\u2019ll take the element as the majority, increase if the element is equal to the majority & decrease if the element doesn\\u2019t match.\\n- Finally, after the loop end whoever stays as the majority, that\\'s our answer.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int n= nums.size();\\n        sort(nums.begin(), nums.end());\\n        return nums[n/2];\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int majority, count = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(count == 0){\\n                majority = nums[i];\\n            }\\n            if(majority == nums[i]) count++;\\n            else count--;\\n        }\\n        return majority;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int n= nums.size();\\n        sort(nums.begin(), nums.end());\\n        return nums[n/2];\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int majority, count = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(count == 0){\\n                majority = nums[i];\\n            }\\n            if(majority == nums[i]) count++;\\n            else count--;\\n        }\\n        return majority;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819635,
                "title": "python-simple-solution-98-faster-time-o-n-spaceo-1",
                "content": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        element, cnt = 0, 0\\n\\n        for e in nums:\\n            if element == e:\\n                cnt += 1\\n            elif cnt == 0:\\n                element, cnt = e, 1\\n            else:\\n                cnt -= 1\\n\\n        return element\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        element, cnt = 0, 0\\n\\n        for e in nums:\\n            if element == e:\\n                cnt += 1\\n            elif cnt == 0:\\n                element, cnt = e, 1\\n            else:\\n                cnt -= 1\\n\\n        return element\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51876,
                "title": "c-solution-with-moore-s-voting-algorithm",
                "content": "Moore's Voting Algoritm\\n\\n    class Solution {\\n    public:\\n        int majorityElement(vector<int>& nums) {\\n            int cnt = 0;\\n            int candidate = 0;\\n            for (int n : nums) {\\n                if (cnt == 0) {\\n                    candidate = n;\\n                    cnt++;\\n                }\\n                else {\\n                    if (candidate == n) cnt++;\\n                    else cnt--;\\n                }\\n            }\\n            return candidate;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int majorityElement(vector<int>& nums) {\\n            int cnt = 0;\\n            int candidate = 0;\\n            for (int n : nums) {\\n                if (cnt == 0) {\\n                    candidate = n;\\n                    cnt++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 51994,
                "title": "java-o-n-solution-with-constant-memory",
                "content": "    /*\\n    Moore\\u2019s Voting Algorithm\\n    */\\n    \\n    public class Solution {\\n        public int majorityElement(int[] num) {\\n            int maj=0;\\n            int count = 0;\\n            int n = num.length;\\n            for (int i = 0; i < n; i++){\\n                if (count == 0){\\n                    maj = num[i];\\n                    count++;\\n                }\\n                else if (num[i] == maj){\\n                    count++;\\n                    if (count > n/2) return maj;\\n                }\\n                else count--;\\n            }\\n            return maj;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int majorityElement(int[] num) {\\n            int maj=0;\\n            int count = 0;\\n            int n = num.length;\\n            for (int i = 0; i < n; i++){\\n                if (count == 0){\\n                    maj = num[i];\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3226883,
                "title": "simple-two-line-python-o-1-space-and-o-nlogn-time-complexity",
                "content": "# Approach\\nIf we sort the array, the middle element would always be the majority element -- the majority element would overarch more than half of the array. \\n\\n# Complexity\\n- Time complexity: O(NLogN) from sorting \\n- Space complexity: O(1) -- we are not adding extra space. \\n# Code\\n```\\nclass Solution(object):\\n    def majorityElement(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        return nums[len(nums) // 2]\\n```\\n\\nHere\\'s why you should upvote my solution: I\\'m not lee215 but I also am kinda smart and write very concise code :)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def majorityElement(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        return nums[len(nums) // 2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787865,
                "title": "c-detailed-explanation-w-funny-story-two-approaches-dry-run",
                "content": "**Brief note about Question-**\\n* We have to return the element that appears more than \\u230An / 2\\u230B times. (so called majority element).\\n```\\nLet\\'s take an example not given in question -\\nSuppose our array given to us is arr[]: [7,2,3,4,7,7,7,7]\\n\\nnow, the size of the array is 8. \\nFor a majority element to be exist it should appear more than \\u230A8 / 2\\u230B = 4 times.\\nSo, the answer should be \\'7\\' as it apppars more 4 times i.e 5 times.\\n```\\n_____________________\\n***Solution - I (Using unordered map, Accepted)-***\\n* First super simple thing that we can see is answer will always exist.\\n* If we see then we find that we have to consider element whose **frequency is more than \\u230An / 2\\u230B** times.\\n* Now, for the name of` frequency`, we remember our superhero i.e `unordered map`.\\n* So, we will store the frequency of each element in our map & after that we start traversing from the map.\\n* Whenever we find an element whose frequency is more than \\u230An / 2\\u230B times, we called that majority element and return that element as our answer.\\n____________\\n```\\nTime Complexity --> O(n) // as we are using traversing array only once and n is the size of the array \\nSpace Complexity --> O(n) // as we are using unordered map to store the frequency of each element.\\n\\nIt paases [ 47 /  47 ] in built test cases\\n```\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& arr) {\\n        int n = arr.size(); // extracting the size of the array\\n        \\n        unordered_map<int,int> mp; // unordered map to store frequency\\n        \\n        for(int i = 0; i < n; i++) // travrsing from the array to store frequency\\n        {\\n            mp[arr[i]]++;\\n        }\\n        \\n        int ans; // ans variable to store frequency\\n        \\n        for(auto x: mp) // traverse from the map\\n        {\\n            // if frequency of any element is greater than n / 2 times\\n            if(x.second > n / 2) \\n            {\\n                ans = x.first; // store it in answer\\n                break; // break the loop\\n            }\\n        }\\n        \\n        return ans; // return answer\\n    }\\n};\\n```\\n_______________\\n***Solution - II (Moore vooting algorithm, Accepted)-***\\n* This question becomes more easy when it says that **we may assume that the majority element always exists in the array.**\\n* If we already know that answer will always going to exist then we start finding our majority element by **assuming our majority element as the element present at zero index.**\\n* For a **majority element defination we know that element that appears more than \\u230An / 2\\u230Btimes in the array.**\\n_____________\\n***Generating intuation in a funny way-***\\n* **If we consider our majority element as hero, and all other element as villian**, then we will always know no matter what happen our majority element (hero) will always going to win the war.\\n* Because, **every time we counters a viilian, both will decrease each other powers.**\\n* And we know already that majority element always occur more than \\u230An / 2\\u230B times, so in last it will going to win the war.\\n* Also we know, **if it is the majority element than in last it will remain alive by killing all other monsters with power of atleast 1.**\\n* Then question is, How we will implement this in our code?\\n_____________\\n***Implementation-***\\n* **Intially, we assume zero index element as our majority element** that and then start traversing the array.\\n* Now, suppose it encounters any other element(say villian) then, what will they both do, they both will decrease each other\\'s power.\\n* And **if power of our majority element becomes zero** then **we say maybe you are not our hero**, so **at that point we make majority element to current element give him power of 1**.\\n* In this way, we travel in the whole array and at last it is given in the question that answer will always exist so whatever the majority element at last we are having that will be our actual majority element.\\n* See with an example-\\n```\\nSuppose our array given to us is arr[]: [7,2,3,7,4,7,7,7]\\nSo, suppose intially \\'7\\' is our majority element (our hero) and intially it\\'s power as 1.\\n \\nNow start travering the array\\narr[]: [7, 2, 3, 7, 4, 7, 7, 7]\\n           \\u2191\\n\\t\\t   It encounters different element (we say villian) then both will decrease each other power.\\n\\t\\t   Therefore, power of our majority element becomes zero. \\n\\t\\t   Now we say maybe you are not our hero, \\n\\t\\t   so we will change our majority element to 2 and give power of 1.\\n\\narr[]: [7, 2, 3, 7, 4, 7, 7, 7]\\n              \\u2191\\n\\t\\t\\t  It encounters different element (we say villian) then both will decrease each other power.\\n\\t\\t      Therefore, power of our majority element becomes zero. \\n\\t\\t      Now we say maybe you are not our hero, \\n\\t\\t      so we will change our majority element to 3 and give power of 1.\\n\\narr[]: [7, 2, 3, 7, 4, 7, 7, 7]\\n                 \\u2191\\n\\t\\t\\t\\t It encounters different element (we say villian) then both will decrease each other power.\\n\\t\\t         Therefore, power of our majority element becomes zero. \\n\\t\\t         Now we say maybe you are not our hero, \\n\\t\\t         so we will change our majority element to 7 and give power of 1.\\n\\narr[]: [7, 2, 3, 7, 4, 7, 7, 7]\\n                    \\u2191\\n\\t\\t\\t\\t\\tIt encounters different element (we say villian) then both will decrease each other power.\\n\\t\\t            Therefore, power of our majority element becomes zero. \\n\\t\\t            Now we say maybe you are not our hero, \\n\\t\\t            so we will change our majority element to 4 and give power of 1.\\n\\t\\t\\t\\t\\t\\narr[]: [7, 2, 3, 7, 4, 7, 7, 7]\\n                       \\u2191\\n\\t\\t\\t\\t\\t   It encounters different element (we say villian) then both will decrease each other power.\\n\\t\\t               Therefore, power of our majority element becomes zero. \\n\\t\\t               Now we say maybe you are not our hero, \\n\\t\\t               so we will change our majority element to 7 and give power of 1.\\n\\t\\t\\t\\t\\t   \\narr[]: [7, 2, 3, 7, 4, 7, 7, 7]\\n                          \\u2191\\n\\t\\t\\t\\t\\t\\t  Now, it counters the same element we say, okay, we beleive in you, so you continue.\\n\\t\\t\\t\\t\\t\\t  Power of our hero now becomes 2.\\n\\t\\t\\t\\t\\t\\t  \\narr[]: [7, 2, 3, 7, 4, 7, 7, 7]\\n                             \\u2191\\n\\t\\t\\t\\t\\t\\t      Now, it counters the same element we say, okay, we beleive in you, so you continue.\\n\\t\\t\\t\\t\\t\\t      Power of our hero now becomes 3.\\n\\t\\t\\t\\t\\t\\t  \\nAnd at last we see our current hero, that comes out to be \\'7\\'.\\nSo, we will say 7 is our majority element and it should be our answer.\\n```\\n_________\\n```\\nTime Complexity --> O(n) // as we are using traversing array only once and n is the size of the array \\nSpace Complexity --> O(1) // as we are not using anything extra from our side\\n\\nIt paases [ 47 /  47 ] in built test cases\\n```\\n____\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& arr) {\\n        int n = arr.size(); // extracting the size of the array\\n        \\n        int hero = arr[0]; // Intially assume our majority element of index zero \\n        int power = 1; // count of majority element\\n        \\n        for(int i = 1; i < n; i++) // start traversing from the array\\n        {\\n            if(arr[i] == hero) // if same element encounters\\n            {\\n                power++; // increase the power of element\\n            }\\n            else // if not same element\\n            {\\n                // decrease power 1, as it used to kill the villian\\n                power = power - 1; \\n                \\n                // if power of our hero becomes zero at any point,\\n                // we say may be your are not our hero, so assign new hero\\n                if(power == 0)\\n                {\\n                    hero = arr[i]; // assigning hero\\n                    power = 1; // make it\\'s power to 1\\n                }\\n            }\\n        }\\n        \\n        return hero; // and at last whatever the hero is present should be our answer\\n    }\\n};\\n```\\n_____\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nLet\\'s take an example not given in question -\\nSuppose our array given to us is arr[]: [7,2,3,4,7,7,7,7]\\n\\nnow, the size of the array is 8. \\nFor a majority element to be exist it should appear more than \\u230A8 / 2\\u230B = 4 times.\\nSo, the answer should be \\'7\\' as it apppars more 4 times i.e 5 times.\\n```\n```\\nTime Complexity --> O(n) // as we are using traversing array only once and n is the size of the array \\nSpace Complexity --> O(n) // as we are using unordered map to store the frequency of each element.\\n\\nIt paases [ 47 /  47 ] in built test cases\\n```\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& arr) {\\n        int n = arr.size(); // extracting the size of the array\\n        \\n        unordered_map<int,int> mp; // unordered map to store frequency\\n        \\n        for(int i = 0; i < n; i++) // travrsing from the array to store frequency\\n        {\\n            mp[arr[i]]++;\\n        }\\n        \\n        int ans; // ans variable to store frequency\\n        \\n        for(auto x: mp) // traverse from the map\\n        {\\n            // if frequency of any element is greater than n / 2 times\\n            if(x.second > n / 2) \\n            {\\n                ans = x.first; // store it in answer\\n                break; // break the loop\\n            }\\n        }\\n        \\n        return ans; // return answer\\n    }\\n};\\n```\n```\\nSuppose our array given to us is arr[]: [7,2,3,7,4,7,7,7]\\nSo, suppose intially \\'7\\' is our majority element (our hero) and intially it\\'s power as 1.\\n \\nNow start travering the array\\narr[]: [7, 2, 3, 7, 4, 7, 7, 7]\\n           \\u2191\\n\\t\\t   It encounters different element (we say villian) then both will decrease each other power.\\n\\t\\t   Therefore, power of our majority element becomes zero. \\n\\t\\t   Now we say maybe you are not our hero, \\n\\t\\t   so we will change our majority element to 2 and give power of 1.\\n\\narr[]: [7, 2, 3, 7, 4, 7, 7, 7]\\n              \\u2191\\n\\t\\t\\t  It encounters different element (we say villian) then both will decrease each other power.\\n\\t\\t      Therefore, power of our majority element becomes zero. \\n\\t\\t      Now we say maybe you are not our hero, \\n\\t\\t      so we will change our majority element to 3 and give power of 1.\\n\\narr[]: [7, 2, 3, 7, 4, 7, 7, 7]\\n                 \\u2191\\n\\t\\t\\t\\t It encounters different element (we say villian) then both will decrease each other power.\\n\\t\\t         Therefore, power of our majority element becomes zero. \\n\\t\\t         Now we say maybe you are not our hero, \\n\\t\\t         so we will change our majority element to 7 and give power of 1.\\n\\narr[]: [7, 2, 3, 7, 4, 7, 7, 7]\\n                    \\u2191\\n\\t\\t\\t\\t\\tIt encounters different element (we say villian) then both will decrease each other power.\\n\\t\\t            Therefore, power of our majority element becomes zero. \\n\\t\\t            Now we say maybe you are not our hero, \\n\\t\\t            so we will change our majority element to 4 and give power of 1.\\n\\t\\t\\t\\t\\t\\narr[]: [7, 2, 3, 7, 4, 7, 7, 7]\\n                       \\u2191\\n\\t\\t\\t\\t\\t   It encounters different element (we say villian) then both will decrease each other power.\\n\\t\\t               Therefore, power of our majority element becomes zero. \\n\\t\\t               Now we say maybe you are not our hero, \\n\\t\\t               so we will change our majority element to 7 and give power of 1.\\n\\t\\t\\t\\t\\t   \\narr[]: [7, 2, 3, 7, 4, 7, 7, 7]\\n                          \\u2191\\n\\t\\t\\t\\t\\t\\t  Now, it counters the same element we say, okay, we beleive in you, so you continue.\\n\\t\\t\\t\\t\\t\\t  Power of our hero now becomes 2.\\n\\t\\t\\t\\t\\t\\t  \\narr[]: [7, 2, 3, 7, 4, 7, 7, 7]\\n                             \\u2191\\n\\t\\t\\t\\t\\t\\t      Now, it counters the same element we say, okay, we beleive in you, so you continue.\\n\\t\\t\\t\\t\\t\\t      Power of our hero now becomes 3.\\n\\t\\t\\t\\t\\t\\t  \\nAnd at last we see our current hero, that comes out to be \\'7\\'.\\nSo, we will say 7 is our majority element and it should be our answer.\\n```\n```\\nTime Complexity --> O(n) // as we are using traversing array only once and n is the size of the array \\nSpace Complexity --> O(1) // as we are not using anything extra from our side\\n\\nIt paases [ 47 /  47 ] in built test cases\\n```\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& arr) {\\n        int n = arr.size(); // extracting the size of the array\\n        \\n        int hero = arr[0]; // Intially assume our majority element of index zero \\n        int power = 1; // count of majority element\\n        \\n        for(int i = 1; i < n; i++) // start traversing from the array\\n        {\\n            if(arr[i] == hero) // if same element encounters\\n            {\\n                power++; // increase the power of element\\n            }\\n            else // if not same element\\n            {\\n                // decrease power 1, as it used to kill the villian\\n                power = power - 1; \\n                \\n                // if power of our hero becomes zero at any point,\\n                // we say may be your are not our hero, so assign new hero\\n                if(power == 0)\\n                {\\n                    hero = arr[i]; // assigning hero\\n                    power = 1; // make it\\'s power to 1\\n                }\\n            }\\n        }\\n        \\n        return hero; // and at last whatever the hero is present should be our answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51793,
                "title": "java-without-sort-or-hashmap",
                "content": "    public class Solution {\\n        public int majorityElement(int[] nums) {\\n            if (nums == null || nums.length ==0){\\n                return 0;\\n            }\\n            int count = 1;\\n            int major = nums[0];\\n            for (int i = 1; i < nums.length; i++){\\n                if (nums[i] != major){\\n                    count--;\\n                } else {\\n                    count++;\\n                }\\n                if (count == 0){\\n                    major = nums[i];\\n                    count = 1;\\n                }\\n            }\\n            return major;\\n        }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n        public int majorityElement(int[] nums) {\\n            if (nums == null || nums.length ==0){\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 51861,
                "title": "accepted-java-solution",
                "content": "public class Solution {\\n\\n    public int majorityElement(int[] num) {\\n\\n        Arrays.sort(num);\\n\\n        return num[num.length/2];\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int majorityElement(int[] num) {\\n\\n        Arrays.sort(num);\\n\\n        return num[num.length/2];\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3346654,
                "title": "c-easy-approach-using-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach of the code is to sort the input vector in non-decreasing order using the sort() function from the standard library. Since the majority element appears more than n/2 times in a vector of length n, the middle element after sorting the vector will be the majority element.\\n\\nTherefore, the code computes the index of the middle element using n/2, where n is the size of the vector. \\n\\nThe code returns the element at this index, which is the majority element.\\n\\nDue to the use of the sort() function and the in-place sorting, this solution has an overall time complexity of O(n log n) and a space complexity of O(1).\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlog(n))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        \\n        int k=nums.size()/2;\\n        int n=nums.size();\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        return nums[n/2];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        \\n        int k=nums.size()/2;\\n        int n=nums.size();\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        return nums[n/2];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789315,
                "title": "o-n-time-solution-using-boyer-moore-majority-vote-algorithm",
                "content": "Boyer Moore voting algorithm is used to find the majority element among the given sequence of elements which occurs more than N/2 times, in linear time complexity and constant space complexity.\\n\\nHere\\'s a diagram to explain the sequence we will follow. \\n\\nLet\\'s assume an array of the following elements, by counting we can say the majority element is 7, but let\\'s see how the voting algorithm works.\\n\\n![image](https://assets.leetcode.com/users/images/ac040209-5bb8-42de-8de8-25c3fbdc2df5_1645460881.7335103.png)\\n\\n**Code**\\n```java\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        int major=nums[0],count=1;\\n        for(int i=1;i<nums.length;i++){\\n            if(count==0){\\n                major=nums[i];\\n                count++;\\n            }\\n            else if(major==nums[i]){\\n                count++;\\n            }else{\\n                count--;\\n            }\\n        }\\n        return major;\\n    }\\n}\\n```\\n\\nI hope you understood the solution.\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        int major=nums[0],count=1;\\n        for(int i=1;i<nums.length;i++){\\n            if(count==0){\\n                major=nums[i];\\n                count++;\\n            }\\n            else if(major==nums[i]){\\n                count++;\\n            }else{\\n                count--;\\n            }\\n        }\\n        return major;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1512681,
                "title": "c-python-o-n-time-o-1-space",
                "content": "**Time complexity** : *o(n)*\\n**Space complexity** : *o(1)*\\n\\n**C++ :**\\n\\n```\\nint majorityElement(vector<int>& nums) {\\n\\tint candidate = nums[0], count = 1;\\n\\n\\tfor(int i = 1; i < nums.size(); ++i)\\n\\t{\\n\\t\\tif(!count)\\n\\t\\t\\tcandidate = nums[i];\\n\\t\\tif(nums[i] == candidate)\\n\\t\\t\\t++count;\\n\\t\\telse\\n\\t\\t\\t--count;\\n\\t}\\n\\n\\treturn candidate;\\n}\\n```\\n\\n**Python :**\\n\\n```\\ndef majorityElement(self, nums: List[int]) -> int:\\n\\tcandidate = nums[0]\\n\\tcount = 1\\n\\n\\tfor i in range(1, len(nums)):\\n\\t\\tif not count:\\n\\t\\t\\tcandidate = nums[i]\\n\\n\\t\\tif nums[i] == candidate:\\n\\t\\t\\tcount += 1\\n\\n\\t\\telse:\\n\\t\\t\\tcount -= 1\\n\\n\\treturn candidate\\n```\\n\\n**Like it ?please upvote !**",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nint majorityElement(vector<int>& nums) {\\n\\tint candidate = nums[0], count = 1;\\n\\n\\tfor(int i = 1; i < nums.size(); ++i)\\n\\t{\\n\\t\\tif(!count)\\n\\t\\t\\tcandidate = nums[i];\\n\\t\\tif(nums[i] == candidate)\\n\\t\\t\\t++count;\\n\\t\\telse\\n\\t\\t\\t--count;\\n\\t}\\n\\n\\treturn candidate;\\n}\\n```\n```\\ndef majorityElement(self, nums: List[int]) -> int:\\n\\tcandidate = nums[0]\\n\\tcount = 1\\n\\n\\tfor i in range(1, len(nums)):\\n\\t\\tif not count:\\n\\t\\t\\tcandidate = nums[i]\\n\\n\\t\\tif nums[i] == candidate:\\n\\t\\t\\tcount += 1\\n\\n\\t\\telse:\\n\\t\\t\\tcount -= 1\\n\\n\\treturn candidate\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 51933,
                "title": "ac-python-1-line-nlogn-time",
                "content": "\\n\\n    class Solution:\\n        # @param num, a list of integers\\n        # @return an integer\\n        def majorityElement(self, num):\\n            return sorted(num)[len(num)/2]",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\n    class Solution:\\n        # @param num, a list of integers\\n        # @return an integer\\n        def majorityElement(self, num):\\n            return sorted(num)[len(num)/2]",
                "codeTag": "Java"
            },
            {
                "id": 51976,
                "title": "my-o-n-solution",
                "content": "I think this is one of the classical selection problem. The idea is simple, each time, pick any two elements, if they're different, then, remove both of them. As the majority element appears more than n/2 times, when the whole array is scanned once, it's guaranteed that the remaining elements are the majority ones. \\n\\n    class Solution {\\n    public:\\n        int majorityElement(vector<int> &num) {\\n            int i = 0;\\n            int j = 1;\\n            while ( j < num.size() )\\n            {\\n                if ( num[i] != num[j] )\\n                {\\n                    swap(num[i+1], num[j]);\\n                    i += 2;\\n                }\\n                ++j;\\n            }\\n            return num[i];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int majorityElement(vector<int> &num) {\\n            int i = 0;\\n            int j = 1;\\n            while ( j < num.size() )\\n            {\\n                if ( num[i] != num[j] )\\n                {\\n                    swap(num[i+1], num[j]);\\n                    i += 2;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 51880,
                "title": "moore-voting-algorithm",
                "content": "    // Moore voting algorithm: Runtime: O(n), Space O(1)\\n    // We maintain a current candidate and a counter initialized to 0. \\n    // As we iterate the array, we look at the current element x: \\n    // If the counter is 0, we set the current candidate to x and the counter to 1.\\n    // If the counter is not 0, we increment or decrement the counter based on whether x is the current candidate. \\n    int majorityElement(vector<int> &num) {\\n        int cur = 0;\\n        int cnt = 0;\\n        for (int x : num) {\\n            if (cnt == 0) cur = x, cnt = 1;\\n            else if (cur == x) ++cnt;\\n            else --cnt;\\n        }\\n        return cur;\\n    }",
                "solutionTags": [],
                "code": "    // Moore voting algorithm: Runtime: O(n), Space O(1)\\n    // We maintain a current candidate and a counter initialized to 0. \\n    // As we iterate the array, we look at the current element x: \\n    // If the counter is 0, we set the current candidate to x and the counter to 1.\\n    // If the counter is not 0, we increment or decrement the counter based on whether x is the current candidate. \\n    int majorityElement(vector<int> &num) {\\n        int cur = 0;\\n        int cnt = 0;\\n        for (int x : num) {\\n            if (cnt == 0) cur = x, cnt = 1;\\n            else if (cur == x) ++cnt;\\n            else --cnt;\\n        }\\n        return cur;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3943069,
                "title": "two-solutions-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code1\\n```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n         if(nums.length == 1) return nums[0];\\n        Arrays.sort(nums);  \\n        return nums[nums.length / 2];\\n    }\\n}\\n```\\n\\n\\n# Code2\\n\\n```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n\\n    if(nums.length == 1) return nums[0];\\n         Arrays.sort(nums);\\n        int count1 = 0 , temp1 = nums[0] ;\\n        for (int i = 0; i <= nums.length - 1; i++) {\\n            if (temp1 == nums[i]) {\\n                count1++;\\n            }else {\\n                temp1 = nums[i];\\n                count1 = 1;\\n            }\\n            if ( count1  >= nums.length / 2.0)\\n                return temp1;\\n        }\\n        return temp1; \\n}\\n    }\\n```\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/aab04036-b3b7-40d7-9c2f-859d6a3dae0c_1692663536.2426503.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n         if(nums.length == 1) return nums[0];\\n        Arrays.sort(nums);  \\n        return nums[nums.length / 2];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n\\n    if(nums.length == 1) return nums[0];\\n         Arrays.sort(nums);\\n        int count1 = 0 , temp1 = nums[0] ;\\n        for (int i = 0; i <= nums.length - 1; i++) {\\n            if (temp1 == nums[i]) {\\n                count1++;\\n            }else {\\n                temp1 = nums[i];\\n                count1 = 1;\\n            }\\n            if ( count1  >= nums.length / 2.0)\\n                return temp1;\\n        }\\n        return temp1; \\n}\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545230,
                "title": "c-java-python-javascript-o-1-space-simple-solution-detailed-explanation",
                "content": "# Intuition:\\nThe problem aims to find the majority element in a given vector `nums`, where the majority element appears more than n/2 times (n is the size of `nums`). The provided code attempts to solve this by sorting the vector and then iterating through it to count the occurrences of each element.\\n\\n# Approach:\\n1. The provided code starts by sorting the `nums` vector in ascending order using `std::sort()` from the C++ standard library. Sorting allows us to identify adjacent elements with the same value more easily.\\n2. It initializes a variable `count` to keep track of the number of occurrences of the current element.\\n3. If the size of `nums` is 1, it means there is only one element in the vector, which automatically becomes the majority element. In this case, the code returns `nums[0]` as the result.\\n4. A loop is then executed from index 0 to `nums.size() - 2` (excluding the last element), checking each element with its adjacent element.\\n5. If the current element is not equal to its adjacent element, it means a new element has been encountered. In this case, `count` is reset to 0.\\n6. Otherwise, if the current element is equal to its adjacent element, `count` is incremented.\\n7. After incrementing `count`, the code checks if `count` is greater than or equal to `nums.size() / 2`. If it is, it means the current element is the majority element, and it is returned as the result.\\n8. Additionally, the code outputs the elements in the vector during the loop (excluding the last element) using `cout`. This seems to be for debugging purposes.\\n9. If no majority element is found after the loop, the code returns 0 as the result.\\n\\n# Complexity:\\n- The time complexity of the provided code is O(n log n), where n is the size of the input vector `nums`. This is because the code uses `std::sort()` to sort the vector, which has a time complexity of O(n log n). The subsequent loop has a linear time complexity of O(n), so it becomes dominated by the sorting operation.\\n\\n- The space complexity of the provided code is O(1) since it does not use any additional space that scales with the input size. It performs the sorting in-place and only uses a constant amount of extra space for the `count` variable.\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count = 0;\\n        if(nums.size()==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]!=nums[i+1]){\\n                count=0;\\n            }\\n            else{\\n                count++;\\n            }\\n            if(count>=(nums.size()/2)){\\n                return nums[i];\\n            }\\n            cout<<nums[i]<<\" \";\\n        }\\n        return 0;\\n    }\\n};\\n```\\n# Java\\n```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        if (nums.length == 1) {\\n            return nums[0];\\n        }\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] != nums[i + 1]) {\\n                count = 0;\\n            } else {\\n                count++;\\n            }\\n            if (count >= (nums.length / 2)) {\\n                return nums[i];\\n            }\\n            System.out.print(nums[i] + \" \");\\n        }\\n        return 0;\\n    }\\n}\\n```\\n# Python\\n```\\nclass Solution(object):\\n    def majorityElement(self, nums):\\n        nums.sort()\\n        count = 0\\n        if len(nums) == 1:\\n            return nums[0]\\n        for i in range(len(nums) - 1):\\n            if nums[i] != nums[i + 1]:\\n                count = 0\\n            else:\\n                count += 1\\n            if count >= len(nums) / 2:\\n                return nums[i]\\n            print nums[i],\\n        return 0\\n\\n```\\n# JavaScript\\n```\\nvar majorityElement = function(nums) {\\n    nums.sort((a, b) => a - b);\\n    var count = 0;\\n    if (nums.length === 1) {\\n        return nums[0];\\n    }\\n    for (var i = 0; i < nums.length - 1; i++) {\\n        if (nums[i] !== nums[i + 1]) {\\n            count = 0;\\n        } else {\\n            count++;\\n        }\\n        if (count >= Math.floor(nums.length / 2)) {\\n            return nums[i];\\n        }\\n        console.log(nums[i] + \" \");\\n    }\\n    return 0;\\n};\\n\\n```\\n\\n---\\n\\n# Approach 2\\nCredits: [@aleksanderpanasiuk](https://leetcode.com/aleksanderpanasiuk/)\\n\\nIf you have a sorted vector you can simply return its middle value.\\nnums = [3,2,3] -> [2,3,3] - mid_val = 3\\nnums = [2,2,1,1,1,2,2] -> [1,1,1,2,2,2,2] - mid_val = 2\\nnums =[3,1,2,1,2,2,2] -> [1,1,2,2,2,2,3] - mid_val = 2\\nIt always works because the majority element appears more than n/2 times.\\n```\\nclass Solution \\n{\\npublic:\\n    int majorityElement(vector<int>& nums) \\n    {\\n        std::sort(nums.begin(), nums.end());\\n        return nums[nums.size()/2];    \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count = 0;\\n        if(nums.size()==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]!=nums[i+1]){\\n                count=0;\\n            }\\n            else{\\n                count++;\\n            }\\n            if(count>=(nums.size()/2)){\\n                return nums[i];\\n            }\\n            cout<<nums[i]<<\" \";\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        if (nums.length == 1) {\\n            return nums[0];\\n        }\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] != nums[i + 1]) {\\n                count = 0;\\n            } else {\\n                count++;\\n            }\\n            if (count >= (nums.length / 2)) {\\n                return nums[i];\\n            }\\n            System.out.print(nums[i] + \" \");\\n        }\\n        return 0;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def majorityElement(self, nums):\\n        nums.sort()\\n        count = 0\\n        if len(nums) == 1:\\n            return nums[0]\\n        for i in range(len(nums) - 1):\\n            if nums[i] != nums[i + 1]:\\n                count = 0\\n            else:\\n                count += 1\\n            if count >= len(nums) / 2:\\n                return nums[i]\\n            print nums[i],\\n        return 0\\n\\n```\n```\\nvar majorityElement = function(nums) {\\n    nums.sort((a, b) => a - b);\\n    var count = 0;\\n    if (nums.length === 1) {\\n        return nums[0];\\n    }\\n    for (var i = 0; i < nums.length - 1; i++) {\\n        if (nums[i] !== nums[i + 1]) {\\n            count = 0;\\n        } else {\\n            count++;\\n        }\\n        if (count >= Math.floor(nums.length / 2)) {\\n            return nums[i];\\n        }\\n        console.log(nums[i] + \" \");\\n    }\\n    return 0;\\n};\\n\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int majorityElement(vector<int>& nums) \\n    {\\n        std::sort(nums.begin(), nums.end());\\n        return nums[nums.size()/2];    \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1788270,
                "title": "python-classical-voting-algorithm-explained",
                "content": "Simple problem, but it is good to investigate \\u2014 it has a lot of different solutions. There is a simple hashtable solution with time and memory complexity `O(n)`, there is a sorting solution with `O(n * log n)` time and `O(1)` memory.\\n\\nRemember, that we did not use the fact, that majority element is in more than half place. Finally there is Boyer-Moore Voting Algorithm, with time complexity `O(n)` and space complexity `O(1)`: the idea is to keep track of current most popular element and if new element is equal to the most popular, we add `1`, if not equal, we subtract `-1`. If we have zero, we forget about all previous elements and update current most popular.\\n\\n#### Complexity\\nIt is `O(n)` for time and `O(1)` for space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def majorityElement(self, nums):\\n        cnt, cand = 0, None\\n        \\n        for num in nums:\\n            if cnt == 0: cand = num\\n            cnt += (1 if num == cand else -1)\\n            \\n        return cand\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def majorityElement(self, nums):\\n        cnt, cand = 0, None\\n        \\n        for num in nums:\\n            if cnt == 0: cand = num\\n            cnt += (1 if num == cand else -1)\\n            \\n        return cand\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787774,
                "title": "c-easy-one-liner-o-nlogn-fast",
                "content": "**Please Upvote if You Like it...!   :)**\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        sort(nums.begin(),nums.end()); return nums[nums.size()/2];   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        sort(nums.begin(),nums.end()); return nums[nums.size()/2];   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948321,
                "title": "divide-and-conquer-solution-with-video-explanation",
                "content": "I used Divide and Conquer to solve this.\\n[Here\\'s the video explanation:-](https://www.youtube.com/watch?v=28D-VLSXBt0)\\n\\nCode:\\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        return self.helper(nums, 0, len(nums))[0]\\n\\n    def helper(self, nums, l, r):\\n        if l == r - 1:\\n            return nums[l], 1\\n        mid = l + (r - l) // 2\\n        maj_left, extra_left = self.helper(nums, l, mid)\\n        maj_right, extra_right = self.helper(nums, mid, r)\\n\\n        if maj_right==maj_left:\\n            maj = maj_left\\n            extra = extra_left + extra_right\\n        elif extra_right > extra_left:\\n            maj = maj_right\\n            extra = extra_right - extra_left\\n        else:\\n            maj = maj_left\\n            extra = extra_left - extra_right\\n        return maj, extra\\n```\\n![image](https://user-images.githubusercontent.com/74953232/100122696-e2875900-2ea3-11eb-83c8-3ac05d495964.jpg)",
                "solutionTags": [
                    "Python3",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        return self.helper(nums, 0, len(nums))[0]\\n\\n    def helper(self, nums, l, r):\\n        if l == r - 1:\\n            return nums[l], 1\\n        mid = l + (r - l) // 2\\n        maj_left, extra_left = self.helper(nums, l, mid)\\n        maj_right, extra_right = self.helper(nums, mid, r)\\n\\n        if maj_right==maj_left:\\n            maj = maj_left\\n            extra = extra_left + extra_right\\n        elif extra_right > extra_left:\\n            maj = maj_right\\n            extra = extra_right - extra_left\\n        else:\\n            maj = maj_left\\n            extra = extra_left - extra_right\\n        return maj, extra\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51850,
                "title": "c-moore-s-majority-vote-algorithm-fastest-solution",
                "content": "\\n    // Moore's majority vote algorithm\\n    // https://en.wikipedia.org/wiki/Boyer\\u2013Moore_majority_vote_algorithm\\n    // Assumption: the array is non-empty and the majority element always exist in the array\\n    int majorityElement(vector<int>& nums) {\\n        int candidate = nums[0], counter = 0;\\n        for (int n: nums) {\\n            if (counter == 0) {\\n                candidate = n;\\n                counter = 1;\\n            } else if (candidate == n) {\\n                counter++;\\n            } else {\\n                counter--;\\n            }\\n        }\\n        return candidate;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n    // Moore's majority vote algorithm\\n    // https://en.wikipedia.org/wiki/Boyer\\u2013Moore_majority_vote_algorithm\\n    // Assumption: the array is non-empty and the majority element always exist in the array\\n    int majorityElement(vector<int>& nums) {\\n        int candidate = nums[0], counter = 0;\\n        for (int n: nums) {\\n            if (counter == 0) {\\n                candidate = n;\\n                counter = 1;\\n            } else if (candidate == n) {\\n                counter++;\\n            } else {\\n                counter--;\\n            }\\n        }\\n        return candidate;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51879,
                "title": "c-different-solutions",
                "content": "        \\n    int majorityElement1(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        return nums[nums.size()/2];\\n    }\\n    \\n    int majorityElement2(vector<int>& nums) {\\n        //unordered_map<int, int> myMap;\\n        map<int, int> myMap;\\n        for (auto& num: nums) {\\n            myMap[num]++;\\n            if (myMap[num]>nums.size()/2)\\n                return num;\\n        }\\n    }\\n    \\n    int majorityElement3(vector<int>& nums) {\\n        //multimap<int, int> myMap;\\n        unordered_multimap<int, int> myMap;\\n        for (auto& num: nums) {\\n            if (myMap.find(num) == myMap.end())\\n                myMap.insert(make_pair(num, 1));\\n            else {\\n                int tmp = (*myMap.find(num)).second+1;\\n                myMap.erase(num);\\n                myMap.insert(pair<int, int>(num, tmp));\\n            }\\n            if (myMap.find(num)->second > nums.size()/2)\\n                return num;\\n        }\\n    }\\n    \\n    int majorityElement4(vector<int>& nums) {\\n        int bit[32] = {0};\\n        for (auto& num: nums) \\n            for(int i=0; i<32; i++) \\n                if ((num>>i)&1 == 1)\\n                    bit[i]++;\\n        int ret = 0;\\n        for (int i=0; i<32; i++) {\\n            ret+=(1<<i)*(bit[i]>nums.size()/2?1:0);\\n        }\\n        return ret;\\n    }\\n    \\n    int majorityElement(vector<int>& nums) {\\n        int count=0, ret=0;\\n        for (auto& num: nums) {\\n            if (count == 0)\\n                ret = num;\\n            if (num != ret)\\n                count--;\\n            else\\n                count++;\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "        \\n    int majorityElement1(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        return nums[nums.size()/2];\\n    }\\n    \\n    int majorityElement2(vector<int>& nums) {\\n        //unordered_map<int, int> myMap;\\n        map<int, int> myMap;\\n        for (auto& num: nums) {\\n            myMap[num]++;\\n            if (myMap[num]>nums.size()/2)\\n                return num;\\n        }\\n    }\\n    \\n    int majorityElement3(vector<int>& nums) {\\n        //multimap<int, int> myMap;\\n        unordered_multimap<int, int> myMap;\\n        for (auto& num: nums) {\\n            if (myMap.find(num) == myMap.end())\\n                myMap.insert(make_pair(num, 1));\\n            else {\\n                int tmp = (*myMap.find(num)).second+1;\\n                myMap.erase(num);\\n                myMap.insert(pair<int, int>(num, tmp));\\n            }\\n            if (myMap.find(num)->second > nums.size()/2)\\n                return num;\\n        }\\n    }\\n    \\n    int majorityElement4(vector<int>& nums) {\\n        int bit[32] = {0};\\n        for (auto& num: nums) \\n            for(int i=0; i<32; i++) \\n                if ((num>>i)&1 == 1)\\n                    bit[i]++;\\n        int ret = 0;\\n        for (int i=0; i<32; i++) {\\n            ret+=(1<<i)*(bit[i]>nums.size()/2?1:0);\\n        }\\n        return ret;\\n    }\\n    \\n    int majorityElement(vector<int>& nums) {\\n        int count=0, ret=0;\\n        for (auto& num: nums) {\\n            if (count == 0)\\n                ret = num;\\n            if (num != ret)\\n                count--;\\n            else\\n                count++;\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51897,
                "title": "c-3-simple-solutions",
                "content": "    class Solution {\\n    public:\\n    int majorityElement(vector<int>& nums) {\\n        //return solution1(nums);     //use map\\n        //return solution2(nums);     //use sort\\n        return solution3(nums);     //use O(1) space\\n    }\\n    private:\\n    int solution1(vector<int> &nums){\\n        unordered_map<int, int> m;\\n        for(int i = 0; i < nums.size(); i++)\\n            m[nums[i]]++;\\n        auto cur = m.begin();\\n        for(auto i = cur; i != m.end(); i++){\\n            if(cur->second < i->second) cur = i;\\n        }\\n        return cur->first;\\n    }\\n    int solution2(vector<int> &nums){\\n        sort(nums.begin(), nums.end());\\n        return nums[nums.size() / 2];\\n    }\\n    int solution3(vector<int> &nums){\\n        int cur = nums[0];\\n        for(int i = 1, count = 1; i < nums.size(); i++){\\n            if(nums[i] == cur) count++;\\n            else count--;\\n            if(count == -1){\\n                cur = nums[i];\\n                count = 1;\\n            }\\n        }\\n        return cur;\\n    }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    int majorityElement(vector<int>& nums) {\\n        //return solution1(nums);     //use map\\n        //return solution2(nums);     //use sort\\n        return solution3(nums);     //use O(1) space\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3640775,
                "title": "easiest-approach-in-cpp-in-2-lines-without-using-hashmap-or-voting-algorithm",
                "content": "# Intuition\\nFirst thought was clearly the Brute force approach of checking each element one by one and put a counter for that element and whichever element appears more than n/2 times is the answer, but this approach will throw TLE.\\n\\n# Approach\\n- Approach is quite simple if the element has appeared for more than n/2 times than for sure the middle element of the array after sorting using basic sort function of vector is the element which appeared more than n/2 times.\\n- And also it is mentioned that there exist atleast a element which has appeared more than n/2 times so no need to make an exception case to throw -1. \\n\\n# Complexity\\n- Time complexity:\\n  O(nlogn)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n      // if n appears more than n/2 times than for sure after sorting the mid element would be that element\\n      sort(nums.begin(),nums.end());\\n      return nums[nums.size()/2];\\n    }\\n};\\n```\\n# Please do upvote if my explanation helped you.",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n      // if n appears more than n/2 times than for sure after sorting the mid element would be that element\\n      sort(nums.begin(),nums.end());\\n      return nums[nums.size()/2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309478,
                "title": "c-solution-o-n-with-proper-explaination",
                "content": "**Approach 1 :** Obviously **Brute force** !! and it\\'s really brutal. Why ? *Time complexity - O(N^2) & Space Complexity O(1)* .\\n    We can simply traverse on every element &  keep a count variable count and keep   updating for every element occurence and whichever element is has frequency of n/2 will be our majority element.\\n\\t\\n**Approach 2:** **Brute force but better than Approach 1** using **Hashmap** keeping a map of value and frequency giving us *Time complexity of O(N)*. \\nbut *Space complexity* - O(N) which is bad than approach 1. Hence we need to optimize it and come up with O(1) space complexity solution.\\n\\n**Approach 3:** Optimized \\n**Mapping of Distinct Elements** and the left out elements will be the Majority Element.\\nsteps: \\n1) make  a majority and count variables.\\n2) Iterate through 0 to size of nums-1\\n3) check if count is 0 if yes majority is equal to nums[i].\\n4) if Majority is qual to nums[i] if yes incvrement the count.\\n5) else  majority is not equal to nums[i] decrement the count.\\n6) majority will be containing the majority element. \\n\\n\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int majority, count = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(count == 0){\\n                majority = nums[i];\\n            }\\n            if(majority == nums[i]) count++;\\n            else count--;\\n        }\\n        return majority;\\n    }\\n};\\n```\\n**Please upvote if you like the solution and comment if have doubts**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int majority, count = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(count == 0){\\n                majority = nums[i];\\n            }\\n            if(majority == nums[i]) count++;\\n            else count--;\\n        }\\n        return majority;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859448,
                "title": "python-cool-solution-one-line-very-clear",
                "content": "\\tclass Solution:\\n\\t\\tdef majorityElement(self, nums: List[int]) -> int:\\n\\t\\t\\treturn sorted(nums)[len(nums) // 2]\\n\\t\\t\\t\\nif the majority appears more than n/2 times, it must appears in the middle place and the one place before",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef majorityElement(self, nums: List[int]) -> int:\\n\\t\\t\\treturn sorted(nums)[len(nums) // 2]\\n\\t\\t\\t\\nif the majority appears more than n/2 times, it must appears in the middle place and the one place before",
                "codeTag": "Java"
            },
            {
                "id": 417440,
                "title": "bit-manipulation-with-explanation-python",
                "content": "```\\nclass Solution(object):\\n\\n    # Bit manipulation\\n\\n    # The algorithm first determines the frequency of each bit in the input array.\\n    # If there is a number with a majority in the input (i.e. it makes up more than half of the input),\\n    # then the frequency of all its set bits will be in the majority, and the frequency of all its unset bits will be in the minority.\\n    #\\n    # The majority number can be recreated from the frequency table by masking together all the majority bits.\\n    # This relies on there being a majority. If there is not guaranteed to be a majority a second pass to check the result is required.\\n    def majorityElement(self, nums):\\n        bitFrequencyTable = [0] * 32 # Bit frequency table\\n\\n        #   Work out bit frequency\\n        for num in nums:\\n            for j in range(32): #  for each bit\\n                if (num >> j & 1) != 0: # is bit j set?\\n                    bitFrequencyTable[j] += 1 # increment frequency\\n\\n        #  Recreate the majority number\\n        res = 0\\n        for i, val in enumerate(bitFrequencyTable): # for each bit\\n            if val > len(nums) // 2:  # is bit i in the majority?\\n                if i == 31: # if the 31th bit if 1, it means it\\'s a negative number\\n                    res = -((1 << 31) - res)\\n                else:\\n                    res |= 1 << i # mask bit i into the result\\n        return res\\n\\n\\n\\n\\n\\nsol = Solution()\\ninput = [2,2,1,1,1,2,2]\\noutput = sol.majorityElement(input)\\nprint(\\'Res: \\', output)\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution(object):\\n\\n    # Bit manipulation\\n\\n    # The algorithm first determines the frequency of each bit in the input array.\\n    # If there is a number with a majority in the input (i.e. it makes up more than half of the input),\\n    # then the frequency of all its set bits will be in the majority, and the frequency of all its unset bits will be in the minority.\\n    #\\n    # The majority number can be recreated from the frequency table by masking together all the majority bits.\\n    # This relies on there being a majority. If there is not guaranteed to be a majority a second pass to check the result is required.\\n    def majorityElement(self, nums):\\n        bitFrequencyTable = [0] * 32 # Bit frequency table\\n\\n        #   Work out bit frequency\\n        for num in nums:\\n            for j in range(32): #  for each bit\\n                if (num >> j & 1) != 0: # is bit j set?\\n                    bitFrequencyTable[j] += 1 # increment frequency\\n\\n        #  Recreate the majority number\\n        res = 0\\n        for i, val in enumerate(bitFrequencyTable): # for each bit\\n            if val > len(nums) // 2:  # is bit i in the majority?\\n                if i == 31: # if the 31th bit if 1, it means it\\'s a negative number\\n                    res = -((1 << 31) - res)\\n                else:\\n                    res |= 1 << i # mask bit i into the result\\n        return res\\n\\n\\n\\n\\n\\nsol = Solution()\\ninput = [2,2,1,1,1,2,2]\\noutput = sol.majorityElement(input)\\nprint(\\'Res: \\', output)\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51808,
                "title": "2-lines-java-using-sort-o-n-log-n",
                "content": "    public class Solution {\\n        public int majorityElement(int[] nums) {\\n            Arrays.sort(nums);\\n            return nums[nums.length/2];\\n        }\\n    }\\n\\nWorth mentioning is to check Moore's voting mechanism as well (O(n)). But anyway, two lines and especially the beauty of the second one...",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int majorityElement(int[] nums) {\\n            Arrays.sort(nums);\\n            return nums[nums.length/2];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 51668,
                "title": "moore-s-voting-algorithm",
                "content": "    public class Solution {\\n        public int majorityElement(int[] nums) {\\n            int count = 0;\\n            int majorityElement = nums[0];\\n            for(int x:nums){\\n                if(x!=majorityElement){\\n                    count--;\\n                }\\n                else{\\n                    count++;\\n                }\\n                  if(count==0){\\n                    majorityElement= x;\\n                    count=1;\\n                }\\n            }\\n            return majorityElement;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int majorityElement(int[] nums) {\\n            int count = 0;\\n            int majorityElement = nums[0];\\n            for(int x:nums){\\n                if(x!=majorityElement){\\n                    count--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 51898,
                "title": "ac-clean-java-solution",
                "content": "    public int majorityElement(int[] a) {\\n      int n = a.length, m = a[0], c = 1;\\n      \\n      for (int i = 1; i < n; i++) {\\n        if (a[i] == m) {\\n          c++;\\n        } else if (c > 0) {\\n          c--;\\n        } else {\\n          m = a[i]; c = 1;\\n        }\\n      }\\n      \\n      return m;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int majorityElement(int[] a) {\\n      int n = a.length, m = a[0], c = 1;\\n      \\n      for (int i = 1; i < n; i++) {\\n        if (a[i] == m) {\\n          c++;\\n        } else if (c > 0) {\\n          c--;\\n        } else {\\n          m = a[i]; c = 1;\\n        }\\n      }\\n      \\n      return m;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51934,
                "title": "java-solution-with-moore-s-voting-algorithm",
                "content": "This problem is a perfect match with moose's voting algorithm. Basic thought: set two variables: *majorityIndex* to locate the index of element occurring most, *count* to count the occurrences of majority element. Loop through array, if current element equals Array[majorityIndex], count++, otherwise count--. If count == 0, turn majorityIndex into current index. Through this way, we are able to find the element occurring most in this array. \\n\\nSince we can assume there is always a majority element, we can immediately return the element we found through algorithm above. However, it'd be better to check if the element we found occurred more than size / 2 times in given array.\\n\\n    public class Solution {\\n        public int majorityElement(int[] nums) {\\n            // moore's voting algorithm\\n            // find candidate element\\n            if (nums.length == 1) return nums[0];\\n            int majorityIndex = 0, count = 1;\\n            for (int i = 1; i < nums.length; i++) {\\n                if (nums[i] == nums[majorityIndex]) count++;\\n                else count--;\\n                if (count == 0) {\\n                    majorityIndex = i;\\n                    count = 1;\\n                }\\n            }\\n            \\n            // check if candidate is the majority element\\n            return nums[majorityIndex];\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int majorityElement(int[] nums) {\\n            // moore's voting algorithm\\n            // find candidate element\\n            if (nums.length == 1) return nums[0];\\n            int majorityIndex = 0, count = 1;\\n            for (int i = 1; i < nums.length; i++) {\\n                if (nums[i] == nums[majorityIndex]) count++;\\n                else count--;\\n                if (count == 0) {\\n                    majorityIndex = i;\\n                    count = 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 51974,
                "title": "bit-manipulation-implementation",
                "content": "    public int majorityElement2(int[] num)\\n    {\\n    \\tint majority = 0;\\n    \\tfor (int p = 0; p < 32; p++)\\n    \\t{\\n    \\t\\tint count0 = 0;\\n    \\t\\tint count1 = 0;\\n    \\t\\tfor (int value : num)\\n    \\t\\t{\\n    \\t\\t\\tif (getIntegerBit(value, p))\\n    \\t\\t\\t\\tcount1++;\\n    \\t\\t\\telse\\n    \\t\\t\\t\\tcount0++;\\n    \\t\\t}\\n    \\n    \\t\\tif (count0 > count1) \\n    \\t\\t\\tmajority = majority & ~(1 << p);\\n    \\t\\telse\\n    \\t\\t\\tmajority = majority | (1 << p);\\n    \\t}\\n    \\treturn majority;\\n    }\\n    \\n    public boolean getIntegerBit(int value, int p)\\n    {\\n    \\tif (p >= 32)\\n    \\t\\tthrow new IllegalArgumentException(\"\");\\n    \\treturn (value & (1L << p)) != 0;\\n    }\\n\\nThis algorithm is 20 times slower than Moore voting algorithm.\\n\\n> Array size: 2147483\\n>\\n> Moore voting algorithm run time: 6419218 ns\\n>\\n> Bit manipulation run time:   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 142345391 ns",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "    public int majorityElement2(int[] num)\\n    {\\n    \\tint majority = 0;\\n    \\tfor (int p = 0; p < 32; p++)\\n    \\t{\\n    \\t\\tint count0 = 0;\\n    \\t\\tint count1 = 0;\\n    \\t\\tfor (int value : num)\\n    \\t\\t{\\n    \\t\\t\\tif (getIntegerBit(value, p))\\n    \\t\\t\\t\\tcount1++;\\n    \\t\\t\\telse\\n    \\t\\t\\t\\tcount0++;\\n    \\t\\t}\\n    \\n    \\t\\tif (count0 > count1) \\n    \\t\\t\\tmajority = majority & ~(1 << p);\\n    \\t\\telse\\n    \\t\\t\\tmajority = majority | (1 << p);\\n    \\t}\\n    \\treturn majority;\\n    }\\n    \\n    public boolean getIntegerBit(int value, int p)\\n    {\\n    \\tif (p >= 32)\\n    \\t\\tthrow new IllegalArgumentException(\"\");\\n    \\treturn (value & (1L << p)) != 0;\\n    }\\n\\nThis algorithm is 20 times slower than Moore voting algorithm.\\n\\n> Array size: 2147483\\n>\\n> Moore voting algorithm run time: 6419218 ns\\n>\\n> Bit manipulation run time:   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 142345391 ns",
                "codeTag": "Unknown"
            },
            {
                "id": 3133635,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MajorityElement(int[] nums) {\\n        int count = 0;\\n        int? candidate = null;\\n\\n        foreach (int num in nums) {\\n            if (count == 0) candidate = num;\\n            count += (num == candidate) ? 1 : -1;\\n        }\\n\\n        return candidate.Value;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MajorityElement(int[] nums) {\\n        int count = 0;\\n        int? candidate = null;\\n\\n        foreach (int num in nums) {\\n            if (count == 0) candidate = num;\\n            count += (num == candidate) ? 1 : -1;\\n        }\\n\\n        return candidate.Value;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717375,
                "title": "majority-element-java-o-1-space-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n\\t// Three Approach to solve Majority Element.\\n\\t\\n        // 1. You can do this by using two loops and finding count of each element and comparing with the whole array but it takes O(n^2) time.\\n\\t\\t// 2. You can use HashMap for finding maximum frequency and returning the element but it takes O(n) space.\\n\\t\\t// 3. Best approach is to use maximumVote-Algorithm(Boyer\\'s Moore Voting Algorithm) which count with its current element in O(N) time and O(1)space. \\n\\t\\t\\n        int count=0;\\n        int max=0;\\n        \\n        for(int ele: nums){\\n            if(count==0){\\n                max=ele;\\n            }\\n            \\n            if(ele==max){\\n                count=count+1;\\n            }else{\\n                count=count-1;\\n            }\\n        }\\n     return max;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n\\t// Three Approach to solve Majority Element.\\n\\t\\n        // 1. You can do this by using two loops and finding count of each element and comparing with the whole array but it takes O(n^2) time.\\n\\t\\t// 2. You can use HashMap for finding maximum frequency and returning the element but it takes O(n) space.\\n\\t\\t// 3. Best approach is to use maximumVote-Algorithm(Boyer\\'s Moore Voting Algorithm) which count with its current element in O(N) time and O(1)space. \\n\\t\\t\\n        int count=0;\\n        int max=0;\\n        \\n        for(int ele: nums){\\n            if(count==0){\\n                max=ele;\\n            }\\n            \\n            if(ele==max){\\n                count=count+1;\\n            }else{\\n                count=count-1;\\n            }\\n        }\\n     return max;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807623,
                "title": "c-o-n-o-1",
                "content": "\\n```cpp\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        \\n        int maxElement;\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            \\n            if(count==0) maxElement=nums[i];\\n            \\n            if(nums[i]== maxElement) count++;\\n            \\n            else count--;\\n        }\\n        return maxElement;\\n    }\\n};\\n```\\n\\nPlease ***upvote*** if the code helped you in anyway!\\uD83D\\uDE42\\n\\n**All the best buddy**!\\uD83D\\uDC4D",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        \\n        int maxElement;\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            \\n            if(count==0) maxElement=nums[i];\\n            \\n            if(nums[i]== maxElement) count++;\\n            \\n            else count--;\\n        }\\n        return maxElement;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376230,
                "title": "interview-strategy-solution-4-solutions-easy-explanation",
                "content": "To optimally solve this problem in a coding interview, begin with a simpler more intuitive solution:\\n\\n**1. Using HashMap** \\nIdea: Traverse through the array and keep the count of elements in a hashmap, then again traverse through the hashmap to find the majority element.\\n\\nTime: O(N) | Space: O(N)\\n\\n**2. Sorting**\\nIdea: Sort the array and then traverse through the array to count the bunch of equal numbers in accumulation.\\nFor time complexity, sorting takes NLogN and for traversal O(N) => O(NLogN)\\nSpace complexity will be O(1) or O(N) depending on the method of sorting.\\n\\nTime: O(NLogN) | Space: O(1) or O(N)\\n\\n**3. Divide and Conquer**\\nIdea: To find the majority in whole array, we divide array into 2 parts and repeatedly find the majority in the respective part and then constructively decide the majority while combining the parted arrays.\\n\\nCode:\\n```\\nint countInRange(vector<int> &nums, int num, int lo, int hi)\\n    {\\n        int count = 0;\\n        for(int i = lo ; i <= hi ; i++)\\n        {\\n            if(nums[i] == num)\\n                count++;\\n        }\\n        return count;\\n    }\\n    \\n    int majorityElementInRange(vector<int> &nums, int lo, int hi)\\n    {\\n        if(lo == hi)\\n            return nums[lo];\\n        int mid = lo + (hi-lo)/2;\\n        int leftMajority = majorityElementInRange(nums, lo, mid);\\n        int rightMajority = majorityElementInRange(nums, mid+1, hi);\\n        \\n        if(leftMajority == rightMajority) return leftMajority;\\n        int leftCount  = countInRange(nums, leftMajority, lo, mid);\\n        int rightCount = countInRange(nums, rightMajority, mid+1, hi);\\n        return leftCount > rightCount ? leftMajority : rightMajority;\\n    }\\n    \\n    int majorityElement(vector<int>& nums) {\\n        return majorityElementInRange(nums, 0, nums.size()-1);\\n    }\\n```\\nSpace: `O(LogN)` | Time: `O(NLogN)`\\n\\n**4. Boyer Moore Algorithm**\\nIdea: We elect a candidate for being the majority element and then if the element occurs, increase the possibility (`count`) of it being the real majority else decrease the possibility strength (`count`).\\n\\n```\\nint majorityElement(vector<int>& nums) {\\n        int n = nums.size();\\n        int candidate = nums[0], count = 1;\\n        \\n        for(int i = 1 ; i < nums.size() ; i++)\\n        {\\n            if(count == 0) candidate = nums[i];\\n            if(nums[i] == candidate) count++;\\n            else count--;\\n        }\\n        return candidate;\\n    }\\n```\\n\\nIn an interview, give a brief idea about the first 2 methods and try to code out the last two ones, happy coding (:",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint countInRange(vector<int> &nums, int num, int lo, int hi)\\n    {\\n        int count = 0;\\n        for(int i = lo ; i <= hi ; i++)\\n        {\\n            if(nums[i] == num)\\n                count++;\\n        }\\n        return count;\\n    }\\n    \\n    int majorityElementInRange(vector<int> &nums, int lo, int hi)\\n    {\\n        if(lo == hi)\\n            return nums[lo];\\n        int mid = lo + (hi-lo)/2;\\n        int leftMajority = majorityElementInRange(nums, lo, mid);\\n        int rightMajority = majorityElementInRange(nums, mid+1, hi);\\n        \\n        if(leftMajority == rightMajority) return leftMajority;\\n        int leftCount  = countInRange(nums, leftMajority, lo, mid);\\n        int rightCount = countInRange(nums, rightMajority, mid+1, hi);\\n        return leftCount > rightCount ? leftMajority : rightMajority;\\n    }\\n    \\n    int majorityElement(vector<int>& nums) {\\n        return majorityElementInRange(nums, 0, nums.size()-1);\\n    }\\n```\n```\\nint majorityElement(vector<int>& nums) {\\n        int n = nums.size();\\n        int candidate = nums[0], count = 1;\\n        \\n        for(int i = 1 ; i < nums.size() ; i++)\\n        {\\n            if(count == 0) candidate = nums[i];\\n            if(nums[i] == candidate) count++;\\n            else count--;\\n        }\\n        return candidate;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1260318,
                "title": "easy-c-solution",
                "content": "**the basic idea is that we will sort the array and the element which is present more than size/2 time must apprear at the mid of the vector**\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums[nums.size()/2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums[nums.size()/2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763482,
                "title": "one-liner",
                "content": "# Intuition\\n<!-- first i done this through frequency list but then i got another easy solution which beats 99% -->\\n\\n# Approach\\n<!-- brute force -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- O(n(log(n))+1) -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        return sorted(nums)[len(nums)//2]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        return sorted(nums)[len(nums)//2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2523833,
                "title": "c-detail-explanation-tc-o-n-sc-o-1-moore-s-voting-algorithm",
                "content": "**IF YOU FIND THIS USEFULL PLEASE PLEASE UPVOTE**\\nHello guys, i guess all of you have done its MAP approach but as it takes space so we need to find more optimized solution, so here we have **Moore\\u2019s Voting Algorithm** which solve our space complexity issue.\\nLet\\'s understand how it works, Think of a three Leaders \\nLeader A\\nLeader B\\nLeader C \\nall of these are standing for votes, tell me who will win, ofcourse the one with **majority votes** now think that what happen at end of election when leader A wins, we say \"A won with 2 or 3 or 4 votes more then B and C\"\\n\\nThis is what we are doing here, we simply count the vote and we cancel count of appearance of an element if we see other element.\\nnow lets directly jump into code to see how its working.\\n\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n         //a simple solution can be using Hash maps but its not optimal\\n        //it will be in TC of O(nlogn) and SC of O(n)\\n        /*********************OPTIMAL APPROACH (Moore\\u2019s Voting Algorithm)************/\\n        int n=nums.size();\\n        int vote =0,leader=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vote==0) leader=nums[i];//when we start the process we choose 0th element as leader\\n            if(leader==nums[i]) vote++;//now when we see its appearance again in array we UPVOTE\\n            else vote--;//if we see some othe element we DOWN VOTE\\n            \\n            //if current leader votes become 0 means its not the ans hence by help of first if\\n            //we again put new element as leader, then carry on the process\\n        }\\n        return leader;\\n    }\\n};\\n``` \\n**IF YOU FIND THIS USEFULL PLEASE PLEASE UPVOTE**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n         //a simple solution can be using Hash maps but its not optimal\\n        //it will be in TC of O(nlogn) and SC of O(n)\\n        /*********************OPTIMAL APPROACH (Moore\\u2019s Voting Algorithm)************/\\n        int n=nums.size();\\n        int vote =0,leader=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vote==0) leader=nums[i];//when we start the process we choose 0th element as leader\\n            if(leader==nums[i]) vote++;//now when we see its appearance again in array we UPVOTE\\n            else vote--;//if we see some othe element we DOWN VOTE\\n            \\n            //if current leader votes become 0 means its not the ans hence by help of first if\\n            //we again put new element as leader, then carry on the process\\n        }\\n        return leader;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1966411,
                "title": "moore-s-voting-algorithm-in-o-n",
                "content": "In O(n)\\n\\n```\\nint majorityElement(vector<int>& v)\\n    {\\n        //Moore\\'s Voting Algorithm\\n        int n=v.size();\\n        int f=0,ele;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(f==0)\\n            {\\n                ele=v[i];\\n            }\\n            if(v[i]==ele)\\n            {\\n                f++;\\n            }\\n            else\\n            {\\n                f--;\\n            }\\n        }\\n        return ele;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint majorityElement(vector<int>& v)\\n    {\\n        //Moore\\'s Voting Algorithm\\n        int n=v.size();\\n        int f=0,ele;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(f==0)\\n            {\\n                ele=v[i];\\n            }\\n            if(v[i]==ele)\\n            {\\n                f++;\\n            }\\n            else\\n            {\\n                f--;\\n            }\\n        }\\n        return ele;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1531134,
                "title": "java-easy-solution-moore-s-voting-algo-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/4de81074-b5d8-4703-9683-83a6781ecbff_1634716136.6327457.png)\\n\\n**Code**\\n```java\\npublic int majorityElement(int[] nums) {\\n\\tint count = 0, candidate = 0;\\n\\n\\tfor(int num: nums) {\\n\\t\\tif(count == 0) {\\n\\t\\t\\tcandidate = num;\\n\\t\\t}\\n\\t\\tif(num == candidate) {\\n\\t\\t\\tcount++;\\n\\t\\t} else {\\n\\t\\t\\tcount--;\\n\\t\\t}\\n\\t}\\n\\n\\treturn candidate;\\n}\\n```\\n\\n**Explanation**\\nSo, Moore\\'s Voting algorithm is based on the fact that the majority element is present more than n/2 number of times, so if we iterate in the array and increase the count if element is same as the choosen element and decrement the count otherwise, then also we will be left with the majority element because it is present more than n/2 number of times and rest of the elements cannot cancel it\\'s presence.\\n\\nSo, that\\'s Moore\\'s Voting Algorithm in a nutshell.\\n\\nLet\\'s analyse this with the help of an diagram:-\\n\\narr = [1,2,3,4,3,3,3]\\n\\n![image](https://assets.leetcode.com/users/images/545246cc-6ac6-4215-a40d-ffedff60ef00_1634885546.4478421.png)\\n\\nSo, as it is clear in the example that we need not care about the count value, we just need the value in candidate, as already mentioned in the question that there is always a majority element. \\n\\nTime complexity - O(n)\\nSpace complexity - O(1)\\n\\nHope it helps.\\nDo like if it helps.\\nThank you.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int majorityElement(int[] nums) {\\n\\tint count = 0, candidate = 0;\\n\\n\\tfor(int num: nums) {\\n\\t\\tif(count == 0) {\\n\\t\\t\\tcandidate = num;\\n\\t\\t}\\n\\t\\tif(num == candidate) {\\n\\t\\t\\tcount++;\\n\\t\\t} else {\\n\\t\\t\\tcount--;\\n\\t\\t}\\n\\t}\\n\\n\\treturn candidate;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1045054,
                "title": "kotlin-1-line",
                "content": "```\\nfun majorityElement(ar: IntArray) = ar.sorted()[ar.size / 2]\\n```\\n\\n**or**\\n```\\nfun majorityElement(ar: IntArray) = ar.find { n -> ar.count { it == n } > ar.size / 2 }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun majorityElement(ar: IntArray) = ar.sorted()[ar.size / 2]\\n```\n```\\nfun majorityElement(ar: IntArray) = ar.find { n -> ar.count { it == n } > ar.size / 2 }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51894,
                "title": "time-o-n-in-place-solution-moore-majority-voting-algorithm",
                "content": "    //http://www.cs.utexas.edu/~moore/best-ideas/mjrty/\\n    //Animation explanation: http://www.cs.utexas.edu/~moore/best-ideas/mjrty/example.html\\n    public int MajorityElement(int[] nums) {\\n        int major = nums[0];\\n        for(int i = 0, count = 0; i < nums.Length; i++){\\n            if(major == nums[i]) count++;\\n            else count--;\\n            if(count == -1){\\n                major = nums[i];\\n                count++;\\n            }\\n        }\\n        return major;\\n    }",
                "solutionTags": [],
                "code": "    //http://www.cs.utexas.edu/~moore/best-ideas/mjrty/\\n    //Animation explanation: http://www.cs.utexas.edu/~moore/best-ideas/mjrty/example.html\\n    public int MajorityElement(int[] nums) {\\n        int major = nums[0];\\n        for(int i = 0, count = 0; i < nums.Length; i++){\\n            if(major == nums[i]) count++;\\n            else count--;\\n            if(count == -1){\\n                major = nums[i];\\n                count++;\\n            }\\n        }\\n        return major;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51681,
                "title": "2-8-lines-bit-counting",
                "content": "I've seen several high-voted bit-counter solutions, but they were all quite long.\\n\\n**C++** (Java would be almost the same)\\n\\n    int majorityElement(vector<int>& nums) {\\n        int winner = 0;\\n        for (int i=0; i<32; i++) {\\n            int ones = 0;\\n            for (int n : nums)\\n                ones += (n >> i) & 1;\\n            winner += (ones > nums.size() / 2) << i;\\n        }\\n        return winner;\\n    }\\n\\n**Python**\\n\\nFor once, Python's arbitrarily large integers are a disadvantage :-(\\n\\n    def majorityElement(self, nums):\\n        return (sum((sum(n>>i&1 for n in nums) > len(nums)/2) << i\\n                    for i in range(32)) + 2**31) % 2**32 - 2**31",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "I've seen several high-voted bit-counter solutions, but they were all quite long.\\n\\n**C++** (Java would be almost the same)\\n\\n    int majorityElement(vector<int>& nums) {\\n        int winner = 0;\\n        for (int i=0; i<32; i++) {\\n            int ones = 0;\\n            for (int n : nums)\\n                ones += (n >> i) & 1;\\n            winner += (ones > nums.size() / 2) << i;\\n        }\\n        return winner;\\n    }\\n\\n**Python**\\n\\nFor once, Python's arbitrarily large integers are a disadvantage :-(\\n\\n    def majorityElement(self, nums):\\n        return (sum((sum(n>>i&1 for n in nums) > len(nums)/2) << i\\n                    for i in range(32)) + 2**31) % 2**32 - 2**31",
                "codeTag": "Python3"
            },
            {
                "id": 51990,
                "title": "92ms-cpp-solution-o-n-runtime-o-1-memory",
                "content": "    int majorityElement(vector<int> &num) {\\n        int maj;\\n        int count = 0;\\n        int n = int(num.size());\\n        for (int i = 0; i < n; i++){\\n            if (count == 0){\\n                maj = num[i];\\n                count++;\\n            }\\n            else if (num[i] == maj){\\n                count++;\\n                if (count > n/2) return maj;\\n            }\\n            else count--;\\n        }\\n        return maj;\\n    }\\n\\n\\n*notice the early return if count exceeds size/2",
                "solutionTags": [],
                "code": "    int majorityElement(vector<int> &num) {\\n        int maj;\\n        int count = 0;\\n        int n = int(num.size());\\n        for (int i = 0; i < n; i++){\\n            if (count == 0){\\n                maj = num[i];\\n                count++;\\n            }\\n            else if (num[i] == maj){\\n                count++;\\n                if (count > n/2) return maj;\\n            }\\n            else count--;\\n        }\\n        return maj;\\n    }\\n\\n\\n*notice the early return if count exceeds size/2",
                "codeTag": "Unknown"
            },
            {
                "id": 3693784,
                "title": "easily-understandable-solution-most-optimised",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N) + O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int counter=0, ele=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(counter==0){ele=nums[i];     counter++; } \\n              else if(ele==nums[i]) counter++; \\n                else counter--;\\n        }return ele;\\n    }\\n};\\n```PLEASE UPVOTE TO MOTIVATE ME WRITE MORE SOLUTION",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int counter=0, ele=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(counter==0){ele=nums[i];     counter++; } \\n              else if(ele==nums[i]) counter++; \\n                else counter--;\\n        }return ele;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393916,
                "title": "boyer-moore-the-efficient-majority-element-finder-c-solution-easy-to-understand",
                "content": "\\n***The Boyer-Moore algorithm has a time complexity of O(n) and a space complexity of O(1), as it only uses two variables to keep track of the candidate element and its count, and modifies the input array in place.***\\n\\n![iages.jpeg](https://assets.leetcode.com/users/images/47ec9693-2ff7-452e-b392-f8799e1a253d_1680958849.4548326.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:\\n     - O(n) \\n\\n- Space complexity:\\n     - O(1)\\n\\n# Code\\n```\\nint majorityElement(int* nums, int numsSize) {\\n    int candidate = nums[0];\\n    int count = 1;\\n    for (int i = 1; i < numsSize; i++) {\\n        if (nums[i] == candidate) {\\n            count++;\\n        } else {\\n            count--;\\n            if (count == 0) {\\n                candidate = nums[i];\\n                count = 1;\\n            }\\n        }\\n    }\\n    return candidate;\\n}\\n\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nint majorityElement(int* nums, int numsSize) {\\n    int candidate = nums[0];\\n    int count = 1;\\n    for (int i = 1; i < numsSize; i++) {\\n        if (nums[i] == candidate) {\\n            count++;\\n        } else {\\n            count--;\\n            if (count == 0) {\\n                candidate = nums[i];\\n                count = 1;\\n            }\\n        }\\n    }\\n    return candidate;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3333192,
                "title": "easiest-c-code-2-lines-approach-explained",
                "content": "# Approach\\nThis code implements a solution to the `majorityElement` problem, which asks to find the element that appears more than `n/2`times in an array of n integers. Therefore the majority element will always be present at `n/2`th position when the array is sorted.\\n# Complexity\\n- **Time complexity**: O(NlogN)\\n- **Space complexity**:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums[nums.size()/2];\\n    }\\n};\\n```\\n\\n# `Note: This solution does not follows the question\\'s follow up.`",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums[nums.size()/2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188670,
                "title": "2-line-simple-java-code",
                "content": "# Approach\\nMaximum element occurs more than n/2 times thats why it is confirm it will be on mid after sorting array\\n\\n# Complexity\\n- Time complexity: O(n logn)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[nums.length/2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[nums.length/2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056592,
                "title": "c-tricky-solution",
                "content": "# Intuition\\nSince a number occurs more than half of the time. If the array is sorted, it will definitely be the middle element of the array.\\n\\n# Approach\\nSort the array and return the middle element.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int mid=nums.size()/2;\\n        return nums[mid];\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int mid=nums.size()/2;\\n        return nums[mid];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013694,
                "title": "python-3-ways-to-solve-this-easy",
                "content": "**INBUILT- One Liner Solution**\\n```\\nreturn Counter(nums).most_common()[0][0]\\n```\\n**taking Dictionary**\\n```\\ncounter = {}\\nfor i in nums:\\n    if i not in counter:\\n        counter[i] = 1\\n    else:\\n        counter[i]+=1\\nreturn max(counter, key=counter.get)\\n```\\n**MOORE VOTING ALGORITHM**\\n```\\ncount = 0\\nmajority = 0\\n        \\nfor i in nums:\\n    if count == 0:\\n            majority = i\\n            count += 1\\n                \\n    elif i == majority:\\n                count += 1\\n    else:\\n        count -= 1 \\n                \\nreturn majority\\n```\\n\\n# ****If It helped you kindly Upvote and motivate me",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nreturn Counter(nums).most_common()[0][0]\\n```\n```\\ncounter = {}\\nfor i in nums:\\n    if i not in counter:\\n        counter[i] = 1\\n    else:\\n        counter[i]+=1\\nreturn max(counter, key=counter.get)\\n```\n```\\ncount = 0\\nmajority = 0\\n        \\nfor i in nums:\\n    if count == 0:\\n            majority = i\\n            count += 1\\n                \\n    elif i == majority:\\n                count += 1\\n    else:\\n        count -= 1 \\n                \\nreturn majority\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1787740,
                "title": "construct-majority-element-bit-manipulation-c-o-n-time-o-1-space",
                "content": "If we consider the binary representation of each element we can see that specific bits must be present more than half the time, and only all of the bits which appear a majority of the time will be for the majority element of the array.\\nFor example if we consider the array: [5,5,6,6,5,7,5]\\n```\\n101\\n101\\n110\\n110\\n101\\n111\\n101\\n```\\nAs we can see if we iterate over each bit can count the number of times that a 1 is present we can built up the majority element, bit by bit.\\nGoing from left to right, \\n```\\n0: 7 bits\\n1: 3 bits\\n2: 5 bits\\n```\\nHence we can construct MajorityElement = 0b101 = 5 as, 7  > 3 (1), 3 < 3 (0), and 5 > 3 (1).\\nAs we are only looping of the array 32 times, we get ***O(n)*** time complexity and ***O(1)*** space complexity.\\n```\\nclass Solution {\\npublic:\\n\\n  int majorityElement(vector<int>& nums) {\\n    int half = nums.size()/2, num = 0;\\n    for (int i = 31; i >= 0; i--) {\\n      int mask = 1 << i, count = 0;\\n      for (int el : nums) {\\n        if (el & mask) count++;\\n      }\\n      if (count > half) num |= mask;\\n    }\\n    return num;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n101\\n101\\n110\\n110\\n101\\n111\\n101\\n```\n```\\n0: 7 bits\\n1: 3 bits\\n2: 5 bits\\n```\n```\\nclass Solution {\\npublic:\\n\\n  int majorityElement(vector<int>& nums) {\\n    int half = nums.size()/2, num = 0;\\n    for (int i = 31; i >= 0; i--) {\\n      int mask = 1 << i, count = 0;\\n      for (int el : nums) {\\n        if (el & mask) count++;\\n      }\\n      if (count > half) num |= mask;\\n    }\\n    return num;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083671,
                "title": "javascript-quick-hashmap",
                "content": "```\\nvar majorityElement = function(nums) {\\n    let map = {}\\n    let n = nums.length;\\n    \\n    for(let i of nums){\\n        if(!map[i]) {\\n            map[i] = 1;\\n        } else {\\n            map[i]++;\\n        }\\n        if (map[i] >= n/2) return i\\n    }\\n    console.log(map)\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar majorityElement = function(nums) {\\n    let map = {}\\n    let n = nums.length;\\n    \\n    for(let i of nums){\\n        if(!map[i]) {\\n            map[i] = 1;\\n        } else {\\n            map[i]++;\\n        }\\n        if (map[i] >= n/2) return i\\n    }\\n    console.log(map)\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 375925,
                "title": "javascript",
                "content": "```\\nvar majorityElement = function(nums) {\\n    \\n    const hash = {}\\n    let max = 0, val\\n    \\n    for (let i = 0; i < nums.length; i++){\\n        hash[nums[i]] ? hash[nums[i]]++ : hash[nums[i]] = 1\\n        if (hash[nums[i]] > max){\\n            max = hash[nums[i]]\\n            val = nums[i]\\n        }\\n    }\\n    \\n    return val\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar majorityElement = function(nums) {\\n    \\n    const hash = {}\\n    let max = 0, val\\n    \\n    for (let i = 0; i < nums.length; i++){\\n        hash[nums[i]] ? hash[nums[i]]++ : hash[nums[i]] = 1\\n        if (hash[nums[i]] > max){\\n            max = hash[nums[i]]\\n            val = nums[i]\\n        }\\n    }\\n    \\n    return val\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 177148,
                "title": "python-solution",
                "content": "Boyer Moore voting algorithm:\\n```\\nclass Solution(object):\\n    def majorityElement(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for num in nums:\\n            if count == 0:\\n                candidate = num\\n            count += (1 if num == candidate else -1)\\n        return candidate\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def majorityElement(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for num in nums:\\n            if count == 0:\\n                candidate = num\\n            count += (1 if num == candidate else -1)\\n        return candidate\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51799,
                "title": "o-n-c-solution",
                "content": "    int majorityElement(int* nums, int numsSize) {\\n        int cnt = 1;\\n        int major = nums[0];\\n        for(int i = 1; i < numsSize; i++){\\n            if(nums[i] == major) cnt++;\\n            else if(cnt == 0){\\n                major = nums[i];\\n                cnt++;\\n           }\\n           else\\n               cnt--;\\n\\t    }\\n        return major;\\n    }",
                "solutionTags": [],
                "code": "    int majorityElement(int* nums, int numsSize) {\\n        int cnt = 1;\\n        int major = nums[0];\\n        for(int i = 1; i < numsSize; i++){\\n            if(nums[i] == major) cnt++;\\n            else if(cnt == 0){\\n                major = nums[i];\\n                cnt++;\\n           }\\n           else\\n               cnt--;\\n\\t    }\\n        return major;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51819,
                "title": "c-5-lines-using-stack",
                "content": "Basically, maintain a stack for comparing two adjacent number. \\nIterate the array left to right, if current stack is empty or the current number is the same as the top of stack, push the number to stack for next comparison.\\nOtherwise, if the stack's top is different than the current number, do pop operation.\\n\\nTime is O(n), worst-case scenario, space is n/2\\n\\n\\n\\n    class Solution {\\n    public:\\n        int majorityElement(vector<int>& nums) {\\n            stack<int> S;\\n            for(int i = 0; i < nums.size(); i++){\\n                if(S.empty() || nums[i] == S.top()) S.push(nums[i]);\\n                else if(nums[i] != S.top()) S.pop();\\n            }\\n            return S.top();\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int majorityElement(vector<int>& nums) {\\n            stack<int> S;\\n            for(int i = 0; i < nums.size(); i++){\\n                if(S.empty() || nums[i] == S.top()) S.push(nums[i]);\\n                else if(nums[i] != S.top()) S.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 51874,
                "title": "simple-solution",
                "content": " \\n\\n       class Solution {\\n    public:\\n        int majorityElement(vector<int>& nums) {\\n            int res,count=0;\\n            for(int num:nums){\\n                if(count==0||res==num){\\n                    res=num;\\n                    ++count;\\n                }else \\n                    --count;\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int majorityElement(vector<int>& nums) {\\n            int res,count=0;\\n            for(int num:nums){\\n                if(count==0||res==num){\\n                    res=num;\\n                    ++count;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 51915,
                "title": "short-20ms-linear-time-c-solution",
                "content": "    class Solution {\\n    public:\\n        int majorityElement(vector<int> &num) {\\n            int cand = 0, count = 0;\\n            for (int i = 0; i < num.size(); ++i) {\\n                if (count == 0) {\\n                    cand = num[i];\\n                    count = 1;\\n                } else if (num[i] == cand) {\\n                    count++;\\n                } else {\\n                    count--;\\n                }\\n            }\\n            return cand;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int majorityElement(vector<int> &num) {\\n            int cand = 0, count = 0;\\n            for (int i = 0; i < num.size(); ++i) {\\n                if (count == 0) {\\n                    cand = num[i];\\n                    count = 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 51919,
                "title": "my-c-bit-operation-solution-in-o-n-time-o-1-space-28ms",
                "content": "Suppose the majority number exist as **n**, \\n\\nIf we sum the count of occurrence of **1** s for all the number in **num** at each bit position.\\n\\nThe number will either exceed **half** because **n** contributed more than half of **1** at that position, \\n\\nor the number will be less-equal than **half** because **n** has **0** here then contributed nothing.\\n\\nclass Solution {\\n\\n    public:\\n        int majorityElement(vector<int> &num) {\\n            int len = num.size();\\n            if (len < 3) return num[0];\\n            int half = len/2;\\n            int bit_ct[32];\\n            for (int i=0; i<32; ++i)  bit_ct[i] = 0;\\n            for (auto n:num){ // count the number of 1 occured on each bit position\\n                for (int i=0; i<32; ++i){\\n                    if (n%2) ++bit_ct[i];\\n                    n >>= 1;\\n                }\\n            }\\n            int ans = 0;\\n            for(int i=31; i>=0; --i){\\n                ans <<= 1;\\n                if (bit_ct[i]>half) ++ans;\\n            }\\n            return ans;\\n        }\\n\\n};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\n    public:\\n        int majorityElement(vector<int> &num) {\\n            int len = num.size();\\n            if (len < 3) return num[0];\\n            int half = len/2;\\n            int bit_ct[32];\\n            for (int i=0; i<32; ++i)  bit_ct[i] = 0;\\n            for (auto n:num){ // count the number of 1 occured on each bit position\\n                for (int i=0; i<32; ++i){\\n                    if (n%2) ++bit_ct[i];\\n                    n >>= 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 51996,
                "title": "share-my-solution-2-lines-use-c",
                "content": "    class Solution {\\n    public:\\n        int majorityElement(vector<int> &num) {\\n             sort(num.begin(), num.end());\\n             return num[(num.size())/2];\\n            \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int majorityElement(vector<int> &num) {\\n             sort(num.begin(), num.end());\\n             return num[(num.size())/2];\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3512886,
                "title": "majority-element-very-easy-solution-c",
                "content": "# Intuition\\nSince majority element can more than half in the given array. We can just sort the array and get the element in the middle.\\n\\n# Approach\\nFirst sort the array and access middle element\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\nNo extra space is used\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MajorityElement(int[] nums) {\\n        //return nums.ToList().GroupBy(x => x).OrderByDescending(g=>g.Count()).Select(y=>y.Key).FirstOrDefault();\\n        Array.Sort(nums);\\n        return nums[nums.Length/2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MajorityElement(int[] nums) {\\n        //return nums.ToList().GroupBy(x => x).OrderByDescending(g=>g.Count()).Select(y=>y.Key).FirstOrDefault();\\n        Array.Sort(nums);\\n        return nums[nums.Length/2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137683,
                "title": "onlycode-in-java-using-hashmap",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        int num = 0;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n            map.put(nums[i],map.get(nums[i])+1);\\n            }else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        Set<Integer> keySet = map.keySet();\\n        for(Integer key:keySet){\\n            if(map.get(key)>nums.length/2){\\n                num = key;\\n            }\\n        }\\n        return num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        int num = 0;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n            map.put(nums[i],map.get(nums[i])+1);\\n            }else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        Set<Integer> keySet = map.keySet();\\n        for(Integer key:keySet){\\n            if(map.get(key)>nums.length/2){\\n                num = key;\\n            }\\n        }\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081811,
                "title": "best-o-n-solution",
                "content": "\\n\\n# Approach\\nMoore\\'s Voting Algorithm\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int idx = 0, count = 1;\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[idx] == nums[i])\\n                count++;\\n            else\\n                count--;\\n            if (count == 0) {\\n                idx = i;\\n                count = 1;\\n            }        \\n        } \\n        return nums[idx];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int idx = 0, count = 1;\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[idx] == nums[i])\\n                count++;\\n            else\\n                count--;\\n            if (count == 0) {\\n                idx = i;\\n                count = 1;\\n            }        \\n        } \\n        return nums[idx];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851781,
                "title": "easy-line-by-line-explained-c-idictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen doing this we will need to consider a few factors \\n- The majority element is the element that appears more than \\u230An / 2\\u230B\\n- eg [3,2,3] so means that the majority of numbers in the array are 3 \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a Dictionary to store the Key and value \\n- Iterate through the array \\n- add to the Dictionary if it does not contain it \\n- else increment the value \\n- check if the current value is greater than n / 2 \\n\\n++ is a preincrement/postincrement operator. It increments a numeric value by 1. The position of the ++ is important.\\nmap[i]++ first evaluates map[i], then increments it by 1.\\n++map[i] would increment map[i] by 1, and then evaluate it.\\n\\nIn this case, it does not matter when map[i] is evaluated, but it does if map[i]++ was used in a larger expression\\n\\nmap[i]++/++map[i] is basically the same as doing map[i] += 1, or map[i] = map[i] + 1. \\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: I wish i knew brother haha \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MajorityElement(int[] nums) {\\n    // creating a dictionary\\n      IDictionary<int, int> map = new Dictionary<int, int>();\\n    // checking if the length is 1 to return the eliment at 0 \\n        if (nums.Length == 1 ){\\n            return nums[0];\\n         }\\n    // Itterate through the array     \\n        foreach (int i in nums){\\n        // checking if the map Key does NOT contains the value at i \\n            if (!map.ContainsKey(i)){\\n              // adding to Dictionary\\n                map.Add(i , 1 );\\n            }else {\\n                // increment the value by 1 \\n                map[i]++;\\n            }\\n            // check if the value at i is greater than nums length  devided by 2 \\n            if (map[i] > nums.Length/2){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public int MajorityElement(int[] nums) {\\n    // creating a dictionary\\n      IDictionary<int, int> map = new Dictionary<int, int>();\\n    // checking if the length is 1 to return the eliment at 0 \\n        if (nums.Length == 1 ){\\n            return nums[0];\\n         }\\n    // Itterate through the array     \\n        foreach (int i in nums){\\n        // checking if the map Key does NOT contains the value at i \\n            if (!map.ContainsKey(i)){\\n              // adding to Dictionary\\n                map.Add(i , 1 );\\n            }else {\\n                // increment the value by 1 \\n                map[i]++;\\n            }\\n            // check if the value at i is greater than nums length  devided by 2 \\n            if (map[i] > nums.Length/2){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645142,
                "title": "java-hashmap-solution-with-explanation",
                "content": "```\\n\\t\\tHashMap<Integer,Integer>map=new HashMap<>();\\n        int n=nums.length;\\n        \\n        for(int i:nums){\\n            \\n\\t\\t\\t//if hashmap does not contain the specific key\\n            if(!map.containsKey(i)){\\n                map.put(i,1);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//if it does contain the specific key,increase its count/value by 1\\n            else{\\n                map.put(i,map.get(i)+1);\\n            }\\n            \\n\\t\\t\\t//if the value of a specific key hai reached n/2 value,then return \\n            if(map.get(i)>n/2){\\n                return i;\\n            }\\n        }\\n        return 0;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\tHashMap<Integer,Integer>map=new HashMap<>();\\n        int n=nums.length;\\n        \\n        for(int i:nums){\\n            \\n\\t\\t\\t//if hashmap does not contain the specific key\\n            if(!map.containsKey(i)){\\n                map.put(i,1);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//if it does contain the specific key,increase its count/value by 1\\n            else{\\n                map.put(i,map.get(i)+1);\\n            }\\n            \\n\\t\\t\\t//if the value of a specific key hai reached n/2 value,then return \\n            if(map.get(i)>n/2){\\n                return i;\\n            }\\n        }\\n        return 0;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2249782,
                "title": "100-faster-0ms",
                "content": "```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n  \\n        int count = 0, ans = 0;\\n      \\tfor(int num: nums) {\\n\\t\\t if(count == 0) {\\n\\t\\t\\t ans = num;\\n\\t\\t}\\n\\t    \\tif(num == ans) {\\n\\t\\t\\t        count++;\\n\\t\\t} else {\\n\\t\\t\\tcount--;\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans; \\n    }\\n}\\n\\n```\\nIf you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n  \\n        int count = 0, ans = 0;\\n      \\tfor(int num: nums) {\\n\\t\\t if(count == 0) {\\n\\t\\t\\t ans = num;\\n\\t\\t}\\n\\t    \\tif(num == ans) {\\n\\t\\t\\t        count++;\\n\\t\\t} else {\\n\\t\\t\\tcount--;\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans; \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1947656,
                "title": "kotlin-o-n-time-and-o-1-space",
                "content": "Taking hints from the Boyer-Moore Algorithm\\'s solution.\\nBasically we keep a count of a running \"candidate\" in the loop, if the count goes back to zero, we start over at that index.\\n```\\nclass Solution {\\n    fun majorityElement(nums: IntArray): Int {\\n        // Boyer-Moore Algorithm\\n        var count = 0\\n        var candidate: Int = 0\\n        nums.forEach { num ->\\n            if (count == 0) {\\n                candidate = num\\n            }\\n            count += if (num == candidate) 1 else -1\\n        }\\n        return candidate\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun majorityElement(nums: IntArray): Int {\\n        // Boyer-Moore Algorithm\\n        var count = 0\\n        var candidate: Int = 0\\n        nums.forEach { num ->\\n            if (count == 0) {\\n                candidate = num\\n            }\\n            count += if (num == candidate) 1 else -1\\n        }\\n        return candidate\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787843,
                "title": "java-1ms-fastest-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/7d53faa0-8e78-43b5-a170-49e44b875e4f_1645415405.60709.png)\\n```\\n\\n```// we will just check what number can be a majority number up until index i;\\n// for a number to be majority its frequency should be greater than (sizeOf array traverse/2)\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        int c=-1; // keep a count to keep freq of element\\n        int maj = -1; // stores the potential majority\\n        for(int n : nums)\\n        {\\n            if(c<=0) // if freq becomes zero consider the curr element as majority\\n            {\\n                maj = n;\\n                c=1;\\n                continue;\\n            }\\n            if(n==maj) c++; // if n is same as what we assumed majority\\n            else c--; // if n is different to what we assumed as majority\\n        }\\n        return maj;\\n    }\\n}``",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1362318,
                "title": "golang-time-o-n-space-o-1",
                "content": "```\\nfunc majorityElement(nums []int) int {\\n    target := nums[0]\\n    cnt := 1\\n    n := len(nums)\\n    for i := 1; i < n; i++ {\\n        if nums[i] == target {\\n            cnt++\\n        } else {\\n            cnt--\\n            if cnt == 0 {\\n                target = nums[i]\\n                cnt = 1\\n            }\\n        }\\n    }\\n    return target\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc majorityElement(nums []int) int {\\n    target := nums[0]\\n    cnt := 1\\n    n := len(nums)\\n    for i := 1; i < n; i++ {\\n        if nums[i] == target {\\n            cnt++\\n        } else {\\n            cnt--\\n            if cnt == 0 {\\n                target = nums[i]\\n                cnt = 1\\n            }\\n        }\\n    }\\n    return target\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1110424,
                "title": "o-n-2-o-nlogn-o-n",
                "content": "**Solution 1: Brute Force**\\n1. count occurance of every element \\n  **Time: O(n^2) && Space :O(1)**\\n  \\n  ```\\n  public int majorityElement(int[] nums){\\n      int n=nums.length;\\n     \\n\\t for(int i=0;i<nums.length;i++){\\n\\t    int value=nums[i];\\n\\t    int count=0;\\t\\n\\t for(int j=0;j<nums.length;j++){\\n\\t    if(nums[j]==value) count++;\\n\\t}\\n\\t   if(count>n/2) return value;\\n\\t   }\\n\\t  return -1; \\n  }\\n  ```\\n  \\n**Solution 2: Sorting**\\n**Time :O(nlogn) && Space :O(1)**\\n```\\npublic int majorityElement(int[] nums){\\n  Arrays.sort(nums);\\n  return nums[nums.length/2];  // as they have mention that there exist majority element for sure\\n}\\n```\\n\\n**Solution 3: HashMap**\\n1. Idea is to make a frequency map and check who have frequency > n/2.\\n**Time : O(n) && Space:O(n)**\\n\\n```\\n\\npublic int majorityElement(int[] nums){\\n  HashMap<Integer,Integer> fmap=new HashMap<>();  //fmap: frequency map\\n  for(int num:nums) fmap.put(num,fmap.getOrDefault(num,0)+1);\\n  \\n  for(int num:fmap.keySet()){\\n      if(fmap.get(num)>nums.length/2) return num;\\n  }\\n  return -1;  \\n}\\n\\n```\\n\\n\\n**Soluton 4: Moore Voting Algorithm**\\n**Time : O(N) && Space:O(1)**\\n```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        int val=nums[0];\\n        int count=1;\\n        \\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]==val){\\n                count++;\\n            }else{\\n                if(count>0){\\n                    count--;\\n                }else{\\n                    val=nums[i];\\n                    count=1;\\n                }\\n            }\\n        }\\n        return val;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  public int majorityElement(int[] nums){\\n      int n=nums.length;\\n     \\n\\t for(int i=0;i<nums.length;i++){\\n\\t    int value=nums[i];\\n\\t    int count=0;\\t\\n\\t for(int j=0;j<nums.length;j++){\\n\\t    if(nums[j]==value) count++;\\n\\t}\\n\\t   if(count>n/2) return value;\\n\\t   }\\n\\t  return -1; \\n  }\\n  ```\n```\\npublic int majorityElement(int[] nums){\\n  Arrays.sort(nums);\\n  return nums[nums.length/2];  // as they have mention that there exist majority element for sure\\n}\\n```\n```\\n\\npublic int majorityElement(int[] nums){\\n  HashMap<Integer,Integer> fmap=new HashMap<>();  //fmap: frequency map\\n  for(int num:nums) fmap.put(num,fmap.getOrDefault(num,0)+1);\\n  \\n  for(int num:fmap.keySet()){\\n      if(fmap.get(num)>nums.length/2) return num;\\n  }\\n  return -1;  \\n}\\n\\n```\n```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        int val=nums[0];\\n        int count=1;\\n        \\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]==val){\\n                count++;\\n            }else{\\n                if(count>0){\\n                    count--;\\n                }else{\\n                    val=nums[i];\\n                    count=1;\\n                }\\n            }\\n        }\\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 616303,
                "title": "c-2-solution-moore-s-voting-algo-o-n-time-o-1-space-hash-table-o-n-time-o-n-space",
                "content": "The **Boyer\\u2013Moore majority vote algorithm** is an algorithm for finding the majority in a sequence of elements using linear time and constant space.\\n\\nIf there is a majority element, the algorithm will always find it. \\n\\n**Proof:**\\nhttp://www.cs.rug.nl/~wim/pub/whh348.pdf\\n\\n**Algorithm:**\\n1. Loop through each element and maintains a count of majority element, and a majority element.\\n2. If the next element is same then increment the count.\\n3. If the next element is not same then decrement the count. If the count reaches 0 then changes the majority element to the current element and set the count again to 1.\\n\\n```\\nint majorityElement( vector<int>& nums ) {\\n\\t// Based on Moore\\'s Voting Algorithm\\n\\t// which gets you majority element if it exists\\n\\tint majority = nums[0], vote=1;\\n\\tfor( int i=1; i < nums.size(); i++ ) {\\n\\t\\tif( nums[i] == majority )\\n\\t\\t\\tvote++;\\n\\t\\telse if( --vote == 0 ) {\\n\\t\\t\\tmajority = nums[i];\\n\\t\\t\\tvote = 1;\\n\\t\\t}\\n\\t}\\n\\treturn  majority; \\n}\\n```\\n\\nOther solution using hash table\\n```\\n    int majorityElement( vector<int>& nums ) {\\n        unordered_map<int, int> numCount;\\n        for( auto num : nums )\\n            ++numCount[num];\\n        \\n        int count = 1, majority=nums[0];\\n        for( auto p : numCount )\\n            if( p.second > count ) {\\n                count = p.second;\\n                majority = p.first;\\n            }\\n        return majority;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint majorityElement( vector<int>& nums ) {\\n\\t// Based on Moore\\'s Voting Algorithm\\n\\t// which gets you majority element if it exists\\n\\tint majority = nums[0], vote=1;\\n\\tfor( int i=1; i < nums.size(); i++ ) {\\n\\t\\tif( nums[i] == majority )\\n\\t\\t\\tvote++;\\n\\t\\telse if( --vote == 0 ) {\\n\\t\\t\\tmajority = nums[i];\\n\\t\\t\\tvote = 1;\\n\\t\\t}\\n\\t}\\n\\treturn  majority; \\n}\\n```\n```\\n    int majorityElement( vector<int>& nums ) {\\n        unordered_map<int, int> numCount;\\n        for( auto num : nums )\\n            ++numCount[num];\\n        \\n        int count = 1, majority=nums[0];\\n        for( auto p : numCount )\\n            if( p.second > count ) {\\n                count = p.second;\\n                majority = p.first;\\n            }\\n        return majority;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 453689,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n\\t public int majorityElement(int[] nums) {\\n        Arrays.sort(nums);\\n        int x = nums.length/2;\\n        return nums[x];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t public int majorityElement(int[] nums) {\\n        Arrays.sort(nums);\\n        int x = nums.length/2;\\n        return nums[x];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51822,
                "title": "divide-and-conquer-solution-to-majority-element-problem-not-optimal-o-nlogn",
                "content": "    \\n    public class Solution {\\n        public int majorityElement(int[] nums) {\\n            if (nums.length == 1) return nums[0];\\n            int leftM = majorityElement(Arrays.copyOfRange(nums, 0, nums.length/2));\\n            int rightM = majorityElement(Arrays.copyOfRange(nums, nums.length/2, nums.length));\\n            int counterLeft = 0;\\n            for (int num : nums) {\\n                if (num == leftM) counterLeft++;\\n                if (counterLeft > nums.length/2) return leftM;\\n            }\\n            return rightM;\\n        }\\n        \\n    }\\n\\nThis is not the optimal solution and time complexity is O(nlogn). T(n) = 2T(n/2) + O(n).",
                "solutionTags": [],
                "code": "class Solution {\\n        public int majorityElement(int[] nums) {\\n            if (nums.length == 1) return nums[0];\\n            int leftM = majorityElement(Arrays.copyOfRange(nums, 0, nums.length/2));\\n            int rightM = majorityElement(Arrays.copyOfRange(nums, nums.length/2, nums.length));\\n            int counterLeft = 0;\\n            for (int num : nums) {\\n                if (num == leftM) counterLeft++;\\n                if (counterLeft > nums.length/2) return leftM;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 51869,
                "title": "16ms-c-solution",
                "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int majorElement = nums[0];\\n        int count = 1;\\n        \\n        for( int i = 1; i < nums.size(); i++){\\n            if( nums[i] == majorElement)\\n                count++;\\n            else if( nums[i] != majorElement && count > 0)\\n                count--;\\n            else{\\n                majorElement = nums[i];\\n                count = 1;\\n            }\\n            \\n        }\\n        \\n        return majorElement;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int majorElement = nums[0];\\n        int count = 1;\\n        \\n        for( int i = 1; i < nums.size(); i++){\\n            if( nums[i] == majorElement)\\n                count++;\\n            else if( nums[i] != majorElement && count > 0)\\n                count--;\\n            else{\\n                majorElement = nums[i];\\n                count = 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 51896,
                "title": "majority-voting-agorithms-o-n-complexity",
                "content": "        public int majorityElement(int[] nums) {\\n     if(nums == null || nums.length <= 0)\\n        return 0;\\n        \\n     int majority=1;\\n     int number = nums[0];\\n        for(int i =1 ; i < nums.length; i++)\\n        {\\n             if(nums[i] !=  number)\\n                majority--;\\n             else\\n             {\\n                 majority++;\\n                 continue;\\n             }\\n             if(majority == 0){\\n                 number = nums[i];\\n                 majority++;\\n             }\\n        }\\n       return number;\\n    }",
                "solutionTags": [],
                "code": "        public int majorityElement(int[] nums) {\\n     if(nums == null || nums.length <= 0)\\n        return 0;\\n        \\n     int majority=1;\\n     int number = nums[0];\\n        for(int i =1 ; i < nums.length; i++)\\n        {\\n             if(nums[i] !=  number)\\n                majority--;\\n             else\\n             {\\n                 majority++;\\n                 continue;\\n             }\\n             if(majority == 0){\\n                 number = nums[i];\\n                 majority++;\\n             }\\n        }\\n       return number;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 52000,
                "title": "solution-simple-python-solution-based-on-voting",
                "content": "The code is based on the elegant Majority Voting algorithm by Moore. ([http://www.cs.utexas.edu/~moore/best-ideas/mjrty/index.html][1])\\n\\nRuntime : O(N), Space: O(1)\\n\\n    class Solution:\\n        # @param num, a list of integers\\n        # @return an integer\\n        def majorityElement(self, num):\\n            candidate = None\\n            count = 0\\n            for n in num:\\n                if candidate == None:\\n                    candidate = n\\n                    count += 1\\n                elif n == candidate:\\n                    count += 1\\n                elif n != candidate and count == 1:\\n                    candidate = None\\n                    count -= 1\\n                elif n != candidate:\\n                    count -= 1\\n            return candidate\\n\\n\\n  [1]: http://www.cs.utexas.edu/~moore/best-ideas/mjrty/index.html",
                "solutionTags": [
                    "Python"
                ],
                "code": "The code is based on the elegant Majority Voting algorithm by Moore. ([http://www.cs.utexas.edu/~moore/best-ideas/mjrty/index.html][1])\\n\\nRuntime : O(N), Space: O(1)\\n\\n    class Solution:\\n        # @param num, a list of integers\\n        # @return an integer\\n        def majorityElement(self, num):\\n            candidate = None\\n            count = 0\\n            for n in num:\\n                if candidate == None:\\n                    candidate = n\\n                    count += 1\\n                elif n == candidate:\\n                    count += 1\\n                elif n != candidate and count == 1:\\n                    candidate = None\\n                    count -= 1\\n                elif n != candidate:\\n                    count -= 1\\n            return candidate\\n\\n\\n  [1]: http://www.cs.utexas.edu/~moore/best-ideas/mjrty/index.html",
                "codeTag": "Java"
            },
            {
                "id": 3738432,
                "title": "o-n-time-o-1-space-beats-90-5-line-only-let-s-vote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can store frequency of each element in a hashmap and later check which element has the highest frequency. Since it is gurranted that there will always be a majority element in the given array so we can return the element with highest frequency as majority element.\\n\\nBut if we think about the above approach then we will see that we are not using the condition that majority element needs to be appear `more than \\u230An / 2\\u230B times`. The condition indicates majority elements will appear at least  `(\\u230An / 2\\u230B + 1)` times. This indicates that majority element will always win if we there is a **voting** where majority element will be one party and all other elements will be opposite party \\uD83D\\uDE09 \\n\\nMajority element will vote for itself (vote++) \\nOther elements will vote against the majority element (vote--)\\n\\nSince majority element is unknown so we will assume an element to be major element when vote count is 0\\n\\nTo understand this with simulation please take a look here - https://www.cs.utexas.edu/~moore/best-ideas/mjrty/\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ (Approach 01)\\n$$O(1)$$ (Approach 02)\\n\\n# Code\\n### Approach 01:  `Hashmap to store frequency of each element`\\n```\\n# PYTHON Solution\\n\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        highest_freq = 1\\n        majority_element = nums[0]\\n        num_to_freq = dict()\\n        num_to_freq[nums[0]] = 1\\n        for num in nums[1:]:\\n            num_to_freq[num] = num_to_freq.get(num, 0) + 1\\n            if  num_to_freq[num] > highest_freq:\\n                highest_freq += 1\\n                majority_element = num\\n        return majority_element\\n        \\n```\\n\\n### Approach 02: `Boyer-Moore Majority Vote Algorithm`\\n\\n```\\n# PYTHON SOLUTION\\n\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        majority_element, majority_element_frequency = nums[0], 1 # Initialize first element as the majority element \\n\\n        for num in nums[1:]:\\n            if majority_element_frequency == 0: # Reset the majority element and frequency of majority element\\n                majority_element, majority_element_frequency = num, 1\\n            else:\\n                majority_element_frequency += (1 if num == majority_element else -1)\\n        \\n        # Checking whether the frequency of majority element is greater than \\u230An / 2\\u230B is not needed since\\n        # we may assume that the majority element always exists in the array for this problem\\n\\n        return majority_element\\n\\n# Shorter version - 5 line\\n\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        majority_element, majority_element_frequency = None, 0\\n        for num in nums:\\n            if majority_element_frequency == 0: majority_element = num\\n            majority_element_frequency += (1 if num == majority_element else -1)\\n        return majority_element\\n                \\n```\\n```\\n// GO SOLUTION\\n\\nfunc majorityElement(nums []int) int {\\n    majority_element, majority_element_frequency := nums[0], 1\\n    for i := 1; i < len(nums); i++ {\\n        if majority_element_frequency == 0 {\\n            majority_element, majority_element_frequency = nums[i], 1\\n        } else {\\n            if nums[i] == majority_element {\\n                majority_element_frequency += 1\\n            } else {\\n                majority_element_frequency -= 1\\n            }\\n        }\\n    }\\n    return majority_element\\n}\\n```\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go",
                    "Array",
                    "Counting"
                ],
                "code": "```\\n# PYTHON Solution\\n\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        highest_freq = 1\\n        majority_element = nums[0]\\n        num_to_freq = dict()\\n        num_to_freq[nums[0]] = 1\\n        for num in nums[1:]:\\n            num_to_freq[num] = num_to_freq.get(num, 0) + 1\\n            if  num_to_freq[num] > highest_freq:\\n                highest_freq += 1\\n                majority_element = num\\n        return majority_element\\n        \\n```\n```\\n# PYTHON SOLUTION\\n\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        majority_element, majority_element_frequency = nums[0], 1 # Initialize first element as the majority element \\n\\n        for num in nums[1:]:\\n            if majority_element_frequency == 0: # Reset the majority element and frequency of majority element\\n                majority_element, majority_element_frequency = num, 1\\n            else:\\n                majority_element_frequency += (1 if num == majority_element else -1)\\n        \\n        # Checking whether the frequency of majority element is greater than \\u230An / 2\\u230B is not needed since\\n        # we may assume that the majority element always exists in the array for this problem\\n\\n        return majority_element\\n\\n# Shorter version - 5 line\\n\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        majority_element, majority_element_frequency = None, 0\\n        for num in nums:\\n            if majority_element_frequency == 0: majority_element = num\\n            majority_element_frequency += (1 if num == majority_element else -1)\\n        return majority_element\\n                \\n```\n```\\n// GO SOLUTION\\n\\nfunc majorityElement(nums []int) int {\\n    majority_element, majority_element_frequency := nums[0], 1\\n    for i := 1; i < len(nums); i++ {\\n        if majority_element_frequency == 0 {\\n            majority_element, majority_element_frequency = nums[i], 1\\n        } else {\\n            if nums[i] == majority_element {\\n                majority_element_frequency += 1\\n            } else {\\n                majority_element_frequency -= 1\\n            }\\n        }\\n    }\\n    return majority_element\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553215,
                "title": "single-pass-c-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this problem, we simply need to assign an arbitrary element as the majority element and keep track of the frequency with which it occurs in the array. Every time it does, increment a counter by one and decrement it when it doesn\\'t.\\n\\nIf the counter ever reaches zero, assign a new element as the majority element and repeat the process till the end of the array is reached.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are assured that a majority element always exists in the array. Using this, we can assign a variable `ele` as the majority element of the array and iterate through the array, increment a counter every time the current element is equal to `ele` and decrementing it when it isn\\'t.\\n\\nIf the counter zero while iterating through the array, assign the current element as `ele` and continue the usual steps.\\n\\nReturn the final value of `ele` as the majority element.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int ctr=1;\\n        int ele=nums[0];\\n\\n        for(int i=1;i<nums.size();i++){\\n            if(!ctr) ele=nums[i];\\n\\n            ele==nums[i]?ctr++:ctr--;\\n        }\\n        return ele;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int ctr=1;\\n        int ele=nums[0];\\n\\n        for(int i=1;i<nums.size();i++){\\n            if(!ctr) ele=nums[i];\\n\\n            ele==nums[i]?ctr++:ctr--;\\n        }\\n        return ele;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510988,
                "title": "java-solution-for-majority-element-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is that the majority element will always be located at the middle index when the array is sorted. This is because it appears more than \\u230An/2\\u230B times, so it will dominate the sorted array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The code first checks if the array has only one element. In this case, that element is returned as the majority element since it is the only element and automatically appears more than \\u230An/2\\u230B times.\\n2. If the array has more than one element, it proceeds to sort the array using Arrays.sort(nums).\\n3. After sorting, the majority element will be located at index nums.length / 2 since it appears more than \\u230An/2\\u230B times. Thus, it is returned as the majority element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is determined by the sorting operation, which has a time complexity of O(n log n), where n is the length of the input array. Sorting the array is the most time-consuming operation in this case.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(1) because it does not use any additional space that grows with the size of the input array. The space used is constant, regardless of the input size.\\n\\n# Code\\n```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        if (nums.length == 1) \\n        {\\n            return nums[0];\\n        }\\n        Arrays.sort(nums);\\n        return nums[nums.length / 2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        if (nums.length == 1) \\n        {\\n            return nums[0];\\n        }\\n        Arrays.sort(nums);\\n        return nums[nums.length / 2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479251,
                "title": "beats-100-full-explanation-2-easy-steps",
                "content": "# Intuition\\n\\nMoore\\u2019s Voting Algorithm\\n\\nIf the array contains a majority element, its occurrence must be greater than the floor(N/2). Now, we can say that the count of minority elements and majority elements are equal up to a certain point in the array. So when we traverse through the array we try to keep track of the count of elements and the element itself for which we are tracking the count. \\n\\nAfter traversing the whole array, we will check the element stored in the variable. If the question states that the array must contain a majority element, the stored element will be that one but if the question does not state so, then we need to check if the stored element is the majority element or not. If not, then the array does not contain any majority element.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nInitialize 2 variables:\\n\\nCount \\u2013  for tracking the count of element\\nElement \\u2013 for which element we are counting\\n\\nTraverse through the given array.\\n\\nIf Count is 0 then store the current element of the array as Element.\\n\\nIf the current element and Element are the same increase the Count by 1.\\nIf they are different decrease the Count by 1.\\nThe integer present in Element should be the result we are expecting \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N) + O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int majorityElement(int[] v) {\\n        int n=v.length;\\n        int cnt=0;\\n        int el=0;\\n\\n        // applying Moores voting Algorithm \\n        for(int i=0;i<n;i++){\\n            if(cnt==0){\\n                cnt =1;\\n                el=v[i];\\n            }\\n            else if(el == v[i]) cnt++;\\n            else cnt--;\\n        }\\n\\n        // checking if the stored element is majority element\\n        int cnt1=0;\\n        for(int i=0;i<n;i++){\\n            if(v[i]== el) cnt1++;\\n        }\\n        if(cnt1>(n/2)) return el;\\n        return -1;\\n        \\n    }\\n}\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/24f407b8-23ee-49f7-80d5-4b494f2ddb1a_1683057979.63642.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int majorityElement(int[] v) {\\n        int n=v.length;\\n        int cnt=0;\\n        int el=0;\\n\\n        // applying Moores voting Algorithm \\n        for(int i=0;i<n;i++){\\n            if(cnt==0){\\n                cnt =1;\\n                el=v[i];\\n            }\\n            else if(el == v[i]) cnt++;\\n            else cnt--;\\n        }\\n\\n        // checking if the stored element is majority element\\n        int cnt1=0;\\n        for(int i=0;i<n;i++){\\n            if(v[i]== el) cnt1++;\\n        }\\n        if(cnt1>(n/2)) return el;\\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212769,
                "title": "169-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo solve the problem in linear time and O(1) space, we can use Boyer-Moore Voting Algorithm. The algorithm works by maintaining a count variable and a candidate variable. We iterate through the array, for each element, we check if the count is 0, if it is, we update the candidate variable to the current element. We then increment the count variable if the current element is equal to the candidate, otherwise we decrement the count variable. At the end of the iteration, the candidate variable will hold the majority element.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this algorithm is O(n), where n is the length of the array. \\n\\n- Space complexity:\\nThe space complexity is O(1), as we only need to maintain two variables.\\n\\n# Code\\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        # initialize the count and candidate variables\\n        count = 0\\n        candidate = None\\n        \\n        # iterate through the array\\n        for num in nums:\\n            # if count is 0, update the candidate variable\\n            if count == 0:\\n                candidate = num\\n            # increment or decrement count based on whether the current element is the candidate\\n            count += (1 if num == candidate else -1)\\n        \\n        # return the candidate variable\\n        return candidate\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        # initialize the count and candidate variables\\n        count = 0\\n        candidate = None\\n        \\n        # iterate through the array\\n        for num in nums:\\n            # if count is 0, update the candidate variable\\n            if count == 0:\\n                candidate = num\\n            # increment or decrement count based on whether the current element is the candidate\\n            count += (1 if num == candidate else -1)\\n        \\n        # return the candidate variable\\n        return candidate\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126028,
                "title": "2-lines-simple-python-code-beats-100-explained",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def majorityElement(self, nums):\\n        nums.sort() #sorting array ---> [1,1,1,2,2,2,2]\\n        return nums[len(nums)//2] #the majority number always appears more than length of array divide 2\\n        # So that number alawys appear in the middle of array before sorted \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def majorityElement(self, nums):\\n        nums.sort() #sorting array ---> [1,1,1,2,2,2,2]\\n        return nums[len(nums)//2] #the majority number always appears more than length of array divide 2\\n        # So that number alawys appear in the middle of array before sorted \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2633612,
                "title": "99-94-99-98-why-how",
                "content": "**First of all, the question was to return the element repeated max times..(most common).**\\n\\n*I knew about the Counter module throught various other problems, and seems easy, hence submitted.*\\n\\n*But why does the other code faster than this??*\\n\\n\\n![image](https://assets.leetcode.com/users/images/d9ec620d-d8fc-41b6-aaca-4ef2b2d800cf_1664348435.6793725.png)\\n\\n_one-liner using collections.Counter_\\n\\n```\\nreturn collections.Counter(nums).most_common()[0][0]\\n```\\n\\n![image](https://assets.leetcode.com/users/images/6a59a5fa-e4f5-460a-9be2-19756b2007c6_1664348190.634809.png)\\n_Got this code from the submissions graph_\\n```\\nf = open(\"user.out\", \\'w\\')\\nfor line in stdin:\\n    ans = c = 0\\n    for v in map(int, line.rstrip()[1:-1].split(\\',\\')):\\n        if c == 0: ans = v\\n        if ans == v: c += 1\\n        else: c -= 1\\n    print(ans, file=f)\\nexit(0)\\n```\\n*Can anyone explain in comments???*\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nreturn collections.Counter(nums).most_common()[0][0]\\n```\n```\\nf = open(\"user.out\", \\'w\\')\\nfor line in stdin:\\n    ans = c = 0\\n    for v in map(int, line.rstrip()[1:-1].split(\\',\\')):\\n        if c == 0: ans = v\\n        if ans == v: c += 1\\n        else: c -= 1\\n    print(ans, file=f)\\nexit(0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2255256,
                "title": "python-o-n-time-o-1-space-solution",
                "content": "Intuition\\n\\nIf we had some way of counting instances of the majority element as +1+1 and instances of any other element as -1\\u22121, summing them would make it obvious that the majority element is indeed the majority element.\\n\\nAlgorithm\\n\\nEssentially, what Boyer-Moore does is look for a suffix sufsuf of nums where suf[0]suf[0] is the majority element in that suffix. To do this, we maintain a count, which is incremented whenever we see an instance of our current candidate for majority element and decremented whenever we see anything else. Whenever count equals 0, we effectively forget about everything in nums up to the current index and consider the current number as the candidate for majority element. It is not immediately obvious why we can get away with forgetting prefixes of nums - consider the following examples (pipes are inserted to separate runs of nonzero count).\\n\\n[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]\\n\\nHere, the 7 at index 0 is selected to be the first candidate for majority element. count will eventually reach 0 after index 5 is processed, so the 5 at index 6 will be the next candidate. In this case, 7 is the true majority element, so by disregarding this prefix, we are ignoring an equal number of majority and minority elements - therefore, 7 will still be the majority element in the suffix formed by throwing away the first prefix.\\n\\n[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 5, 5, 5, 5]\\n\\nNow, the majority element is 5 (we changed the last run of the array from 7s to 5s), but our first candidate is still 7. In this case, our candidate is not the true majority element, but we still cannot discard more majority elements than minority elements (this would imply that count could reach -1 before we reassign candidate, which is obviously false).\\n\\nTherefore, given that it is impossible (in both cases) to discard more majority elements than minority elements, we are safe in discarding the prefix and attempting to recursively solve the majority element problem for the suffix. Eventually, a suffix will be found for which count does not hit 0, and the majority element of that suffix will necessarily be the same as the majority element of the overall array.\\ncredits: leetcode solution\\n```\\nclass Solution:\\n    def majorityElement(self, nums):\\n        count = 0\\n        candidate = None\\n\\n        for num in nums:\\n            if count == 0:\\n                candidate = num\\n                count +=1\\n                \\n            elif candidate == num:\\n                count +=1\\n            else:\\n                count -=1\\n                \\n\\n        return candidate\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def majorityElement(self, nums):\\n        count = 0\\n        candidate = None\\n\\n        for num in nums:\\n            if count == 0:\\n                candidate = num\\n                count +=1\\n                \\n            elif candidate == num:\\n                count +=1\\n            else:\\n                count -=1\\n                \\n\\n        return candidate\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860414,
                "title": "majority-element-two-approaches-voting-algorithm-and-hashmap",
                "content": "Approach 1: (Optimised Approach) Boyer Moore\\'s Voting Algorithm\\n\\n```\\n\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        \\n        int val=nums[0];\\n        int count=1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            if(val==nums[i]){\\n                count++;\\n            }else{\\n                count--;\\n            }\\n            \\n            if(count==0){\\n                val=nums[i];\\n                count=1;\\n            }\\n        }\\n        \\n        int flag=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==val){\\n                flag++;\\n                \\n            }\\n        }\\n        \\n    if(flag>nums.length/2) return val;\\n        return -1;\\n    }\\n}\\n\\n```\\nStep -1: Assume that the element at index \\'0-th\\' position is a potential candidate for the majority element. Initialise the variable \\'count\\' as 1.\\n\\nStep -2: Traverse the array and check if the next element is equal to the one we have assumed as the potential candidate for the majority element. If the element is same, incremenet the count by 1, else decrement the count by 1.\\n\\nStep -3: If count becomes 0, then assume the element at the \\'i-th\\' index as the new possible candidate for the majority element and initialise the count as 1.\\n\\nStep -4: Traverse the array once more to confirm whether are assumed majority element is the actual one or not.\\n\\n\\nApproach 2: Using HashMaps\\n\\n```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        \\n        HashMap<Integer, Integer> map= new HashMap<Integer, Integer>();\\n        int maxKey=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i],map.get(nums[i])+1);\\n            }else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        \\n        int maxValueInMap=Collections.max(map.values());\\n    \\n      \\n        \\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {  \\n            if (entry.getValue()==maxValueInMap) {\\n                maxKey=entry.getKey();     \\n            }\\n        }\\n        \\n        return maxKey;\\n        \\n    }\\n}\\n```\\n\\nDeclare a hashmap of <Integer, Integer> type and keep on storing the values and their frequenecy as you encounter them.\\nFinally, find the key with maximum frequency value and return in. \\n\\nNOTE: use Map.Entry<Integer, Integer> entry over Entry<Integer, Integer> to avoid running into exceptions.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        \\n        int val=nums[0];\\n        int count=1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            if(val==nums[i]){\\n                count++;\\n            }else{\\n                count--;\\n            }\\n            \\n            if(count==0){\\n                val=nums[i];\\n                count=1;\\n            }\\n        }\\n        \\n        int flag=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==val){\\n                flag++;\\n                \\n            }\\n        }\\n        \\n    if(flag>nums.length/2) return val;\\n        return -1;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        \\n        HashMap<Integer, Integer> map= new HashMap<Integer, Integer>();\\n        int maxKey=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i],map.get(nums[i])+1);\\n            }else{\\n                map.put(nums[i],1);\\n            }\\n        }\\n        \\n        int maxValueInMap=Collections.max(map.values());\\n    \\n      \\n        \\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {  \\n            if (entry.getValue()==maxValueInMap) {\\n                maxKey=entry.getKey();     \\n            }\\n        }\\n        \\n        return maxKey;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788095,
                "title": "o-1-space-two-line-code-c-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        return nums[n/2];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        return nums[n/2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672165,
                "title": "0ms-and-2-line-solution-java",
                "content": "```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        return nums[n/2];\\n    }\\n}\\n```\\n\\nThe Approach is that first sort the array and return majority element is the element that appears more than **[n / 2] times**. That the simple approach , **here n denotes the length of the array.**\\n\\n**Example - [3,2,3] here the n is \\'2\\' so if we divide it by \\'2\\' we get \\'1\\' , so it denotes the majority element is that which appears more than \\'1\\' which is \\'3\\' , why not \\'2\\' because \\'2\\' appears only one time**\\n\\n**Complexities:**\\nTime Complexity - O(nlogn) which is for sorting the array.\\nSpace Complexity - O(1)\\n\\nPlease **UPVOTE** if you understand the solution\\nThank You \\uD83D\\uDE0A\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        return nums[n/2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1565753,
                "title": "java-100-easy-simple-real-life-example",
                "content": "```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        \\n        // Assume, there are many persons with same face\\n        // And one person (side person) is taking care of a countBox of person name \\n        // If same person comes, he increases the count\\n        // Otherwise decreases the count\\n        \\n        // Understand it this way,\\n        // [3,2,3] == Mohan, Sohan, Mohan\\n        \\n        // All three of them are standing in a Queue\\n        // If CountBox is Empty, he adds the first person name ticket into the Box\\n        // If he finds same person again, he adds another same ticket\\n        \\n        // **** -> When he finds a different person, he doesn\\'t add different name ticket\\n        // He actually removes a ticket from the box\\n        \\n        // Logic : When same person comes, count increases\\n        // When another person comes, count decreases\\n        // This way, the person which has the majority will last in the countBox\\n        \\n        int countBox = 0;\\n        int person = 0;\\n        \\n        for(int num : nums){\\n            \\n            if(countBox == 0){ // countBox is Empty\\n                person = num; // First Person in the Queue will be added to the Box\\n            }\\n            \\n            if(num == person){// If the same person comes again\\n                countBox++;\\n            }else{\\n                countBox--; // If different person comes\\n            }\\n        }\\n        return person; // Last Person who remains in the box\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        \\n        // Assume, there are many persons with same face\\n        // And one person (side person) is taking care of a countBox of person name \\n        // If same person comes, he increases the count\\n        // Otherwise decreases the count\\n        \\n        // Understand it this way,\\n        // [3,2,3] == Mohan, Sohan, Mohan\\n        \\n        // All three of them are standing in a Queue\\n        // If CountBox is Empty, he adds the first person name ticket into the Box\\n        // If he finds same person again, he adds another same ticket\\n        \\n        // **** -> When he finds a different person, he doesn\\'t add different name ticket\\n        // He actually removes a ticket from the box\\n        \\n        // Logic : When same person comes, count increases\\n        // When another person comes, count decreases\\n        // This way, the person which has the majority will last in the countBox\\n        \\n        int countBox = 0;\\n        int person = 0;\\n        \\n        for(int num : nums){\\n            \\n            if(countBox == 0){ // countBox is Empty\\n                person = num; // First Person in the Queue will be added to the Box\\n            }\\n            \\n            if(num == person){// If the same person comes again\\n                countBox++;\\n            }else{\\n                countBox--; // If different person comes\\n            }\\n        }\\n        return person; // Last Person who remains in the box\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487007,
                "title": "java-easy-solutions-3-methods-o-n-2-o-nlogn-o-n",
                "content": "Brute Force: O(n^2) 900ms:Time Complexity. O(1) space complexity\\n```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int val=nums[i];\\n            int count=1;\\n\\t\\t\\t//Counting the number of times the same number appears:\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[j]==val)\\n                {\\n                    count++;\\n                }\\n            }\\n\\t\\t\\t//Checking if it\\'s greater than n/2:\\n            if(count>(nums.length/2))\\n            {\\n                return val;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\nHashMap:O(nlogn) : 12ms O(nlogn) same logic as before\\n```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        int n=nums.length;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int val=nums[i];\\n            if(hm.containsKey(val))\\n            {\\n                hm.put(val,hm.get(val)+1);\\n                if(hm.get(val)>(n/2))\\n                {\\n                    return val;\\n                }\\n            }\\n            else\\n            {\\n                hm.put(val,1);\\n            }\\n        }\\n        return nums[0];\\n    }\\n}\\n```\\n\\nMoore\\'s Voting Algorith: O(n) 1 ms 100% faster:\\n```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        int count=0;\\n        int ele=0;\\n        int i=0;\\n\\t\\t//Travelling over the array keep a \"count\"\\n\\t\\t//and an \"element\" if the \"count==0\" then update the element and match if the next \"i\" \\n\\t\\t//is \"== element\" if yes then \"count++\" else \"count--\" \\n\\t\\t//and the nums[i] which is highest appearing will be in the element.\\n\\t\\t//return element.\\n        while(i<nums.length)\\n        {\\n            if(count==0)\\n            {\\n                ele=nums[i];\\n            }\\n            if(ele==nums[i])\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                count--;\\n            }\\n            i++;\\n        }\\n        return ele;\\n    }\\n}\\n```\\n\\nUpvote if usefull.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int val=nums[i];\\n            int count=1;\\n\\t\\t\\t//Counting the number of times the same number appears:\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[j]==val)\\n                {\\n                    count++;\\n                }\\n            }\\n\\t\\t\\t//Checking if it\\'s greater than n/2:\\n            if(count>(nums.length/2))\\n            {\\n                return val;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        int n=nums.length;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int val=nums[i];\\n            if(hm.containsKey(val))\\n            {\\n                hm.put(val,hm.get(val)+1);\\n                if(hm.get(val)>(n/2))\\n                {\\n                    return val;\\n                }\\n            }\\n            else\\n            {\\n                hm.put(val,1);\\n            }\\n        }\\n        return nums[0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        int count=0;\\n        int ele=0;\\n        int i=0;\\n\\t\\t//Travelling over the array keep a \"count\"\\n\\t\\t//and an \"element\" if the \"count==0\" then update the element and match if the next \"i\" \\n\\t\\t//is \"== element\" if yes then \"count++\" else \"count--\" \\n\\t\\t//and the nums[i] which is highest appearing will be in the element.\\n\\t\\t//return element.\\n        while(i<nums.length)\\n        {\\n            if(count==0)\\n            {\\n                ele=nums[i];\\n            }\\n            if(ele==nums[i])\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                count--;\\n            }\\n            i++;\\n        }\\n        return ele;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397510,
                "title": "c-solution-fastest-all-methods",
                "content": "METHOD1: Boyer-Moore Algo  (T(n) = O(n) and S(n) = O(1))\\n\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        // Boyer-Moore Algo\\n        int candidate = INT_MIN, count = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (!count) candidate = nums[i];\\n            count += nums[i] == candidate ? 1 : -1;\\n        }\\n        return candidate;\\n    }\\n};\\n```\\n\\nMETHOD2: Sorting  (T(n) = O(nlgn) and S(n) = O(1))\\n\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        return nums[nums.size() / 2];\\n    }\\n};\\n```\\n\\nMETHOD3: Hashmap  (T(n) = S(n) = O(n))\\n\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int majorFreq = nums.size() & 1 ? nums.size() / 2 + 1 : nums.size() / 2;\\n        unordered_map<int, int> freq;\\n        for (auto &num : nums)\\n            if (++freq[num] == majorFreq)\\n                return num;\\n        return -1;\\n    }\\n};\\n```\\n\\nMETHOD4: Divide and Conquer (T(n) = O(nlgn) and S(n) = O(lgn))\\n\\n```\\nclass Solution {\\npublic:\\n    int findFreq(vector<int> &nums, int ele, int l = 0, int r = -1) {\\n        int freq = 0;\\n        r = r < 0 ? nums.size() - 1 : r;\\n        for (int i = l; i <= r; i++)\\n            if (nums[i] == ele) freq++;\\n        return freq;\\n    }\\n    int majorityElementRec(vector<int> &nums, int l, int r) {\\n        if (l == r) return nums[l];\\n        int mid = (r - l) / 2 + l;\\n        int left = majorityElementRec(nums, l, mid);\\n        int right = majorityElementRec(nums, mid + 1, r);\\n        if (left == right) return left;\\n        int leftFreq = findFreq(nums, left, l, r);\\n        int rightFreq = findFreq(nums, right, l, r);\\n        return  leftFreq > rightFreq ? left : right;\\n    }\\n    int majorityElement(vector<int>& nums) {\\n        return majorityElementRec(nums, 0, nums.size() - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Divide and Conquer",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        // Boyer-Moore Algo\\n        int candidate = INT_MIN, count = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (!count) candidate = nums[i];\\n            count += nums[i] == candidate ? 1 : -1;\\n        }\\n        return candidate;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        return nums[nums.size() / 2];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int majorFreq = nums.size() & 1 ? nums.size() / 2 + 1 : nums.size() / 2;\\n        unordered_map<int, int> freq;\\n        for (auto &num : nums)\\n            if (++freq[num] == majorFreq)\\n                return num;\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findFreq(vector<int> &nums, int ele, int l = 0, int r = -1) {\\n        int freq = 0;\\n        r = r < 0 ? nums.size() - 1 : r;\\n        for (int i = l; i <= r; i++)\\n            if (nums[i] == ele) freq++;\\n        return freq;\\n    }\\n    int majorityElementRec(vector<int> &nums, int l, int r) {\\n        if (l == r) return nums[l];\\n        int mid = (r - l) / 2 + l;\\n        int left = majorityElementRec(nums, l, mid);\\n        int right = majorityElementRec(nums, mid + 1, r);\\n        if (left == right) return left;\\n        int leftFreq = findFreq(nums, left, l, r);\\n        int rightFreq = findFreq(nums, right, l, r);\\n        return  leftFreq > rightFreq ? left : right;\\n    }\\n    int majorityElement(vector<int>& nums) {\\n        return majorityElementRec(nums, 0, nums.size() - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384438,
                "title": "moore-s-voting-algorithm-o-n-time-o-1-space-optimal-solution-in-c",
                "content": "Intuition behind the algorithm is to cancel out the majority element  by the minority elements till its occurence dominates the other elements. Since, we are sure that a majority element exists, the algorithm works perfectly.\\n\\n*  Initialize a count variable with 0.\\n*  Iterate through the array.  \\n\\t* If count is 0 at any stage then that element is a potential candidate for majority element.\\n\\t* Increase count by 1 if array element is equal to candidate or else decrease count by 1.\\n* The candidate element is the final answer.\\n\\n```\\nint majorityElement(vector<int>& nums) {\\n        int candidate;\\n\\t\\tint n = nums.size();\\n\\t\\tint count = 0;\\n        for(int i=0; i<n;  i++) {\\n            if(count == 0)\\n                candidate = nums[i];\\n            if(nums[i] == candidate)\\n                count++;\\n            else\\n                count--;\\n        }\\n        return candidate;\\n}\\n```\\n",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nint majorityElement(vector<int>& nums) {\\n        int candidate;\\n\\t\\tint n = nums.size();\\n\\t\\tint count = 0;\\n        for(int i=0; i<n;  i++) {\\n            if(count == 0)\\n                candidate = nums[i];\\n            if(nums[i] == candidate)\\n                count++;\\n            else\\n                count--;\\n        }\\n        return candidate;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1336949,
                "title": "c-brute-force-better-optimal-moore-s-voting-algorithm-time-o-n-auxiliary-space-o-1",
                "content": "\\n**Brute Force Solution : Time O(NlogN) & Auxiliary Space O(1)**\\n\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        // Brute Force Solution\\n        sort(nums.begin(),nums.end());\\n        return nums[nums.size()/2];\\n    }\\n};\\n\\n```\\n\\n**Better Solution : Time O(N) & Auxiliary Space O(N)**\\n\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        // Better Solution\\n        map<int,int> m;\\n        int len=nums.size(), pos;\\n        for(int i=0;i<len;i++){\\n            m[nums[i]]++;\\n        if(m[nums[i]]>(len/2))\\n            pos=i;\\n        }\\n        return nums[pos];\\n    }\\n};\\n```\\n\\n**Optimal Solution : Time O(N) & Auxiliary Space O(1)**\\n\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        // Optimal Solution\\n        // Boyer\\u2013Moore Majority Voting Algorithm\\n        int len=nums.size(), maj=nums[0], count=1;\\n        for(auto i=1;i<len;i++){\\n            if(nums[i]==maj)\\n                count++;\\n            else\\n                count--;\\n            if(count==0){\\n                maj=nums[i];\\n                count=1;\\n            }\\n        }\\n        return maj;\\n    }\\n};\\n```\\n**All suggestions are welcome. Please upvote if you like it. Thank you for reading the post.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        // Brute Force Solution\\n        sort(nums.begin(),nums.end());\\n        return nums[nums.size()/2];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        // Better Solution\\n        map<int,int> m;\\n        int len=nums.size(), pos;\\n        for(int i=0;i<len;i++){\\n            m[nums[i]]++;\\n        if(m[nums[i]]>(len/2))\\n            pos=i;\\n        }\\n        return nums[pos];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        // Optimal Solution\\n        // Boyer\\u2013Moore Majority Voting Algorithm\\n        int len=nums.size(), maj=nums[0], count=1;\\n        for(auto i=1;i<len;i++){\\n            if(nums[i]==maj)\\n                count++;\\n            else\\n                count--;\\n            if(count==0){\\n                maj=nums[i];\\n                count=1;\\n            }\\n        }\\n        return maj;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190351,
                "title": "what-is-the-error-in-the-code",
                "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000000b0 overflowed to 0x601efafafba8 (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\n```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        vector<int> v(nums.size()+1,0);\\n        \\n        for(int i=1;i<v.size();i++)\\n            v[nums[i]]++;\\n        \\n        return *max_element(v.begin(),v.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        vector<int> v(nums.size()+1,0);\\n        \\n        for(int i=1;i<v.size();i++)\\n            v[nums[i]]++;\\n        \\n        return *max_element(v.begin(),v.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028321,
                "title": "short-and-easy-python3-solution-faster-than-98-23",
                "content": "Faster than 98.23% of Python3 online submissions for Majority Element.\\nExplanation:\\nWe are sorting and taking the middle element/middle +1 element because in question it asked us to find majority element is the element that appears more than \\u230An / 2\\u230B times. Which will occur in n/2 for even and for odd it will occur at floor(n/2).\\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return nums[len(nums)//2]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return nums[len(nums)//2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859830,
                "title": "javascript-clean-o-1-space",
                "content": "```javascript\\nvar majorityElement = function(nums) {\\n    let currNum = nums[0], count = 0;\\n    \\n    for(let x of nums) {\\n        if(currNum == x) count++;\\n        else {\\n            count--;\\n            if(!count) {\\n                currNum = x;\\n                count = 1;\\n            }\\n        }\\n    }\\n    return currNum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar majorityElement = function(nums) {\\n    let currNum = nums[0], count = 0;\\n    \\n    for(let x of nums) {\\n        if(currNum == x) count++;\\n        else {\\n            count--;\\n            if(!count) {\\n                currNum = x;\\n                count = 1;\\n            }\\n        }\\n    }\\n    return currNum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 616659,
                "title": "c-one-line-solution-o-n-time",
                "content": "```\\npublic int MajorityElement(int[] nums) =>\\n\\tnums.GroupBy(num => num)\\n\\t\\t.First(group => group.Count() > nums.Length / 2)\\n\\t\\t.Key;\\n```",
                "solutionTags": [],
                "code": "```\\npublic int MajorityElement(int[] nums) =>\\n\\tnums.GroupBy(num => num)\\n\\t\\t.First(group => group.Count() > nums.Length / 2)\\n\\t\\t.Key;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 457064,
                "title": "majority-element",
                "content": "```\\nfunc majorityElement(nums []int) int {\\n\\tsort.Ints(nums)\\n\\treturn nums[len(nums)/2]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc majorityElement(nums []int) int {\\n\\tsort.Ints(nums)\\n\\treturn nums[len(nums)/2]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 452477,
                "title": "one-liner-o-n-log-n-but-concise",
                "content": "If the array were sorted the majority element, by definition, would be in the middle.\\n\\n```js\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar majorityElement = function(nums) {\\n    return nums.sort()[Math.floor(nums.length / 2)];\\n};\\n```\\n\\nThe complexity is not linear though but I\\'d rather got for this solution in case of a small array.\\n\\n**UPD**\\n\\n`Math.floor` is important here. For instance, rounding of `2.5` should be `2` not `3`.",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```js\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar majorityElement = function(nums) {\\n    return nums.sort()[Math.floor(nums.length / 2)];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 177183,
                "title": "c-divide-and-conquer-o-n-solution-4-ms-beats-100",
                "content": "The idea is \\n* Pair up the elements of `nums` arbitrarily, to get `n/2` pairs.\\n* Look at each pair: if the two elements are different, discard both of them; if they are the same, keep just one of them.\\n* Put these \"survived\" element in a new array which must contain the majority element.\\n* Do this over and over again, we can get the majority element.\\n* However, when `n` is odd, we need to pay close attention to the last element in the array, check the frequency of this element, if its frequency is greater than `n/2`, then it is the majority element, done. Otherwise, discard this element.\\n\\nTime complexity: O(N) vs. Space complexity: O(N).\\n\\n```C++\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return nums[0];\\n        if (n % 2 == 1) {\\n            int count = 1;\\n            for (int i = 0; i < n - 1; ++i)\\n                if (nums[n-1] == nums[i])\\n                    ++count;\\n            if (count > n / 2)\\n                return nums[n-1];\\n        }\\n        vector<int> numsTmp;\\n        for (int i = 0; i < n / 2; ++i)\\n            if (nums[2 * i] == nums[2 * i + 1])\\n                numsTmp.push_back(nums[2 * i]);\\n        return majorityElement(numsTmp);\\n    } \\n};\\n```\\n![image](https://assets.leetcode.com/users/jinlibao/image_1538581125.png)\\n",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return nums[0];\\n        if (n % 2 == 1) {\\n            int count = 1;\\n            for (int i = 0; i < n - 1; ++i)\\n                if (nums[n-1] == nums[i])\\n                    ++count;\\n            if (count > n / 2)\\n                return nums[n-1];\\n        }\\n        vector<int> numsTmp;\\n        for (int i = 0; i < n / 2; ++i)\\n            if (nums[2 * i] == nums[2 * i + 1])\\n                numsTmp.push_back(nums[2 * i]);\\n        return majorityElement(numsTmp);\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51790,
                "title": "two-lines-with-c",
                "content": "class Solution {\\n\\npublic:\\n\\n    int majorityElement(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums[nums.size()/2];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n\\n    int majorityElement(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums[nums.size()/2];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 51807,
                "title": "c-16ms-solution-with-explanation",
                "content": "    int majorityElement(int* nums, int numsSize) {\\n        if(numsSize <=0)return NULL;\\n        int cnt = 1,tmp = nums[0];\\n        for(int i=1;i<numsSize;i++){\\n            if(0 == cnt)\\n                 tmp = nums[i];\\n            if(nums[i]==tmp)\\n                 cnt++;\\n            else cnt--;\\n        }\\n    return tmp;}\\n\\nThis problem is called the main element problem, we can use the method of offset. Once found there are two different number in the array, then both delete, until the rest of the number are the same.",
                "solutionTags": [],
                "code": "    int majorityElement(int* nums, int numsSize) {\\n        if(numsSize <=0)return NULL;\\n        int cnt = 1,tmp = nums[0];\\n        for(int i=1;i<numsSize;i++){\\n            if(0 == cnt)\\n                 tmp = nums[i];\\n            if(nums[i]==tmp)\\n                 cnt++;\\n            else cnt--;\\n        }\\n    return tmp;}\\n\\nThis problem is called the main element problem, we can use the method of offset. Once found there are two different number in the array, then both delete, until the rest of the number are the same.",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1570155,
                "content": [
                    {
                        "username": "singhabhay11",
                        "content": "Arrays.sort(nums);\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@cswartzell](/cswartzell) See the last line\\n`Follow-up: Could you solve the problem in linear time and in O(1) space?`"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@tanmayyyj](/tanmayyyj)  Question doesnt mention time complexity at all. The O(n) solutions are pretty trivial, its interesting to think of different ways to do it. "
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "but not the time complexity the question is asking for\\n"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "[@sanon3714](/sanon3714) That is not an valid input for this problem since the majority element is said to be occuring more than n/2 times, here n=8 so 8/2=4 no element occurs more than 4 times. Therefore not a valid input."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "majority element present more than (n / 2) times. .not n/2 times [@Shivang verma](/Shivang_Verma1)"
                    },
                    {
                        "username": "sanon3714",
                        "content": "check for this 1,2,3,4,3,5,5,5\\n"
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "[@nikhila01](/nikhila01)  thankyou so much ,now I understand."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Shivang_Verma1](/Shivang_Verma1) `[1,1,1,2,2,4]` is an invalid input since it has no majority element. The majority element has to appear **more than** `\\u230An / 2\\u230B` times. Here `1` appears **exactly** `\\u230An / 2\\u230B` times."
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "what if arr=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1 "
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "If you\\'re sorting then it\\'s not linear time"
                    },
                    {
                        "username": "jerryy147",
                        "content": "This is genius!"
                    },
                    {
                        "username": "hampuztt",
                        "content": "[@keeganasmith2003](/keeganasmith2003) Even if counting sort was used, it\\'s not O(1) space"
                    },
                    {
                        "username": "bob1123030",
                        "content": "god level code\\n"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Can you not post solutions in the Discussion ... "
                    },
                    {
                        "username": "ParasAtal05",
                        "content": "God level code"
                    },
                    {
                        "username": "Rithym",
                        "content": "God level code\\n"
                    },
                    {
                        "username": "keeganasmith2003",
                        "content": "[@wisegauravmehra](/wisegauravmehra) It is linear if counting sort is used. This is an integer container, so counting sort can be used. "
                    },
                    {
                        "username": "wisegauravmehra",
                        "content": "It\\'s not linear runtime solution."
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/6c81d433-5a1c-412b-ba0c-f08ae95baa9e_1648865936.0360248.jpeg)\\n"
                    },
                    {
                        "username": "k_praphull",
                        "content": "[@nitish07maximus](/nitish07maximus) Have you read question properly, majority element is **more than n/2**"
                    },
                    {
                        "username": "ismaelmiah",
                        "content": "[@nitish07maximus](/nitish07maximus)  This is a wrong test case. as the description says \"You may assume that the majority element always exists in the array.\" You can assume these types of case won\\'t set in judge panel."
                    },
                    {
                        "username": "junjiexu",
                        "content": "[@nitish07maximus](/nitish07maximus) But that\\'s invalid input?"
                    },
                    {
                        "username": "nitish07maximus",
                        "content": "Give wrong result for this input.\\n1,1,1,2,2,3,2,1"
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "codyli520",
                        "content": "if I have [1,1,1,2,2,2], why is 1 the majority number and not 2?"
                    },
                    {
                        "username": "mursalin777",
                        "content": "the majority element must exist more than n/2 times. That\\'s the condition. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@CT-7567](/CT-7567) In my opinion you shouldn't treat the input as a random array. The problem constraints are there for a reason and allow you to come up with more interesting and efficient algorithms, like the follow up of O(N) time and O(1) space.\n\nIf you assume you can be given any inputs then it's a different problem. If a problem asks you to merge two sorted arrays into a single sorted array, would you just pretend the inputs aren't sorted and use a less efficient algorithm? It doesn't make sense."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sagar-pro](/sagar-pro) In my opinion you should approach this question like your input is a random array. it is harder but can be work in every array"
                    },
                    {
                        "username": "sagar-pro",
                        "content": "In your case no majority element because no element exist greater than 3(6/2)times and It is given in question input will always have majority element.\n"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I have problem coming up with the divide and conquer solution.Assume the base case contains only one element, which is the majority element for the base case. Now suppose we have two elements, each one returning from the base case. Say they are 1 2. There is clearly no majority element in this two-element array. If the whole input array is 1 2 2 and you divide the problem into 1 2 and 2. Of course you pick 2 in the right half. But what to pick in the left half?"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "it telling me [2,2]=1 surely should be =2??\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "I think I had a similar problem its telling me [2,2]=1, which makes no sense it should be 2 surely??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Kalyan19111999](/Kalyan19111999) You\\'re right in general, but we\\'re specifically talking about a divide and conquer solution.\\n\\nYou break up an array like `[1, 2, 2]` into subproblems such as `[1, 2]` and `[2]`. Even though `[1, 2]` doesn\\'t have a majority element you still have to return some value from the subproblem. That\\'s what the original question was about: what do you return in that case?"
                    },
                    {
                        "username": "Kalyan19111999",
                        "content": "[@nikhila01](/nikhila01)  I\\'m not quite sure if this case of length of ```nums``` being 2 with both elements being different comes up because, according to the problem description \"You may assume that the majority element always exists in the array\" which can only happen if both elements are the same e.g: [1,1] or [2,2]. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@himanshug9119](/himanshug9119) Majority is defined as _more than_ `floor(n / 2)` occurrences. If `n == 2` then `floor(n / 2) = 1` and no element out of 1 and 2 occurs _more than_ one time in `[1,2]`. So there isn't a majority.\n\n----\n\nAnyway, the answer to the original question is that for `[1,2]` you split it into `[1]` and `[2]`. Then `1` is the majority element on the left and `2` is the majority element on the right as per the base case. Now we have to combine the answers.\n\nWhat LeetCode's official solution does is this: Since the left and right subproblems don't agree on the majority element, you have to count the occurrences of `1` and `2` in the combined subarray. Whichever occurs more times is the majority. Here, both occur _one_ time in `[1,2]`, so it arbitrarily returns one of the elements as the majority. Let's pick the left to make the example more interesting, although LeetCode's solution actually returns the right if the counts are equal.\n\nThen when we combine `[1,2]` and `[2]` we got `1` on the left and `2` on the right. Again, they don't agree so we have to count occurrences of `1` and `2` in `[1,2,2]`. Now `2` wins so that's our answer."
                    },
                    {
                        "username": "himanshug9119",
                        "content": "You are saying in length 2 array there is no majority element why ?\\nYes there is also a majority element first one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "All those upvotes are for sure done by nerds who used either an extra O(n) space or extra time complexity which maybe n^2 or nlogn.  \nBut guys be honest did anyone solve it O(n) time and O(1) space. who has solved it like this ? \nI'm here sitting for an hour to figure out this."
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "[@emengel](/emengel) There is no O(n) sorting algorithm"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "hashing table algo"
                    },
                    {
                        "username": "leeyanleryan",
                        "content": "```\\nclass Solution \\n{\\n    public int majorityElement(int[] nums) \\n    {\\n        int count = 0;\\n        int dom = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (count == 0)\\n            {\\n                dom = nums[i];\\n                count++;\\n            }\\n            else if (dom != nums[i])\\n            {\\n                count--;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return dom;\\n    }\\n}\\n```\\n\\nThis is my solution for O(n) time and O(1) space."
                    },
                    {
                        "username": "emengel",
                        "content": "Try using an O(n) sorting algorithm that you can perform in-place (there\\'s only one that I know of). You\\'ll have to implement your own, since python\\'s sort() runs in n*log(n) time. You\\'ll find that a solution using the O(n) algorithm actually performs worse than the n*log(n) sorts. Determining the conditions under which this remains true is a fantastic exercise in complexity analysis."
                    },
                    {
                        "username": "TheOnix",
                        "content": "This is a stupid problem that only tests that you know the solution, not your problem-solving skills"
                    },
                    {
                        "username": "FindIshita",
                        "content": "moore\\'s voting algo will be helpful"
                    },
                    {
                        "username": "hanhongsun",
                        "content": "I found nobody using bit-Operation for this question.\\n\\nI will try make up a O(n) time bit operation solution. \\n\\n**No** Boyer-Moore Majority Vote Algorithm \\n**No** Hashing table"
                    },
                    {
                        "username": "simonrouse9461",
                        "content": "[@Saketyadav](/Saketyadav) This does not have linear time. It\\'s O(n log n)"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "[@mdas95](/mdas95) Arrays.sort(nums);\\nreturn nums[nums.length/2];  try this one\\n"
                    },
                    {
                        "username": "mdas95",
                        "content": "tell me more I am all ears. \\nby the way[2 2 2 1 1 1 3 3] will it solve the this set of data. I am getting majority as 3 which is not the case. Since this has no majority.\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/majority-element/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** HashMap\n\n  \n**Approach 3:** Sorting\n\n  \n**Approach 4:** Randomization\n\n  \n**Approach 5:** Divide and Conquer\n\n  \n**Approach 6:** Boyer-Moore Voting Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sofs1",
                        "content": "Why did they put this problem under \"Bit Manipulation\" when none of the 6 solutions use bit operators?"
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "I don\\'t understand why people are sorting and returning the middle element. Although it is a valid solution, the follow-up of the question is asking us to solve the problem in Linear time and not O(nlogn) time. "
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Moore\\'s Voting Algorithm Explained in Super Simple efficient way!! \\nLink : https://leetcode.com/problems/majority-element/solutions/3015428/c-moore-s-voting-algorithm-explained-in-super-simple-fast-way/ \\n\\n \\n"
                    }
                ]
            },
            {
                "id": 1570835,
                "content": [
                    {
                        "username": "singhabhay11",
                        "content": "Arrays.sort(nums);\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@cswartzell](/cswartzell) See the last line\\n`Follow-up: Could you solve the problem in linear time and in O(1) space?`"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@tanmayyyj](/tanmayyyj)  Question doesnt mention time complexity at all. The O(n) solutions are pretty trivial, its interesting to think of different ways to do it. "
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "but not the time complexity the question is asking for\\n"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "[@sanon3714](/sanon3714) That is not an valid input for this problem since the majority element is said to be occuring more than n/2 times, here n=8 so 8/2=4 no element occurs more than 4 times. Therefore not a valid input."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "majority element present more than (n / 2) times. .not n/2 times [@Shivang verma](/Shivang_Verma1)"
                    },
                    {
                        "username": "sanon3714",
                        "content": "check for this 1,2,3,4,3,5,5,5\\n"
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "[@nikhila01](/nikhila01)  thankyou so much ,now I understand."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Shivang_Verma1](/Shivang_Verma1) `[1,1,1,2,2,4]` is an invalid input since it has no majority element. The majority element has to appear **more than** `\\u230An / 2\\u230B` times. Here `1` appears **exactly** `\\u230An / 2\\u230B` times."
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "what if arr=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1 "
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "If you\\'re sorting then it\\'s not linear time"
                    },
                    {
                        "username": "jerryy147",
                        "content": "This is genius!"
                    },
                    {
                        "username": "hampuztt",
                        "content": "[@keeganasmith2003](/keeganasmith2003) Even if counting sort was used, it\\'s not O(1) space"
                    },
                    {
                        "username": "bob1123030",
                        "content": "god level code\\n"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Can you not post solutions in the Discussion ... "
                    },
                    {
                        "username": "ParasAtal05",
                        "content": "God level code"
                    },
                    {
                        "username": "Rithym",
                        "content": "God level code\\n"
                    },
                    {
                        "username": "keeganasmith2003",
                        "content": "[@wisegauravmehra](/wisegauravmehra) It is linear if counting sort is used. This is an integer container, so counting sort can be used. "
                    },
                    {
                        "username": "wisegauravmehra",
                        "content": "It\\'s not linear runtime solution."
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/6c81d433-5a1c-412b-ba0c-f08ae95baa9e_1648865936.0360248.jpeg)\\n"
                    },
                    {
                        "username": "k_praphull",
                        "content": "[@nitish07maximus](/nitish07maximus) Have you read question properly, majority element is **more than n/2**"
                    },
                    {
                        "username": "ismaelmiah",
                        "content": "[@nitish07maximus](/nitish07maximus)  This is a wrong test case. as the description says \"You may assume that the majority element always exists in the array.\" You can assume these types of case won\\'t set in judge panel."
                    },
                    {
                        "username": "junjiexu",
                        "content": "[@nitish07maximus](/nitish07maximus) But that\\'s invalid input?"
                    },
                    {
                        "username": "nitish07maximus",
                        "content": "Give wrong result for this input.\\n1,1,1,2,2,3,2,1"
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "codyli520",
                        "content": "if I have [1,1,1,2,2,2], why is 1 the majority number and not 2?"
                    },
                    {
                        "username": "mursalin777",
                        "content": "the majority element must exist more than n/2 times. That\\'s the condition. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@CT-7567](/CT-7567) In my opinion you shouldn't treat the input as a random array. The problem constraints are there for a reason and allow you to come up with more interesting and efficient algorithms, like the follow up of O(N) time and O(1) space.\n\nIf you assume you can be given any inputs then it's a different problem. If a problem asks you to merge two sorted arrays into a single sorted array, would you just pretend the inputs aren't sorted and use a less efficient algorithm? It doesn't make sense."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sagar-pro](/sagar-pro) In my opinion you should approach this question like your input is a random array. it is harder but can be work in every array"
                    },
                    {
                        "username": "sagar-pro",
                        "content": "In your case no majority element because no element exist greater than 3(6/2)times and It is given in question input will always have majority element.\n"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I have problem coming up with the divide and conquer solution.Assume the base case contains only one element, which is the majority element for the base case. Now suppose we have two elements, each one returning from the base case. Say they are 1 2. There is clearly no majority element in this two-element array. If the whole input array is 1 2 2 and you divide the problem into 1 2 and 2. Of course you pick 2 in the right half. But what to pick in the left half?"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "it telling me [2,2]=1 surely should be =2??\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "I think I had a similar problem its telling me [2,2]=1, which makes no sense it should be 2 surely??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Kalyan19111999](/Kalyan19111999) You\\'re right in general, but we\\'re specifically talking about a divide and conquer solution.\\n\\nYou break up an array like `[1, 2, 2]` into subproblems such as `[1, 2]` and `[2]`. Even though `[1, 2]` doesn\\'t have a majority element you still have to return some value from the subproblem. That\\'s what the original question was about: what do you return in that case?"
                    },
                    {
                        "username": "Kalyan19111999",
                        "content": "[@nikhila01](/nikhila01)  I\\'m not quite sure if this case of length of ```nums``` being 2 with both elements being different comes up because, according to the problem description \"You may assume that the majority element always exists in the array\" which can only happen if both elements are the same e.g: [1,1] or [2,2]. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@himanshug9119](/himanshug9119) Majority is defined as _more than_ `floor(n / 2)` occurrences. If `n == 2` then `floor(n / 2) = 1` and no element out of 1 and 2 occurs _more than_ one time in `[1,2]`. So there isn't a majority.\n\n----\n\nAnyway, the answer to the original question is that for `[1,2]` you split it into `[1]` and `[2]`. Then `1` is the majority element on the left and `2` is the majority element on the right as per the base case. Now we have to combine the answers.\n\nWhat LeetCode's official solution does is this: Since the left and right subproblems don't agree on the majority element, you have to count the occurrences of `1` and `2` in the combined subarray. Whichever occurs more times is the majority. Here, both occur _one_ time in `[1,2]`, so it arbitrarily returns one of the elements as the majority. Let's pick the left to make the example more interesting, although LeetCode's solution actually returns the right if the counts are equal.\n\nThen when we combine `[1,2]` and `[2]` we got `1` on the left and `2` on the right. Again, they don't agree so we have to count occurrences of `1` and `2` in `[1,2,2]`. Now `2` wins so that's our answer."
                    },
                    {
                        "username": "himanshug9119",
                        "content": "You are saying in length 2 array there is no majority element why ?\\nYes there is also a majority element first one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "All those upvotes are for sure done by nerds who used either an extra O(n) space or extra time complexity which maybe n^2 or nlogn.  \nBut guys be honest did anyone solve it O(n) time and O(1) space. who has solved it like this ? \nI'm here sitting for an hour to figure out this."
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "[@emengel](/emengel) There is no O(n) sorting algorithm"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "hashing table algo"
                    },
                    {
                        "username": "leeyanleryan",
                        "content": "```\\nclass Solution \\n{\\n    public int majorityElement(int[] nums) \\n    {\\n        int count = 0;\\n        int dom = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (count == 0)\\n            {\\n                dom = nums[i];\\n                count++;\\n            }\\n            else if (dom != nums[i])\\n            {\\n                count--;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return dom;\\n    }\\n}\\n```\\n\\nThis is my solution for O(n) time and O(1) space."
                    },
                    {
                        "username": "emengel",
                        "content": "Try using an O(n) sorting algorithm that you can perform in-place (there\\'s only one that I know of). You\\'ll have to implement your own, since python\\'s sort() runs in n*log(n) time. You\\'ll find that a solution using the O(n) algorithm actually performs worse than the n*log(n) sorts. Determining the conditions under which this remains true is a fantastic exercise in complexity analysis."
                    },
                    {
                        "username": "TheOnix",
                        "content": "This is a stupid problem that only tests that you know the solution, not your problem-solving skills"
                    },
                    {
                        "username": "FindIshita",
                        "content": "moore\\'s voting algo will be helpful"
                    },
                    {
                        "username": "hanhongsun",
                        "content": "I found nobody using bit-Operation for this question.\\n\\nI will try make up a O(n) time bit operation solution. \\n\\n**No** Boyer-Moore Majority Vote Algorithm \\n**No** Hashing table"
                    },
                    {
                        "username": "simonrouse9461",
                        "content": "[@Saketyadav](/Saketyadav) This does not have linear time. It\\'s O(n log n)"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "[@mdas95](/mdas95) Arrays.sort(nums);\\nreturn nums[nums.length/2];  try this one\\n"
                    },
                    {
                        "username": "mdas95",
                        "content": "tell me more I am all ears. \\nby the way[2 2 2 1 1 1 3 3] will it solve the this set of data. I am getting majority as 3 which is not the case. Since this has no majority.\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/majority-element/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** HashMap\n\n  \n**Approach 3:** Sorting\n\n  \n**Approach 4:** Randomization\n\n  \n**Approach 5:** Divide and Conquer\n\n  \n**Approach 6:** Boyer-Moore Voting Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sofs1",
                        "content": "Why did they put this problem under \"Bit Manipulation\" when none of the 6 solutions use bit operators?"
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "I don\\'t understand why people are sorting and returning the middle element. Although it is a valid solution, the follow-up of the question is asking us to solve the problem in Linear time and not O(nlogn) time. "
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Moore\\'s Voting Algorithm Explained in Super Simple efficient way!! \\nLink : https://leetcode.com/problems/majority-element/solutions/3015428/c-moore-s-voting-algorithm-explained-in-super-simple-fast-way/ \\n\\n \\n"
                    }
                ]
            },
            {
                "id": 1571372,
                "content": [
                    {
                        "username": "singhabhay11",
                        "content": "Arrays.sort(nums);\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@cswartzell](/cswartzell) See the last line\\n`Follow-up: Could you solve the problem in linear time and in O(1) space?`"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@tanmayyyj](/tanmayyyj)  Question doesnt mention time complexity at all. The O(n) solutions are pretty trivial, its interesting to think of different ways to do it. "
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "but not the time complexity the question is asking for\\n"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "[@sanon3714](/sanon3714) That is not an valid input for this problem since the majority element is said to be occuring more than n/2 times, here n=8 so 8/2=4 no element occurs more than 4 times. Therefore not a valid input."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "majority element present more than (n / 2) times. .not n/2 times [@Shivang verma](/Shivang_Verma1)"
                    },
                    {
                        "username": "sanon3714",
                        "content": "check for this 1,2,3,4,3,5,5,5\\n"
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "[@nikhila01](/nikhila01)  thankyou so much ,now I understand."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Shivang_Verma1](/Shivang_Verma1) `[1,1,1,2,2,4]` is an invalid input since it has no majority element. The majority element has to appear **more than** `\\u230An / 2\\u230B` times. Here `1` appears **exactly** `\\u230An / 2\\u230B` times."
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "what if arr=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1 "
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "If you\\'re sorting then it\\'s not linear time"
                    },
                    {
                        "username": "jerryy147",
                        "content": "This is genius!"
                    },
                    {
                        "username": "hampuztt",
                        "content": "[@keeganasmith2003](/keeganasmith2003) Even if counting sort was used, it\\'s not O(1) space"
                    },
                    {
                        "username": "bob1123030",
                        "content": "god level code\\n"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Can you not post solutions in the Discussion ... "
                    },
                    {
                        "username": "ParasAtal05",
                        "content": "God level code"
                    },
                    {
                        "username": "Rithym",
                        "content": "God level code\\n"
                    },
                    {
                        "username": "keeganasmith2003",
                        "content": "[@wisegauravmehra](/wisegauravmehra) It is linear if counting sort is used. This is an integer container, so counting sort can be used. "
                    },
                    {
                        "username": "wisegauravmehra",
                        "content": "It\\'s not linear runtime solution."
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/6c81d433-5a1c-412b-ba0c-f08ae95baa9e_1648865936.0360248.jpeg)\\n"
                    },
                    {
                        "username": "k_praphull",
                        "content": "[@nitish07maximus](/nitish07maximus) Have you read question properly, majority element is **more than n/2**"
                    },
                    {
                        "username": "ismaelmiah",
                        "content": "[@nitish07maximus](/nitish07maximus)  This is a wrong test case. as the description says \"You may assume that the majority element always exists in the array.\" You can assume these types of case won\\'t set in judge panel."
                    },
                    {
                        "username": "junjiexu",
                        "content": "[@nitish07maximus](/nitish07maximus) But that\\'s invalid input?"
                    },
                    {
                        "username": "nitish07maximus",
                        "content": "Give wrong result for this input.\\n1,1,1,2,2,3,2,1"
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "codyli520",
                        "content": "if I have [1,1,1,2,2,2], why is 1 the majority number and not 2?"
                    },
                    {
                        "username": "mursalin777",
                        "content": "the majority element must exist more than n/2 times. That\\'s the condition. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@CT-7567](/CT-7567) In my opinion you shouldn't treat the input as a random array. The problem constraints are there for a reason and allow you to come up with more interesting and efficient algorithms, like the follow up of O(N) time and O(1) space.\n\nIf you assume you can be given any inputs then it's a different problem. If a problem asks you to merge two sorted arrays into a single sorted array, would you just pretend the inputs aren't sorted and use a less efficient algorithm? It doesn't make sense."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sagar-pro](/sagar-pro) In my opinion you should approach this question like your input is a random array. it is harder but can be work in every array"
                    },
                    {
                        "username": "sagar-pro",
                        "content": "In your case no majority element because no element exist greater than 3(6/2)times and It is given in question input will always have majority element.\n"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I have problem coming up with the divide and conquer solution.Assume the base case contains only one element, which is the majority element for the base case. Now suppose we have two elements, each one returning from the base case. Say they are 1 2. There is clearly no majority element in this two-element array. If the whole input array is 1 2 2 and you divide the problem into 1 2 and 2. Of course you pick 2 in the right half. But what to pick in the left half?"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "it telling me [2,2]=1 surely should be =2??\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "I think I had a similar problem its telling me [2,2]=1, which makes no sense it should be 2 surely??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Kalyan19111999](/Kalyan19111999) You\\'re right in general, but we\\'re specifically talking about a divide and conquer solution.\\n\\nYou break up an array like `[1, 2, 2]` into subproblems such as `[1, 2]` and `[2]`. Even though `[1, 2]` doesn\\'t have a majority element you still have to return some value from the subproblem. That\\'s what the original question was about: what do you return in that case?"
                    },
                    {
                        "username": "Kalyan19111999",
                        "content": "[@nikhila01](/nikhila01)  I\\'m not quite sure if this case of length of ```nums``` being 2 with both elements being different comes up because, according to the problem description \"You may assume that the majority element always exists in the array\" which can only happen if both elements are the same e.g: [1,1] or [2,2]. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@himanshug9119](/himanshug9119) Majority is defined as _more than_ `floor(n / 2)` occurrences. If `n == 2` then `floor(n / 2) = 1` and no element out of 1 and 2 occurs _more than_ one time in `[1,2]`. So there isn't a majority.\n\n----\n\nAnyway, the answer to the original question is that for `[1,2]` you split it into `[1]` and `[2]`. Then `1` is the majority element on the left and `2` is the majority element on the right as per the base case. Now we have to combine the answers.\n\nWhat LeetCode's official solution does is this: Since the left and right subproblems don't agree on the majority element, you have to count the occurrences of `1` and `2` in the combined subarray. Whichever occurs more times is the majority. Here, both occur _one_ time in `[1,2]`, so it arbitrarily returns one of the elements as the majority. Let's pick the left to make the example more interesting, although LeetCode's solution actually returns the right if the counts are equal.\n\nThen when we combine `[1,2]` and `[2]` we got `1` on the left and `2` on the right. Again, they don't agree so we have to count occurrences of `1` and `2` in `[1,2,2]`. Now `2` wins so that's our answer."
                    },
                    {
                        "username": "himanshug9119",
                        "content": "You are saying in length 2 array there is no majority element why ?\\nYes there is also a majority element first one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "All those upvotes are for sure done by nerds who used either an extra O(n) space or extra time complexity which maybe n^2 or nlogn.  \nBut guys be honest did anyone solve it O(n) time and O(1) space. who has solved it like this ? \nI'm here sitting for an hour to figure out this."
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "[@emengel](/emengel) There is no O(n) sorting algorithm"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "hashing table algo"
                    },
                    {
                        "username": "leeyanleryan",
                        "content": "```\\nclass Solution \\n{\\n    public int majorityElement(int[] nums) \\n    {\\n        int count = 0;\\n        int dom = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (count == 0)\\n            {\\n                dom = nums[i];\\n                count++;\\n            }\\n            else if (dom != nums[i])\\n            {\\n                count--;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return dom;\\n    }\\n}\\n```\\n\\nThis is my solution for O(n) time and O(1) space."
                    },
                    {
                        "username": "emengel",
                        "content": "Try using an O(n) sorting algorithm that you can perform in-place (there\\'s only one that I know of). You\\'ll have to implement your own, since python\\'s sort() runs in n*log(n) time. You\\'ll find that a solution using the O(n) algorithm actually performs worse than the n*log(n) sorts. Determining the conditions under which this remains true is a fantastic exercise in complexity analysis."
                    },
                    {
                        "username": "TheOnix",
                        "content": "This is a stupid problem that only tests that you know the solution, not your problem-solving skills"
                    },
                    {
                        "username": "FindIshita",
                        "content": "moore\\'s voting algo will be helpful"
                    },
                    {
                        "username": "hanhongsun",
                        "content": "I found nobody using bit-Operation for this question.\\n\\nI will try make up a O(n) time bit operation solution. \\n\\n**No** Boyer-Moore Majority Vote Algorithm \\n**No** Hashing table"
                    },
                    {
                        "username": "simonrouse9461",
                        "content": "[@Saketyadav](/Saketyadav) This does not have linear time. It\\'s O(n log n)"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "[@mdas95](/mdas95) Arrays.sort(nums);\\nreturn nums[nums.length/2];  try this one\\n"
                    },
                    {
                        "username": "mdas95",
                        "content": "tell me more I am all ears. \\nby the way[2 2 2 1 1 1 3 3] will it solve the this set of data. I am getting majority as 3 which is not the case. Since this has no majority.\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/majority-element/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** HashMap\n\n  \n**Approach 3:** Sorting\n\n  \n**Approach 4:** Randomization\n\n  \n**Approach 5:** Divide and Conquer\n\n  \n**Approach 6:** Boyer-Moore Voting Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sofs1",
                        "content": "Why did they put this problem under \"Bit Manipulation\" when none of the 6 solutions use bit operators?"
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "I don\\'t understand why people are sorting and returning the middle element. Although it is a valid solution, the follow-up of the question is asking us to solve the problem in Linear time and not O(nlogn) time. "
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Moore\\'s Voting Algorithm Explained in Super Simple efficient way!! \\nLink : https://leetcode.com/problems/majority-element/solutions/3015428/c-moore-s-voting-algorithm-explained-in-super-simple-fast-way/ \\n\\n \\n"
                    }
                ]
            },
            {
                "id": 1565664,
                "content": [
                    {
                        "username": "singhabhay11",
                        "content": "Arrays.sort(nums);\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@cswartzell](/cswartzell) See the last line\\n`Follow-up: Could you solve the problem in linear time and in O(1) space?`"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@tanmayyyj](/tanmayyyj)  Question doesnt mention time complexity at all. The O(n) solutions are pretty trivial, its interesting to think of different ways to do it. "
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "but not the time complexity the question is asking for\\n"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "[@sanon3714](/sanon3714) That is not an valid input for this problem since the majority element is said to be occuring more than n/2 times, here n=8 so 8/2=4 no element occurs more than 4 times. Therefore not a valid input."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "majority element present more than (n / 2) times. .not n/2 times [@Shivang verma](/Shivang_Verma1)"
                    },
                    {
                        "username": "sanon3714",
                        "content": "check for this 1,2,3,4,3,5,5,5\\n"
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "[@nikhila01](/nikhila01)  thankyou so much ,now I understand."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Shivang_Verma1](/Shivang_Verma1) `[1,1,1,2,2,4]` is an invalid input since it has no majority element. The majority element has to appear **more than** `\\u230An / 2\\u230B` times. Here `1` appears **exactly** `\\u230An / 2\\u230B` times."
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "what if arr=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1 "
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "If you\\'re sorting then it\\'s not linear time"
                    },
                    {
                        "username": "jerryy147",
                        "content": "This is genius!"
                    },
                    {
                        "username": "hampuztt",
                        "content": "[@keeganasmith2003](/keeganasmith2003) Even if counting sort was used, it\\'s not O(1) space"
                    },
                    {
                        "username": "bob1123030",
                        "content": "god level code\\n"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Can you not post solutions in the Discussion ... "
                    },
                    {
                        "username": "ParasAtal05",
                        "content": "God level code"
                    },
                    {
                        "username": "Rithym",
                        "content": "God level code\\n"
                    },
                    {
                        "username": "keeganasmith2003",
                        "content": "[@wisegauravmehra](/wisegauravmehra) It is linear if counting sort is used. This is an integer container, so counting sort can be used. "
                    },
                    {
                        "username": "wisegauravmehra",
                        "content": "It\\'s not linear runtime solution."
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/6c81d433-5a1c-412b-ba0c-f08ae95baa9e_1648865936.0360248.jpeg)\\n"
                    },
                    {
                        "username": "k_praphull",
                        "content": "[@nitish07maximus](/nitish07maximus) Have you read question properly, majority element is **more than n/2**"
                    },
                    {
                        "username": "ismaelmiah",
                        "content": "[@nitish07maximus](/nitish07maximus)  This is a wrong test case. as the description says \"You may assume that the majority element always exists in the array.\" You can assume these types of case won\\'t set in judge panel."
                    },
                    {
                        "username": "junjiexu",
                        "content": "[@nitish07maximus](/nitish07maximus) But that\\'s invalid input?"
                    },
                    {
                        "username": "nitish07maximus",
                        "content": "Give wrong result for this input.\\n1,1,1,2,2,3,2,1"
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "codyli520",
                        "content": "if I have [1,1,1,2,2,2], why is 1 the majority number and not 2?"
                    },
                    {
                        "username": "mursalin777",
                        "content": "the majority element must exist more than n/2 times. That\\'s the condition. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@CT-7567](/CT-7567) In my opinion you shouldn't treat the input as a random array. The problem constraints are there for a reason and allow you to come up with more interesting and efficient algorithms, like the follow up of O(N) time and O(1) space.\n\nIf you assume you can be given any inputs then it's a different problem. If a problem asks you to merge two sorted arrays into a single sorted array, would you just pretend the inputs aren't sorted and use a less efficient algorithm? It doesn't make sense."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sagar-pro](/sagar-pro) In my opinion you should approach this question like your input is a random array. it is harder but can be work in every array"
                    },
                    {
                        "username": "sagar-pro",
                        "content": "In your case no majority element because no element exist greater than 3(6/2)times and It is given in question input will always have majority element.\n"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I have problem coming up with the divide and conquer solution.Assume the base case contains only one element, which is the majority element for the base case. Now suppose we have two elements, each one returning from the base case. Say they are 1 2. There is clearly no majority element in this two-element array. If the whole input array is 1 2 2 and you divide the problem into 1 2 and 2. Of course you pick 2 in the right half. But what to pick in the left half?"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "it telling me [2,2]=1 surely should be =2??\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "I think I had a similar problem its telling me [2,2]=1, which makes no sense it should be 2 surely??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Kalyan19111999](/Kalyan19111999) You\\'re right in general, but we\\'re specifically talking about a divide and conquer solution.\\n\\nYou break up an array like `[1, 2, 2]` into subproblems such as `[1, 2]` and `[2]`. Even though `[1, 2]` doesn\\'t have a majority element you still have to return some value from the subproblem. That\\'s what the original question was about: what do you return in that case?"
                    },
                    {
                        "username": "Kalyan19111999",
                        "content": "[@nikhila01](/nikhila01)  I\\'m not quite sure if this case of length of ```nums``` being 2 with both elements being different comes up because, according to the problem description \"You may assume that the majority element always exists in the array\" which can only happen if both elements are the same e.g: [1,1] or [2,2]. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@himanshug9119](/himanshug9119) Majority is defined as _more than_ `floor(n / 2)` occurrences. If `n == 2` then `floor(n / 2) = 1` and no element out of 1 and 2 occurs _more than_ one time in `[1,2]`. So there isn't a majority.\n\n----\n\nAnyway, the answer to the original question is that for `[1,2]` you split it into `[1]` and `[2]`. Then `1` is the majority element on the left and `2` is the majority element on the right as per the base case. Now we have to combine the answers.\n\nWhat LeetCode's official solution does is this: Since the left and right subproblems don't agree on the majority element, you have to count the occurrences of `1` and `2` in the combined subarray. Whichever occurs more times is the majority. Here, both occur _one_ time in `[1,2]`, so it arbitrarily returns one of the elements as the majority. Let's pick the left to make the example more interesting, although LeetCode's solution actually returns the right if the counts are equal.\n\nThen when we combine `[1,2]` and `[2]` we got `1` on the left and `2` on the right. Again, they don't agree so we have to count occurrences of `1` and `2` in `[1,2,2]`. Now `2` wins so that's our answer."
                    },
                    {
                        "username": "himanshug9119",
                        "content": "You are saying in length 2 array there is no majority element why ?\\nYes there is also a majority element first one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "All those upvotes are for sure done by nerds who used either an extra O(n) space or extra time complexity which maybe n^2 or nlogn.  \nBut guys be honest did anyone solve it O(n) time and O(1) space. who has solved it like this ? \nI'm here sitting for an hour to figure out this."
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "[@emengel](/emengel) There is no O(n) sorting algorithm"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "hashing table algo"
                    },
                    {
                        "username": "leeyanleryan",
                        "content": "```\\nclass Solution \\n{\\n    public int majorityElement(int[] nums) \\n    {\\n        int count = 0;\\n        int dom = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (count == 0)\\n            {\\n                dom = nums[i];\\n                count++;\\n            }\\n            else if (dom != nums[i])\\n            {\\n                count--;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return dom;\\n    }\\n}\\n```\\n\\nThis is my solution for O(n) time and O(1) space."
                    },
                    {
                        "username": "emengel",
                        "content": "Try using an O(n) sorting algorithm that you can perform in-place (there\\'s only one that I know of). You\\'ll have to implement your own, since python\\'s sort() runs in n*log(n) time. You\\'ll find that a solution using the O(n) algorithm actually performs worse than the n*log(n) sorts. Determining the conditions under which this remains true is a fantastic exercise in complexity analysis."
                    },
                    {
                        "username": "TheOnix",
                        "content": "This is a stupid problem that only tests that you know the solution, not your problem-solving skills"
                    },
                    {
                        "username": "FindIshita",
                        "content": "moore\\'s voting algo will be helpful"
                    },
                    {
                        "username": "hanhongsun",
                        "content": "I found nobody using bit-Operation for this question.\\n\\nI will try make up a O(n) time bit operation solution. \\n\\n**No** Boyer-Moore Majority Vote Algorithm \\n**No** Hashing table"
                    },
                    {
                        "username": "simonrouse9461",
                        "content": "[@Saketyadav](/Saketyadav) This does not have linear time. It\\'s O(n log n)"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "[@mdas95](/mdas95) Arrays.sort(nums);\\nreturn nums[nums.length/2];  try this one\\n"
                    },
                    {
                        "username": "mdas95",
                        "content": "tell me more I am all ears. \\nby the way[2 2 2 1 1 1 3 3] will it solve the this set of data. I am getting majority as 3 which is not the case. Since this has no majority.\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/majority-element/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** HashMap\n\n  \n**Approach 3:** Sorting\n\n  \n**Approach 4:** Randomization\n\n  \n**Approach 5:** Divide and Conquer\n\n  \n**Approach 6:** Boyer-Moore Voting Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sofs1",
                        "content": "Why did they put this problem under \"Bit Manipulation\" when none of the 6 solutions use bit operators?"
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "I don\\'t understand why people are sorting and returning the middle element. Although it is a valid solution, the follow-up of the question is asking us to solve the problem in Linear time and not O(nlogn) time. "
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Moore\\'s Voting Algorithm Explained in Super Simple efficient way!! \\nLink : https://leetcode.com/problems/majority-element/solutions/3015428/c-moore-s-voting-algorithm-explained-in-super-simple-fast-way/ \\n\\n \\n"
                    }
                ]
            },
            {
                "id": 1834161,
                "content": [
                    {
                        "username": "singhabhay11",
                        "content": "Arrays.sort(nums);\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@cswartzell](/cswartzell) See the last line\\n`Follow-up: Could you solve the problem in linear time and in O(1) space?`"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@tanmayyyj](/tanmayyyj)  Question doesnt mention time complexity at all. The O(n) solutions are pretty trivial, its interesting to think of different ways to do it. "
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "but not the time complexity the question is asking for\\n"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "[@sanon3714](/sanon3714) That is not an valid input for this problem since the majority element is said to be occuring more than n/2 times, here n=8 so 8/2=4 no element occurs more than 4 times. Therefore not a valid input."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "majority element present more than (n / 2) times. .not n/2 times [@Shivang verma](/Shivang_Verma1)"
                    },
                    {
                        "username": "sanon3714",
                        "content": "check for this 1,2,3,4,3,5,5,5\\n"
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "[@nikhila01](/nikhila01)  thankyou so much ,now I understand."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Shivang_Verma1](/Shivang_Verma1) `[1,1,1,2,2,4]` is an invalid input since it has no majority element. The majority element has to appear **more than** `\\u230An / 2\\u230B` times. Here `1` appears **exactly** `\\u230An / 2\\u230B` times."
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "what if arr=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1 "
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "If you\\'re sorting then it\\'s not linear time"
                    },
                    {
                        "username": "jerryy147",
                        "content": "This is genius!"
                    },
                    {
                        "username": "hampuztt",
                        "content": "[@keeganasmith2003](/keeganasmith2003) Even if counting sort was used, it\\'s not O(1) space"
                    },
                    {
                        "username": "bob1123030",
                        "content": "god level code\\n"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Can you not post solutions in the Discussion ... "
                    },
                    {
                        "username": "ParasAtal05",
                        "content": "God level code"
                    },
                    {
                        "username": "Rithym",
                        "content": "God level code\\n"
                    },
                    {
                        "username": "keeganasmith2003",
                        "content": "[@wisegauravmehra](/wisegauravmehra) It is linear if counting sort is used. This is an integer container, so counting sort can be used. "
                    },
                    {
                        "username": "wisegauravmehra",
                        "content": "It\\'s not linear runtime solution."
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/6c81d433-5a1c-412b-ba0c-f08ae95baa9e_1648865936.0360248.jpeg)\\n"
                    },
                    {
                        "username": "k_praphull",
                        "content": "[@nitish07maximus](/nitish07maximus) Have you read question properly, majority element is **more than n/2**"
                    },
                    {
                        "username": "ismaelmiah",
                        "content": "[@nitish07maximus](/nitish07maximus)  This is a wrong test case. as the description says \"You may assume that the majority element always exists in the array.\" You can assume these types of case won\\'t set in judge panel."
                    },
                    {
                        "username": "junjiexu",
                        "content": "[@nitish07maximus](/nitish07maximus) But that\\'s invalid input?"
                    },
                    {
                        "username": "nitish07maximus",
                        "content": "Give wrong result for this input.\\n1,1,1,2,2,3,2,1"
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "codyli520",
                        "content": "if I have [1,1,1,2,2,2], why is 1 the majority number and not 2?"
                    },
                    {
                        "username": "mursalin777",
                        "content": "the majority element must exist more than n/2 times. That\\'s the condition. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@CT-7567](/CT-7567) In my opinion you shouldn't treat the input as a random array. The problem constraints are there for a reason and allow you to come up with more interesting and efficient algorithms, like the follow up of O(N) time and O(1) space.\n\nIf you assume you can be given any inputs then it's a different problem. If a problem asks you to merge two sorted arrays into a single sorted array, would you just pretend the inputs aren't sorted and use a less efficient algorithm? It doesn't make sense."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sagar-pro](/sagar-pro) In my opinion you should approach this question like your input is a random array. it is harder but can be work in every array"
                    },
                    {
                        "username": "sagar-pro",
                        "content": "In your case no majority element because no element exist greater than 3(6/2)times and It is given in question input will always have majority element.\n"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I have problem coming up with the divide and conquer solution.Assume the base case contains only one element, which is the majority element for the base case. Now suppose we have two elements, each one returning from the base case. Say they are 1 2. There is clearly no majority element in this two-element array. If the whole input array is 1 2 2 and you divide the problem into 1 2 and 2. Of course you pick 2 in the right half. But what to pick in the left half?"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "it telling me [2,2]=1 surely should be =2??\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "I think I had a similar problem its telling me [2,2]=1, which makes no sense it should be 2 surely??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Kalyan19111999](/Kalyan19111999) You\\'re right in general, but we\\'re specifically talking about a divide and conquer solution.\\n\\nYou break up an array like `[1, 2, 2]` into subproblems such as `[1, 2]` and `[2]`. Even though `[1, 2]` doesn\\'t have a majority element you still have to return some value from the subproblem. That\\'s what the original question was about: what do you return in that case?"
                    },
                    {
                        "username": "Kalyan19111999",
                        "content": "[@nikhila01](/nikhila01)  I\\'m not quite sure if this case of length of ```nums``` being 2 with both elements being different comes up because, according to the problem description \"You may assume that the majority element always exists in the array\" which can only happen if both elements are the same e.g: [1,1] or [2,2]. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@himanshug9119](/himanshug9119) Majority is defined as _more than_ `floor(n / 2)` occurrences. If `n == 2` then `floor(n / 2) = 1` and no element out of 1 and 2 occurs _more than_ one time in `[1,2]`. So there isn't a majority.\n\n----\n\nAnyway, the answer to the original question is that for `[1,2]` you split it into `[1]` and `[2]`. Then `1` is the majority element on the left and `2` is the majority element on the right as per the base case. Now we have to combine the answers.\n\nWhat LeetCode's official solution does is this: Since the left and right subproblems don't agree on the majority element, you have to count the occurrences of `1` and `2` in the combined subarray. Whichever occurs more times is the majority. Here, both occur _one_ time in `[1,2]`, so it arbitrarily returns one of the elements as the majority. Let's pick the left to make the example more interesting, although LeetCode's solution actually returns the right if the counts are equal.\n\nThen when we combine `[1,2]` and `[2]` we got `1` on the left and `2` on the right. Again, they don't agree so we have to count occurrences of `1` and `2` in `[1,2,2]`. Now `2` wins so that's our answer."
                    },
                    {
                        "username": "himanshug9119",
                        "content": "You are saying in length 2 array there is no majority element why ?\\nYes there is also a majority element first one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "All those upvotes are for sure done by nerds who used either an extra O(n) space or extra time complexity which maybe n^2 or nlogn.  \nBut guys be honest did anyone solve it O(n) time and O(1) space. who has solved it like this ? \nI'm here sitting for an hour to figure out this."
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "[@emengel](/emengel) There is no O(n) sorting algorithm"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "hashing table algo"
                    },
                    {
                        "username": "leeyanleryan",
                        "content": "```\\nclass Solution \\n{\\n    public int majorityElement(int[] nums) \\n    {\\n        int count = 0;\\n        int dom = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (count == 0)\\n            {\\n                dom = nums[i];\\n                count++;\\n            }\\n            else if (dom != nums[i])\\n            {\\n                count--;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return dom;\\n    }\\n}\\n```\\n\\nThis is my solution for O(n) time and O(1) space."
                    },
                    {
                        "username": "emengel",
                        "content": "Try using an O(n) sorting algorithm that you can perform in-place (there\\'s only one that I know of). You\\'ll have to implement your own, since python\\'s sort() runs in n*log(n) time. You\\'ll find that a solution using the O(n) algorithm actually performs worse than the n*log(n) sorts. Determining the conditions under which this remains true is a fantastic exercise in complexity analysis."
                    },
                    {
                        "username": "TheOnix",
                        "content": "This is a stupid problem that only tests that you know the solution, not your problem-solving skills"
                    },
                    {
                        "username": "FindIshita",
                        "content": "moore\\'s voting algo will be helpful"
                    },
                    {
                        "username": "hanhongsun",
                        "content": "I found nobody using bit-Operation for this question.\\n\\nI will try make up a O(n) time bit operation solution. \\n\\n**No** Boyer-Moore Majority Vote Algorithm \\n**No** Hashing table"
                    },
                    {
                        "username": "simonrouse9461",
                        "content": "[@Saketyadav](/Saketyadav) This does not have linear time. It\\'s O(n log n)"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "[@mdas95](/mdas95) Arrays.sort(nums);\\nreturn nums[nums.length/2];  try this one\\n"
                    },
                    {
                        "username": "mdas95",
                        "content": "tell me more I am all ears. \\nby the way[2 2 2 1 1 1 3 3] will it solve the this set of data. I am getting majority as 3 which is not the case. Since this has no majority.\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/majority-element/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** HashMap\n\n  \n**Approach 3:** Sorting\n\n  \n**Approach 4:** Randomization\n\n  \n**Approach 5:** Divide and Conquer\n\n  \n**Approach 6:** Boyer-Moore Voting Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sofs1",
                        "content": "Why did they put this problem under \"Bit Manipulation\" when none of the 6 solutions use bit operators?"
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "I don\\'t understand why people are sorting and returning the middle element. Although it is a valid solution, the follow-up of the question is asking us to solve the problem in Linear time and not O(nlogn) time. "
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Moore\\'s Voting Algorithm Explained in Super Simple efficient way!! \\nLink : https://leetcode.com/problems/majority-element/solutions/3015428/c-moore-s-voting-algorithm-explained-in-super-simple-fast-way/ \\n\\n \\n"
                    }
                ]
            },
            {
                "id": 1567899,
                "content": [
                    {
                        "username": "singhabhay11",
                        "content": "Arrays.sort(nums);\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@cswartzell](/cswartzell) See the last line\\n`Follow-up: Could you solve the problem in linear time and in O(1) space?`"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@tanmayyyj](/tanmayyyj)  Question doesnt mention time complexity at all. The O(n) solutions are pretty trivial, its interesting to think of different ways to do it. "
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "but not the time complexity the question is asking for\\n"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "[@sanon3714](/sanon3714) That is not an valid input for this problem since the majority element is said to be occuring more than n/2 times, here n=8 so 8/2=4 no element occurs more than 4 times. Therefore not a valid input."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "majority element present more than (n / 2) times. .not n/2 times [@Shivang verma](/Shivang_Verma1)"
                    },
                    {
                        "username": "sanon3714",
                        "content": "check for this 1,2,3,4,3,5,5,5\\n"
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "[@nikhila01](/nikhila01)  thankyou so much ,now I understand."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Shivang_Verma1](/Shivang_Verma1) `[1,1,1,2,2,4]` is an invalid input since it has no majority element. The majority element has to appear **more than** `\\u230An / 2\\u230B` times. Here `1` appears **exactly** `\\u230An / 2\\u230B` times."
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "what if arr=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1 "
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "If you\\'re sorting then it\\'s not linear time"
                    },
                    {
                        "username": "jerryy147",
                        "content": "This is genius!"
                    },
                    {
                        "username": "hampuztt",
                        "content": "[@keeganasmith2003](/keeganasmith2003) Even if counting sort was used, it\\'s not O(1) space"
                    },
                    {
                        "username": "bob1123030",
                        "content": "god level code\\n"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Can you not post solutions in the Discussion ... "
                    },
                    {
                        "username": "ParasAtal05",
                        "content": "God level code"
                    },
                    {
                        "username": "Rithym",
                        "content": "God level code\\n"
                    },
                    {
                        "username": "keeganasmith2003",
                        "content": "[@wisegauravmehra](/wisegauravmehra) It is linear if counting sort is used. This is an integer container, so counting sort can be used. "
                    },
                    {
                        "username": "wisegauravmehra",
                        "content": "It\\'s not linear runtime solution."
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/6c81d433-5a1c-412b-ba0c-f08ae95baa9e_1648865936.0360248.jpeg)\\n"
                    },
                    {
                        "username": "k_praphull",
                        "content": "[@nitish07maximus](/nitish07maximus) Have you read question properly, majority element is **more than n/2**"
                    },
                    {
                        "username": "ismaelmiah",
                        "content": "[@nitish07maximus](/nitish07maximus)  This is a wrong test case. as the description says \"You may assume that the majority element always exists in the array.\" You can assume these types of case won\\'t set in judge panel."
                    },
                    {
                        "username": "junjiexu",
                        "content": "[@nitish07maximus](/nitish07maximus) But that\\'s invalid input?"
                    },
                    {
                        "username": "nitish07maximus",
                        "content": "Give wrong result for this input.\\n1,1,1,2,2,3,2,1"
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "codyli520",
                        "content": "if I have [1,1,1,2,2,2], why is 1 the majority number and not 2?"
                    },
                    {
                        "username": "mursalin777",
                        "content": "the majority element must exist more than n/2 times. That\\'s the condition. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@CT-7567](/CT-7567) In my opinion you shouldn't treat the input as a random array. The problem constraints are there for a reason and allow you to come up with more interesting and efficient algorithms, like the follow up of O(N) time and O(1) space.\n\nIf you assume you can be given any inputs then it's a different problem. If a problem asks you to merge two sorted arrays into a single sorted array, would you just pretend the inputs aren't sorted and use a less efficient algorithm? It doesn't make sense."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sagar-pro](/sagar-pro) In my opinion you should approach this question like your input is a random array. it is harder but can be work in every array"
                    },
                    {
                        "username": "sagar-pro",
                        "content": "In your case no majority element because no element exist greater than 3(6/2)times and It is given in question input will always have majority element.\n"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I have problem coming up with the divide and conquer solution.Assume the base case contains only one element, which is the majority element for the base case. Now suppose we have two elements, each one returning from the base case. Say they are 1 2. There is clearly no majority element in this two-element array. If the whole input array is 1 2 2 and you divide the problem into 1 2 and 2. Of course you pick 2 in the right half. But what to pick in the left half?"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "it telling me [2,2]=1 surely should be =2??\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "I think I had a similar problem its telling me [2,2]=1, which makes no sense it should be 2 surely??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Kalyan19111999](/Kalyan19111999) You\\'re right in general, but we\\'re specifically talking about a divide and conquer solution.\\n\\nYou break up an array like `[1, 2, 2]` into subproblems such as `[1, 2]` and `[2]`. Even though `[1, 2]` doesn\\'t have a majority element you still have to return some value from the subproblem. That\\'s what the original question was about: what do you return in that case?"
                    },
                    {
                        "username": "Kalyan19111999",
                        "content": "[@nikhila01](/nikhila01)  I\\'m not quite sure if this case of length of ```nums``` being 2 with both elements being different comes up because, according to the problem description \"You may assume that the majority element always exists in the array\" which can only happen if both elements are the same e.g: [1,1] or [2,2]. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@himanshug9119](/himanshug9119) Majority is defined as _more than_ `floor(n / 2)` occurrences. If `n == 2` then `floor(n / 2) = 1` and no element out of 1 and 2 occurs _more than_ one time in `[1,2]`. So there isn't a majority.\n\n----\n\nAnyway, the answer to the original question is that for `[1,2]` you split it into `[1]` and `[2]`. Then `1` is the majority element on the left and `2` is the majority element on the right as per the base case. Now we have to combine the answers.\n\nWhat LeetCode's official solution does is this: Since the left and right subproblems don't agree on the majority element, you have to count the occurrences of `1` and `2` in the combined subarray. Whichever occurs more times is the majority. Here, both occur _one_ time in `[1,2]`, so it arbitrarily returns one of the elements as the majority. Let's pick the left to make the example more interesting, although LeetCode's solution actually returns the right if the counts are equal.\n\nThen when we combine `[1,2]` and `[2]` we got `1` on the left and `2` on the right. Again, they don't agree so we have to count occurrences of `1` and `2` in `[1,2,2]`. Now `2` wins so that's our answer."
                    },
                    {
                        "username": "himanshug9119",
                        "content": "You are saying in length 2 array there is no majority element why ?\\nYes there is also a majority element first one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "All those upvotes are for sure done by nerds who used either an extra O(n) space or extra time complexity which maybe n^2 or nlogn.  \nBut guys be honest did anyone solve it O(n) time and O(1) space. who has solved it like this ? \nI'm here sitting for an hour to figure out this."
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "[@emengel](/emengel) There is no O(n) sorting algorithm"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "hashing table algo"
                    },
                    {
                        "username": "leeyanleryan",
                        "content": "```\\nclass Solution \\n{\\n    public int majorityElement(int[] nums) \\n    {\\n        int count = 0;\\n        int dom = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (count == 0)\\n            {\\n                dom = nums[i];\\n                count++;\\n            }\\n            else if (dom != nums[i])\\n            {\\n                count--;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return dom;\\n    }\\n}\\n```\\n\\nThis is my solution for O(n) time and O(1) space."
                    },
                    {
                        "username": "emengel",
                        "content": "Try using an O(n) sorting algorithm that you can perform in-place (there\\'s only one that I know of). You\\'ll have to implement your own, since python\\'s sort() runs in n*log(n) time. You\\'ll find that a solution using the O(n) algorithm actually performs worse than the n*log(n) sorts. Determining the conditions under which this remains true is a fantastic exercise in complexity analysis."
                    },
                    {
                        "username": "TheOnix",
                        "content": "This is a stupid problem that only tests that you know the solution, not your problem-solving skills"
                    },
                    {
                        "username": "FindIshita",
                        "content": "moore\\'s voting algo will be helpful"
                    },
                    {
                        "username": "hanhongsun",
                        "content": "I found nobody using bit-Operation for this question.\\n\\nI will try make up a O(n) time bit operation solution. \\n\\n**No** Boyer-Moore Majority Vote Algorithm \\n**No** Hashing table"
                    },
                    {
                        "username": "simonrouse9461",
                        "content": "[@Saketyadav](/Saketyadav) This does not have linear time. It\\'s O(n log n)"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "[@mdas95](/mdas95) Arrays.sort(nums);\\nreturn nums[nums.length/2];  try this one\\n"
                    },
                    {
                        "username": "mdas95",
                        "content": "tell me more I am all ears. \\nby the way[2 2 2 1 1 1 3 3] will it solve the this set of data. I am getting majority as 3 which is not the case. Since this has no majority.\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/majority-element/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** HashMap\n\n  \n**Approach 3:** Sorting\n\n  \n**Approach 4:** Randomization\n\n  \n**Approach 5:** Divide and Conquer\n\n  \n**Approach 6:** Boyer-Moore Voting Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sofs1",
                        "content": "Why did they put this problem under \"Bit Manipulation\" when none of the 6 solutions use bit operators?"
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "I don\\'t understand why people are sorting and returning the middle element. Although it is a valid solution, the follow-up of the question is asking us to solve the problem in Linear time and not O(nlogn) time. "
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Moore\\'s Voting Algorithm Explained in Super Simple efficient way!! \\nLink : https://leetcode.com/problems/majority-element/solutions/3015428/c-moore-s-voting-algorithm-explained-in-super-simple-fast-way/ \\n\\n \\n"
                    }
                ]
            },
            {
                "id": 1565812,
                "content": [
                    {
                        "username": "singhabhay11",
                        "content": "Arrays.sort(nums);\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@cswartzell](/cswartzell) See the last line\\n`Follow-up: Could you solve the problem in linear time and in O(1) space?`"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@tanmayyyj](/tanmayyyj)  Question doesnt mention time complexity at all. The O(n) solutions are pretty trivial, its interesting to think of different ways to do it. "
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "but not the time complexity the question is asking for\\n"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "[@sanon3714](/sanon3714) That is not an valid input for this problem since the majority element is said to be occuring more than n/2 times, here n=8 so 8/2=4 no element occurs more than 4 times. Therefore not a valid input."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "majority element present more than (n / 2) times. .not n/2 times [@Shivang verma](/Shivang_Verma1)"
                    },
                    {
                        "username": "sanon3714",
                        "content": "check for this 1,2,3,4,3,5,5,5\\n"
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "[@nikhila01](/nikhila01)  thankyou so much ,now I understand."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Shivang_Verma1](/Shivang_Verma1) `[1,1,1,2,2,4]` is an invalid input since it has no majority element. The majority element has to appear **more than** `\\u230An / 2\\u230B` times. Here `1` appears **exactly** `\\u230An / 2\\u230B` times."
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "what if arr=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1 "
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "If you\\'re sorting then it\\'s not linear time"
                    },
                    {
                        "username": "jerryy147",
                        "content": "This is genius!"
                    },
                    {
                        "username": "hampuztt",
                        "content": "[@keeganasmith2003](/keeganasmith2003) Even if counting sort was used, it\\'s not O(1) space"
                    },
                    {
                        "username": "bob1123030",
                        "content": "god level code\\n"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Can you not post solutions in the Discussion ... "
                    },
                    {
                        "username": "ParasAtal05",
                        "content": "God level code"
                    },
                    {
                        "username": "Rithym",
                        "content": "God level code\\n"
                    },
                    {
                        "username": "keeganasmith2003",
                        "content": "[@wisegauravmehra](/wisegauravmehra) It is linear if counting sort is used. This is an integer container, so counting sort can be used. "
                    },
                    {
                        "username": "wisegauravmehra",
                        "content": "It\\'s not linear runtime solution."
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/6c81d433-5a1c-412b-ba0c-f08ae95baa9e_1648865936.0360248.jpeg)\\n"
                    },
                    {
                        "username": "k_praphull",
                        "content": "[@nitish07maximus](/nitish07maximus) Have you read question properly, majority element is **more than n/2**"
                    },
                    {
                        "username": "ismaelmiah",
                        "content": "[@nitish07maximus](/nitish07maximus)  This is a wrong test case. as the description says \"You may assume that the majority element always exists in the array.\" You can assume these types of case won\\'t set in judge panel."
                    },
                    {
                        "username": "junjiexu",
                        "content": "[@nitish07maximus](/nitish07maximus) But that\\'s invalid input?"
                    },
                    {
                        "username": "nitish07maximus",
                        "content": "Give wrong result for this input.\\n1,1,1,2,2,3,2,1"
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "codyli520",
                        "content": "if I have [1,1,1,2,2,2], why is 1 the majority number and not 2?"
                    },
                    {
                        "username": "mursalin777",
                        "content": "the majority element must exist more than n/2 times. That\\'s the condition. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@CT-7567](/CT-7567) In my opinion you shouldn't treat the input as a random array. The problem constraints are there for a reason and allow you to come up with more interesting and efficient algorithms, like the follow up of O(N) time and O(1) space.\n\nIf you assume you can be given any inputs then it's a different problem. If a problem asks you to merge two sorted arrays into a single sorted array, would you just pretend the inputs aren't sorted and use a less efficient algorithm? It doesn't make sense."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sagar-pro](/sagar-pro) In my opinion you should approach this question like your input is a random array. it is harder but can be work in every array"
                    },
                    {
                        "username": "sagar-pro",
                        "content": "In your case no majority element because no element exist greater than 3(6/2)times and It is given in question input will always have majority element.\n"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I have problem coming up with the divide and conquer solution.Assume the base case contains only one element, which is the majority element for the base case. Now suppose we have two elements, each one returning from the base case. Say they are 1 2. There is clearly no majority element in this two-element array. If the whole input array is 1 2 2 and you divide the problem into 1 2 and 2. Of course you pick 2 in the right half. But what to pick in the left half?"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "it telling me [2,2]=1 surely should be =2??\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "I think I had a similar problem its telling me [2,2]=1, which makes no sense it should be 2 surely??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Kalyan19111999](/Kalyan19111999) You\\'re right in general, but we\\'re specifically talking about a divide and conquer solution.\\n\\nYou break up an array like `[1, 2, 2]` into subproblems such as `[1, 2]` and `[2]`. Even though `[1, 2]` doesn\\'t have a majority element you still have to return some value from the subproblem. That\\'s what the original question was about: what do you return in that case?"
                    },
                    {
                        "username": "Kalyan19111999",
                        "content": "[@nikhila01](/nikhila01)  I\\'m not quite sure if this case of length of ```nums``` being 2 with both elements being different comes up because, according to the problem description \"You may assume that the majority element always exists in the array\" which can only happen if both elements are the same e.g: [1,1] or [2,2]. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@himanshug9119](/himanshug9119) Majority is defined as _more than_ `floor(n / 2)` occurrences. If `n == 2` then `floor(n / 2) = 1` and no element out of 1 and 2 occurs _more than_ one time in `[1,2]`. So there isn't a majority.\n\n----\n\nAnyway, the answer to the original question is that for `[1,2]` you split it into `[1]` and `[2]`. Then `1` is the majority element on the left and `2` is the majority element on the right as per the base case. Now we have to combine the answers.\n\nWhat LeetCode's official solution does is this: Since the left and right subproblems don't agree on the majority element, you have to count the occurrences of `1` and `2` in the combined subarray. Whichever occurs more times is the majority. Here, both occur _one_ time in `[1,2]`, so it arbitrarily returns one of the elements as the majority. Let's pick the left to make the example more interesting, although LeetCode's solution actually returns the right if the counts are equal.\n\nThen when we combine `[1,2]` and `[2]` we got `1` on the left and `2` on the right. Again, they don't agree so we have to count occurrences of `1` and `2` in `[1,2,2]`. Now `2` wins so that's our answer."
                    },
                    {
                        "username": "himanshug9119",
                        "content": "You are saying in length 2 array there is no majority element why ?\\nYes there is also a majority element first one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "All those upvotes are for sure done by nerds who used either an extra O(n) space or extra time complexity which maybe n^2 or nlogn.  \nBut guys be honest did anyone solve it O(n) time and O(1) space. who has solved it like this ? \nI'm here sitting for an hour to figure out this."
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "[@emengel](/emengel) There is no O(n) sorting algorithm"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "hashing table algo"
                    },
                    {
                        "username": "leeyanleryan",
                        "content": "```\\nclass Solution \\n{\\n    public int majorityElement(int[] nums) \\n    {\\n        int count = 0;\\n        int dom = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (count == 0)\\n            {\\n                dom = nums[i];\\n                count++;\\n            }\\n            else if (dom != nums[i])\\n            {\\n                count--;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return dom;\\n    }\\n}\\n```\\n\\nThis is my solution for O(n) time and O(1) space."
                    },
                    {
                        "username": "emengel",
                        "content": "Try using an O(n) sorting algorithm that you can perform in-place (there\\'s only one that I know of). You\\'ll have to implement your own, since python\\'s sort() runs in n*log(n) time. You\\'ll find that a solution using the O(n) algorithm actually performs worse than the n*log(n) sorts. Determining the conditions under which this remains true is a fantastic exercise in complexity analysis."
                    },
                    {
                        "username": "TheOnix",
                        "content": "This is a stupid problem that only tests that you know the solution, not your problem-solving skills"
                    },
                    {
                        "username": "FindIshita",
                        "content": "moore\\'s voting algo will be helpful"
                    },
                    {
                        "username": "hanhongsun",
                        "content": "I found nobody using bit-Operation for this question.\\n\\nI will try make up a O(n) time bit operation solution. \\n\\n**No** Boyer-Moore Majority Vote Algorithm \\n**No** Hashing table"
                    },
                    {
                        "username": "simonrouse9461",
                        "content": "[@Saketyadav](/Saketyadav) This does not have linear time. It\\'s O(n log n)"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "[@mdas95](/mdas95) Arrays.sort(nums);\\nreturn nums[nums.length/2];  try this one\\n"
                    },
                    {
                        "username": "mdas95",
                        "content": "tell me more I am all ears. \\nby the way[2 2 2 1 1 1 3 3] will it solve the this set of data. I am getting majority as 3 which is not the case. Since this has no majority.\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/majority-element/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** HashMap\n\n  \n**Approach 3:** Sorting\n\n  \n**Approach 4:** Randomization\n\n  \n**Approach 5:** Divide and Conquer\n\n  \n**Approach 6:** Boyer-Moore Voting Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sofs1",
                        "content": "Why did they put this problem under \"Bit Manipulation\" when none of the 6 solutions use bit operators?"
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "I don\\'t understand why people are sorting and returning the middle element. Although it is a valid solution, the follow-up of the question is asking us to solve the problem in Linear time and not O(nlogn) time. "
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Moore\\'s Voting Algorithm Explained in Super Simple efficient way!! \\nLink : https://leetcode.com/problems/majority-element/solutions/3015428/c-moore-s-voting-algorithm-explained-in-super-simple-fast-way/ \\n\\n \\n"
                    }
                ]
            },
            {
                "id": 1572220,
                "content": [
                    {
                        "username": "singhabhay11",
                        "content": "Arrays.sort(nums);\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@cswartzell](/cswartzell) See the last line\\n`Follow-up: Could you solve the problem in linear time and in O(1) space?`"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@tanmayyyj](/tanmayyyj)  Question doesnt mention time complexity at all. The O(n) solutions are pretty trivial, its interesting to think of different ways to do it. "
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "but not the time complexity the question is asking for\\n"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "[@sanon3714](/sanon3714) That is not an valid input for this problem since the majority element is said to be occuring more than n/2 times, here n=8 so 8/2=4 no element occurs more than 4 times. Therefore not a valid input."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "majority element present more than (n / 2) times. .not n/2 times [@Shivang verma](/Shivang_Verma1)"
                    },
                    {
                        "username": "sanon3714",
                        "content": "check for this 1,2,3,4,3,5,5,5\\n"
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "[@nikhila01](/nikhila01)  thankyou so much ,now I understand."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Shivang_Verma1](/Shivang_Verma1) `[1,1,1,2,2,4]` is an invalid input since it has no majority element. The majority element has to appear **more than** `\\u230An / 2\\u230B` times. Here `1` appears **exactly** `\\u230An / 2\\u230B` times."
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "what if arr=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1 "
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "If you\\'re sorting then it\\'s not linear time"
                    },
                    {
                        "username": "jerryy147",
                        "content": "This is genius!"
                    },
                    {
                        "username": "hampuztt",
                        "content": "[@keeganasmith2003](/keeganasmith2003) Even if counting sort was used, it\\'s not O(1) space"
                    },
                    {
                        "username": "bob1123030",
                        "content": "god level code\\n"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Can you not post solutions in the Discussion ... "
                    },
                    {
                        "username": "ParasAtal05",
                        "content": "God level code"
                    },
                    {
                        "username": "Rithym",
                        "content": "God level code\\n"
                    },
                    {
                        "username": "keeganasmith2003",
                        "content": "[@wisegauravmehra](/wisegauravmehra) It is linear if counting sort is used. This is an integer container, so counting sort can be used. "
                    },
                    {
                        "username": "wisegauravmehra",
                        "content": "It\\'s not linear runtime solution."
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/6c81d433-5a1c-412b-ba0c-f08ae95baa9e_1648865936.0360248.jpeg)\\n"
                    },
                    {
                        "username": "k_praphull",
                        "content": "[@nitish07maximus](/nitish07maximus) Have you read question properly, majority element is **more than n/2**"
                    },
                    {
                        "username": "ismaelmiah",
                        "content": "[@nitish07maximus](/nitish07maximus)  This is a wrong test case. as the description says \"You may assume that the majority element always exists in the array.\" You can assume these types of case won\\'t set in judge panel."
                    },
                    {
                        "username": "junjiexu",
                        "content": "[@nitish07maximus](/nitish07maximus) But that\\'s invalid input?"
                    },
                    {
                        "username": "nitish07maximus",
                        "content": "Give wrong result for this input.\\n1,1,1,2,2,3,2,1"
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "codyli520",
                        "content": "if I have [1,1,1,2,2,2], why is 1 the majority number and not 2?"
                    },
                    {
                        "username": "mursalin777",
                        "content": "the majority element must exist more than n/2 times. That\\'s the condition. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@CT-7567](/CT-7567) In my opinion you shouldn't treat the input as a random array. The problem constraints are there for a reason and allow you to come up with more interesting and efficient algorithms, like the follow up of O(N) time and O(1) space.\n\nIf you assume you can be given any inputs then it's a different problem. If a problem asks you to merge two sorted arrays into a single sorted array, would you just pretend the inputs aren't sorted and use a less efficient algorithm? It doesn't make sense."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sagar-pro](/sagar-pro) In my opinion you should approach this question like your input is a random array. it is harder but can be work in every array"
                    },
                    {
                        "username": "sagar-pro",
                        "content": "In your case no majority element because no element exist greater than 3(6/2)times and It is given in question input will always have majority element.\n"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I have problem coming up with the divide and conquer solution.Assume the base case contains only one element, which is the majority element for the base case. Now suppose we have two elements, each one returning from the base case. Say they are 1 2. There is clearly no majority element in this two-element array. If the whole input array is 1 2 2 and you divide the problem into 1 2 and 2. Of course you pick 2 in the right half. But what to pick in the left half?"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "it telling me [2,2]=1 surely should be =2??\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "I think I had a similar problem its telling me [2,2]=1, which makes no sense it should be 2 surely??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Kalyan19111999](/Kalyan19111999) You\\'re right in general, but we\\'re specifically talking about a divide and conquer solution.\\n\\nYou break up an array like `[1, 2, 2]` into subproblems such as `[1, 2]` and `[2]`. Even though `[1, 2]` doesn\\'t have a majority element you still have to return some value from the subproblem. That\\'s what the original question was about: what do you return in that case?"
                    },
                    {
                        "username": "Kalyan19111999",
                        "content": "[@nikhila01](/nikhila01)  I\\'m not quite sure if this case of length of ```nums``` being 2 with both elements being different comes up because, according to the problem description \"You may assume that the majority element always exists in the array\" which can only happen if both elements are the same e.g: [1,1] or [2,2]. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@himanshug9119](/himanshug9119) Majority is defined as _more than_ `floor(n / 2)` occurrences. If `n == 2` then `floor(n / 2) = 1` and no element out of 1 and 2 occurs _more than_ one time in `[1,2]`. So there isn't a majority.\n\n----\n\nAnyway, the answer to the original question is that for `[1,2]` you split it into `[1]` and `[2]`. Then `1` is the majority element on the left and `2` is the majority element on the right as per the base case. Now we have to combine the answers.\n\nWhat LeetCode's official solution does is this: Since the left and right subproblems don't agree on the majority element, you have to count the occurrences of `1` and `2` in the combined subarray. Whichever occurs more times is the majority. Here, both occur _one_ time in `[1,2]`, so it arbitrarily returns one of the elements as the majority. Let's pick the left to make the example more interesting, although LeetCode's solution actually returns the right if the counts are equal.\n\nThen when we combine `[1,2]` and `[2]` we got `1` on the left and `2` on the right. Again, they don't agree so we have to count occurrences of `1` and `2` in `[1,2,2]`. Now `2` wins so that's our answer."
                    },
                    {
                        "username": "himanshug9119",
                        "content": "You are saying in length 2 array there is no majority element why ?\\nYes there is also a majority element first one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "All those upvotes are for sure done by nerds who used either an extra O(n) space or extra time complexity which maybe n^2 or nlogn.  \nBut guys be honest did anyone solve it O(n) time and O(1) space. who has solved it like this ? \nI'm here sitting for an hour to figure out this."
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "[@emengel](/emengel) There is no O(n) sorting algorithm"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "hashing table algo"
                    },
                    {
                        "username": "leeyanleryan",
                        "content": "```\\nclass Solution \\n{\\n    public int majorityElement(int[] nums) \\n    {\\n        int count = 0;\\n        int dom = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (count == 0)\\n            {\\n                dom = nums[i];\\n                count++;\\n            }\\n            else if (dom != nums[i])\\n            {\\n                count--;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return dom;\\n    }\\n}\\n```\\n\\nThis is my solution for O(n) time and O(1) space."
                    },
                    {
                        "username": "emengel",
                        "content": "Try using an O(n) sorting algorithm that you can perform in-place (there\\'s only one that I know of). You\\'ll have to implement your own, since python\\'s sort() runs in n*log(n) time. You\\'ll find that a solution using the O(n) algorithm actually performs worse than the n*log(n) sorts. Determining the conditions under which this remains true is a fantastic exercise in complexity analysis."
                    },
                    {
                        "username": "TheOnix",
                        "content": "This is a stupid problem that only tests that you know the solution, not your problem-solving skills"
                    },
                    {
                        "username": "FindIshita",
                        "content": "moore\\'s voting algo will be helpful"
                    },
                    {
                        "username": "hanhongsun",
                        "content": "I found nobody using bit-Operation for this question.\\n\\nI will try make up a O(n) time bit operation solution. \\n\\n**No** Boyer-Moore Majority Vote Algorithm \\n**No** Hashing table"
                    },
                    {
                        "username": "simonrouse9461",
                        "content": "[@Saketyadav](/Saketyadav) This does not have linear time. It\\'s O(n log n)"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "[@mdas95](/mdas95) Arrays.sort(nums);\\nreturn nums[nums.length/2];  try this one\\n"
                    },
                    {
                        "username": "mdas95",
                        "content": "tell me more I am all ears. \\nby the way[2 2 2 1 1 1 3 3] will it solve the this set of data. I am getting majority as 3 which is not the case. Since this has no majority.\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/majority-element/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** HashMap\n\n  \n**Approach 3:** Sorting\n\n  \n**Approach 4:** Randomization\n\n  \n**Approach 5:** Divide and Conquer\n\n  \n**Approach 6:** Boyer-Moore Voting Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sofs1",
                        "content": "Why did they put this problem under \"Bit Manipulation\" when none of the 6 solutions use bit operators?"
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "I don\\'t understand why people are sorting and returning the middle element. Although it is a valid solution, the follow-up of the question is asking us to solve the problem in Linear time and not O(nlogn) time. "
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Moore\\'s Voting Algorithm Explained in Super Simple efficient way!! \\nLink : https://leetcode.com/problems/majority-element/solutions/3015428/c-moore-s-voting-algorithm-explained-in-super-simple-fast-way/ \\n\\n \\n"
                    }
                ]
            },
            {
                "id": 1891387,
                "content": [
                    {
                        "username": "singhabhay11",
                        "content": "Arrays.sort(nums);\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@cswartzell](/cswartzell) See the last line\\n`Follow-up: Could you solve the problem in linear time and in O(1) space?`"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@tanmayyyj](/tanmayyyj)  Question doesnt mention time complexity at all. The O(n) solutions are pretty trivial, its interesting to think of different ways to do it. "
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "but not the time complexity the question is asking for\\n"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "[@sanon3714](/sanon3714) That is not an valid input for this problem since the majority element is said to be occuring more than n/2 times, here n=8 so 8/2=4 no element occurs more than 4 times. Therefore not a valid input."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "majority element present more than (n / 2) times. .not n/2 times [@Shivang verma](/Shivang_Verma1)"
                    },
                    {
                        "username": "sanon3714",
                        "content": "check for this 1,2,3,4,3,5,5,5\\n"
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "[@nikhila01](/nikhila01)  thankyou so much ,now I understand."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Shivang_Verma1](/Shivang_Verma1) `[1,1,1,2,2,4]` is an invalid input since it has no majority element. The majority element has to appear **more than** `\\u230An / 2\\u230B` times. Here `1` appears **exactly** `\\u230An / 2\\u230B` times."
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "what if arr=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1 "
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "If you\\'re sorting then it\\'s not linear time"
                    },
                    {
                        "username": "jerryy147",
                        "content": "This is genius!"
                    },
                    {
                        "username": "hampuztt",
                        "content": "[@keeganasmith2003](/keeganasmith2003) Even if counting sort was used, it\\'s not O(1) space"
                    },
                    {
                        "username": "bob1123030",
                        "content": "god level code\\n"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Can you not post solutions in the Discussion ... "
                    },
                    {
                        "username": "ParasAtal05",
                        "content": "God level code"
                    },
                    {
                        "username": "Rithym",
                        "content": "God level code\\n"
                    },
                    {
                        "username": "keeganasmith2003",
                        "content": "[@wisegauravmehra](/wisegauravmehra) It is linear if counting sort is used. This is an integer container, so counting sort can be used. "
                    },
                    {
                        "username": "wisegauravmehra",
                        "content": "It\\'s not linear runtime solution."
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/6c81d433-5a1c-412b-ba0c-f08ae95baa9e_1648865936.0360248.jpeg)\\n"
                    },
                    {
                        "username": "k_praphull",
                        "content": "[@nitish07maximus](/nitish07maximus) Have you read question properly, majority element is **more than n/2**"
                    },
                    {
                        "username": "ismaelmiah",
                        "content": "[@nitish07maximus](/nitish07maximus)  This is a wrong test case. as the description says \"You may assume that the majority element always exists in the array.\" You can assume these types of case won\\'t set in judge panel."
                    },
                    {
                        "username": "junjiexu",
                        "content": "[@nitish07maximus](/nitish07maximus) But that\\'s invalid input?"
                    },
                    {
                        "username": "nitish07maximus",
                        "content": "Give wrong result for this input.\\n1,1,1,2,2,3,2,1"
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "codyli520",
                        "content": "if I have [1,1,1,2,2,2], why is 1 the majority number and not 2?"
                    },
                    {
                        "username": "mursalin777",
                        "content": "the majority element must exist more than n/2 times. That\\'s the condition. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@CT-7567](/CT-7567) In my opinion you shouldn't treat the input as a random array. The problem constraints are there for a reason and allow you to come up with more interesting and efficient algorithms, like the follow up of O(N) time and O(1) space.\n\nIf you assume you can be given any inputs then it's a different problem. If a problem asks you to merge two sorted arrays into a single sorted array, would you just pretend the inputs aren't sorted and use a less efficient algorithm? It doesn't make sense."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sagar-pro](/sagar-pro) In my opinion you should approach this question like your input is a random array. it is harder but can be work in every array"
                    },
                    {
                        "username": "sagar-pro",
                        "content": "In your case no majority element because no element exist greater than 3(6/2)times and It is given in question input will always have majority element.\n"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I have problem coming up with the divide and conquer solution.Assume the base case contains only one element, which is the majority element for the base case. Now suppose we have two elements, each one returning from the base case. Say they are 1 2. There is clearly no majority element in this two-element array. If the whole input array is 1 2 2 and you divide the problem into 1 2 and 2. Of course you pick 2 in the right half. But what to pick in the left half?"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "it telling me [2,2]=1 surely should be =2??\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "I think I had a similar problem its telling me [2,2]=1, which makes no sense it should be 2 surely??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Kalyan19111999](/Kalyan19111999) You\\'re right in general, but we\\'re specifically talking about a divide and conquer solution.\\n\\nYou break up an array like `[1, 2, 2]` into subproblems such as `[1, 2]` and `[2]`. Even though `[1, 2]` doesn\\'t have a majority element you still have to return some value from the subproblem. That\\'s what the original question was about: what do you return in that case?"
                    },
                    {
                        "username": "Kalyan19111999",
                        "content": "[@nikhila01](/nikhila01)  I\\'m not quite sure if this case of length of ```nums``` being 2 with both elements being different comes up because, according to the problem description \"You may assume that the majority element always exists in the array\" which can only happen if both elements are the same e.g: [1,1] or [2,2]. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@himanshug9119](/himanshug9119) Majority is defined as _more than_ `floor(n / 2)` occurrences. If `n == 2` then `floor(n / 2) = 1` and no element out of 1 and 2 occurs _more than_ one time in `[1,2]`. So there isn't a majority.\n\n----\n\nAnyway, the answer to the original question is that for `[1,2]` you split it into `[1]` and `[2]`. Then `1` is the majority element on the left and `2` is the majority element on the right as per the base case. Now we have to combine the answers.\n\nWhat LeetCode's official solution does is this: Since the left and right subproblems don't agree on the majority element, you have to count the occurrences of `1` and `2` in the combined subarray. Whichever occurs more times is the majority. Here, both occur _one_ time in `[1,2]`, so it arbitrarily returns one of the elements as the majority. Let's pick the left to make the example more interesting, although LeetCode's solution actually returns the right if the counts are equal.\n\nThen when we combine `[1,2]` and `[2]` we got `1` on the left and `2` on the right. Again, they don't agree so we have to count occurrences of `1` and `2` in `[1,2,2]`. Now `2` wins so that's our answer."
                    },
                    {
                        "username": "himanshug9119",
                        "content": "You are saying in length 2 array there is no majority element why ?\\nYes there is also a majority element first one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "All those upvotes are for sure done by nerds who used either an extra O(n) space or extra time complexity which maybe n^2 or nlogn.  \nBut guys be honest did anyone solve it O(n) time and O(1) space. who has solved it like this ? \nI'm here sitting for an hour to figure out this."
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "[@emengel](/emengel) There is no O(n) sorting algorithm"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "hashing table algo"
                    },
                    {
                        "username": "leeyanleryan",
                        "content": "```\\nclass Solution \\n{\\n    public int majorityElement(int[] nums) \\n    {\\n        int count = 0;\\n        int dom = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (count == 0)\\n            {\\n                dom = nums[i];\\n                count++;\\n            }\\n            else if (dom != nums[i])\\n            {\\n                count--;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return dom;\\n    }\\n}\\n```\\n\\nThis is my solution for O(n) time and O(1) space."
                    },
                    {
                        "username": "emengel",
                        "content": "Try using an O(n) sorting algorithm that you can perform in-place (there\\'s only one that I know of). You\\'ll have to implement your own, since python\\'s sort() runs in n*log(n) time. You\\'ll find that a solution using the O(n) algorithm actually performs worse than the n*log(n) sorts. Determining the conditions under which this remains true is a fantastic exercise in complexity analysis."
                    },
                    {
                        "username": "TheOnix",
                        "content": "This is a stupid problem that only tests that you know the solution, not your problem-solving skills"
                    },
                    {
                        "username": "FindIshita",
                        "content": "moore\\'s voting algo will be helpful"
                    },
                    {
                        "username": "hanhongsun",
                        "content": "I found nobody using bit-Operation for this question.\\n\\nI will try make up a O(n) time bit operation solution. \\n\\n**No** Boyer-Moore Majority Vote Algorithm \\n**No** Hashing table"
                    },
                    {
                        "username": "simonrouse9461",
                        "content": "[@Saketyadav](/Saketyadav) This does not have linear time. It\\'s O(n log n)"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "[@mdas95](/mdas95) Arrays.sort(nums);\\nreturn nums[nums.length/2];  try this one\\n"
                    },
                    {
                        "username": "mdas95",
                        "content": "tell me more I am all ears. \\nby the way[2 2 2 1 1 1 3 3] will it solve the this set of data. I am getting majority as 3 which is not the case. Since this has no majority.\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/majority-element/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** HashMap\n\n  \n**Approach 3:** Sorting\n\n  \n**Approach 4:** Randomization\n\n  \n**Approach 5:** Divide and Conquer\n\n  \n**Approach 6:** Boyer-Moore Voting Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sofs1",
                        "content": "Why did they put this problem under \"Bit Manipulation\" when none of the 6 solutions use bit operators?"
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "I don\\'t understand why people are sorting and returning the middle element. Although it is a valid solution, the follow-up of the question is asking us to solve the problem in Linear time and not O(nlogn) time. "
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Moore\\'s Voting Algorithm Explained in Super Simple efficient way!! \\nLink : https://leetcode.com/problems/majority-element/solutions/3015428/c-moore-s-voting-algorithm-explained-in-super-simple-fast-way/ \\n\\n \\n"
                    }
                ]
            },
            {
                "id": 1746724,
                "content": [
                    {
                        "username": "singhabhay11",
                        "content": "Arrays.sort(nums);\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@cswartzell](/cswartzell) See the last line\\n`Follow-up: Could you solve the problem in linear time and in O(1) space?`"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@tanmayyyj](/tanmayyyj)  Question doesnt mention time complexity at all. The O(n) solutions are pretty trivial, its interesting to think of different ways to do it. "
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "but not the time complexity the question is asking for\\n"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "[@sanon3714](/sanon3714) That is not an valid input for this problem since the majority element is said to be occuring more than n/2 times, here n=8 so 8/2=4 no element occurs more than 4 times. Therefore not a valid input."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "majority element present more than (n / 2) times. .not n/2 times [@Shivang verma](/Shivang_Verma1)"
                    },
                    {
                        "username": "sanon3714",
                        "content": "check for this 1,2,3,4,3,5,5,5\\n"
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "[@nikhila01](/nikhila01)  thankyou so much ,now I understand."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Shivang_Verma1](/Shivang_Verma1) `[1,1,1,2,2,4]` is an invalid input since it has no majority element. The majority element has to appear **more than** `\\u230An / 2\\u230B` times. Here `1` appears **exactly** `\\u230An / 2\\u230B` times."
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "what if arr=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1 "
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "If you\\'re sorting then it\\'s not linear time"
                    },
                    {
                        "username": "jerryy147",
                        "content": "This is genius!"
                    },
                    {
                        "username": "hampuztt",
                        "content": "[@keeganasmith2003](/keeganasmith2003) Even if counting sort was used, it\\'s not O(1) space"
                    },
                    {
                        "username": "bob1123030",
                        "content": "god level code\\n"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Can you not post solutions in the Discussion ... "
                    },
                    {
                        "username": "ParasAtal05",
                        "content": "God level code"
                    },
                    {
                        "username": "Rithym",
                        "content": "God level code\\n"
                    },
                    {
                        "username": "keeganasmith2003",
                        "content": "[@wisegauravmehra](/wisegauravmehra) It is linear if counting sort is used. This is an integer container, so counting sort can be used. "
                    },
                    {
                        "username": "wisegauravmehra",
                        "content": "It\\'s not linear runtime solution."
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/6c81d433-5a1c-412b-ba0c-f08ae95baa9e_1648865936.0360248.jpeg)\\n"
                    },
                    {
                        "username": "k_praphull",
                        "content": "[@nitish07maximus](/nitish07maximus) Have you read question properly, majority element is **more than n/2**"
                    },
                    {
                        "username": "ismaelmiah",
                        "content": "[@nitish07maximus](/nitish07maximus)  This is a wrong test case. as the description says \"You may assume that the majority element always exists in the array.\" You can assume these types of case won\\'t set in judge panel."
                    },
                    {
                        "username": "junjiexu",
                        "content": "[@nitish07maximus](/nitish07maximus) But that\\'s invalid input?"
                    },
                    {
                        "username": "nitish07maximus",
                        "content": "Give wrong result for this input.\\n1,1,1,2,2,3,2,1"
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "codyli520",
                        "content": "if I have [1,1,1,2,2,2], why is 1 the majority number and not 2?"
                    },
                    {
                        "username": "mursalin777",
                        "content": "the majority element must exist more than n/2 times. That\\'s the condition. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@CT-7567](/CT-7567) In my opinion you shouldn't treat the input as a random array. The problem constraints are there for a reason and allow you to come up with more interesting and efficient algorithms, like the follow up of O(N) time and O(1) space.\n\nIf you assume you can be given any inputs then it's a different problem. If a problem asks you to merge two sorted arrays into a single sorted array, would you just pretend the inputs aren't sorted and use a less efficient algorithm? It doesn't make sense."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sagar-pro](/sagar-pro) In my opinion you should approach this question like your input is a random array. it is harder but can be work in every array"
                    },
                    {
                        "username": "sagar-pro",
                        "content": "In your case no majority element because no element exist greater than 3(6/2)times and It is given in question input will always have majority element.\n"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I have problem coming up with the divide and conquer solution.Assume the base case contains only one element, which is the majority element for the base case. Now suppose we have two elements, each one returning from the base case. Say they are 1 2. There is clearly no majority element in this two-element array. If the whole input array is 1 2 2 and you divide the problem into 1 2 and 2. Of course you pick 2 in the right half. But what to pick in the left half?"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "it telling me [2,2]=1 surely should be =2??\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "I think I had a similar problem its telling me [2,2]=1, which makes no sense it should be 2 surely??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Kalyan19111999](/Kalyan19111999) You\\'re right in general, but we\\'re specifically talking about a divide and conquer solution.\\n\\nYou break up an array like `[1, 2, 2]` into subproblems such as `[1, 2]` and `[2]`. Even though `[1, 2]` doesn\\'t have a majority element you still have to return some value from the subproblem. That\\'s what the original question was about: what do you return in that case?"
                    },
                    {
                        "username": "Kalyan19111999",
                        "content": "[@nikhila01](/nikhila01)  I\\'m not quite sure if this case of length of ```nums``` being 2 with both elements being different comes up because, according to the problem description \"You may assume that the majority element always exists in the array\" which can only happen if both elements are the same e.g: [1,1] or [2,2]. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@himanshug9119](/himanshug9119) Majority is defined as _more than_ `floor(n / 2)` occurrences. If `n == 2` then `floor(n / 2) = 1` and no element out of 1 and 2 occurs _more than_ one time in `[1,2]`. So there isn't a majority.\n\n----\n\nAnyway, the answer to the original question is that for `[1,2]` you split it into `[1]` and `[2]`. Then `1` is the majority element on the left and `2` is the majority element on the right as per the base case. Now we have to combine the answers.\n\nWhat LeetCode's official solution does is this: Since the left and right subproblems don't agree on the majority element, you have to count the occurrences of `1` and `2` in the combined subarray. Whichever occurs more times is the majority. Here, both occur _one_ time in `[1,2]`, so it arbitrarily returns one of the elements as the majority. Let's pick the left to make the example more interesting, although LeetCode's solution actually returns the right if the counts are equal.\n\nThen when we combine `[1,2]` and `[2]` we got `1` on the left and `2` on the right. Again, they don't agree so we have to count occurrences of `1` and `2` in `[1,2,2]`. Now `2` wins so that's our answer."
                    },
                    {
                        "username": "himanshug9119",
                        "content": "You are saying in length 2 array there is no majority element why ?\\nYes there is also a majority element first one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "All those upvotes are for sure done by nerds who used either an extra O(n) space or extra time complexity which maybe n^2 or nlogn.  \nBut guys be honest did anyone solve it O(n) time and O(1) space. who has solved it like this ? \nI'm here sitting for an hour to figure out this."
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "[@emengel](/emengel) There is no O(n) sorting algorithm"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "hashing table algo"
                    },
                    {
                        "username": "leeyanleryan",
                        "content": "```\\nclass Solution \\n{\\n    public int majorityElement(int[] nums) \\n    {\\n        int count = 0;\\n        int dom = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (count == 0)\\n            {\\n                dom = nums[i];\\n                count++;\\n            }\\n            else if (dom != nums[i])\\n            {\\n                count--;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return dom;\\n    }\\n}\\n```\\n\\nThis is my solution for O(n) time and O(1) space."
                    },
                    {
                        "username": "emengel",
                        "content": "Try using an O(n) sorting algorithm that you can perform in-place (there\\'s only one that I know of). You\\'ll have to implement your own, since python\\'s sort() runs in n*log(n) time. You\\'ll find that a solution using the O(n) algorithm actually performs worse than the n*log(n) sorts. Determining the conditions under which this remains true is a fantastic exercise in complexity analysis."
                    },
                    {
                        "username": "TheOnix",
                        "content": "This is a stupid problem that only tests that you know the solution, not your problem-solving skills"
                    },
                    {
                        "username": "FindIshita",
                        "content": "moore\\'s voting algo will be helpful"
                    },
                    {
                        "username": "hanhongsun",
                        "content": "I found nobody using bit-Operation for this question.\\n\\nI will try make up a O(n) time bit operation solution. \\n\\n**No** Boyer-Moore Majority Vote Algorithm \\n**No** Hashing table"
                    },
                    {
                        "username": "simonrouse9461",
                        "content": "[@Saketyadav](/Saketyadav) This does not have linear time. It\\'s O(n log n)"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "[@mdas95](/mdas95) Arrays.sort(nums);\\nreturn nums[nums.length/2];  try this one\\n"
                    },
                    {
                        "username": "mdas95",
                        "content": "tell me more I am all ears. \\nby the way[2 2 2 1 1 1 3 3] will it solve the this set of data. I am getting majority as 3 which is not the case. Since this has no majority.\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/majority-element/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** HashMap\n\n  \n**Approach 3:** Sorting\n\n  \n**Approach 4:** Randomization\n\n  \n**Approach 5:** Divide and Conquer\n\n  \n**Approach 6:** Boyer-Moore Voting Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sofs1",
                        "content": "Why did they put this problem under \"Bit Manipulation\" when none of the 6 solutions use bit operators?"
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "I don\\'t understand why people are sorting and returning the middle element. Although it is a valid solution, the follow-up of the question is asking us to solve the problem in Linear time and not O(nlogn) time. "
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Moore\\'s Voting Algorithm Explained in Super Simple efficient way!! \\nLink : https://leetcode.com/problems/majority-element/solutions/3015428/c-moore-s-voting-algorithm-explained-in-super-simple-fast-way/ \\n\\n \\n"
                    }
                ]
            },
            {
                "id": 1570155,
                "content": [
                    {
                        "username": "singhabhay11",
                        "content": "Arrays.sort(nums);\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@cswartzell](/cswartzell) See the last line\\n`Follow-up: Could you solve the problem in linear time and in O(1) space?`"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@tanmayyyj](/tanmayyyj)  Question doesnt mention time complexity at all. The O(n) solutions are pretty trivial, its interesting to think of different ways to do it. "
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "but not the time complexity the question is asking for\\n"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "[@sanon3714](/sanon3714) That is not an valid input for this problem since the majority element is said to be occuring more than n/2 times, here n=8 so 8/2=4 no element occurs more than 4 times. Therefore not a valid input."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "majority element present more than (n / 2) times. .not n/2 times [@Shivang verma](/Shivang_Verma1)"
                    },
                    {
                        "username": "sanon3714",
                        "content": "check for this 1,2,3,4,3,5,5,5\\n"
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "[@nikhila01](/nikhila01)  thankyou so much ,now I understand."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Shivang_Verma1](/Shivang_Verma1) `[1,1,1,2,2,4]` is an invalid input since it has no majority element. The majority element has to appear **more than** `\\u230An / 2\\u230B` times. Here `1` appears **exactly** `\\u230An / 2\\u230B` times."
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "what if arr=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1 "
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "If you\\'re sorting then it\\'s not linear time"
                    },
                    {
                        "username": "jerryy147",
                        "content": "This is genius!"
                    },
                    {
                        "username": "hampuztt",
                        "content": "[@keeganasmith2003](/keeganasmith2003) Even if counting sort was used, it\\'s not O(1) space"
                    },
                    {
                        "username": "bob1123030",
                        "content": "god level code\\n"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Can you not post solutions in the Discussion ... "
                    },
                    {
                        "username": "ParasAtal05",
                        "content": "God level code"
                    },
                    {
                        "username": "Rithym",
                        "content": "God level code\\n"
                    },
                    {
                        "username": "keeganasmith2003",
                        "content": "[@wisegauravmehra](/wisegauravmehra) It is linear if counting sort is used. This is an integer container, so counting sort can be used. "
                    },
                    {
                        "username": "wisegauravmehra",
                        "content": "It\\'s not linear runtime solution."
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/6c81d433-5a1c-412b-ba0c-f08ae95baa9e_1648865936.0360248.jpeg)\\n"
                    },
                    {
                        "username": "k_praphull",
                        "content": "[@nitish07maximus](/nitish07maximus) Have you read question properly, majority element is **more than n/2**"
                    },
                    {
                        "username": "ismaelmiah",
                        "content": "[@nitish07maximus](/nitish07maximus)  This is a wrong test case. as the description says \"You may assume that the majority element always exists in the array.\" You can assume these types of case won\\'t set in judge panel."
                    },
                    {
                        "username": "junjiexu",
                        "content": "[@nitish07maximus](/nitish07maximus) But that\\'s invalid input?"
                    },
                    {
                        "username": "nitish07maximus",
                        "content": "Give wrong result for this input.\\n1,1,1,2,2,3,2,1"
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "codyli520",
                        "content": "if I have [1,1,1,2,2,2], why is 1 the majority number and not 2?"
                    },
                    {
                        "username": "mursalin777",
                        "content": "the majority element must exist more than n/2 times. That\\'s the condition. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@CT-7567](/CT-7567) In my opinion you shouldn't treat the input as a random array. The problem constraints are there for a reason and allow you to come up with more interesting and efficient algorithms, like the follow up of O(N) time and O(1) space.\n\nIf you assume you can be given any inputs then it's a different problem. If a problem asks you to merge two sorted arrays into a single sorted array, would you just pretend the inputs aren't sorted and use a less efficient algorithm? It doesn't make sense."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sagar-pro](/sagar-pro) In my opinion you should approach this question like your input is a random array. it is harder but can be work in every array"
                    },
                    {
                        "username": "sagar-pro",
                        "content": "In your case no majority element because no element exist greater than 3(6/2)times and It is given in question input will always have majority element.\n"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I have problem coming up with the divide and conquer solution.Assume the base case contains only one element, which is the majority element for the base case. Now suppose we have two elements, each one returning from the base case. Say they are 1 2. There is clearly no majority element in this two-element array. If the whole input array is 1 2 2 and you divide the problem into 1 2 and 2. Of course you pick 2 in the right half. But what to pick in the left half?"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "it telling me [2,2]=1 surely should be =2??\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "I think I had a similar problem its telling me [2,2]=1, which makes no sense it should be 2 surely??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Kalyan19111999](/Kalyan19111999) You\\'re right in general, but we\\'re specifically talking about a divide and conquer solution.\\n\\nYou break up an array like `[1, 2, 2]` into subproblems such as `[1, 2]` and `[2]`. Even though `[1, 2]` doesn\\'t have a majority element you still have to return some value from the subproblem. That\\'s what the original question was about: what do you return in that case?"
                    },
                    {
                        "username": "Kalyan19111999",
                        "content": "[@nikhila01](/nikhila01)  I\\'m not quite sure if this case of length of ```nums``` being 2 with both elements being different comes up because, according to the problem description \"You may assume that the majority element always exists in the array\" which can only happen if both elements are the same e.g: [1,1] or [2,2]. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@himanshug9119](/himanshug9119) Majority is defined as _more than_ `floor(n / 2)` occurrences. If `n == 2` then `floor(n / 2) = 1` and no element out of 1 and 2 occurs _more than_ one time in `[1,2]`. So there isn't a majority.\n\n----\n\nAnyway, the answer to the original question is that for `[1,2]` you split it into `[1]` and `[2]`. Then `1` is the majority element on the left and `2` is the majority element on the right as per the base case. Now we have to combine the answers.\n\nWhat LeetCode's official solution does is this: Since the left and right subproblems don't agree on the majority element, you have to count the occurrences of `1` and `2` in the combined subarray. Whichever occurs more times is the majority. Here, both occur _one_ time in `[1,2]`, so it arbitrarily returns one of the elements as the majority. Let's pick the left to make the example more interesting, although LeetCode's solution actually returns the right if the counts are equal.\n\nThen when we combine `[1,2]` and `[2]` we got `1` on the left and `2` on the right. Again, they don't agree so we have to count occurrences of `1` and `2` in `[1,2,2]`. Now `2` wins so that's our answer."
                    },
                    {
                        "username": "himanshug9119",
                        "content": "You are saying in length 2 array there is no majority element why ?\\nYes there is also a majority element first one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "All those upvotes are for sure done by nerds who used either an extra O(n) space or extra time complexity which maybe n^2 or nlogn.  \nBut guys be honest did anyone solve it O(n) time and O(1) space. who has solved it like this ? \nI'm here sitting for an hour to figure out this."
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "[@emengel](/emengel) There is no O(n) sorting algorithm"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "hashing table algo"
                    },
                    {
                        "username": "leeyanleryan",
                        "content": "```\\nclass Solution \\n{\\n    public int majorityElement(int[] nums) \\n    {\\n        int count = 0;\\n        int dom = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (count == 0)\\n            {\\n                dom = nums[i];\\n                count++;\\n            }\\n            else if (dom != nums[i])\\n            {\\n                count--;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return dom;\\n    }\\n}\\n```\\n\\nThis is my solution for O(n) time and O(1) space."
                    },
                    {
                        "username": "emengel",
                        "content": "Try using an O(n) sorting algorithm that you can perform in-place (there\\'s only one that I know of). You\\'ll have to implement your own, since python\\'s sort() runs in n*log(n) time. You\\'ll find that a solution using the O(n) algorithm actually performs worse than the n*log(n) sorts. Determining the conditions under which this remains true is a fantastic exercise in complexity analysis."
                    },
                    {
                        "username": "TheOnix",
                        "content": "This is a stupid problem that only tests that you know the solution, not your problem-solving skills"
                    },
                    {
                        "username": "FindIshita",
                        "content": "moore\\'s voting algo will be helpful"
                    },
                    {
                        "username": "hanhongsun",
                        "content": "I found nobody using bit-Operation for this question.\\n\\nI will try make up a O(n) time bit operation solution. \\n\\n**No** Boyer-Moore Majority Vote Algorithm \\n**No** Hashing table"
                    },
                    {
                        "username": "simonrouse9461",
                        "content": "[@Saketyadav](/Saketyadav) This does not have linear time. It\\'s O(n log n)"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "[@mdas95](/mdas95) Arrays.sort(nums);\\nreturn nums[nums.length/2];  try this one\\n"
                    },
                    {
                        "username": "mdas95",
                        "content": "tell me more I am all ears. \\nby the way[2 2 2 1 1 1 3 3] will it solve the this set of data. I am getting majority as 3 which is not the case. Since this has no majority.\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/majority-element/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** HashMap\n\n  \n**Approach 3:** Sorting\n\n  \n**Approach 4:** Randomization\n\n  \n**Approach 5:** Divide and Conquer\n\n  \n**Approach 6:** Boyer-Moore Voting Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sofs1",
                        "content": "Why did they put this problem under \"Bit Manipulation\" when none of the 6 solutions use bit operators?"
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "I don\\'t understand why people are sorting and returning the middle element. Although it is a valid solution, the follow-up of the question is asking us to solve the problem in Linear time and not O(nlogn) time. "
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Moore\\'s Voting Algorithm Explained in Super Simple efficient way!! \\nLink : https://leetcode.com/problems/majority-element/solutions/3015428/c-moore-s-voting-algorithm-explained-in-super-simple-fast-way/ \\n\\n \\n"
                    }
                ]
            },
            {
                "id": 1570835,
                "content": [
                    {
                        "username": "singhabhay11",
                        "content": "Arrays.sort(nums);\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@cswartzell](/cswartzell) See the last line\\n`Follow-up: Could you solve the problem in linear time and in O(1) space?`"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@tanmayyyj](/tanmayyyj)  Question doesnt mention time complexity at all. The O(n) solutions are pretty trivial, its interesting to think of different ways to do it. "
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "but not the time complexity the question is asking for\\n"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "[@sanon3714](/sanon3714) That is not an valid input for this problem since the majority element is said to be occuring more than n/2 times, here n=8 so 8/2=4 no element occurs more than 4 times. Therefore not a valid input."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "majority element present more than (n / 2) times. .not n/2 times [@Shivang verma](/Shivang_Verma1)"
                    },
                    {
                        "username": "sanon3714",
                        "content": "check for this 1,2,3,4,3,5,5,5\\n"
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "[@nikhila01](/nikhila01)  thankyou so much ,now I understand."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Shivang_Verma1](/Shivang_Verma1) `[1,1,1,2,2,4]` is an invalid input since it has no majority element. The majority element has to appear **more than** `\\u230An / 2\\u230B` times. Here `1` appears **exactly** `\\u230An / 2\\u230B` times."
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "what if arr=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1 "
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "If you\\'re sorting then it\\'s not linear time"
                    },
                    {
                        "username": "jerryy147",
                        "content": "This is genius!"
                    },
                    {
                        "username": "hampuztt",
                        "content": "[@keeganasmith2003](/keeganasmith2003) Even if counting sort was used, it\\'s not O(1) space"
                    },
                    {
                        "username": "bob1123030",
                        "content": "god level code\\n"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Can you not post solutions in the Discussion ... "
                    },
                    {
                        "username": "ParasAtal05",
                        "content": "God level code"
                    },
                    {
                        "username": "Rithym",
                        "content": "God level code\\n"
                    },
                    {
                        "username": "keeganasmith2003",
                        "content": "[@wisegauravmehra](/wisegauravmehra) It is linear if counting sort is used. This is an integer container, so counting sort can be used. "
                    },
                    {
                        "username": "wisegauravmehra",
                        "content": "It\\'s not linear runtime solution."
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/6c81d433-5a1c-412b-ba0c-f08ae95baa9e_1648865936.0360248.jpeg)\\n"
                    },
                    {
                        "username": "k_praphull",
                        "content": "[@nitish07maximus](/nitish07maximus) Have you read question properly, majority element is **more than n/2**"
                    },
                    {
                        "username": "ismaelmiah",
                        "content": "[@nitish07maximus](/nitish07maximus)  This is a wrong test case. as the description says \"You may assume that the majority element always exists in the array.\" You can assume these types of case won\\'t set in judge panel."
                    },
                    {
                        "username": "junjiexu",
                        "content": "[@nitish07maximus](/nitish07maximus) But that\\'s invalid input?"
                    },
                    {
                        "username": "nitish07maximus",
                        "content": "Give wrong result for this input.\\n1,1,1,2,2,3,2,1"
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "codyli520",
                        "content": "if I have [1,1,1,2,2,2], why is 1 the majority number and not 2?"
                    },
                    {
                        "username": "mursalin777",
                        "content": "the majority element must exist more than n/2 times. That\\'s the condition. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@CT-7567](/CT-7567) In my opinion you shouldn't treat the input as a random array. The problem constraints are there for a reason and allow you to come up with more interesting and efficient algorithms, like the follow up of O(N) time and O(1) space.\n\nIf you assume you can be given any inputs then it's a different problem. If a problem asks you to merge two sorted arrays into a single sorted array, would you just pretend the inputs aren't sorted and use a less efficient algorithm? It doesn't make sense."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sagar-pro](/sagar-pro) In my opinion you should approach this question like your input is a random array. it is harder but can be work in every array"
                    },
                    {
                        "username": "sagar-pro",
                        "content": "In your case no majority element because no element exist greater than 3(6/2)times and It is given in question input will always have majority element.\n"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I have problem coming up with the divide and conquer solution.Assume the base case contains only one element, which is the majority element for the base case. Now suppose we have two elements, each one returning from the base case. Say they are 1 2. There is clearly no majority element in this two-element array. If the whole input array is 1 2 2 and you divide the problem into 1 2 and 2. Of course you pick 2 in the right half. But what to pick in the left half?"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "it telling me [2,2]=1 surely should be =2??\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "I think I had a similar problem its telling me [2,2]=1, which makes no sense it should be 2 surely??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Kalyan19111999](/Kalyan19111999) You\\'re right in general, but we\\'re specifically talking about a divide and conquer solution.\\n\\nYou break up an array like `[1, 2, 2]` into subproblems such as `[1, 2]` and `[2]`. Even though `[1, 2]` doesn\\'t have a majority element you still have to return some value from the subproblem. That\\'s what the original question was about: what do you return in that case?"
                    },
                    {
                        "username": "Kalyan19111999",
                        "content": "[@nikhila01](/nikhila01)  I\\'m not quite sure if this case of length of ```nums``` being 2 with both elements being different comes up because, according to the problem description \"You may assume that the majority element always exists in the array\" which can only happen if both elements are the same e.g: [1,1] or [2,2]. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@himanshug9119](/himanshug9119) Majority is defined as _more than_ `floor(n / 2)` occurrences. If `n == 2` then `floor(n / 2) = 1` and no element out of 1 and 2 occurs _more than_ one time in `[1,2]`. So there isn't a majority.\n\n----\n\nAnyway, the answer to the original question is that for `[1,2]` you split it into `[1]` and `[2]`. Then `1` is the majority element on the left and `2` is the majority element on the right as per the base case. Now we have to combine the answers.\n\nWhat LeetCode's official solution does is this: Since the left and right subproblems don't agree on the majority element, you have to count the occurrences of `1` and `2` in the combined subarray. Whichever occurs more times is the majority. Here, both occur _one_ time in `[1,2]`, so it arbitrarily returns one of the elements as the majority. Let's pick the left to make the example more interesting, although LeetCode's solution actually returns the right if the counts are equal.\n\nThen when we combine `[1,2]` and `[2]` we got `1` on the left and `2` on the right. Again, they don't agree so we have to count occurrences of `1` and `2` in `[1,2,2]`. Now `2` wins so that's our answer."
                    },
                    {
                        "username": "himanshug9119",
                        "content": "You are saying in length 2 array there is no majority element why ?\\nYes there is also a majority element first one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "All those upvotes are for sure done by nerds who used either an extra O(n) space or extra time complexity which maybe n^2 or nlogn.  \nBut guys be honest did anyone solve it O(n) time and O(1) space. who has solved it like this ? \nI'm here sitting for an hour to figure out this."
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "[@emengel](/emengel) There is no O(n) sorting algorithm"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "hashing table algo"
                    },
                    {
                        "username": "leeyanleryan",
                        "content": "```\\nclass Solution \\n{\\n    public int majorityElement(int[] nums) \\n    {\\n        int count = 0;\\n        int dom = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (count == 0)\\n            {\\n                dom = nums[i];\\n                count++;\\n            }\\n            else if (dom != nums[i])\\n            {\\n                count--;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return dom;\\n    }\\n}\\n```\\n\\nThis is my solution for O(n) time and O(1) space."
                    },
                    {
                        "username": "emengel",
                        "content": "Try using an O(n) sorting algorithm that you can perform in-place (there\\'s only one that I know of). You\\'ll have to implement your own, since python\\'s sort() runs in n*log(n) time. You\\'ll find that a solution using the O(n) algorithm actually performs worse than the n*log(n) sorts. Determining the conditions under which this remains true is a fantastic exercise in complexity analysis."
                    },
                    {
                        "username": "TheOnix",
                        "content": "This is a stupid problem that only tests that you know the solution, not your problem-solving skills"
                    },
                    {
                        "username": "FindIshita",
                        "content": "moore\\'s voting algo will be helpful"
                    },
                    {
                        "username": "hanhongsun",
                        "content": "I found nobody using bit-Operation for this question.\\n\\nI will try make up a O(n) time bit operation solution. \\n\\n**No** Boyer-Moore Majority Vote Algorithm \\n**No** Hashing table"
                    },
                    {
                        "username": "simonrouse9461",
                        "content": "[@Saketyadav](/Saketyadav) This does not have linear time. It\\'s O(n log n)"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "[@mdas95](/mdas95) Arrays.sort(nums);\\nreturn nums[nums.length/2];  try this one\\n"
                    },
                    {
                        "username": "mdas95",
                        "content": "tell me more I am all ears. \\nby the way[2 2 2 1 1 1 3 3] will it solve the this set of data. I am getting majority as 3 which is not the case. Since this has no majority.\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/majority-element/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** HashMap\n\n  \n**Approach 3:** Sorting\n\n  \n**Approach 4:** Randomization\n\n  \n**Approach 5:** Divide and Conquer\n\n  \n**Approach 6:** Boyer-Moore Voting Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sofs1",
                        "content": "Why did they put this problem under \"Bit Manipulation\" when none of the 6 solutions use bit operators?"
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "I don\\'t understand why people are sorting and returning the middle element. Although it is a valid solution, the follow-up of the question is asking us to solve the problem in Linear time and not O(nlogn) time. "
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Moore\\'s Voting Algorithm Explained in Super Simple efficient way!! \\nLink : https://leetcode.com/problems/majority-element/solutions/3015428/c-moore-s-voting-algorithm-explained-in-super-simple-fast-way/ \\n\\n \\n"
                    }
                ]
            },
            {
                "id": 1571372,
                "content": [
                    {
                        "username": "singhabhay11",
                        "content": "Arrays.sort(nums);\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@cswartzell](/cswartzell) See the last line\\n`Follow-up: Could you solve the problem in linear time and in O(1) space?`"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@tanmayyyj](/tanmayyyj)  Question doesnt mention time complexity at all. The O(n) solutions are pretty trivial, its interesting to think of different ways to do it. "
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "but not the time complexity the question is asking for\\n"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "[@sanon3714](/sanon3714) That is not an valid input for this problem since the majority element is said to be occuring more than n/2 times, here n=8 so 8/2=4 no element occurs more than 4 times. Therefore not a valid input."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "majority element present more than (n / 2) times. .not n/2 times [@Shivang verma](/Shivang_Verma1)"
                    },
                    {
                        "username": "sanon3714",
                        "content": "check for this 1,2,3,4,3,5,5,5\\n"
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "[@nikhila01](/nikhila01)  thankyou so much ,now I understand."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Shivang_Verma1](/Shivang_Verma1) `[1,1,1,2,2,4]` is an invalid input since it has no majority element. The majority element has to appear **more than** `\\u230An / 2\\u230B` times. Here `1` appears **exactly** `\\u230An / 2\\u230B` times."
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "what if arr=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1 "
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "If you\\'re sorting then it\\'s not linear time"
                    },
                    {
                        "username": "jerryy147",
                        "content": "This is genius!"
                    },
                    {
                        "username": "hampuztt",
                        "content": "[@keeganasmith2003](/keeganasmith2003) Even if counting sort was used, it\\'s not O(1) space"
                    },
                    {
                        "username": "bob1123030",
                        "content": "god level code\\n"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Can you not post solutions in the Discussion ... "
                    },
                    {
                        "username": "ParasAtal05",
                        "content": "God level code"
                    },
                    {
                        "username": "Rithym",
                        "content": "God level code\\n"
                    },
                    {
                        "username": "keeganasmith2003",
                        "content": "[@wisegauravmehra](/wisegauravmehra) It is linear if counting sort is used. This is an integer container, so counting sort can be used. "
                    },
                    {
                        "username": "wisegauravmehra",
                        "content": "It\\'s not linear runtime solution."
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/6c81d433-5a1c-412b-ba0c-f08ae95baa9e_1648865936.0360248.jpeg)\\n"
                    },
                    {
                        "username": "k_praphull",
                        "content": "[@nitish07maximus](/nitish07maximus) Have you read question properly, majority element is **more than n/2**"
                    },
                    {
                        "username": "ismaelmiah",
                        "content": "[@nitish07maximus](/nitish07maximus)  This is a wrong test case. as the description says \"You may assume that the majority element always exists in the array.\" You can assume these types of case won\\'t set in judge panel."
                    },
                    {
                        "username": "junjiexu",
                        "content": "[@nitish07maximus](/nitish07maximus) But that\\'s invalid input?"
                    },
                    {
                        "username": "nitish07maximus",
                        "content": "Give wrong result for this input.\\n1,1,1,2,2,3,2,1"
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "codyli520",
                        "content": "if I have [1,1,1,2,2,2], why is 1 the majority number and not 2?"
                    },
                    {
                        "username": "mursalin777",
                        "content": "the majority element must exist more than n/2 times. That\\'s the condition. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@CT-7567](/CT-7567) In my opinion you shouldn't treat the input as a random array. The problem constraints are there for a reason and allow you to come up with more interesting and efficient algorithms, like the follow up of O(N) time and O(1) space.\n\nIf you assume you can be given any inputs then it's a different problem. If a problem asks you to merge two sorted arrays into a single sorted array, would you just pretend the inputs aren't sorted and use a less efficient algorithm? It doesn't make sense."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sagar-pro](/sagar-pro) In my opinion you should approach this question like your input is a random array. it is harder but can be work in every array"
                    },
                    {
                        "username": "sagar-pro",
                        "content": "In your case no majority element because no element exist greater than 3(6/2)times and It is given in question input will always have majority element.\n"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I have problem coming up with the divide and conquer solution.Assume the base case contains only one element, which is the majority element for the base case. Now suppose we have two elements, each one returning from the base case. Say they are 1 2. There is clearly no majority element in this two-element array. If the whole input array is 1 2 2 and you divide the problem into 1 2 and 2. Of course you pick 2 in the right half. But what to pick in the left half?"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "it telling me [2,2]=1 surely should be =2??\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "I think I had a similar problem its telling me [2,2]=1, which makes no sense it should be 2 surely??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Kalyan19111999](/Kalyan19111999) You\\'re right in general, but we\\'re specifically talking about a divide and conquer solution.\\n\\nYou break up an array like `[1, 2, 2]` into subproblems such as `[1, 2]` and `[2]`. Even though `[1, 2]` doesn\\'t have a majority element you still have to return some value from the subproblem. That\\'s what the original question was about: what do you return in that case?"
                    },
                    {
                        "username": "Kalyan19111999",
                        "content": "[@nikhila01](/nikhila01)  I\\'m not quite sure if this case of length of ```nums``` being 2 with both elements being different comes up because, according to the problem description \"You may assume that the majority element always exists in the array\" which can only happen if both elements are the same e.g: [1,1] or [2,2]. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@himanshug9119](/himanshug9119) Majority is defined as _more than_ `floor(n / 2)` occurrences. If `n == 2` then `floor(n / 2) = 1` and no element out of 1 and 2 occurs _more than_ one time in `[1,2]`. So there isn't a majority.\n\n----\n\nAnyway, the answer to the original question is that for `[1,2]` you split it into `[1]` and `[2]`. Then `1` is the majority element on the left and `2` is the majority element on the right as per the base case. Now we have to combine the answers.\n\nWhat LeetCode's official solution does is this: Since the left and right subproblems don't agree on the majority element, you have to count the occurrences of `1` and `2` in the combined subarray. Whichever occurs more times is the majority. Here, both occur _one_ time in `[1,2]`, so it arbitrarily returns one of the elements as the majority. Let's pick the left to make the example more interesting, although LeetCode's solution actually returns the right if the counts are equal.\n\nThen when we combine `[1,2]` and `[2]` we got `1` on the left and `2` on the right. Again, they don't agree so we have to count occurrences of `1` and `2` in `[1,2,2]`. Now `2` wins so that's our answer."
                    },
                    {
                        "username": "himanshug9119",
                        "content": "You are saying in length 2 array there is no majority element why ?\\nYes there is also a majority element first one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "All those upvotes are for sure done by nerds who used either an extra O(n) space or extra time complexity which maybe n^2 or nlogn.  \nBut guys be honest did anyone solve it O(n) time and O(1) space. who has solved it like this ? \nI'm here sitting for an hour to figure out this."
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "[@emengel](/emengel) There is no O(n) sorting algorithm"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "hashing table algo"
                    },
                    {
                        "username": "leeyanleryan",
                        "content": "```\\nclass Solution \\n{\\n    public int majorityElement(int[] nums) \\n    {\\n        int count = 0;\\n        int dom = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (count == 0)\\n            {\\n                dom = nums[i];\\n                count++;\\n            }\\n            else if (dom != nums[i])\\n            {\\n                count--;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return dom;\\n    }\\n}\\n```\\n\\nThis is my solution for O(n) time and O(1) space."
                    },
                    {
                        "username": "emengel",
                        "content": "Try using an O(n) sorting algorithm that you can perform in-place (there\\'s only one that I know of). You\\'ll have to implement your own, since python\\'s sort() runs in n*log(n) time. You\\'ll find that a solution using the O(n) algorithm actually performs worse than the n*log(n) sorts. Determining the conditions under which this remains true is a fantastic exercise in complexity analysis."
                    },
                    {
                        "username": "TheOnix",
                        "content": "This is a stupid problem that only tests that you know the solution, not your problem-solving skills"
                    },
                    {
                        "username": "FindIshita",
                        "content": "moore\\'s voting algo will be helpful"
                    },
                    {
                        "username": "hanhongsun",
                        "content": "I found nobody using bit-Operation for this question.\\n\\nI will try make up a O(n) time bit operation solution. \\n\\n**No** Boyer-Moore Majority Vote Algorithm \\n**No** Hashing table"
                    },
                    {
                        "username": "simonrouse9461",
                        "content": "[@Saketyadav](/Saketyadav) This does not have linear time. It\\'s O(n log n)"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "[@mdas95](/mdas95) Arrays.sort(nums);\\nreturn nums[nums.length/2];  try this one\\n"
                    },
                    {
                        "username": "mdas95",
                        "content": "tell me more I am all ears. \\nby the way[2 2 2 1 1 1 3 3] will it solve the this set of data. I am getting majority as 3 which is not the case. Since this has no majority.\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/majority-element/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** HashMap\n\n  \n**Approach 3:** Sorting\n\n  \n**Approach 4:** Randomization\n\n  \n**Approach 5:** Divide and Conquer\n\n  \n**Approach 6:** Boyer-Moore Voting Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sofs1",
                        "content": "Why did they put this problem under \"Bit Manipulation\" when none of the 6 solutions use bit operators?"
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "I don\\'t understand why people are sorting and returning the middle element. Although it is a valid solution, the follow-up of the question is asking us to solve the problem in Linear time and not O(nlogn) time. "
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Moore\\'s Voting Algorithm Explained in Super Simple efficient way!! \\nLink : https://leetcode.com/problems/majority-element/solutions/3015428/c-moore-s-voting-algorithm-explained-in-super-simple-fast-way/ \\n\\n \\n"
                    }
                ]
            },
            {
                "id": 1565664,
                "content": [
                    {
                        "username": "singhabhay11",
                        "content": "Arrays.sort(nums);\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@cswartzell](/cswartzell) See the last line\\n`Follow-up: Could you solve the problem in linear time and in O(1) space?`"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@tanmayyyj](/tanmayyyj)  Question doesnt mention time complexity at all. The O(n) solutions are pretty trivial, its interesting to think of different ways to do it. "
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "but not the time complexity the question is asking for\\n"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "[@sanon3714](/sanon3714) That is not an valid input for this problem since the majority element is said to be occuring more than n/2 times, here n=8 so 8/2=4 no element occurs more than 4 times. Therefore not a valid input."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "majority element present more than (n / 2) times. .not n/2 times [@Shivang verma](/Shivang_Verma1)"
                    },
                    {
                        "username": "sanon3714",
                        "content": "check for this 1,2,3,4,3,5,5,5\\n"
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "[@nikhila01](/nikhila01)  thankyou so much ,now I understand."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Shivang_Verma1](/Shivang_Verma1) `[1,1,1,2,2,4]` is an invalid input since it has no majority element. The majority element has to appear **more than** `\\u230An / 2\\u230B` times. Here `1` appears **exactly** `\\u230An / 2\\u230B` times."
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "what if arr=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1 "
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "If you\\'re sorting then it\\'s not linear time"
                    },
                    {
                        "username": "jerryy147",
                        "content": "This is genius!"
                    },
                    {
                        "username": "hampuztt",
                        "content": "[@keeganasmith2003](/keeganasmith2003) Even if counting sort was used, it\\'s not O(1) space"
                    },
                    {
                        "username": "bob1123030",
                        "content": "god level code\\n"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Can you not post solutions in the Discussion ... "
                    },
                    {
                        "username": "ParasAtal05",
                        "content": "God level code"
                    },
                    {
                        "username": "Rithym",
                        "content": "God level code\\n"
                    },
                    {
                        "username": "keeganasmith2003",
                        "content": "[@wisegauravmehra](/wisegauravmehra) It is linear if counting sort is used. This is an integer container, so counting sort can be used. "
                    },
                    {
                        "username": "wisegauravmehra",
                        "content": "It\\'s not linear runtime solution."
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/6c81d433-5a1c-412b-ba0c-f08ae95baa9e_1648865936.0360248.jpeg)\\n"
                    },
                    {
                        "username": "k_praphull",
                        "content": "[@nitish07maximus](/nitish07maximus) Have you read question properly, majority element is **more than n/2**"
                    },
                    {
                        "username": "ismaelmiah",
                        "content": "[@nitish07maximus](/nitish07maximus)  This is a wrong test case. as the description says \"You may assume that the majority element always exists in the array.\" You can assume these types of case won\\'t set in judge panel."
                    },
                    {
                        "username": "junjiexu",
                        "content": "[@nitish07maximus](/nitish07maximus) But that\\'s invalid input?"
                    },
                    {
                        "username": "nitish07maximus",
                        "content": "Give wrong result for this input.\\n1,1,1,2,2,3,2,1"
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "codyli520",
                        "content": "if I have [1,1,1,2,2,2], why is 1 the majority number and not 2?"
                    },
                    {
                        "username": "mursalin777",
                        "content": "the majority element must exist more than n/2 times. That\\'s the condition. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@CT-7567](/CT-7567) In my opinion you shouldn't treat the input as a random array. The problem constraints are there for a reason and allow you to come up with more interesting and efficient algorithms, like the follow up of O(N) time and O(1) space.\n\nIf you assume you can be given any inputs then it's a different problem. If a problem asks you to merge two sorted arrays into a single sorted array, would you just pretend the inputs aren't sorted and use a less efficient algorithm? It doesn't make sense."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sagar-pro](/sagar-pro) In my opinion you should approach this question like your input is a random array. it is harder but can be work in every array"
                    },
                    {
                        "username": "sagar-pro",
                        "content": "In your case no majority element because no element exist greater than 3(6/2)times and It is given in question input will always have majority element.\n"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I have problem coming up with the divide and conquer solution.Assume the base case contains only one element, which is the majority element for the base case. Now suppose we have two elements, each one returning from the base case. Say they are 1 2. There is clearly no majority element in this two-element array. If the whole input array is 1 2 2 and you divide the problem into 1 2 and 2. Of course you pick 2 in the right half. But what to pick in the left half?"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "it telling me [2,2]=1 surely should be =2??\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "I think I had a similar problem its telling me [2,2]=1, which makes no sense it should be 2 surely??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Kalyan19111999](/Kalyan19111999) You\\'re right in general, but we\\'re specifically talking about a divide and conquer solution.\\n\\nYou break up an array like `[1, 2, 2]` into subproblems such as `[1, 2]` and `[2]`. Even though `[1, 2]` doesn\\'t have a majority element you still have to return some value from the subproblem. That\\'s what the original question was about: what do you return in that case?"
                    },
                    {
                        "username": "Kalyan19111999",
                        "content": "[@nikhila01](/nikhila01)  I\\'m not quite sure if this case of length of ```nums``` being 2 with both elements being different comes up because, according to the problem description \"You may assume that the majority element always exists in the array\" which can only happen if both elements are the same e.g: [1,1] or [2,2]. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@himanshug9119](/himanshug9119) Majority is defined as _more than_ `floor(n / 2)` occurrences. If `n == 2` then `floor(n / 2) = 1` and no element out of 1 and 2 occurs _more than_ one time in `[1,2]`. So there isn't a majority.\n\n----\n\nAnyway, the answer to the original question is that for `[1,2]` you split it into `[1]` and `[2]`. Then `1` is the majority element on the left and `2` is the majority element on the right as per the base case. Now we have to combine the answers.\n\nWhat LeetCode's official solution does is this: Since the left and right subproblems don't agree on the majority element, you have to count the occurrences of `1` and `2` in the combined subarray. Whichever occurs more times is the majority. Here, both occur _one_ time in `[1,2]`, so it arbitrarily returns one of the elements as the majority. Let's pick the left to make the example more interesting, although LeetCode's solution actually returns the right if the counts are equal.\n\nThen when we combine `[1,2]` and `[2]` we got `1` on the left and `2` on the right. Again, they don't agree so we have to count occurrences of `1` and `2` in `[1,2,2]`. Now `2` wins so that's our answer."
                    },
                    {
                        "username": "himanshug9119",
                        "content": "You are saying in length 2 array there is no majority element why ?\\nYes there is also a majority element first one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "All those upvotes are for sure done by nerds who used either an extra O(n) space or extra time complexity which maybe n^2 or nlogn.  \nBut guys be honest did anyone solve it O(n) time and O(1) space. who has solved it like this ? \nI'm here sitting for an hour to figure out this."
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "[@emengel](/emengel) There is no O(n) sorting algorithm"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "hashing table algo"
                    },
                    {
                        "username": "leeyanleryan",
                        "content": "```\\nclass Solution \\n{\\n    public int majorityElement(int[] nums) \\n    {\\n        int count = 0;\\n        int dom = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (count == 0)\\n            {\\n                dom = nums[i];\\n                count++;\\n            }\\n            else if (dom != nums[i])\\n            {\\n                count--;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return dom;\\n    }\\n}\\n```\\n\\nThis is my solution for O(n) time and O(1) space."
                    },
                    {
                        "username": "emengel",
                        "content": "Try using an O(n) sorting algorithm that you can perform in-place (there\\'s only one that I know of). You\\'ll have to implement your own, since python\\'s sort() runs in n*log(n) time. You\\'ll find that a solution using the O(n) algorithm actually performs worse than the n*log(n) sorts. Determining the conditions under which this remains true is a fantastic exercise in complexity analysis."
                    },
                    {
                        "username": "TheOnix",
                        "content": "This is a stupid problem that only tests that you know the solution, not your problem-solving skills"
                    },
                    {
                        "username": "FindIshita",
                        "content": "moore\\'s voting algo will be helpful"
                    },
                    {
                        "username": "hanhongsun",
                        "content": "I found nobody using bit-Operation for this question.\\n\\nI will try make up a O(n) time bit operation solution. \\n\\n**No** Boyer-Moore Majority Vote Algorithm \\n**No** Hashing table"
                    },
                    {
                        "username": "simonrouse9461",
                        "content": "[@Saketyadav](/Saketyadav) This does not have linear time. It\\'s O(n log n)"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "[@mdas95](/mdas95) Arrays.sort(nums);\\nreturn nums[nums.length/2];  try this one\\n"
                    },
                    {
                        "username": "mdas95",
                        "content": "tell me more I am all ears. \\nby the way[2 2 2 1 1 1 3 3] will it solve the this set of data. I am getting majority as 3 which is not the case. Since this has no majority.\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/majority-element/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** HashMap\n\n  \n**Approach 3:** Sorting\n\n  \n**Approach 4:** Randomization\n\n  \n**Approach 5:** Divide and Conquer\n\n  \n**Approach 6:** Boyer-Moore Voting Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sofs1",
                        "content": "Why did they put this problem under \"Bit Manipulation\" when none of the 6 solutions use bit operators?"
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "I don\\'t understand why people are sorting and returning the middle element. Although it is a valid solution, the follow-up of the question is asking us to solve the problem in Linear time and not O(nlogn) time. "
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Moore\\'s Voting Algorithm Explained in Super Simple efficient way!! \\nLink : https://leetcode.com/problems/majority-element/solutions/3015428/c-moore-s-voting-algorithm-explained-in-super-simple-fast-way/ \\n\\n \\n"
                    }
                ]
            },
            {
                "id": 1834161,
                "content": [
                    {
                        "username": "singhabhay11",
                        "content": "Arrays.sort(nums);\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@cswartzell](/cswartzell) See the last line\\n`Follow-up: Could you solve the problem in linear time and in O(1) space?`"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@tanmayyyj](/tanmayyyj)  Question doesnt mention time complexity at all. The O(n) solutions are pretty trivial, its interesting to think of different ways to do it. "
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "but not the time complexity the question is asking for\\n"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "[@sanon3714](/sanon3714) That is not an valid input for this problem since the majority element is said to be occuring more than n/2 times, here n=8 so 8/2=4 no element occurs more than 4 times. Therefore not a valid input."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "majority element present more than (n / 2) times. .not n/2 times [@Shivang verma](/Shivang_Verma1)"
                    },
                    {
                        "username": "sanon3714",
                        "content": "check for this 1,2,3,4,3,5,5,5\\n"
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "[@nikhila01](/nikhila01)  thankyou so much ,now I understand."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Shivang_Verma1](/Shivang_Verma1) `[1,1,1,2,2,4]` is an invalid input since it has no majority element. The majority element has to appear **more than** `\\u230An / 2\\u230B` times. Here `1` appears **exactly** `\\u230An / 2\\u230B` times."
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "what if arr=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1 "
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "If you\\'re sorting then it\\'s not linear time"
                    },
                    {
                        "username": "jerryy147",
                        "content": "This is genius!"
                    },
                    {
                        "username": "hampuztt",
                        "content": "[@keeganasmith2003](/keeganasmith2003) Even if counting sort was used, it\\'s not O(1) space"
                    },
                    {
                        "username": "bob1123030",
                        "content": "god level code\\n"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Can you not post solutions in the Discussion ... "
                    },
                    {
                        "username": "ParasAtal05",
                        "content": "God level code"
                    },
                    {
                        "username": "Rithym",
                        "content": "God level code\\n"
                    },
                    {
                        "username": "keeganasmith2003",
                        "content": "[@wisegauravmehra](/wisegauravmehra) It is linear if counting sort is used. This is an integer container, so counting sort can be used. "
                    },
                    {
                        "username": "wisegauravmehra",
                        "content": "It\\'s not linear runtime solution."
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/6c81d433-5a1c-412b-ba0c-f08ae95baa9e_1648865936.0360248.jpeg)\\n"
                    },
                    {
                        "username": "k_praphull",
                        "content": "[@nitish07maximus](/nitish07maximus) Have you read question properly, majority element is **more than n/2**"
                    },
                    {
                        "username": "ismaelmiah",
                        "content": "[@nitish07maximus](/nitish07maximus)  This is a wrong test case. as the description says \"You may assume that the majority element always exists in the array.\" You can assume these types of case won\\'t set in judge panel."
                    },
                    {
                        "username": "junjiexu",
                        "content": "[@nitish07maximus](/nitish07maximus) But that\\'s invalid input?"
                    },
                    {
                        "username": "nitish07maximus",
                        "content": "Give wrong result for this input.\\n1,1,1,2,2,3,2,1"
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "codyli520",
                        "content": "if I have [1,1,1,2,2,2], why is 1 the majority number and not 2?"
                    },
                    {
                        "username": "mursalin777",
                        "content": "the majority element must exist more than n/2 times. That\\'s the condition. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@CT-7567](/CT-7567) In my opinion you shouldn't treat the input as a random array. The problem constraints are there for a reason and allow you to come up with more interesting and efficient algorithms, like the follow up of O(N) time and O(1) space.\n\nIf you assume you can be given any inputs then it's a different problem. If a problem asks you to merge two sorted arrays into a single sorted array, would you just pretend the inputs aren't sorted and use a less efficient algorithm? It doesn't make sense."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sagar-pro](/sagar-pro) In my opinion you should approach this question like your input is a random array. it is harder but can be work in every array"
                    },
                    {
                        "username": "sagar-pro",
                        "content": "In your case no majority element because no element exist greater than 3(6/2)times and It is given in question input will always have majority element.\n"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I have problem coming up with the divide and conquer solution.Assume the base case contains only one element, which is the majority element for the base case. Now suppose we have two elements, each one returning from the base case. Say they are 1 2. There is clearly no majority element in this two-element array. If the whole input array is 1 2 2 and you divide the problem into 1 2 and 2. Of course you pick 2 in the right half. But what to pick in the left half?"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "it telling me [2,2]=1 surely should be =2??\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "I think I had a similar problem its telling me [2,2]=1, which makes no sense it should be 2 surely??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Kalyan19111999](/Kalyan19111999) You\\'re right in general, but we\\'re specifically talking about a divide and conquer solution.\\n\\nYou break up an array like `[1, 2, 2]` into subproblems such as `[1, 2]` and `[2]`. Even though `[1, 2]` doesn\\'t have a majority element you still have to return some value from the subproblem. That\\'s what the original question was about: what do you return in that case?"
                    },
                    {
                        "username": "Kalyan19111999",
                        "content": "[@nikhila01](/nikhila01)  I\\'m not quite sure if this case of length of ```nums``` being 2 with both elements being different comes up because, according to the problem description \"You may assume that the majority element always exists in the array\" which can only happen if both elements are the same e.g: [1,1] or [2,2]. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@himanshug9119](/himanshug9119) Majority is defined as _more than_ `floor(n / 2)` occurrences. If `n == 2` then `floor(n / 2) = 1` and no element out of 1 and 2 occurs _more than_ one time in `[1,2]`. So there isn't a majority.\n\n----\n\nAnyway, the answer to the original question is that for `[1,2]` you split it into `[1]` and `[2]`. Then `1` is the majority element on the left and `2` is the majority element on the right as per the base case. Now we have to combine the answers.\n\nWhat LeetCode's official solution does is this: Since the left and right subproblems don't agree on the majority element, you have to count the occurrences of `1` and `2` in the combined subarray. Whichever occurs more times is the majority. Here, both occur _one_ time in `[1,2]`, so it arbitrarily returns one of the elements as the majority. Let's pick the left to make the example more interesting, although LeetCode's solution actually returns the right if the counts are equal.\n\nThen when we combine `[1,2]` and `[2]` we got `1` on the left and `2` on the right. Again, they don't agree so we have to count occurrences of `1` and `2` in `[1,2,2]`. Now `2` wins so that's our answer."
                    },
                    {
                        "username": "himanshug9119",
                        "content": "You are saying in length 2 array there is no majority element why ?\\nYes there is also a majority element first one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "All those upvotes are for sure done by nerds who used either an extra O(n) space or extra time complexity which maybe n^2 or nlogn.  \nBut guys be honest did anyone solve it O(n) time and O(1) space. who has solved it like this ? \nI'm here sitting for an hour to figure out this."
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "[@emengel](/emengel) There is no O(n) sorting algorithm"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "hashing table algo"
                    },
                    {
                        "username": "leeyanleryan",
                        "content": "```\\nclass Solution \\n{\\n    public int majorityElement(int[] nums) \\n    {\\n        int count = 0;\\n        int dom = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (count == 0)\\n            {\\n                dom = nums[i];\\n                count++;\\n            }\\n            else if (dom != nums[i])\\n            {\\n                count--;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return dom;\\n    }\\n}\\n```\\n\\nThis is my solution for O(n) time and O(1) space."
                    },
                    {
                        "username": "emengel",
                        "content": "Try using an O(n) sorting algorithm that you can perform in-place (there\\'s only one that I know of). You\\'ll have to implement your own, since python\\'s sort() runs in n*log(n) time. You\\'ll find that a solution using the O(n) algorithm actually performs worse than the n*log(n) sorts. Determining the conditions under which this remains true is a fantastic exercise in complexity analysis."
                    },
                    {
                        "username": "TheOnix",
                        "content": "This is a stupid problem that only tests that you know the solution, not your problem-solving skills"
                    },
                    {
                        "username": "FindIshita",
                        "content": "moore\\'s voting algo will be helpful"
                    },
                    {
                        "username": "hanhongsun",
                        "content": "I found nobody using bit-Operation for this question.\\n\\nI will try make up a O(n) time bit operation solution. \\n\\n**No** Boyer-Moore Majority Vote Algorithm \\n**No** Hashing table"
                    },
                    {
                        "username": "simonrouse9461",
                        "content": "[@Saketyadav](/Saketyadav) This does not have linear time. It\\'s O(n log n)"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "[@mdas95](/mdas95) Arrays.sort(nums);\\nreturn nums[nums.length/2];  try this one\\n"
                    },
                    {
                        "username": "mdas95",
                        "content": "tell me more I am all ears. \\nby the way[2 2 2 1 1 1 3 3] will it solve the this set of data. I am getting majority as 3 which is not the case. Since this has no majority.\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/majority-element/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** HashMap\n\n  \n**Approach 3:** Sorting\n\n  \n**Approach 4:** Randomization\n\n  \n**Approach 5:** Divide and Conquer\n\n  \n**Approach 6:** Boyer-Moore Voting Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sofs1",
                        "content": "Why did they put this problem under \"Bit Manipulation\" when none of the 6 solutions use bit operators?"
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "I don\\'t understand why people are sorting and returning the middle element. Although it is a valid solution, the follow-up of the question is asking us to solve the problem in Linear time and not O(nlogn) time. "
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Moore\\'s Voting Algorithm Explained in Super Simple efficient way!! \\nLink : https://leetcode.com/problems/majority-element/solutions/3015428/c-moore-s-voting-algorithm-explained-in-super-simple-fast-way/ \\n\\n \\n"
                    }
                ]
            },
            {
                "id": 1567899,
                "content": [
                    {
                        "username": "singhabhay11",
                        "content": "Arrays.sort(nums);\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@cswartzell](/cswartzell) See the last line\\n`Follow-up: Could you solve the problem in linear time and in O(1) space?`"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@tanmayyyj](/tanmayyyj)  Question doesnt mention time complexity at all. The O(n) solutions are pretty trivial, its interesting to think of different ways to do it. "
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "but not the time complexity the question is asking for\\n"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "[@sanon3714](/sanon3714) That is not an valid input for this problem since the majority element is said to be occuring more than n/2 times, here n=8 so 8/2=4 no element occurs more than 4 times. Therefore not a valid input."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "majority element present more than (n / 2) times. .not n/2 times [@Shivang verma](/Shivang_Verma1)"
                    },
                    {
                        "username": "sanon3714",
                        "content": "check for this 1,2,3,4,3,5,5,5\\n"
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "[@nikhila01](/nikhila01)  thankyou so much ,now I understand."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Shivang_Verma1](/Shivang_Verma1) `[1,1,1,2,2,4]` is an invalid input since it has no majority element. The majority element has to appear **more than** `\\u230An / 2\\u230B` times. Here `1` appears **exactly** `\\u230An / 2\\u230B` times."
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "what if arr=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1 "
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "If you\\'re sorting then it\\'s not linear time"
                    },
                    {
                        "username": "jerryy147",
                        "content": "This is genius!"
                    },
                    {
                        "username": "hampuztt",
                        "content": "[@keeganasmith2003](/keeganasmith2003) Even if counting sort was used, it\\'s not O(1) space"
                    },
                    {
                        "username": "bob1123030",
                        "content": "god level code\\n"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Can you not post solutions in the Discussion ... "
                    },
                    {
                        "username": "ParasAtal05",
                        "content": "God level code"
                    },
                    {
                        "username": "Rithym",
                        "content": "God level code\\n"
                    },
                    {
                        "username": "keeganasmith2003",
                        "content": "[@wisegauravmehra](/wisegauravmehra) It is linear if counting sort is used. This is an integer container, so counting sort can be used. "
                    },
                    {
                        "username": "wisegauravmehra",
                        "content": "It\\'s not linear runtime solution."
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/6c81d433-5a1c-412b-ba0c-f08ae95baa9e_1648865936.0360248.jpeg)\\n"
                    },
                    {
                        "username": "k_praphull",
                        "content": "[@nitish07maximus](/nitish07maximus) Have you read question properly, majority element is **more than n/2**"
                    },
                    {
                        "username": "ismaelmiah",
                        "content": "[@nitish07maximus](/nitish07maximus)  This is a wrong test case. as the description says \"You may assume that the majority element always exists in the array.\" You can assume these types of case won\\'t set in judge panel."
                    },
                    {
                        "username": "junjiexu",
                        "content": "[@nitish07maximus](/nitish07maximus) But that\\'s invalid input?"
                    },
                    {
                        "username": "nitish07maximus",
                        "content": "Give wrong result for this input.\\n1,1,1,2,2,3,2,1"
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "codyli520",
                        "content": "if I have [1,1,1,2,2,2], why is 1 the majority number and not 2?"
                    },
                    {
                        "username": "mursalin777",
                        "content": "the majority element must exist more than n/2 times. That\\'s the condition. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@CT-7567](/CT-7567) In my opinion you shouldn't treat the input as a random array. The problem constraints are there for a reason and allow you to come up with more interesting and efficient algorithms, like the follow up of O(N) time and O(1) space.\n\nIf you assume you can be given any inputs then it's a different problem. If a problem asks you to merge two sorted arrays into a single sorted array, would you just pretend the inputs aren't sorted and use a less efficient algorithm? It doesn't make sense."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sagar-pro](/sagar-pro) In my opinion you should approach this question like your input is a random array. it is harder but can be work in every array"
                    },
                    {
                        "username": "sagar-pro",
                        "content": "In your case no majority element because no element exist greater than 3(6/2)times and It is given in question input will always have majority element.\n"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I have problem coming up with the divide and conquer solution.Assume the base case contains only one element, which is the majority element for the base case. Now suppose we have two elements, each one returning from the base case. Say they are 1 2. There is clearly no majority element in this two-element array. If the whole input array is 1 2 2 and you divide the problem into 1 2 and 2. Of course you pick 2 in the right half. But what to pick in the left half?"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "it telling me [2,2]=1 surely should be =2??\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "I think I had a similar problem its telling me [2,2]=1, which makes no sense it should be 2 surely??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Kalyan19111999](/Kalyan19111999) You\\'re right in general, but we\\'re specifically talking about a divide and conquer solution.\\n\\nYou break up an array like `[1, 2, 2]` into subproblems such as `[1, 2]` and `[2]`. Even though `[1, 2]` doesn\\'t have a majority element you still have to return some value from the subproblem. That\\'s what the original question was about: what do you return in that case?"
                    },
                    {
                        "username": "Kalyan19111999",
                        "content": "[@nikhila01](/nikhila01)  I\\'m not quite sure if this case of length of ```nums``` being 2 with both elements being different comes up because, according to the problem description \"You may assume that the majority element always exists in the array\" which can only happen if both elements are the same e.g: [1,1] or [2,2]. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@himanshug9119](/himanshug9119) Majority is defined as _more than_ `floor(n / 2)` occurrences. If `n == 2` then `floor(n / 2) = 1` and no element out of 1 and 2 occurs _more than_ one time in `[1,2]`. So there isn't a majority.\n\n----\n\nAnyway, the answer to the original question is that for `[1,2]` you split it into `[1]` and `[2]`. Then `1` is the majority element on the left and `2` is the majority element on the right as per the base case. Now we have to combine the answers.\n\nWhat LeetCode's official solution does is this: Since the left and right subproblems don't agree on the majority element, you have to count the occurrences of `1` and `2` in the combined subarray. Whichever occurs more times is the majority. Here, both occur _one_ time in `[1,2]`, so it arbitrarily returns one of the elements as the majority. Let's pick the left to make the example more interesting, although LeetCode's solution actually returns the right if the counts are equal.\n\nThen when we combine `[1,2]` and `[2]` we got `1` on the left and `2` on the right. Again, they don't agree so we have to count occurrences of `1` and `2` in `[1,2,2]`. Now `2` wins so that's our answer."
                    },
                    {
                        "username": "himanshug9119",
                        "content": "You are saying in length 2 array there is no majority element why ?\\nYes there is also a majority element first one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "All those upvotes are for sure done by nerds who used either an extra O(n) space or extra time complexity which maybe n^2 or nlogn.  \nBut guys be honest did anyone solve it O(n) time and O(1) space. who has solved it like this ? \nI'm here sitting for an hour to figure out this."
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "[@emengel](/emengel) There is no O(n) sorting algorithm"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "hashing table algo"
                    },
                    {
                        "username": "leeyanleryan",
                        "content": "```\\nclass Solution \\n{\\n    public int majorityElement(int[] nums) \\n    {\\n        int count = 0;\\n        int dom = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (count == 0)\\n            {\\n                dom = nums[i];\\n                count++;\\n            }\\n            else if (dom != nums[i])\\n            {\\n                count--;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return dom;\\n    }\\n}\\n```\\n\\nThis is my solution for O(n) time and O(1) space."
                    },
                    {
                        "username": "emengel",
                        "content": "Try using an O(n) sorting algorithm that you can perform in-place (there\\'s only one that I know of). You\\'ll have to implement your own, since python\\'s sort() runs in n*log(n) time. You\\'ll find that a solution using the O(n) algorithm actually performs worse than the n*log(n) sorts. Determining the conditions under which this remains true is a fantastic exercise in complexity analysis."
                    },
                    {
                        "username": "TheOnix",
                        "content": "This is a stupid problem that only tests that you know the solution, not your problem-solving skills"
                    },
                    {
                        "username": "FindIshita",
                        "content": "moore\\'s voting algo will be helpful"
                    },
                    {
                        "username": "hanhongsun",
                        "content": "I found nobody using bit-Operation for this question.\\n\\nI will try make up a O(n) time bit operation solution. \\n\\n**No** Boyer-Moore Majority Vote Algorithm \\n**No** Hashing table"
                    },
                    {
                        "username": "simonrouse9461",
                        "content": "[@Saketyadav](/Saketyadav) This does not have linear time. It\\'s O(n log n)"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "[@mdas95](/mdas95) Arrays.sort(nums);\\nreturn nums[nums.length/2];  try this one\\n"
                    },
                    {
                        "username": "mdas95",
                        "content": "tell me more I am all ears. \\nby the way[2 2 2 1 1 1 3 3] will it solve the this set of data. I am getting majority as 3 which is not the case. Since this has no majority.\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/majority-element/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** HashMap\n\n  \n**Approach 3:** Sorting\n\n  \n**Approach 4:** Randomization\n\n  \n**Approach 5:** Divide and Conquer\n\n  \n**Approach 6:** Boyer-Moore Voting Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sofs1",
                        "content": "Why did they put this problem under \"Bit Manipulation\" when none of the 6 solutions use bit operators?"
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "I don\\'t understand why people are sorting and returning the middle element. Although it is a valid solution, the follow-up of the question is asking us to solve the problem in Linear time and not O(nlogn) time. "
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Moore\\'s Voting Algorithm Explained in Super Simple efficient way!! \\nLink : https://leetcode.com/problems/majority-element/solutions/3015428/c-moore-s-voting-algorithm-explained-in-super-simple-fast-way/ \\n\\n \\n"
                    }
                ]
            },
            {
                "id": 1565812,
                "content": [
                    {
                        "username": "singhabhay11",
                        "content": "Arrays.sort(nums);\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@cswartzell](/cswartzell) See the last line\\n`Follow-up: Could you solve the problem in linear time and in O(1) space?`"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@tanmayyyj](/tanmayyyj)  Question doesnt mention time complexity at all. The O(n) solutions are pretty trivial, its interesting to think of different ways to do it. "
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "but not the time complexity the question is asking for\\n"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "[@sanon3714](/sanon3714) That is not an valid input for this problem since the majority element is said to be occuring more than n/2 times, here n=8 so 8/2=4 no element occurs more than 4 times. Therefore not a valid input."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "majority element present more than (n / 2) times. .not n/2 times [@Shivang verma](/Shivang_Verma1)"
                    },
                    {
                        "username": "sanon3714",
                        "content": "check for this 1,2,3,4,3,5,5,5\\n"
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "[@nikhila01](/nikhila01)  thankyou so much ,now I understand."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Shivang_Verma1](/Shivang_Verma1) `[1,1,1,2,2,4]` is an invalid input since it has no majority element. The majority element has to appear **more than** `\\u230An / 2\\u230B` times. Here `1` appears **exactly** `\\u230An / 2\\u230B` times."
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "what if arr=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1 "
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "If you\\'re sorting then it\\'s not linear time"
                    },
                    {
                        "username": "jerryy147",
                        "content": "This is genius!"
                    },
                    {
                        "username": "hampuztt",
                        "content": "[@keeganasmith2003](/keeganasmith2003) Even if counting sort was used, it\\'s not O(1) space"
                    },
                    {
                        "username": "bob1123030",
                        "content": "god level code\\n"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Can you not post solutions in the Discussion ... "
                    },
                    {
                        "username": "ParasAtal05",
                        "content": "God level code"
                    },
                    {
                        "username": "Rithym",
                        "content": "God level code\\n"
                    },
                    {
                        "username": "keeganasmith2003",
                        "content": "[@wisegauravmehra](/wisegauravmehra) It is linear if counting sort is used. This is an integer container, so counting sort can be used. "
                    },
                    {
                        "username": "wisegauravmehra",
                        "content": "It\\'s not linear runtime solution."
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/6c81d433-5a1c-412b-ba0c-f08ae95baa9e_1648865936.0360248.jpeg)\\n"
                    },
                    {
                        "username": "k_praphull",
                        "content": "[@nitish07maximus](/nitish07maximus) Have you read question properly, majority element is **more than n/2**"
                    },
                    {
                        "username": "ismaelmiah",
                        "content": "[@nitish07maximus](/nitish07maximus)  This is a wrong test case. as the description says \"You may assume that the majority element always exists in the array.\" You can assume these types of case won\\'t set in judge panel."
                    },
                    {
                        "username": "junjiexu",
                        "content": "[@nitish07maximus](/nitish07maximus) But that\\'s invalid input?"
                    },
                    {
                        "username": "nitish07maximus",
                        "content": "Give wrong result for this input.\\n1,1,1,2,2,3,2,1"
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "codyli520",
                        "content": "if I have [1,1,1,2,2,2], why is 1 the majority number and not 2?"
                    },
                    {
                        "username": "mursalin777",
                        "content": "the majority element must exist more than n/2 times. That\\'s the condition. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@CT-7567](/CT-7567) In my opinion you shouldn't treat the input as a random array. The problem constraints are there for a reason and allow you to come up with more interesting and efficient algorithms, like the follow up of O(N) time and O(1) space.\n\nIf you assume you can be given any inputs then it's a different problem. If a problem asks you to merge two sorted arrays into a single sorted array, would you just pretend the inputs aren't sorted and use a less efficient algorithm? It doesn't make sense."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sagar-pro](/sagar-pro) In my opinion you should approach this question like your input is a random array. it is harder but can be work in every array"
                    },
                    {
                        "username": "sagar-pro",
                        "content": "In your case no majority element because no element exist greater than 3(6/2)times and It is given in question input will always have majority element.\n"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I have problem coming up with the divide and conquer solution.Assume the base case contains only one element, which is the majority element for the base case. Now suppose we have two elements, each one returning from the base case. Say they are 1 2. There is clearly no majority element in this two-element array. If the whole input array is 1 2 2 and you divide the problem into 1 2 and 2. Of course you pick 2 in the right half. But what to pick in the left half?"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "it telling me [2,2]=1 surely should be =2??\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "I think I had a similar problem its telling me [2,2]=1, which makes no sense it should be 2 surely??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Kalyan19111999](/Kalyan19111999) You\\'re right in general, but we\\'re specifically talking about a divide and conquer solution.\\n\\nYou break up an array like `[1, 2, 2]` into subproblems such as `[1, 2]` and `[2]`. Even though `[1, 2]` doesn\\'t have a majority element you still have to return some value from the subproblem. That\\'s what the original question was about: what do you return in that case?"
                    },
                    {
                        "username": "Kalyan19111999",
                        "content": "[@nikhila01](/nikhila01)  I\\'m not quite sure if this case of length of ```nums``` being 2 with both elements being different comes up because, according to the problem description \"You may assume that the majority element always exists in the array\" which can only happen if both elements are the same e.g: [1,1] or [2,2]. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@himanshug9119](/himanshug9119) Majority is defined as _more than_ `floor(n / 2)` occurrences. If `n == 2` then `floor(n / 2) = 1` and no element out of 1 and 2 occurs _more than_ one time in `[1,2]`. So there isn't a majority.\n\n----\n\nAnyway, the answer to the original question is that for `[1,2]` you split it into `[1]` and `[2]`. Then `1` is the majority element on the left and `2` is the majority element on the right as per the base case. Now we have to combine the answers.\n\nWhat LeetCode's official solution does is this: Since the left and right subproblems don't agree on the majority element, you have to count the occurrences of `1` and `2` in the combined subarray. Whichever occurs more times is the majority. Here, both occur _one_ time in `[1,2]`, so it arbitrarily returns one of the elements as the majority. Let's pick the left to make the example more interesting, although LeetCode's solution actually returns the right if the counts are equal.\n\nThen when we combine `[1,2]` and `[2]` we got `1` on the left and `2` on the right. Again, they don't agree so we have to count occurrences of `1` and `2` in `[1,2,2]`. Now `2` wins so that's our answer."
                    },
                    {
                        "username": "himanshug9119",
                        "content": "You are saying in length 2 array there is no majority element why ?\\nYes there is also a majority element first one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "All those upvotes are for sure done by nerds who used either an extra O(n) space or extra time complexity which maybe n^2 or nlogn.  \nBut guys be honest did anyone solve it O(n) time and O(1) space. who has solved it like this ? \nI'm here sitting for an hour to figure out this."
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "[@emengel](/emengel) There is no O(n) sorting algorithm"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "hashing table algo"
                    },
                    {
                        "username": "leeyanleryan",
                        "content": "```\\nclass Solution \\n{\\n    public int majorityElement(int[] nums) \\n    {\\n        int count = 0;\\n        int dom = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (count == 0)\\n            {\\n                dom = nums[i];\\n                count++;\\n            }\\n            else if (dom != nums[i])\\n            {\\n                count--;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return dom;\\n    }\\n}\\n```\\n\\nThis is my solution for O(n) time and O(1) space."
                    },
                    {
                        "username": "emengel",
                        "content": "Try using an O(n) sorting algorithm that you can perform in-place (there\\'s only one that I know of). You\\'ll have to implement your own, since python\\'s sort() runs in n*log(n) time. You\\'ll find that a solution using the O(n) algorithm actually performs worse than the n*log(n) sorts. Determining the conditions under which this remains true is a fantastic exercise in complexity analysis."
                    },
                    {
                        "username": "TheOnix",
                        "content": "This is a stupid problem that only tests that you know the solution, not your problem-solving skills"
                    },
                    {
                        "username": "FindIshita",
                        "content": "moore\\'s voting algo will be helpful"
                    },
                    {
                        "username": "hanhongsun",
                        "content": "I found nobody using bit-Operation for this question.\\n\\nI will try make up a O(n) time bit operation solution. \\n\\n**No** Boyer-Moore Majority Vote Algorithm \\n**No** Hashing table"
                    },
                    {
                        "username": "simonrouse9461",
                        "content": "[@Saketyadav](/Saketyadav) This does not have linear time. It\\'s O(n log n)"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "[@mdas95](/mdas95) Arrays.sort(nums);\\nreturn nums[nums.length/2];  try this one\\n"
                    },
                    {
                        "username": "mdas95",
                        "content": "tell me more I am all ears. \\nby the way[2 2 2 1 1 1 3 3] will it solve the this set of data. I am getting majority as 3 which is not the case. Since this has no majority.\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/majority-element/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** HashMap\n\n  \n**Approach 3:** Sorting\n\n  \n**Approach 4:** Randomization\n\n  \n**Approach 5:** Divide and Conquer\n\n  \n**Approach 6:** Boyer-Moore Voting Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sofs1",
                        "content": "Why did they put this problem under \"Bit Manipulation\" when none of the 6 solutions use bit operators?"
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "I don\\'t understand why people are sorting and returning the middle element. Although it is a valid solution, the follow-up of the question is asking us to solve the problem in Linear time and not O(nlogn) time. "
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Moore\\'s Voting Algorithm Explained in Super Simple efficient way!! \\nLink : https://leetcode.com/problems/majority-element/solutions/3015428/c-moore-s-voting-algorithm-explained-in-super-simple-fast-way/ \\n\\n \\n"
                    }
                ]
            },
            {
                "id": 1572220,
                "content": [
                    {
                        "username": "singhabhay11",
                        "content": "Arrays.sort(nums);\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@cswartzell](/cswartzell) See the last line\\n`Follow-up: Could you solve the problem in linear time and in O(1) space?`"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@tanmayyyj](/tanmayyyj)  Question doesnt mention time complexity at all. The O(n) solutions are pretty trivial, its interesting to think of different ways to do it. "
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "but not the time complexity the question is asking for\\n"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "[@sanon3714](/sanon3714) That is not an valid input for this problem since the majority element is said to be occuring more than n/2 times, here n=8 so 8/2=4 no element occurs more than 4 times. Therefore not a valid input."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "majority element present more than (n / 2) times. .not n/2 times [@Shivang verma](/Shivang_Verma1)"
                    },
                    {
                        "username": "sanon3714",
                        "content": "check for this 1,2,3,4,3,5,5,5\\n"
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "[@nikhila01](/nikhila01)  thankyou so much ,now I understand."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Shivang_Verma1](/Shivang_Verma1) `[1,1,1,2,2,4]` is an invalid input since it has no majority element. The majority element has to appear **more than** `\\u230An / 2\\u230B` times. Here `1` appears **exactly** `\\u230An / 2\\u230B` times."
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "what if arr=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1 "
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "If you\\'re sorting then it\\'s not linear time"
                    },
                    {
                        "username": "jerryy147",
                        "content": "This is genius!"
                    },
                    {
                        "username": "hampuztt",
                        "content": "[@keeganasmith2003](/keeganasmith2003) Even if counting sort was used, it\\'s not O(1) space"
                    },
                    {
                        "username": "bob1123030",
                        "content": "god level code\\n"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Can you not post solutions in the Discussion ... "
                    },
                    {
                        "username": "ParasAtal05",
                        "content": "God level code"
                    },
                    {
                        "username": "Rithym",
                        "content": "God level code\\n"
                    },
                    {
                        "username": "keeganasmith2003",
                        "content": "[@wisegauravmehra](/wisegauravmehra) It is linear if counting sort is used. This is an integer container, so counting sort can be used. "
                    },
                    {
                        "username": "wisegauravmehra",
                        "content": "It\\'s not linear runtime solution."
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/6c81d433-5a1c-412b-ba0c-f08ae95baa9e_1648865936.0360248.jpeg)\\n"
                    },
                    {
                        "username": "k_praphull",
                        "content": "[@nitish07maximus](/nitish07maximus) Have you read question properly, majority element is **more than n/2**"
                    },
                    {
                        "username": "ismaelmiah",
                        "content": "[@nitish07maximus](/nitish07maximus)  This is a wrong test case. as the description says \"You may assume that the majority element always exists in the array.\" You can assume these types of case won\\'t set in judge panel."
                    },
                    {
                        "username": "junjiexu",
                        "content": "[@nitish07maximus](/nitish07maximus) But that\\'s invalid input?"
                    },
                    {
                        "username": "nitish07maximus",
                        "content": "Give wrong result for this input.\\n1,1,1,2,2,3,2,1"
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "codyli520",
                        "content": "if I have [1,1,1,2,2,2], why is 1 the majority number and not 2?"
                    },
                    {
                        "username": "mursalin777",
                        "content": "the majority element must exist more than n/2 times. That\\'s the condition. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@CT-7567](/CT-7567) In my opinion you shouldn't treat the input as a random array. The problem constraints are there for a reason and allow you to come up with more interesting and efficient algorithms, like the follow up of O(N) time and O(1) space.\n\nIf you assume you can be given any inputs then it's a different problem. If a problem asks you to merge two sorted arrays into a single sorted array, would you just pretend the inputs aren't sorted and use a less efficient algorithm? It doesn't make sense."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sagar-pro](/sagar-pro) In my opinion you should approach this question like your input is a random array. it is harder but can be work in every array"
                    },
                    {
                        "username": "sagar-pro",
                        "content": "In your case no majority element because no element exist greater than 3(6/2)times and It is given in question input will always have majority element.\n"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I have problem coming up with the divide and conquer solution.Assume the base case contains only one element, which is the majority element for the base case. Now suppose we have two elements, each one returning from the base case. Say they are 1 2. There is clearly no majority element in this two-element array. If the whole input array is 1 2 2 and you divide the problem into 1 2 and 2. Of course you pick 2 in the right half. But what to pick in the left half?"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "it telling me [2,2]=1 surely should be =2??\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "I think I had a similar problem its telling me [2,2]=1, which makes no sense it should be 2 surely??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Kalyan19111999](/Kalyan19111999) You\\'re right in general, but we\\'re specifically talking about a divide and conquer solution.\\n\\nYou break up an array like `[1, 2, 2]` into subproblems such as `[1, 2]` and `[2]`. Even though `[1, 2]` doesn\\'t have a majority element you still have to return some value from the subproblem. That\\'s what the original question was about: what do you return in that case?"
                    },
                    {
                        "username": "Kalyan19111999",
                        "content": "[@nikhila01](/nikhila01)  I\\'m not quite sure if this case of length of ```nums``` being 2 with both elements being different comes up because, according to the problem description \"You may assume that the majority element always exists in the array\" which can only happen if both elements are the same e.g: [1,1] or [2,2]. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@himanshug9119](/himanshug9119) Majority is defined as _more than_ `floor(n / 2)` occurrences. If `n == 2` then `floor(n / 2) = 1` and no element out of 1 and 2 occurs _more than_ one time in `[1,2]`. So there isn't a majority.\n\n----\n\nAnyway, the answer to the original question is that for `[1,2]` you split it into `[1]` and `[2]`. Then `1` is the majority element on the left and `2` is the majority element on the right as per the base case. Now we have to combine the answers.\n\nWhat LeetCode's official solution does is this: Since the left and right subproblems don't agree on the majority element, you have to count the occurrences of `1` and `2` in the combined subarray. Whichever occurs more times is the majority. Here, both occur _one_ time in `[1,2]`, so it arbitrarily returns one of the elements as the majority. Let's pick the left to make the example more interesting, although LeetCode's solution actually returns the right if the counts are equal.\n\nThen when we combine `[1,2]` and `[2]` we got `1` on the left and `2` on the right. Again, they don't agree so we have to count occurrences of `1` and `2` in `[1,2,2]`. Now `2` wins so that's our answer."
                    },
                    {
                        "username": "himanshug9119",
                        "content": "You are saying in length 2 array there is no majority element why ?\\nYes there is also a majority element first one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "All those upvotes are for sure done by nerds who used either an extra O(n) space or extra time complexity which maybe n^2 or nlogn.  \nBut guys be honest did anyone solve it O(n) time and O(1) space. who has solved it like this ? \nI'm here sitting for an hour to figure out this."
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "[@emengel](/emengel) There is no O(n) sorting algorithm"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "hashing table algo"
                    },
                    {
                        "username": "leeyanleryan",
                        "content": "```\\nclass Solution \\n{\\n    public int majorityElement(int[] nums) \\n    {\\n        int count = 0;\\n        int dom = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (count == 0)\\n            {\\n                dom = nums[i];\\n                count++;\\n            }\\n            else if (dom != nums[i])\\n            {\\n                count--;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return dom;\\n    }\\n}\\n```\\n\\nThis is my solution for O(n) time and O(1) space."
                    },
                    {
                        "username": "emengel",
                        "content": "Try using an O(n) sorting algorithm that you can perform in-place (there\\'s only one that I know of). You\\'ll have to implement your own, since python\\'s sort() runs in n*log(n) time. You\\'ll find that a solution using the O(n) algorithm actually performs worse than the n*log(n) sorts. Determining the conditions under which this remains true is a fantastic exercise in complexity analysis."
                    },
                    {
                        "username": "TheOnix",
                        "content": "This is a stupid problem that only tests that you know the solution, not your problem-solving skills"
                    },
                    {
                        "username": "FindIshita",
                        "content": "moore\\'s voting algo will be helpful"
                    },
                    {
                        "username": "hanhongsun",
                        "content": "I found nobody using bit-Operation for this question.\\n\\nI will try make up a O(n) time bit operation solution. \\n\\n**No** Boyer-Moore Majority Vote Algorithm \\n**No** Hashing table"
                    },
                    {
                        "username": "simonrouse9461",
                        "content": "[@Saketyadav](/Saketyadav) This does not have linear time. It\\'s O(n log n)"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "[@mdas95](/mdas95) Arrays.sort(nums);\\nreturn nums[nums.length/2];  try this one\\n"
                    },
                    {
                        "username": "mdas95",
                        "content": "tell me more I am all ears. \\nby the way[2 2 2 1 1 1 3 3] will it solve the this set of data. I am getting majority as 3 which is not the case. Since this has no majority.\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/majority-element/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** HashMap\n\n  \n**Approach 3:** Sorting\n\n  \n**Approach 4:** Randomization\n\n  \n**Approach 5:** Divide and Conquer\n\n  \n**Approach 6:** Boyer-Moore Voting Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sofs1",
                        "content": "Why did they put this problem under \"Bit Manipulation\" when none of the 6 solutions use bit operators?"
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "I don\\'t understand why people are sorting and returning the middle element. Although it is a valid solution, the follow-up of the question is asking us to solve the problem in Linear time and not O(nlogn) time. "
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Moore\\'s Voting Algorithm Explained in Super Simple efficient way!! \\nLink : https://leetcode.com/problems/majority-element/solutions/3015428/c-moore-s-voting-algorithm-explained-in-super-simple-fast-way/ \\n\\n \\n"
                    }
                ]
            },
            {
                "id": 1891387,
                "content": [
                    {
                        "username": "singhabhay11",
                        "content": "Arrays.sort(nums);\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@cswartzell](/cswartzell) See the last line\\n`Follow-up: Could you solve the problem in linear time and in O(1) space?`"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@tanmayyyj](/tanmayyyj)  Question doesnt mention time complexity at all. The O(n) solutions are pretty trivial, its interesting to think of different ways to do it. "
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "but not the time complexity the question is asking for\\n"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "[@sanon3714](/sanon3714) That is not an valid input for this problem since the majority element is said to be occuring more than n/2 times, here n=8 so 8/2=4 no element occurs more than 4 times. Therefore not a valid input."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "majority element present more than (n / 2) times. .not n/2 times [@Shivang verma](/Shivang_Verma1)"
                    },
                    {
                        "username": "sanon3714",
                        "content": "check for this 1,2,3,4,3,5,5,5\\n"
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "[@nikhila01](/nikhila01)  thankyou so much ,now I understand."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Shivang_Verma1](/Shivang_Verma1) `[1,1,1,2,2,4]` is an invalid input since it has no majority element. The majority element has to appear **more than** `\\u230An / 2\\u230B` times. Here `1` appears **exactly** `\\u230An / 2\\u230B` times."
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "what if arr=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1 "
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "If you\\'re sorting then it\\'s not linear time"
                    },
                    {
                        "username": "jerryy147",
                        "content": "This is genius!"
                    },
                    {
                        "username": "hampuztt",
                        "content": "[@keeganasmith2003](/keeganasmith2003) Even if counting sort was used, it\\'s not O(1) space"
                    },
                    {
                        "username": "bob1123030",
                        "content": "god level code\\n"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Can you not post solutions in the Discussion ... "
                    },
                    {
                        "username": "ParasAtal05",
                        "content": "God level code"
                    },
                    {
                        "username": "Rithym",
                        "content": "God level code\\n"
                    },
                    {
                        "username": "keeganasmith2003",
                        "content": "[@wisegauravmehra](/wisegauravmehra) It is linear if counting sort is used. This is an integer container, so counting sort can be used. "
                    },
                    {
                        "username": "wisegauravmehra",
                        "content": "It\\'s not linear runtime solution."
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/6c81d433-5a1c-412b-ba0c-f08ae95baa9e_1648865936.0360248.jpeg)\\n"
                    },
                    {
                        "username": "k_praphull",
                        "content": "[@nitish07maximus](/nitish07maximus) Have you read question properly, majority element is **more than n/2**"
                    },
                    {
                        "username": "ismaelmiah",
                        "content": "[@nitish07maximus](/nitish07maximus)  This is a wrong test case. as the description says \"You may assume that the majority element always exists in the array.\" You can assume these types of case won\\'t set in judge panel."
                    },
                    {
                        "username": "junjiexu",
                        "content": "[@nitish07maximus](/nitish07maximus) But that\\'s invalid input?"
                    },
                    {
                        "username": "nitish07maximus",
                        "content": "Give wrong result for this input.\\n1,1,1,2,2,3,2,1"
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "codyli520",
                        "content": "if I have [1,1,1,2,2,2], why is 1 the majority number and not 2?"
                    },
                    {
                        "username": "mursalin777",
                        "content": "the majority element must exist more than n/2 times. That\\'s the condition. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@CT-7567](/CT-7567) In my opinion you shouldn't treat the input as a random array. The problem constraints are there for a reason and allow you to come up with more interesting and efficient algorithms, like the follow up of O(N) time and O(1) space.\n\nIf you assume you can be given any inputs then it's a different problem. If a problem asks you to merge two sorted arrays into a single sorted array, would you just pretend the inputs aren't sorted and use a less efficient algorithm? It doesn't make sense."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sagar-pro](/sagar-pro) In my opinion you should approach this question like your input is a random array. it is harder but can be work in every array"
                    },
                    {
                        "username": "sagar-pro",
                        "content": "In your case no majority element because no element exist greater than 3(6/2)times and It is given in question input will always have majority element.\n"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I have problem coming up with the divide and conquer solution.Assume the base case contains only one element, which is the majority element for the base case. Now suppose we have two elements, each one returning from the base case. Say they are 1 2. There is clearly no majority element in this two-element array. If the whole input array is 1 2 2 and you divide the problem into 1 2 and 2. Of course you pick 2 in the right half. But what to pick in the left half?"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "it telling me [2,2]=1 surely should be =2??\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "I think I had a similar problem its telling me [2,2]=1, which makes no sense it should be 2 surely??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Kalyan19111999](/Kalyan19111999) You\\'re right in general, but we\\'re specifically talking about a divide and conquer solution.\\n\\nYou break up an array like `[1, 2, 2]` into subproblems such as `[1, 2]` and `[2]`. Even though `[1, 2]` doesn\\'t have a majority element you still have to return some value from the subproblem. That\\'s what the original question was about: what do you return in that case?"
                    },
                    {
                        "username": "Kalyan19111999",
                        "content": "[@nikhila01](/nikhila01)  I\\'m not quite sure if this case of length of ```nums``` being 2 with both elements being different comes up because, according to the problem description \"You may assume that the majority element always exists in the array\" which can only happen if both elements are the same e.g: [1,1] or [2,2]. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@himanshug9119](/himanshug9119) Majority is defined as _more than_ `floor(n / 2)` occurrences. If `n == 2` then `floor(n / 2) = 1` and no element out of 1 and 2 occurs _more than_ one time in `[1,2]`. So there isn't a majority.\n\n----\n\nAnyway, the answer to the original question is that for `[1,2]` you split it into `[1]` and `[2]`. Then `1` is the majority element on the left and `2` is the majority element on the right as per the base case. Now we have to combine the answers.\n\nWhat LeetCode's official solution does is this: Since the left and right subproblems don't agree on the majority element, you have to count the occurrences of `1` and `2` in the combined subarray. Whichever occurs more times is the majority. Here, both occur _one_ time in `[1,2]`, so it arbitrarily returns one of the elements as the majority. Let's pick the left to make the example more interesting, although LeetCode's solution actually returns the right if the counts are equal.\n\nThen when we combine `[1,2]` and `[2]` we got `1` on the left and `2` on the right. Again, they don't agree so we have to count occurrences of `1` and `2` in `[1,2,2]`. Now `2` wins so that's our answer."
                    },
                    {
                        "username": "himanshug9119",
                        "content": "You are saying in length 2 array there is no majority element why ?\\nYes there is also a majority element first one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "All those upvotes are for sure done by nerds who used either an extra O(n) space or extra time complexity which maybe n^2 or nlogn.  \nBut guys be honest did anyone solve it O(n) time and O(1) space. who has solved it like this ? \nI'm here sitting for an hour to figure out this."
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "[@emengel](/emengel) There is no O(n) sorting algorithm"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "hashing table algo"
                    },
                    {
                        "username": "leeyanleryan",
                        "content": "```\\nclass Solution \\n{\\n    public int majorityElement(int[] nums) \\n    {\\n        int count = 0;\\n        int dom = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (count == 0)\\n            {\\n                dom = nums[i];\\n                count++;\\n            }\\n            else if (dom != nums[i])\\n            {\\n                count--;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return dom;\\n    }\\n}\\n```\\n\\nThis is my solution for O(n) time and O(1) space."
                    },
                    {
                        "username": "emengel",
                        "content": "Try using an O(n) sorting algorithm that you can perform in-place (there\\'s only one that I know of). You\\'ll have to implement your own, since python\\'s sort() runs in n*log(n) time. You\\'ll find that a solution using the O(n) algorithm actually performs worse than the n*log(n) sorts. Determining the conditions under which this remains true is a fantastic exercise in complexity analysis."
                    },
                    {
                        "username": "TheOnix",
                        "content": "This is a stupid problem that only tests that you know the solution, not your problem-solving skills"
                    },
                    {
                        "username": "FindIshita",
                        "content": "moore\\'s voting algo will be helpful"
                    },
                    {
                        "username": "hanhongsun",
                        "content": "I found nobody using bit-Operation for this question.\\n\\nI will try make up a O(n) time bit operation solution. \\n\\n**No** Boyer-Moore Majority Vote Algorithm \\n**No** Hashing table"
                    },
                    {
                        "username": "simonrouse9461",
                        "content": "[@Saketyadav](/Saketyadav) This does not have linear time. It\\'s O(n log n)"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "[@mdas95](/mdas95) Arrays.sort(nums);\\nreturn nums[nums.length/2];  try this one\\n"
                    },
                    {
                        "username": "mdas95",
                        "content": "tell me more I am all ears. \\nby the way[2 2 2 1 1 1 3 3] will it solve the this set of data. I am getting majority as 3 which is not the case. Since this has no majority.\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/majority-element/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** HashMap\n\n  \n**Approach 3:** Sorting\n\n  \n**Approach 4:** Randomization\n\n  \n**Approach 5:** Divide and Conquer\n\n  \n**Approach 6:** Boyer-Moore Voting Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sofs1",
                        "content": "Why did they put this problem under \"Bit Manipulation\" when none of the 6 solutions use bit operators?"
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "I don\\'t understand why people are sorting and returning the middle element. Although it is a valid solution, the follow-up of the question is asking us to solve the problem in Linear time and not O(nlogn) time. "
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Moore\\'s Voting Algorithm Explained in Super Simple efficient way!! \\nLink : https://leetcode.com/problems/majority-element/solutions/3015428/c-moore-s-voting-algorithm-explained-in-super-simple-fast-way/ \\n\\n \\n"
                    }
                ]
            },
            {
                "id": 1746724,
                "content": [
                    {
                        "username": "singhabhay11",
                        "content": "Arrays.sort(nums);\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@cswartzell](/cswartzell) See the last line\\n`Follow-up: Could you solve the problem in linear time and in O(1) space?`"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@tanmayyyj](/tanmayyyj)  Question doesnt mention time complexity at all. The O(n) solutions are pretty trivial, its interesting to think of different ways to do it. "
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "but not the time complexity the question is asking for\\n"
                    },
                    {
                        "username": "Dusty_Donkey",
                        "content": "[@sanon3714](/sanon3714) That is not an valid input for this problem since the majority element is said to be occuring more than n/2 times, here n=8 so 8/2=4 no element occurs more than 4 times. Therefore not a valid input."
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "majority element present more than (n / 2) times. .not n/2 times [@Shivang verma](/Shivang_Verma1)"
                    },
                    {
                        "username": "sanon3714",
                        "content": "check for this 1,2,3,4,3,5,5,5\\n"
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "[@nikhila01](/nikhila01)  thankyou so much ,now I understand."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Shivang_Verma1](/Shivang_Verma1) `[1,1,1,2,2,4]` is an invalid input since it has no majority element. The majority element has to appear **more than** `\\u230An / 2\\u230B` times. Here `1` appears **exactly** `\\u230An / 2\\u230B` times."
                    },
                    {
                        "username": "Shivang_Verma1",
                        "content": "what if arr=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1 "
                    },
                    {
                        "username": "GustavoWilliam",
                        "content": "If you\\'re sorting then it\\'s not linear time"
                    },
                    {
                        "username": "jerryy147",
                        "content": "This is genius!"
                    },
                    {
                        "username": "hampuztt",
                        "content": "[@keeganasmith2003](/keeganasmith2003) Even if counting sort was used, it\\'s not O(1) space"
                    },
                    {
                        "username": "bob1123030",
                        "content": "god level code\\n"
                    },
                    {
                        "username": "ya17kun",
                        "content": "Can you not post solutions in the Discussion ... "
                    },
                    {
                        "username": "ParasAtal05",
                        "content": "God level code"
                    },
                    {
                        "username": "Rithym",
                        "content": "God level code\\n"
                    },
                    {
                        "username": "keeganasmith2003",
                        "content": "[@wisegauravmehra](/wisegauravmehra) It is linear if counting sort is used. This is an integer container, so counting sort can be used. "
                    },
                    {
                        "username": "wisegauravmehra",
                        "content": "It\\'s not linear runtime solution."
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/6c81d433-5a1c-412b-ba0c-f08ae95baa9e_1648865936.0360248.jpeg)\\n"
                    },
                    {
                        "username": "k_praphull",
                        "content": "[@nitish07maximus](/nitish07maximus) Have you read question properly, majority element is **more than n/2**"
                    },
                    {
                        "username": "ismaelmiah",
                        "content": "[@nitish07maximus](/nitish07maximus)  This is a wrong test case. as the description says \"You may assume that the majority element always exists in the array.\" You can assume these types of case won\\'t set in judge panel."
                    },
                    {
                        "username": "junjiexu",
                        "content": "[@nitish07maximus](/nitish07maximus) But that\\'s invalid input?"
                    },
                    {
                        "username": "nitish07maximus",
                        "content": "Give wrong result for this input.\\n1,1,1,2,2,3,2,1"
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "pulkittank",
                        "content": "Bro can you please explain this solution to me in an easy way."
                    },
                    {
                        "username": "codyli520",
                        "content": "if I have [1,1,1,2,2,2], why is 1 the majority number and not 2?"
                    },
                    {
                        "username": "mursalin777",
                        "content": "the majority element must exist more than n/2 times. That\\'s the condition. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@CT-7567](/CT-7567) In my opinion you shouldn't treat the input as a random array. The problem constraints are there for a reason and allow you to come up with more interesting and efficient algorithms, like the follow up of O(N) time and O(1) space.\n\nIf you assume you can be given any inputs then it's a different problem. If a problem asks you to merge two sorted arrays into a single sorted array, would you just pretend the inputs aren't sorted and use a less efficient algorithm? It doesn't make sense."
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@sagar-pro](/sagar-pro) In my opinion you should approach this question like your input is a random array. it is harder but can be work in every array"
                    },
                    {
                        "username": "sagar-pro",
                        "content": "In your case no majority element because no element exist greater than 3(6/2)times and It is given in question input will always have majority element.\n"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "I have problem coming up with the divide and conquer solution.Assume the base case contains only one element, which is the majority element for the base case. Now suppose we have two elements, each one returning from the base case. Say they are 1 2. There is clearly no majority element in this two-element array. If the whole input array is 1 2 2 and you divide the problem into 1 2 and 2. Of course you pick 2 in the right half. But what to pick in the left half?"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "it telling me [2,2]=1 surely should be =2??\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "I think I had a similar problem its telling me [2,2]=1, which makes no sense it should be 2 surely??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Kalyan19111999](/Kalyan19111999) You\\'re right in general, but we\\'re specifically talking about a divide and conquer solution.\\n\\nYou break up an array like `[1, 2, 2]` into subproblems such as `[1, 2]` and `[2]`. Even though `[1, 2]` doesn\\'t have a majority element you still have to return some value from the subproblem. That\\'s what the original question was about: what do you return in that case?"
                    },
                    {
                        "username": "Kalyan19111999",
                        "content": "[@nikhila01](/nikhila01)  I\\'m not quite sure if this case of length of ```nums``` being 2 with both elements being different comes up because, according to the problem description \"You may assume that the majority element always exists in the array\" which can only happen if both elements are the same e.g: [1,1] or [2,2]. "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@himanshug9119](/himanshug9119) Majority is defined as _more than_ `floor(n / 2)` occurrences. If `n == 2` then `floor(n / 2) = 1` and no element out of 1 and 2 occurs _more than_ one time in `[1,2]`. So there isn't a majority.\n\n----\n\nAnyway, the answer to the original question is that for `[1,2]` you split it into `[1]` and `[2]`. Then `1` is the majority element on the left and `2` is the majority element on the right as per the base case. Now we have to combine the answers.\n\nWhat LeetCode's official solution does is this: Since the left and right subproblems don't agree on the majority element, you have to count the occurrences of `1` and `2` in the combined subarray. Whichever occurs more times is the majority. Here, both occur _one_ time in `[1,2]`, so it arbitrarily returns one of the elements as the majority. Let's pick the left to make the example more interesting, although LeetCode's solution actually returns the right if the counts are equal.\n\nThen when we combine `[1,2]` and `[2]` we got `1` on the left and `2` on the right. Again, they don't agree so we have to count occurrences of `1` and `2` in `[1,2,2]`. Now `2` wins so that's our answer."
                    },
                    {
                        "username": "himanshug9119",
                        "content": "You are saying in length 2 array there is no majority element why ?\\nYes there is also a majority element first one."
                    },
                    {
                        "username": "Vithesh",
                        "content": "All those upvotes are for sure done by nerds who used either an extra O(n) space or extra time complexity which maybe n^2 or nlogn.  \nBut guys be honest did anyone solve it O(n) time and O(1) space. who has solved it like this ? \nI'm here sitting for an hour to figure out this."
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "[@emengel](/emengel) There is no O(n) sorting algorithm"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "hashing table algo"
                    },
                    {
                        "username": "leeyanleryan",
                        "content": "```\\nclass Solution \\n{\\n    public int majorityElement(int[] nums) \\n    {\\n        int count = 0;\\n        int dom = 0;\\n\\n        for (int i = 0; i < nums.length; i++)\\n        {\\n            if (count == 0)\\n            {\\n                dom = nums[i];\\n                count++;\\n            }\\n            else if (dom != nums[i])\\n            {\\n                count--;\\n            }\\n            else\\n            {\\n                count++;\\n            }\\n        }\\n\\n        return dom;\\n    }\\n}\\n```\\n\\nThis is my solution for O(n) time and O(1) space."
                    },
                    {
                        "username": "emengel",
                        "content": "Try using an O(n) sorting algorithm that you can perform in-place (there\\'s only one that I know of). You\\'ll have to implement your own, since python\\'s sort() runs in n*log(n) time. You\\'ll find that a solution using the O(n) algorithm actually performs worse than the n*log(n) sorts. Determining the conditions under which this remains true is a fantastic exercise in complexity analysis."
                    },
                    {
                        "username": "TheOnix",
                        "content": "This is a stupid problem that only tests that you know the solution, not your problem-solving skills"
                    },
                    {
                        "username": "FindIshita",
                        "content": "moore\\'s voting algo will be helpful"
                    },
                    {
                        "username": "hanhongsun",
                        "content": "I found nobody using bit-Operation for this question.\\n\\nI will try make up a O(n) time bit operation solution. \\n\\n**No** Boyer-Moore Majority Vote Algorithm \\n**No** Hashing table"
                    },
                    {
                        "username": "simonrouse9461",
                        "content": "[@Saketyadav](/Saketyadav) This does not have linear time. It\\'s O(n log n)"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "[@mdas95](/mdas95) Arrays.sort(nums);\\nreturn nums[nums.length/2];  try this one\\n"
                    },
                    {
                        "username": "mdas95",
                        "content": "tell me more I am all ears. \\nby the way[2 2 2 1 1 1 3 3] will it solve the this set of data. I am getting majority as 3 which is not the case. Since this has no majority.\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/majority-element/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** HashMap\n\n  \n**Approach 3:** Sorting\n\n  \n**Approach 4:** Randomization\n\n  \n**Approach 5:** Divide and Conquer\n\n  \n**Approach 6:** Boyer-Moore Voting Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sofs1",
                        "content": "Why did they put this problem under \"Bit Manipulation\" when none of the 6 solutions use bit operators?"
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "I don\\'t understand why people are sorting and returning the middle element. Although it is a valid solution, the follow-up of the question is asking us to solve the problem in Linear time and not O(nlogn) time. "
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Moore\\'s Voting Algorithm Explained in Super Simple efficient way!! \\nLink : https://leetcode.com/problems/majority-element/solutions/3015428/c-moore-s-voting-algorithm-explained-in-super-simple-fast-way/ \\n\\n \\n"
                    }
                ]
            },
            {
                "id": 1567898,
                "content": [
                    {
                        "username": "ghostli123",
                        "content": "I found that someone got the answer faster than 20ms by using c++. Any idea to share?"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "1 ms, by Boyer-Moore majority voting algorithm. It is guaranteed that a majority element exists so we would need 1 pass to find the majority element."
                    },
                    {
                        "username": "Abhishek06",
                        "content": "14ms, By randomly selecting any element and checking if this element is majority. Since in worse case also every second element is majority element, this solution is very fast."
                    },
                    {
                        "username": "meghaSamkaria",
                        "content": "by Boyer-Moore Majority Vote Algorithm in 18 ms."
                    },
                    {
                        "username": "rcode0",
                        "content": "1. Pick a random element\\n2. Check if it\\'s the majority element, this will succeed first time most of the time and we finish\\n3. Else, store the random element in a set. Pick a new random element, repick it if it\\'s already in the set. Goto 2.\\n\\nThis yielded a 0ms solution in Rust."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@youssifgamal606](/youssifgamal606) The worst case time complexity of your solution would be O((n/2)*(n))\\nwhich is equal to O(n^2)\\nExplanation : number of non-majority element is (n/2) out of (n) ==> worst case\\nfor each non-majority element we will have to iterate the whole array to find it\\'s count , and check if it is majority or not \\nTherefore for (n/2) elements , we will iterate whole array , i.e n\\nTherefore your time complexity is O(n2)\\n\\nIt is worse than sorting it and then find the majority , which will take only O(nlogn) time "
                    },
                    {
                        "username": "cswartzell",
                        "content": "How does randomizing the element you are picking help? What do you mean \"this will succeed first time\"? While statistically likely, we havent proven that. I dont think this is possible to solve in less than O(n/2 + 1) BEST case"
                    },
                    {
                        "username": "Suman_Saurabh02",
                        "content": "[@youssifgamal606](/youssifgamal606) -In step 2, if the count of the selected element is greater than floor(n/2), then it is majority."
                    },
                    {
                        "username": "youssifgamal606",
                        "content": "how do you check if it is the majority element in step 2 ?\\n"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\' \\n\\nreturn max(set(nums), key = nums.count) \\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "srk6",
                        "content": "[2,1,2,3,7] => Your algorithm returns 7 but how can 7 be the result for this input? "
                    },
                    {
                        "username": "speye_21",
                        "content": "The algorithm returns a majority element if it exists.  Your example does not have a majority element."
                    },
                    {
                        "username": "rakeshdrk",
                        "content": "Sort the array, return the mid element."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int n = nums.length -1;\\n        int ans = n/2;\\n        return nums[ans];   \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "hus250",
                        "content": "it says Time Limit Exceeded"
                    },
                    {
                        "username": "galenw",
                        "content": "Two questions for Boyer-Moore:\\n\\n1. Is it an example of DP when count == 0? The problem then reduces to finding the majority element in the remaining subarray.\\n2. Am I correct in assuming this approach will not work if the array does not contain a majority element?"
                    },
                    {
                        "username": "zacharyrhansen",
                        "content": "#1 DP is usually classified as utilizing repeated sub-problems as a means to improve efficiency. In this case, although we are solving \\'sub-problems\\' within the larger problem, the sub-problems do not contribute to the computation of other sub-problems (there is no repetition of computation). When sub-problems do repeat in a solution, the solution to the sub-problems can be stored either through memoization (top-down) or tabulation (bottom-up) so that the next time the algorithm encounters the same sub-problem it does not need to re-compute - this is what is called dynamic programming.\\n\\n#2 yes this solution would return a random number depending on the ordering of the array. If a majority is not guaranteed and you wanted to solve it in constant space, the most efficient solution would be bit-manipulation. Although the bit manipulation would still result in an incorrect number, that incorrect number should not exist in the array due to the fact that any bits that result in a majority must be derived from a combination of existing numbers. Thus you can do an additional single pass to ensure the existence of the bit manipulation result to say wither it is indeed the answer or if no answer exists."
                    },
                    {
                        "username": "vineetkumarprocoder",
                        "content": "Why this question given in Bit Manipulation Tag, How to solve using bit manipulation ?"
                    },
                    {
                        "username": "geek_",
                        "content": "solution using hashmap and arrays\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/majority-element.html"
                    },
                    {
                        "username": "ashutoshmadhwani2807",
                        "content": "This algorithm works perfectly for problems **WHERE YOU ARE SURE** about the existence of Majority Element plus this algorithm also fails to tell the exact count of Majority Element in the array.\\n\\nNow the reason why this algorithm works is because the ME is present more than n/2 times and the canditate will not change its value unless count becomes zero which will never happen even if array is sorted.\\n\\nOne more point to notice is that if the elements are present in alternative manner ie[2,3,4,3,5,3] so on , then if array has odd number of elements the last element will always be ME(logic permutation) and if the array has even number of elements then the ME has to occur in pair atleast one time ie[2,3,4,3,5,3,3] so that ME can be more than n/2 which brings to point that this algorithm **MIGHT FAIL** if ME has count of exactly n/2."
                    },
                    {
                        "username": "techysiddhant",
                        "content": " for [2,3,4,3,5,3,3] this algo is working fine\\nint majorityElement(vector<int>& nums) {\\n        int count=0;\\n        int element = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(count == 0){\\n                element = nums[i];\\n            }\\n            if(element == nums[i]) count++;\\n            else count--;\\n        }\\n        count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(element == nums[i]){\\n                count++;\\n            }\\n        }\\n        if(count > nums.size()/2){\\n            return element;\\n        }else{\\n            return -1;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "IcedLife",
                        "content": "When input is [1,1,1,3,3,4,4] answer should be 1,but the answer that fetched is 4.  I don't know if it's just me."
                    }
                ]
            },
            {
                "id": 1570027,
                "content": [
                    {
                        "username": "ghostli123",
                        "content": "I found that someone got the answer faster than 20ms by using c++. Any idea to share?"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "1 ms, by Boyer-Moore majority voting algorithm. It is guaranteed that a majority element exists so we would need 1 pass to find the majority element."
                    },
                    {
                        "username": "Abhishek06",
                        "content": "14ms, By randomly selecting any element and checking if this element is majority. Since in worse case also every second element is majority element, this solution is very fast."
                    },
                    {
                        "username": "meghaSamkaria",
                        "content": "by Boyer-Moore Majority Vote Algorithm in 18 ms."
                    },
                    {
                        "username": "rcode0",
                        "content": "1. Pick a random element\\n2. Check if it\\'s the majority element, this will succeed first time most of the time and we finish\\n3. Else, store the random element in a set. Pick a new random element, repick it if it\\'s already in the set. Goto 2.\\n\\nThis yielded a 0ms solution in Rust."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@youssifgamal606](/youssifgamal606) The worst case time complexity of your solution would be O((n/2)*(n))\\nwhich is equal to O(n^2)\\nExplanation : number of non-majority element is (n/2) out of (n) ==> worst case\\nfor each non-majority element we will have to iterate the whole array to find it\\'s count , and check if it is majority or not \\nTherefore for (n/2) elements , we will iterate whole array , i.e n\\nTherefore your time complexity is O(n2)\\n\\nIt is worse than sorting it and then find the majority , which will take only O(nlogn) time "
                    },
                    {
                        "username": "cswartzell",
                        "content": "How does randomizing the element you are picking help? What do you mean \"this will succeed first time\"? While statistically likely, we havent proven that. I dont think this is possible to solve in less than O(n/2 + 1) BEST case"
                    },
                    {
                        "username": "Suman_Saurabh02",
                        "content": "[@youssifgamal606](/youssifgamal606) -In step 2, if the count of the selected element is greater than floor(n/2), then it is majority."
                    },
                    {
                        "username": "youssifgamal606",
                        "content": "how do you check if it is the majority element in step 2 ?\\n"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\' \\n\\nreturn max(set(nums), key = nums.count) \\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "srk6",
                        "content": "[2,1,2,3,7] => Your algorithm returns 7 but how can 7 be the result for this input? "
                    },
                    {
                        "username": "speye_21",
                        "content": "The algorithm returns a majority element if it exists.  Your example does not have a majority element."
                    },
                    {
                        "username": "rakeshdrk",
                        "content": "Sort the array, return the mid element."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int n = nums.length -1;\\n        int ans = n/2;\\n        return nums[ans];   \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "hus250",
                        "content": "it says Time Limit Exceeded"
                    },
                    {
                        "username": "galenw",
                        "content": "Two questions for Boyer-Moore:\\n\\n1. Is it an example of DP when count == 0? The problem then reduces to finding the majority element in the remaining subarray.\\n2. Am I correct in assuming this approach will not work if the array does not contain a majority element?"
                    },
                    {
                        "username": "zacharyrhansen",
                        "content": "#1 DP is usually classified as utilizing repeated sub-problems as a means to improve efficiency. In this case, although we are solving \\'sub-problems\\' within the larger problem, the sub-problems do not contribute to the computation of other sub-problems (there is no repetition of computation). When sub-problems do repeat in a solution, the solution to the sub-problems can be stored either through memoization (top-down) or tabulation (bottom-up) so that the next time the algorithm encounters the same sub-problem it does not need to re-compute - this is what is called dynamic programming.\\n\\n#2 yes this solution would return a random number depending on the ordering of the array. If a majority is not guaranteed and you wanted to solve it in constant space, the most efficient solution would be bit-manipulation. Although the bit manipulation would still result in an incorrect number, that incorrect number should not exist in the array due to the fact that any bits that result in a majority must be derived from a combination of existing numbers. Thus you can do an additional single pass to ensure the existence of the bit manipulation result to say wither it is indeed the answer or if no answer exists."
                    },
                    {
                        "username": "vineetkumarprocoder",
                        "content": "Why this question given in Bit Manipulation Tag, How to solve using bit manipulation ?"
                    },
                    {
                        "username": "geek_",
                        "content": "solution using hashmap and arrays\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/majority-element.html"
                    },
                    {
                        "username": "ashutoshmadhwani2807",
                        "content": "This algorithm works perfectly for problems **WHERE YOU ARE SURE** about the existence of Majority Element plus this algorithm also fails to tell the exact count of Majority Element in the array.\\n\\nNow the reason why this algorithm works is because the ME is present more than n/2 times and the canditate will not change its value unless count becomes zero which will never happen even if array is sorted.\\n\\nOne more point to notice is that if the elements are present in alternative manner ie[2,3,4,3,5,3] so on , then if array has odd number of elements the last element will always be ME(logic permutation) and if the array has even number of elements then the ME has to occur in pair atleast one time ie[2,3,4,3,5,3,3] so that ME can be more than n/2 which brings to point that this algorithm **MIGHT FAIL** if ME has count of exactly n/2."
                    },
                    {
                        "username": "techysiddhant",
                        "content": " for [2,3,4,3,5,3,3] this algo is working fine\\nint majorityElement(vector<int>& nums) {\\n        int count=0;\\n        int element = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(count == 0){\\n                element = nums[i];\\n            }\\n            if(element == nums[i]) count++;\\n            else count--;\\n        }\\n        count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(element == nums[i]){\\n                count++;\\n            }\\n        }\\n        if(count > nums.size()/2){\\n            return element;\\n        }else{\\n            return -1;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "IcedLife",
                        "content": "When input is [1,1,1,3,3,4,4] answer should be 1,but the answer that fetched is 4.  I don't know if it's just me."
                    }
                ]
            },
            {
                "id": 1573166,
                "content": [
                    {
                        "username": "ghostli123",
                        "content": "I found that someone got the answer faster than 20ms by using c++. Any idea to share?"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "1 ms, by Boyer-Moore majority voting algorithm. It is guaranteed that a majority element exists so we would need 1 pass to find the majority element."
                    },
                    {
                        "username": "Abhishek06",
                        "content": "14ms, By randomly selecting any element and checking if this element is majority. Since in worse case also every second element is majority element, this solution is very fast."
                    },
                    {
                        "username": "meghaSamkaria",
                        "content": "by Boyer-Moore Majority Vote Algorithm in 18 ms."
                    },
                    {
                        "username": "rcode0",
                        "content": "1. Pick a random element\\n2. Check if it\\'s the majority element, this will succeed first time most of the time and we finish\\n3. Else, store the random element in a set. Pick a new random element, repick it if it\\'s already in the set. Goto 2.\\n\\nThis yielded a 0ms solution in Rust."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@youssifgamal606](/youssifgamal606) The worst case time complexity of your solution would be O((n/2)*(n))\\nwhich is equal to O(n^2)\\nExplanation : number of non-majority element is (n/2) out of (n) ==> worst case\\nfor each non-majority element we will have to iterate the whole array to find it\\'s count , and check if it is majority or not \\nTherefore for (n/2) elements , we will iterate whole array , i.e n\\nTherefore your time complexity is O(n2)\\n\\nIt is worse than sorting it and then find the majority , which will take only O(nlogn) time "
                    },
                    {
                        "username": "cswartzell",
                        "content": "How does randomizing the element you are picking help? What do you mean \"this will succeed first time\"? While statistically likely, we havent proven that. I dont think this is possible to solve in less than O(n/2 + 1) BEST case"
                    },
                    {
                        "username": "Suman_Saurabh02",
                        "content": "[@youssifgamal606](/youssifgamal606) -In step 2, if the count of the selected element is greater than floor(n/2), then it is majority."
                    },
                    {
                        "username": "youssifgamal606",
                        "content": "how do you check if it is the majority element in step 2 ?\\n"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\' \\n\\nreturn max(set(nums), key = nums.count) \\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "srk6",
                        "content": "[2,1,2,3,7] => Your algorithm returns 7 but how can 7 be the result for this input? "
                    },
                    {
                        "username": "speye_21",
                        "content": "The algorithm returns a majority element if it exists.  Your example does not have a majority element."
                    },
                    {
                        "username": "rakeshdrk",
                        "content": "Sort the array, return the mid element."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int n = nums.length -1;\\n        int ans = n/2;\\n        return nums[ans];   \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "hus250",
                        "content": "it says Time Limit Exceeded"
                    },
                    {
                        "username": "galenw",
                        "content": "Two questions for Boyer-Moore:\\n\\n1. Is it an example of DP when count == 0? The problem then reduces to finding the majority element in the remaining subarray.\\n2. Am I correct in assuming this approach will not work if the array does not contain a majority element?"
                    },
                    {
                        "username": "zacharyrhansen",
                        "content": "#1 DP is usually classified as utilizing repeated sub-problems as a means to improve efficiency. In this case, although we are solving \\'sub-problems\\' within the larger problem, the sub-problems do not contribute to the computation of other sub-problems (there is no repetition of computation). When sub-problems do repeat in a solution, the solution to the sub-problems can be stored either through memoization (top-down) or tabulation (bottom-up) so that the next time the algorithm encounters the same sub-problem it does not need to re-compute - this is what is called dynamic programming.\\n\\n#2 yes this solution would return a random number depending on the ordering of the array. If a majority is not guaranteed and you wanted to solve it in constant space, the most efficient solution would be bit-manipulation. Although the bit manipulation would still result in an incorrect number, that incorrect number should not exist in the array due to the fact that any bits that result in a majority must be derived from a combination of existing numbers. Thus you can do an additional single pass to ensure the existence of the bit manipulation result to say wither it is indeed the answer or if no answer exists."
                    },
                    {
                        "username": "vineetkumarprocoder",
                        "content": "Why this question given in Bit Manipulation Tag, How to solve using bit manipulation ?"
                    },
                    {
                        "username": "geek_",
                        "content": "solution using hashmap and arrays\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/majority-element.html"
                    },
                    {
                        "username": "ashutoshmadhwani2807",
                        "content": "This algorithm works perfectly for problems **WHERE YOU ARE SURE** about the existence of Majority Element plus this algorithm also fails to tell the exact count of Majority Element in the array.\\n\\nNow the reason why this algorithm works is because the ME is present more than n/2 times and the canditate will not change its value unless count becomes zero which will never happen even if array is sorted.\\n\\nOne more point to notice is that if the elements are present in alternative manner ie[2,3,4,3,5,3] so on , then if array has odd number of elements the last element will always be ME(logic permutation) and if the array has even number of elements then the ME has to occur in pair atleast one time ie[2,3,4,3,5,3,3] so that ME can be more than n/2 which brings to point that this algorithm **MIGHT FAIL** if ME has count of exactly n/2."
                    },
                    {
                        "username": "techysiddhant",
                        "content": " for [2,3,4,3,5,3,3] this algo is working fine\\nint majorityElement(vector<int>& nums) {\\n        int count=0;\\n        int element = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(count == 0){\\n                element = nums[i];\\n            }\\n            if(element == nums[i]) count++;\\n            else count--;\\n        }\\n        count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(element == nums[i]){\\n                count++;\\n            }\\n        }\\n        if(count > nums.size()/2){\\n            return element;\\n        }else{\\n            return -1;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "IcedLife",
                        "content": "When input is [1,1,1,3,3,4,4] answer should be 1,but the answer that fetched is 4.  I don't know if it's just me."
                    }
                ]
            },
            {
                "id": 1572230,
                "content": [
                    {
                        "username": "ghostli123",
                        "content": "I found that someone got the answer faster than 20ms by using c++. Any idea to share?"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "1 ms, by Boyer-Moore majority voting algorithm. It is guaranteed that a majority element exists so we would need 1 pass to find the majority element."
                    },
                    {
                        "username": "Abhishek06",
                        "content": "14ms, By randomly selecting any element and checking if this element is majority. Since in worse case also every second element is majority element, this solution is very fast."
                    },
                    {
                        "username": "meghaSamkaria",
                        "content": "by Boyer-Moore Majority Vote Algorithm in 18 ms."
                    },
                    {
                        "username": "rcode0",
                        "content": "1. Pick a random element\\n2. Check if it\\'s the majority element, this will succeed first time most of the time and we finish\\n3. Else, store the random element in a set. Pick a new random element, repick it if it\\'s already in the set. Goto 2.\\n\\nThis yielded a 0ms solution in Rust."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@youssifgamal606](/youssifgamal606) The worst case time complexity of your solution would be O((n/2)*(n))\\nwhich is equal to O(n^2)\\nExplanation : number of non-majority element is (n/2) out of (n) ==> worst case\\nfor each non-majority element we will have to iterate the whole array to find it\\'s count , and check if it is majority or not \\nTherefore for (n/2) elements , we will iterate whole array , i.e n\\nTherefore your time complexity is O(n2)\\n\\nIt is worse than sorting it and then find the majority , which will take only O(nlogn) time "
                    },
                    {
                        "username": "cswartzell",
                        "content": "How does randomizing the element you are picking help? What do you mean \"this will succeed first time\"? While statistically likely, we havent proven that. I dont think this is possible to solve in less than O(n/2 + 1) BEST case"
                    },
                    {
                        "username": "Suman_Saurabh02",
                        "content": "[@youssifgamal606](/youssifgamal606) -In step 2, if the count of the selected element is greater than floor(n/2), then it is majority."
                    },
                    {
                        "username": "youssifgamal606",
                        "content": "how do you check if it is the majority element in step 2 ?\\n"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\' \\n\\nreturn max(set(nums), key = nums.count) \\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "srk6",
                        "content": "[2,1,2,3,7] => Your algorithm returns 7 but how can 7 be the result for this input? "
                    },
                    {
                        "username": "speye_21",
                        "content": "The algorithm returns a majority element if it exists.  Your example does not have a majority element."
                    },
                    {
                        "username": "rakeshdrk",
                        "content": "Sort the array, return the mid element."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int n = nums.length -1;\\n        int ans = n/2;\\n        return nums[ans];   \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "hus250",
                        "content": "it says Time Limit Exceeded"
                    },
                    {
                        "username": "galenw",
                        "content": "Two questions for Boyer-Moore:\\n\\n1. Is it an example of DP when count == 0? The problem then reduces to finding the majority element in the remaining subarray.\\n2. Am I correct in assuming this approach will not work if the array does not contain a majority element?"
                    },
                    {
                        "username": "zacharyrhansen",
                        "content": "#1 DP is usually classified as utilizing repeated sub-problems as a means to improve efficiency. In this case, although we are solving \\'sub-problems\\' within the larger problem, the sub-problems do not contribute to the computation of other sub-problems (there is no repetition of computation). When sub-problems do repeat in a solution, the solution to the sub-problems can be stored either through memoization (top-down) or tabulation (bottom-up) so that the next time the algorithm encounters the same sub-problem it does not need to re-compute - this is what is called dynamic programming.\\n\\n#2 yes this solution would return a random number depending on the ordering of the array. If a majority is not guaranteed and you wanted to solve it in constant space, the most efficient solution would be bit-manipulation. Although the bit manipulation would still result in an incorrect number, that incorrect number should not exist in the array due to the fact that any bits that result in a majority must be derived from a combination of existing numbers. Thus you can do an additional single pass to ensure the existence of the bit manipulation result to say wither it is indeed the answer or if no answer exists."
                    },
                    {
                        "username": "vineetkumarprocoder",
                        "content": "Why this question given in Bit Manipulation Tag, How to solve using bit manipulation ?"
                    },
                    {
                        "username": "geek_",
                        "content": "solution using hashmap and arrays\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/majority-element.html"
                    },
                    {
                        "username": "ashutoshmadhwani2807",
                        "content": "This algorithm works perfectly for problems **WHERE YOU ARE SURE** about the existence of Majority Element plus this algorithm also fails to tell the exact count of Majority Element in the array.\\n\\nNow the reason why this algorithm works is because the ME is present more than n/2 times and the canditate will not change its value unless count becomes zero which will never happen even if array is sorted.\\n\\nOne more point to notice is that if the elements are present in alternative manner ie[2,3,4,3,5,3] so on , then if array has odd number of elements the last element will always be ME(logic permutation) and if the array has even number of elements then the ME has to occur in pair atleast one time ie[2,3,4,3,5,3,3] so that ME can be more than n/2 which brings to point that this algorithm **MIGHT FAIL** if ME has count of exactly n/2."
                    },
                    {
                        "username": "techysiddhant",
                        "content": " for [2,3,4,3,5,3,3] this algo is working fine\\nint majorityElement(vector<int>& nums) {\\n        int count=0;\\n        int element = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(count == 0){\\n                element = nums[i];\\n            }\\n            if(element == nums[i]) count++;\\n            else count--;\\n        }\\n        count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(element == nums[i]){\\n                count++;\\n            }\\n        }\\n        if(count > nums.size()/2){\\n            return element;\\n        }else{\\n            return -1;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "IcedLife",
                        "content": "When input is [1,1,1,3,3,4,4] answer should be 1,but the answer that fetched is 4.  I don't know if it's just me."
                    }
                ]
            },
            {
                "id": 1571368,
                "content": [
                    {
                        "username": "ghostli123",
                        "content": "I found that someone got the answer faster than 20ms by using c++. Any idea to share?"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "1 ms, by Boyer-Moore majority voting algorithm. It is guaranteed that a majority element exists so we would need 1 pass to find the majority element."
                    },
                    {
                        "username": "Abhishek06",
                        "content": "14ms, By randomly selecting any element and checking if this element is majority. Since in worse case also every second element is majority element, this solution is very fast."
                    },
                    {
                        "username": "meghaSamkaria",
                        "content": "by Boyer-Moore Majority Vote Algorithm in 18 ms."
                    },
                    {
                        "username": "rcode0",
                        "content": "1. Pick a random element\\n2. Check if it\\'s the majority element, this will succeed first time most of the time and we finish\\n3. Else, store the random element in a set. Pick a new random element, repick it if it\\'s already in the set. Goto 2.\\n\\nThis yielded a 0ms solution in Rust."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@youssifgamal606](/youssifgamal606) The worst case time complexity of your solution would be O((n/2)*(n))\\nwhich is equal to O(n^2)\\nExplanation : number of non-majority element is (n/2) out of (n) ==> worst case\\nfor each non-majority element we will have to iterate the whole array to find it\\'s count , and check if it is majority or not \\nTherefore for (n/2) elements , we will iterate whole array , i.e n\\nTherefore your time complexity is O(n2)\\n\\nIt is worse than sorting it and then find the majority , which will take only O(nlogn) time "
                    },
                    {
                        "username": "cswartzell",
                        "content": "How does randomizing the element you are picking help? What do you mean \"this will succeed first time\"? While statistically likely, we havent proven that. I dont think this is possible to solve in less than O(n/2 + 1) BEST case"
                    },
                    {
                        "username": "Suman_Saurabh02",
                        "content": "[@youssifgamal606](/youssifgamal606) -In step 2, if the count of the selected element is greater than floor(n/2), then it is majority."
                    },
                    {
                        "username": "youssifgamal606",
                        "content": "how do you check if it is the majority element in step 2 ?\\n"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\' \\n\\nreturn max(set(nums), key = nums.count) \\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "srk6",
                        "content": "[2,1,2,3,7] => Your algorithm returns 7 but how can 7 be the result for this input? "
                    },
                    {
                        "username": "speye_21",
                        "content": "The algorithm returns a majority element if it exists.  Your example does not have a majority element."
                    },
                    {
                        "username": "rakeshdrk",
                        "content": "Sort the array, return the mid element."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int n = nums.length -1;\\n        int ans = n/2;\\n        return nums[ans];   \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "hus250",
                        "content": "it says Time Limit Exceeded"
                    },
                    {
                        "username": "galenw",
                        "content": "Two questions for Boyer-Moore:\\n\\n1. Is it an example of DP when count == 0? The problem then reduces to finding the majority element in the remaining subarray.\\n2. Am I correct in assuming this approach will not work if the array does not contain a majority element?"
                    },
                    {
                        "username": "zacharyrhansen",
                        "content": "#1 DP is usually classified as utilizing repeated sub-problems as a means to improve efficiency. In this case, although we are solving \\'sub-problems\\' within the larger problem, the sub-problems do not contribute to the computation of other sub-problems (there is no repetition of computation). When sub-problems do repeat in a solution, the solution to the sub-problems can be stored either through memoization (top-down) or tabulation (bottom-up) so that the next time the algorithm encounters the same sub-problem it does not need to re-compute - this is what is called dynamic programming.\\n\\n#2 yes this solution would return a random number depending on the ordering of the array. If a majority is not guaranteed and you wanted to solve it in constant space, the most efficient solution would be bit-manipulation. Although the bit manipulation would still result in an incorrect number, that incorrect number should not exist in the array due to the fact that any bits that result in a majority must be derived from a combination of existing numbers. Thus you can do an additional single pass to ensure the existence of the bit manipulation result to say wither it is indeed the answer or if no answer exists."
                    },
                    {
                        "username": "vineetkumarprocoder",
                        "content": "Why this question given in Bit Manipulation Tag, How to solve using bit manipulation ?"
                    },
                    {
                        "username": "geek_",
                        "content": "solution using hashmap and arrays\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/majority-element.html"
                    },
                    {
                        "username": "ashutoshmadhwani2807",
                        "content": "This algorithm works perfectly for problems **WHERE YOU ARE SURE** about the existence of Majority Element plus this algorithm also fails to tell the exact count of Majority Element in the array.\\n\\nNow the reason why this algorithm works is because the ME is present more than n/2 times and the canditate will not change its value unless count becomes zero which will never happen even if array is sorted.\\n\\nOne more point to notice is that if the elements are present in alternative manner ie[2,3,4,3,5,3] so on , then if array has odd number of elements the last element will always be ME(logic permutation) and if the array has even number of elements then the ME has to occur in pair atleast one time ie[2,3,4,3,5,3,3] so that ME can be more than n/2 which brings to point that this algorithm **MIGHT FAIL** if ME has count of exactly n/2."
                    },
                    {
                        "username": "techysiddhant",
                        "content": " for [2,3,4,3,5,3,3] this algo is working fine\\nint majorityElement(vector<int>& nums) {\\n        int count=0;\\n        int element = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(count == 0){\\n                element = nums[i];\\n            }\\n            if(element == nums[i]) count++;\\n            else count--;\\n        }\\n        count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(element == nums[i]){\\n                count++;\\n            }\\n        }\\n        if(count > nums.size()/2){\\n            return element;\\n        }else{\\n            return -1;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "IcedLife",
                        "content": "When input is [1,1,1,3,3,4,4] answer should be 1,but the answer that fetched is 4.  I don't know if it's just me."
                    }
                ]
            },
            {
                "id": 1570686,
                "content": [
                    {
                        "username": "ghostli123",
                        "content": "I found that someone got the answer faster than 20ms by using c++. Any idea to share?"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "1 ms, by Boyer-Moore majority voting algorithm. It is guaranteed that a majority element exists so we would need 1 pass to find the majority element."
                    },
                    {
                        "username": "Abhishek06",
                        "content": "14ms, By randomly selecting any element and checking if this element is majority. Since in worse case also every second element is majority element, this solution is very fast."
                    },
                    {
                        "username": "meghaSamkaria",
                        "content": "by Boyer-Moore Majority Vote Algorithm in 18 ms."
                    },
                    {
                        "username": "rcode0",
                        "content": "1. Pick a random element\\n2. Check if it\\'s the majority element, this will succeed first time most of the time and we finish\\n3. Else, store the random element in a set. Pick a new random element, repick it if it\\'s already in the set. Goto 2.\\n\\nThis yielded a 0ms solution in Rust."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@youssifgamal606](/youssifgamal606) The worst case time complexity of your solution would be O((n/2)*(n))\\nwhich is equal to O(n^2)\\nExplanation : number of non-majority element is (n/2) out of (n) ==> worst case\\nfor each non-majority element we will have to iterate the whole array to find it\\'s count , and check if it is majority or not \\nTherefore for (n/2) elements , we will iterate whole array , i.e n\\nTherefore your time complexity is O(n2)\\n\\nIt is worse than sorting it and then find the majority , which will take only O(nlogn) time "
                    },
                    {
                        "username": "cswartzell",
                        "content": "How does randomizing the element you are picking help? What do you mean \"this will succeed first time\"? While statistically likely, we havent proven that. I dont think this is possible to solve in less than O(n/2 + 1) BEST case"
                    },
                    {
                        "username": "Suman_Saurabh02",
                        "content": "[@youssifgamal606](/youssifgamal606) -In step 2, if the count of the selected element is greater than floor(n/2), then it is majority."
                    },
                    {
                        "username": "youssifgamal606",
                        "content": "how do you check if it is the majority element in step 2 ?\\n"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\' \\n\\nreturn max(set(nums), key = nums.count) \\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "srk6",
                        "content": "[2,1,2,3,7] => Your algorithm returns 7 but how can 7 be the result for this input? "
                    },
                    {
                        "username": "speye_21",
                        "content": "The algorithm returns a majority element if it exists.  Your example does not have a majority element."
                    },
                    {
                        "username": "rakeshdrk",
                        "content": "Sort the array, return the mid element."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int n = nums.length -1;\\n        int ans = n/2;\\n        return nums[ans];   \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "hus250",
                        "content": "it says Time Limit Exceeded"
                    },
                    {
                        "username": "galenw",
                        "content": "Two questions for Boyer-Moore:\\n\\n1. Is it an example of DP when count == 0? The problem then reduces to finding the majority element in the remaining subarray.\\n2. Am I correct in assuming this approach will not work if the array does not contain a majority element?"
                    },
                    {
                        "username": "zacharyrhansen",
                        "content": "#1 DP is usually classified as utilizing repeated sub-problems as a means to improve efficiency. In this case, although we are solving \\'sub-problems\\' within the larger problem, the sub-problems do not contribute to the computation of other sub-problems (there is no repetition of computation). When sub-problems do repeat in a solution, the solution to the sub-problems can be stored either through memoization (top-down) or tabulation (bottom-up) so that the next time the algorithm encounters the same sub-problem it does not need to re-compute - this is what is called dynamic programming.\\n\\n#2 yes this solution would return a random number depending on the ordering of the array. If a majority is not guaranteed and you wanted to solve it in constant space, the most efficient solution would be bit-manipulation. Although the bit manipulation would still result in an incorrect number, that incorrect number should not exist in the array due to the fact that any bits that result in a majority must be derived from a combination of existing numbers. Thus you can do an additional single pass to ensure the existence of the bit manipulation result to say wither it is indeed the answer or if no answer exists."
                    },
                    {
                        "username": "vineetkumarprocoder",
                        "content": "Why this question given in Bit Manipulation Tag, How to solve using bit manipulation ?"
                    },
                    {
                        "username": "geek_",
                        "content": "solution using hashmap and arrays\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/majority-element.html"
                    },
                    {
                        "username": "ashutoshmadhwani2807",
                        "content": "This algorithm works perfectly for problems **WHERE YOU ARE SURE** about the existence of Majority Element plus this algorithm also fails to tell the exact count of Majority Element in the array.\\n\\nNow the reason why this algorithm works is because the ME is present more than n/2 times and the canditate will not change its value unless count becomes zero which will never happen even if array is sorted.\\n\\nOne more point to notice is that if the elements are present in alternative manner ie[2,3,4,3,5,3] so on , then if array has odd number of elements the last element will always be ME(logic permutation) and if the array has even number of elements then the ME has to occur in pair atleast one time ie[2,3,4,3,5,3,3] so that ME can be more than n/2 which brings to point that this algorithm **MIGHT FAIL** if ME has count of exactly n/2."
                    },
                    {
                        "username": "techysiddhant",
                        "content": " for [2,3,4,3,5,3,3] this algo is working fine\\nint majorityElement(vector<int>& nums) {\\n        int count=0;\\n        int element = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(count == 0){\\n                element = nums[i];\\n            }\\n            if(element == nums[i]) count++;\\n            else count--;\\n        }\\n        count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(element == nums[i]){\\n                count++;\\n            }\\n        }\\n        if(count > nums.size()/2){\\n            return element;\\n        }else{\\n            return -1;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "IcedLife",
                        "content": "When input is [1,1,1,3,3,4,4] answer should be 1,but the answer that fetched is 4.  I don't know if it's just me."
                    }
                ]
            },
            {
                "id": 1575299,
                "content": [
                    {
                        "username": "ghostli123",
                        "content": "I found that someone got the answer faster than 20ms by using c++. Any idea to share?"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "1 ms, by Boyer-Moore majority voting algorithm. It is guaranteed that a majority element exists so we would need 1 pass to find the majority element."
                    },
                    {
                        "username": "Abhishek06",
                        "content": "14ms, By randomly selecting any element and checking if this element is majority. Since in worse case also every second element is majority element, this solution is very fast."
                    },
                    {
                        "username": "meghaSamkaria",
                        "content": "by Boyer-Moore Majority Vote Algorithm in 18 ms."
                    },
                    {
                        "username": "rcode0",
                        "content": "1. Pick a random element\\n2. Check if it\\'s the majority element, this will succeed first time most of the time and we finish\\n3. Else, store the random element in a set. Pick a new random element, repick it if it\\'s already in the set. Goto 2.\\n\\nThis yielded a 0ms solution in Rust."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@youssifgamal606](/youssifgamal606) The worst case time complexity of your solution would be O((n/2)*(n))\\nwhich is equal to O(n^2)\\nExplanation : number of non-majority element is (n/2) out of (n) ==> worst case\\nfor each non-majority element we will have to iterate the whole array to find it\\'s count , and check if it is majority or not \\nTherefore for (n/2) elements , we will iterate whole array , i.e n\\nTherefore your time complexity is O(n2)\\n\\nIt is worse than sorting it and then find the majority , which will take only O(nlogn) time "
                    },
                    {
                        "username": "cswartzell",
                        "content": "How does randomizing the element you are picking help? What do you mean \"this will succeed first time\"? While statistically likely, we havent proven that. I dont think this is possible to solve in less than O(n/2 + 1) BEST case"
                    },
                    {
                        "username": "Suman_Saurabh02",
                        "content": "[@youssifgamal606](/youssifgamal606) -In step 2, if the count of the selected element is greater than floor(n/2), then it is majority."
                    },
                    {
                        "username": "youssifgamal606",
                        "content": "how do you check if it is the majority element in step 2 ?\\n"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\' \\n\\nreturn max(set(nums), key = nums.count) \\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "srk6",
                        "content": "[2,1,2,3,7] => Your algorithm returns 7 but how can 7 be the result for this input? "
                    },
                    {
                        "username": "speye_21",
                        "content": "The algorithm returns a majority element if it exists.  Your example does not have a majority element."
                    },
                    {
                        "username": "rakeshdrk",
                        "content": "Sort the array, return the mid element."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int n = nums.length -1;\\n        int ans = n/2;\\n        return nums[ans];   \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "hus250",
                        "content": "it says Time Limit Exceeded"
                    },
                    {
                        "username": "galenw",
                        "content": "Two questions for Boyer-Moore:\\n\\n1. Is it an example of DP when count == 0? The problem then reduces to finding the majority element in the remaining subarray.\\n2. Am I correct in assuming this approach will not work if the array does not contain a majority element?"
                    },
                    {
                        "username": "zacharyrhansen",
                        "content": "#1 DP is usually classified as utilizing repeated sub-problems as a means to improve efficiency. In this case, although we are solving \\'sub-problems\\' within the larger problem, the sub-problems do not contribute to the computation of other sub-problems (there is no repetition of computation). When sub-problems do repeat in a solution, the solution to the sub-problems can be stored either through memoization (top-down) or tabulation (bottom-up) so that the next time the algorithm encounters the same sub-problem it does not need to re-compute - this is what is called dynamic programming.\\n\\n#2 yes this solution would return a random number depending on the ordering of the array. If a majority is not guaranteed and you wanted to solve it in constant space, the most efficient solution would be bit-manipulation. Although the bit manipulation would still result in an incorrect number, that incorrect number should not exist in the array due to the fact that any bits that result in a majority must be derived from a combination of existing numbers. Thus you can do an additional single pass to ensure the existence of the bit manipulation result to say wither it is indeed the answer or if no answer exists."
                    },
                    {
                        "username": "vineetkumarprocoder",
                        "content": "Why this question given in Bit Manipulation Tag, How to solve using bit manipulation ?"
                    },
                    {
                        "username": "geek_",
                        "content": "solution using hashmap and arrays\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/majority-element.html"
                    },
                    {
                        "username": "ashutoshmadhwani2807",
                        "content": "This algorithm works perfectly for problems **WHERE YOU ARE SURE** about the existence of Majority Element plus this algorithm also fails to tell the exact count of Majority Element in the array.\\n\\nNow the reason why this algorithm works is because the ME is present more than n/2 times and the canditate will not change its value unless count becomes zero which will never happen even if array is sorted.\\n\\nOne more point to notice is that if the elements are present in alternative manner ie[2,3,4,3,5,3] so on , then if array has odd number of elements the last element will always be ME(logic permutation) and if the array has even number of elements then the ME has to occur in pair atleast one time ie[2,3,4,3,5,3,3] so that ME can be more than n/2 which brings to point that this algorithm **MIGHT FAIL** if ME has count of exactly n/2."
                    },
                    {
                        "username": "techysiddhant",
                        "content": " for [2,3,4,3,5,3,3] this algo is working fine\\nint majorityElement(vector<int>& nums) {\\n        int count=0;\\n        int element = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(count == 0){\\n                element = nums[i];\\n            }\\n            if(element == nums[i]) count++;\\n            else count--;\\n        }\\n        count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(element == nums[i]){\\n                count++;\\n            }\\n        }\\n        if(count > nums.size()/2){\\n            return element;\\n        }else{\\n            return -1;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "IcedLife",
                        "content": "When input is [1,1,1,3,3,4,4] answer should be 1,but the answer that fetched is 4.  I don't know if it's just me."
                    }
                ]
            },
            {
                "id": 1569870,
                "content": [
                    {
                        "username": "ghostli123",
                        "content": "I found that someone got the answer faster than 20ms by using c++. Any idea to share?"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "1 ms, by Boyer-Moore majority voting algorithm. It is guaranteed that a majority element exists so we would need 1 pass to find the majority element."
                    },
                    {
                        "username": "Abhishek06",
                        "content": "14ms, By randomly selecting any element and checking if this element is majority. Since in worse case also every second element is majority element, this solution is very fast."
                    },
                    {
                        "username": "meghaSamkaria",
                        "content": "by Boyer-Moore Majority Vote Algorithm in 18 ms."
                    },
                    {
                        "username": "rcode0",
                        "content": "1. Pick a random element\\n2. Check if it\\'s the majority element, this will succeed first time most of the time and we finish\\n3. Else, store the random element in a set. Pick a new random element, repick it if it\\'s already in the set. Goto 2.\\n\\nThis yielded a 0ms solution in Rust."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@youssifgamal606](/youssifgamal606) The worst case time complexity of your solution would be O((n/2)*(n))\\nwhich is equal to O(n^2)\\nExplanation : number of non-majority element is (n/2) out of (n) ==> worst case\\nfor each non-majority element we will have to iterate the whole array to find it\\'s count , and check if it is majority or not \\nTherefore for (n/2) elements , we will iterate whole array , i.e n\\nTherefore your time complexity is O(n2)\\n\\nIt is worse than sorting it and then find the majority , which will take only O(nlogn) time "
                    },
                    {
                        "username": "cswartzell",
                        "content": "How does randomizing the element you are picking help? What do you mean \"this will succeed first time\"? While statistically likely, we havent proven that. I dont think this is possible to solve in less than O(n/2 + 1) BEST case"
                    },
                    {
                        "username": "Suman_Saurabh02",
                        "content": "[@youssifgamal606](/youssifgamal606) -In step 2, if the count of the selected element is greater than floor(n/2), then it is majority."
                    },
                    {
                        "username": "youssifgamal606",
                        "content": "how do you check if it is the majority element in step 2 ?\\n"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\' \\n\\nreturn max(set(nums), key = nums.count) \\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "srk6",
                        "content": "[2,1,2,3,7] => Your algorithm returns 7 but how can 7 be the result for this input? "
                    },
                    {
                        "username": "speye_21",
                        "content": "The algorithm returns a majority element if it exists.  Your example does not have a majority element."
                    },
                    {
                        "username": "rakeshdrk",
                        "content": "Sort the array, return the mid element."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int n = nums.length -1;\\n        int ans = n/2;\\n        return nums[ans];   \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "hus250",
                        "content": "it says Time Limit Exceeded"
                    },
                    {
                        "username": "galenw",
                        "content": "Two questions for Boyer-Moore:\\n\\n1. Is it an example of DP when count == 0? The problem then reduces to finding the majority element in the remaining subarray.\\n2. Am I correct in assuming this approach will not work if the array does not contain a majority element?"
                    },
                    {
                        "username": "zacharyrhansen",
                        "content": "#1 DP is usually classified as utilizing repeated sub-problems as a means to improve efficiency. In this case, although we are solving \\'sub-problems\\' within the larger problem, the sub-problems do not contribute to the computation of other sub-problems (there is no repetition of computation). When sub-problems do repeat in a solution, the solution to the sub-problems can be stored either through memoization (top-down) or tabulation (bottom-up) so that the next time the algorithm encounters the same sub-problem it does not need to re-compute - this is what is called dynamic programming.\\n\\n#2 yes this solution would return a random number depending on the ordering of the array. If a majority is not guaranteed and you wanted to solve it in constant space, the most efficient solution would be bit-manipulation. Although the bit manipulation would still result in an incorrect number, that incorrect number should not exist in the array due to the fact that any bits that result in a majority must be derived from a combination of existing numbers. Thus you can do an additional single pass to ensure the existence of the bit manipulation result to say wither it is indeed the answer or if no answer exists."
                    },
                    {
                        "username": "vineetkumarprocoder",
                        "content": "Why this question given in Bit Manipulation Tag, How to solve using bit manipulation ?"
                    },
                    {
                        "username": "geek_",
                        "content": "solution using hashmap and arrays\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/majority-element.html"
                    },
                    {
                        "username": "ashutoshmadhwani2807",
                        "content": "This algorithm works perfectly for problems **WHERE YOU ARE SURE** about the existence of Majority Element plus this algorithm also fails to tell the exact count of Majority Element in the array.\\n\\nNow the reason why this algorithm works is because the ME is present more than n/2 times and the canditate will not change its value unless count becomes zero which will never happen even if array is sorted.\\n\\nOne more point to notice is that if the elements are present in alternative manner ie[2,3,4,3,5,3] so on , then if array has odd number of elements the last element will always be ME(logic permutation) and if the array has even number of elements then the ME has to occur in pair atleast one time ie[2,3,4,3,5,3,3] so that ME can be more than n/2 which brings to point that this algorithm **MIGHT FAIL** if ME has count of exactly n/2."
                    },
                    {
                        "username": "techysiddhant",
                        "content": " for [2,3,4,3,5,3,3] this algo is working fine\\nint majorityElement(vector<int>& nums) {\\n        int count=0;\\n        int element = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(count == 0){\\n                element = nums[i];\\n            }\\n            if(element == nums[i]) count++;\\n            else count--;\\n        }\\n        count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(element == nums[i]){\\n                count++;\\n            }\\n        }\\n        if(count > nums.size()/2){\\n            return element;\\n        }else{\\n            return -1;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "IcedLife",
                        "content": "When input is [1,1,1,3,3,4,4] answer should be 1,but the answer that fetched is 4.  I don't know if it's just me."
                    }
                ]
            },
            {
                "id": 1573722,
                "content": [
                    {
                        "username": "ghostli123",
                        "content": "I found that someone got the answer faster than 20ms by using c++. Any idea to share?"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "1 ms, by Boyer-Moore majority voting algorithm. It is guaranteed that a majority element exists so we would need 1 pass to find the majority element."
                    },
                    {
                        "username": "Abhishek06",
                        "content": "14ms, By randomly selecting any element and checking if this element is majority. Since in worse case also every second element is majority element, this solution is very fast."
                    },
                    {
                        "username": "meghaSamkaria",
                        "content": "by Boyer-Moore Majority Vote Algorithm in 18 ms."
                    },
                    {
                        "username": "rcode0",
                        "content": "1. Pick a random element\\n2. Check if it\\'s the majority element, this will succeed first time most of the time and we finish\\n3. Else, store the random element in a set. Pick a new random element, repick it if it\\'s already in the set. Goto 2.\\n\\nThis yielded a 0ms solution in Rust."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@youssifgamal606](/youssifgamal606) The worst case time complexity of your solution would be O((n/2)*(n))\\nwhich is equal to O(n^2)\\nExplanation : number of non-majority element is (n/2) out of (n) ==> worst case\\nfor each non-majority element we will have to iterate the whole array to find it\\'s count , and check if it is majority or not \\nTherefore for (n/2) elements , we will iterate whole array , i.e n\\nTherefore your time complexity is O(n2)\\n\\nIt is worse than sorting it and then find the majority , which will take only O(nlogn) time "
                    },
                    {
                        "username": "cswartzell",
                        "content": "How does randomizing the element you are picking help? What do you mean \"this will succeed first time\"? While statistically likely, we havent proven that. I dont think this is possible to solve in less than O(n/2 + 1) BEST case"
                    },
                    {
                        "username": "Suman_Saurabh02",
                        "content": "[@youssifgamal606](/youssifgamal606) -In step 2, if the count of the selected element is greater than floor(n/2), then it is majority."
                    },
                    {
                        "username": "youssifgamal606",
                        "content": "how do you check if it is the majority element in step 2 ?\\n"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\' \\n\\nreturn max(set(nums), key = nums.count) \\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "srk6",
                        "content": "[2,1,2,3,7] => Your algorithm returns 7 but how can 7 be the result for this input? "
                    },
                    {
                        "username": "speye_21",
                        "content": "The algorithm returns a majority element if it exists.  Your example does not have a majority element."
                    },
                    {
                        "username": "rakeshdrk",
                        "content": "Sort the array, return the mid element."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int n = nums.length -1;\\n        int ans = n/2;\\n        return nums[ans];   \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "hus250",
                        "content": "it says Time Limit Exceeded"
                    },
                    {
                        "username": "galenw",
                        "content": "Two questions for Boyer-Moore:\\n\\n1. Is it an example of DP when count == 0? The problem then reduces to finding the majority element in the remaining subarray.\\n2. Am I correct in assuming this approach will not work if the array does not contain a majority element?"
                    },
                    {
                        "username": "zacharyrhansen",
                        "content": "#1 DP is usually classified as utilizing repeated sub-problems as a means to improve efficiency. In this case, although we are solving \\'sub-problems\\' within the larger problem, the sub-problems do not contribute to the computation of other sub-problems (there is no repetition of computation). When sub-problems do repeat in a solution, the solution to the sub-problems can be stored either through memoization (top-down) or tabulation (bottom-up) so that the next time the algorithm encounters the same sub-problem it does not need to re-compute - this is what is called dynamic programming.\\n\\n#2 yes this solution would return a random number depending on the ordering of the array. If a majority is not guaranteed and you wanted to solve it in constant space, the most efficient solution would be bit-manipulation. Although the bit manipulation would still result in an incorrect number, that incorrect number should not exist in the array due to the fact that any bits that result in a majority must be derived from a combination of existing numbers. Thus you can do an additional single pass to ensure the existence of the bit manipulation result to say wither it is indeed the answer or if no answer exists."
                    },
                    {
                        "username": "vineetkumarprocoder",
                        "content": "Why this question given in Bit Manipulation Tag, How to solve using bit manipulation ?"
                    },
                    {
                        "username": "geek_",
                        "content": "solution using hashmap and arrays\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/majority-element.html"
                    },
                    {
                        "username": "ashutoshmadhwani2807",
                        "content": "This algorithm works perfectly for problems **WHERE YOU ARE SURE** about the existence of Majority Element plus this algorithm also fails to tell the exact count of Majority Element in the array.\\n\\nNow the reason why this algorithm works is because the ME is present more than n/2 times and the canditate will not change its value unless count becomes zero which will never happen even if array is sorted.\\n\\nOne more point to notice is that if the elements are present in alternative manner ie[2,3,4,3,5,3] so on , then if array has odd number of elements the last element will always be ME(logic permutation) and if the array has even number of elements then the ME has to occur in pair atleast one time ie[2,3,4,3,5,3,3] so that ME can be more than n/2 which brings to point that this algorithm **MIGHT FAIL** if ME has count of exactly n/2."
                    },
                    {
                        "username": "techysiddhant",
                        "content": " for [2,3,4,3,5,3,3] this algo is working fine\\nint majorityElement(vector<int>& nums) {\\n        int count=0;\\n        int element = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(count == 0){\\n                element = nums[i];\\n            }\\n            if(element == nums[i]) count++;\\n            else count--;\\n        }\\n        count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(element == nums[i]){\\n                count++;\\n            }\\n        }\\n        if(count > nums.size()/2){\\n            return element;\\n        }else{\\n            return -1;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "IcedLife",
                        "content": "When input is [1,1,1,3,3,4,4] answer should be 1,but the answer that fetched is 4.  I don't know if it's just me."
                    }
                ]
            },
            {
                "id": 1571369,
                "content": [
                    {
                        "username": "ghostli123",
                        "content": "I found that someone got the answer faster than 20ms by using c++. Any idea to share?"
                    },
                    {
                        "username": "saikiran1s",
                        "content": "1 ms, by Boyer-Moore majority voting algorithm. It is guaranteed that a majority element exists so we would need 1 pass to find the majority element."
                    },
                    {
                        "username": "Abhishek06",
                        "content": "14ms, By randomly selecting any element and checking if this element is majority. Since in worse case also every second element is majority element, this solution is very fast."
                    },
                    {
                        "username": "meghaSamkaria",
                        "content": "by Boyer-Moore Majority Vote Algorithm in 18 ms."
                    },
                    {
                        "username": "rcode0",
                        "content": "1. Pick a random element\\n2. Check if it\\'s the majority element, this will succeed first time most of the time and we finish\\n3. Else, store the random element in a set. Pick a new random element, repick it if it\\'s already in the set. Goto 2.\\n\\nThis yielded a 0ms solution in Rust."
                    },
                    {
                        "username": "TanveerSingh",
                        "content": "[@youssifgamal606](/youssifgamal606) The worst case time complexity of your solution would be O((n/2)*(n))\\nwhich is equal to O(n^2)\\nExplanation : number of non-majority element is (n/2) out of (n) ==> worst case\\nfor each non-majority element we will have to iterate the whole array to find it\\'s count , and check if it is majority or not \\nTherefore for (n/2) elements , we will iterate whole array , i.e n\\nTherefore your time complexity is O(n2)\\n\\nIt is worse than sorting it and then find the majority , which will take only O(nlogn) time "
                    },
                    {
                        "username": "cswartzell",
                        "content": "How does randomizing the element you are picking help? What do you mean \"this will succeed first time\"? While statistically likely, we havent proven that. I dont think this is possible to solve in less than O(n/2 + 1) BEST case"
                    },
                    {
                        "username": "Suman_Saurabh02",
                        "content": "[@youssifgamal606](/youssifgamal606) -In step 2, if the count of the selected element is greater than floor(n/2), then it is majority."
                    },
                    {
                        "username": "youssifgamal606",
                        "content": "how do you check if it is the majority element in step 2 ?\\n"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\' \\n\\nreturn max(set(nums), key = nums.count) \\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "srk6",
                        "content": "[2,1,2,3,7] => Your algorithm returns 7 but how can 7 be the result for this input? "
                    },
                    {
                        "username": "speye_21",
                        "content": "The algorithm returns a majority element if it exists.  Your example does not have a majority element."
                    },
                    {
                        "username": "rakeshdrk",
                        "content": "Sort the array, return the mid element."
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int n = nums.length -1;\\n        int ans = n/2;\\n        return nums[ans];   \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "hus250",
                        "content": "it says Time Limit Exceeded"
                    },
                    {
                        "username": "galenw",
                        "content": "Two questions for Boyer-Moore:\\n\\n1. Is it an example of DP when count == 0? The problem then reduces to finding the majority element in the remaining subarray.\\n2. Am I correct in assuming this approach will not work if the array does not contain a majority element?"
                    },
                    {
                        "username": "zacharyrhansen",
                        "content": "#1 DP is usually classified as utilizing repeated sub-problems as a means to improve efficiency. In this case, although we are solving \\'sub-problems\\' within the larger problem, the sub-problems do not contribute to the computation of other sub-problems (there is no repetition of computation). When sub-problems do repeat in a solution, the solution to the sub-problems can be stored either through memoization (top-down) or tabulation (bottom-up) so that the next time the algorithm encounters the same sub-problem it does not need to re-compute - this is what is called dynamic programming.\\n\\n#2 yes this solution would return a random number depending on the ordering of the array. If a majority is not guaranteed and you wanted to solve it in constant space, the most efficient solution would be bit-manipulation. Although the bit manipulation would still result in an incorrect number, that incorrect number should not exist in the array due to the fact that any bits that result in a majority must be derived from a combination of existing numbers. Thus you can do an additional single pass to ensure the existence of the bit manipulation result to say wither it is indeed the answer or if no answer exists."
                    },
                    {
                        "username": "vineetkumarprocoder",
                        "content": "Why this question given in Bit Manipulation Tag, How to solve using bit manipulation ?"
                    },
                    {
                        "username": "geek_",
                        "content": "solution using hashmap and arrays\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/majority-element.html"
                    },
                    {
                        "username": "ashutoshmadhwani2807",
                        "content": "This algorithm works perfectly for problems **WHERE YOU ARE SURE** about the existence of Majority Element plus this algorithm also fails to tell the exact count of Majority Element in the array.\\n\\nNow the reason why this algorithm works is because the ME is present more than n/2 times and the canditate will not change its value unless count becomes zero which will never happen even if array is sorted.\\n\\nOne more point to notice is that if the elements are present in alternative manner ie[2,3,4,3,5,3] so on , then if array has odd number of elements the last element will always be ME(logic permutation) and if the array has even number of elements then the ME has to occur in pair atleast one time ie[2,3,4,3,5,3,3] so that ME can be more than n/2 which brings to point that this algorithm **MIGHT FAIL** if ME has count of exactly n/2."
                    },
                    {
                        "username": "techysiddhant",
                        "content": " for [2,3,4,3,5,3,3] this algo is working fine\\nint majorityElement(vector<int>& nums) {\\n        int count=0;\\n        int element = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(count == 0){\\n                element = nums[i];\\n            }\\n            if(element == nums[i]) count++;\\n            else count--;\\n        }\\n        count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(element == nums[i]){\\n                count++;\\n            }\\n        }\\n        if(count > nums.size()/2){\\n            return element;\\n        }else{\\n            return -1;\\n        }\\n        return -1;\\n    }"
                    },
                    {
                        "username": "IcedLife",
                        "content": "When input is [1,1,1,3,3,4,4] answer should be 1,but the answer that fetched is 4.  I don't know if it's just me."
                    }
                ]
            },
            {
                "id": 2074481,
                "content": [
                    {
                        "username": "Shakthi5136",
                        "content": "Guys can someone help me with my time complexity? most of my code\\'s time complexity is huge and this code\\'s time complexity is no better as i was able to do this only with(O(n^2)) "
                    },
                    {
                        "username": "Shakthi5136",
                        "content": "[@kryptic_coder](/kryptic_coder) u can check my code from my submissions i guess\\n"
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "Post your algorithm"
                    },
                    {
                        "username": "merkfrom",
                        "content": "Why is my Moore Voting giving same memory usage as hash map? Shouldn\\'t it be constant space instead of linear?\\n\\nAnd how do you get ~30m or something solving via random element check, if you need linear time only to check if the choosen elem is majority?\\n\\nThx for answering."
                    },
                    {
                        "username": "ratchapongt",
                        "content": "\\nRegarding the distribution, it (nearly) always seem that most of the upvoted answers are not the fastest solution. \\n\\nFor example, in the case of Majority Element question,\\n\\n![enter image description here][1]\\n\\nAlot people are in the most upvoted answer category. So my question is that does that mean there is a much faster implementation somewhere? How do these people get such a fast solution and not sharing it? \\n\\n  [1]: http://imgur.com/WWUJqVH\\n\\nSome of the most upvoted answer seems so efficient, I don't know what other people are doing to be even more efficient. Can someone enlighten me? Thanks : )"
                    },
                    {
                        "username": "Omeradama",
                        "content": "\\t\\tdef majorityElement(self, nums: List[int]):\\n\\t\\t\\treturn sorted(nums)[len(nums)//2]"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this problem has a simple solution if we read it carefully. It says that majority element always exists and its frequency is more than n/2\\n\\nso if we sort the array in the following\\n\\ninput: [1,3,2,4,5,6,5,5,6,3,5,3,7,5,5,7,2,3,9,0,5,1,5,2,8,7,4,5]\\n\\nSorted Array: [0,1,1,2,2,2,3,3,3,3,4,4,5,5,5,5,5,5,5,5,5,6,6,7,7,7,8,9]\\n\\nwe can observe that in every case the majority element will be the one in the position n/2. \\ntry it yourself and see.\\n\\n\\nso all we have to do is sort the array and return the element ar position n/2;"
                    },
                    {
                        "username": "belyakovsergeyrus",
                        "content": "Do you mean that since such an element is necessarily present - it will most likely be in the middle of the sorted array?"
                    },
                    {
                        "username": "aritraghorai",
                        "content": "**Java  Solution**\\n![image](https://assets.leetcode.com/users/images/0a06923d-dc00-48e3-9b9f-973f07b828bc_1645414830.1471505.png)\\n**JavaScript Solution**\\n![image](https://assets.leetcode.com/users/images/6d64c92a-a06f-4fdb-a5c4-19979d167956_1645414867.9084265.png)\\n"
                    },
                    {
                        "username": "coz_its_raunak",
                        "content": "![image](https://assets.leetcode.com/users/images/7aa786ec-8e35-45a9-9141-183c6998e526_1621406612.551685.png)\\n"
                    },
                    {
                        "username": "geek_",
                        "content": "Try this one\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/majority-element.html"
                    },
                    {
                        "username": "zachh",
                        "content": "just tried to run custom test case: [1,2,3,1,1,4,4,1]\\nwhich the correct result should return 1\\nbut the 'expected answers' on leetcode OJ is 4....interesting"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "Arrays.sort(nums);\\n            return nums[nums.length/2];"
                    },
                    {
                        "username": "adi_kan",
                        "content": "Why is Boyer-Moore\\'s algorithm giving worse memory usage than Hash Map?"
                    }
                ]
            },
            {
                "id": 2034208,
                "content": [
                    {
                        "username": "Shakthi5136",
                        "content": "Guys can someone help me with my time complexity? most of my code\\'s time complexity is huge and this code\\'s time complexity is no better as i was able to do this only with(O(n^2)) "
                    },
                    {
                        "username": "Shakthi5136",
                        "content": "[@kryptic_coder](/kryptic_coder) u can check my code from my submissions i guess\\n"
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "Post your algorithm"
                    },
                    {
                        "username": "merkfrom",
                        "content": "Why is my Moore Voting giving same memory usage as hash map? Shouldn\\'t it be constant space instead of linear?\\n\\nAnd how do you get ~30m or something solving via random element check, if you need linear time only to check if the choosen elem is majority?\\n\\nThx for answering."
                    },
                    {
                        "username": "ratchapongt",
                        "content": "\\nRegarding the distribution, it (nearly) always seem that most of the upvoted answers are not the fastest solution. \\n\\nFor example, in the case of Majority Element question,\\n\\n![enter image description here][1]\\n\\nAlot people are in the most upvoted answer category. So my question is that does that mean there is a much faster implementation somewhere? How do these people get such a fast solution and not sharing it? \\n\\n  [1]: http://imgur.com/WWUJqVH\\n\\nSome of the most upvoted answer seems so efficient, I don't know what other people are doing to be even more efficient. Can someone enlighten me? Thanks : )"
                    },
                    {
                        "username": "Omeradama",
                        "content": "\\t\\tdef majorityElement(self, nums: List[int]):\\n\\t\\t\\treturn sorted(nums)[len(nums)//2]"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this problem has a simple solution if we read it carefully. It says that majority element always exists and its frequency is more than n/2\\n\\nso if we sort the array in the following\\n\\ninput: [1,3,2,4,5,6,5,5,6,3,5,3,7,5,5,7,2,3,9,0,5,1,5,2,8,7,4,5]\\n\\nSorted Array: [0,1,1,2,2,2,3,3,3,3,4,4,5,5,5,5,5,5,5,5,5,6,6,7,7,7,8,9]\\n\\nwe can observe that in every case the majority element will be the one in the position n/2. \\ntry it yourself and see.\\n\\n\\nso all we have to do is sort the array and return the element ar position n/2;"
                    },
                    {
                        "username": "belyakovsergeyrus",
                        "content": "Do you mean that since such an element is necessarily present - it will most likely be in the middle of the sorted array?"
                    },
                    {
                        "username": "aritraghorai",
                        "content": "**Java  Solution**\\n![image](https://assets.leetcode.com/users/images/0a06923d-dc00-48e3-9b9f-973f07b828bc_1645414830.1471505.png)\\n**JavaScript Solution**\\n![image](https://assets.leetcode.com/users/images/6d64c92a-a06f-4fdb-a5c4-19979d167956_1645414867.9084265.png)\\n"
                    },
                    {
                        "username": "coz_its_raunak",
                        "content": "![image](https://assets.leetcode.com/users/images/7aa786ec-8e35-45a9-9141-183c6998e526_1621406612.551685.png)\\n"
                    },
                    {
                        "username": "geek_",
                        "content": "Try this one\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/majority-element.html"
                    },
                    {
                        "username": "zachh",
                        "content": "just tried to run custom test case: [1,2,3,1,1,4,4,1]\\nwhich the correct result should return 1\\nbut the 'expected answers' on leetcode OJ is 4....interesting"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "Arrays.sort(nums);\\n            return nums[nums.length/2];"
                    },
                    {
                        "username": "adi_kan",
                        "content": "Why is Boyer-Moore\\'s algorithm giving worse memory usage than Hash Map?"
                    }
                ]
            },
            {
                "id": 1571371,
                "content": [
                    {
                        "username": "Shakthi5136",
                        "content": "Guys can someone help me with my time complexity? most of my code\\'s time complexity is huge and this code\\'s time complexity is no better as i was able to do this only with(O(n^2)) "
                    },
                    {
                        "username": "Shakthi5136",
                        "content": "[@kryptic_coder](/kryptic_coder) u can check my code from my submissions i guess\\n"
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "Post your algorithm"
                    },
                    {
                        "username": "merkfrom",
                        "content": "Why is my Moore Voting giving same memory usage as hash map? Shouldn\\'t it be constant space instead of linear?\\n\\nAnd how do you get ~30m or something solving via random element check, if you need linear time only to check if the choosen elem is majority?\\n\\nThx for answering."
                    },
                    {
                        "username": "ratchapongt",
                        "content": "\\nRegarding the distribution, it (nearly) always seem that most of the upvoted answers are not the fastest solution. \\n\\nFor example, in the case of Majority Element question,\\n\\n![enter image description here][1]\\n\\nAlot people are in the most upvoted answer category. So my question is that does that mean there is a much faster implementation somewhere? How do these people get such a fast solution and not sharing it? \\n\\n  [1]: http://imgur.com/WWUJqVH\\n\\nSome of the most upvoted answer seems so efficient, I don't know what other people are doing to be even more efficient. Can someone enlighten me? Thanks : )"
                    },
                    {
                        "username": "Omeradama",
                        "content": "\\t\\tdef majorityElement(self, nums: List[int]):\\n\\t\\t\\treturn sorted(nums)[len(nums)//2]"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this problem has a simple solution if we read it carefully. It says that majority element always exists and its frequency is more than n/2\\n\\nso if we sort the array in the following\\n\\ninput: [1,3,2,4,5,6,5,5,6,3,5,3,7,5,5,7,2,3,9,0,5,1,5,2,8,7,4,5]\\n\\nSorted Array: [0,1,1,2,2,2,3,3,3,3,4,4,5,5,5,5,5,5,5,5,5,6,6,7,7,7,8,9]\\n\\nwe can observe that in every case the majority element will be the one in the position n/2. \\ntry it yourself and see.\\n\\n\\nso all we have to do is sort the array and return the element ar position n/2;"
                    },
                    {
                        "username": "belyakovsergeyrus",
                        "content": "Do you mean that since such an element is necessarily present - it will most likely be in the middle of the sorted array?"
                    },
                    {
                        "username": "aritraghorai",
                        "content": "**Java  Solution**\\n![image](https://assets.leetcode.com/users/images/0a06923d-dc00-48e3-9b9f-973f07b828bc_1645414830.1471505.png)\\n**JavaScript Solution**\\n![image](https://assets.leetcode.com/users/images/6d64c92a-a06f-4fdb-a5c4-19979d167956_1645414867.9084265.png)\\n"
                    },
                    {
                        "username": "coz_its_raunak",
                        "content": "![image](https://assets.leetcode.com/users/images/7aa786ec-8e35-45a9-9141-183c6998e526_1621406612.551685.png)\\n"
                    },
                    {
                        "username": "geek_",
                        "content": "Try this one\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/majority-element.html"
                    },
                    {
                        "username": "zachh",
                        "content": "just tried to run custom test case: [1,2,3,1,1,4,4,1]\\nwhich the correct result should return 1\\nbut the 'expected answers' on leetcode OJ is 4....interesting"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "Arrays.sort(nums);\\n            return nums[nums.length/2];"
                    },
                    {
                        "username": "adi_kan",
                        "content": "Why is Boyer-Moore\\'s algorithm giving worse memory usage than Hash Map?"
                    }
                ]
            },
            {
                "id": 1576461,
                "content": [
                    {
                        "username": "Shakthi5136",
                        "content": "Guys can someone help me with my time complexity? most of my code\\'s time complexity is huge and this code\\'s time complexity is no better as i was able to do this only with(O(n^2)) "
                    },
                    {
                        "username": "Shakthi5136",
                        "content": "[@kryptic_coder](/kryptic_coder) u can check my code from my submissions i guess\\n"
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "Post your algorithm"
                    },
                    {
                        "username": "merkfrom",
                        "content": "Why is my Moore Voting giving same memory usage as hash map? Shouldn\\'t it be constant space instead of linear?\\n\\nAnd how do you get ~30m or something solving via random element check, if you need linear time only to check if the choosen elem is majority?\\n\\nThx for answering."
                    },
                    {
                        "username": "ratchapongt",
                        "content": "\\nRegarding the distribution, it (nearly) always seem that most of the upvoted answers are not the fastest solution. \\n\\nFor example, in the case of Majority Element question,\\n\\n![enter image description here][1]\\n\\nAlot people are in the most upvoted answer category. So my question is that does that mean there is a much faster implementation somewhere? How do these people get such a fast solution and not sharing it? \\n\\n  [1]: http://imgur.com/WWUJqVH\\n\\nSome of the most upvoted answer seems so efficient, I don't know what other people are doing to be even more efficient. Can someone enlighten me? Thanks : )"
                    },
                    {
                        "username": "Omeradama",
                        "content": "\\t\\tdef majorityElement(self, nums: List[int]):\\n\\t\\t\\treturn sorted(nums)[len(nums)//2]"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this problem has a simple solution if we read it carefully. It says that majority element always exists and its frequency is more than n/2\\n\\nso if we sort the array in the following\\n\\ninput: [1,3,2,4,5,6,5,5,6,3,5,3,7,5,5,7,2,3,9,0,5,1,5,2,8,7,4,5]\\n\\nSorted Array: [0,1,1,2,2,2,3,3,3,3,4,4,5,5,5,5,5,5,5,5,5,6,6,7,7,7,8,9]\\n\\nwe can observe that in every case the majority element will be the one in the position n/2. \\ntry it yourself and see.\\n\\n\\nso all we have to do is sort the array and return the element ar position n/2;"
                    },
                    {
                        "username": "belyakovsergeyrus",
                        "content": "Do you mean that since such an element is necessarily present - it will most likely be in the middle of the sorted array?"
                    },
                    {
                        "username": "aritraghorai",
                        "content": "**Java  Solution**\\n![image](https://assets.leetcode.com/users/images/0a06923d-dc00-48e3-9b9f-973f07b828bc_1645414830.1471505.png)\\n**JavaScript Solution**\\n![image](https://assets.leetcode.com/users/images/6d64c92a-a06f-4fdb-a5c4-19979d167956_1645414867.9084265.png)\\n"
                    },
                    {
                        "username": "coz_its_raunak",
                        "content": "![image](https://assets.leetcode.com/users/images/7aa786ec-8e35-45a9-9141-183c6998e526_1621406612.551685.png)\\n"
                    },
                    {
                        "username": "geek_",
                        "content": "Try this one\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/majority-element.html"
                    },
                    {
                        "username": "zachh",
                        "content": "just tried to run custom test case: [1,2,3,1,1,4,4,1]\\nwhich the correct result should return 1\\nbut the 'expected answers' on leetcode OJ is 4....interesting"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "Arrays.sort(nums);\\n            return nums[nums.length/2];"
                    },
                    {
                        "username": "adi_kan",
                        "content": "Why is Boyer-Moore\\'s algorithm giving worse memory usage than Hash Map?"
                    }
                ]
            },
            {
                "id": 1757436,
                "content": [
                    {
                        "username": "Shakthi5136",
                        "content": "Guys can someone help me with my time complexity? most of my code\\'s time complexity is huge and this code\\'s time complexity is no better as i was able to do this only with(O(n^2)) "
                    },
                    {
                        "username": "Shakthi5136",
                        "content": "[@kryptic_coder](/kryptic_coder) u can check my code from my submissions i guess\\n"
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "Post your algorithm"
                    },
                    {
                        "username": "merkfrom",
                        "content": "Why is my Moore Voting giving same memory usage as hash map? Shouldn\\'t it be constant space instead of linear?\\n\\nAnd how do you get ~30m or something solving via random element check, if you need linear time only to check if the choosen elem is majority?\\n\\nThx for answering."
                    },
                    {
                        "username": "ratchapongt",
                        "content": "\\nRegarding the distribution, it (nearly) always seem that most of the upvoted answers are not the fastest solution. \\n\\nFor example, in the case of Majority Element question,\\n\\n![enter image description here][1]\\n\\nAlot people are in the most upvoted answer category. So my question is that does that mean there is a much faster implementation somewhere? How do these people get such a fast solution and not sharing it? \\n\\n  [1]: http://imgur.com/WWUJqVH\\n\\nSome of the most upvoted answer seems so efficient, I don't know what other people are doing to be even more efficient. Can someone enlighten me? Thanks : )"
                    },
                    {
                        "username": "Omeradama",
                        "content": "\\t\\tdef majorityElement(self, nums: List[int]):\\n\\t\\t\\treturn sorted(nums)[len(nums)//2]"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this problem has a simple solution if we read it carefully. It says that majority element always exists and its frequency is more than n/2\\n\\nso if we sort the array in the following\\n\\ninput: [1,3,2,4,5,6,5,5,6,3,5,3,7,5,5,7,2,3,9,0,5,1,5,2,8,7,4,5]\\n\\nSorted Array: [0,1,1,2,2,2,3,3,3,3,4,4,5,5,5,5,5,5,5,5,5,6,6,7,7,7,8,9]\\n\\nwe can observe that in every case the majority element will be the one in the position n/2. \\ntry it yourself and see.\\n\\n\\nso all we have to do is sort the array and return the element ar position n/2;"
                    },
                    {
                        "username": "belyakovsergeyrus",
                        "content": "Do you mean that since such an element is necessarily present - it will most likely be in the middle of the sorted array?"
                    },
                    {
                        "username": "aritraghorai",
                        "content": "**Java  Solution**\\n![image](https://assets.leetcode.com/users/images/0a06923d-dc00-48e3-9b9f-973f07b828bc_1645414830.1471505.png)\\n**JavaScript Solution**\\n![image](https://assets.leetcode.com/users/images/6d64c92a-a06f-4fdb-a5c4-19979d167956_1645414867.9084265.png)\\n"
                    },
                    {
                        "username": "coz_its_raunak",
                        "content": "![image](https://assets.leetcode.com/users/images/7aa786ec-8e35-45a9-9141-183c6998e526_1621406612.551685.png)\\n"
                    },
                    {
                        "username": "geek_",
                        "content": "Try this one\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/majority-element.html"
                    },
                    {
                        "username": "zachh",
                        "content": "just tried to run custom test case: [1,2,3,1,1,4,4,1]\\nwhich the correct result should return 1\\nbut the 'expected answers' on leetcode OJ is 4....interesting"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "Arrays.sort(nums);\\n            return nums[nums.length/2];"
                    },
                    {
                        "username": "adi_kan",
                        "content": "Why is Boyer-Moore\\'s algorithm giving worse memory usage than Hash Map?"
                    }
                ]
            },
            {
                "id": 1576425,
                "content": [
                    {
                        "username": "Shakthi5136",
                        "content": "Guys can someone help me with my time complexity? most of my code\\'s time complexity is huge and this code\\'s time complexity is no better as i was able to do this only with(O(n^2)) "
                    },
                    {
                        "username": "Shakthi5136",
                        "content": "[@kryptic_coder](/kryptic_coder) u can check my code from my submissions i guess\\n"
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "Post your algorithm"
                    },
                    {
                        "username": "merkfrom",
                        "content": "Why is my Moore Voting giving same memory usage as hash map? Shouldn\\'t it be constant space instead of linear?\\n\\nAnd how do you get ~30m or something solving via random element check, if you need linear time only to check if the choosen elem is majority?\\n\\nThx for answering."
                    },
                    {
                        "username": "ratchapongt",
                        "content": "\\nRegarding the distribution, it (nearly) always seem that most of the upvoted answers are not the fastest solution. \\n\\nFor example, in the case of Majority Element question,\\n\\n![enter image description here][1]\\n\\nAlot people are in the most upvoted answer category. So my question is that does that mean there is a much faster implementation somewhere? How do these people get such a fast solution and not sharing it? \\n\\n  [1]: http://imgur.com/WWUJqVH\\n\\nSome of the most upvoted answer seems so efficient, I don't know what other people are doing to be even more efficient. Can someone enlighten me? Thanks : )"
                    },
                    {
                        "username": "Omeradama",
                        "content": "\\t\\tdef majorityElement(self, nums: List[int]):\\n\\t\\t\\treturn sorted(nums)[len(nums)//2]"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this problem has a simple solution if we read it carefully. It says that majority element always exists and its frequency is more than n/2\\n\\nso if we sort the array in the following\\n\\ninput: [1,3,2,4,5,6,5,5,6,3,5,3,7,5,5,7,2,3,9,0,5,1,5,2,8,7,4,5]\\n\\nSorted Array: [0,1,1,2,2,2,3,3,3,3,4,4,5,5,5,5,5,5,5,5,5,6,6,7,7,7,8,9]\\n\\nwe can observe that in every case the majority element will be the one in the position n/2. \\ntry it yourself and see.\\n\\n\\nso all we have to do is sort the array and return the element ar position n/2;"
                    },
                    {
                        "username": "belyakovsergeyrus",
                        "content": "Do you mean that since such an element is necessarily present - it will most likely be in the middle of the sorted array?"
                    },
                    {
                        "username": "aritraghorai",
                        "content": "**Java  Solution**\\n![image](https://assets.leetcode.com/users/images/0a06923d-dc00-48e3-9b9f-973f07b828bc_1645414830.1471505.png)\\n**JavaScript Solution**\\n![image](https://assets.leetcode.com/users/images/6d64c92a-a06f-4fdb-a5c4-19979d167956_1645414867.9084265.png)\\n"
                    },
                    {
                        "username": "coz_its_raunak",
                        "content": "![image](https://assets.leetcode.com/users/images/7aa786ec-8e35-45a9-9141-183c6998e526_1621406612.551685.png)\\n"
                    },
                    {
                        "username": "geek_",
                        "content": "Try this one\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/majority-element.html"
                    },
                    {
                        "username": "zachh",
                        "content": "just tried to run custom test case: [1,2,3,1,1,4,4,1]\\nwhich the correct result should return 1\\nbut the 'expected answers' on leetcode OJ is 4....interesting"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "Arrays.sort(nums);\\n            return nums[nums.length/2];"
                    },
                    {
                        "username": "adi_kan",
                        "content": "Why is Boyer-Moore\\'s algorithm giving worse memory usage than Hash Map?"
                    }
                ]
            },
            {
                "id": 1575278,
                "content": [
                    {
                        "username": "Shakthi5136",
                        "content": "Guys can someone help me with my time complexity? most of my code\\'s time complexity is huge and this code\\'s time complexity is no better as i was able to do this only with(O(n^2)) "
                    },
                    {
                        "username": "Shakthi5136",
                        "content": "[@kryptic_coder](/kryptic_coder) u can check my code from my submissions i guess\\n"
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "Post your algorithm"
                    },
                    {
                        "username": "merkfrom",
                        "content": "Why is my Moore Voting giving same memory usage as hash map? Shouldn\\'t it be constant space instead of linear?\\n\\nAnd how do you get ~30m or something solving via random element check, if you need linear time only to check if the choosen elem is majority?\\n\\nThx for answering."
                    },
                    {
                        "username": "ratchapongt",
                        "content": "\\nRegarding the distribution, it (nearly) always seem that most of the upvoted answers are not the fastest solution. \\n\\nFor example, in the case of Majority Element question,\\n\\n![enter image description here][1]\\n\\nAlot people are in the most upvoted answer category. So my question is that does that mean there is a much faster implementation somewhere? How do these people get such a fast solution and not sharing it? \\n\\n  [1]: http://imgur.com/WWUJqVH\\n\\nSome of the most upvoted answer seems so efficient, I don't know what other people are doing to be even more efficient. Can someone enlighten me? Thanks : )"
                    },
                    {
                        "username": "Omeradama",
                        "content": "\\t\\tdef majorityElement(self, nums: List[int]):\\n\\t\\t\\treturn sorted(nums)[len(nums)//2]"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this problem has a simple solution if we read it carefully. It says that majority element always exists and its frequency is more than n/2\\n\\nso if we sort the array in the following\\n\\ninput: [1,3,2,4,5,6,5,5,6,3,5,3,7,5,5,7,2,3,9,0,5,1,5,2,8,7,4,5]\\n\\nSorted Array: [0,1,1,2,2,2,3,3,3,3,4,4,5,5,5,5,5,5,5,5,5,6,6,7,7,7,8,9]\\n\\nwe can observe that in every case the majority element will be the one in the position n/2. \\ntry it yourself and see.\\n\\n\\nso all we have to do is sort the array and return the element ar position n/2;"
                    },
                    {
                        "username": "belyakovsergeyrus",
                        "content": "Do you mean that since such an element is necessarily present - it will most likely be in the middle of the sorted array?"
                    },
                    {
                        "username": "aritraghorai",
                        "content": "**Java  Solution**\\n![image](https://assets.leetcode.com/users/images/0a06923d-dc00-48e3-9b9f-973f07b828bc_1645414830.1471505.png)\\n**JavaScript Solution**\\n![image](https://assets.leetcode.com/users/images/6d64c92a-a06f-4fdb-a5c4-19979d167956_1645414867.9084265.png)\\n"
                    },
                    {
                        "username": "coz_its_raunak",
                        "content": "![image](https://assets.leetcode.com/users/images/7aa786ec-8e35-45a9-9141-183c6998e526_1621406612.551685.png)\\n"
                    },
                    {
                        "username": "geek_",
                        "content": "Try this one\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/majority-element.html"
                    },
                    {
                        "username": "zachh",
                        "content": "just tried to run custom test case: [1,2,3,1,1,4,4,1]\\nwhich the correct result should return 1\\nbut the 'expected answers' on leetcode OJ is 4....interesting"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "Arrays.sort(nums);\\n            return nums[nums.length/2];"
                    },
                    {
                        "username": "adi_kan",
                        "content": "Why is Boyer-Moore\\'s algorithm giving worse memory usage than Hash Map?"
                    }
                ]
            },
            {
                "id": 1573719,
                "content": [
                    {
                        "username": "Shakthi5136",
                        "content": "Guys can someone help me with my time complexity? most of my code\\'s time complexity is huge and this code\\'s time complexity is no better as i was able to do this only with(O(n^2)) "
                    },
                    {
                        "username": "Shakthi5136",
                        "content": "[@kryptic_coder](/kryptic_coder) u can check my code from my submissions i guess\\n"
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "Post your algorithm"
                    },
                    {
                        "username": "merkfrom",
                        "content": "Why is my Moore Voting giving same memory usage as hash map? Shouldn\\'t it be constant space instead of linear?\\n\\nAnd how do you get ~30m or something solving via random element check, if you need linear time only to check if the choosen elem is majority?\\n\\nThx for answering."
                    },
                    {
                        "username": "ratchapongt",
                        "content": "\\nRegarding the distribution, it (nearly) always seem that most of the upvoted answers are not the fastest solution. \\n\\nFor example, in the case of Majority Element question,\\n\\n![enter image description here][1]\\n\\nAlot people are in the most upvoted answer category. So my question is that does that mean there is a much faster implementation somewhere? How do these people get such a fast solution and not sharing it? \\n\\n  [1]: http://imgur.com/WWUJqVH\\n\\nSome of the most upvoted answer seems so efficient, I don't know what other people are doing to be even more efficient. Can someone enlighten me? Thanks : )"
                    },
                    {
                        "username": "Omeradama",
                        "content": "\\t\\tdef majorityElement(self, nums: List[int]):\\n\\t\\t\\treturn sorted(nums)[len(nums)//2]"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this problem has a simple solution if we read it carefully. It says that majority element always exists and its frequency is more than n/2\\n\\nso if we sort the array in the following\\n\\ninput: [1,3,2,4,5,6,5,5,6,3,5,3,7,5,5,7,2,3,9,0,5,1,5,2,8,7,4,5]\\n\\nSorted Array: [0,1,1,2,2,2,3,3,3,3,4,4,5,5,5,5,5,5,5,5,5,6,6,7,7,7,8,9]\\n\\nwe can observe that in every case the majority element will be the one in the position n/2. \\ntry it yourself and see.\\n\\n\\nso all we have to do is sort the array and return the element ar position n/2;"
                    },
                    {
                        "username": "belyakovsergeyrus",
                        "content": "Do you mean that since such an element is necessarily present - it will most likely be in the middle of the sorted array?"
                    },
                    {
                        "username": "aritraghorai",
                        "content": "**Java  Solution**\\n![image](https://assets.leetcode.com/users/images/0a06923d-dc00-48e3-9b9f-973f07b828bc_1645414830.1471505.png)\\n**JavaScript Solution**\\n![image](https://assets.leetcode.com/users/images/6d64c92a-a06f-4fdb-a5c4-19979d167956_1645414867.9084265.png)\\n"
                    },
                    {
                        "username": "coz_its_raunak",
                        "content": "![image](https://assets.leetcode.com/users/images/7aa786ec-8e35-45a9-9141-183c6998e526_1621406612.551685.png)\\n"
                    },
                    {
                        "username": "geek_",
                        "content": "Try this one\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/majority-element.html"
                    },
                    {
                        "username": "zachh",
                        "content": "just tried to run custom test case: [1,2,3,1,1,4,4,1]\\nwhich the correct result should return 1\\nbut the 'expected answers' on leetcode OJ is 4....interesting"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "Arrays.sort(nums);\\n            return nums[nums.length/2];"
                    },
                    {
                        "username": "adi_kan",
                        "content": "Why is Boyer-Moore\\'s algorithm giving worse memory usage than Hash Map?"
                    }
                ]
            },
            {
                "id": 1571370,
                "content": [
                    {
                        "username": "Shakthi5136",
                        "content": "Guys can someone help me with my time complexity? most of my code\\'s time complexity is huge and this code\\'s time complexity is no better as i was able to do this only with(O(n^2)) "
                    },
                    {
                        "username": "Shakthi5136",
                        "content": "[@kryptic_coder](/kryptic_coder) u can check my code from my submissions i guess\\n"
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "Post your algorithm"
                    },
                    {
                        "username": "merkfrom",
                        "content": "Why is my Moore Voting giving same memory usage as hash map? Shouldn\\'t it be constant space instead of linear?\\n\\nAnd how do you get ~30m or something solving via random element check, if you need linear time only to check if the choosen elem is majority?\\n\\nThx for answering."
                    },
                    {
                        "username": "ratchapongt",
                        "content": "\\nRegarding the distribution, it (nearly) always seem that most of the upvoted answers are not the fastest solution. \\n\\nFor example, in the case of Majority Element question,\\n\\n![enter image description here][1]\\n\\nAlot people are in the most upvoted answer category. So my question is that does that mean there is a much faster implementation somewhere? How do these people get such a fast solution and not sharing it? \\n\\n  [1]: http://imgur.com/WWUJqVH\\n\\nSome of the most upvoted answer seems so efficient, I don't know what other people are doing to be even more efficient. Can someone enlighten me? Thanks : )"
                    },
                    {
                        "username": "Omeradama",
                        "content": "\\t\\tdef majorityElement(self, nums: List[int]):\\n\\t\\t\\treturn sorted(nums)[len(nums)//2]"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this problem has a simple solution if we read it carefully. It says that majority element always exists and its frequency is more than n/2\\n\\nso if we sort the array in the following\\n\\ninput: [1,3,2,4,5,6,5,5,6,3,5,3,7,5,5,7,2,3,9,0,5,1,5,2,8,7,4,5]\\n\\nSorted Array: [0,1,1,2,2,2,3,3,3,3,4,4,5,5,5,5,5,5,5,5,5,6,6,7,7,7,8,9]\\n\\nwe can observe that in every case the majority element will be the one in the position n/2. \\ntry it yourself and see.\\n\\n\\nso all we have to do is sort the array and return the element ar position n/2;"
                    },
                    {
                        "username": "belyakovsergeyrus",
                        "content": "Do you mean that since such an element is necessarily present - it will most likely be in the middle of the sorted array?"
                    },
                    {
                        "username": "aritraghorai",
                        "content": "**Java  Solution**\\n![image](https://assets.leetcode.com/users/images/0a06923d-dc00-48e3-9b9f-973f07b828bc_1645414830.1471505.png)\\n**JavaScript Solution**\\n![image](https://assets.leetcode.com/users/images/6d64c92a-a06f-4fdb-a5c4-19979d167956_1645414867.9084265.png)\\n"
                    },
                    {
                        "username": "coz_its_raunak",
                        "content": "![image](https://assets.leetcode.com/users/images/7aa786ec-8e35-45a9-9141-183c6998e526_1621406612.551685.png)\\n"
                    },
                    {
                        "username": "geek_",
                        "content": "Try this one\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/majority-element.html"
                    },
                    {
                        "username": "zachh",
                        "content": "just tried to run custom test case: [1,2,3,1,1,4,4,1]\\nwhich the correct result should return 1\\nbut the 'expected answers' on leetcode OJ is 4....interesting"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "Arrays.sort(nums);\\n            return nums[nums.length/2];"
                    },
                    {
                        "username": "adi_kan",
                        "content": "Why is Boyer-Moore\\'s algorithm giving worse memory usage than Hash Map?"
                    }
                ]
            },
            {
                "id": 2069627,
                "content": [
                    {
                        "username": "Shakthi5136",
                        "content": "Guys can someone help me with my time complexity? most of my code\\'s time complexity is huge and this code\\'s time complexity is no better as i was able to do this only with(O(n^2)) "
                    },
                    {
                        "username": "Shakthi5136",
                        "content": "[@kryptic_coder](/kryptic_coder) u can check my code from my submissions i guess\\n"
                    },
                    {
                        "username": "kryptic_coder",
                        "content": "Post your algorithm"
                    },
                    {
                        "username": "merkfrom",
                        "content": "Why is my Moore Voting giving same memory usage as hash map? Shouldn\\'t it be constant space instead of linear?\\n\\nAnd how do you get ~30m or something solving via random element check, if you need linear time only to check if the choosen elem is majority?\\n\\nThx for answering."
                    },
                    {
                        "username": "ratchapongt",
                        "content": "\\nRegarding the distribution, it (nearly) always seem that most of the upvoted answers are not the fastest solution. \\n\\nFor example, in the case of Majority Element question,\\n\\n![enter image description here][1]\\n\\nAlot people are in the most upvoted answer category. So my question is that does that mean there is a much faster implementation somewhere? How do these people get such a fast solution and not sharing it? \\n\\n  [1]: http://imgur.com/WWUJqVH\\n\\nSome of the most upvoted answer seems so efficient, I don't know what other people are doing to be even more efficient. Can someone enlighten me? Thanks : )"
                    },
                    {
                        "username": "Omeradama",
                        "content": "\\t\\tdef majorityElement(self, nums: List[int]):\\n\\t\\t\\treturn sorted(nums)[len(nums)//2]"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this problem has a simple solution if we read it carefully. It says that majority element always exists and its frequency is more than n/2\\n\\nso if we sort the array in the following\\n\\ninput: [1,3,2,4,5,6,5,5,6,3,5,3,7,5,5,7,2,3,9,0,5,1,5,2,8,7,4,5]\\n\\nSorted Array: [0,1,1,2,2,2,3,3,3,3,4,4,5,5,5,5,5,5,5,5,5,6,6,7,7,7,8,9]\\n\\nwe can observe that in every case the majority element will be the one in the position n/2. \\ntry it yourself and see.\\n\\n\\nso all we have to do is sort the array and return the element ar position n/2;"
                    },
                    {
                        "username": "belyakovsergeyrus",
                        "content": "Do you mean that since such an element is necessarily present - it will most likely be in the middle of the sorted array?"
                    },
                    {
                        "username": "aritraghorai",
                        "content": "**Java  Solution**\\n![image](https://assets.leetcode.com/users/images/0a06923d-dc00-48e3-9b9f-973f07b828bc_1645414830.1471505.png)\\n**JavaScript Solution**\\n![image](https://assets.leetcode.com/users/images/6d64c92a-a06f-4fdb-a5c4-19979d167956_1645414867.9084265.png)\\n"
                    },
                    {
                        "username": "coz_its_raunak",
                        "content": "![image](https://assets.leetcode.com/users/images/7aa786ec-8e35-45a9-9141-183c6998e526_1621406612.551685.png)\\n"
                    },
                    {
                        "username": "geek_",
                        "content": "Try this one\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/majority-element.html"
                    },
                    {
                        "username": "zachh",
                        "content": "just tried to run custom test case: [1,2,3,1,1,4,4,1]\\nwhich the correct result should return 1\\nbut the 'expected answers' on leetcode OJ is 4....interesting"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "Arrays.sort(nums);\\n            return nums[nums.length/2];"
                    },
                    {
                        "username": "adi_kan",
                        "content": "Why is Boyer-Moore\\'s algorithm giving worse memory usage than Hash Map?"
                    }
                ]
            },
            {
                "id": 2064563,
                "content": [
                    {
                        "username": "lovishbansal441",
                        "content": "map<long, long> mpp;\\n        for(int i=0;i<nums.size(); i++) {\\n            mpp[nums[i]]++;\\n            if(mpp[nums[i]]>nums.size()/2) {\\n                return nums[i];\\n            }\\n        }\\nreturn 0;\\n\\nThis is a hashing method answer\\nby 0(N)"
                    },
                    {
                        "username": "Satheesh_5",
                        "content": " int e =0;\\n\\t\\tint sum=0;\\n\\t\\tint n = nums.length;\\n\\t\\tfor (int i =0 ; i<n/2; i++) {\\n\\t\\t\\t//sum++;\\n\\t\\t\\tsum+=nums[i];\\n\\t\\t\\t\\n\\t\\t\\tif (sum<=nums[i]) {\\n\\t\\t\\n\\t\\t\\t\\te+=nums[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn e;\\n\\t}\\n\\n\\n    }\\n\\nhere is every test case pass and when i submit its shows error?  can you suggest?\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "the testcases  tells me[2,2]=1, wtf?? and even when I make identical numbers in a list =1 it still tells me its not =1. even though when I run it on python its fine,\\nLeetcode you need to show all the criteria,not just 2 examples here, your just wasting peoples time having to keep tweaking the code"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@richard-akkad](/richard-akkad) Sure, you can send me the code. It's probably something to do with the way your code is interacting with the LeetCode environment.\n\nYou can post the code in a comment here. You should make sure to use triple backticks ```  around the code to create a code block and preserve the formatting. There's a formatting guide here: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "[@nikhila01](/nikhila01) hi nikhila, I did it another way instead using sort method, but my initial way of doing it wasnt accepted for some reason even though when I ran the code on python it was fine. I can send you the code if you like, maybe you might know why it wasnt working. I have only just start using leetcode :)"
                    },
                    {
                        "username": "nikhila01",
                        "content": "I'm not sure what exactly you're doing but the test cases work fine for me. The expected output of `[2,2]` is `2` and the expected output of `[1,1,1]` is `1` when I run them."
                    },
                    {
                        "username": "debanjalisaha508",
                        "content": "Is it necessary that the array has to be sorted? "
                    },
                    {
                        "username": "emengel",
                        "content": "Hey all! Seeing a lot of posts asking about the linear time and O(1) space solution. The trick is to implement a sorting algorithm that can run in O(n) time *AND* be performed in-place. There\\'s only one obvious choice for this, and I won\\'t post it here (but a quick google should send you in the right direction). Even if you implement it correctly, you\\'ll likely find that it performs worse on the test cases than does a comparative O(n*logn) sorting algorithm. Determining why this is true (and the conditions under which it might perform better) is an excellent exercise in analyzing complexity that I won\\'t spoil in this comment. Enjoy!"
                    },
                    {
                        "username": "ayunick",
                        "content": "To answer the follow-up, don\\'t try too hard if you don\\'t know Moore\\'s Voting Algorithm, it\\'s rather less likely to come up with the approach by self."
                    },
                    {
                        "username": "deerslab",
                        "content": "the challenge here is to solve with this condition:\\n\"Could you solve the problem in linear time and in O(1) space?\"\\n\\nThe answer is simple and it is [Boyer\\u2013Moore majority vote algorithm](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm)"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip: The Ans Is given In the Question .\\n\\nmid/2"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "Can Anyone Tell Me How Boyer-Moore Majority Vote Algorithm will work when you have more then 2 candidates ? \\n\\ni think it will not work \\nexample testcase \\n[2,2,2,2,2,1,1,1,1,1,1,2,2,3,3,3,3]"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "[2,2,2,2,2,1,1,1,1,1,1,2,2,3]\\n[2,2,2,2,2,1,1,1,1,1,1,2,2,3,3,3,3]\\n\\nfor both the above custom testcase i get error from leetcode saying major element does not exits "
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "[@Saketyadav](/Saketyadav) yes as i said you can not use this moores algo if there are more then 2 candidates .... in my custom testcase there is a clear major element yet i am getting error which is wrong"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "question requirment was that we have to assume that we have majority element if we have don\\'t have that so we can\\'t use moores algo try on Differ IDE and check the answer\\n"
                    }
                ]
            },
            {
                "id": 2050590,
                "content": [
                    {
                        "username": "lovishbansal441",
                        "content": "map<long, long> mpp;\\n        for(int i=0;i<nums.size(); i++) {\\n            mpp[nums[i]]++;\\n            if(mpp[nums[i]]>nums.size()/2) {\\n                return nums[i];\\n            }\\n        }\\nreturn 0;\\n\\nThis is a hashing method answer\\nby 0(N)"
                    },
                    {
                        "username": "Satheesh_5",
                        "content": " int e =0;\\n\\t\\tint sum=0;\\n\\t\\tint n = nums.length;\\n\\t\\tfor (int i =0 ; i<n/2; i++) {\\n\\t\\t\\t//sum++;\\n\\t\\t\\tsum+=nums[i];\\n\\t\\t\\t\\n\\t\\t\\tif (sum<=nums[i]) {\\n\\t\\t\\n\\t\\t\\t\\te+=nums[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn e;\\n\\t}\\n\\n\\n    }\\n\\nhere is every test case pass and when i submit its shows error?  can you suggest?\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "the testcases  tells me[2,2]=1, wtf?? and even when I make identical numbers in a list =1 it still tells me its not =1. even though when I run it on python its fine,\\nLeetcode you need to show all the criteria,not just 2 examples here, your just wasting peoples time having to keep tweaking the code"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@richard-akkad](/richard-akkad) Sure, you can send me the code. It's probably something to do with the way your code is interacting with the LeetCode environment.\n\nYou can post the code in a comment here. You should make sure to use triple backticks ```  around the code to create a code block and preserve the formatting. There's a formatting guide here: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "[@nikhila01](/nikhila01) hi nikhila, I did it another way instead using sort method, but my initial way of doing it wasnt accepted for some reason even though when I ran the code on python it was fine. I can send you the code if you like, maybe you might know why it wasnt working. I have only just start using leetcode :)"
                    },
                    {
                        "username": "nikhila01",
                        "content": "I'm not sure what exactly you're doing but the test cases work fine for me. The expected output of `[2,2]` is `2` and the expected output of `[1,1,1]` is `1` when I run them."
                    },
                    {
                        "username": "debanjalisaha508",
                        "content": "Is it necessary that the array has to be sorted? "
                    },
                    {
                        "username": "emengel",
                        "content": "Hey all! Seeing a lot of posts asking about the linear time and O(1) space solution. The trick is to implement a sorting algorithm that can run in O(n) time *AND* be performed in-place. There\\'s only one obvious choice for this, and I won\\'t post it here (but a quick google should send you in the right direction). Even if you implement it correctly, you\\'ll likely find that it performs worse on the test cases than does a comparative O(n*logn) sorting algorithm. Determining why this is true (and the conditions under which it might perform better) is an excellent exercise in analyzing complexity that I won\\'t spoil in this comment. Enjoy!"
                    },
                    {
                        "username": "ayunick",
                        "content": "To answer the follow-up, don\\'t try too hard if you don\\'t know Moore\\'s Voting Algorithm, it\\'s rather less likely to come up with the approach by self."
                    },
                    {
                        "username": "deerslab",
                        "content": "the challenge here is to solve with this condition:\\n\"Could you solve the problem in linear time and in O(1) space?\"\\n\\nThe answer is simple and it is [Boyer\\u2013Moore majority vote algorithm](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm)"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip: The Ans Is given In the Question .\\n\\nmid/2"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "Can Anyone Tell Me How Boyer-Moore Majority Vote Algorithm will work when you have more then 2 candidates ? \\n\\ni think it will not work \\nexample testcase \\n[2,2,2,2,2,1,1,1,1,1,1,2,2,3,3,3,3]"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "[2,2,2,2,2,1,1,1,1,1,1,2,2,3]\\n[2,2,2,2,2,1,1,1,1,1,1,2,2,3,3,3,3]\\n\\nfor both the above custom testcase i get error from leetcode saying major element does not exits "
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "[@Saketyadav](/Saketyadav) yes as i said you can not use this moores algo if there are more then 2 candidates .... in my custom testcase there is a clear major element yet i am getting error which is wrong"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "question requirment was that we have to assume that we have majority element if we have don\\'t have that so we can\\'t use moores algo try on Differ IDE and check the answer\\n"
                    }
                ]
            },
            {
                "id": 2037117,
                "content": [
                    {
                        "username": "lovishbansal441",
                        "content": "map<long, long> mpp;\\n        for(int i=0;i<nums.size(); i++) {\\n            mpp[nums[i]]++;\\n            if(mpp[nums[i]]>nums.size()/2) {\\n                return nums[i];\\n            }\\n        }\\nreturn 0;\\n\\nThis is a hashing method answer\\nby 0(N)"
                    },
                    {
                        "username": "Satheesh_5",
                        "content": " int e =0;\\n\\t\\tint sum=0;\\n\\t\\tint n = nums.length;\\n\\t\\tfor (int i =0 ; i<n/2; i++) {\\n\\t\\t\\t//sum++;\\n\\t\\t\\tsum+=nums[i];\\n\\t\\t\\t\\n\\t\\t\\tif (sum<=nums[i]) {\\n\\t\\t\\n\\t\\t\\t\\te+=nums[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn e;\\n\\t}\\n\\n\\n    }\\n\\nhere is every test case pass and when i submit its shows error?  can you suggest?\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "the testcases  tells me[2,2]=1, wtf?? and even when I make identical numbers in a list =1 it still tells me its not =1. even though when I run it on python its fine,\\nLeetcode you need to show all the criteria,not just 2 examples here, your just wasting peoples time having to keep tweaking the code"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@richard-akkad](/richard-akkad) Sure, you can send me the code. It's probably something to do with the way your code is interacting with the LeetCode environment.\n\nYou can post the code in a comment here. You should make sure to use triple backticks ```  around the code to create a code block and preserve the formatting. There's a formatting guide here: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "[@nikhila01](/nikhila01) hi nikhila, I did it another way instead using sort method, but my initial way of doing it wasnt accepted for some reason even though when I ran the code on python it was fine. I can send you the code if you like, maybe you might know why it wasnt working. I have only just start using leetcode :)"
                    },
                    {
                        "username": "nikhila01",
                        "content": "I'm not sure what exactly you're doing but the test cases work fine for me. The expected output of `[2,2]` is `2` and the expected output of `[1,1,1]` is `1` when I run them."
                    },
                    {
                        "username": "debanjalisaha508",
                        "content": "Is it necessary that the array has to be sorted? "
                    },
                    {
                        "username": "emengel",
                        "content": "Hey all! Seeing a lot of posts asking about the linear time and O(1) space solution. The trick is to implement a sorting algorithm that can run in O(n) time *AND* be performed in-place. There\\'s only one obvious choice for this, and I won\\'t post it here (but a quick google should send you in the right direction). Even if you implement it correctly, you\\'ll likely find that it performs worse on the test cases than does a comparative O(n*logn) sorting algorithm. Determining why this is true (and the conditions under which it might perform better) is an excellent exercise in analyzing complexity that I won\\'t spoil in this comment. Enjoy!"
                    },
                    {
                        "username": "ayunick",
                        "content": "To answer the follow-up, don\\'t try too hard if you don\\'t know Moore\\'s Voting Algorithm, it\\'s rather less likely to come up with the approach by self."
                    },
                    {
                        "username": "deerslab",
                        "content": "the challenge here is to solve with this condition:\\n\"Could you solve the problem in linear time and in O(1) space?\"\\n\\nThe answer is simple and it is [Boyer\\u2013Moore majority vote algorithm](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm)"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip: The Ans Is given In the Question .\\n\\nmid/2"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "Can Anyone Tell Me How Boyer-Moore Majority Vote Algorithm will work when you have more then 2 candidates ? \\n\\ni think it will not work \\nexample testcase \\n[2,2,2,2,2,1,1,1,1,1,1,2,2,3,3,3,3]"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "[2,2,2,2,2,1,1,1,1,1,1,2,2,3]\\n[2,2,2,2,2,1,1,1,1,1,1,2,2,3,3,3,3]\\n\\nfor both the above custom testcase i get error from leetcode saying major element does not exits "
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "[@Saketyadav](/Saketyadav) yes as i said you can not use this moores algo if there are more then 2 candidates .... in my custom testcase there is a clear major element yet i am getting error which is wrong"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "question requirment was that we have to assume that we have majority element if we have don\\'t have that so we can\\'t use moores algo try on Differ IDE and check the answer\\n"
                    }
                ]
            },
            {
                "id": 2036128,
                "content": [
                    {
                        "username": "lovishbansal441",
                        "content": "map<long, long> mpp;\\n        for(int i=0;i<nums.size(); i++) {\\n            mpp[nums[i]]++;\\n            if(mpp[nums[i]]>nums.size()/2) {\\n                return nums[i];\\n            }\\n        }\\nreturn 0;\\n\\nThis is a hashing method answer\\nby 0(N)"
                    },
                    {
                        "username": "Satheesh_5",
                        "content": " int e =0;\\n\\t\\tint sum=0;\\n\\t\\tint n = nums.length;\\n\\t\\tfor (int i =0 ; i<n/2; i++) {\\n\\t\\t\\t//sum++;\\n\\t\\t\\tsum+=nums[i];\\n\\t\\t\\t\\n\\t\\t\\tif (sum<=nums[i]) {\\n\\t\\t\\n\\t\\t\\t\\te+=nums[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn e;\\n\\t}\\n\\n\\n    }\\n\\nhere is every test case pass and when i submit its shows error?  can you suggest?\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "the testcases  tells me[2,2]=1, wtf?? and even when I make identical numbers in a list =1 it still tells me its not =1. even though when I run it on python its fine,\\nLeetcode you need to show all the criteria,not just 2 examples here, your just wasting peoples time having to keep tweaking the code"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@richard-akkad](/richard-akkad) Sure, you can send me the code. It's probably something to do with the way your code is interacting with the LeetCode environment.\n\nYou can post the code in a comment here. You should make sure to use triple backticks ```  around the code to create a code block and preserve the formatting. There's a formatting guide here: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "[@nikhila01](/nikhila01) hi nikhila, I did it another way instead using sort method, but my initial way of doing it wasnt accepted for some reason even though when I ran the code on python it was fine. I can send you the code if you like, maybe you might know why it wasnt working. I have only just start using leetcode :)"
                    },
                    {
                        "username": "nikhila01",
                        "content": "I'm not sure what exactly you're doing but the test cases work fine for me. The expected output of `[2,2]` is `2` and the expected output of `[1,1,1]` is `1` when I run them."
                    },
                    {
                        "username": "debanjalisaha508",
                        "content": "Is it necessary that the array has to be sorted? "
                    },
                    {
                        "username": "emengel",
                        "content": "Hey all! Seeing a lot of posts asking about the linear time and O(1) space solution. The trick is to implement a sorting algorithm that can run in O(n) time *AND* be performed in-place. There\\'s only one obvious choice for this, and I won\\'t post it here (but a quick google should send you in the right direction). Even if you implement it correctly, you\\'ll likely find that it performs worse on the test cases than does a comparative O(n*logn) sorting algorithm. Determining why this is true (and the conditions under which it might perform better) is an excellent exercise in analyzing complexity that I won\\'t spoil in this comment. Enjoy!"
                    },
                    {
                        "username": "ayunick",
                        "content": "To answer the follow-up, don\\'t try too hard if you don\\'t know Moore\\'s Voting Algorithm, it\\'s rather less likely to come up with the approach by self."
                    },
                    {
                        "username": "deerslab",
                        "content": "the challenge here is to solve with this condition:\\n\"Could you solve the problem in linear time and in O(1) space?\"\\n\\nThe answer is simple and it is [Boyer\\u2013Moore majority vote algorithm](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm)"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip: The Ans Is given In the Question .\\n\\nmid/2"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "Can Anyone Tell Me How Boyer-Moore Majority Vote Algorithm will work when you have more then 2 candidates ? \\n\\ni think it will not work \\nexample testcase \\n[2,2,2,2,2,1,1,1,1,1,1,2,2,3,3,3,3]"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "[2,2,2,2,2,1,1,1,1,1,1,2,2,3]\\n[2,2,2,2,2,1,1,1,1,1,1,2,2,3,3,3,3]\\n\\nfor both the above custom testcase i get error from leetcode saying major element does not exits "
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "[@Saketyadav](/Saketyadav) yes as i said you can not use this moores algo if there are more then 2 candidates .... in my custom testcase there is a clear major element yet i am getting error which is wrong"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "question requirment was that we have to assume that we have majority element if we have don\\'t have that so we can\\'t use moores algo try on Differ IDE and check the answer\\n"
                    }
                ]
            },
            {
                "id": 2024630,
                "content": [
                    {
                        "username": "lovishbansal441",
                        "content": "map<long, long> mpp;\\n        for(int i=0;i<nums.size(); i++) {\\n            mpp[nums[i]]++;\\n            if(mpp[nums[i]]>nums.size()/2) {\\n                return nums[i];\\n            }\\n        }\\nreturn 0;\\n\\nThis is a hashing method answer\\nby 0(N)"
                    },
                    {
                        "username": "Satheesh_5",
                        "content": " int e =0;\\n\\t\\tint sum=0;\\n\\t\\tint n = nums.length;\\n\\t\\tfor (int i =0 ; i<n/2; i++) {\\n\\t\\t\\t//sum++;\\n\\t\\t\\tsum+=nums[i];\\n\\t\\t\\t\\n\\t\\t\\tif (sum<=nums[i]) {\\n\\t\\t\\n\\t\\t\\t\\te+=nums[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn e;\\n\\t}\\n\\n\\n    }\\n\\nhere is every test case pass and when i submit its shows error?  can you suggest?\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "the testcases  tells me[2,2]=1, wtf?? and even when I make identical numbers in a list =1 it still tells me its not =1. even though when I run it on python its fine,\\nLeetcode you need to show all the criteria,not just 2 examples here, your just wasting peoples time having to keep tweaking the code"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@richard-akkad](/richard-akkad) Sure, you can send me the code. It's probably something to do with the way your code is interacting with the LeetCode environment.\n\nYou can post the code in a comment here. You should make sure to use triple backticks ```  around the code to create a code block and preserve the formatting. There's a formatting guide here: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "[@nikhila01](/nikhila01) hi nikhila, I did it another way instead using sort method, but my initial way of doing it wasnt accepted for some reason even though when I ran the code on python it was fine. I can send you the code if you like, maybe you might know why it wasnt working. I have only just start using leetcode :)"
                    },
                    {
                        "username": "nikhila01",
                        "content": "I'm not sure what exactly you're doing but the test cases work fine for me. The expected output of `[2,2]` is `2` and the expected output of `[1,1,1]` is `1` when I run them."
                    },
                    {
                        "username": "debanjalisaha508",
                        "content": "Is it necessary that the array has to be sorted? "
                    },
                    {
                        "username": "emengel",
                        "content": "Hey all! Seeing a lot of posts asking about the linear time and O(1) space solution. The trick is to implement a sorting algorithm that can run in O(n) time *AND* be performed in-place. There\\'s only one obvious choice for this, and I won\\'t post it here (but a quick google should send you in the right direction). Even if you implement it correctly, you\\'ll likely find that it performs worse on the test cases than does a comparative O(n*logn) sorting algorithm. Determining why this is true (and the conditions under which it might perform better) is an excellent exercise in analyzing complexity that I won\\'t spoil in this comment. Enjoy!"
                    },
                    {
                        "username": "ayunick",
                        "content": "To answer the follow-up, don\\'t try too hard if you don\\'t know Moore\\'s Voting Algorithm, it\\'s rather less likely to come up with the approach by self."
                    },
                    {
                        "username": "deerslab",
                        "content": "the challenge here is to solve with this condition:\\n\"Could you solve the problem in linear time and in O(1) space?\"\\n\\nThe answer is simple and it is [Boyer\\u2013Moore majority vote algorithm](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm)"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip: The Ans Is given In the Question .\\n\\nmid/2"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "Can Anyone Tell Me How Boyer-Moore Majority Vote Algorithm will work when you have more then 2 candidates ? \\n\\ni think it will not work \\nexample testcase \\n[2,2,2,2,2,1,1,1,1,1,1,2,2,3,3,3,3]"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "[2,2,2,2,2,1,1,1,1,1,1,2,2,3]\\n[2,2,2,2,2,1,1,1,1,1,1,2,2,3,3,3,3]\\n\\nfor both the above custom testcase i get error from leetcode saying major element does not exits "
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "[@Saketyadav](/Saketyadav) yes as i said you can not use this moores algo if there are more then 2 candidates .... in my custom testcase there is a clear major element yet i am getting error which is wrong"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "question requirment was that we have to assume that we have majority element if we have don\\'t have that so we can\\'t use moores algo try on Differ IDE and check the answer\\n"
                    }
                ]
            },
            {
                "id": 2020774,
                "content": [
                    {
                        "username": "lovishbansal441",
                        "content": "map<long, long> mpp;\\n        for(int i=0;i<nums.size(); i++) {\\n            mpp[nums[i]]++;\\n            if(mpp[nums[i]]>nums.size()/2) {\\n                return nums[i];\\n            }\\n        }\\nreturn 0;\\n\\nThis is a hashing method answer\\nby 0(N)"
                    },
                    {
                        "username": "Satheesh_5",
                        "content": " int e =0;\\n\\t\\tint sum=0;\\n\\t\\tint n = nums.length;\\n\\t\\tfor (int i =0 ; i<n/2; i++) {\\n\\t\\t\\t//sum++;\\n\\t\\t\\tsum+=nums[i];\\n\\t\\t\\t\\n\\t\\t\\tif (sum<=nums[i]) {\\n\\t\\t\\n\\t\\t\\t\\te+=nums[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn e;\\n\\t}\\n\\n\\n    }\\n\\nhere is every test case pass and when i submit its shows error?  can you suggest?\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "the testcases  tells me[2,2]=1, wtf?? and even when I make identical numbers in a list =1 it still tells me its not =1. even though when I run it on python its fine,\\nLeetcode you need to show all the criteria,not just 2 examples here, your just wasting peoples time having to keep tweaking the code"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@richard-akkad](/richard-akkad) Sure, you can send me the code. It's probably something to do with the way your code is interacting with the LeetCode environment.\n\nYou can post the code in a comment here. You should make sure to use triple backticks ```  around the code to create a code block and preserve the formatting. There's a formatting guide here: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "[@nikhila01](/nikhila01) hi nikhila, I did it another way instead using sort method, but my initial way of doing it wasnt accepted for some reason even though when I ran the code on python it was fine. I can send you the code if you like, maybe you might know why it wasnt working. I have only just start using leetcode :)"
                    },
                    {
                        "username": "nikhila01",
                        "content": "I'm not sure what exactly you're doing but the test cases work fine for me. The expected output of `[2,2]` is `2` and the expected output of `[1,1,1]` is `1` when I run them."
                    },
                    {
                        "username": "debanjalisaha508",
                        "content": "Is it necessary that the array has to be sorted? "
                    },
                    {
                        "username": "emengel",
                        "content": "Hey all! Seeing a lot of posts asking about the linear time and O(1) space solution. The trick is to implement a sorting algorithm that can run in O(n) time *AND* be performed in-place. There\\'s only one obvious choice for this, and I won\\'t post it here (but a quick google should send you in the right direction). Even if you implement it correctly, you\\'ll likely find that it performs worse on the test cases than does a comparative O(n*logn) sorting algorithm. Determining why this is true (and the conditions under which it might perform better) is an excellent exercise in analyzing complexity that I won\\'t spoil in this comment. Enjoy!"
                    },
                    {
                        "username": "ayunick",
                        "content": "To answer the follow-up, don\\'t try too hard if you don\\'t know Moore\\'s Voting Algorithm, it\\'s rather less likely to come up with the approach by self."
                    },
                    {
                        "username": "deerslab",
                        "content": "the challenge here is to solve with this condition:\\n\"Could you solve the problem in linear time and in O(1) space?\"\\n\\nThe answer is simple and it is [Boyer\\u2013Moore majority vote algorithm](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm)"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip: The Ans Is given In the Question .\\n\\nmid/2"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "Can Anyone Tell Me How Boyer-Moore Majority Vote Algorithm will work when you have more then 2 candidates ? \\n\\ni think it will not work \\nexample testcase \\n[2,2,2,2,2,1,1,1,1,1,1,2,2,3,3,3,3]"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "[2,2,2,2,2,1,1,1,1,1,1,2,2,3]\\n[2,2,2,2,2,1,1,1,1,1,1,2,2,3,3,3,3]\\n\\nfor both the above custom testcase i get error from leetcode saying major element does not exits "
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "[@Saketyadav](/Saketyadav) yes as i said you can not use this moores algo if there are more then 2 candidates .... in my custom testcase there is a clear major element yet i am getting error which is wrong"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "question requirment was that we have to assume that we have majority element if we have don\\'t have that so we can\\'t use moores algo try on Differ IDE and check the answer\\n"
                    }
                ]
            },
            {
                "id": 2018447,
                "content": [
                    {
                        "username": "lovishbansal441",
                        "content": "map<long, long> mpp;\\n        for(int i=0;i<nums.size(); i++) {\\n            mpp[nums[i]]++;\\n            if(mpp[nums[i]]>nums.size()/2) {\\n                return nums[i];\\n            }\\n        }\\nreturn 0;\\n\\nThis is a hashing method answer\\nby 0(N)"
                    },
                    {
                        "username": "Satheesh_5",
                        "content": " int e =0;\\n\\t\\tint sum=0;\\n\\t\\tint n = nums.length;\\n\\t\\tfor (int i =0 ; i<n/2; i++) {\\n\\t\\t\\t//sum++;\\n\\t\\t\\tsum+=nums[i];\\n\\t\\t\\t\\n\\t\\t\\tif (sum<=nums[i]) {\\n\\t\\t\\n\\t\\t\\t\\te+=nums[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn e;\\n\\t}\\n\\n\\n    }\\n\\nhere is every test case pass and when i submit its shows error?  can you suggest?\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "the testcases  tells me[2,2]=1, wtf?? and even when I make identical numbers in a list =1 it still tells me its not =1. even though when I run it on python its fine,\\nLeetcode you need to show all the criteria,not just 2 examples here, your just wasting peoples time having to keep tweaking the code"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@richard-akkad](/richard-akkad) Sure, you can send me the code. It's probably something to do with the way your code is interacting with the LeetCode environment.\n\nYou can post the code in a comment here. You should make sure to use triple backticks ```  around the code to create a code block and preserve the formatting. There's a formatting guide here: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "[@nikhila01](/nikhila01) hi nikhila, I did it another way instead using sort method, but my initial way of doing it wasnt accepted for some reason even though when I ran the code on python it was fine. I can send you the code if you like, maybe you might know why it wasnt working. I have only just start using leetcode :)"
                    },
                    {
                        "username": "nikhila01",
                        "content": "I'm not sure what exactly you're doing but the test cases work fine for me. The expected output of `[2,2]` is `2` and the expected output of `[1,1,1]` is `1` when I run them."
                    },
                    {
                        "username": "debanjalisaha508",
                        "content": "Is it necessary that the array has to be sorted? "
                    },
                    {
                        "username": "emengel",
                        "content": "Hey all! Seeing a lot of posts asking about the linear time and O(1) space solution. The trick is to implement a sorting algorithm that can run in O(n) time *AND* be performed in-place. There\\'s only one obvious choice for this, and I won\\'t post it here (but a quick google should send you in the right direction). Even if you implement it correctly, you\\'ll likely find that it performs worse on the test cases than does a comparative O(n*logn) sorting algorithm. Determining why this is true (and the conditions under which it might perform better) is an excellent exercise in analyzing complexity that I won\\'t spoil in this comment. Enjoy!"
                    },
                    {
                        "username": "ayunick",
                        "content": "To answer the follow-up, don\\'t try too hard if you don\\'t know Moore\\'s Voting Algorithm, it\\'s rather less likely to come up with the approach by self."
                    },
                    {
                        "username": "deerslab",
                        "content": "the challenge here is to solve with this condition:\\n\"Could you solve the problem in linear time and in O(1) space?\"\\n\\nThe answer is simple and it is [Boyer\\u2013Moore majority vote algorithm](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm)"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip: The Ans Is given In the Question .\\n\\nmid/2"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "Can Anyone Tell Me How Boyer-Moore Majority Vote Algorithm will work when you have more then 2 candidates ? \\n\\ni think it will not work \\nexample testcase \\n[2,2,2,2,2,1,1,1,1,1,1,2,2,3,3,3,3]"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "[2,2,2,2,2,1,1,1,1,1,1,2,2,3]\\n[2,2,2,2,2,1,1,1,1,1,1,2,2,3,3,3,3]\\n\\nfor both the above custom testcase i get error from leetcode saying major element does not exits "
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "[@Saketyadav](/Saketyadav) yes as i said you can not use this moores algo if there are more then 2 candidates .... in my custom testcase there is a clear major element yet i am getting error which is wrong"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "question requirment was that we have to assume that we have majority element if we have don\\'t have that so we can\\'t use moores algo try on Differ IDE and check the answer\\n"
                    }
                ]
            },
            {
                "id": 2016781,
                "content": [
                    {
                        "username": "lovishbansal441",
                        "content": "map<long, long> mpp;\\n        for(int i=0;i<nums.size(); i++) {\\n            mpp[nums[i]]++;\\n            if(mpp[nums[i]]>nums.size()/2) {\\n                return nums[i];\\n            }\\n        }\\nreturn 0;\\n\\nThis is a hashing method answer\\nby 0(N)"
                    },
                    {
                        "username": "Satheesh_5",
                        "content": " int e =0;\\n\\t\\tint sum=0;\\n\\t\\tint n = nums.length;\\n\\t\\tfor (int i =0 ; i<n/2; i++) {\\n\\t\\t\\t//sum++;\\n\\t\\t\\tsum+=nums[i];\\n\\t\\t\\t\\n\\t\\t\\tif (sum<=nums[i]) {\\n\\t\\t\\n\\t\\t\\t\\te+=nums[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn e;\\n\\t}\\n\\n\\n    }\\n\\nhere is every test case pass and when i submit its shows error?  can you suggest?\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "the testcases  tells me[2,2]=1, wtf?? and even when I make identical numbers in a list =1 it still tells me its not =1. even though when I run it on python its fine,\\nLeetcode you need to show all the criteria,not just 2 examples here, your just wasting peoples time having to keep tweaking the code"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@richard-akkad](/richard-akkad) Sure, you can send me the code. It's probably something to do with the way your code is interacting with the LeetCode environment.\n\nYou can post the code in a comment here. You should make sure to use triple backticks ```  around the code to create a code block and preserve the formatting. There's a formatting guide here: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "[@nikhila01](/nikhila01) hi nikhila, I did it another way instead using sort method, but my initial way of doing it wasnt accepted for some reason even though when I ran the code on python it was fine. I can send you the code if you like, maybe you might know why it wasnt working. I have only just start using leetcode :)"
                    },
                    {
                        "username": "nikhila01",
                        "content": "I'm not sure what exactly you're doing but the test cases work fine for me. The expected output of `[2,2]` is `2` and the expected output of `[1,1,1]` is `1` when I run them."
                    },
                    {
                        "username": "debanjalisaha508",
                        "content": "Is it necessary that the array has to be sorted? "
                    },
                    {
                        "username": "emengel",
                        "content": "Hey all! Seeing a lot of posts asking about the linear time and O(1) space solution. The trick is to implement a sorting algorithm that can run in O(n) time *AND* be performed in-place. There\\'s only one obvious choice for this, and I won\\'t post it here (but a quick google should send you in the right direction). Even if you implement it correctly, you\\'ll likely find that it performs worse on the test cases than does a comparative O(n*logn) sorting algorithm. Determining why this is true (and the conditions under which it might perform better) is an excellent exercise in analyzing complexity that I won\\'t spoil in this comment. Enjoy!"
                    },
                    {
                        "username": "ayunick",
                        "content": "To answer the follow-up, don\\'t try too hard if you don\\'t know Moore\\'s Voting Algorithm, it\\'s rather less likely to come up with the approach by self."
                    },
                    {
                        "username": "deerslab",
                        "content": "the challenge here is to solve with this condition:\\n\"Could you solve the problem in linear time and in O(1) space?\"\\n\\nThe answer is simple and it is [Boyer\\u2013Moore majority vote algorithm](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm)"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip: The Ans Is given In the Question .\\n\\nmid/2"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "Can Anyone Tell Me How Boyer-Moore Majority Vote Algorithm will work when you have more then 2 candidates ? \\n\\ni think it will not work \\nexample testcase \\n[2,2,2,2,2,1,1,1,1,1,1,2,2,3,3,3,3]"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "[2,2,2,2,2,1,1,1,1,1,1,2,2,3]\\n[2,2,2,2,2,1,1,1,1,1,1,2,2,3,3,3,3]\\n\\nfor both the above custom testcase i get error from leetcode saying major element does not exits "
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "[@Saketyadav](/Saketyadav) yes as i said you can not use this moores algo if there are more then 2 candidates .... in my custom testcase there is a clear major element yet i am getting error which is wrong"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "question requirment was that we have to assume that we have majority element if we have don\\'t have that so we can\\'t use moores algo try on Differ IDE and check the answer\\n"
                    }
                ]
            },
            {
                "id": 2014063,
                "content": [
                    {
                        "username": "lovishbansal441",
                        "content": "map<long, long> mpp;\\n        for(int i=0;i<nums.size(); i++) {\\n            mpp[nums[i]]++;\\n            if(mpp[nums[i]]>nums.size()/2) {\\n                return nums[i];\\n            }\\n        }\\nreturn 0;\\n\\nThis is a hashing method answer\\nby 0(N)"
                    },
                    {
                        "username": "Satheesh_5",
                        "content": " int e =0;\\n\\t\\tint sum=0;\\n\\t\\tint n = nums.length;\\n\\t\\tfor (int i =0 ; i<n/2; i++) {\\n\\t\\t\\t//sum++;\\n\\t\\t\\tsum+=nums[i];\\n\\t\\t\\t\\n\\t\\t\\tif (sum<=nums[i]) {\\n\\t\\t\\n\\t\\t\\t\\te+=nums[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn e;\\n\\t}\\n\\n\\n    }\\n\\nhere is every test case pass and when i submit its shows error?  can you suggest?\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "the testcases  tells me[2,2]=1, wtf?? and even when I make identical numbers in a list =1 it still tells me its not =1. even though when I run it on python its fine,\\nLeetcode you need to show all the criteria,not just 2 examples here, your just wasting peoples time having to keep tweaking the code"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@richard-akkad](/richard-akkad) Sure, you can send me the code. It's probably something to do with the way your code is interacting with the LeetCode environment.\n\nYou can post the code in a comment here. You should make sure to use triple backticks ```  around the code to create a code block and preserve the formatting. There's a formatting guide here: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "[@nikhila01](/nikhila01) hi nikhila, I did it another way instead using sort method, but my initial way of doing it wasnt accepted for some reason even though when I ran the code on python it was fine. I can send you the code if you like, maybe you might know why it wasnt working. I have only just start using leetcode :)"
                    },
                    {
                        "username": "nikhila01",
                        "content": "I'm not sure what exactly you're doing but the test cases work fine for me. The expected output of `[2,2]` is `2` and the expected output of `[1,1,1]` is `1` when I run them."
                    },
                    {
                        "username": "debanjalisaha508",
                        "content": "Is it necessary that the array has to be sorted? "
                    },
                    {
                        "username": "emengel",
                        "content": "Hey all! Seeing a lot of posts asking about the linear time and O(1) space solution. The trick is to implement a sorting algorithm that can run in O(n) time *AND* be performed in-place. There\\'s only one obvious choice for this, and I won\\'t post it here (but a quick google should send you in the right direction). Even if you implement it correctly, you\\'ll likely find that it performs worse on the test cases than does a comparative O(n*logn) sorting algorithm. Determining why this is true (and the conditions under which it might perform better) is an excellent exercise in analyzing complexity that I won\\'t spoil in this comment. Enjoy!"
                    },
                    {
                        "username": "ayunick",
                        "content": "To answer the follow-up, don\\'t try too hard if you don\\'t know Moore\\'s Voting Algorithm, it\\'s rather less likely to come up with the approach by self."
                    },
                    {
                        "username": "deerslab",
                        "content": "the challenge here is to solve with this condition:\\n\"Could you solve the problem in linear time and in O(1) space?\"\\n\\nThe answer is simple and it is [Boyer\\u2013Moore majority vote algorithm](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm)"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip: The Ans Is given In the Question .\\n\\nmid/2"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "Can Anyone Tell Me How Boyer-Moore Majority Vote Algorithm will work when you have more then 2 candidates ? \\n\\ni think it will not work \\nexample testcase \\n[2,2,2,2,2,1,1,1,1,1,1,2,2,3,3,3,3]"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "[2,2,2,2,2,1,1,1,1,1,1,2,2,3]\\n[2,2,2,2,2,1,1,1,1,1,1,2,2,3,3,3,3]\\n\\nfor both the above custom testcase i get error from leetcode saying major element does not exits "
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "[@Saketyadav](/Saketyadav) yes as i said you can not use this moores algo if there are more then 2 candidates .... in my custom testcase there is a clear major element yet i am getting error which is wrong"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "question requirment was that we have to assume that we have majority element if we have don\\'t have that so we can\\'t use moores algo try on Differ IDE and check the answer\\n"
                    }
                ]
            },
            {
                "id": 2014001,
                "content": [
                    {
                        "username": "lovishbansal441",
                        "content": "map<long, long> mpp;\\n        for(int i=0;i<nums.size(); i++) {\\n            mpp[nums[i]]++;\\n            if(mpp[nums[i]]>nums.size()/2) {\\n                return nums[i];\\n            }\\n        }\\nreturn 0;\\n\\nThis is a hashing method answer\\nby 0(N)"
                    },
                    {
                        "username": "Satheesh_5",
                        "content": " int e =0;\\n\\t\\tint sum=0;\\n\\t\\tint n = nums.length;\\n\\t\\tfor (int i =0 ; i<n/2; i++) {\\n\\t\\t\\t//sum++;\\n\\t\\t\\tsum+=nums[i];\\n\\t\\t\\t\\n\\t\\t\\tif (sum<=nums[i]) {\\n\\t\\t\\n\\t\\t\\t\\te+=nums[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn e;\\n\\t}\\n\\n\\n    }\\n\\nhere is every test case pass and when i submit its shows error?  can you suggest?\\n"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "the testcases  tells me[2,2]=1, wtf?? and even when I make identical numbers in a list =1 it still tells me its not =1. even though when I run it on python its fine,\\nLeetcode you need to show all the criteria,not just 2 examples here, your just wasting peoples time having to keep tweaking the code"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@richard-akkad](/richard-akkad) Sure, you can send me the code. It's probably something to do with the way your code is interacting with the LeetCode environment.\n\nYou can post the code in a comment here. You should make sure to use triple backticks ```  around the code to create a code block and preserve the formatting. There's a formatting guide here: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet"
                    },
                    {
                        "username": "richard-akkad",
                        "content": "[@nikhila01](/nikhila01) hi nikhila, I did it another way instead using sort method, but my initial way of doing it wasnt accepted for some reason even though when I ran the code on python it was fine. I can send you the code if you like, maybe you might know why it wasnt working. I have only just start using leetcode :)"
                    },
                    {
                        "username": "nikhila01",
                        "content": "I'm not sure what exactly you're doing but the test cases work fine for me. The expected output of `[2,2]` is `2` and the expected output of `[1,1,1]` is `1` when I run them."
                    },
                    {
                        "username": "debanjalisaha508",
                        "content": "Is it necessary that the array has to be sorted? "
                    },
                    {
                        "username": "emengel",
                        "content": "Hey all! Seeing a lot of posts asking about the linear time and O(1) space solution. The trick is to implement a sorting algorithm that can run in O(n) time *AND* be performed in-place. There\\'s only one obvious choice for this, and I won\\'t post it here (but a quick google should send you in the right direction). Even if you implement it correctly, you\\'ll likely find that it performs worse on the test cases than does a comparative O(n*logn) sorting algorithm. Determining why this is true (and the conditions under which it might perform better) is an excellent exercise in analyzing complexity that I won\\'t spoil in this comment. Enjoy!"
                    },
                    {
                        "username": "ayunick",
                        "content": "To answer the follow-up, don\\'t try too hard if you don\\'t know Moore\\'s Voting Algorithm, it\\'s rather less likely to come up with the approach by self."
                    },
                    {
                        "username": "deerslab",
                        "content": "the challenge here is to solve with this condition:\\n\"Could you solve the problem in linear time and in O(1) space?\"\\n\\nThe answer is simple and it is [Boyer\\u2013Moore majority vote algorithm](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm)"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip: The Ans Is given In the Question .\\n\\nmid/2"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "Can Anyone Tell Me How Boyer-Moore Majority Vote Algorithm will work when you have more then 2 candidates ? \\n\\ni think it will not work \\nexample testcase \\n[2,2,2,2,2,1,1,1,1,1,1,2,2,3,3,3,3]"
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "[2,2,2,2,2,1,1,1,1,1,1,2,2,3]\\n[2,2,2,2,2,1,1,1,1,1,1,2,2,3,3,3,3]\\n\\nfor both the above custom testcase i get error from leetcode saying major element does not exits "
                    },
                    {
                        "username": "iamsagarmaheta",
                        "content": "[@Saketyadav](/Saketyadav) yes as i said you can not use this moores algo if there are more then 2 candidates .... in my custom testcase there is a clear major element yet i am getting error which is wrong"
                    },
                    {
                        "username": "Saketyadav",
                        "content": "question requirment was that we have to assume that we have majority element if we have don\\'t have that so we can\\'t use moores algo try on Differ IDE and check the answer\\n"
                    }
                ]
            },
            {
                "id": 2008232,
                "content": [
                    {
                        "username": "surapallisaikiran2",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        l=[]\\n        for i in nums:\\n            if i not in l:\\n                l.append(i)\\n        for i in l:\\n            if nums.count(i)>(len(nums)/2):\\n                return i"
                    },
                    {
                        "username": "tshuryanshu",
                        "content": "Why for the test case [1,2,0,0] the result is \"There is no majority element\". Could anyone please explain it. \\n\\n```\\ncount = 0\\n        majorityElement = 0\\n        for x in range(len(nums)):\\n            if count == 0:\\n                majorityElement = nums[x]\\n                if majorityElement == nums[x]:\\n                    count +=1\\n            else:\\n                count = count - 1\\n        return majorityElement\\n```"
                    },
                    {
                        "username": "TheOnix",
                        "content": "Classic stupid problem that only checks that you know the solution and not your problem solving skills"
                    },
                    {
                        "username": "daveanue",
                        "content": "My Solution doesn't work due to being O(N^2) time out, but I think this was a good attempt before going for an linear solution. I like how clever the optimal solution was to treating every number that's your target as protons and number's that not your target as electron, and the final value should the neutrons. What I didn't like was how un-reliant the solution was to n / 2. \n\n\nMy time complexity: O(N^2), space: O(1)  attempt\nint majorityElement(vector<int>& nums) {\n        int majorityCount = nums.size() / 2, freqCount = 0;\n        int slow = 0, fast = 0;\n        int candidate;\n        while (freqCount <= majorityCount) {\n            if (freqCount == 0) {\n                candidate = nums[slow];\n            }\n            if (nums[fast] == candidate) {\n                freqCount++;\n            }\n            if (freqCount > majorityCount) return candidate;\n            if (fast == nums.size() - 1) {\n                while (slow < nums.size() && nums[slow] == candidate) {\n                    slow++;\n                } \n                candidate = nums[slow];\n                freqCount = 0;\n                fast = slow - 1;\n            }\n            // skipped once b.c fast = slow, and immediately incrementing fast\n            fast++;\n        }\n\n        return candidate;\n    }"
                    },
                    {
                        "username": "shreyans4020",
                        "content": "This will need Moore\\'s Algorithm to solve"
                    },
                    {
                        "username": "oussama_gadria",
                        "content": "Did someone know why i get undefined ?  \\nmy Solution : \\nnums.sort((a,b)=>a-b)\\nreturn nums[nums.length/2] \\n"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "why an arrow operator in this solution?\nin c++ thats invalid tell why language u use."
                    },
                    {
                        "username": "mng48301",
                        "content": "I came up with a logical approach of using for loops to count the most common element. However, when I reach testcase 41/45, where the input becomes a huge array with hundreds of values, my algorithm becomes inefficient and reaches a time limit \\n\\n`class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        n = len(nums) / 2\\n        count = 0\\n        must_break = False\\n        if len(nums) > 1:\\n            for e in range(0, len(nums) - 1):\\n                for l in range(e, len(nums)):\\n                    if nums[e] == nums[l]:\\n                        count += 1\\n                    if l == len(nums) - 1:\\n                        if count >= n:\\n                            return nums[e]\\n                            must_break = True\\n                            break\\n                        else: \\n                            count = 0\\n                if must_break:\\n                    break\\n\\n        else:\\n            return nums[0]  `."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n        for(int i=0;i<nums.length-1;i++){//first sort the elemnts\\n            for(int j=i+1;j>0;j--){\\n                if(nums[j]<nums[j-1]){\\n                    int temp=nums[j];\\n                    nums[j]=nums[j-1];\\n                    nums[j-1]=temp;\\n                }\\n            }\\n        }\\n       int mostoccured=nums[0];\\n        int start=1;\\n        int end=nums.length-1;\\n        while(start<=end){\\n            int count=0;\\n            int currentelemnt=nums[start];\\n            while(currentelemnt==mostoccured){\\n                count++;\\n                start++;\\n                if(count>=nums.length/2){\\n                    return currentelemnt;\\n                }else{\\n                mostoccured=nums[start];\\n            }\\n            }\\n\\n\\n        }\\n\\n      return -1;\\n    }\\n}this ran on my system but it doesnt run on leet code time limit exceeded\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "wiill the arrray will always contain 2 elements?\\n"
                    },
                    {
                        "username": "mhoq",
                        "content": "New to this. A bit of explnation on Linear time and O(1) would be helpful. "
                    }
                ]
            },
            {
                "id": 2005233,
                "content": [
                    {
                        "username": "surapallisaikiran2",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        l=[]\\n        for i in nums:\\n            if i not in l:\\n                l.append(i)\\n        for i in l:\\n            if nums.count(i)>(len(nums)/2):\\n                return i"
                    },
                    {
                        "username": "tshuryanshu",
                        "content": "Why for the test case [1,2,0,0] the result is \"There is no majority element\". Could anyone please explain it. \\n\\n```\\ncount = 0\\n        majorityElement = 0\\n        for x in range(len(nums)):\\n            if count == 0:\\n                majorityElement = nums[x]\\n                if majorityElement == nums[x]:\\n                    count +=1\\n            else:\\n                count = count - 1\\n        return majorityElement\\n```"
                    },
                    {
                        "username": "TheOnix",
                        "content": "Classic stupid problem that only checks that you know the solution and not your problem solving skills"
                    },
                    {
                        "username": "daveanue",
                        "content": "My Solution doesn't work due to being O(N^2) time out, but I think this was a good attempt before going for an linear solution. I like how clever the optimal solution was to treating every number that's your target as protons and number's that not your target as electron, and the final value should the neutrons. What I didn't like was how un-reliant the solution was to n / 2. \n\n\nMy time complexity: O(N^2), space: O(1)  attempt\nint majorityElement(vector<int>& nums) {\n        int majorityCount = nums.size() / 2, freqCount = 0;\n        int slow = 0, fast = 0;\n        int candidate;\n        while (freqCount <= majorityCount) {\n            if (freqCount == 0) {\n                candidate = nums[slow];\n            }\n            if (nums[fast] == candidate) {\n                freqCount++;\n            }\n            if (freqCount > majorityCount) return candidate;\n            if (fast == nums.size() - 1) {\n                while (slow < nums.size() && nums[slow] == candidate) {\n                    slow++;\n                } \n                candidate = nums[slow];\n                freqCount = 0;\n                fast = slow - 1;\n            }\n            // skipped once b.c fast = slow, and immediately incrementing fast\n            fast++;\n        }\n\n        return candidate;\n    }"
                    },
                    {
                        "username": "shreyans4020",
                        "content": "This will need Moore\\'s Algorithm to solve"
                    },
                    {
                        "username": "oussama_gadria",
                        "content": "Did someone know why i get undefined ?  \\nmy Solution : \\nnums.sort((a,b)=>a-b)\\nreturn nums[nums.length/2] \\n"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "why an arrow operator in this solution?\nin c++ thats invalid tell why language u use."
                    },
                    {
                        "username": "mng48301",
                        "content": "I came up with a logical approach of using for loops to count the most common element. However, when I reach testcase 41/45, where the input becomes a huge array with hundreds of values, my algorithm becomes inefficient and reaches a time limit \\n\\n`class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        n = len(nums) / 2\\n        count = 0\\n        must_break = False\\n        if len(nums) > 1:\\n            for e in range(0, len(nums) - 1):\\n                for l in range(e, len(nums)):\\n                    if nums[e] == nums[l]:\\n                        count += 1\\n                    if l == len(nums) - 1:\\n                        if count >= n:\\n                            return nums[e]\\n                            must_break = True\\n                            break\\n                        else: \\n                            count = 0\\n                if must_break:\\n                    break\\n\\n        else:\\n            return nums[0]  `."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n        for(int i=0;i<nums.length-1;i++){//first sort the elemnts\\n            for(int j=i+1;j>0;j--){\\n                if(nums[j]<nums[j-1]){\\n                    int temp=nums[j];\\n                    nums[j]=nums[j-1];\\n                    nums[j-1]=temp;\\n                }\\n            }\\n        }\\n       int mostoccured=nums[0];\\n        int start=1;\\n        int end=nums.length-1;\\n        while(start<=end){\\n            int count=0;\\n            int currentelemnt=nums[start];\\n            while(currentelemnt==mostoccured){\\n                count++;\\n                start++;\\n                if(count>=nums.length/2){\\n                    return currentelemnt;\\n                }else{\\n                mostoccured=nums[start];\\n            }\\n            }\\n\\n\\n        }\\n\\n      return -1;\\n    }\\n}this ran on my system but it doesnt run on leet code time limit exceeded\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "wiill the arrray will always contain 2 elements?\\n"
                    },
                    {
                        "username": "mhoq",
                        "content": "New to this. A bit of explnation on Linear time and O(1) would be helpful. "
                    }
                ]
            },
            {
                "id": 1990852,
                "content": [
                    {
                        "username": "surapallisaikiran2",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        l=[]\\n        for i in nums:\\n            if i not in l:\\n                l.append(i)\\n        for i in l:\\n            if nums.count(i)>(len(nums)/2):\\n                return i"
                    },
                    {
                        "username": "tshuryanshu",
                        "content": "Why for the test case [1,2,0,0] the result is \"There is no majority element\". Could anyone please explain it. \\n\\n```\\ncount = 0\\n        majorityElement = 0\\n        for x in range(len(nums)):\\n            if count == 0:\\n                majorityElement = nums[x]\\n                if majorityElement == nums[x]:\\n                    count +=1\\n            else:\\n                count = count - 1\\n        return majorityElement\\n```"
                    },
                    {
                        "username": "TheOnix",
                        "content": "Classic stupid problem that only checks that you know the solution and not your problem solving skills"
                    },
                    {
                        "username": "daveanue",
                        "content": "My Solution doesn't work due to being O(N^2) time out, but I think this was a good attempt before going for an linear solution. I like how clever the optimal solution was to treating every number that's your target as protons and number's that not your target as electron, and the final value should the neutrons. What I didn't like was how un-reliant the solution was to n / 2. \n\n\nMy time complexity: O(N^2), space: O(1)  attempt\nint majorityElement(vector<int>& nums) {\n        int majorityCount = nums.size() / 2, freqCount = 0;\n        int slow = 0, fast = 0;\n        int candidate;\n        while (freqCount <= majorityCount) {\n            if (freqCount == 0) {\n                candidate = nums[slow];\n            }\n            if (nums[fast] == candidate) {\n                freqCount++;\n            }\n            if (freqCount > majorityCount) return candidate;\n            if (fast == nums.size() - 1) {\n                while (slow < nums.size() && nums[slow] == candidate) {\n                    slow++;\n                } \n                candidate = nums[slow];\n                freqCount = 0;\n                fast = slow - 1;\n            }\n            // skipped once b.c fast = slow, and immediately incrementing fast\n            fast++;\n        }\n\n        return candidate;\n    }"
                    },
                    {
                        "username": "shreyans4020",
                        "content": "This will need Moore\\'s Algorithm to solve"
                    },
                    {
                        "username": "oussama_gadria",
                        "content": "Did someone know why i get undefined ?  \\nmy Solution : \\nnums.sort((a,b)=>a-b)\\nreturn nums[nums.length/2] \\n"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "why an arrow operator in this solution?\nin c++ thats invalid tell why language u use."
                    },
                    {
                        "username": "mng48301",
                        "content": "I came up with a logical approach of using for loops to count the most common element. However, when I reach testcase 41/45, where the input becomes a huge array with hundreds of values, my algorithm becomes inefficient and reaches a time limit \\n\\n`class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        n = len(nums) / 2\\n        count = 0\\n        must_break = False\\n        if len(nums) > 1:\\n            for e in range(0, len(nums) - 1):\\n                for l in range(e, len(nums)):\\n                    if nums[e] == nums[l]:\\n                        count += 1\\n                    if l == len(nums) - 1:\\n                        if count >= n:\\n                            return nums[e]\\n                            must_break = True\\n                            break\\n                        else: \\n                            count = 0\\n                if must_break:\\n                    break\\n\\n        else:\\n            return nums[0]  `."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n        for(int i=0;i<nums.length-1;i++){//first sort the elemnts\\n            for(int j=i+1;j>0;j--){\\n                if(nums[j]<nums[j-1]){\\n                    int temp=nums[j];\\n                    nums[j]=nums[j-1];\\n                    nums[j-1]=temp;\\n                }\\n            }\\n        }\\n       int mostoccured=nums[0];\\n        int start=1;\\n        int end=nums.length-1;\\n        while(start<=end){\\n            int count=0;\\n            int currentelemnt=nums[start];\\n            while(currentelemnt==mostoccured){\\n                count++;\\n                start++;\\n                if(count>=nums.length/2){\\n                    return currentelemnt;\\n                }else{\\n                mostoccured=nums[start];\\n            }\\n            }\\n\\n\\n        }\\n\\n      return -1;\\n    }\\n}this ran on my system but it doesnt run on leet code time limit exceeded\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "wiill the arrray will always contain 2 elements?\\n"
                    },
                    {
                        "username": "mhoq",
                        "content": "New to this. A bit of explnation on Linear time and O(1) would be helpful. "
                    }
                ]
            },
            {
                "id": 1976254,
                "content": [
                    {
                        "username": "surapallisaikiran2",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        l=[]\\n        for i in nums:\\n            if i not in l:\\n                l.append(i)\\n        for i in l:\\n            if nums.count(i)>(len(nums)/2):\\n                return i"
                    },
                    {
                        "username": "tshuryanshu",
                        "content": "Why for the test case [1,2,0,0] the result is \"There is no majority element\". Could anyone please explain it. \\n\\n```\\ncount = 0\\n        majorityElement = 0\\n        for x in range(len(nums)):\\n            if count == 0:\\n                majorityElement = nums[x]\\n                if majorityElement == nums[x]:\\n                    count +=1\\n            else:\\n                count = count - 1\\n        return majorityElement\\n```"
                    },
                    {
                        "username": "TheOnix",
                        "content": "Classic stupid problem that only checks that you know the solution and not your problem solving skills"
                    },
                    {
                        "username": "daveanue",
                        "content": "My Solution doesn't work due to being O(N^2) time out, but I think this was a good attempt before going for an linear solution. I like how clever the optimal solution was to treating every number that's your target as protons and number's that not your target as electron, and the final value should the neutrons. What I didn't like was how un-reliant the solution was to n / 2. \n\n\nMy time complexity: O(N^2), space: O(1)  attempt\nint majorityElement(vector<int>& nums) {\n        int majorityCount = nums.size() / 2, freqCount = 0;\n        int slow = 0, fast = 0;\n        int candidate;\n        while (freqCount <= majorityCount) {\n            if (freqCount == 0) {\n                candidate = nums[slow];\n            }\n            if (nums[fast] == candidate) {\n                freqCount++;\n            }\n            if (freqCount > majorityCount) return candidate;\n            if (fast == nums.size() - 1) {\n                while (slow < nums.size() && nums[slow] == candidate) {\n                    slow++;\n                } \n                candidate = nums[slow];\n                freqCount = 0;\n                fast = slow - 1;\n            }\n            // skipped once b.c fast = slow, and immediately incrementing fast\n            fast++;\n        }\n\n        return candidate;\n    }"
                    },
                    {
                        "username": "shreyans4020",
                        "content": "This will need Moore\\'s Algorithm to solve"
                    },
                    {
                        "username": "oussama_gadria",
                        "content": "Did someone know why i get undefined ?  \\nmy Solution : \\nnums.sort((a,b)=>a-b)\\nreturn nums[nums.length/2] \\n"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "why an arrow operator in this solution?\nin c++ thats invalid tell why language u use."
                    },
                    {
                        "username": "mng48301",
                        "content": "I came up with a logical approach of using for loops to count the most common element. However, when I reach testcase 41/45, where the input becomes a huge array with hundreds of values, my algorithm becomes inefficient and reaches a time limit \\n\\n`class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        n = len(nums) / 2\\n        count = 0\\n        must_break = False\\n        if len(nums) > 1:\\n            for e in range(0, len(nums) - 1):\\n                for l in range(e, len(nums)):\\n                    if nums[e] == nums[l]:\\n                        count += 1\\n                    if l == len(nums) - 1:\\n                        if count >= n:\\n                            return nums[e]\\n                            must_break = True\\n                            break\\n                        else: \\n                            count = 0\\n                if must_break:\\n                    break\\n\\n        else:\\n            return nums[0]  `."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n        for(int i=0;i<nums.length-1;i++){//first sort the elemnts\\n            for(int j=i+1;j>0;j--){\\n                if(nums[j]<nums[j-1]){\\n                    int temp=nums[j];\\n                    nums[j]=nums[j-1];\\n                    nums[j-1]=temp;\\n                }\\n            }\\n        }\\n       int mostoccured=nums[0];\\n        int start=1;\\n        int end=nums.length-1;\\n        while(start<=end){\\n            int count=0;\\n            int currentelemnt=nums[start];\\n            while(currentelemnt==mostoccured){\\n                count++;\\n                start++;\\n                if(count>=nums.length/2){\\n                    return currentelemnt;\\n                }else{\\n                mostoccured=nums[start];\\n            }\\n            }\\n\\n\\n        }\\n\\n      return -1;\\n    }\\n}this ran on my system but it doesnt run on leet code time limit exceeded\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "wiill the arrray will always contain 2 elements?\\n"
                    },
                    {
                        "username": "mhoq",
                        "content": "New to this. A bit of explnation on Linear time and O(1) would be helpful. "
                    }
                ]
            },
            {
                "id": 1974600,
                "content": [
                    {
                        "username": "surapallisaikiran2",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        l=[]\\n        for i in nums:\\n            if i not in l:\\n                l.append(i)\\n        for i in l:\\n            if nums.count(i)>(len(nums)/2):\\n                return i"
                    },
                    {
                        "username": "tshuryanshu",
                        "content": "Why for the test case [1,2,0,0] the result is \"There is no majority element\". Could anyone please explain it. \\n\\n```\\ncount = 0\\n        majorityElement = 0\\n        for x in range(len(nums)):\\n            if count == 0:\\n                majorityElement = nums[x]\\n                if majorityElement == nums[x]:\\n                    count +=1\\n            else:\\n                count = count - 1\\n        return majorityElement\\n```"
                    },
                    {
                        "username": "TheOnix",
                        "content": "Classic stupid problem that only checks that you know the solution and not your problem solving skills"
                    },
                    {
                        "username": "daveanue",
                        "content": "My Solution doesn't work due to being O(N^2) time out, but I think this was a good attempt before going for an linear solution. I like how clever the optimal solution was to treating every number that's your target as protons and number's that not your target as electron, and the final value should the neutrons. What I didn't like was how un-reliant the solution was to n / 2. \n\n\nMy time complexity: O(N^2), space: O(1)  attempt\nint majorityElement(vector<int>& nums) {\n        int majorityCount = nums.size() / 2, freqCount = 0;\n        int slow = 0, fast = 0;\n        int candidate;\n        while (freqCount <= majorityCount) {\n            if (freqCount == 0) {\n                candidate = nums[slow];\n            }\n            if (nums[fast] == candidate) {\n                freqCount++;\n            }\n            if (freqCount > majorityCount) return candidate;\n            if (fast == nums.size() - 1) {\n                while (slow < nums.size() && nums[slow] == candidate) {\n                    slow++;\n                } \n                candidate = nums[slow];\n                freqCount = 0;\n                fast = slow - 1;\n            }\n            // skipped once b.c fast = slow, and immediately incrementing fast\n            fast++;\n        }\n\n        return candidate;\n    }"
                    },
                    {
                        "username": "shreyans4020",
                        "content": "This will need Moore\\'s Algorithm to solve"
                    },
                    {
                        "username": "oussama_gadria",
                        "content": "Did someone know why i get undefined ?  \\nmy Solution : \\nnums.sort((a,b)=>a-b)\\nreturn nums[nums.length/2] \\n"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "why an arrow operator in this solution?\nin c++ thats invalid tell why language u use."
                    },
                    {
                        "username": "mng48301",
                        "content": "I came up with a logical approach of using for loops to count the most common element. However, when I reach testcase 41/45, where the input becomes a huge array with hundreds of values, my algorithm becomes inefficient and reaches a time limit \\n\\n`class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        n = len(nums) / 2\\n        count = 0\\n        must_break = False\\n        if len(nums) > 1:\\n            for e in range(0, len(nums) - 1):\\n                for l in range(e, len(nums)):\\n                    if nums[e] == nums[l]:\\n                        count += 1\\n                    if l == len(nums) - 1:\\n                        if count >= n:\\n                            return nums[e]\\n                            must_break = True\\n                            break\\n                        else: \\n                            count = 0\\n                if must_break:\\n                    break\\n\\n        else:\\n            return nums[0]  `."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n        for(int i=0;i<nums.length-1;i++){//first sort the elemnts\\n            for(int j=i+1;j>0;j--){\\n                if(nums[j]<nums[j-1]){\\n                    int temp=nums[j];\\n                    nums[j]=nums[j-1];\\n                    nums[j-1]=temp;\\n                }\\n            }\\n        }\\n       int mostoccured=nums[0];\\n        int start=1;\\n        int end=nums.length-1;\\n        while(start<=end){\\n            int count=0;\\n            int currentelemnt=nums[start];\\n            while(currentelemnt==mostoccured){\\n                count++;\\n                start++;\\n                if(count>=nums.length/2){\\n                    return currentelemnt;\\n                }else{\\n                mostoccured=nums[start];\\n            }\\n            }\\n\\n\\n        }\\n\\n      return -1;\\n    }\\n}this ran on my system but it doesnt run on leet code time limit exceeded\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "wiill the arrray will always contain 2 elements?\\n"
                    },
                    {
                        "username": "mhoq",
                        "content": "New to this. A bit of explnation on Linear time and O(1) would be helpful. "
                    }
                ]
            },
            {
                "id": 1973031,
                "content": [
                    {
                        "username": "surapallisaikiran2",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        l=[]\\n        for i in nums:\\n            if i not in l:\\n                l.append(i)\\n        for i in l:\\n            if nums.count(i)>(len(nums)/2):\\n                return i"
                    },
                    {
                        "username": "tshuryanshu",
                        "content": "Why for the test case [1,2,0,0] the result is \"There is no majority element\". Could anyone please explain it. \\n\\n```\\ncount = 0\\n        majorityElement = 0\\n        for x in range(len(nums)):\\n            if count == 0:\\n                majorityElement = nums[x]\\n                if majorityElement == nums[x]:\\n                    count +=1\\n            else:\\n                count = count - 1\\n        return majorityElement\\n```"
                    },
                    {
                        "username": "TheOnix",
                        "content": "Classic stupid problem that only checks that you know the solution and not your problem solving skills"
                    },
                    {
                        "username": "daveanue",
                        "content": "My Solution doesn't work due to being O(N^2) time out, but I think this was a good attempt before going for an linear solution. I like how clever the optimal solution was to treating every number that's your target as protons and number's that not your target as electron, and the final value should the neutrons. What I didn't like was how un-reliant the solution was to n / 2. \n\n\nMy time complexity: O(N^2), space: O(1)  attempt\nint majorityElement(vector<int>& nums) {\n        int majorityCount = nums.size() / 2, freqCount = 0;\n        int slow = 0, fast = 0;\n        int candidate;\n        while (freqCount <= majorityCount) {\n            if (freqCount == 0) {\n                candidate = nums[slow];\n            }\n            if (nums[fast] == candidate) {\n                freqCount++;\n            }\n            if (freqCount > majorityCount) return candidate;\n            if (fast == nums.size() - 1) {\n                while (slow < nums.size() && nums[slow] == candidate) {\n                    slow++;\n                } \n                candidate = nums[slow];\n                freqCount = 0;\n                fast = slow - 1;\n            }\n            // skipped once b.c fast = slow, and immediately incrementing fast\n            fast++;\n        }\n\n        return candidate;\n    }"
                    },
                    {
                        "username": "shreyans4020",
                        "content": "This will need Moore\\'s Algorithm to solve"
                    },
                    {
                        "username": "oussama_gadria",
                        "content": "Did someone know why i get undefined ?  \\nmy Solution : \\nnums.sort((a,b)=>a-b)\\nreturn nums[nums.length/2] \\n"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "why an arrow operator in this solution?\nin c++ thats invalid tell why language u use."
                    },
                    {
                        "username": "mng48301",
                        "content": "I came up with a logical approach of using for loops to count the most common element. However, when I reach testcase 41/45, where the input becomes a huge array with hundreds of values, my algorithm becomes inefficient and reaches a time limit \\n\\n`class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        n = len(nums) / 2\\n        count = 0\\n        must_break = False\\n        if len(nums) > 1:\\n            for e in range(0, len(nums) - 1):\\n                for l in range(e, len(nums)):\\n                    if nums[e] == nums[l]:\\n                        count += 1\\n                    if l == len(nums) - 1:\\n                        if count >= n:\\n                            return nums[e]\\n                            must_break = True\\n                            break\\n                        else: \\n                            count = 0\\n                if must_break:\\n                    break\\n\\n        else:\\n            return nums[0]  `."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n        for(int i=0;i<nums.length-1;i++){//first sort the elemnts\\n            for(int j=i+1;j>0;j--){\\n                if(nums[j]<nums[j-1]){\\n                    int temp=nums[j];\\n                    nums[j]=nums[j-1];\\n                    nums[j-1]=temp;\\n                }\\n            }\\n        }\\n       int mostoccured=nums[0];\\n        int start=1;\\n        int end=nums.length-1;\\n        while(start<=end){\\n            int count=0;\\n            int currentelemnt=nums[start];\\n            while(currentelemnt==mostoccured){\\n                count++;\\n                start++;\\n                if(count>=nums.length/2){\\n                    return currentelemnt;\\n                }else{\\n                mostoccured=nums[start];\\n            }\\n            }\\n\\n\\n        }\\n\\n      return -1;\\n    }\\n}this ran on my system but it doesnt run on leet code time limit exceeded\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "wiill the arrray will always contain 2 elements?\\n"
                    },
                    {
                        "username": "mhoq",
                        "content": "New to this. A bit of explnation on Linear time and O(1) would be helpful. "
                    }
                ]
            },
            {
                "id": 1962020,
                "content": [
                    {
                        "username": "surapallisaikiran2",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        l=[]\\n        for i in nums:\\n            if i not in l:\\n                l.append(i)\\n        for i in l:\\n            if nums.count(i)>(len(nums)/2):\\n                return i"
                    },
                    {
                        "username": "tshuryanshu",
                        "content": "Why for the test case [1,2,0,0] the result is \"There is no majority element\". Could anyone please explain it. \\n\\n```\\ncount = 0\\n        majorityElement = 0\\n        for x in range(len(nums)):\\n            if count == 0:\\n                majorityElement = nums[x]\\n                if majorityElement == nums[x]:\\n                    count +=1\\n            else:\\n                count = count - 1\\n        return majorityElement\\n```"
                    },
                    {
                        "username": "TheOnix",
                        "content": "Classic stupid problem that only checks that you know the solution and not your problem solving skills"
                    },
                    {
                        "username": "daveanue",
                        "content": "My Solution doesn't work due to being O(N^2) time out, but I think this was a good attempt before going for an linear solution. I like how clever the optimal solution was to treating every number that's your target as protons and number's that not your target as electron, and the final value should the neutrons. What I didn't like was how un-reliant the solution was to n / 2. \n\n\nMy time complexity: O(N^2), space: O(1)  attempt\nint majorityElement(vector<int>& nums) {\n        int majorityCount = nums.size() / 2, freqCount = 0;\n        int slow = 0, fast = 0;\n        int candidate;\n        while (freqCount <= majorityCount) {\n            if (freqCount == 0) {\n                candidate = nums[slow];\n            }\n            if (nums[fast] == candidate) {\n                freqCount++;\n            }\n            if (freqCount > majorityCount) return candidate;\n            if (fast == nums.size() - 1) {\n                while (slow < nums.size() && nums[slow] == candidate) {\n                    slow++;\n                } \n                candidate = nums[slow];\n                freqCount = 0;\n                fast = slow - 1;\n            }\n            // skipped once b.c fast = slow, and immediately incrementing fast\n            fast++;\n        }\n\n        return candidate;\n    }"
                    },
                    {
                        "username": "shreyans4020",
                        "content": "This will need Moore\\'s Algorithm to solve"
                    },
                    {
                        "username": "oussama_gadria",
                        "content": "Did someone know why i get undefined ?  \\nmy Solution : \\nnums.sort((a,b)=>a-b)\\nreturn nums[nums.length/2] \\n"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "why an arrow operator in this solution?\nin c++ thats invalid tell why language u use."
                    },
                    {
                        "username": "mng48301",
                        "content": "I came up with a logical approach of using for loops to count the most common element. However, when I reach testcase 41/45, where the input becomes a huge array with hundreds of values, my algorithm becomes inefficient and reaches a time limit \\n\\n`class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        n = len(nums) / 2\\n        count = 0\\n        must_break = False\\n        if len(nums) > 1:\\n            for e in range(0, len(nums) - 1):\\n                for l in range(e, len(nums)):\\n                    if nums[e] == nums[l]:\\n                        count += 1\\n                    if l == len(nums) - 1:\\n                        if count >= n:\\n                            return nums[e]\\n                            must_break = True\\n                            break\\n                        else: \\n                            count = 0\\n                if must_break:\\n                    break\\n\\n        else:\\n            return nums[0]  `."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n        for(int i=0;i<nums.length-1;i++){//first sort the elemnts\\n            for(int j=i+1;j>0;j--){\\n                if(nums[j]<nums[j-1]){\\n                    int temp=nums[j];\\n                    nums[j]=nums[j-1];\\n                    nums[j-1]=temp;\\n                }\\n            }\\n        }\\n       int mostoccured=nums[0];\\n        int start=1;\\n        int end=nums.length-1;\\n        while(start<=end){\\n            int count=0;\\n            int currentelemnt=nums[start];\\n            while(currentelemnt==mostoccured){\\n                count++;\\n                start++;\\n                if(count>=nums.length/2){\\n                    return currentelemnt;\\n                }else{\\n                mostoccured=nums[start];\\n            }\\n            }\\n\\n\\n        }\\n\\n      return -1;\\n    }\\n}this ran on my system but it doesnt run on leet code time limit exceeded\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "wiill the arrray will always contain 2 elements?\\n"
                    },
                    {
                        "username": "mhoq",
                        "content": "New to this. A bit of explnation on Linear time and O(1) would be helpful. "
                    }
                ]
            },
            {
                "id": 1961177,
                "content": [
                    {
                        "username": "surapallisaikiran2",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        l=[]\\n        for i in nums:\\n            if i not in l:\\n                l.append(i)\\n        for i in l:\\n            if nums.count(i)>(len(nums)/2):\\n                return i"
                    },
                    {
                        "username": "tshuryanshu",
                        "content": "Why for the test case [1,2,0,0] the result is \"There is no majority element\". Could anyone please explain it. \\n\\n```\\ncount = 0\\n        majorityElement = 0\\n        for x in range(len(nums)):\\n            if count == 0:\\n                majorityElement = nums[x]\\n                if majorityElement == nums[x]:\\n                    count +=1\\n            else:\\n                count = count - 1\\n        return majorityElement\\n```"
                    },
                    {
                        "username": "TheOnix",
                        "content": "Classic stupid problem that only checks that you know the solution and not your problem solving skills"
                    },
                    {
                        "username": "daveanue",
                        "content": "My Solution doesn't work due to being O(N^2) time out, but I think this was a good attempt before going for an linear solution. I like how clever the optimal solution was to treating every number that's your target as protons and number's that not your target as electron, and the final value should the neutrons. What I didn't like was how un-reliant the solution was to n / 2. \n\n\nMy time complexity: O(N^2), space: O(1)  attempt\nint majorityElement(vector<int>& nums) {\n        int majorityCount = nums.size() / 2, freqCount = 0;\n        int slow = 0, fast = 0;\n        int candidate;\n        while (freqCount <= majorityCount) {\n            if (freqCount == 0) {\n                candidate = nums[slow];\n            }\n            if (nums[fast] == candidate) {\n                freqCount++;\n            }\n            if (freqCount > majorityCount) return candidate;\n            if (fast == nums.size() - 1) {\n                while (slow < nums.size() && nums[slow] == candidate) {\n                    slow++;\n                } \n                candidate = nums[slow];\n                freqCount = 0;\n                fast = slow - 1;\n            }\n            // skipped once b.c fast = slow, and immediately incrementing fast\n            fast++;\n        }\n\n        return candidate;\n    }"
                    },
                    {
                        "username": "shreyans4020",
                        "content": "This will need Moore\\'s Algorithm to solve"
                    },
                    {
                        "username": "oussama_gadria",
                        "content": "Did someone know why i get undefined ?  \\nmy Solution : \\nnums.sort((a,b)=>a-b)\\nreturn nums[nums.length/2] \\n"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "why an arrow operator in this solution?\nin c++ thats invalid tell why language u use."
                    },
                    {
                        "username": "mng48301",
                        "content": "I came up with a logical approach of using for loops to count the most common element. However, when I reach testcase 41/45, where the input becomes a huge array with hundreds of values, my algorithm becomes inefficient and reaches a time limit \\n\\n`class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        n = len(nums) / 2\\n        count = 0\\n        must_break = False\\n        if len(nums) > 1:\\n            for e in range(0, len(nums) - 1):\\n                for l in range(e, len(nums)):\\n                    if nums[e] == nums[l]:\\n                        count += 1\\n                    if l == len(nums) - 1:\\n                        if count >= n:\\n                            return nums[e]\\n                            must_break = True\\n                            break\\n                        else: \\n                            count = 0\\n                if must_break:\\n                    break\\n\\n        else:\\n            return nums[0]  `."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n        for(int i=0;i<nums.length-1;i++){//first sort the elemnts\\n            for(int j=i+1;j>0;j--){\\n                if(nums[j]<nums[j-1]){\\n                    int temp=nums[j];\\n                    nums[j]=nums[j-1];\\n                    nums[j-1]=temp;\\n                }\\n            }\\n        }\\n       int mostoccured=nums[0];\\n        int start=1;\\n        int end=nums.length-1;\\n        while(start<=end){\\n            int count=0;\\n            int currentelemnt=nums[start];\\n            while(currentelemnt==mostoccured){\\n                count++;\\n                start++;\\n                if(count>=nums.length/2){\\n                    return currentelemnt;\\n                }else{\\n                mostoccured=nums[start];\\n            }\\n            }\\n\\n\\n        }\\n\\n      return -1;\\n    }\\n}this ran on my system but it doesnt run on leet code time limit exceeded\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "wiill the arrray will always contain 2 elements?\\n"
                    },
                    {
                        "username": "mhoq",
                        "content": "New to this. A bit of explnation on Linear time and O(1) would be helpful. "
                    }
                ]
            },
            {
                "id": 1961153,
                "content": [
                    {
                        "username": "surapallisaikiran2",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        l=[]\\n        for i in nums:\\n            if i not in l:\\n                l.append(i)\\n        for i in l:\\n            if nums.count(i)>(len(nums)/2):\\n                return i"
                    },
                    {
                        "username": "tshuryanshu",
                        "content": "Why for the test case [1,2,0,0] the result is \"There is no majority element\". Could anyone please explain it. \\n\\n```\\ncount = 0\\n        majorityElement = 0\\n        for x in range(len(nums)):\\n            if count == 0:\\n                majorityElement = nums[x]\\n                if majorityElement == nums[x]:\\n                    count +=1\\n            else:\\n                count = count - 1\\n        return majorityElement\\n```"
                    },
                    {
                        "username": "TheOnix",
                        "content": "Classic stupid problem that only checks that you know the solution and not your problem solving skills"
                    },
                    {
                        "username": "daveanue",
                        "content": "My Solution doesn't work due to being O(N^2) time out, but I think this was a good attempt before going for an linear solution. I like how clever the optimal solution was to treating every number that's your target as protons and number's that not your target as electron, and the final value should the neutrons. What I didn't like was how un-reliant the solution was to n / 2. \n\n\nMy time complexity: O(N^2), space: O(1)  attempt\nint majorityElement(vector<int>& nums) {\n        int majorityCount = nums.size() / 2, freqCount = 0;\n        int slow = 0, fast = 0;\n        int candidate;\n        while (freqCount <= majorityCount) {\n            if (freqCount == 0) {\n                candidate = nums[slow];\n            }\n            if (nums[fast] == candidate) {\n                freqCount++;\n            }\n            if (freqCount > majorityCount) return candidate;\n            if (fast == nums.size() - 1) {\n                while (slow < nums.size() && nums[slow] == candidate) {\n                    slow++;\n                } \n                candidate = nums[slow];\n                freqCount = 0;\n                fast = slow - 1;\n            }\n            // skipped once b.c fast = slow, and immediately incrementing fast\n            fast++;\n        }\n\n        return candidate;\n    }"
                    },
                    {
                        "username": "shreyans4020",
                        "content": "This will need Moore\\'s Algorithm to solve"
                    },
                    {
                        "username": "oussama_gadria",
                        "content": "Did someone know why i get undefined ?  \\nmy Solution : \\nnums.sort((a,b)=>a-b)\\nreturn nums[nums.length/2] \\n"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "why an arrow operator in this solution?\nin c++ thats invalid tell why language u use."
                    },
                    {
                        "username": "mng48301",
                        "content": "I came up with a logical approach of using for loops to count the most common element. However, when I reach testcase 41/45, where the input becomes a huge array with hundreds of values, my algorithm becomes inefficient and reaches a time limit \\n\\n`class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        n = len(nums) / 2\\n        count = 0\\n        must_break = False\\n        if len(nums) > 1:\\n            for e in range(0, len(nums) - 1):\\n                for l in range(e, len(nums)):\\n                    if nums[e] == nums[l]:\\n                        count += 1\\n                    if l == len(nums) - 1:\\n                        if count >= n:\\n                            return nums[e]\\n                            must_break = True\\n                            break\\n                        else: \\n                            count = 0\\n                if must_break:\\n                    break\\n\\n        else:\\n            return nums[0]  `."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n        for(int i=0;i<nums.length-1;i++){//first sort the elemnts\\n            for(int j=i+1;j>0;j--){\\n                if(nums[j]<nums[j-1]){\\n                    int temp=nums[j];\\n                    nums[j]=nums[j-1];\\n                    nums[j-1]=temp;\\n                }\\n            }\\n        }\\n       int mostoccured=nums[0];\\n        int start=1;\\n        int end=nums.length-1;\\n        while(start<=end){\\n            int count=0;\\n            int currentelemnt=nums[start];\\n            while(currentelemnt==mostoccured){\\n                count++;\\n                start++;\\n                if(count>=nums.length/2){\\n                    return currentelemnt;\\n                }else{\\n                mostoccured=nums[start];\\n            }\\n            }\\n\\n\\n        }\\n\\n      return -1;\\n    }\\n}this ran on my system but it doesnt run on leet code time limit exceeded\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "wiill the arrray will always contain 2 elements?\\n"
                    },
                    {
                        "username": "mhoq",
                        "content": "New to this. A bit of explnation on Linear time and O(1) would be helpful. "
                    }
                ]
            },
            {
                "id": 1951694,
                "content": [
                    {
                        "username": "surapallisaikiran2",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        l=[]\\n        for i in nums:\\n            if i not in l:\\n                l.append(i)\\n        for i in l:\\n            if nums.count(i)>(len(nums)/2):\\n                return i"
                    },
                    {
                        "username": "tshuryanshu",
                        "content": "Why for the test case [1,2,0,0] the result is \"There is no majority element\". Could anyone please explain it. \\n\\n```\\ncount = 0\\n        majorityElement = 0\\n        for x in range(len(nums)):\\n            if count == 0:\\n                majorityElement = nums[x]\\n                if majorityElement == nums[x]:\\n                    count +=1\\n            else:\\n                count = count - 1\\n        return majorityElement\\n```"
                    },
                    {
                        "username": "TheOnix",
                        "content": "Classic stupid problem that only checks that you know the solution and not your problem solving skills"
                    },
                    {
                        "username": "daveanue",
                        "content": "My Solution doesn't work due to being O(N^2) time out, but I think this was a good attempt before going for an linear solution. I like how clever the optimal solution was to treating every number that's your target as protons and number's that not your target as electron, and the final value should the neutrons. What I didn't like was how un-reliant the solution was to n / 2. \n\n\nMy time complexity: O(N^2), space: O(1)  attempt\nint majorityElement(vector<int>& nums) {\n        int majorityCount = nums.size() / 2, freqCount = 0;\n        int slow = 0, fast = 0;\n        int candidate;\n        while (freqCount <= majorityCount) {\n            if (freqCount == 0) {\n                candidate = nums[slow];\n            }\n            if (nums[fast] == candidate) {\n                freqCount++;\n            }\n            if (freqCount > majorityCount) return candidate;\n            if (fast == nums.size() - 1) {\n                while (slow < nums.size() && nums[slow] == candidate) {\n                    slow++;\n                } \n                candidate = nums[slow];\n                freqCount = 0;\n                fast = slow - 1;\n            }\n            // skipped once b.c fast = slow, and immediately incrementing fast\n            fast++;\n        }\n\n        return candidate;\n    }"
                    },
                    {
                        "username": "shreyans4020",
                        "content": "This will need Moore\\'s Algorithm to solve"
                    },
                    {
                        "username": "oussama_gadria",
                        "content": "Did someone know why i get undefined ?  \\nmy Solution : \\nnums.sort((a,b)=>a-b)\\nreturn nums[nums.length/2] \\n"
                    },
                    {
                        "username": "lovishbansal441",
                        "content": "why an arrow operator in this solution?\nin c++ thats invalid tell why language u use."
                    },
                    {
                        "username": "mng48301",
                        "content": "I came up with a logical approach of using for loops to count the most common element. However, when I reach testcase 41/45, where the input becomes a huge array with hundreds of values, my algorithm becomes inefficient and reaches a time limit \\n\\n`class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        n = len(nums) / 2\\n        count = 0\\n        must_break = False\\n        if len(nums) > 1:\\n            for e in range(0, len(nums) - 1):\\n                for l in range(e, len(nums)):\\n                    if nums[e] == nums[l]:\\n                        count += 1\\n                    if l == len(nums) - 1:\\n                        if count >= n:\\n                            return nums[e]\\n                            must_break = True\\n                            break\\n                        else: \\n                            count = 0\\n                if must_break:\\n                    break\\n\\n        else:\\n            return nums[0]  `."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n        for(int i=0;i<nums.length-1;i++){//first sort the elemnts\\n            for(int j=i+1;j>0;j--){\\n                if(nums[j]<nums[j-1]){\\n                    int temp=nums[j];\\n                    nums[j]=nums[j-1];\\n                    nums[j-1]=temp;\\n                }\\n            }\\n        }\\n       int mostoccured=nums[0];\\n        int start=1;\\n        int end=nums.length-1;\\n        while(start<=end){\\n            int count=0;\\n            int currentelemnt=nums[start];\\n            while(currentelemnt==mostoccured){\\n                count++;\\n                start++;\\n                if(count>=nums.length/2){\\n                    return currentelemnt;\\n                }else{\\n                mostoccured=nums[start];\\n            }\\n            }\\n\\n\\n        }\\n\\n      return -1;\\n    }\\n}this ran on my system but it doesnt run on leet code time limit exceeded\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "wiill the arrray will always contain 2 elements?\\n"
                    },
                    {
                        "username": "mhoq",
                        "content": "New to this. A bit of explnation on Linear time and O(1) would be helpful. "
                    }
                ]
            },
            {
                "id": 1947648,
                "content": [
                    {
                        "username": "sharaddubeymbaadm",
                        "content": "Anyone who did it in constant time?"
                    },
                    {
                        "username": "artemisFowl",
                        "content": "So I passed the testcases, but when I tried to submit, it would load, and then say \"time limit exceeded\" with only 41/45 testcases passed. What should I do to fix that?"
                    },
                    {
                        "username": "Dansah",
                        "content": "Does anyone know how to install the statistics package?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "In python we directly install statistics package while using pip install statistics"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "   def majorityElement(self, nums: List[int]) -> int:\\n        candidate = -1\\n        count = 0\\n        \\n        # Find potential majority element\\n        for num in nums:\\n            if count == 0:\\n                candidate = num\\n            if num == candidate:\\n                count += 1\\n            else:\\n                count -= 1\\n        \\n        # Check if the candidate is the majority element\\n        count = 0\\n        for num in nums:\\n            if num == candidate:\\n                count += 1\\n        if count > len(nums) // 2:\\n            return candidate\\n        else:\\n            return -1\\n\\nThis is the best solution with the O(n) time and O(1) space complexity"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I found this method. But  Leetcode says \"Time Limit Exceeded\". I dont know why ?\\n\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar majorityElement = function (nums) {\\n  const maxElement = nums.reduce((a, b) => {\\n    if (\\n      nums.filter((num) => num === a).length >\\n      nums.filter((num) => num === b).length\\n    ) {\\n      return a;\\n    } else {\\n      return b;\\n    }\\n  });\\n\\n  const newArray = nums.filter((num) => num === maxElement);\\n  for (let i = 0; i < newArray.length; i++) {\\n    return newArray[i];\\n  }\\n};\\n\\nconst nums = [3, 2, 3];\\n\\nconst result = majorityElement(nums);\\nconsole.log(result);\\n"
                    },
                    {
                        "username": "Akarsh_S",
                        "content": "int majorityElement(vector<int>& nums) {\\n        float n =  ( float(nums.size())/2);\\n        int count=0;\\n        int num;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            for(int j=0 ; j<nums.size() ; j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count>n){\\n                num = nums[i];\\n                break;\\n            }\\n            count=0;\\n        }\\n      return num;\\n\\n\\n\\nI have written this code  , 41/45 test cases are passed but I am unable to pass 41th test case. Please someone help."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Solution with TIME LIMIT EXCEED but could be helpful for building logic, quick sort algo is used.\\n\\nint find_index(int nums[],int low,int high)\\n{\\n    int pivot=nums[low];\\n    int i=low;\\n    int j=high;\\n    int temp;\\n    while(i<j)\\n    {\\n        while(nums[i]<=pivot&&i<high)\\n        {\\n            i++;\\n        }\\n        while(nums[i]>pivot&&j>low)\\n        {\\n            j--;\\n        }\\n        if(i<j)\\n        {\\n           temp=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=temp;\\n        }\\n    }\\n    temp=nums[j];\\n    nums[j]=nums[low];\\n    nums[low]=temp;\\n    return j;\\n}\\n\\nvoid q_sort(int nums[],int low,int high)\\n{\\n    while(low<high)\\n    {\\n        int p_index=find_index(nums,low,high);\\n        q_sort(nums,low,p_index-1);\\n        q_sort(nums,p_index+1,high);\\n    }\\n}\\n\\nint majorityElement(int* nums, int numsSize){\\n    int low=0;\\n    int high=numsSize-1;\\nq_sort(nums,low,high);\\nreturn nums[numsSize/2];\\n}"
                    },
                    {
                        "username": "vikashpandey45",
                        "content": "i am unable to understand the question anyone can please explain "
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "Any given array there is one value that occurring more than half of the length of the array. Find that element."
                    },
                    {
                        "username": "t75332007",
                        "content": "can we do this with cyclic sort ????"
                    },
                    {
                        "username": "egretrteg",
                        "content": "based on moores voting algo"
                    }
                ]
            },
            {
                "id": 1944786,
                "content": [
                    {
                        "username": "sharaddubeymbaadm",
                        "content": "Anyone who did it in constant time?"
                    },
                    {
                        "username": "artemisFowl",
                        "content": "So I passed the testcases, but when I tried to submit, it would load, and then say \"time limit exceeded\" with only 41/45 testcases passed. What should I do to fix that?"
                    },
                    {
                        "username": "Dansah",
                        "content": "Does anyone know how to install the statistics package?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "In python we directly install statistics package while using pip install statistics"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "   def majorityElement(self, nums: List[int]) -> int:\\n        candidate = -1\\n        count = 0\\n        \\n        # Find potential majority element\\n        for num in nums:\\n            if count == 0:\\n                candidate = num\\n            if num == candidate:\\n                count += 1\\n            else:\\n                count -= 1\\n        \\n        # Check if the candidate is the majority element\\n        count = 0\\n        for num in nums:\\n            if num == candidate:\\n                count += 1\\n        if count > len(nums) // 2:\\n            return candidate\\n        else:\\n            return -1\\n\\nThis is the best solution with the O(n) time and O(1) space complexity"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I found this method. But  Leetcode says \"Time Limit Exceeded\". I dont know why ?\\n\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar majorityElement = function (nums) {\\n  const maxElement = nums.reduce((a, b) => {\\n    if (\\n      nums.filter((num) => num === a).length >\\n      nums.filter((num) => num === b).length\\n    ) {\\n      return a;\\n    } else {\\n      return b;\\n    }\\n  });\\n\\n  const newArray = nums.filter((num) => num === maxElement);\\n  for (let i = 0; i < newArray.length; i++) {\\n    return newArray[i];\\n  }\\n};\\n\\nconst nums = [3, 2, 3];\\n\\nconst result = majorityElement(nums);\\nconsole.log(result);\\n"
                    },
                    {
                        "username": "Akarsh_S",
                        "content": "int majorityElement(vector<int>& nums) {\\n        float n =  ( float(nums.size())/2);\\n        int count=0;\\n        int num;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            for(int j=0 ; j<nums.size() ; j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count>n){\\n                num = nums[i];\\n                break;\\n            }\\n            count=0;\\n        }\\n      return num;\\n\\n\\n\\nI have written this code  , 41/45 test cases are passed but I am unable to pass 41th test case. Please someone help."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Solution with TIME LIMIT EXCEED but could be helpful for building logic, quick sort algo is used.\\n\\nint find_index(int nums[],int low,int high)\\n{\\n    int pivot=nums[low];\\n    int i=low;\\n    int j=high;\\n    int temp;\\n    while(i<j)\\n    {\\n        while(nums[i]<=pivot&&i<high)\\n        {\\n            i++;\\n        }\\n        while(nums[i]>pivot&&j>low)\\n        {\\n            j--;\\n        }\\n        if(i<j)\\n        {\\n           temp=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=temp;\\n        }\\n    }\\n    temp=nums[j];\\n    nums[j]=nums[low];\\n    nums[low]=temp;\\n    return j;\\n}\\n\\nvoid q_sort(int nums[],int low,int high)\\n{\\n    while(low<high)\\n    {\\n        int p_index=find_index(nums,low,high);\\n        q_sort(nums,low,p_index-1);\\n        q_sort(nums,p_index+1,high);\\n    }\\n}\\n\\nint majorityElement(int* nums, int numsSize){\\n    int low=0;\\n    int high=numsSize-1;\\nq_sort(nums,low,high);\\nreturn nums[numsSize/2];\\n}"
                    },
                    {
                        "username": "vikashpandey45",
                        "content": "i am unable to understand the question anyone can please explain "
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "Any given array there is one value that occurring more than half of the length of the array. Find that element."
                    },
                    {
                        "username": "t75332007",
                        "content": "can we do this with cyclic sort ????"
                    },
                    {
                        "username": "egretrteg",
                        "content": "based on moores voting algo"
                    }
                ]
            },
            {
                "id": 1941512,
                "content": [
                    {
                        "username": "sharaddubeymbaadm",
                        "content": "Anyone who did it in constant time?"
                    },
                    {
                        "username": "artemisFowl",
                        "content": "So I passed the testcases, but when I tried to submit, it would load, and then say \"time limit exceeded\" with only 41/45 testcases passed. What should I do to fix that?"
                    },
                    {
                        "username": "Dansah",
                        "content": "Does anyone know how to install the statistics package?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "In python we directly install statistics package while using pip install statistics"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "   def majorityElement(self, nums: List[int]) -> int:\\n        candidate = -1\\n        count = 0\\n        \\n        # Find potential majority element\\n        for num in nums:\\n            if count == 0:\\n                candidate = num\\n            if num == candidate:\\n                count += 1\\n            else:\\n                count -= 1\\n        \\n        # Check if the candidate is the majority element\\n        count = 0\\n        for num in nums:\\n            if num == candidate:\\n                count += 1\\n        if count > len(nums) // 2:\\n            return candidate\\n        else:\\n            return -1\\n\\nThis is the best solution with the O(n) time and O(1) space complexity"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I found this method. But  Leetcode says \"Time Limit Exceeded\". I dont know why ?\\n\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar majorityElement = function (nums) {\\n  const maxElement = nums.reduce((a, b) => {\\n    if (\\n      nums.filter((num) => num === a).length >\\n      nums.filter((num) => num === b).length\\n    ) {\\n      return a;\\n    } else {\\n      return b;\\n    }\\n  });\\n\\n  const newArray = nums.filter((num) => num === maxElement);\\n  for (let i = 0; i < newArray.length; i++) {\\n    return newArray[i];\\n  }\\n};\\n\\nconst nums = [3, 2, 3];\\n\\nconst result = majorityElement(nums);\\nconsole.log(result);\\n"
                    },
                    {
                        "username": "Akarsh_S",
                        "content": "int majorityElement(vector<int>& nums) {\\n        float n =  ( float(nums.size())/2);\\n        int count=0;\\n        int num;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            for(int j=0 ; j<nums.size() ; j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count>n){\\n                num = nums[i];\\n                break;\\n            }\\n            count=0;\\n        }\\n      return num;\\n\\n\\n\\nI have written this code  , 41/45 test cases are passed but I am unable to pass 41th test case. Please someone help."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Solution with TIME LIMIT EXCEED but could be helpful for building logic, quick sort algo is used.\\n\\nint find_index(int nums[],int low,int high)\\n{\\n    int pivot=nums[low];\\n    int i=low;\\n    int j=high;\\n    int temp;\\n    while(i<j)\\n    {\\n        while(nums[i]<=pivot&&i<high)\\n        {\\n            i++;\\n        }\\n        while(nums[i]>pivot&&j>low)\\n        {\\n            j--;\\n        }\\n        if(i<j)\\n        {\\n           temp=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=temp;\\n        }\\n    }\\n    temp=nums[j];\\n    nums[j]=nums[low];\\n    nums[low]=temp;\\n    return j;\\n}\\n\\nvoid q_sort(int nums[],int low,int high)\\n{\\n    while(low<high)\\n    {\\n        int p_index=find_index(nums,low,high);\\n        q_sort(nums,low,p_index-1);\\n        q_sort(nums,p_index+1,high);\\n    }\\n}\\n\\nint majorityElement(int* nums, int numsSize){\\n    int low=0;\\n    int high=numsSize-1;\\nq_sort(nums,low,high);\\nreturn nums[numsSize/2];\\n}"
                    },
                    {
                        "username": "vikashpandey45",
                        "content": "i am unable to understand the question anyone can please explain "
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "Any given array there is one value that occurring more than half of the length of the array. Find that element."
                    },
                    {
                        "username": "t75332007",
                        "content": "can we do this with cyclic sort ????"
                    },
                    {
                        "username": "egretrteg",
                        "content": "based on moores voting algo"
                    }
                ]
            },
            {
                "id": 1935627,
                "content": [
                    {
                        "username": "sharaddubeymbaadm",
                        "content": "Anyone who did it in constant time?"
                    },
                    {
                        "username": "artemisFowl",
                        "content": "So I passed the testcases, but when I tried to submit, it would load, and then say \"time limit exceeded\" with only 41/45 testcases passed. What should I do to fix that?"
                    },
                    {
                        "username": "Dansah",
                        "content": "Does anyone know how to install the statistics package?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "In python we directly install statistics package while using pip install statistics"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "   def majorityElement(self, nums: List[int]) -> int:\\n        candidate = -1\\n        count = 0\\n        \\n        # Find potential majority element\\n        for num in nums:\\n            if count == 0:\\n                candidate = num\\n            if num == candidate:\\n                count += 1\\n            else:\\n                count -= 1\\n        \\n        # Check if the candidate is the majority element\\n        count = 0\\n        for num in nums:\\n            if num == candidate:\\n                count += 1\\n        if count > len(nums) // 2:\\n            return candidate\\n        else:\\n            return -1\\n\\nThis is the best solution with the O(n) time and O(1) space complexity"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I found this method. But  Leetcode says \"Time Limit Exceeded\". I dont know why ?\\n\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar majorityElement = function (nums) {\\n  const maxElement = nums.reduce((a, b) => {\\n    if (\\n      nums.filter((num) => num === a).length >\\n      nums.filter((num) => num === b).length\\n    ) {\\n      return a;\\n    } else {\\n      return b;\\n    }\\n  });\\n\\n  const newArray = nums.filter((num) => num === maxElement);\\n  for (let i = 0; i < newArray.length; i++) {\\n    return newArray[i];\\n  }\\n};\\n\\nconst nums = [3, 2, 3];\\n\\nconst result = majorityElement(nums);\\nconsole.log(result);\\n"
                    },
                    {
                        "username": "Akarsh_S",
                        "content": "int majorityElement(vector<int>& nums) {\\n        float n =  ( float(nums.size())/2);\\n        int count=0;\\n        int num;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            for(int j=0 ; j<nums.size() ; j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count>n){\\n                num = nums[i];\\n                break;\\n            }\\n            count=0;\\n        }\\n      return num;\\n\\n\\n\\nI have written this code  , 41/45 test cases are passed but I am unable to pass 41th test case. Please someone help."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Solution with TIME LIMIT EXCEED but could be helpful for building logic, quick sort algo is used.\\n\\nint find_index(int nums[],int low,int high)\\n{\\n    int pivot=nums[low];\\n    int i=low;\\n    int j=high;\\n    int temp;\\n    while(i<j)\\n    {\\n        while(nums[i]<=pivot&&i<high)\\n        {\\n            i++;\\n        }\\n        while(nums[i]>pivot&&j>low)\\n        {\\n            j--;\\n        }\\n        if(i<j)\\n        {\\n           temp=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=temp;\\n        }\\n    }\\n    temp=nums[j];\\n    nums[j]=nums[low];\\n    nums[low]=temp;\\n    return j;\\n}\\n\\nvoid q_sort(int nums[],int low,int high)\\n{\\n    while(low<high)\\n    {\\n        int p_index=find_index(nums,low,high);\\n        q_sort(nums,low,p_index-1);\\n        q_sort(nums,p_index+1,high);\\n    }\\n}\\n\\nint majorityElement(int* nums, int numsSize){\\n    int low=0;\\n    int high=numsSize-1;\\nq_sort(nums,low,high);\\nreturn nums[numsSize/2];\\n}"
                    },
                    {
                        "username": "vikashpandey45",
                        "content": "i am unable to understand the question anyone can please explain "
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "Any given array there is one value that occurring more than half of the length of the array. Find that element."
                    },
                    {
                        "username": "t75332007",
                        "content": "can we do this with cyclic sort ????"
                    },
                    {
                        "username": "egretrteg",
                        "content": "based on moores voting algo"
                    }
                ]
            },
            {
                "id": 1934920,
                "content": [
                    {
                        "username": "sharaddubeymbaadm",
                        "content": "Anyone who did it in constant time?"
                    },
                    {
                        "username": "artemisFowl",
                        "content": "So I passed the testcases, but when I tried to submit, it would load, and then say \"time limit exceeded\" with only 41/45 testcases passed. What should I do to fix that?"
                    },
                    {
                        "username": "Dansah",
                        "content": "Does anyone know how to install the statistics package?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "In python we directly install statistics package while using pip install statistics"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "   def majorityElement(self, nums: List[int]) -> int:\\n        candidate = -1\\n        count = 0\\n        \\n        # Find potential majority element\\n        for num in nums:\\n            if count == 0:\\n                candidate = num\\n            if num == candidate:\\n                count += 1\\n            else:\\n                count -= 1\\n        \\n        # Check if the candidate is the majority element\\n        count = 0\\n        for num in nums:\\n            if num == candidate:\\n                count += 1\\n        if count > len(nums) // 2:\\n            return candidate\\n        else:\\n            return -1\\n\\nThis is the best solution with the O(n) time and O(1) space complexity"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I found this method. But  Leetcode says \"Time Limit Exceeded\". I dont know why ?\\n\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar majorityElement = function (nums) {\\n  const maxElement = nums.reduce((a, b) => {\\n    if (\\n      nums.filter((num) => num === a).length >\\n      nums.filter((num) => num === b).length\\n    ) {\\n      return a;\\n    } else {\\n      return b;\\n    }\\n  });\\n\\n  const newArray = nums.filter((num) => num === maxElement);\\n  for (let i = 0; i < newArray.length; i++) {\\n    return newArray[i];\\n  }\\n};\\n\\nconst nums = [3, 2, 3];\\n\\nconst result = majorityElement(nums);\\nconsole.log(result);\\n"
                    },
                    {
                        "username": "Akarsh_S",
                        "content": "int majorityElement(vector<int>& nums) {\\n        float n =  ( float(nums.size())/2);\\n        int count=0;\\n        int num;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            for(int j=0 ; j<nums.size() ; j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count>n){\\n                num = nums[i];\\n                break;\\n            }\\n            count=0;\\n        }\\n      return num;\\n\\n\\n\\nI have written this code  , 41/45 test cases are passed but I am unable to pass 41th test case. Please someone help."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Solution with TIME LIMIT EXCEED but could be helpful for building logic, quick sort algo is used.\\n\\nint find_index(int nums[],int low,int high)\\n{\\n    int pivot=nums[low];\\n    int i=low;\\n    int j=high;\\n    int temp;\\n    while(i<j)\\n    {\\n        while(nums[i]<=pivot&&i<high)\\n        {\\n            i++;\\n        }\\n        while(nums[i]>pivot&&j>low)\\n        {\\n            j--;\\n        }\\n        if(i<j)\\n        {\\n           temp=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=temp;\\n        }\\n    }\\n    temp=nums[j];\\n    nums[j]=nums[low];\\n    nums[low]=temp;\\n    return j;\\n}\\n\\nvoid q_sort(int nums[],int low,int high)\\n{\\n    while(low<high)\\n    {\\n        int p_index=find_index(nums,low,high);\\n        q_sort(nums,low,p_index-1);\\n        q_sort(nums,p_index+1,high);\\n    }\\n}\\n\\nint majorityElement(int* nums, int numsSize){\\n    int low=0;\\n    int high=numsSize-1;\\nq_sort(nums,low,high);\\nreturn nums[numsSize/2];\\n}"
                    },
                    {
                        "username": "vikashpandey45",
                        "content": "i am unable to understand the question anyone can please explain "
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "Any given array there is one value that occurring more than half of the length of the array. Find that element."
                    },
                    {
                        "username": "t75332007",
                        "content": "can we do this with cyclic sort ????"
                    },
                    {
                        "username": "egretrteg",
                        "content": "based on moores voting algo"
                    }
                ]
            },
            {
                "id": 1918910,
                "content": [
                    {
                        "username": "sharaddubeymbaadm",
                        "content": "Anyone who did it in constant time?"
                    },
                    {
                        "username": "artemisFowl",
                        "content": "So I passed the testcases, but when I tried to submit, it would load, and then say \"time limit exceeded\" with only 41/45 testcases passed. What should I do to fix that?"
                    },
                    {
                        "username": "Dansah",
                        "content": "Does anyone know how to install the statistics package?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "In python we directly install statistics package while using pip install statistics"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "   def majorityElement(self, nums: List[int]) -> int:\\n        candidate = -1\\n        count = 0\\n        \\n        # Find potential majority element\\n        for num in nums:\\n            if count == 0:\\n                candidate = num\\n            if num == candidate:\\n                count += 1\\n            else:\\n                count -= 1\\n        \\n        # Check if the candidate is the majority element\\n        count = 0\\n        for num in nums:\\n            if num == candidate:\\n                count += 1\\n        if count > len(nums) // 2:\\n            return candidate\\n        else:\\n            return -1\\n\\nThis is the best solution with the O(n) time and O(1) space complexity"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I found this method. But  Leetcode says \"Time Limit Exceeded\". I dont know why ?\\n\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar majorityElement = function (nums) {\\n  const maxElement = nums.reduce((a, b) => {\\n    if (\\n      nums.filter((num) => num === a).length >\\n      nums.filter((num) => num === b).length\\n    ) {\\n      return a;\\n    } else {\\n      return b;\\n    }\\n  });\\n\\n  const newArray = nums.filter((num) => num === maxElement);\\n  for (let i = 0; i < newArray.length; i++) {\\n    return newArray[i];\\n  }\\n};\\n\\nconst nums = [3, 2, 3];\\n\\nconst result = majorityElement(nums);\\nconsole.log(result);\\n"
                    },
                    {
                        "username": "Akarsh_S",
                        "content": "int majorityElement(vector<int>& nums) {\\n        float n =  ( float(nums.size())/2);\\n        int count=0;\\n        int num;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            for(int j=0 ; j<nums.size() ; j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count>n){\\n                num = nums[i];\\n                break;\\n            }\\n            count=0;\\n        }\\n      return num;\\n\\n\\n\\nI have written this code  , 41/45 test cases are passed but I am unable to pass 41th test case. Please someone help."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Solution with TIME LIMIT EXCEED but could be helpful for building logic, quick sort algo is used.\\n\\nint find_index(int nums[],int low,int high)\\n{\\n    int pivot=nums[low];\\n    int i=low;\\n    int j=high;\\n    int temp;\\n    while(i<j)\\n    {\\n        while(nums[i]<=pivot&&i<high)\\n        {\\n            i++;\\n        }\\n        while(nums[i]>pivot&&j>low)\\n        {\\n            j--;\\n        }\\n        if(i<j)\\n        {\\n           temp=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=temp;\\n        }\\n    }\\n    temp=nums[j];\\n    nums[j]=nums[low];\\n    nums[low]=temp;\\n    return j;\\n}\\n\\nvoid q_sort(int nums[],int low,int high)\\n{\\n    while(low<high)\\n    {\\n        int p_index=find_index(nums,low,high);\\n        q_sort(nums,low,p_index-1);\\n        q_sort(nums,p_index+1,high);\\n    }\\n}\\n\\nint majorityElement(int* nums, int numsSize){\\n    int low=0;\\n    int high=numsSize-1;\\nq_sort(nums,low,high);\\nreturn nums[numsSize/2];\\n}"
                    },
                    {
                        "username": "vikashpandey45",
                        "content": "i am unable to understand the question anyone can please explain "
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "Any given array there is one value that occurring more than half of the length of the array. Find that element."
                    },
                    {
                        "username": "t75332007",
                        "content": "can we do this with cyclic sort ????"
                    },
                    {
                        "username": "egretrteg",
                        "content": "based on moores voting algo"
                    }
                ]
            },
            {
                "id": 1911663,
                "content": [
                    {
                        "username": "sharaddubeymbaadm",
                        "content": "Anyone who did it in constant time?"
                    },
                    {
                        "username": "artemisFowl",
                        "content": "So I passed the testcases, but when I tried to submit, it would load, and then say \"time limit exceeded\" with only 41/45 testcases passed. What should I do to fix that?"
                    },
                    {
                        "username": "Dansah",
                        "content": "Does anyone know how to install the statistics package?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "In python we directly install statistics package while using pip install statistics"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "   def majorityElement(self, nums: List[int]) -> int:\\n        candidate = -1\\n        count = 0\\n        \\n        # Find potential majority element\\n        for num in nums:\\n            if count == 0:\\n                candidate = num\\n            if num == candidate:\\n                count += 1\\n            else:\\n                count -= 1\\n        \\n        # Check if the candidate is the majority element\\n        count = 0\\n        for num in nums:\\n            if num == candidate:\\n                count += 1\\n        if count > len(nums) // 2:\\n            return candidate\\n        else:\\n            return -1\\n\\nThis is the best solution with the O(n) time and O(1) space complexity"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I found this method. But  Leetcode says \"Time Limit Exceeded\". I dont know why ?\\n\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar majorityElement = function (nums) {\\n  const maxElement = nums.reduce((a, b) => {\\n    if (\\n      nums.filter((num) => num === a).length >\\n      nums.filter((num) => num === b).length\\n    ) {\\n      return a;\\n    } else {\\n      return b;\\n    }\\n  });\\n\\n  const newArray = nums.filter((num) => num === maxElement);\\n  for (let i = 0; i < newArray.length; i++) {\\n    return newArray[i];\\n  }\\n};\\n\\nconst nums = [3, 2, 3];\\n\\nconst result = majorityElement(nums);\\nconsole.log(result);\\n"
                    },
                    {
                        "username": "Akarsh_S",
                        "content": "int majorityElement(vector<int>& nums) {\\n        float n =  ( float(nums.size())/2);\\n        int count=0;\\n        int num;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            for(int j=0 ; j<nums.size() ; j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count>n){\\n                num = nums[i];\\n                break;\\n            }\\n            count=0;\\n        }\\n      return num;\\n\\n\\n\\nI have written this code  , 41/45 test cases are passed but I am unable to pass 41th test case. Please someone help."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Solution with TIME LIMIT EXCEED but could be helpful for building logic, quick sort algo is used.\\n\\nint find_index(int nums[],int low,int high)\\n{\\n    int pivot=nums[low];\\n    int i=low;\\n    int j=high;\\n    int temp;\\n    while(i<j)\\n    {\\n        while(nums[i]<=pivot&&i<high)\\n        {\\n            i++;\\n        }\\n        while(nums[i]>pivot&&j>low)\\n        {\\n            j--;\\n        }\\n        if(i<j)\\n        {\\n           temp=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=temp;\\n        }\\n    }\\n    temp=nums[j];\\n    nums[j]=nums[low];\\n    nums[low]=temp;\\n    return j;\\n}\\n\\nvoid q_sort(int nums[],int low,int high)\\n{\\n    while(low<high)\\n    {\\n        int p_index=find_index(nums,low,high);\\n        q_sort(nums,low,p_index-1);\\n        q_sort(nums,p_index+1,high);\\n    }\\n}\\n\\nint majorityElement(int* nums, int numsSize){\\n    int low=0;\\n    int high=numsSize-1;\\nq_sort(nums,low,high);\\nreturn nums[numsSize/2];\\n}"
                    },
                    {
                        "username": "vikashpandey45",
                        "content": "i am unable to understand the question anyone can please explain "
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "Any given array there is one value that occurring more than half of the length of the array. Find that element."
                    },
                    {
                        "username": "t75332007",
                        "content": "can we do this with cyclic sort ????"
                    },
                    {
                        "username": "egretrteg",
                        "content": "based on moores voting algo"
                    }
                ]
            },
            {
                "id": 1906786,
                "content": [
                    {
                        "username": "sharaddubeymbaadm",
                        "content": "Anyone who did it in constant time?"
                    },
                    {
                        "username": "artemisFowl",
                        "content": "So I passed the testcases, but when I tried to submit, it would load, and then say \"time limit exceeded\" with only 41/45 testcases passed. What should I do to fix that?"
                    },
                    {
                        "username": "Dansah",
                        "content": "Does anyone know how to install the statistics package?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "In python we directly install statistics package while using pip install statistics"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "   def majorityElement(self, nums: List[int]) -> int:\\n        candidate = -1\\n        count = 0\\n        \\n        # Find potential majority element\\n        for num in nums:\\n            if count == 0:\\n                candidate = num\\n            if num == candidate:\\n                count += 1\\n            else:\\n                count -= 1\\n        \\n        # Check if the candidate is the majority element\\n        count = 0\\n        for num in nums:\\n            if num == candidate:\\n                count += 1\\n        if count > len(nums) // 2:\\n            return candidate\\n        else:\\n            return -1\\n\\nThis is the best solution with the O(n) time and O(1) space complexity"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I found this method. But  Leetcode says \"Time Limit Exceeded\". I dont know why ?\\n\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar majorityElement = function (nums) {\\n  const maxElement = nums.reduce((a, b) => {\\n    if (\\n      nums.filter((num) => num === a).length >\\n      nums.filter((num) => num === b).length\\n    ) {\\n      return a;\\n    } else {\\n      return b;\\n    }\\n  });\\n\\n  const newArray = nums.filter((num) => num === maxElement);\\n  for (let i = 0; i < newArray.length; i++) {\\n    return newArray[i];\\n  }\\n};\\n\\nconst nums = [3, 2, 3];\\n\\nconst result = majorityElement(nums);\\nconsole.log(result);\\n"
                    },
                    {
                        "username": "Akarsh_S",
                        "content": "int majorityElement(vector<int>& nums) {\\n        float n =  ( float(nums.size())/2);\\n        int count=0;\\n        int num;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            for(int j=0 ; j<nums.size() ; j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count>n){\\n                num = nums[i];\\n                break;\\n            }\\n            count=0;\\n        }\\n      return num;\\n\\n\\n\\nI have written this code  , 41/45 test cases are passed but I am unable to pass 41th test case. Please someone help."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Solution with TIME LIMIT EXCEED but could be helpful for building logic, quick sort algo is used.\\n\\nint find_index(int nums[],int low,int high)\\n{\\n    int pivot=nums[low];\\n    int i=low;\\n    int j=high;\\n    int temp;\\n    while(i<j)\\n    {\\n        while(nums[i]<=pivot&&i<high)\\n        {\\n            i++;\\n        }\\n        while(nums[i]>pivot&&j>low)\\n        {\\n            j--;\\n        }\\n        if(i<j)\\n        {\\n           temp=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=temp;\\n        }\\n    }\\n    temp=nums[j];\\n    nums[j]=nums[low];\\n    nums[low]=temp;\\n    return j;\\n}\\n\\nvoid q_sort(int nums[],int low,int high)\\n{\\n    while(low<high)\\n    {\\n        int p_index=find_index(nums,low,high);\\n        q_sort(nums,low,p_index-1);\\n        q_sort(nums,p_index+1,high);\\n    }\\n}\\n\\nint majorityElement(int* nums, int numsSize){\\n    int low=0;\\n    int high=numsSize-1;\\nq_sort(nums,low,high);\\nreturn nums[numsSize/2];\\n}"
                    },
                    {
                        "username": "vikashpandey45",
                        "content": "i am unable to understand the question anyone can please explain "
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "Any given array there is one value that occurring more than half of the length of the array. Find that element."
                    },
                    {
                        "username": "t75332007",
                        "content": "can we do this with cyclic sort ????"
                    },
                    {
                        "username": "egretrteg",
                        "content": "based on moores voting algo"
                    }
                ]
            },
            {
                "id": 1906125,
                "content": [
                    {
                        "username": "sharaddubeymbaadm",
                        "content": "Anyone who did it in constant time?"
                    },
                    {
                        "username": "artemisFowl",
                        "content": "So I passed the testcases, but when I tried to submit, it would load, and then say \"time limit exceeded\" with only 41/45 testcases passed. What should I do to fix that?"
                    },
                    {
                        "username": "Dansah",
                        "content": "Does anyone know how to install the statistics package?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "In python we directly install statistics package while using pip install statistics"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "   def majorityElement(self, nums: List[int]) -> int:\\n        candidate = -1\\n        count = 0\\n        \\n        # Find potential majority element\\n        for num in nums:\\n            if count == 0:\\n                candidate = num\\n            if num == candidate:\\n                count += 1\\n            else:\\n                count -= 1\\n        \\n        # Check if the candidate is the majority element\\n        count = 0\\n        for num in nums:\\n            if num == candidate:\\n                count += 1\\n        if count > len(nums) // 2:\\n            return candidate\\n        else:\\n            return -1\\n\\nThis is the best solution with the O(n) time and O(1) space complexity"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I found this method. But  Leetcode says \"Time Limit Exceeded\". I dont know why ?\\n\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar majorityElement = function (nums) {\\n  const maxElement = nums.reduce((a, b) => {\\n    if (\\n      nums.filter((num) => num === a).length >\\n      nums.filter((num) => num === b).length\\n    ) {\\n      return a;\\n    } else {\\n      return b;\\n    }\\n  });\\n\\n  const newArray = nums.filter((num) => num === maxElement);\\n  for (let i = 0; i < newArray.length; i++) {\\n    return newArray[i];\\n  }\\n};\\n\\nconst nums = [3, 2, 3];\\n\\nconst result = majorityElement(nums);\\nconsole.log(result);\\n"
                    },
                    {
                        "username": "Akarsh_S",
                        "content": "int majorityElement(vector<int>& nums) {\\n        float n =  ( float(nums.size())/2);\\n        int count=0;\\n        int num;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            for(int j=0 ; j<nums.size() ; j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count>n){\\n                num = nums[i];\\n                break;\\n            }\\n            count=0;\\n        }\\n      return num;\\n\\n\\n\\nI have written this code  , 41/45 test cases are passed but I am unable to pass 41th test case. Please someone help."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Solution with TIME LIMIT EXCEED but could be helpful for building logic, quick sort algo is used.\\n\\nint find_index(int nums[],int low,int high)\\n{\\n    int pivot=nums[low];\\n    int i=low;\\n    int j=high;\\n    int temp;\\n    while(i<j)\\n    {\\n        while(nums[i]<=pivot&&i<high)\\n        {\\n            i++;\\n        }\\n        while(nums[i]>pivot&&j>low)\\n        {\\n            j--;\\n        }\\n        if(i<j)\\n        {\\n           temp=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=temp;\\n        }\\n    }\\n    temp=nums[j];\\n    nums[j]=nums[low];\\n    nums[low]=temp;\\n    return j;\\n}\\n\\nvoid q_sort(int nums[],int low,int high)\\n{\\n    while(low<high)\\n    {\\n        int p_index=find_index(nums,low,high);\\n        q_sort(nums,low,p_index-1);\\n        q_sort(nums,p_index+1,high);\\n    }\\n}\\n\\nint majorityElement(int* nums, int numsSize){\\n    int low=0;\\n    int high=numsSize-1;\\nq_sort(nums,low,high);\\nreturn nums[numsSize/2];\\n}"
                    },
                    {
                        "username": "vikashpandey45",
                        "content": "i am unable to understand the question anyone can please explain "
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "Any given array there is one value that occurring more than half of the length of the array. Find that element."
                    },
                    {
                        "username": "t75332007",
                        "content": "can we do this with cyclic sort ????"
                    },
                    {
                        "username": "egretrteg",
                        "content": "based on moores voting algo"
                    }
                ]
            },
            {
                "id": 1905854,
                "content": [
                    {
                        "username": "sharaddubeymbaadm",
                        "content": "Anyone who did it in constant time?"
                    },
                    {
                        "username": "artemisFowl",
                        "content": "So I passed the testcases, but when I tried to submit, it would load, and then say \"time limit exceeded\" with only 41/45 testcases passed. What should I do to fix that?"
                    },
                    {
                        "username": "Dansah",
                        "content": "Does anyone know how to install the statistics package?"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "In python we directly install statistics package while using pip install statistics"
                    },
                    {
                        "username": "AswiniKumar0509",
                        "content": "   def majorityElement(self, nums: List[int]) -> int:\\n        candidate = -1\\n        count = 0\\n        \\n        # Find potential majority element\\n        for num in nums:\\n            if count == 0:\\n                candidate = num\\n            if num == candidate:\\n                count += 1\\n            else:\\n                count -= 1\\n        \\n        # Check if the candidate is the majority element\\n        count = 0\\n        for num in nums:\\n            if num == candidate:\\n                count += 1\\n        if count > len(nums) // 2:\\n            return candidate\\n        else:\\n            return -1\\n\\nThis is the best solution with the O(n) time and O(1) space complexity"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I found this method. But  Leetcode says \"Time Limit Exceeded\". I dont know why ?\\n\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar majorityElement = function (nums) {\\n  const maxElement = nums.reduce((a, b) => {\\n    if (\\n      nums.filter((num) => num === a).length >\\n      nums.filter((num) => num === b).length\\n    ) {\\n      return a;\\n    } else {\\n      return b;\\n    }\\n  });\\n\\n  const newArray = nums.filter((num) => num === maxElement);\\n  for (let i = 0; i < newArray.length; i++) {\\n    return newArray[i];\\n  }\\n};\\n\\nconst nums = [3, 2, 3];\\n\\nconst result = majorityElement(nums);\\nconsole.log(result);\\n"
                    },
                    {
                        "username": "Akarsh_S",
                        "content": "int majorityElement(vector<int>& nums) {\\n        float n =  ( float(nums.size())/2);\\n        int count=0;\\n        int num;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            for(int j=0 ; j<nums.size() ; j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count>n){\\n                num = nums[i];\\n                break;\\n            }\\n            count=0;\\n        }\\n      return num;\\n\\n\\n\\nI have written this code  , 41/45 test cases are passed but I am unable to pass 41th test case. Please someone help."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Solution with TIME LIMIT EXCEED but could be helpful for building logic, quick sort algo is used.\\n\\nint find_index(int nums[],int low,int high)\\n{\\n    int pivot=nums[low];\\n    int i=low;\\n    int j=high;\\n    int temp;\\n    while(i<j)\\n    {\\n        while(nums[i]<=pivot&&i<high)\\n        {\\n            i++;\\n        }\\n        while(nums[i]>pivot&&j>low)\\n        {\\n            j--;\\n        }\\n        if(i<j)\\n        {\\n           temp=nums[i];\\n           nums[i]=nums[j];\\n           nums[j]=temp;\\n        }\\n    }\\n    temp=nums[j];\\n    nums[j]=nums[low];\\n    nums[low]=temp;\\n    return j;\\n}\\n\\nvoid q_sort(int nums[],int low,int high)\\n{\\n    while(low<high)\\n    {\\n        int p_index=find_index(nums,low,high);\\n        q_sort(nums,low,p_index-1);\\n        q_sort(nums,p_index+1,high);\\n    }\\n}\\n\\nint majorityElement(int* nums, int numsSize){\\n    int low=0;\\n    int high=numsSize-1;\\nq_sort(nums,low,high);\\nreturn nums[numsSize/2];\\n}"
                    },
                    {
                        "username": "vikashpandey45",
                        "content": "i am unable to understand the question anyone can please explain "
                    },
                    {
                        "username": "98-percent-Milk",
                        "content": "Any given array there is one value that occurring more than half of the length of the array. Find that element."
                    },
                    {
                        "username": "t75332007",
                        "content": "can we do this with cyclic sort ????"
                    },
                    {
                        "username": "egretrteg",
                        "content": "based on moores voting algo"
                    }
                ]
            },
            {
                "id": 1879394,
                "content": [
                    {
                        "username": "Shivang_Verma1",
                        "content": "````\n Arrays.sort(nums);\n    int len = nums.length;\n    return nums[len/2];\n````\n\nwhat if nums=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1;\n"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def majorityElement(self, nums):\\n        nums.sort()\\n        return nums[len(nums) // 2]\\n```"
                    },
                    {
                        "username": "Feruz1212",
                        "content": "I think, returning `middle number of sorted array` here, `not fair and not  linear time and in O(1) space ` SOLUTION, if i am not mistaken."
                    },
                    {
                        "username": "gopal_0208",
                        "content": "If you are having doubts then go through this article, it will help you in understanding\\nhttps://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm"
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "Can any one tell me what is wrong with this approach?\\n\\n   int high = 1;\\n   for(auto i: nums){\\n       if(nums[i]>high){\\n           high = nums[i];\\n       }\\n   }\\n   int arr[high+1];\\n   for (int i=0; i<nums.size(); i++){\\n       arr[nums[i]]+=1;\\n   }\\n   for(auto i: nums){\\n       if(nums[i]>high){\\n           high = nums[i];\\n       }\\n   }\\n   cout<< high;"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n        class Solution:\n            def majorityElement(self, nums: List[int]) -> int:\n               hashMap = {}\n               max_num = 0\n               for i in range(len(nums)):\n                    if nums[i] not in hashMap:\n                         hashMap[nums[i]] = 1\n                    else:\n                         hashMap[nums[i]] = 1 + hashMap.get(nums[i],0)\n        \n               max_num = max(hashMap.values())\n        \n               for num in nums:\n                   if hashMap.get(num) == max_num:\n                       return num\n\nIs the time complexity O(n) for the above code? "
                    },
                    {
                        "username": "Khunger_Shivansh",
                        "content": " `#include <iostream>\n#include <vector>\n#include <limits.h>\nusing namespace std;\nint main()\n{\n    vector<int> arr{3, 2, 3};\n    int count = 0;\n    int ans;\n    for (int i = 0; i < arr.size(); i++)\n    {\n        int temp = arr[i];\n        if (arr[i] == INT_MIN)\n        {\n            continue;\n        }\n        int si = 0;\n        int ei = arr.size() - 1;\n        int count = 0;\n        while (si <= ei)\n        {\n            if (arr[i] == arr[si])\n            {\n                count++;\n                arr[si] = INT_MIN;\n            }\n            if (arr[i] == arr[ei])\n            {\n                count++;\n                arr[ei] = INT_MIN;\n            }\n            si++;\n            ei--;\n        }\n        if (count > arr.size() / 2)\n        {\n            cout << arr.size() / 2 << endl;\n            ans = temp;\n        }\n    }\n    cout << ans;\n}`\nFor this Code - Leetcode is giving Diff Ans and VS code is giving diff \nI think the problem is in arr.size() value.\nAnybody knows why this is happening ?"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can anybody share ideas for O(n) time & O(1) space solution?"
                    },
                    {
                        "username": "kunjalshah101",
                        "content": "Use Boyer-Moore voting algorithm"
                    },
                    {
                        "username": "ParagPriyadarshi",
                        "content": "PLEASE SOMEONE HELP ME WITH THIS \n\n\nclass Solution {\n    public int majorityElement(int[] nums) {\n     int count = 0;\n       int maj = 0;\n        for(int i = 0; i<nums.length;i++){\n               \n            for(int j = 0; j<nums.length;j++){\n                if(nums[j] == nums[i]){\n                    count++;\n                }    \n                \n          } if(count > Math.floor(nums.length/2)){\n                   \n                   return maj = nums[i];\n                    \n            }}return maj;\n    }}\n            why this code can't pass all the test cases , while changing the initialization of int count = 0;  to the for loop passes the all the test case.\nPls anyone help me with this I can't understand why changing the scope of the initialization of the variable gives the right answer.\n\nThis gives the answer.\n \nclass Solution {\n    public int majorityElement(int[] nums) {\n     \n       int maj = 0;\n        for(int i = 0; i<nums.length;i++){\n           int count = 0;    \n            for(int j = 0; j<nums.length;j++){\n                if(nums[j] == nums[i]){\n                    count++;\n                }    \n                \n          } if(count > Math.floor(nums.length/2)){\n                   \n                   return maj = nums[i];\n                    \n            }}return maj;\n    }}\n            "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        from collections import Counter\\n\\n        l = len(nums)/2\\n        nums = Counter(nums) \\n        \\n        for key, val in nums.items():\\n            if val > l:\\n                return key"
                    }
                ]
            },
            {
                "id": 1858305,
                "content": [
                    {
                        "username": "Shivang_Verma1",
                        "content": "````\n Arrays.sort(nums);\n    int len = nums.length;\n    return nums[len/2];\n````\n\nwhat if nums=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1;\n"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def majorityElement(self, nums):\\n        nums.sort()\\n        return nums[len(nums) // 2]\\n```"
                    },
                    {
                        "username": "Feruz1212",
                        "content": "I think, returning `middle number of sorted array` here, `not fair and not  linear time and in O(1) space ` SOLUTION, if i am not mistaken."
                    },
                    {
                        "username": "gopal_0208",
                        "content": "If you are having doubts then go through this article, it will help you in understanding\\nhttps://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm"
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "Can any one tell me what is wrong with this approach?\\n\\n   int high = 1;\\n   for(auto i: nums){\\n       if(nums[i]>high){\\n           high = nums[i];\\n       }\\n   }\\n   int arr[high+1];\\n   for (int i=0; i<nums.size(); i++){\\n       arr[nums[i]]+=1;\\n   }\\n   for(auto i: nums){\\n       if(nums[i]>high){\\n           high = nums[i];\\n       }\\n   }\\n   cout<< high;"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n        class Solution:\n            def majorityElement(self, nums: List[int]) -> int:\n               hashMap = {}\n               max_num = 0\n               for i in range(len(nums)):\n                    if nums[i] not in hashMap:\n                         hashMap[nums[i]] = 1\n                    else:\n                         hashMap[nums[i]] = 1 + hashMap.get(nums[i],0)\n        \n               max_num = max(hashMap.values())\n        \n               for num in nums:\n                   if hashMap.get(num) == max_num:\n                       return num\n\nIs the time complexity O(n) for the above code? "
                    },
                    {
                        "username": "Khunger_Shivansh",
                        "content": " `#include <iostream>\n#include <vector>\n#include <limits.h>\nusing namespace std;\nint main()\n{\n    vector<int> arr{3, 2, 3};\n    int count = 0;\n    int ans;\n    for (int i = 0; i < arr.size(); i++)\n    {\n        int temp = arr[i];\n        if (arr[i] == INT_MIN)\n        {\n            continue;\n        }\n        int si = 0;\n        int ei = arr.size() - 1;\n        int count = 0;\n        while (si <= ei)\n        {\n            if (arr[i] == arr[si])\n            {\n                count++;\n                arr[si] = INT_MIN;\n            }\n            if (arr[i] == arr[ei])\n            {\n                count++;\n                arr[ei] = INT_MIN;\n            }\n            si++;\n            ei--;\n        }\n        if (count > arr.size() / 2)\n        {\n            cout << arr.size() / 2 << endl;\n            ans = temp;\n        }\n    }\n    cout << ans;\n}`\nFor this Code - Leetcode is giving Diff Ans and VS code is giving diff \nI think the problem is in arr.size() value.\nAnybody knows why this is happening ?"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can anybody share ideas for O(n) time & O(1) space solution?"
                    },
                    {
                        "username": "kunjalshah101",
                        "content": "Use Boyer-Moore voting algorithm"
                    },
                    {
                        "username": "ParagPriyadarshi",
                        "content": "PLEASE SOMEONE HELP ME WITH THIS \n\n\nclass Solution {\n    public int majorityElement(int[] nums) {\n     int count = 0;\n       int maj = 0;\n        for(int i = 0; i<nums.length;i++){\n               \n            for(int j = 0; j<nums.length;j++){\n                if(nums[j] == nums[i]){\n                    count++;\n                }    \n                \n          } if(count > Math.floor(nums.length/2)){\n                   \n                   return maj = nums[i];\n                    \n            }}return maj;\n    }}\n            why this code can't pass all the test cases , while changing the initialization of int count = 0;  to the for loop passes the all the test case.\nPls anyone help me with this I can't understand why changing the scope of the initialization of the variable gives the right answer.\n\nThis gives the answer.\n \nclass Solution {\n    public int majorityElement(int[] nums) {\n     \n       int maj = 0;\n        for(int i = 0; i<nums.length;i++){\n           int count = 0;    \n            for(int j = 0; j<nums.length;j++){\n                if(nums[j] == nums[i]){\n                    count++;\n                }    \n                \n          } if(count > Math.floor(nums.length/2)){\n                   \n                   return maj = nums[i];\n                    \n            }}return maj;\n    }}\n            "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        from collections import Counter\\n\\n        l = len(nums)/2\\n        nums = Counter(nums) \\n        \\n        for key, val in nums.items():\\n            if val > l:\\n                return key"
                    }
                ]
            },
            {
                "id": 1838593,
                "content": [
                    {
                        "username": "Shivang_Verma1",
                        "content": "````\n Arrays.sort(nums);\n    int len = nums.length;\n    return nums[len/2];\n````\n\nwhat if nums=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1;\n"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def majorityElement(self, nums):\\n        nums.sort()\\n        return nums[len(nums) // 2]\\n```"
                    },
                    {
                        "username": "Feruz1212",
                        "content": "I think, returning `middle number of sorted array` here, `not fair and not  linear time and in O(1) space ` SOLUTION, if i am not mistaken."
                    },
                    {
                        "username": "gopal_0208",
                        "content": "If you are having doubts then go through this article, it will help you in understanding\\nhttps://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm"
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "Can any one tell me what is wrong with this approach?\\n\\n   int high = 1;\\n   for(auto i: nums){\\n       if(nums[i]>high){\\n           high = nums[i];\\n       }\\n   }\\n   int arr[high+1];\\n   for (int i=0; i<nums.size(); i++){\\n       arr[nums[i]]+=1;\\n   }\\n   for(auto i: nums){\\n       if(nums[i]>high){\\n           high = nums[i];\\n       }\\n   }\\n   cout<< high;"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n        class Solution:\n            def majorityElement(self, nums: List[int]) -> int:\n               hashMap = {}\n               max_num = 0\n               for i in range(len(nums)):\n                    if nums[i] not in hashMap:\n                         hashMap[nums[i]] = 1\n                    else:\n                         hashMap[nums[i]] = 1 + hashMap.get(nums[i],0)\n        \n               max_num = max(hashMap.values())\n        \n               for num in nums:\n                   if hashMap.get(num) == max_num:\n                       return num\n\nIs the time complexity O(n) for the above code? "
                    },
                    {
                        "username": "Khunger_Shivansh",
                        "content": " `#include <iostream>\n#include <vector>\n#include <limits.h>\nusing namespace std;\nint main()\n{\n    vector<int> arr{3, 2, 3};\n    int count = 0;\n    int ans;\n    for (int i = 0; i < arr.size(); i++)\n    {\n        int temp = arr[i];\n        if (arr[i] == INT_MIN)\n        {\n            continue;\n        }\n        int si = 0;\n        int ei = arr.size() - 1;\n        int count = 0;\n        while (si <= ei)\n        {\n            if (arr[i] == arr[si])\n            {\n                count++;\n                arr[si] = INT_MIN;\n            }\n            if (arr[i] == arr[ei])\n            {\n                count++;\n                arr[ei] = INT_MIN;\n            }\n            si++;\n            ei--;\n        }\n        if (count > arr.size() / 2)\n        {\n            cout << arr.size() / 2 << endl;\n            ans = temp;\n        }\n    }\n    cout << ans;\n}`\nFor this Code - Leetcode is giving Diff Ans and VS code is giving diff \nI think the problem is in arr.size() value.\nAnybody knows why this is happening ?"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can anybody share ideas for O(n) time & O(1) space solution?"
                    },
                    {
                        "username": "kunjalshah101",
                        "content": "Use Boyer-Moore voting algorithm"
                    },
                    {
                        "username": "ParagPriyadarshi",
                        "content": "PLEASE SOMEONE HELP ME WITH THIS \n\n\nclass Solution {\n    public int majorityElement(int[] nums) {\n     int count = 0;\n       int maj = 0;\n        for(int i = 0; i<nums.length;i++){\n               \n            for(int j = 0; j<nums.length;j++){\n                if(nums[j] == nums[i]){\n                    count++;\n                }    \n                \n          } if(count > Math.floor(nums.length/2)){\n                   \n                   return maj = nums[i];\n                    \n            }}return maj;\n    }}\n            why this code can't pass all the test cases , while changing the initialization of int count = 0;  to the for loop passes the all the test case.\nPls anyone help me with this I can't understand why changing the scope of the initialization of the variable gives the right answer.\n\nThis gives the answer.\n \nclass Solution {\n    public int majorityElement(int[] nums) {\n     \n       int maj = 0;\n        for(int i = 0; i<nums.length;i++){\n           int count = 0;    \n            for(int j = 0; j<nums.length;j++){\n                if(nums[j] == nums[i]){\n                    count++;\n                }    \n                \n          } if(count > Math.floor(nums.length/2)){\n                   \n                   return maj = nums[i];\n                    \n            }}return maj;\n    }}\n            "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        from collections import Counter\\n\\n        l = len(nums)/2\\n        nums = Counter(nums) \\n        \\n        for key, val in nums.items():\\n            if val > l:\\n                return key"
                    }
                ]
            },
            {
                "id": 1834870,
                "content": [
                    {
                        "username": "Shivang_Verma1",
                        "content": "````\n Arrays.sort(nums);\n    int len = nums.length;\n    return nums[len/2];\n````\n\nwhat if nums=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1;\n"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def majorityElement(self, nums):\\n        nums.sort()\\n        return nums[len(nums) // 2]\\n```"
                    },
                    {
                        "username": "Feruz1212",
                        "content": "I think, returning `middle number of sorted array` here, `not fair and not  linear time and in O(1) space ` SOLUTION, if i am not mistaken."
                    },
                    {
                        "username": "gopal_0208",
                        "content": "If you are having doubts then go through this article, it will help you in understanding\\nhttps://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm"
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "Can any one tell me what is wrong with this approach?\\n\\n   int high = 1;\\n   for(auto i: nums){\\n       if(nums[i]>high){\\n           high = nums[i];\\n       }\\n   }\\n   int arr[high+1];\\n   for (int i=0; i<nums.size(); i++){\\n       arr[nums[i]]+=1;\\n   }\\n   for(auto i: nums){\\n       if(nums[i]>high){\\n           high = nums[i];\\n       }\\n   }\\n   cout<< high;"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n        class Solution:\n            def majorityElement(self, nums: List[int]) -> int:\n               hashMap = {}\n               max_num = 0\n               for i in range(len(nums)):\n                    if nums[i] not in hashMap:\n                         hashMap[nums[i]] = 1\n                    else:\n                         hashMap[nums[i]] = 1 + hashMap.get(nums[i],0)\n        \n               max_num = max(hashMap.values())\n        \n               for num in nums:\n                   if hashMap.get(num) == max_num:\n                       return num\n\nIs the time complexity O(n) for the above code? "
                    },
                    {
                        "username": "Khunger_Shivansh",
                        "content": " `#include <iostream>\n#include <vector>\n#include <limits.h>\nusing namespace std;\nint main()\n{\n    vector<int> arr{3, 2, 3};\n    int count = 0;\n    int ans;\n    for (int i = 0; i < arr.size(); i++)\n    {\n        int temp = arr[i];\n        if (arr[i] == INT_MIN)\n        {\n            continue;\n        }\n        int si = 0;\n        int ei = arr.size() - 1;\n        int count = 0;\n        while (si <= ei)\n        {\n            if (arr[i] == arr[si])\n            {\n                count++;\n                arr[si] = INT_MIN;\n            }\n            if (arr[i] == arr[ei])\n            {\n                count++;\n                arr[ei] = INT_MIN;\n            }\n            si++;\n            ei--;\n        }\n        if (count > arr.size() / 2)\n        {\n            cout << arr.size() / 2 << endl;\n            ans = temp;\n        }\n    }\n    cout << ans;\n}`\nFor this Code - Leetcode is giving Diff Ans and VS code is giving diff \nI think the problem is in arr.size() value.\nAnybody knows why this is happening ?"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can anybody share ideas for O(n) time & O(1) space solution?"
                    },
                    {
                        "username": "kunjalshah101",
                        "content": "Use Boyer-Moore voting algorithm"
                    },
                    {
                        "username": "ParagPriyadarshi",
                        "content": "PLEASE SOMEONE HELP ME WITH THIS \n\n\nclass Solution {\n    public int majorityElement(int[] nums) {\n     int count = 0;\n       int maj = 0;\n        for(int i = 0; i<nums.length;i++){\n               \n            for(int j = 0; j<nums.length;j++){\n                if(nums[j] == nums[i]){\n                    count++;\n                }    \n                \n          } if(count > Math.floor(nums.length/2)){\n                   \n                   return maj = nums[i];\n                    \n            }}return maj;\n    }}\n            why this code can't pass all the test cases , while changing the initialization of int count = 0;  to the for loop passes the all the test case.\nPls anyone help me with this I can't understand why changing the scope of the initialization of the variable gives the right answer.\n\nThis gives the answer.\n \nclass Solution {\n    public int majorityElement(int[] nums) {\n     \n       int maj = 0;\n        for(int i = 0; i<nums.length;i++){\n           int count = 0;    \n            for(int j = 0; j<nums.length;j++){\n                if(nums[j] == nums[i]){\n                    count++;\n                }    \n                \n          } if(count > Math.floor(nums.length/2)){\n                   \n                   return maj = nums[i];\n                    \n            }}return maj;\n    }}\n            "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        from collections import Counter\\n\\n        l = len(nums)/2\\n        nums = Counter(nums) \\n        \\n        for key, val in nums.items():\\n            if val > l:\\n                return key"
                    }
                ]
            },
            {
                "id": 1834461,
                "content": [
                    {
                        "username": "Shivang_Verma1",
                        "content": "````\n Arrays.sort(nums);\n    int len = nums.length;\n    return nums[len/2];\n````\n\nwhat if nums=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1;\n"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def majorityElement(self, nums):\\n        nums.sort()\\n        return nums[len(nums) // 2]\\n```"
                    },
                    {
                        "username": "Feruz1212",
                        "content": "I think, returning `middle number of sorted array` here, `not fair and not  linear time and in O(1) space ` SOLUTION, if i am not mistaken."
                    },
                    {
                        "username": "gopal_0208",
                        "content": "If you are having doubts then go through this article, it will help you in understanding\\nhttps://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm"
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "Can any one tell me what is wrong with this approach?\\n\\n   int high = 1;\\n   for(auto i: nums){\\n       if(nums[i]>high){\\n           high = nums[i];\\n       }\\n   }\\n   int arr[high+1];\\n   for (int i=0; i<nums.size(); i++){\\n       arr[nums[i]]+=1;\\n   }\\n   for(auto i: nums){\\n       if(nums[i]>high){\\n           high = nums[i];\\n       }\\n   }\\n   cout<< high;"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n        class Solution:\n            def majorityElement(self, nums: List[int]) -> int:\n               hashMap = {}\n               max_num = 0\n               for i in range(len(nums)):\n                    if nums[i] not in hashMap:\n                         hashMap[nums[i]] = 1\n                    else:\n                         hashMap[nums[i]] = 1 + hashMap.get(nums[i],0)\n        \n               max_num = max(hashMap.values())\n        \n               for num in nums:\n                   if hashMap.get(num) == max_num:\n                       return num\n\nIs the time complexity O(n) for the above code? "
                    },
                    {
                        "username": "Khunger_Shivansh",
                        "content": " `#include <iostream>\n#include <vector>\n#include <limits.h>\nusing namespace std;\nint main()\n{\n    vector<int> arr{3, 2, 3};\n    int count = 0;\n    int ans;\n    for (int i = 0; i < arr.size(); i++)\n    {\n        int temp = arr[i];\n        if (arr[i] == INT_MIN)\n        {\n            continue;\n        }\n        int si = 0;\n        int ei = arr.size() - 1;\n        int count = 0;\n        while (si <= ei)\n        {\n            if (arr[i] == arr[si])\n            {\n                count++;\n                arr[si] = INT_MIN;\n            }\n            if (arr[i] == arr[ei])\n            {\n                count++;\n                arr[ei] = INT_MIN;\n            }\n            si++;\n            ei--;\n        }\n        if (count > arr.size() / 2)\n        {\n            cout << arr.size() / 2 << endl;\n            ans = temp;\n        }\n    }\n    cout << ans;\n}`\nFor this Code - Leetcode is giving Diff Ans and VS code is giving diff \nI think the problem is in arr.size() value.\nAnybody knows why this is happening ?"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can anybody share ideas for O(n) time & O(1) space solution?"
                    },
                    {
                        "username": "kunjalshah101",
                        "content": "Use Boyer-Moore voting algorithm"
                    },
                    {
                        "username": "ParagPriyadarshi",
                        "content": "PLEASE SOMEONE HELP ME WITH THIS \n\n\nclass Solution {\n    public int majorityElement(int[] nums) {\n     int count = 0;\n       int maj = 0;\n        for(int i = 0; i<nums.length;i++){\n               \n            for(int j = 0; j<nums.length;j++){\n                if(nums[j] == nums[i]){\n                    count++;\n                }    \n                \n          } if(count > Math.floor(nums.length/2)){\n                   \n                   return maj = nums[i];\n                    \n            }}return maj;\n    }}\n            why this code can't pass all the test cases , while changing the initialization of int count = 0;  to the for loop passes the all the test case.\nPls anyone help me with this I can't understand why changing the scope of the initialization of the variable gives the right answer.\n\nThis gives the answer.\n \nclass Solution {\n    public int majorityElement(int[] nums) {\n     \n       int maj = 0;\n        for(int i = 0; i<nums.length;i++){\n           int count = 0;    \n            for(int j = 0; j<nums.length;j++){\n                if(nums[j] == nums[i]){\n                    count++;\n                }    \n                \n          } if(count > Math.floor(nums.length/2)){\n                   \n                   return maj = nums[i];\n                    \n            }}return maj;\n    }}\n            "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        from collections import Counter\\n\\n        l = len(nums)/2\\n        nums = Counter(nums) \\n        \\n        for key, val in nums.items():\\n            if val > l:\\n                return key"
                    }
                ]
            },
            {
                "id": 1831531,
                "content": [
                    {
                        "username": "Shivang_Verma1",
                        "content": "````\n Arrays.sort(nums);\n    int len = nums.length;\n    return nums[len/2];\n````\n\nwhat if nums=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1;\n"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def majorityElement(self, nums):\\n        nums.sort()\\n        return nums[len(nums) // 2]\\n```"
                    },
                    {
                        "username": "Feruz1212",
                        "content": "I think, returning `middle number of sorted array` here, `not fair and not  linear time and in O(1) space ` SOLUTION, if i am not mistaken."
                    },
                    {
                        "username": "gopal_0208",
                        "content": "If you are having doubts then go through this article, it will help you in understanding\\nhttps://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm"
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "Can any one tell me what is wrong with this approach?\\n\\n   int high = 1;\\n   for(auto i: nums){\\n       if(nums[i]>high){\\n           high = nums[i];\\n       }\\n   }\\n   int arr[high+1];\\n   for (int i=0; i<nums.size(); i++){\\n       arr[nums[i]]+=1;\\n   }\\n   for(auto i: nums){\\n       if(nums[i]>high){\\n           high = nums[i];\\n       }\\n   }\\n   cout<< high;"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n        class Solution:\n            def majorityElement(self, nums: List[int]) -> int:\n               hashMap = {}\n               max_num = 0\n               for i in range(len(nums)):\n                    if nums[i] not in hashMap:\n                         hashMap[nums[i]] = 1\n                    else:\n                         hashMap[nums[i]] = 1 + hashMap.get(nums[i],0)\n        \n               max_num = max(hashMap.values())\n        \n               for num in nums:\n                   if hashMap.get(num) == max_num:\n                       return num\n\nIs the time complexity O(n) for the above code? "
                    },
                    {
                        "username": "Khunger_Shivansh",
                        "content": " `#include <iostream>\n#include <vector>\n#include <limits.h>\nusing namespace std;\nint main()\n{\n    vector<int> arr{3, 2, 3};\n    int count = 0;\n    int ans;\n    for (int i = 0; i < arr.size(); i++)\n    {\n        int temp = arr[i];\n        if (arr[i] == INT_MIN)\n        {\n            continue;\n        }\n        int si = 0;\n        int ei = arr.size() - 1;\n        int count = 0;\n        while (si <= ei)\n        {\n            if (arr[i] == arr[si])\n            {\n                count++;\n                arr[si] = INT_MIN;\n            }\n            if (arr[i] == arr[ei])\n            {\n                count++;\n                arr[ei] = INT_MIN;\n            }\n            si++;\n            ei--;\n        }\n        if (count > arr.size() / 2)\n        {\n            cout << arr.size() / 2 << endl;\n            ans = temp;\n        }\n    }\n    cout << ans;\n}`\nFor this Code - Leetcode is giving Diff Ans and VS code is giving diff \nI think the problem is in arr.size() value.\nAnybody knows why this is happening ?"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can anybody share ideas for O(n) time & O(1) space solution?"
                    },
                    {
                        "username": "kunjalshah101",
                        "content": "Use Boyer-Moore voting algorithm"
                    },
                    {
                        "username": "ParagPriyadarshi",
                        "content": "PLEASE SOMEONE HELP ME WITH THIS \n\n\nclass Solution {\n    public int majorityElement(int[] nums) {\n     int count = 0;\n       int maj = 0;\n        for(int i = 0; i<nums.length;i++){\n               \n            for(int j = 0; j<nums.length;j++){\n                if(nums[j] == nums[i]){\n                    count++;\n                }    \n                \n          } if(count > Math.floor(nums.length/2)){\n                   \n                   return maj = nums[i];\n                    \n            }}return maj;\n    }}\n            why this code can't pass all the test cases , while changing the initialization of int count = 0;  to the for loop passes the all the test case.\nPls anyone help me with this I can't understand why changing the scope of the initialization of the variable gives the right answer.\n\nThis gives the answer.\n \nclass Solution {\n    public int majorityElement(int[] nums) {\n     \n       int maj = 0;\n        for(int i = 0; i<nums.length;i++){\n           int count = 0;    \n            for(int j = 0; j<nums.length;j++){\n                if(nums[j] == nums[i]){\n                    count++;\n                }    \n                \n          } if(count > Math.floor(nums.length/2)){\n                   \n                   return maj = nums[i];\n                    \n            }}return maj;\n    }}\n            "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        from collections import Counter\\n\\n        l = len(nums)/2\\n        nums = Counter(nums) \\n        \\n        for key, val in nums.items():\\n            if val > l:\\n                return key"
                    }
                ]
            },
            {
                "id": 1820666,
                "content": [
                    {
                        "username": "Shivang_Verma1",
                        "content": "````\n Arrays.sort(nums);\n    int len = nums.length;\n    return nums[len/2];\n````\n\nwhat if nums=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1;\n"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def majorityElement(self, nums):\\n        nums.sort()\\n        return nums[len(nums) // 2]\\n```"
                    },
                    {
                        "username": "Feruz1212",
                        "content": "I think, returning `middle number of sorted array` here, `not fair and not  linear time and in O(1) space ` SOLUTION, if i am not mistaken."
                    },
                    {
                        "username": "gopal_0208",
                        "content": "If you are having doubts then go through this article, it will help you in understanding\\nhttps://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm"
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "Can any one tell me what is wrong with this approach?\\n\\n   int high = 1;\\n   for(auto i: nums){\\n       if(nums[i]>high){\\n           high = nums[i];\\n       }\\n   }\\n   int arr[high+1];\\n   for (int i=0; i<nums.size(); i++){\\n       arr[nums[i]]+=1;\\n   }\\n   for(auto i: nums){\\n       if(nums[i]>high){\\n           high = nums[i];\\n       }\\n   }\\n   cout<< high;"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n        class Solution:\n            def majorityElement(self, nums: List[int]) -> int:\n               hashMap = {}\n               max_num = 0\n               for i in range(len(nums)):\n                    if nums[i] not in hashMap:\n                         hashMap[nums[i]] = 1\n                    else:\n                         hashMap[nums[i]] = 1 + hashMap.get(nums[i],0)\n        \n               max_num = max(hashMap.values())\n        \n               for num in nums:\n                   if hashMap.get(num) == max_num:\n                       return num\n\nIs the time complexity O(n) for the above code? "
                    },
                    {
                        "username": "Khunger_Shivansh",
                        "content": " `#include <iostream>\n#include <vector>\n#include <limits.h>\nusing namespace std;\nint main()\n{\n    vector<int> arr{3, 2, 3};\n    int count = 0;\n    int ans;\n    for (int i = 0; i < arr.size(); i++)\n    {\n        int temp = arr[i];\n        if (arr[i] == INT_MIN)\n        {\n            continue;\n        }\n        int si = 0;\n        int ei = arr.size() - 1;\n        int count = 0;\n        while (si <= ei)\n        {\n            if (arr[i] == arr[si])\n            {\n                count++;\n                arr[si] = INT_MIN;\n            }\n            if (arr[i] == arr[ei])\n            {\n                count++;\n                arr[ei] = INT_MIN;\n            }\n            si++;\n            ei--;\n        }\n        if (count > arr.size() / 2)\n        {\n            cout << arr.size() / 2 << endl;\n            ans = temp;\n        }\n    }\n    cout << ans;\n}`\nFor this Code - Leetcode is giving Diff Ans and VS code is giving diff \nI think the problem is in arr.size() value.\nAnybody knows why this is happening ?"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can anybody share ideas for O(n) time & O(1) space solution?"
                    },
                    {
                        "username": "kunjalshah101",
                        "content": "Use Boyer-Moore voting algorithm"
                    },
                    {
                        "username": "ParagPriyadarshi",
                        "content": "PLEASE SOMEONE HELP ME WITH THIS \n\n\nclass Solution {\n    public int majorityElement(int[] nums) {\n     int count = 0;\n       int maj = 0;\n        for(int i = 0; i<nums.length;i++){\n               \n            for(int j = 0; j<nums.length;j++){\n                if(nums[j] == nums[i]){\n                    count++;\n                }    \n                \n          } if(count > Math.floor(nums.length/2)){\n                   \n                   return maj = nums[i];\n                    \n            }}return maj;\n    }}\n            why this code can't pass all the test cases , while changing the initialization of int count = 0;  to the for loop passes the all the test case.\nPls anyone help me with this I can't understand why changing the scope of the initialization of the variable gives the right answer.\n\nThis gives the answer.\n \nclass Solution {\n    public int majorityElement(int[] nums) {\n     \n       int maj = 0;\n        for(int i = 0; i<nums.length;i++){\n           int count = 0;    \n            for(int j = 0; j<nums.length;j++){\n                if(nums[j] == nums[i]){\n                    count++;\n                }    \n                \n          } if(count > Math.floor(nums.length/2)){\n                   \n                   return maj = nums[i];\n                    \n            }}return maj;\n    }}\n            "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        from collections import Counter\\n\\n        l = len(nums)/2\\n        nums = Counter(nums) \\n        \\n        for key, val in nums.items():\\n            if val > l:\\n                return key"
                    }
                ]
            },
            {
                "id": 1817348,
                "content": [
                    {
                        "username": "Shivang_Verma1",
                        "content": "````\n Arrays.sort(nums);\n    int len = nums.length;\n    return nums[len/2];\n````\n\nwhat if nums=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1;\n"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def majorityElement(self, nums):\\n        nums.sort()\\n        return nums[len(nums) // 2]\\n```"
                    },
                    {
                        "username": "Feruz1212",
                        "content": "I think, returning `middle number of sorted array` here, `not fair and not  linear time and in O(1) space ` SOLUTION, if i am not mistaken."
                    },
                    {
                        "username": "gopal_0208",
                        "content": "If you are having doubts then go through this article, it will help you in understanding\\nhttps://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm"
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "Can any one tell me what is wrong with this approach?\\n\\n   int high = 1;\\n   for(auto i: nums){\\n       if(nums[i]>high){\\n           high = nums[i];\\n       }\\n   }\\n   int arr[high+1];\\n   for (int i=0; i<nums.size(); i++){\\n       arr[nums[i]]+=1;\\n   }\\n   for(auto i: nums){\\n       if(nums[i]>high){\\n           high = nums[i];\\n       }\\n   }\\n   cout<< high;"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n        class Solution:\n            def majorityElement(self, nums: List[int]) -> int:\n               hashMap = {}\n               max_num = 0\n               for i in range(len(nums)):\n                    if nums[i] not in hashMap:\n                         hashMap[nums[i]] = 1\n                    else:\n                         hashMap[nums[i]] = 1 + hashMap.get(nums[i],0)\n        \n               max_num = max(hashMap.values())\n        \n               for num in nums:\n                   if hashMap.get(num) == max_num:\n                       return num\n\nIs the time complexity O(n) for the above code? "
                    },
                    {
                        "username": "Khunger_Shivansh",
                        "content": " `#include <iostream>\n#include <vector>\n#include <limits.h>\nusing namespace std;\nint main()\n{\n    vector<int> arr{3, 2, 3};\n    int count = 0;\n    int ans;\n    for (int i = 0; i < arr.size(); i++)\n    {\n        int temp = arr[i];\n        if (arr[i] == INT_MIN)\n        {\n            continue;\n        }\n        int si = 0;\n        int ei = arr.size() - 1;\n        int count = 0;\n        while (si <= ei)\n        {\n            if (arr[i] == arr[si])\n            {\n                count++;\n                arr[si] = INT_MIN;\n            }\n            if (arr[i] == arr[ei])\n            {\n                count++;\n                arr[ei] = INT_MIN;\n            }\n            si++;\n            ei--;\n        }\n        if (count > arr.size() / 2)\n        {\n            cout << arr.size() / 2 << endl;\n            ans = temp;\n        }\n    }\n    cout << ans;\n}`\nFor this Code - Leetcode is giving Diff Ans and VS code is giving diff \nI think the problem is in arr.size() value.\nAnybody knows why this is happening ?"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can anybody share ideas for O(n) time & O(1) space solution?"
                    },
                    {
                        "username": "kunjalshah101",
                        "content": "Use Boyer-Moore voting algorithm"
                    },
                    {
                        "username": "ParagPriyadarshi",
                        "content": "PLEASE SOMEONE HELP ME WITH THIS \n\n\nclass Solution {\n    public int majorityElement(int[] nums) {\n     int count = 0;\n       int maj = 0;\n        for(int i = 0; i<nums.length;i++){\n               \n            for(int j = 0; j<nums.length;j++){\n                if(nums[j] == nums[i]){\n                    count++;\n                }    \n                \n          } if(count > Math.floor(nums.length/2)){\n                   \n                   return maj = nums[i];\n                    \n            }}return maj;\n    }}\n            why this code can't pass all the test cases , while changing the initialization of int count = 0;  to the for loop passes the all the test case.\nPls anyone help me with this I can't understand why changing the scope of the initialization of the variable gives the right answer.\n\nThis gives the answer.\n \nclass Solution {\n    public int majorityElement(int[] nums) {\n     \n       int maj = 0;\n        for(int i = 0; i<nums.length;i++){\n           int count = 0;    \n            for(int j = 0; j<nums.length;j++){\n                if(nums[j] == nums[i]){\n                    count++;\n                }    \n                \n          } if(count > Math.floor(nums.length/2)){\n                   \n                   return maj = nums[i];\n                    \n            }}return maj;\n    }}\n            "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        from collections import Counter\\n\\n        l = len(nums)/2\\n        nums = Counter(nums) \\n        \\n        for key, val in nums.items():\\n            if val > l:\\n                return key"
                    }
                ]
            },
            {
                "id": 1815397,
                "content": [
                    {
                        "username": "Shivang_Verma1",
                        "content": "````\n Arrays.sort(nums);\n    int len = nums.length;\n    return nums[len/2];\n````\n\nwhat if nums=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1;\n"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def majorityElement(self, nums):\\n        nums.sort()\\n        return nums[len(nums) // 2]\\n```"
                    },
                    {
                        "username": "Feruz1212",
                        "content": "I think, returning `middle number of sorted array` here, `not fair and not  linear time and in O(1) space ` SOLUTION, if i am not mistaken."
                    },
                    {
                        "username": "gopal_0208",
                        "content": "If you are having doubts then go through this article, it will help you in understanding\\nhttps://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm"
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "Can any one tell me what is wrong with this approach?\\n\\n   int high = 1;\\n   for(auto i: nums){\\n       if(nums[i]>high){\\n           high = nums[i];\\n       }\\n   }\\n   int arr[high+1];\\n   for (int i=0; i<nums.size(); i++){\\n       arr[nums[i]]+=1;\\n   }\\n   for(auto i: nums){\\n       if(nums[i]>high){\\n           high = nums[i];\\n       }\\n   }\\n   cout<< high;"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n        class Solution:\n            def majorityElement(self, nums: List[int]) -> int:\n               hashMap = {}\n               max_num = 0\n               for i in range(len(nums)):\n                    if nums[i] not in hashMap:\n                         hashMap[nums[i]] = 1\n                    else:\n                         hashMap[nums[i]] = 1 + hashMap.get(nums[i],0)\n        \n               max_num = max(hashMap.values())\n        \n               for num in nums:\n                   if hashMap.get(num) == max_num:\n                       return num\n\nIs the time complexity O(n) for the above code? "
                    },
                    {
                        "username": "Khunger_Shivansh",
                        "content": " `#include <iostream>\n#include <vector>\n#include <limits.h>\nusing namespace std;\nint main()\n{\n    vector<int> arr{3, 2, 3};\n    int count = 0;\n    int ans;\n    for (int i = 0; i < arr.size(); i++)\n    {\n        int temp = arr[i];\n        if (arr[i] == INT_MIN)\n        {\n            continue;\n        }\n        int si = 0;\n        int ei = arr.size() - 1;\n        int count = 0;\n        while (si <= ei)\n        {\n            if (arr[i] == arr[si])\n            {\n                count++;\n                arr[si] = INT_MIN;\n            }\n            if (arr[i] == arr[ei])\n            {\n                count++;\n                arr[ei] = INT_MIN;\n            }\n            si++;\n            ei--;\n        }\n        if (count > arr.size() / 2)\n        {\n            cout << arr.size() / 2 << endl;\n            ans = temp;\n        }\n    }\n    cout << ans;\n}`\nFor this Code - Leetcode is giving Diff Ans and VS code is giving diff \nI think the problem is in arr.size() value.\nAnybody knows why this is happening ?"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can anybody share ideas for O(n) time & O(1) space solution?"
                    },
                    {
                        "username": "kunjalshah101",
                        "content": "Use Boyer-Moore voting algorithm"
                    },
                    {
                        "username": "ParagPriyadarshi",
                        "content": "PLEASE SOMEONE HELP ME WITH THIS \n\n\nclass Solution {\n    public int majorityElement(int[] nums) {\n     int count = 0;\n       int maj = 0;\n        for(int i = 0; i<nums.length;i++){\n               \n            for(int j = 0; j<nums.length;j++){\n                if(nums[j] == nums[i]){\n                    count++;\n                }    \n                \n          } if(count > Math.floor(nums.length/2)){\n                   \n                   return maj = nums[i];\n                    \n            }}return maj;\n    }}\n            why this code can't pass all the test cases , while changing the initialization of int count = 0;  to the for loop passes the all the test case.\nPls anyone help me with this I can't understand why changing the scope of the initialization of the variable gives the right answer.\n\nThis gives the answer.\n \nclass Solution {\n    public int majorityElement(int[] nums) {\n     \n       int maj = 0;\n        for(int i = 0; i<nums.length;i++){\n           int count = 0;    \n            for(int j = 0; j<nums.length;j++){\n                if(nums[j] == nums[i]){\n                    count++;\n                }    \n                \n          } if(count > Math.floor(nums.length/2)){\n                   \n                   return maj = nums[i];\n                    \n            }}return maj;\n    }}\n            "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        from collections import Counter\\n\\n        l = len(nums)/2\\n        nums = Counter(nums) \\n        \\n        for key, val in nums.items():\\n            if val > l:\\n                return key"
                    }
                ]
            },
            {
                "id": 1805264,
                "content": [
                    {
                        "username": "Shivang_Verma1",
                        "content": "````\n Arrays.sort(nums);\n    int len = nums.length;\n    return nums[len/2];\n````\n\nwhat if nums=[1,1,1,2,2,4]?\nthen your code will give nums[6/2] ---> nums[3] i.e 2 but the majority element is 1;\n"
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def majorityElement(self, nums):\\n        nums.sort()\\n        return nums[len(nums) // 2]\\n```"
                    },
                    {
                        "username": "Feruz1212",
                        "content": "I think, returning `middle number of sorted array` here, `not fair and not  linear time and in O(1) space ` SOLUTION, if i am not mistaken."
                    },
                    {
                        "username": "gopal_0208",
                        "content": "If you are having doubts then go through this article, it will help you in understanding\\nhttps://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm"
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "Can any one tell me what is wrong with this approach?\\n\\n   int high = 1;\\n   for(auto i: nums){\\n       if(nums[i]>high){\\n           high = nums[i];\\n       }\\n   }\\n   int arr[high+1];\\n   for (int i=0; i<nums.size(); i++){\\n       arr[nums[i]]+=1;\\n   }\\n   for(auto i: nums){\\n       if(nums[i]>high){\\n           high = nums[i];\\n       }\\n   }\\n   cout<< high;"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n        class Solution:\n            def majorityElement(self, nums: List[int]) -> int:\n               hashMap = {}\n               max_num = 0\n               for i in range(len(nums)):\n                    if nums[i] not in hashMap:\n                         hashMap[nums[i]] = 1\n                    else:\n                         hashMap[nums[i]] = 1 + hashMap.get(nums[i],0)\n        \n               max_num = max(hashMap.values())\n        \n               for num in nums:\n                   if hashMap.get(num) == max_num:\n                       return num\n\nIs the time complexity O(n) for the above code? "
                    },
                    {
                        "username": "Khunger_Shivansh",
                        "content": " `#include <iostream>\n#include <vector>\n#include <limits.h>\nusing namespace std;\nint main()\n{\n    vector<int> arr{3, 2, 3};\n    int count = 0;\n    int ans;\n    for (int i = 0; i < arr.size(); i++)\n    {\n        int temp = arr[i];\n        if (arr[i] == INT_MIN)\n        {\n            continue;\n        }\n        int si = 0;\n        int ei = arr.size() - 1;\n        int count = 0;\n        while (si <= ei)\n        {\n            if (arr[i] == arr[si])\n            {\n                count++;\n                arr[si] = INT_MIN;\n            }\n            if (arr[i] == arr[ei])\n            {\n                count++;\n                arr[ei] = INT_MIN;\n            }\n            si++;\n            ei--;\n        }\n        if (count > arr.size() / 2)\n        {\n            cout << arr.size() / 2 << endl;\n            ans = temp;\n        }\n    }\n    cout << ans;\n}`\nFor this Code - Leetcode is giving Diff Ans and VS code is giving diff \nI think the problem is in arr.size() value.\nAnybody knows why this is happening ?"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can anybody share ideas for O(n) time & O(1) space solution?"
                    },
                    {
                        "username": "kunjalshah101",
                        "content": "Use Boyer-Moore voting algorithm"
                    },
                    {
                        "username": "ParagPriyadarshi",
                        "content": "PLEASE SOMEONE HELP ME WITH THIS \n\n\nclass Solution {\n    public int majorityElement(int[] nums) {\n     int count = 0;\n       int maj = 0;\n        for(int i = 0; i<nums.length;i++){\n               \n            for(int j = 0; j<nums.length;j++){\n                if(nums[j] == nums[i]){\n                    count++;\n                }    \n                \n          } if(count > Math.floor(nums.length/2)){\n                   \n                   return maj = nums[i];\n                    \n            }}return maj;\n    }}\n            why this code can't pass all the test cases , while changing the initialization of int count = 0;  to the for loop passes the all the test case.\nPls anyone help me with this I can't understand why changing the scope of the initialization of the variable gives the right answer.\n\nThis gives the answer.\n \nclass Solution {\n    public int majorityElement(int[] nums) {\n     \n       int maj = 0;\n        for(int i = 0; i<nums.length;i++){\n           int count = 0;    \n            for(int j = 0; j<nums.length;j++){\n                if(nums[j] == nums[i]){\n                    count++;\n                }    \n                \n          } if(count > Math.floor(nums.length/2)){\n                   \n                   return maj = nums[i];\n                    \n            }}return maj;\n    }}\n            "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        from collections import Counter\\n\\n        l = len(nums)/2\\n        nums = Counter(nums) \\n        \\n        for key, val in nums.items():\\n            if val > l:\\n                return key"
                    }
                ]
            },
            {
                "id": 1797912,
                "content": [
                    {
                        "username": "NaveenKewat",
                        "content": "easy sollution java\\n\\n`class Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        for(int i = 0;i < nums.length;i++){\\n\\n            int count = 0;\\n            for(int j = i;j<nums.length;j++){\\n                if(nums[i] == nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count > nums.length/2){\\n                return nums[i];\\n            }\\n\\n        }\\n        return -1;\\n\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "pritz99",
                        "content": "class Solution {\\n    public int majorityElement(int[] arr) {\\n      LinkedList<Integer> l= new LinkedList();\\n    for(int i=0;i<arr.length;i++) {\\n    \\tl.add(arr[i]);\\n    }\\n    int m=0;\\n    for(int i=0;i<l.size();i++) {\\n    \\tm=  Collections.frequency(l,l.get(i));\\n    \\tif(m>l.size()/2) return l.get(i);\\n    }\\nreturn -1;\\n    }\\n}\\ni write this code and it passes 41/45 cases but after that it gives time limit exceed error?\\n"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "hint:use boyer moore voting alogorithm for linear time complexity and O(1) space"
                    },
                    {
                        "username": "Sandesh_Tangade",
                        "content": "I still don\\'t understand why this line?\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "kvm22",
                        "content": "Bruteforce :TLE\\n\\nfor(int i=0;i<nums.size();i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.size();j++){\\n               \\n               if(nums[i]==nums[j])\\n               count++;\\n               \\n            \\n            }\\n            if(count>nums.size()/2)\\n                 return nums[i];\\n           \\n            \\n        }\\n        return -1; "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "eduard92",
                        "content": "Damn I came here from some low submissions problems and I went straight away overthinking this.\\nI assumed off the bat that the array would contain different numbers, not just 2 and I was like what is this n/2 because if we have 3 numbers, that is gonna get messed up.\\n\\nEither way this problem could use a part 2, but then is about counting the frequency of a number I guess."
                    },
                    {
                        "username": "jhaeeshani",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n     int c[1000];\\n     int n = nums.size();\\n     int d ;\\n        for(int i = 0 ;i<n;i++){\\n            int num = nums[i];\\n           { if(nums[i] == num)\\n         c[nums[i]]++;\\n        }\\n        d = max(  c[nums[i]], d);\\n        return nums[i];\\n        \\n        }\\n        return 0;\\n\\n        \\n\\n        \\n    }\\n};\\nCan someone suggest why is this code failing in the 8th test case of 6,5,5 ,the output coming 6.\\nThanks in advance."
                    },
                    {
                        "username": "Pengu_98",
                        "content": "Been grinding leetcode for almost a year. Came up with the Hash Map solution and I have never felt so good.  Consistency is the key my friends !"
                    },
                    {
                        "username": "knazdawid",
                        "content": "HashMap is not O(1) space efficient solution. So not sure why you are happy XD"
                    },
                    {
                        "username": "manuchaitanya17",
                        "content": "for solution nums[nums.length/2]:\\nWhat about this test case: 2,2,1,1,1,2,2,3,3,3,3,3,3,3,2,2,1,1.\\n"
                    }
                ]
            },
            {
                "id": 1794435,
                "content": [
                    {
                        "username": "NaveenKewat",
                        "content": "easy sollution java\\n\\n`class Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        for(int i = 0;i < nums.length;i++){\\n\\n            int count = 0;\\n            for(int j = i;j<nums.length;j++){\\n                if(nums[i] == nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count > nums.length/2){\\n                return nums[i];\\n            }\\n\\n        }\\n        return -1;\\n\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "pritz99",
                        "content": "class Solution {\\n    public int majorityElement(int[] arr) {\\n      LinkedList<Integer> l= new LinkedList();\\n    for(int i=0;i<arr.length;i++) {\\n    \\tl.add(arr[i]);\\n    }\\n    int m=0;\\n    for(int i=0;i<l.size();i++) {\\n    \\tm=  Collections.frequency(l,l.get(i));\\n    \\tif(m>l.size()/2) return l.get(i);\\n    }\\nreturn -1;\\n    }\\n}\\ni write this code and it passes 41/45 cases but after that it gives time limit exceed error?\\n"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "hint:use boyer moore voting alogorithm for linear time complexity and O(1) space"
                    },
                    {
                        "username": "Sandesh_Tangade",
                        "content": "I still don\\'t understand why this line?\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "kvm22",
                        "content": "Bruteforce :TLE\\n\\nfor(int i=0;i<nums.size();i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.size();j++){\\n               \\n               if(nums[i]==nums[j])\\n               count++;\\n               \\n            \\n            }\\n            if(count>nums.size()/2)\\n                 return nums[i];\\n           \\n            \\n        }\\n        return -1; "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "eduard92",
                        "content": "Damn I came here from some low submissions problems and I went straight away overthinking this.\\nI assumed off the bat that the array would contain different numbers, not just 2 and I was like what is this n/2 because if we have 3 numbers, that is gonna get messed up.\\n\\nEither way this problem could use a part 2, but then is about counting the frequency of a number I guess."
                    },
                    {
                        "username": "jhaeeshani",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n     int c[1000];\\n     int n = nums.size();\\n     int d ;\\n        for(int i = 0 ;i<n;i++){\\n            int num = nums[i];\\n           { if(nums[i] == num)\\n         c[nums[i]]++;\\n        }\\n        d = max(  c[nums[i]], d);\\n        return nums[i];\\n        \\n        }\\n        return 0;\\n\\n        \\n\\n        \\n    }\\n};\\nCan someone suggest why is this code failing in the 8th test case of 6,5,5 ,the output coming 6.\\nThanks in advance."
                    },
                    {
                        "username": "Pengu_98",
                        "content": "Been grinding leetcode for almost a year. Came up with the Hash Map solution and I have never felt so good.  Consistency is the key my friends !"
                    },
                    {
                        "username": "knazdawid",
                        "content": "HashMap is not O(1) space efficient solution. So not sure why you are happy XD"
                    },
                    {
                        "username": "manuchaitanya17",
                        "content": "for solution nums[nums.length/2]:\\nWhat about this test case: 2,2,1,1,1,2,2,3,3,3,3,3,3,3,2,2,1,1.\\n"
                    }
                ]
            },
            {
                "id": 1794296,
                "content": [
                    {
                        "username": "NaveenKewat",
                        "content": "easy sollution java\\n\\n`class Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        for(int i = 0;i < nums.length;i++){\\n\\n            int count = 0;\\n            for(int j = i;j<nums.length;j++){\\n                if(nums[i] == nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count > nums.length/2){\\n                return nums[i];\\n            }\\n\\n        }\\n        return -1;\\n\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "pritz99",
                        "content": "class Solution {\\n    public int majorityElement(int[] arr) {\\n      LinkedList<Integer> l= new LinkedList();\\n    for(int i=0;i<arr.length;i++) {\\n    \\tl.add(arr[i]);\\n    }\\n    int m=0;\\n    for(int i=0;i<l.size();i++) {\\n    \\tm=  Collections.frequency(l,l.get(i));\\n    \\tif(m>l.size()/2) return l.get(i);\\n    }\\nreturn -1;\\n    }\\n}\\ni write this code and it passes 41/45 cases but after that it gives time limit exceed error?\\n"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "hint:use boyer moore voting alogorithm for linear time complexity and O(1) space"
                    },
                    {
                        "username": "Sandesh_Tangade",
                        "content": "I still don\\'t understand why this line?\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "kvm22",
                        "content": "Bruteforce :TLE\\n\\nfor(int i=0;i<nums.size();i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.size();j++){\\n               \\n               if(nums[i]==nums[j])\\n               count++;\\n               \\n            \\n            }\\n            if(count>nums.size()/2)\\n                 return nums[i];\\n           \\n            \\n        }\\n        return -1; "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "eduard92",
                        "content": "Damn I came here from some low submissions problems and I went straight away overthinking this.\\nI assumed off the bat that the array would contain different numbers, not just 2 and I was like what is this n/2 because if we have 3 numbers, that is gonna get messed up.\\n\\nEither way this problem could use a part 2, but then is about counting the frequency of a number I guess."
                    },
                    {
                        "username": "jhaeeshani",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n     int c[1000];\\n     int n = nums.size();\\n     int d ;\\n        for(int i = 0 ;i<n;i++){\\n            int num = nums[i];\\n           { if(nums[i] == num)\\n         c[nums[i]]++;\\n        }\\n        d = max(  c[nums[i]], d);\\n        return nums[i];\\n        \\n        }\\n        return 0;\\n\\n        \\n\\n        \\n    }\\n};\\nCan someone suggest why is this code failing in the 8th test case of 6,5,5 ,the output coming 6.\\nThanks in advance."
                    },
                    {
                        "username": "Pengu_98",
                        "content": "Been grinding leetcode for almost a year. Came up with the Hash Map solution and I have never felt so good.  Consistency is the key my friends !"
                    },
                    {
                        "username": "knazdawid",
                        "content": "HashMap is not O(1) space efficient solution. So not sure why you are happy XD"
                    },
                    {
                        "username": "manuchaitanya17",
                        "content": "for solution nums[nums.length/2]:\\nWhat about this test case: 2,2,1,1,1,2,2,3,3,3,3,3,3,3,2,2,1,1.\\n"
                    }
                ]
            },
            {
                "id": 1783828,
                "content": [
                    {
                        "username": "NaveenKewat",
                        "content": "easy sollution java\\n\\n`class Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        for(int i = 0;i < nums.length;i++){\\n\\n            int count = 0;\\n            for(int j = i;j<nums.length;j++){\\n                if(nums[i] == nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count > nums.length/2){\\n                return nums[i];\\n            }\\n\\n        }\\n        return -1;\\n\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "pritz99",
                        "content": "class Solution {\\n    public int majorityElement(int[] arr) {\\n      LinkedList<Integer> l= new LinkedList();\\n    for(int i=0;i<arr.length;i++) {\\n    \\tl.add(arr[i]);\\n    }\\n    int m=0;\\n    for(int i=0;i<l.size();i++) {\\n    \\tm=  Collections.frequency(l,l.get(i));\\n    \\tif(m>l.size()/2) return l.get(i);\\n    }\\nreturn -1;\\n    }\\n}\\ni write this code and it passes 41/45 cases but after that it gives time limit exceed error?\\n"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "hint:use boyer moore voting alogorithm for linear time complexity and O(1) space"
                    },
                    {
                        "username": "Sandesh_Tangade",
                        "content": "I still don\\'t understand why this line?\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "kvm22",
                        "content": "Bruteforce :TLE\\n\\nfor(int i=0;i<nums.size();i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.size();j++){\\n               \\n               if(nums[i]==nums[j])\\n               count++;\\n               \\n            \\n            }\\n            if(count>nums.size()/2)\\n                 return nums[i];\\n           \\n            \\n        }\\n        return -1; "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "eduard92",
                        "content": "Damn I came here from some low submissions problems and I went straight away overthinking this.\\nI assumed off the bat that the array would contain different numbers, not just 2 and I was like what is this n/2 because if we have 3 numbers, that is gonna get messed up.\\n\\nEither way this problem could use a part 2, but then is about counting the frequency of a number I guess."
                    },
                    {
                        "username": "jhaeeshani",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n     int c[1000];\\n     int n = nums.size();\\n     int d ;\\n        for(int i = 0 ;i<n;i++){\\n            int num = nums[i];\\n           { if(nums[i] == num)\\n         c[nums[i]]++;\\n        }\\n        d = max(  c[nums[i]], d);\\n        return nums[i];\\n        \\n        }\\n        return 0;\\n\\n        \\n\\n        \\n    }\\n};\\nCan someone suggest why is this code failing in the 8th test case of 6,5,5 ,the output coming 6.\\nThanks in advance."
                    },
                    {
                        "username": "Pengu_98",
                        "content": "Been grinding leetcode for almost a year. Came up with the Hash Map solution and I have never felt so good.  Consistency is the key my friends !"
                    },
                    {
                        "username": "knazdawid",
                        "content": "HashMap is not O(1) space efficient solution. So not sure why you are happy XD"
                    },
                    {
                        "username": "manuchaitanya17",
                        "content": "for solution nums[nums.length/2]:\\nWhat about this test case: 2,2,1,1,1,2,2,3,3,3,3,3,3,3,2,2,1,1.\\n"
                    }
                ]
            },
            {
                "id": 1779573,
                "content": [
                    {
                        "username": "NaveenKewat",
                        "content": "easy sollution java\\n\\n`class Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        for(int i = 0;i < nums.length;i++){\\n\\n            int count = 0;\\n            for(int j = i;j<nums.length;j++){\\n                if(nums[i] == nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count > nums.length/2){\\n                return nums[i];\\n            }\\n\\n        }\\n        return -1;\\n\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "pritz99",
                        "content": "class Solution {\\n    public int majorityElement(int[] arr) {\\n      LinkedList<Integer> l= new LinkedList();\\n    for(int i=0;i<arr.length;i++) {\\n    \\tl.add(arr[i]);\\n    }\\n    int m=0;\\n    for(int i=0;i<l.size();i++) {\\n    \\tm=  Collections.frequency(l,l.get(i));\\n    \\tif(m>l.size()/2) return l.get(i);\\n    }\\nreturn -1;\\n    }\\n}\\ni write this code and it passes 41/45 cases but after that it gives time limit exceed error?\\n"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "hint:use boyer moore voting alogorithm for linear time complexity and O(1) space"
                    },
                    {
                        "username": "Sandesh_Tangade",
                        "content": "I still don\\'t understand why this line?\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "kvm22",
                        "content": "Bruteforce :TLE\\n\\nfor(int i=0;i<nums.size();i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.size();j++){\\n               \\n               if(nums[i]==nums[j])\\n               count++;\\n               \\n            \\n            }\\n            if(count>nums.size()/2)\\n                 return nums[i];\\n           \\n            \\n        }\\n        return -1; "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "eduard92",
                        "content": "Damn I came here from some low submissions problems and I went straight away overthinking this.\\nI assumed off the bat that the array would contain different numbers, not just 2 and I was like what is this n/2 because if we have 3 numbers, that is gonna get messed up.\\n\\nEither way this problem could use a part 2, but then is about counting the frequency of a number I guess."
                    },
                    {
                        "username": "jhaeeshani",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n     int c[1000];\\n     int n = nums.size();\\n     int d ;\\n        for(int i = 0 ;i<n;i++){\\n            int num = nums[i];\\n           { if(nums[i] == num)\\n         c[nums[i]]++;\\n        }\\n        d = max(  c[nums[i]], d);\\n        return nums[i];\\n        \\n        }\\n        return 0;\\n\\n        \\n\\n        \\n    }\\n};\\nCan someone suggest why is this code failing in the 8th test case of 6,5,5 ,the output coming 6.\\nThanks in advance."
                    },
                    {
                        "username": "Pengu_98",
                        "content": "Been grinding leetcode for almost a year. Came up with the Hash Map solution and I have never felt so good.  Consistency is the key my friends !"
                    },
                    {
                        "username": "knazdawid",
                        "content": "HashMap is not O(1) space efficient solution. So not sure why you are happy XD"
                    },
                    {
                        "username": "manuchaitanya17",
                        "content": "for solution nums[nums.length/2]:\\nWhat about this test case: 2,2,1,1,1,2,2,3,3,3,3,3,3,3,2,2,1,1.\\n"
                    }
                ]
            },
            {
                "id": 1769749,
                "content": [
                    {
                        "username": "NaveenKewat",
                        "content": "easy sollution java\\n\\n`class Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        for(int i = 0;i < nums.length;i++){\\n\\n            int count = 0;\\n            for(int j = i;j<nums.length;j++){\\n                if(nums[i] == nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count > nums.length/2){\\n                return nums[i];\\n            }\\n\\n        }\\n        return -1;\\n\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "pritz99",
                        "content": "class Solution {\\n    public int majorityElement(int[] arr) {\\n      LinkedList<Integer> l= new LinkedList();\\n    for(int i=0;i<arr.length;i++) {\\n    \\tl.add(arr[i]);\\n    }\\n    int m=0;\\n    for(int i=0;i<l.size();i++) {\\n    \\tm=  Collections.frequency(l,l.get(i));\\n    \\tif(m>l.size()/2) return l.get(i);\\n    }\\nreturn -1;\\n    }\\n}\\ni write this code and it passes 41/45 cases but after that it gives time limit exceed error?\\n"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "hint:use boyer moore voting alogorithm for linear time complexity and O(1) space"
                    },
                    {
                        "username": "Sandesh_Tangade",
                        "content": "I still don\\'t understand why this line?\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "kvm22",
                        "content": "Bruteforce :TLE\\n\\nfor(int i=0;i<nums.size();i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.size();j++){\\n               \\n               if(nums[i]==nums[j])\\n               count++;\\n               \\n            \\n            }\\n            if(count>nums.size()/2)\\n                 return nums[i];\\n           \\n            \\n        }\\n        return -1; "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "eduard92",
                        "content": "Damn I came here from some low submissions problems and I went straight away overthinking this.\\nI assumed off the bat that the array would contain different numbers, not just 2 and I was like what is this n/2 because if we have 3 numbers, that is gonna get messed up.\\n\\nEither way this problem could use a part 2, but then is about counting the frequency of a number I guess."
                    },
                    {
                        "username": "jhaeeshani",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n     int c[1000];\\n     int n = nums.size();\\n     int d ;\\n        for(int i = 0 ;i<n;i++){\\n            int num = nums[i];\\n           { if(nums[i] == num)\\n         c[nums[i]]++;\\n        }\\n        d = max(  c[nums[i]], d);\\n        return nums[i];\\n        \\n        }\\n        return 0;\\n\\n        \\n\\n        \\n    }\\n};\\nCan someone suggest why is this code failing in the 8th test case of 6,5,5 ,the output coming 6.\\nThanks in advance."
                    },
                    {
                        "username": "Pengu_98",
                        "content": "Been grinding leetcode for almost a year. Came up with the Hash Map solution and I have never felt so good.  Consistency is the key my friends !"
                    },
                    {
                        "username": "knazdawid",
                        "content": "HashMap is not O(1) space efficient solution. So not sure why you are happy XD"
                    },
                    {
                        "username": "manuchaitanya17",
                        "content": "for solution nums[nums.length/2]:\\nWhat about this test case: 2,2,1,1,1,2,2,3,3,3,3,3,3,3,2,2,1,1.\\n"
                    }
                ]
            },
            {
                "id": 1762573,
                "content": [
                    {
                        "username": "NaveenKewat",
                        "content": "easy sollution java\\n\\n`class Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        for(int i = 0;i < nums.length;i++){\\n\\n            int count = 0;\\n            for(int j = i;j<nums.length;j++){\\n                if(nums[i] == nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count > nums.length/2){\\n                return nums[i];\\n            }\\n\\n        }\\n        return -1;\\n\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "pritz99",
                        "content": "class Solution {\\n    public int majorityElement(int[] arr) {\\n      LinkedList<Integer> l= new LinkedList();\\n    for(int i=0;i<arr.length;i++) {\\n    \\tl.add(arr[i]);\\n    }\\n    int m=0;\\n    for(int i=0;i<l.size();i++) {\\n    \\tm=  Collections.frequency(l,l.get(i));\\n    \\tif(m>l.size()/2) return l.get(i);\\n    }\\nreturn -1;\\n    }\\n}\\ni write this code and it passes 41/45 cases but after that it gives time limit exceed error?\\n"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "hint:use boyer moore voting alogorithm for linear time complexity and O(1) space"
                    },
                    {
                        "username": "Sandesh_Tangade",
                        "content": "I still don\\'t understand why this line?\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "kvm22",
                        "content": "Bruteforce :TLE\\n\\nfor(int i=0;i<nums.size();i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.size();j++){\\n               \\n               if(nums[i]==nums[j])\\n               count++;\\n               \\n            \\n            }\\n            if(count>nums.size()/2)\\n                 return nums[i];\\n           \\n            \\n        }\\n        return -1; "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "eduard92",
                        "content": "Damn I came here from some low submissions problems and I went straight away overthinking this.\\nI assumed off the bat that the array would contain different numbers, not just 2 and I was like what is this n/2 because if we have 3 numbers, that is gonna get messed up.\\n\\nEither way this problem could use a part 2, but then is about counting the frequency of a number I guess."
                    },
                    {
                        "username": "jhaeeshani",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n     int c[1000];\\n     int n = nums.size();\\n     int d ;\\n        for(int i = 0 ;i<n;i++){\\n            int num = nums[i];\\n           { if(nums[i] == num)\\n         c[nums[i]]++;\\n        }\\n        d = max(  c[nums[i]], d);\\n        return nums[i];\\n        \\n        }\\n        return 0;\\n\\n        \\n\\n        \\n    }\\n};\\nCan someone suggest why is this code failing in the 8th test case of 6,5,5 ,the output coming 6.\\nThanks in advance."
                    },
                    {
                        "username": "Pengu_98",
                        "content": "Been grinding leetcode for almost a year. Came up with the Hash Map solution and I have never felt so good.  Consistency is the key my friends !"
                    },
                    {
                        "username": "knazdawid",
                        "content": "HashMap is not O(1) space efficient solution. So not sure why you are happy XD"
                    },
                    {
                        "username": "manuchaitanya17",
                        "content": "for solution nums[nums.length/2]:\\nWhat about this test case: 2,2,1,1,1,2,2,3,3,3,3,3,3,3,2,2,1,1.\\n"
                    }
                ]
            },
            {
                "id": 1760650,
                "content": [
                    {
                        "username": "NaveenKewat",
                        "content": "easy sollution java\\n\\n`class Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        for(int i = 0;i < nums.length;i++){\\n\\n            int count = 0;\\n            for(int j = i;j<nums.length;j++){\\n                if(nums[i] == nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count > nums.length/2){\\n                return nums[i];\\n            }\\n\\n        }\\n        return -1;\\n\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "pritz99",
                        "content": "class Solution {\\n    public int majorityElement(int[] arr) {\\n      LinkedList<Integer> l= new LinkedList();\\n    for(int i=0;i<arr.length;i++) {\\n    \\tl.add(arr[i]);\\n    }\\n    int m=0;\\n    for(int i=0;i<l.size();i++) {\\n    \\tm=  Collections.frequency(l,l.get(i));\\n    \\tif(m>l.size()/2) return l.get(i);\\n    }\\nreturn -1;\\n    }\\n}\\ni write this code and it passes 41/45 cases but after that it gives time limit exceed error?\\n"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "hint:use boyer moore voting alogorithm for linear time complexity and O(1) space"
                    },
                    {
                        "username": "Sandesh_Tangade",
                        "content": "I still don\\'t understand why this line?\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "kvm22",
                        "content": "Bruteforce :TLE\\n\\nfor(int i=0;i<nums.size();i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.size();j++){\\n               \\n               if(nums[i]==nums[j])\\n               count++;\\n               \\n            \\n            }\\n            if(count>nums.size()/2)\\n                 return nums[i];\\n           \\n            \\n        }\\n        return -1; "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "eduard92",
                        "content": "Damn I came here from some low submissions problems and I went straight away overthinking this.\\nI assumed off the bat that the array would contain different numbers, not just 2 and I was like what is this n/2 because if we have 3 numbers, that is gonna get messed up.\\n\\nEither way this problem could use a part 2, but then is about counting the frequency of a number I guess."
                    },
                    {
                        "username": "jhaeeshani",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n     int c[1000];\\n     int n = nums.size();\\n     int d ;\\n        for(int i = 0 ;i<n;i++){\\n            int num = nums[i];\\n           { if(nums[i] == num)\\n         c[nums[i]]++;\\n        }\\n        d = max(  c[nums[i]], d);\\n        return nums[i];\\n        \\n        }\\n        return 0;\\n\\n        \\n\\n        \\n    }\\n};\\nCan someone suggest why is this code failing in the 8th test case of 6,5,5 ,the output coming 6.\\nThanks in advance."
                    },
                    {
                        "username": "Pengu_98",
                        "content": "Been grinding leetcode for almost a year. Came up with the Hash Map solution and I have never felt so good.  Consistency is the key my friends !"
                    },
                    {
                        "username": "knazdawid",
                        "content": "HashMap is not O(1) space efficient solution. So not sure why you are happy XD"
                    },
                    {
                        "username": "manuchaitanya17",
                        "content": "for solution nums[nums.length/2]:\\nWhat about this test case: 2,2,1,1,1,2,2,3,3,3,3,3,3,3,2,2,1,1.\\n"
                    }
                ]
            },
            {
                "id": 1760397,
                "content": [
                    {
                        "username": "NaveenKewat",
                        "content": "easy sollution java\\n\\n`class Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        for(int i = 0;i < nums.length;i++){\\n\\n            int count = 0;\\n            for(int j = i;j<nums.length;j++){\\n                if(nums[i] == nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count > nums.length/2){\\n                return nums[i];\\n            }\\n\\n        }\\n        return -1;\\n\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "pritz99",
                        "content": "class Solution {\\n    public int majorityElement(int[] arr) {\\n      LinkedList<Integer> l= new LinkedList();\\n    for(int i=0;i<arr.length;i++) {\\n    \\tl.add(arr[i]);\\n    }\\n    int m=0;\\n    for(int i=0;i<l.size();i++) {\\n    \\tm=  Collections.frequency(l,l.get(i));\\n    \\tif(m>l.size()/2) return l.get(i);\\n    }\\nreturn -1;\\n    }\\n}\\ni write this code and it passes 41/45 cases but after that it gives time limit exceed error?\\n"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "hint:use boyer moore voting alogorithm for linear time complexity and O(1) space"
                    },
                    {
                        "username": "Sandesh_Tangade",
                        "content": "I still don\\'t understand why this line?\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "kvm22",
                        "content": "Bruteforce :TLE\\n\\nfor(int i=0;i<nums.size();i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.size();j++){\\n               \\n               if(nums[i]==nums[j])\\n               count++;\\n               \\n            \\n            }\\n            if(count>nums.size()/2)\\n                 return nums[i];\\n           \\n            \\n        }\\n        return -1; "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "eduard92",
                        "content": "Damn I came here from some low submissions problems and I went straight away overthinking this.\\nI assumed off the bat that the array would contain different numbers, not just 2 and I was like what is this n/2 because if we have 3 numbers, that is gonna get messed up.\\n\\nEither way this problem could use a part 2, but then is about counting the frequency of a number I guess."
                    },
                    {
                        "username": "jhaeeshani",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n     int c[1000];\\n     int n = nums.size();\\n     int d ;\\n        for(int i = 0 ;i<n;i++){\\n            int num = nums[i];\\n           { if(nums[i] == num)\\n         c[nums[i]]++;\\n        }\\n        d = max(  c[nums[i]], d);\\n        return nums[i];\\n        \\n        }\\n        return 0;\\n\\n        \\n\\n        \\n    }\\n};\\nCan someone suggest why is this code failing in the 8th test case of 6,5,5 ,the output coming 6.\\nThanks in advance."
                    },
                    {
                        "username": "Pengu_98",
                        "content": "Been grinding leetcode for almost a year. Came up with the Hash Map solution and I have never felt so good.  Consistency is the key my friends !"
                    },
                    {
                        "username": "knazdawid",
                        "content": "HashMap is not O(1) space efficient solution. So not sure why you are happy XD"
                    },
                    {
                        "username": "manuchaitanya17",
                        "content": "for solution nums[nums.length/2]:\\nWhat about this test case: 2,2,1,1,1,2,2,3,3,3,3,3,3,3,2,2,1,1.\\n"
                    }
                ]
            },
            {
                "id": 1760303,
                "content": [
                    {
                        "username": "NaveenKewat",
                        "content": "easy sollution java\\n\\n`class Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        for(int i = 0;i < nums.length;i++){\\n\\n            int count = 0;\\n            for(int j = i;j<nums.length;j++){\\n                if(nums[i] == nums[j]){\\n                    count++;\\n                }\\n            }\\n            if(count > nums.length/2){\\n                return nums[i];\\n            }\\n\\n        }\\n        return -1;\\n\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "pritz99",
                        "content": "class Solution {\\n    public int majorityElement(int[] arr) {\\n      LinkedList<Integer> l= new LinkedList();\\n    for(int i=0;i<arr.length;i++) {\\n    \\tl.add(arr[i]);\\n    }\\n    int m=0;\\n    for(int i=0;i<l.size();i++) {\\n    \\tm=  Collections.frequency(l,l.get(i));\\n    \\tif(m>l.size()/2) return l.get(i);\\n    }\\nreturn -1;\\n    }\\n}\\ni write this code and it passes 41/45 cases but after that it gives time limit exceed error?\\n"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "hint:use boyer moore voting alogorithm for linear time complexity and O(1) space"
                    },
                    {
                        "username": "Sandesh_Tangade",
                        "content": "I still don\\'t understand why this line?\\nreturn nums[nums.length/2];"
                    },
                    {
                        "username": "kvm22",
                        "content": "Bruteforce :TLE\\n\\nfor(int i=0;i<nums.size();i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.size();j++){\\n               \\n               if(nums[i]==nums[j])\\n               count++;\\n               \\n            \\n            }\\n            if(count>nums.size()/2)\\n                 return nums[i];\\n           \\n            \\n        }\\n        return -1; "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "eduard92",
                        "content": "Damn I came here from some low submissions problems and I went straight away overthinking this.\\nI assumed off the bat that the array would contain different numbers, not just 2 and I was like what is this n/2 because if we have 3 numbers, that is gonna get messed up.\\n\\nEither way this problem could use a part 2, but then is about counting the frequency of a number I guess."
                    },
                    {
                        "username": "jhaeeshani",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n     int c[1000];\\n     int n = nums.size();\\n     int d ;\\n        for(int i = 0 ;i<n;i++){\\n            int num = nums[i];\\n           { if(nums[i] == num)\\n         c[nums[i]]++;\\n        }\\n        d = max(  c[nums[i]], d);\\n        return nums[i];\\n        \\n        }\\n        return 0;\\n\\n        \\n\\n        \\n    }\\n};\\nCan someone suggest why is this code failing in the 8th test case of 6,5,5 ,the output coming 6.\\nThanks in advance."
                    },
                    {
                        "username": "Pengu_98",
                        "content": "Been grinding leetcode for almost a year. Came up with the Hash Map solution and I have never felt so good.  Consistency is the key my friends !"
                    },
                    {
                        "username": "knazdawid",
                        "content": "HashMap is not O(1) space efficient solution. So not sure why you are happy XD"
                    },
                    {
                        "username": "manuchaitanya17",
                        "content": "for solution nums[nums.length/2]:\\nWhat about this test case: 2,2,1,1,1,2,2,3,3,3,3,3,3,3,2,2,1,1.\\n"
                    }
                ]
            },
            {
                "id": 1756384,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "savy07",
                        "content": "1> First sort the array;\n2> Just you have to print the array value of N(array length) / 2 .\n3> Hit the submitt button."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "moore\\'s voting algorithm"
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "// Is it correct? \\n#include<bits/stdc++.h>\\nusing namespace std;\\nint majority(int arr[],int n)\\n{\\n\\tif(n==1)\\n\\t{\\n\\t\\treturn arr[0];\\n\\t}\\n\\tsort(arr,arr+n);\\n\\tint i,count=0;\\n\\tfor(i=1;i<n;i++)\\n\\t{\\n\\t\\tif(arr[i-1]==arr[i])\\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(count>n/2)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn arr[i-1];\\n\\t\\t\\t\\t//count=1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\nint main()\\n{\\n\\tint arr[]={2,3,1,2,3,2,2,2,1,2};\\n\\tint n=sizeof(arr)/sizeof(arr[0]);\\n\\tcout<<majority(arr,n);\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "try and find-out :)"
                    },
                    {
                        "username": "ajaygs1998",
                        "content": "by using the  moore\\'s voting algorithm \\ntime complexity becomes O(n).\\n "
                    },
                    {
                        "username": "luongminhduy",
                        "content": "The array has only two type of elements."
                    },
                    {
                        "username": "harshitchodvadiya",
                        "content": "sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        return nums[n/2];"
                    },
                    {
                        "username": "abhinav200",
                        "content": "Can anyone help me understanding this test case\\n[1,2,3,1]\\n\\nit is failing for this TC for Boyer-Moore Voting Algorithm."
                    },
                    {
                        "username": "saurabhguptabsva",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        //if majority element comes more than n/2 then the middle element of a sorted array is the majority element. \\n        //time complexity - O(nlogn)\\n        //space complexity - O(1)\\n        sort(nums.begin(), nums.end());\\n        return nums[nums.size()/2];\\n    }\\n};"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "\\'\\'\\'class Solution {\\n    public int majorityElement(int[] nums) {\\n        \\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i]))\\n               map.put(nums[i],map.get(nums[i])+1);\\n            else\\n               map.put(nums[i],1);\\n        }\\n        int ans=0;\\n        for(int key:map.keySet()){\\n            if(map.get(key)>nums.length/2){\\n                ans=key;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1753999,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "savy07",
                        "content": "1> First sort the array;\n2> Just you have to print the array value of N(array length) / 2 .\n3> Hit the submitt button."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "moore\\'s voting algorithm"
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "// Is it correct? \\n#include<bits/stdc++.h>\\nusing namespace std;\\nint majority(int arr[],int n)\\n{\\n\\tif(n==1)\\n\\t{\\n\\t\\treturn arr[0];\\n\\t}\\n\\tsort(arr,arr+n);\\n\\tint i,count=0;\\n\\tfor(i=1;i<n;i++)\\n\\t{\\n\\t\\tif(arr[i-1]==arr[i])\\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(count>n/2)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn arr[i-1];\\n\\t\\t\\t\\t//count=1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\nint main()\\n{\\n\\tint arr[]={2,3,1,2,3,2,2,2,1,2};\\n\\tint n=sizeof(arr)/sizeof(arr[0]);\\n\\tcout<<majority(arr,n);\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "try and find-out :)"
                    },
                    {
                        "username": "ajaygs1998",
                        "content": "by using the  moore\\'s voting algorithm \\ntime complexity becomes O(n).\\n "
                    },
                    {
                        "username": "luongminhduy",
                        "content": "The array has only two type of elements."
                    },
                    {
                        "username": "harshitchodvadiya",
                        "content": "sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        return nums[n/2];"
                    },
                    {
                        "username": "abhinav200",
                        "content": "Can anyone help me understanding this test case\\n[1,2,3,1]\\n\\nit is failing for this TC for Boyer-Moore Voting Algorithm."
                    },
                    {
                        "username": "saurabhguptabsva",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        //if majority element comes more than n/2 then the middle element of a sorted array is the majority element. \\n        //time complexity - O(nlogn)\\n        //space complexity - O(1)\\n        sort(nums.begin(), nums.end());\\n        return nums[nums.size()/2];\\n    }\\n};"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "\\'\\'\\'class Solution {\\n    public int majorityElement(int[] nums) {\\n        \\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i]))\\n               map.put(nums[i],map.get(nums[i])+1);\\n            else\\n               map.put(nums[i],1);\\n        }\\n        int ans=0;\\n        for(int key:map.keySet()){\\n            if(map.get(key)>nums.length/2){\\n                ans=key;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1746700,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "savy07",
                        "content": "1> First sort the array;\n2> Just you have to print the array value of N(array length) / 2 .\n3> Hit the submitt button."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "moore\\'s voting algorithm"
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "// Is it correct? \\n#include<bits/stdc++.h>\\nusing namespace std;\\nint majority(int arr[],int n)\\n{\\n\\tif(n==1)\\n\\t{\\n\\t\\treturn arr[0];\\n\\t}\\n\\tsort(arr,arr+n);\\n\\tint i,count=0;\\n\\tfor(i=1;i<n;i++)\\n\\t{\\n\\t\\tif(arr[i-1]==arr[i])\\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(count>n/2)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn arr[i-1];\\n\\t\\t\\t\\t//count=1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\nint main()\\n{\\n\\tint arr[]={2,3,1,2,3,2,2,2,1,2};\\n\\tint n=sizeof(arr)/sizeof(arr[0]);\\n\\tcout<<majority(arr,n);\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "try and find-out :)"
                    },
                    {
                        "username": "ajaygs1998",
                        "content": "by using the  moore\\'s voting algorithm \\ntime complexity becomes O(n).\\n "
                    },
                    {
                        "username": "luongminhduy",
                        "content": "The array has only two type of elements."
                    },
                    {
                        "username": "harshitchodvadiya",
                        "content": "sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        return nums[n/2];"
                    },
                    {
                        "username": "abhinav200",
                        "content": "Can anyone help me understanding this test case\\n[1,2,3,1]\\n\\nit is failing for this TC for Boyer-Moore Voting Algorithm."
                    },
                    {
                        "username": "saurabhguptabsva",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        //if majority element comes more than n/2 then the middle element of a sorted array is the majority element. \\n        //time complexity - O(nlogn)\\n        //space complexity - O(1)\\n        sort(nums.begin(), nums.end());\\n        return nums[nums.size()/2];\\n    }\\n};"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "\\'\\'\\'class Solution {\\n    public int majorityElement(int[] nums) {\\n        \\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i]))\\n               map.put(nums[i],map.get(nums[i])+1);\\n            else\\n               map.put(nums[i],1);\\n        }\\n        int ans=0;\\n        for(int key:map.keySet()){\\n            if(map.get(key)>nums.length/2){\\n                ans=key;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1740414,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "savy07",
                        "content": "1> First sort the array;\n2> Just you have to print the array value of N(array length) / 2 .\n3> Hit the submitt button."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "moore\\'s voting algorithm"
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "// Is it correct? \\n#include<bits/stdc++.h>\\nusing namespace std;\\nint majority(int arr[],int n)\\n{\\n\\tif(n==1)\\n\\t{\\n\\t\\treturn arr[0];\\n\\t}\\n\\tsort(arr,arr+n);\\n\\tint i,count=0;\\n\\tfor(i=1;i<n;i++)\\n\\t{\\n\\t\\tif(arr[i-1]==arr[i])\\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(count>n/2)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn arr[i-1];\\n\\t\\t\\t\\t//count=1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\nint main()\\n{\\n\\tint arr[]={2,3,1,2,3,2,2,2,1,2};\\n\\tint n=sizeof(arr)/sizeof(arr[0]);\\n\\tcout<<majority(arr,n);\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "try and find-out :)"
                    },
                    {
                        "username": "ajaygs1998",
                        "content": "by using the  moore\\'s voting algorithm \\ntime complexity becomes O(n).\\n "
                    },
                    {
                        "username": "luongminhduy",
                        "content": "The array has only two type of elements."
                    },
                    {
                        "username": "harshitchodvadiya",
                        "content": "sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        return nums[n/2];"
                    },
                    {
                        "username": "abhinav200",
                        "content": "Can anyone help me understanding this test case\\n[1,2,3,1]\\n\\nit is failing for this TC for Boyer-Moore Voting Algorithm."
                    },
                    {
                        "username": "saurabhguptabsva",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        //if majority element comes more than n/2 then the middle element of a sorted array is the majority element. \\n        //time complexity - O(nlogn)\\n        //space complexity - O(1)\\n        sort(nums.begin(), nums.end());\\n        return nums[nums.size()/2];\\n    }\\n};"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "\\'\\'\\'class Solution {\\n    public int majorityElement(int[] nums) {\\n        \\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i]))\\n               map.put(nums[i],map.get(nums[i])+1);\\n            else\\n               map.put(nums[i],1);\\n        }\\n        int ans=0;\\n        for(int key:map.keySet()){\\n            if(map.get(key)>nums.length/2){\\n                ans=key;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1739432,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "savy07",
                        "content": "1> First sort the array;\n2> Just you have to print the array value of N(array length) / 2 .\n3> Hit the submitt button."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "moore\\'s voting algorithm"
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "// Is it correct? \\n#include<bits/stdc++.h>\\nusing namespace std;\\nint majority(int arr[],int n)\\n{\\n\\tif(n==1)\\n\\t{\\n\\t\\treturn arr[0];\\n\\t}\\n\\tsort(arr,arr+n);\\n\\tint i,count=0;\\n\\tfor(i=1;i<n;i++)\\n\\t{\\n\\t\\tif(arr[i-1]==arr[i])\\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(count>n/2)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn arr[i-1];\\n\\t\\t\\t\\t//count=1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\nint main()\\n{\\n\\tint arr[]={2,3,1,2,3,2,2,2,1,2};\\n\\tint n=sizeof(arr)/sizeof(arr[0]);\\n\\tcout<<majority(arr,n);\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "try and find-out :)"
                    },
                    {
                        "username": "ajaygs1998",
                        "content": "by using the  moore\\'s voting algorithm \\ntime complexity becomes O(n).\\n "
                    },
                    {
                        "username": "luongminhduy",
                        "content": "The array has only two type of elements."
                    },
                    {
                        "username": "harshitchodvadiya",
                        "content": "sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        return nums[n/2];"
                    },
                    {
                        "username": "abhinav200",
                        "content": "Can anyone help me understanding this test case\\n[1,2,3,1]\\n\\nit is failing for this TC for Boyer-Moore Voting Algorithm."
                    },
                    {
                        "username": "saurabhguptabsva",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        //if majority element comes more than n/2 then the middle element of a sorted array is the majority element. \\n        //time complexity - O(nlogn)\\n        //space complexity - O(1)\\n        sort(nums.begin(), nums.end());\\n        return nums[nums.size()/2];\\n    }\\n};"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "\\'\\'\\'class Solution {\\n    public int majorityElement(int[] nums) {\\n        \\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i]))\\n               map.put(nums[i],map.get(nums[i])+1);\\n            else\\n               map.put(nums[i],1);\\n        }\\n        int ans=0;\\n        for(int key:map.keySet()){\\n            if(map.get(key)>nums.length/2){\\n                ans=key;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1737523,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "savy07",
                        "content": "1> First sort the array;\n2> Just you have to print the array value of N(array length) / 2 .\n3> Hit the submitt button."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "moore\\'s voting algorithm"
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "// Is it correct? \\n#include<bits/stdc++.h>\\nusing namespace std;\\nint majority(int arr[],int n)\\n{\\n\\tif(n==1)\\n\\t{\\n\\t\\treturn arr[0];\\n\\t}\\n\\tsort(arr,arr+n);\\n\\tint i,count=0;\\n\\tfor(i=1;i<n;i++)\\n\\t{\\n\\t\\tif(arr[i-1]==arr[i])\\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(count>n/2)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn arr[i-1];\\n\\t\\t\\t\\t//count=1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\nint main()\\n{\\n\\tint arr[]={2,3,1,2,3,2,2,2,1,2};\\n\\tint n=sizeof(arr)/sizeof(arr[0]);\\n\\tcout<<majority(arr,n);\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "try and find-out :)"
                    },
                    {
                        "username": "ajaygs1998",
                        "content": "by using the  moore\\'s voting algorithm \\ntime complexity becomes O(n).\\n "
                    },
                    {
                        "username": "luongminhduy",
                        "content": "The array has only two type of elements."
                    },
                    {
                        "username": "harshitchodvadiya",
                        "content": "sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        return nums[n/2];"
                    },
                    {
                        "username": "abhinav200",
                        "content": "Can anyone help me understanding this test case\\n[1,2,3,1]\\n\\nit is failing for this TC for Boyer-Moore Voting Algorithm."
                    },
                    {
                        "username": "saurabhguptabsva",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        //if majority element comes more than n/2 then the middle element of a sorted array is the majority element. \\n        //time complexity - O(nlogn)\\n        //space complexity - O(1)\\n        sort(nums.begin(), nums.end());\\n        return nums[nums.size()/2];\\n    }\\n};"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "\\'\\'\\'class Solution {\\n    public int majorityElement(int[] nums) {\\n        \\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i]))\\n               map.put(nums[i],map.get(nums[i])+1);\\n            else\\n               map.put(nums[i],1);\\n        }\\n        int ans=0;\\n        for(int key:map.keySet()){\\n            if(map.get(key)>nums.length/2){\\n                ans=key;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1730120,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "savy07",
                        "content": "1> First sort the array;\n2> Just you have to print the array value of N(array length) / 2 .\n3> Hit the submitt button."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "moore\\'s voting algorithm"
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "// Is it correct? \\n#include<bits/stdc++.h>\\nusing namespace std;\\nint majority(int arr[],int n)\\n{\\n\\tif(n==1)\\n\\t{\\n\\t\\treturn arr[0];\\n\\t}\\n\\tsort(arr,arr+n);\\n\\tint i,count=0;\\n\\tfor(i=1;i<n;i++)\\n\\t{\\n\\t\\tif(arr[i-1]==arr[i])\\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(count>n/2)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn arr[i-1];\\n\\t\\t\\t\\t//count=1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\nint main()\\n{\\n\\tint arr[]={2,3,1,2,3,2,2,2,1,2};\\n\\tint n=sizeof(arr)/sizeof(arr[0]);\\n\\tcout<<majority(arr,n);\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "try and find-out :)"
                    },
                    {
                        "username": "ajaygs1998",
                        "content": "by using the  moore\\'s voting algorithm \\ntime complexity becomes O(n).\\n "
                    },
                    {
                        "username": "luongminhduy",
                        "content": "The array has only two type of elements."
                    },
                    {
                        "username": "harshitchodvadiya",
                        "content": "sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        return nums[n/2];"
                    },
                    {
                        "username": "abhinav200",
                        "content": "Can anyone help me understanding this test case\\n[1,2,3,1]\\n\\nit is failing for this TC for Boyer-Moore Voting Algorithm."
                    },
                    {
                        "username": "saurabhguptabsva",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        //if majority element comes more than n/2 then the middle element of a sorted array is the majority element. \\n        //time complexity - O(nlogn)\\n        //space complexity - O(1)\\n        sort(nums.begin(), nums.end());\\n        return nums[nums.size()/2];\\n    }\\n};"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "\\'\\'\\'class Solution {\\n    public int majorityElement(int[] nums) {\\n        \\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i]))\\n               map.put(nums[i],map.get(nums[i])+1);\\n            else\\n               map.put(nums[i],1);\\n        }\\n        int ans=0;\\n        for(int key:map.keySet()){\\n            if(map.get(key)>nums.length/2){\\n                ans=key;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1729769,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "savy07",
                        "content": "1> First sort the array;\n2> Just you have to print the array value of N(array length) / 2 .\n3> Hit the submitt button."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "moore\\'s voting algorithm"
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "// Is it correct? \\n#include<bits/stdc++.h>\\nusing namespace std;\\nint majority(int arr[],int n)\\n{\\n\\tif(n==1)\\n\\t{\\n\\t\\treturn arr[0];\\n\\t}\\n\\tsort(arr,arr+n);\\n\\tint i,count=0;\\n\\tfor(i=1;i<n;i++)\\n\\t{\\n\\t\\tif(arr[i-1]==arr[i])\\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(count>n/2)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn arr[i-1];\\n\\t\\t\\t\\t//count=1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\nint main()\\n{\\n\\tint arr[]={2,3,1,2,3,2,2,2,1,2};\\n\\tint n=sizeof(arr)/sizeof(arr[0]);\\n\\tcout<<majority(arr,n);\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "try and find-out :)"
                    },
                    {
                        "username": "ajaygs1998",
                        "content": "by using the  moore\\'s voting algorithm \\ntime complexity becomes O(n).\\n "
                    },
                    {
                        "username": "luongminhduy",
                        "content": "The array has only two type of elements."
                    },
                    {
                        "username": "harshitchodvadiya",
                        "content": "sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        return nums[n/2];"
                    },
                    {
                        "username": "abhinav200",
                        "content": "Can anyone help me understanding this test case\\n[1,2,3,1]\\n\\nit is failing for this TC for Boyer-Moore Voting Algorithm."
                    },
                    {
                        "username": "saurabhguptabsva",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        //if majority element comes more than n/2 then the middle element of a sorted array is the majority element. \\n        //time complexity - O(nlogn)\\n        //space complexity - O(1)\\n        sort(nums.begin(), nums.end());\\n        return nums[nums.size()/2];\\n    }\\n};"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "\\'\\'\\'class Solution {\\n    public int majorityElement(int[] nums) {\\n        \\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i]))\\n               map.put(nums[i],map.get(nums[i])+1);\\n            else\\n               map.put(nums[i],1);\\n        }\\n        int ans=0;\\n        for(int key:map.keySet()){\\n            if(map.get(key)>nums.length/2){\\n                ans=key;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1729447,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "savy07",
                        "content": "1> First sort the array;\n2> Just you have to print the array value of N(array length) / 2 .\n3> Hit the submitt button."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "moore\\'s voting algorithm"
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "// Is it correct? \\n#include<bits/stdc++.h>\\nusing namespace std;\\nint majority(int arr[],int n)\\n{\\n\\tif(n==1)\\n\\t{\\n\\t\\treturn arr[0];\\n\\t}\\n\\tsort(arr,arr+n);\\n\\tint i,count=0;\\n\\tfor(i=1;i<n;i++)\\n\\t{\\n\\t\\tif(arr[i-1]==arr[i])\\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(count>n/2)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn arr[i-1];\\n\\t\\t\\t\\t//count=1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\nint main()\\n{\\n\\tint arr[]={2,3,1,2,3,2,2,2,1,2};\\n\\tint n=sizeof(arr)/sizeof(arr[0]);\\n\\tcout<<majority(arr,n);\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "try and find-out :)"
                    },
                    {
                        "username": "ajaygs1998",
                        "content": "by using the  moore\\'s voting algorithm \\ntime complexity becomes O(n).\\n "
                    },
                    {
                        "username": "luongminhduy",
                        "content": "The array has only two type of elements."
                    },
                    {
                        "username": "harshitchodvadiya",
                        "content": "sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        return nums[n/2];"
                    },
                    {
                        "username": "abhinav200",
                        "content": "Can anyone help me understanding this test case\\n[1,2,3,1]\\n\\nit is failing for this TC for Boyer-Moore Voting Algorithm."
                    },
                    {
                        "username": "saurabhguptabsva",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        //if majority element comes more than n/2 then the middle element of a sorted array is the majority element. \\n        //time complexity - O(nlogn)\\n        //space complexity - O(1)\\n        sort(nums.begin(), nums.end());\\n        return nums[nums.size()/2];\\n    }\\n};"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "\\'\\'\\'class Solution {\\n    public int majorityElement(int[] nums) {\\n        \\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i]))\\n               map.put(nums[i],map.get(nums[i])+1);\\n            else\\n               map.put(nums[i],1);\\n        }\\n        int ans=0;\\n        for(int key:map.keySet()){\\n            if(map.get(key)>nums.length/2){\\n                ans=key;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1725374,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "savy07",
                        "content": "1> First sort the array;\n2> Just you have to print the array value of N(array length) / 2 .\n3> Hit the submitt button."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "moore\\'s voting algorithm"
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "// Is it correct? \\n#include<bits/stdc++.h>\\nusing namespace std;\\nint majority(int arr[],int n)\\n{\\n\\tif(n==1)\\n\\t{\\n\\t\\treturn arr[0];\\n\\t}\\n\\tsort(arr,arr+n);\\n\\tint i,count=0;\\n\\tfor(i=1;i<n;i++)\\n\\t{\\n\\t\\tif(arr[i-1]==arr[i])\\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tif(count>n/2)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn arr[i-1];\\n\\t\\t\\t\\t//count=1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\nint main()\\n{\\n\\tint arr[]={2,3,1,2,3,2,2,2,1,2};\\n\\tint n=sizeof(arr)/sizeof(arr[0]);\\n\\tcout<<majority(arr,n);\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "try and find-out :)"
                    },
                    {
                        "username": "ajaygs1998",
                        "content": "by using the  moore\\'s voting algorithm \\ntime complexity becomes O(n).\\n "
                    },
                    {
                        "username": "luongminhduy",
                        "content": "The array has only two type of elements."
                    },
                    {
                        "username": "harshitchodvadiya",
                        "content": "sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        return nums[n/2];"
                    },
                    {
                        "username": "abhinav200",
                        "content": "Can anyone help me understanding this test case\\n[1,2,3,1]\\n\\nit is failing for this TC for Boyer-Moore Voting Algorithm."
                    },
                    {
                        "username": "saurabhguptabsva",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        //if majority element comes more than n/2 then the middle element of a sorted array is the majority element. \\n        //time complexity - O(nlogn)\\n        //space complexity - O(1)\\n        sort(nums.begin(), nums.end());\\n        return nums[nums.size()/2];\\n    }\\n};"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "\\'\\'\\'class Solution {\\n    public int majorityElement(int[] nums) {\\n        \\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i]))\\n               map.put(nums[i],map.get(nums[i])+1);\\n            else\\n               map.put(nums[i],1);\\n        }\\n        int ans=0;\\n        for(int key:map.keySet()){\\n            if(map.get(key)>nums.length/2){\\n                ans=key;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1725199,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "My Two ways to solve this problem:\n1) O(1) space ......sort the given array and check count of each element using loop, if its greater than n/2, break loop and return its value, else keep on checking.\n\n\n2) this will take O(n) space... Use unordered map. (4 line code)\n// unordered_map<int,int>m;\n        // for(auto a:nums)m[a]++;               \n        // for(auto a:m)if(a.second>n) return a.first;\n        // return -1;\n"
                    },
                    {
                        "username": "yash_eth",
                        "content": "2 line easy....\\n1. sort the array.\\n2. return the middle element.\\ndone\\n\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        Arrays.sort(nums);\\n\\n        return nums[(nums.length-1)/2];\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "Hello everyone, do I understand the increment here as a frequency count?\\n\\n```\\nfor(const auto &i:nums)\\n           map[i]++;\\n```"
                    },
                    {
                        "username": "ravi3018",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(Integer ele:nums){\\n            map.put(ele,map.getOrDefault(ele,0)+1);\\n        }\\n        int maxCount=0;\\n        int ans = 0;\\n        for(Map.Entry<Integer,Integer> ele : map.entrySet()){\\n            if(ele.getValue()>=maxCount){\\n                ans = ele.getKey();\\n                maxCount = ele.getValue();\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Khushboo2525",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>v\\n        \\n        \\n        (n);\\n        map<int,int>f;\\n        for(int i=1;i<=n;i++){\\n            \\n             f[nums[i]]++;\\n        }\\n        int maxii=0;\\n        long long ans=0;\\n        for(auto it :f){\\n            long long x=it.first;\\n            v.push_back(x);\\n            \\n        }\\n        return v[v.size()-1];\\n        \\n    }\\n};\\nwhy this is giving runtime error???"
                    },
                    {
                        "username": "shank9931",
                        "content": "no matching constructor for initialization of \\'vector<int>\\'\\n\\nwhy do I get this error?"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int count =0;\\n        int major = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(count==0){\\n                major = nums[i];\\n            }\\n            if(major == nums[i]){\\n                count++;\\n            }\\n            else{\\n                count -=1;\\n            }\\n\\n        }\\n        return major;\\n    }\\n};"
                    },
                    {
                        "username": "user3262F",
                        "content": "In this constraint what is the meaning of.\\nn == nums.length\\n\\nCould any one can explain?"
                    },
                    {
                        "username": "nguyej16",
                        "content": "n is equal to the number of elements within the nums array"
                    },
                    {
                        "username": "305057174a",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n       return max(nums,key=nums.count)\\n\\nwhy wrong?????"
                    },
                    {
                        "username": "tongalexhe",
                        "content": " class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int st = nums.size()/2;\\n        for(auto i : nums)\\n        {\\n            mp[i]++;\\n            if(mp[i]>st)\\n                return i;\\n        }\\n        return 0;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1723842,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "My Two ways to solve this problem:\n1) O(1) space ......sort the given array and check count of each element using loop, if its greater than n/2, break loop and return its value, else keep on checking.\n\n\n2) this will take O(n) space... Use unordered map. (4 line code)\n// unordered_map<int,int>m;\n        // for(auto a:nums)m[a]++;               \n        // for(auto a:m)if(a.second>n) return a.first;\n        // return -1;\n"
                    },
                    {
                        "username": "yash_eth",
                        "content": "2 line easy....\\n1. sort the array.\\n2. return the middle element.\\ndone\\n\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        Arrays.sort(nums);\\n\\n        return nums[(nums.length-1)/2];\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "Hello everyone, do I understand the increment here as a frequency count?\\n\\n```\\nfor(const auto &i:nums)\\n           map[i]++;\\n```"
                    },
                    {
                        "username": "ravi3018",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(Integer ele:nums){\\n            map.put(ele,map.getOrDefault(ele,0)+1);\\n        }\\n        int maxCount=0;\\n        int ans = 0;\\n        for(Map.Entry<Integer,Integer> ele : map.entrySet()){\\n            if(ele.getValue()>=maxCount){\\n                ans = ele.getKey();\\n                maxCount = ele.getValue();\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Khushboo2525",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>v\\n        \\n        \\n        (n);\\n        map<int,int>f;\\n        for(int i=1;i<=n;i++){\\n            \\n             f[nums[i]]++;\\n        }\\n        int maxii=0;\\n        long long ans=0;\\n        for(auto it :f){\\n            long long x=it.first;\\n            v.push_back(x);\\n            \\n        }\\n        return v[v.size()-1];\\n        \\n    }\\n};\\nwhy this is giving runtime error???"
                    },
                    {
                        "username": "shank9931",
                        "content": "no matching constructor for initialization of \\'vector<int>\\'\\n\\nwhy do I get this error?"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int count =0;\\n        int major = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(count==0){\\n                major = nums[i];\\n            }\\n            if(major == nums[i]){\\n                count++;\\n            }\\n            else{\\n                count -=1;\\n            }\\n\\n        }\\n        return major;\\n    }\\n};"
                    },
                    {
                        "username": "user3262F",
                        "content": "In this constraint what is the meaning of.\\nn == nums.length\\n\\nCould any one can explain?"
                    },
                    {
                        "username": "nguyej16",
                        "content": "n is equal to the number of elements within the nums array"
                    },
                    {
                        "username": "305057174a",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n       return max(nums,key=nums.count)\\n\\nwhy wrong?????"
                    },
                    {
                        "username": "tongalexhe",
                        "content": " class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int st = nums.size()/2;\\n        for(auto i : nums)\\n        {\\n            mp[i]++;\\n            if(mp[i]>st)\\n                return i;\\n        }\\n        return 0;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1722357,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "My Two ways to solve this problem:\n1) O(1) space ......sort the given array and check count of each element using loop, if its greater than n/2, break loop and return its value, else keep on checking.\n\n\n2) this will take O(n) space... Use unordered map. (4 line code)\n// unordered_map<int,int>m;\n        // for(auto a:nums)m[a]++;               \n        // for(auto a:m)if(a.second>n) return a.first;\n        // return -1;\n"
                    },
                    {
                        "username": "yash_eth",
                        "content": "2 line easy....\\n1. sort the array.\\n2. return the middle element.\\ndone\\n\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        Arrays.sort(nums);\\n\\n        return nums[(nums.length-1)/2];\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "Hello everyone, do I understand the increment here as a frequency count?\\n\\n```\\nfor(const auto &i:nums)\\n           map[i]++;\\n```"
                    },
                    {
                        "username": "ravi3018",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(Integer ele:nums){\\n            map.put(ele,map.getOrDefault(ele,0)+1);\\n        }\\n        int maxCount=0;\\n        int ans = 0;\\n        for(Map.Entry<Integer,Integer> ele : map.entrySet()){\\n            if(ele.getValue()>=maxCount){\\n                ans = ele.getKey();\\n                maxCount = ele.getValue();\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Khushboo2525",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>v\\n        \\n        \\n        (n);\\n        map<int,int>f;\\n        for(int i=1;i<=n;i++){\\n            \\n             f[nums[i]]++;\\n        }\\n        int maxii=0;\\n        long long ans=0;\\n        for(auto it :f){\\n            long long x=it.first;\\n            v.push_back(x);\\n            \\n        }\\n        return v[v.size()-1];\\n        \\n    }\\n};\\nwhy this is giving runtime error???"
                    },
                    {
                        "username": "shank9931",
                        "content": "no matching constructor for initialization of \\'vector<int>\\'\\n\\nwhy do I get this error?"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int count =0;\\n        int major = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(count==0){\\n                major = nums[i];\\n            }\\n            if(major == nums[i]){\\n                count++;\\n            }\\n            else{\\n                count -=1;\\n            }\\n\\n        }\\n        return major;\\n    }\\n};"
                    },
                    {
                        "username": "user3262F",
                        "content": "In this constraint what is the meaning of.\\nn == nums.length\\n\\nCould any one can explain?"
                    },
                    {
                        "username": "nguyej16",
                        "content": "n is equal to the number of elements within the nums array"
                    },
                    {
                        "username": "305057174a",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n       return max(nums,key=nums.count)\\n\\nwhy wrong?????"
                    },
                    {
                        "username": "tongalexhe",
                        "content": " class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int st = nums.size()/2;\\n        for(auto i : nums)\\n        {\\n            mp[i]++;\\n            if(mp[i]>st)\\n                return i;\\n        }\\n        return 0;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1716461,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "My Two ways to solve this problem:\n1) O(1) space ......sort the given array and check count of each element using loop, if its greater than n/2, break loop and return its value, else keep on checking.\n\n\n2) this will take O(n) space... Use unordered map. (4 line code)\n// unordered_map<int,int>m;\n        // for(auto a:nums)m[a]++;               \n        // for(auto a:m)if(a.second>n) return a.first;\n        // return -1;\n"
                    },
                    {
                        "username": "yash_eth",
                        "content": "2 line easy....\\n1. sort the array.\\n2. return the middle element.\\ndone\\n\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        Arrays.sort(nums);\\n\\n        return nums[(nums.length-1)/2];\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "Hello everyone, do I understand the increment here as a frequency count?\\n\\n```\\nfor(const auto &i:nums)\\n           map[i]++;\\n```"
                    },
                    {
                        "username": "ravi3018",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(Integer ele:nums){\\n            map.put(ele,map.getOrDefault(ele,0)+1);\\n        }\\n        int maxCount=0;\\n        int ans = 0;\\n        for(Map.Entry<Integer,Integer> ele : map.entrySet()){\\n            if(ele.getValue()>=maxCount){\\n                ans = ele.getKey();\\n                maxCount = ele.getValue();\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Khushboo2525",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>v\\n        \\n        \\n        (n);\\n        map<int,int>f;\\n        for(int i=1;i<=n;i++){\\n            \\n             f[nums[i]]++;\\n        }\\n        int maxii=0;\\n        long long ans=0;\\n        for(auto it :f){\\n            long long x=it.first;\\n            v.push_back(x);\\n            \\n        }\\n        return v[v.size()-1];\\n        \\n    }\\n};\\nwhy this is giving runtime error???"
                    },
                    {
                        "username": "shank9931",
                        "content": "no matching constructor for initialization of \\'vector<int>\\'\\n\\nwhy do I get this error?"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int count =0;\\n        int major = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(count==0){\\n                major = nums[i];\\n            }\\n            if(major == nums[i]){\\n                count++;\\n            }\\n            else{\\n                count -=1;\\n            }\\n\\n        }\\n        return major;\\n    }\\n};"
                    },
                    {
                        "username": "user3262F",
                        "content": "In this constraint what is the meaning of.\\nn == nums.length\\n\\nCould any one can explain?"
                    },
                    {
                        "username": "nguyej16",
                        "content": "n is equal to the number of elements within the nums array"
                    },
                    {
                        "username": "305057174a",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n       return max(nums,key=nums.count)\\n\\nwhy wrong?????"
                    },
                    {
                        "username": "tongalexhe",
                        "content": " class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int st = nums.size()/2;\\n        for(auto i : nums)\\n        {\\n            mp[i]++;\\n            if(mp[i]>st)\\n                return i;\\n        }\\n        return 0;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1714675,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "My Two ways to solve this problem:\n1) O(1) space ......sort the given array and check count of each element using loop, if its greater than n/2, break loop and return its value, else keep on checking.\n\n\n2) this will take O(n) space... Use unordered map. (4 line code)\n// unordered_map<int,int>m;\n        // for(auto a:nums)m[a]++;               \n        // for(auto a:m)if(a.second>n) return a.first;\n        // return -1;\n"
                    },
                    {
                        "username": "yash_eth",
                        "content": "2 line easy....\\n1. sort the array.\\n2. return the middle element.\\ndone\\n\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        Arrays.sort(nums);\\n\\n        return nums[(nums.length-1)/2];\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "Hello everyone, do I understand the increment here as a frequency count?\\n\\n```\\nfor(const auto &i:nums)\\n           map[i]++;\\n```"
                    },
                    {
                        "username": "ravi3018",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(Integer ele:nums){\\n            map.put(ele,map.getOrDefault(ele,0)+1);\\n        }\\n        int maxCount=0;\\n        int ans = 0;\\n        for(Map.Entry<Integer,Integer> ele : map.entrySet()){\\n            if(ele.getValue()>=maxCount){\\n                ans = ele.getKey();\\n                maxCount = ele.getValue();\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Khushboo2525",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>v\\n        \\n        \\n        (n);\\n        map<int,int>f;\\n        for(int i=1;i<=n;i++){\\n            \\n             f[nums[i]]++;\\n        }\\n        int maxii=0;\\n        long long ans=0;\\n        for(auto it :f){\\n            long long x=it.first;\\n            v.push_back(x);\\n            \\n        }\\n        return v[v.size()-1];\\n        \\n    }\\n};\\nwhy this is giving runtime error???"
                    },
                    {
                        "username": "shank9931",
                        "content": "no matching constructor for initialization of \\'vector<int>\\'\\n\\nwhy do I get this error?"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int count =0;\\n        int major = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(count==0){\\n                major = nums[i];\\n            }\\n            if(major == nums[i]){\\n                count++;\\n            }\\n            else{\\n                count -=1;\\n            }\\n\\n        }\\n        return major;\\n    }\\n};"
                    },
                    {
                        "username": "user3262F",
                        "content": "In this constraint what is the meaning of.\\nn == nums.length\\n\\nCould any one can explain?"
                    },
                    {
                        "username": "nguyej16",
                        "content": "n is equal to the number of elements within the nums array"
                    },
                    {
                        "username": "305057174a",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n       return max(nums,key=nums.count)\\n\\nwhy wrong?????"
                    },
                    {
                        "username": "tongalexhe",
                        "content": " class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int st = nums.size()/2;\\n        for(auto i : nums)\\n        {\\n            mp[i]++;\\n            if(mp[i]>st)\\n                return i;\\n        }\\n        return 0;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1713730,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "My Two ways to solve this problem:\n1) O(1) space ......sort the given array and check count of each element using loop, if its greater than n/2, break loop and return its value, else keep on checking.\n\n\n2) this will take O(n) space... Use unordered map. (4 line code)\n// unordered_map<int,int>m;\n        // for(auto a:nums)m[a]++;               \n        // for(auto a:m)if(a.second>n) return a.first;\n        // return -1;\n"
                    },
                    {
                        "username": "yash_eth",
                        "content": "2 line easy....\\n1. sort the array.\\n2. return the middle element.\\ndone\\n\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        Arrays.sort(nums);\\n\\n        return nums[(nums.length-1)/2];\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "Hello everyone, do I understand the increment here as a frequency count?\\n\\n```\\nfor(const auto &i:nums)\\n           map[i]++;\\n```"
                    },
                    {
                        "username": "ravi3018",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(Integer ele:nums){\\n            map.put(ele,map.getOrDefault(ele,0)+1);\\n        }\\n        int maxCount=0;\\n        int ans = 0;\\n        for(Map.Entry<Integer,Integer> ele : map.entrySet()){\\n            if(ele.getValue()>=maxCount){\\n                ans = ele.getKey();\\n                maxCount = ele.getValue();\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Khushboo2525",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>v\\n        \\n        \\n        (n);\\n        map<int,int>f;\\n        for(int i=1;i<=n;i++){\\n            \\n             f[nums[i]]++;\\n        }\\n        int maxii=0;\\n        long long ans=0;\\n        for(auto it :f){\\n            long long x=it.first;\\n            v.push_back(x);\\n            \\n        }\\n        return v[v.size()-1];\\n        \\n    }\\n};\\nwhy this is giving runtime error???"
                    },
                    {
                        "username": "shank9931",
                        "content": "no matching constructor for initialization of \\'vector<int>\\'\\n\\nwhy do I get this error?"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int count =0;\\n        int major = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(count==0){\\n                major = nums[i];\\n            }\\n            if(major == nums[i]){\\n                count++;\\n            }\\n            else{\\n                count -=1;\\n            }\\n\\n        }\\n        return major;\\n    }\\n};"
                    },
                    {
                        "username": "user3262F",
                        "content": "In this constraint what is the meaning of.\\nn == nums.length\\n\\nCould any one can explain?"
                    },
                    {
                        "username": "nguyej16",
                        "content": "n is equal to the number of elements within the nums array"
                    },
                    {
                        "username": "305057174a",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n       return max(nums,key=nums.count)\\n\\nwhy wrong?????"
                    },
                    {
                        "username": "tongalexhe",
                        "content": " class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int st = nums.size()/2;\\n        for(auto i : nums)\\n        {\\n            mp[i]++;\\n            if(mp[i]>st)\\n                return i;\\n        }\\n        return 0;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1711857,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "My Two ways to solve this problem:\n1) O(1) space ......sort the given array and check count of each element using loop, if its greater than n/2, break loop and return its value, else keep on checking.\n\n\n2) this will take O(n) space... Use unordered map. (4 line code)\n// unordered_map<int,int>m;\n        // for(auto a:nums)m[a]++;               \n        // for(auto a:m)if(a.second>n) return a.first;\n        // return -1;\n"
                    },
                    {
                        "username": "yash_eth",
                        "content": "2 line easy....\\n1. sort the array.\\n2. return the middle element.\\ndone\\n\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        Arrays.sort(nums);\\n\\n        return nums[(nums.length-1)/2];\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "Hello everyone, do I understand the increment here as a frequency count?\\n\\n```\\nfor(const auto &i:nums)\\n           map[i]++;\\n```"
                    },
                    {
                        "username": "ravi3018",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(Integer ele:nums){\\n            map.put(ele,map.getOrDefault(ele,0)+1);\\n        }\\n        int maxCount=0;\\n        int ans = 0;\\n        for(Map.Entry<Integer,Integer> ele : map.entrySet()){\\n            if(ele.getValue()>=maxCount){\\n                ans = ele.getKey();\\n                maxCount = ele.getValue();\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Khushboo2525",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>v\\n        \\n        \\n        (n);\\n        map<int,int>f;\\n        for(int i=1;i<=n;i++){\\n            \\n             f[nums[i]]++;\\n        }\\n        int maxii=0;\\n        long long ans=0;\\n        for(auto it :f){\\n            long long x=it.first;\\n            v.push_back(x);\\n            \\n        }\\n        return v[v.size()-1];\\n        \\n    }\\n};\\nwhy this is giving runtime error???"
                    },
                    {
                        "username": "shank9931",
                        "content": "no matching constructor for initialization of \\'vector<int>\\'\\n\\nwhy do I get this error?"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int count =0;\\n        int major = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(count==0){\\n                major = nums[i];\\n            }\\n            if(major == nums[i]){\\n                count++;\\n            }\\n            else{\\n                count -=1;\\n            }\\n\\n        }\\n        return major;\\n    }\\n};"
                    },
                    {
                        "username": "user3262F",
                        "content": "In this constraint what is the meaning of.\\nn == nums.length\\n\\nCould any one can explain?"
                    },
                    {
                        "username": "nguyej16",
                        "content": "n is equal to the number of elements within the nums array"
                    },
                    {
                        "username": "305057174a",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n       return max(nums,key=nums.count)\\n\\nwhy wrong?????"
                    },
                    {
                        "username": "tongalexhe",
                        "content": " class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int st = nums.size()/2;\\n        for(auto i : nums)\\n        {\\n            mp[i]++;\\n            if(mp[i]>st)\\n                return i;\\n        }\\n        return 0;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1711347,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "My Two ways to solve this problem:\n1) O(1) space ......sort the given array and check count of each element using loop, if its greater than n/2, break loop and return its value, else keep on checking.\n\n\n2) this will take O(n) space... Use unordered map. (4 line code)\n// unordered_map<int,int>m;\n        // for(auto a:nums)m[a]++;               \n        // for(auto a:m)if(a.second>n) return a.first;\n        // return -1;\n"
                    },
                    {
                        "username": "yash_eth",
                        "content": "2 line easy....\\n1. sort the array.\\n2. return the middle element.\\ndone\\n\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        Arrays.sort(nums);\\n\\n        return nums[(nums.length-1)/2];\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "Hello everyone, do I understand the increment here as a frequency count?\\n\\n```\\nfor(const auto &i:nums)\\n           map[i]++;\\n```"
                    },
                    {
                        "username": "ravi3018",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(Integer ele:nums){\\n            map.put(ele,map.getOrDefault(ele,0)+1);\\n        }\\n        int maxCount=0;\\n        int ans = 0;\\n        for(Map.Entry<Integer,Integer> ele : map.entrySet()){\\n            if(ele.getValue()>=maxCount){\\n                ans = ele.getKey();\\n                maxCount = ele.getValue();\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Khushboo2525",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>v\\n        \\n        \\n        (n);\\n        map<int,int>f;\\n        for(int i=1;i<=n;i++){\\n            \\n             f[nums[i]]++;\\n        }\\n        int maxii=0;\\n        long long ans=0;\\n        for(auto it :f){\\n            long long x=it.first;\\n            v.push_back(x);\\n            \\n        }\\n        return v[v.size()-1];\\n        \\n    }\\n};\\nwhy this is giving runtime error???"
                    },
                    {
                        "username": "shank9931",
                        "content": "no matching constructor for initialization of \\'vector<int>\\'\\n\\nwhy do I get this error?"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int count =0;\\n        int major = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(count==0){\\n                major = nums[i];\\n            }\\n            if(major == nums[i]){\\n                count++;\\n            }\\n            else{\\n                count -=1;\\n            }\\n\\n        }\\n        return major;\\n    }\\n};"
                    },
                    {
                        "username": "user3262F",
                        "content": "In this constraint what is the meaning of.\\nn == nums.length\\n\\nCould any one can explain?"
                    },
                    {
                        "username": "nguyej16",
                        "content": "n is equal to the number of elements within the nums array"
                    },
                    {
                        "username": "305057174a",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n       return max(nums,key=nums.count)\\n\\nwhy wrong?????"
                    },
                    {
                        "username": "tongalexhe",
                        "content": " class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int st = nums.size()/2;\\n        for(auto i : nums)\\n        {\\n            mp[i]++;\\n            if(mp[i]>st)\\n                return i;\\n        }\\n        return 0;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1709711,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "My Two ways to solve this problem:\n1) O(1) space ......sort the given array and check count of each element using loop, if its greater than n/2, break loop and return its value, else keep on checking.\n\n\n2) this will take O(n) space... Use unordered map. (4 line code)\n// unordered_map<int,int>m;\n        // for(auto a:nums)m[a]++;               \n        // for(auto a:m)if(a.second>n) return a.first;\n        // return -1;\n"
                    },
                    {
                        "username": "yash_eth",
                        "content": "2 line easy....\\n1. sort the array.\\n2. return the middle element.\\ndone\\n\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        Arrays.sort(nums);\\n\\n        return nums[(nums.length-1)/2];\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "Hello everyone, do I understand the increment here as a frequency count?\\n\\n```\\nfor(const auto &i:nums)\\n           map[i]++;\\n```"
                    },
                    {
                        "username": "ravi3018",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(Integer ele:nums){\\n            map.put(ele,map.getOrDefault(ele,0)+1);\\n        }\\n        int maxCount=0;\\n        int ans = 0;\\n        for(Map.Entry<Integer,Integer> ele : map.entrySet()){\\n            if(ele.getValue()>=maxCount){\\n                ans = ele.getKey();\\n                maxCount = ele.getValue();\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Khushboo2525",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>v\\n        \\n        \\n        (n);\\n        map<int,int>f;\\n        for(int i=1;i<=n;i++){\\n            \\n             f[nums[i]]++;\\n        }\\n        int maxii=0;\\n        long long ans=0;\\n        for(auto it :f){\\n            long long x=it.first;\\n            v.push_back(x);\\n            \\n        }\\n        return v[v.size()-1];\\n        \\n    }\\n};\\nwhy this is giving runtime error???"
                    },
                    {
                        "username": "shank9931",
                        "content": "no matching constructor for initialization of \\'vector<int>\\'\\n\\nwhy do I get this error?"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int count =0;\\n        int major = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(count==0){\\n                major = nums[i];\\n            }\\n            if(major == nums[i]){\\n                count++;\\n            }\\n            else{\\n                count -=1;\\n            }\\n\\n        }\\n        return major;\\n    }\\n};"
                    },
                    {
                        "username": "user3262F",
                        "content": "In this constraint what is the meaning of.\\nn == nums.length\\n\\nCould any one can explain?"
                    },
                    {
                        "username": "nguyej16",
                        "content": "n is equal to the number of elements within the nums array"
                    },
                    {
                        "username": "305057174a",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n       return max(nums,key=nums.count)\\n\\nwhy wrong?????"
                    },
                    {
                        "username": "tongalexhe",
                        "content": " class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int st = nums.size()/2;\\n        for(auto i : nums)\\n        {\\n            mp[i]++;\\n            if(mp[i]>st)\\n                return i;\\n        }\\n        return 0;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1708811,
                "content": [
                    {
                        "username": "stuartYoung_",
                        "content": "My Two ways to solve this problem:\n1) O(1) space ......sort the given array and check count of each element using loop, if its greater than n/2, break loop and return its value, else keep on checking.\n\n\n2) this will take O(n) space... Use unordered map. (4 line code)\n// unordered_map<int,int>m;\n        // for(auto a:nums)m[a]++;               \n        // for(auto a:m)if(a.second>n) return a.first;\n        // return -1;\n"
                    },
                    {
                        "username": "yash_eth",
                        "content": "2 line easy....\\n1. sort the array.\\n2. return the middle element.\\ndone\\n\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n\\n        Arrays.sort(nums);\\n\\n        return nums[(nums.length-1)/2];\\n        \\n    }\\n}"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "Hello everyone, do I understand the increment here as a frequency count?\\n\\n```\\nfor(const auto &i:nums)\\n           map[i]++;\\n```"
                    },
                    {
                        "username": "ravi3018",
                        "content": "class Solution {\\n    public int majorityElement(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(Integer ele:nums){\\n            map.put(ele,map.getOrDefault(ele,0)+1);\\n        }\\n        int maxCount=0;\\n        int ans = 0;\\n        for(Map.Entry<Integer,Integer> ele : map.entrySet()){\\n            if(ele.getValue()>=maxCount){\\n                ans = ele.getKey();\\n                maxCount = ele.getValue();\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Khushboo2525",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>v\\n        \\n        \\n        (n);\\n        map<int,int>f;\\n        for(int i=1;i<=n;i++){\\n            \\n             f[nums[i]]++;\\n        }\\n        int maxii=0;\\n        long long ans=0;\\n        for(auto it :f){\\n            long long x=it.first;\\n            v.push_back(x);\\n            \\n        }\\n        return v[v.size()-1];\\n        \\n    }\\n};\\nwhy this is giving runtime error???"
                    },
                    {
                        "username": "shank9931",
                        "content": "no matching constructor for initialization of \\'vector<int>\\'\\n\\nwhy do I get this error?"
                    },
                    {
                        "username": "kamiya_18",
                        "content": "class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int count =0;\\n        int major = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(count==0){\\n                major = nums[i];\\n            }\\n            if(major == nums[i]){\\n                count++;\\n            }\\n            else{\\n                count -=1;\\n            }\\n\\n        }\\n        return major;\\n    }\\n};"
                    },
                    {
                        "username": "user3262F",
                        "content": "In this constraint what is the meaning of.\\nn == nums.length\\n\\nCould any one can explain?"
                    },
                    {
                        "username": "nguyej16",
                        "content": "n is equal to the number of elements within the nums array"
                    },
                    {
                        "username": "305057174a",
                        "content": "class Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n       return max(nums,key=nums.count)\\n\\nwhy wrong?????"
                    },
                    {
                        "username": "tongalexhe",
                        "content": " class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int st = nums.size()/2;\\n        for(auto i : nums)\\n        {\\n            mp[i]++;\\n            if(mp[i]>st)\\n                return i;\\n        }\\n        return 0;\\n    }\\n};"
                    }
                ]
            }
        ]
    }
]